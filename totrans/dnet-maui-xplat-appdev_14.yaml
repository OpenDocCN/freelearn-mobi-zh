- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Developing Unit Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发单元测试
- en: Testing plays a crucial role in ensuring software quality in contemporary software
    development. Various types of testing are involved in the software development
    lifecycle, including unit testing, integration testing, and system testing. Unit
    testing is employed to examine software modules or components within an isolated
    environment and is typically carried out by developers. With a well-devised unit
    test strategy, programming issues can be detected at the earliest stage of the
    software development lifecycle, rendering unit testing the most efficient and
    cost-effective approach to guaranteeing software quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在当代软件开发中确保软件质量方面发挥着至关重要的作用。软件开发生命周期中涉及多种类型的测试，包括单元测试、集成测试和系统测试。单元测试用于在隔离环境中检查软件模块或组件，通常由开发人员执行。通过一个精心设计的单元测试策略，可以在软件开发生命周期的早期阶段发现编程问题，使单元测试成为保证软件质量最有效和最经济的途径。
- en: In .NET MAUI app development, we can utilize existing unit test frameworks or
    libraries present in the .NET ecosystem. By employing a test framework or library,
    we can expedite unit test development. An effective test framework is generally
    designed for seamless integration with a **continuous integration** (**CI**) and
    **continuous deployment** (**CD**) environment. In this chapter, we will demonstrate
    how to set up unit testing and execute unit test cases as part of the .NET MAUI
    app development lifecycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 应用程序开发中，我们可以利用 .NET 生态系统中的现有单元测试框架或库。通过使用测试框架或库，我们可以加快单元测试的开发。一个有效的测试框架通常是设计用于与
    **持续集成** (**CI**) 和 **持续部署** (**CD**) 环境无缝集成的。在本章中，我们将演示如何设置单元测试并在 .NET MAUI 应用程序开发生命周期中执行单元测试用例。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Unit testing in .NET
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 中的单元测试
- en: Mock .NET MAUI components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟 .NET MAUI 组件
- en: Razor component testing using bUnit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bUnit 进行 Razor 组件测试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To test and debug the source code from this chapter, you need to have a .NET
    8 environment set up. You can install .NET 8 by following the instructions provided
    at the Microsoft link below on Windows, macOS, or Linux: [https://dotnet.microsoft.com/en-us/download/dotnet/8.0](https://dotnet.microsoft.com/en-us/download/dotnet/8.0).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章的源代码，您需要设置 .NET 8 环境。您可以通过以下 Microsoft 链接中的说明在 Windows、macOS 或 Linux
    上安装 .NET 8：[https://dotnet.microsoft.com/en-us/download/dotnet/8.0](https://dotnet.microsoft.com/en-us/download/dotnet/8.0)。
- en: Unit tests can be executed from the command line using the `dotnet` command,
    or via the Test Explorer in Visual Studio if you’re using Windows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以使用 `dotnet` 命令从命令行执行，或者如果您使用的是 Windows，可以通过 Visual Studio 中的测试资源管理器执行。
- en: To set up Visual Studio 2022, please refer to the *Development environment setup*
    section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 Visual Studio 2022，请参阅 *第一章*，*使用 .NET MAUI 入门* 中的 *开发环境设置* 部分，以获取详细信息。
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter11](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/ae2e0ad9324ff4e05b1508090fe3cda77ad47ccf).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter11](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/ae2e0ad9324ff4e05b1508090fe3cda77ad47ccf)。
- en: 'To check out the source code of this chapter, we can use the below command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the section
    *Managing the source code in this book* in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书源代码的信息，请参阅 *第二章*，*构建我们的第一个 .NET MAUI 应用程序* 中的 *管理本书中的源代码* 部分。
- en: Unit testing in .NET
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 中的单元测试
- en: 'To develop unit test cases, it is common to utilize a unit test framework to
    enhance efficiency. There are several unit test frameworks available in the .NET
    environment, which are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发单元测试用例，通常使用单元测试框架来提高效率。在 .NET 环境中，有几种单元测试框架可供选择，如下所示：
- en: '**Microsoft Test Framework** (**MSTest**) comes bundled with Visual Studio.
    The initial version of MSTest (V1) was not an open-source product, and it first
    appeared alongside the release of Visual Studio 2005\. For more information about
    MSTest (V1), please refer to the book Microsoft Visual Studio 2005 Unleashed by
    Lars Powers and Mike Snell. Later, Microsoft made the MSTest (V2) open-source,
    hosting it on GitHub, with the first release becoming available around 2017.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft 测试框架**（**MSTest**）与 Visual Studio 一起捆绑提供。MSTest（V1）的初始版本不是一个开源产品，它首次与
    Visual Studio 2005 的发布一同出现。有关 MSTest（V1）的更多信息，请参阅 Lars Powers 和 Mike Snell 合著的《Microsoft
    Visual Studio 2005 Unleashed》一书。后来，Microsoft 将 MSTest（V2）开源，托管在 GitHub 上，首个版本大约在
    2017 年发布。'
- en: '**NUnit** is an open-source testing framework ported from JUnit. It was the
    inaugural unit test framework for .NET, with its earliest releases hosted on SourceForge
    in 2004\. For more information on version 2.0, please refer to the release notes
    in the *Further reading* section. The latest releases have since been moved to
    GitHub.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NUnit** 是一个从 JUnit 转移过来的开源测试框架。它是 .NET 的首个单元测试框架，其最早的版本于 2004 年在 SourceForge
    上发布。有关 2.0 版本的信息，请参阅“进一步阅读”部分的发布说明。最新的版本已经转移到 GitHub 上。'
- en: '**xUnit** is a modern and extensible framework developed by Jim Newkirk and
    Brad Wilson, the creators of NUnit. They made significant improvements to this
    new test framework compared to NUnit. To find out more about these enhancements,
    please refer to Jim’s blog, *Why Did we Build xUnit 1.0*? The first stable release
    of xUnit was available around 2015.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xUnit** 是由 NUnit 的创造者 Jim Newkirk 和 Brad Wilson 开发的一个现代且可扩展的框架。与 NUnit 相比，他们对这个新的测试框架进行了重大改进。要了解更多关于这些改进的信息，请参阅
    Jim 的博客，*Why Did we Build xUnit 1.0*？xUnit 的第一个稳定版本大约在 2015 年发布。'
- en: All of these frameworks are quite popular and can be selected according to the
    project’s requirements. In this chapter, we will utilize xUnit to develop unit
    test cases, as it is a more recent framework that offers numerous enhancements
    compared to NUnit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些框架都非常受欢迎，可以根据项目需求进行选择。在本章中，我们将使用 xUnit 来开发单元测试用例，因为它是一个更新的框架，与 NUnit 相比提供了许多增强功能。
- en: Regardless of the unit test framework you select, the process of developing
    unit tests is rather consistent. Even if you employ a different framework for
    your project, this chapter’s content remains applicable. Unit test cases are designed
    to run exclusively on cross-platform target frameworks instead of platform-specific
    ones. In this book, we utilize .NET 8.0; therefore, the target framework for unit
    testing is `net8.0`, as opposed to `net8.0-android` or `net8.0-ios`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个单元测试框架，开发单元测试的过程都非常一致。即使你在项目中使用不同的框架，本章的内容仍然适用。单元测试用例旨在仅在跨平台目标框架上运行，而不是在特定平台上的框架。在这本书中，我们使用
    .NET 8.0；因此，单元测试的目标框架是 `net8.0`，而不是 `net8.0-android` 或 `net8.0-ios`。
- en: 'In this chapter, we will first develop unit tests for the model layer, which
    is common to both XAML and Blazor. Subsequently, we will introduce unit test development
    for Blazor apps using bUnit. bUnit is a versatile testing library compatible with
    all three test frameworks: xUnit, NUnit, and MSTest.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先为模型层开发单元测试，该层对 XAML 和 Blazor 都适用。随后，我们将介绍使用 bUnit 为 Blazor 应用进行单元测试的开发。bUnit
    是一个兼容所有三个测试框架（xUnit、NUnit 和 MSTest）的多功能测试库。
- en: Setting up the unit test project
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置单元测试项目
- en: 'To gain some practical experience, let’s create a unit test project. We can
    create a xUnit project using either Visual Studio or the .NET command line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一些实践经验，让我们创建一个单元测试项目。我们可以使用 Visual Studio 或 .NET 命令行来创建 xUnit 项目：
- en: 'To start with Visual Studio, we can add a new project to our current solution,
    as shown in *Figure 11.1*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Visual Studio 开始，我们可以向当前解决方案添加一个新项目，如图 *图 11.1* 所示：
- en: '![Figure 11.1 – Creating a xUnit project](img/B21554_11_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 创建 xUnit 项目](img/B21554_11_01.png)'
- en: Figure 11.1 – Creating an xUnit project using Visual Studio
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 使用 Visual Studio 创建 xUnit 项目
- en: To begin, type `xunit` into the search box and select **xUnit Test Project**
    for C#.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在搜索框中输入 `xunit` 并选择 C# 的 **xUnit 测试项目**。
- en: On the following screen, name the project `PassXYZ.Vault.Tests` and click **Next**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，将项目命名为 `PassXYZ.Vault.Tests` 并点击 **下一步**。
- en: Subsequently, set the framework to .NET 8.0 and click **Create**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，将框架设置为 .NET 8.0 并点击 **创建**。
- en: If you’re using Visual Studio Code, the first step is to install the .NET MAUI
    extension in your environment. Once the extension is installed, you can navigate
    through your project using Solution Explorer, akin to how you would in Visual
    Studio. Please be aware that the .NET MAUI extension is still in the preview stage
    as of March 2024.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Visual Studio Code，第一步是在你的环境中安装.NET MAUI扩展。一旦扩展安装完成，你就可以使用解决方案资源管理器导航你的项目，就像在Visual
    Studio中做的那样。请注意，截至2024年3月，.NET MAUI扩展仍处于预览阶段。
- en: 'To create an xUnit project, click the **+** button located in the solution.
    This action will reveal a list of project templates, as demonstrated below:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个xUnit项目，请点击位于解决方案中的**+**按钮。此操作将显示以下所示的项目模板列表：
- en: '![A screenshot of a computer  Description automatically generated](img/B21554_11_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21554_11_02.png)'
- en: Figure 11.1a – Creating an xUnit project using Visual Studio Code
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1a – 使用Visual Studio Code创建xUnit项目
- en: 'To create the project using a command line, we should first create the folder
    and then utilize a .NET command to establish the project, as demonstrated below:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行创建项目，我们首先应创建文件夹，然后使用.NET命令来建立项目，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After creating the project, we can utilize the `dotnet test` command to run
    the test cases. The default test case in the template will be executed, and we
    will proceed to add more test cases to this project. Our test targets incorporate
    components from both the `PassXYZ.Vault` and `PassXYZ.BlazorUI` projects, hence
    requiring us to include these two projects as reference projects. The target framework
    of `PassXYZ.BlazorUI` is `net8.0`, allowing us to add it directly. However, as
    the target frameworks of `PassXYZ.Vault` are platform-specific, we must implement
    some modifications before incorporating them as references in `PassXYZ.Vault.Tests`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，我们可以使用`dotnet test`命令来运行测试用例。模板中的默认测试用例将被执行，然后我们将继续向该项目添加更多测试用例。我们的测试目标包含来自`PassXYZ.Vault`和`PassXYZ.BlazorUI`项目的组件，因此我们需要将这些两个项目作为引用项目包含在内。`PassXYZ.BlazorUI`的目标框架是`net8.0`，这允许我们直接添加它。然而，由于`PassXYZ.Vault`的目标框架是平台特定的，我们必须在将其作为引用包含到`PassXYZ.Vault.Tests`之前进行一些修改。
- en: 'As we need to build the unit test against the target framework `net8.0`, it
    is necessary to modify the `PassXYZ.Vault.csproj` file to include `net8.0` as
    one of the target frameworks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要针对目标框架`net8.0`构建单元测试，因此有必要修改`PassXYZ.Vault.csproj`文件，将`net8.0`作为目标框架之一包含在内：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When building the `PassXYZ.Vault` project on supported platforms, we anticipate
    an executable, as it is an app. However, when building `PassXYZ.Vault` for the
    `net8.0` target framework, we aim to test it. `PassXYZ.Vault` should be generated
    as a library so that the test framework can utilize it to run test cases. In this
    instance, we expect to build a file with a `.dll` extension instead of `.exe`,
    which necessitates the following modification:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的平台构建`PassXYZ.Vault`项目时，我们预期会生成一个可执行文件，因为它是一个应用程序。然而，当为`net8.0`目标框架构建`PassXYZ.Vault`时，我们的目标是进行测试。`PassXYZ.Vault`应生成为一个库，以便测试框架可以利用它来运行测试用例。在这种情况下，我们期望构建一个具有`.dll`扩展名的文件，而不是`.exe`，这需要以下修改：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding build setup, a condition has been added to verify the target
    framework for the output type. If the target framework is not `net8.0`, the build
    output will be generated as an executable. Conversely, if the target framework
    is set to `net8.0`, a library will be generated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的构建设置中，已添加一个条件来验证输出类型的目标框架。如果目标框架不是`net8.0`，则构建输出将生成一个可执行文件。相反，如果目标框架设置为`net8.0`，则将生成一个库。
- en: 'After making these changes, we can add reference projects to `PassXYZ.Vault.Tests`
    by either right-clicking on the solution node and selecting **Add** -> **Project
    Reference**, or by editing the project file for `PassXYZ.Vault.Tests` to include
    these lines:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，我们可以通过右键单击解决方案节点并选择**添加** -> **项目引用**，或者通过编辑`PassXYZ.Vault.Tests`的项目文件来包含这些行，将引用项目添加到`PassXYZ.Vault.Tests`中：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to test the MAUI project, it is also necessary to add the following
    configuration to the `PassXYZ.Vault.Tests` project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试MAUI项目，还需要将以下配置添加到`PassXYZ.Vault.Tests`项目中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have now successfully set up the xUnit project. Next, let’s proceed to add
    our test cases.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功设置了xUnit项目。接下来，让我们继续添加我们的测试用例。
- en: Developing test cases for the model
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为模型开发测试用例
- en: We use xUnit as a unit testing tool for our app. It provides a comprehensive
    and efficient way to run tests sequentially in isolation from each other, supporting
    both desktop and mobile applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用xUnit作为我们应用的单元测试工具。它提供了一种全面且高效的方式来顺序运行测试，彼此之间相互独立，支持桌面和移动应用。
- en: Two fundamental concepts in xUnit are `Fact` and `Theory`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit中的两个基本概念是 `Fact` 和 `Theory`。
- en: '`Fact` in xUnit refers to a parameterless test method that confirms the correctness
    of certain conditions in code. It states that something should always be true.
    A “fact” test always runs every time the test suite runs as they are supposed
    to be invariant conditions, regardless of the data state at the execution time.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在xUnit中，`Fact` 指的是一个无参数的测试方法，用于确认代码中某些条件的正确性。它声明某事应该是始终正确的。一个“事实”测试在测试套件每次运行时都会运行，因为它们应该是不可变条件，无论执行时的数据状态如何。
- en: On the other hand, `Theory` allows parameterized tests to be conducted. It allows
    developers to run a single test method multiple times with different sets of data,
    reducing code redundancy while enhancing coverage. It is based on the idea that
    if the test method’s contract is true for a specific dataset, it should be true
    for all datasets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Theory` 允许进行参数化测试。它允许开发者使用不同的数据集多次运行单个测试方法，减少代码冗余，同时提高覆盖率。它基于这样一个想法：如果测试方法的合同对于特定的数据集是正确的，那么它应该对所有数据集都是正确的。
- en: We will begin by adding test cases to examine the model layer, as the test case
    setup for the model layer is identical in both the XAML and Blazor versions of
    our app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加测试用例来检查模型层，因为模型层的测试用例设置在XAML和Blazor版本的应用中是相同的。
- en: 'In the model layer, the primary implementation resides within the `PassXYZLib`
    library. For more information on the unit test cases at the model layer, please
    refer to the `PassXYZLib` source code: [https://github.com/shugaoye/PassXYZLib](https://github.com/shugaoye/PassXYZLib).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型层，主要实现位于 `PassXYZLib` 库中。有关模型层的单元测试的更多信息，请参阅 `PassXYZLib` 源代码：[https://github.com/shugaoye/PassXYZLib](https://github.com/shugaoye/PassXYZLib)。
- en: 'In our app, `IDataStore` is the interface used to export `PassXYZLib`. Therefore,
    let’s incorporate test cases to test this interface, `IDataStore`. To assess the
    `IDataStore` interface, we can establish a new test class, `DataStoreTest`, within
    the `PassXYZ.Vault.Tests` project. We can add a new test case by testing “the
    addition of an item” as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，`IDataStore` 是用于导出 `PassXYZLib` 的接口。因此，让我们在 `PassXYZ.Vault.Tests` 项目中创建一个新的测试类
    `DataStoreTest` 来测试这个接口，`IDataStore`。为了评估 `IDataStore` 接口，我们可以创建一个新的测试用例，如下测试“添加项目”：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'xUnit employs attributes to inform the framework about test case configurations.
    In this test case, we utilize the `[Fact]` attribute **(1)** to designate this
    method as a test case. To define a test case, we can follow a common pattern –
    `Arrange`, `Act`, and `Assert`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit使用属性来通知框架关于测试用例配置。在这个测试用例中，我们使用 `[Fact]` 属性 **(1)** 来指定这个方法为一个测试用例。为了定义一个测试用例，我们可以遵循一个常见的模式
    – `Arrange`、`Act` 和 `Assert`：
- en: '`Arrange` **(2)** – We will prepare all necessary setup for the test. To add
    an item, we need to initialize the `IDataStore` interface first, and then we will
    define a variable to hold the item type.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Arrange` **(2)** – 我们将为测试准备所有必要的设置。为了添加一个项目，我们首先需要初始化 `IDataStore` 接口，然后我们将定义一个变量来保存项目类型。'
- en: '`Act` **(3)** – We execute the methods that we want to test, which are `CreateNewItem`
    and `AddItemAsync`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Act` **(3)** – 我们执行我们想要测试的方法，这些方法是 `CreateNewItem` 和 `AddItemAsync`。'
- en: '`Assert` **(4)** – We check the result that we expected. In our case, we try
    to retrieve the new item using `item.Id`. After that, we check to ensure that
    the item ID retrieved is the same as what we expected.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert` **(4)** – 我们检查我们期望的结果。在我们的例子中，我们尝试使用 `item.Id` 来检索新项目。之后，我们检查确保检索到的项目ID与我们期望的相同。'
- en: As you may have noticed, we tested the `Entry` type in the previous test case.
    The `Entry` type is only one of the item types – we have many. To test all of
    them, we need to create many test cases. xUnit supports another test case type,
    `[Theory]`, which helps us to test different scenarios with one test case.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在上一个测试用例中测试了 `Entry` 类型。`Entry` 类型只是项目类型之一 – 我们有很多。为了测试所有这些类型，我们需要创建许多测试用例。xUnit支持另一种测试用例类型
    `[Theory]`，它帮助我们使用一个测试用例测试不同的场景。
- en: 'We can use the “delete an item” test case to demonstrate how to test different
    scenarios in one test case with the `[Theory]` attribute. In this test case, we
    can delete an item in different item types in one test case:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“删除项目”测试用例来演示如何使用 `[Theory]` 属性在一个测试用例中测试不同的场景。在这个测试用例中，我们可以在一个测试用例中删除不同项目类型的项目：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we create a test case using the `[Theory]` attribute, **(1)**, we can pass
    different item types using the `itemSubType` parameter. The value of the `itemSubType`
    argument is defined using the `[InlineData]` attribute, **(2)**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `[Theory]` 属性创建测试用例时，**（1）**，我们可以通过 `itemSubType` 参数传递不同的项目类型。`itemSubType`
    参数的值使用 `[InlineData]` 属性定义，**（2）**。
- en: To arrange test data, we create a new item using the `itemSubType` argument,
    **(3)**. Then, we execute the `DeleteItemAsync` method, **(4)**, which is the
    one that we want to test.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安排测试数据，我们使用 `itemSubType` 参数创建一个新的项目，**（3）**。然后，我们执行 `DeleteItemAsync` 方法，**（4）**，这是我们想要测试的方法。
- en: Finally, we check the return value, **(5)**. If the item is deleted successfully,
    the result is true. Otherwise, the result is false.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查返回值，**（5）**。如果项目成功删除，则结果为真。否则，结果为假。
- en: We have learned the process of creating a test case using the `[Fact]` attribute,
    as well as how to address different scenarios with the `[Theory]` attribute. In
    the next section, we will delve into further topics related to test case development.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用 `[Fact]` 属性创建测试用例的过程，以及如何使用 `[Theory]` 属性处理不同的场景。在下一节中，我们将深入探讨与测试用例开发相关的进一步主题。
- en: Sharing context between tests
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试之间共享上下文
- en: In our previous test cases, we created a new `IDataStore` instance for each
    test. Is it possible to share one `IDataStore` instance, instead of repeatedly
    creating the same instance for every test? By sharing the test setup among a group
    of test cases in xUnit, we can minimize duplication.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的测试用例中，我们为每个测试创建了一个新的 `IDataStore` 实例。是否有可能共享一个 `IDataStore` 实例，而不是为每个测试重复创建相同的实例？通过在
    xUnit 中将测试设置共享到一组测试用例中，我们可以最小化重复。
- en: 'There are three methods for sharing setup and cleanup code between tests in
    xUnit:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 xUnit 中，有三种方法可以在测试之间共享设置和清理代码：
- en: '**Constructor** and **Dispose**`:` We can use a class constructor to share
    the setup and cleanup code without sharing instances.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数** 和 **Dispose**：我们可以使用类构造函数来共享设置和清理代码，而不共享实例。'
- en: '**Class Fixture**`:` We can use a fixture to share object instances in a single
    class.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类固定器**：我们可以使用固定器在单个类中共享对象实例。'
- en: '**Collection Fixtures**`:` We can use collection fixtures to share object instances
    in multiple test classes.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合固定器**：我们可以使用集合固定器在多个测试类中共享对象实例。'
- en: Sharing using a constructor
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用构造函数进行共享
- en: 'To remove the duplicated setup code from the previous tests, we can move the
    creation of the `IDataStore` instance to the constructor of the `DataStoreTests`
    test class as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从之前的测试中移除重复的设置代码，我们可以将 `IDataStore` 实例的创建移动到 `DataStoreTests` 测试类的构造函数中，如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code, we added a private member variable, `datastore`, and created
    an instance of `IDataStore` in the constructor of `DataStoreTests`. We also added
    a debug output so we can monitor the creation of the `IDataStore` interface. Let
    us debug the execution of the `DataStoreTests` class so we can see the debug output
    here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们添加了一个私有成员变量 `datastore`，并在 `DataStoreTests` 的构造函数中创建了一个 `IDataStore`
    实例。我们还添加了调试输出，以便我们可以监控 `IDataStore` 接口的创建。让我们调试 `DataStoreTests` 类的执行，以便我们可以在这里看到调试输出：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see from the debug output that a `DataStoreTests` class is created for
    each test case. There is no difference whether we create the instance of `IDataStore`
    inside the test method or in the constructor. All the test cases are still isolated
    from each other. When we use the `[Theory]` attribute to test different scenarios
    with one method, each of them looks like a separate test case at runtime. To understand
    this better, we can use the `dotnet` command to list all the defined tests:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从调试输出中看到，为每个测试用例创建了一个 `DataStoreTests` 类。我们在测试方法内部或构造函数中创建 `IDataStore`
    实例没有区别。所有测试用例仍然彼此隔离。当我们使用 `[Theory]` 属性使用一个方法测试不同的场景时，每个场景在运行时都像是一个单独的测试用例。为了更好地理解这一点，我们可以使用
    `dotnet` 命令列出所有定义的测试：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that each parameter defined by the `[InlineData]` attribute is shown
    as a separate test case. They are all isolated test cases at runtime.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由 `[InlineData]` 属性定义的每个参数都显示为单独的测试用例。它们在运行时都是隔离的测试用例。
- en: After we list all the tests, we can selectively execute them using the `dotnet`
    command.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出所有测试后，我们可以使用 `dotnet` 命令选择性地执行它们。
- en: 'If we want to run all the tests in the `DataStoreTests` class, we can use this
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想运行 `DataStoreTests` 类中的所有测试，我们可以使用此命令：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to run `Add_Item` tests only, we can use this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想运行 `Add_Item` 测试，我们可以使用此命令：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see from the debug output, even though we created an instance of `IDataStore`
    in the constructor, the instance is re-created for each test. The instances created
    in the test class constructor won’t be shared across tests. Even though the effect
    is still the same, the code looks more concise.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从调试输出中可以看到的，尽管我们在构造函数中创建了一个 `IDataStore` 的实例，但每个测试都会重新创建该实例。在测试类构造函数中创建的实例不会在测试之间共享。尽管效果仍然相同，但代码看起来更简洁。
- en: However, in certain scenarios, we may want to share instances across multiple
    tests. To achieve this, we can utilize class fixtures. In the following section,
    we will examine these specific cases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些场景下，我们可能希望在不同测试之间共享实例。为了实现这一点，我们可以利用类固定器。在下一节中，我们将检查这些特定的情况。
- en: Sharing using class fixtures
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类固定器共享
- en: When utilizing a tool across all test cases, it can be more efficient to share
    the setup among them rather than creating the same one each time. Let’s use a
    logging function as an example to illustrate this approach.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当在所有测试案例中使用工具时，共享设置可能比每次都创建相同的设置更有效。让我们用一个日志函数作为例子来说明这种方法。
- en: To generate a test report, we aim to create a test log that monitors the execution
    of unit tests. The `Serilog` library is the one which can be used for this purpose.
    `Serilog` enables us to log messages to different channels. In order to use `Serilog`,
    we must first set it up and then clean it up after all the tests have been executed.
    In this scenario, we prefer to share a single instance of `Serilog` between all
    the tests instead of creating one for each test. This setup allows us to produce
    a consolidated log file for all the tests rather than generating multiple log
    files for each individual test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成测试报告，我们的目标是创建一个测试日志，用于监控单元测试的执行。`Serilog` 库是用于此目的的库。`Serilog` 允许我们将消息记录到不同的通道。为了使用
    `Serilog`，我们首先必须设置它，然后在所有测试执行完毕后清理它。在这种情况下，我们更倾向于在所有测试之间共享单个 `Serilog` 实例，而不是为每个测试创建一个。这种设置使我们能够为所有测试生成一个综合的日志文件，而不是为每个单独的测试生成多个日志文件。
- en: 'To incorporate `Serilog`, we need to add the `Serilog` package to the project.
    This can be accomplished by executing the following `dotnet` commands in the project’s
    `PassXYZ.Vault.Tests` folder:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成 `Serilog`，我们需要将 `Serilog` 包添加到项目中。这可以通过在项目的 `PassXYZ.Vault.Tests` 文件夹中执行以下
    `dotnet` 命令来完成：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Having added the `Serilog` libraries to the project, we can now create a class
    fixture, `SerilogFixture`, for demonstration purposes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `Serilog` 库添加到项目中后，我们现在可以创建一个用于演示目的的类固定器，`SerilogFixture`：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we want to use class fixtures, we can create them using the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用类固定器，我们可以按照以下步骤创建它们：
- en: We can create a new class as the fixture class and add the setup code to the
    constructor. Here, we created a fixture class, `SerilogFixture`, **(1)**, and
    initialized the `ILogger` interface, **(2)**, in the constructor.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的类作为固定器类，并将设置代码添加到构造函数中。在这里，我们创建了一个固定器类，`SerilogFixture` **(1**)，并在构造函数中初始化了
    `ILogger` 接口，**(2**)。
- en: Because we need to clean up the setup after the test case execution, we need
    to implement the `IDisposable` interface for the fixture class and put the cleanup
    code in the `Dispose` method. We implemented `IDisposable` in `SerilogFixture`
    and called the `Serilog` function, `Log.CloseAndFlush`, **(3)**, in the `Dispose`
    method.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们需要在测试用例执行后清理设置，我们需要为固定器类实现 `IDisposable` 接口，并将清理代码放在 `Dispose` 方法中。我们在 `SerilogFixture`
    中实现了 `IDisposable`，并在 `Dispose` 方法中调用了 `Serilog` 函数，`Log.CloseAndFlush` **(3**)。
- en: To use the fixture, the test case needs to implement the `IClassFixture<T>`
    interface. We implemented this in the `DataStoreTests` test class, **(4)**.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用固定器，测试用例需要实现 `IClassFixture<T>` 接口。我们在 `DataStoreTests` 测试类中实现了这一点，**(4**)。
- en: To access the fixture instance, we can add it as a constructor argument and
    it will be provided automatically. In the constructor of `DataStoreTests`, **(5)**,
    we assign the argument to the private member variable, `serilogFixture`, **(6)**.
    In test cases, we can access `Serilog` using this variable.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问固定件实例，我们可以将其作为构造函数参数添加，它将自动提供。在 `DataStoreTests` 的构造函数 **(5)** 中，我们将参数分配给私有成员变量
    `serilogFixture` **(6)**。在测试用例中，我们可以使用这个变量访问 `Serilog`。
- en: 'To verify this setup, we replaced all our debug output with `Serilog` `Debug`.
    After executing the tests in `DataStoreTests`, we can see the log messages here
    in the `xunit_log.txt` log file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证此设置，我们将所有调试输出替换为 `Serilog` 的 `Debug`。在执行 `DataStoreTests` 中的测试后，我们可以在 `xunit_log.txt`
    日志文件中看到这里的日志消息：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As anticipated, the `SerilogFixture` class is initialized only once, allowing
    its instance to be utilized in all tests within `DataStoreTests`. This is in contrast
    to the `IDataStore` interface, which is initialized for each individual test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`SerilogFixture` 类仅初始化一次，使其实例可以在 `DataStoreTests` 中的所有测试中使用。这与为每个单独的测试初始化的
    `IDataStore` 接口形成对比。
- en: Sharing using collection fixtures
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集合固定件的共享
- en: Utilizing class fixtures, as demonstrated in the previous section, allows us
    to share the test setup context within a single test class. However, there may
    be instances where we need to share the test setup across multiple test classes.
    In such cases, we can employ collection fixtures to achieve this.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，利用类固定件允许我们在单个测试类中共享测试设置上下文。然而，可能存在需要跨多个测试类共享测试设置的情况。在这种情况下，我们可以使用集合固定件来实现这一点。
- en: 'In the case of `Serilog`, we can utilize it across multiple test classes, allowing
    us to view all log messages in a single log file. To achieve a unified `Serilog`
    setup for all test classes, we can implement collection fixtures in our project.
    By employing collection fixtures, we can create two new classes, `SerilogFixture`
    and `SerilogCollection`, within the `PassXYZ.Vault.Tests` project, as demonstrated
    in *Listing 11.1*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Serilog` 的情况下，我们可以在多个测试类之间使用它，使我们能够在一个日志文件中查看所有日志消息。为了为所有测试类实现统一的 `Serilog`
    设置，我们可以在项目中实现集合固定件。通过使用集合固定件，我们可以在 `PassXYZ.Vault.Tests` 项目中创建两个新类，`SerilogFixture`
    和 `SerilogCollection`，如 *Listing 11.1* 所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11.1: `SerilogFixture.cs` ([https://epa.ms/SerilogFixture11-1](https://epa.ms/SerilogFixture11-1))'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 11.1: `SerilogFixture.cs` ([https://epa.ms/SerilogFixture11-1](https://epa.ms/SerilogFixture11-1))'
- en: 'To implement collection fixtures, we can follow the steps outlined below:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现集合固定件，我们可以遵循以下步骤：
- en: Create a new class file, `SerilogFixture.cs`, that houses both the `SerilogFixture`
    and `SerilogCollection` classes.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的类文件，`SerilogFixture.cs`，其中包含 `SerilogFixture` 和 `SerilogCollection` 类。
- en: Decorate the collection definition class, `SerilogCollection`, with the `[CollectionDefinition]`
    attribute **(1)** and assign it a unique name to help identify the test collection.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[CollectionDefinition]` 属性 **(1)** 装饰集合定义类 `SerilogCollection` 并为其分配一个唯一名称，以帮助识别测试集合。
- en: Ensure that the collection definition class, `SerilogCollection`, implements
    the `ICollectionFixture<T>` interface **(2)**.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保集合定义类 `SerilogCollection` 实现了 `ICollectionFixture<T>` 接口 **(2)**。
- en: 'To utilize a collection fixture, we can implement the following modifications
    to our test classes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用集合固定件，我们可以对我们的测试类进行以下修改：
- en: We can attach the `[Collection]` attribute to all test classes that will be
    incorporated into the collection. We designate `Serilog collection` as the name
    for the test collection definition within the attribute. In our case, as displayed
    in *Listing 11.2*, we append a `[Collection("Serilog collection")]` attribute
    **(1)** to the `DataStoreTests` class.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将 `[Collection]` 属性附加到所有将被包含在集合中的测试类。我们在属性中将测试集合定义命名为 `Serilog collection`。在我们的例子中，如
    *Listing 11.2* 所示，我们向 `DataStoreTests` 类添加了 `[Collection("Serilog collection")]`
    属性 **(1)**。
- en: To access the fixture instance, we can follow the same approach as in the previous
    section with class fixtures by including it as a constructor argument. It will
    then be provided automatically. In the `DataStoreTests` constructor, we assign
    a `fixture` argument to the `serilogFixture` variable **(2)**.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问固定件实例，我们可以遵循与上一节中类固定件相同的做法，将其包括为构造函数参数。然后它将自动提供。在 `DataStoreTests` 的构造函数中，我们将
    `fixture` 参数分配给 `serilogFixture` 变量 **(2)**。
- en: In order to save space, the full code is not provided in *Listing 11.2*. The
    absent parts are indicated with the “...” symbol. The `Add_Item` test case was
    constructed using `Fact` to examine the creation of an entry. The `Create_Item`
    and `Delete_Item` test cases both employ `Theory`, enabling us to test a variety
    of items.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了节省空间，*列表 11.2* 中没有提供完整的代码。缺失的部分用“...”符号表示。`Add_Item` 测试用例是用 `Fact` 构建的，用于检查条目的创建。`Create_Item`
    和 `Delete_Item` 测试用例都使用了 `Theory`，使我们能够测试各种条目。
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11.2: `DataStoreTests.cs` ([https://epa.ms/DataStoreTests11-2](https://epa.ms/DataStoreTests11-2))'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 11.2: `DataStoreTests.cs` ([https://epa.ms/DataStoreTests11-2](https://epa.ms/DataStoreTests11-2))'
- en: Through these examples, we have demonstrated how to create unit tests in the
    model layer. The knowledge we have acquired thus far can also be applied to unit
    testing in other .NET applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们展示了如何在模型层创建单元测试。我们迄今为止获得的知识也可以应用于其他 .NET 应用程序的单元测试。
- en: Having concluded the introduction to the model layer unit testing, we will proceed
    to explore the Razor component unit testing using the bUnit library in the next
    part of this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了模型层单元测试之后，我们将继续探讨本章下一部分使用 bUnit 库进行 Razor 组件单元测试。
- en: Mock .NET MAUI components
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 .NET MAUI 组件
- en: 'In developing unit tests for .NET MAUI, we will present test case development
    for both XAML-based and Blazor-based apps. In both instances, we will incorporate
    the MVVM pattern in the design. The unit test cases at the model layer are identical
    for both; however, testing the view and the view model differs significantly.
    Developing unit test cases for the view and the view model in a XAML-based app
    can be quite complex. To test the view model, it is necessary to resolve the dependencies
    of XAML components. For instance, in the XAML version of our app, we need to invoke
    `Shell` navigation methods within the view model, as demonstrated in the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 .NET MAUI 开发单元测试时，我们将展示基于 XAML 和基于 Blazor 的应用程序的测试用例开发。在这两种情况下，我们都会在设计时采用
    MVVM 模式。模型层的单元测试用例对于两者都是相同的；然而，对视图和视图模型的测试存在显著差异。在基于 XAML 的应用程序中开发视图和视图模型的单元测试可能相当复杂。为了测试视图模型，需要解决
    XAML 组件的依赖关系。例如，在我们的应用程序的 XAML 版本中，我们需要在视图模型中调用 `Shell` 导航方法，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To address dependencies in `Xamarin.Forms`, an open-source project, `Xamarin.Forms.Mocks`,
    is available to help mock `Xamarin.Forms` components. In the case of .NET MAUI
    XAML apps, we require a similar solution for developing unit test cases for the
    view model, but currently, an equivalent does not seem to exist. Furthermore,
    there is a native user interface test framework, `Xamarin.UITest`, specifically
    for Android and iOS. However, it is not yet compatible with .NET MAUI. Additionally,
    since `Xamarin.UITest` is not a cross-platform solution, it will not be discussed
    in this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决开源项目 `Xamarin.Forms` 中的依赖关系，有一个名为 `Xamarin.Forms.Mocks` 的项目可以帮助模拟 `Xamarin.Forms`
    组件。对于 .NET MAUI XAML 应用程序，我们需要一个类似解决方案来开发视图模型的单元测试用例，但目前似乎还没有等效的解决方案。此外，还有一个针对
    Android 和 iOS 的本地用户界面测试框架 `Xamarin.UITest`。然而，它目前还不兼容 .NET MAUI。另外，由于 `Xamarin.UITest`
    不是一个跨平台解决方案，因此本书中不会讨论它。
- en: To partially address the dependency issue related to the view model test in
    this book, we can reference the .NET MAUI source code directly. Found at [https://github.com/dotnet/maui](https://github.com/dotnet/maui),
    this source code includes the original unit test code containing mock .NET MAUI
    components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部分解决本书中关于视图模型测试的依赖问题，我们可以直接引用 .NET MAUI 源代码。位于 [https://github.com/dotnet/maui](https://github.com/dotnet/maui)，该源代码包括包含模拟
    .NET MAUI 组件的原始单元测试代码。
- en: 'I have incorporated some elements from the .NET MAUI source code into the unit
    test project `PassXYZ.Vault.Tests`. To resolve the `Shell` navigation issue in
    the view model, the following code from `PassXYZ.Vault.Tests/maui/ShellTestBase.cs`
    is included:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将 .NET MAUI 源代码的一些元素纳入到单元测试项目 `PassXYZ.Vault.Tests` 中。为了解决视图模型中的 `Shell`
    导航问题，包含了来自 `PassXYZ.Vault.Tests/maui/ShellTestBase.cs` 的以下代码：
- en: 'In the `NewItemViewModel` tests, we can incorporate the `ShellTestBase` class
    with the following namespace:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `NewItemViewModel` 测试中，我们可以使用以下命名空间将 `ShellTestBase` 类纳入：
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After implementing the namespace above, a mock `Shell` can be created using
    the following code:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现上述命名空间后，可以使用以下代码创建模拟的 `Shell`：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have a mock `Shell` instance, we can use this mock `Shell` instance
    in the following test case:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有一个模拟的 `Shell` 实例，我们就可以在以下测试用例中使用这个模拟的 `Shell` 实例：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For a Blazor Hybrid app, we don’t have the above issue. We have access to a
    reliable testing library called bUnit, which can be utilized for testing Razor
    components. This allows us to develop unit test cases for the view, view model,
    and model layers for Blazor apps.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Blazor 混合应用，我们没有上述问题。我们可以访问一个可靠的测试库 bUnit，它可以用于测试 Razor 组件。这使我们能够为 Blazor
    应用程序的视图、视图模型和模型层开发单元测试用例。
- en: Razor component testing using bUnit
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 bUnit 进行 Razor 组件测试
- en: In .NET MAUI development, we cannot create unit test cases for all view and
    view model layers in XAML-based UI components; however, this is possible with
    Blazor. bUnit is an exceptional test library that can be employed for developing
    unit tests for Razor components. The bUnit library facilitates the creation of
    unit test cases for Razor components using xUnit, NUnit, or MSTest. Throughout
    the remainder of this chapter, we will utilize xUnit in conjunction with bUnit.
    The structure of unit test cases using bUnit bears similarity to the xUnit test
    cases we discussed in the previous section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 开发中，我们无法为所有基于 XAML 的 UI 组件的所有视图和视图模型层创建单元测试用例；然而，使用 Blazor 是可以做到的。bUnit
    是一个出色的测试库，可以用于为 Razor 组件开发单元测试。bUnit 库简化了使用 xUnit、NUnit 或 MSTest 为 Razor 组件创建单元测试用例的过程。在本章的剩余部分，我们将结合使用
    xUnit 和 bUnit。使用 bUnit 的单元测试用例结构与我们在上一节中讨论的 xUnit 测试用例类似。
- en: 'In the remainder of this chapter, we will focus on testing the following Razor
    components, which were created in the second part of this book:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将专注于测试以下 Razor 组件，这些组件是在本书的第二部分创建的：
- en: Razor components in the `PassXYZ.BlazorUI` project
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PassXYZ.BlazorUI` 项目的 Razor 组件'
- en: Razor components in the `PassXYZ.Vault` project
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PassXYZ.Vault` 项目的 Razor 组件'
- en: To test Razor components using bUnit, it is necessary to modify the project
    configuration of `PassXYZ.Vault.Tests`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 bUnit 测试 Razor 组件，需要修改 `PassXYZ.Vault.Tests` 的项目配置。
- en: Changing the project configuration for bUnit
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改 bUnit 的项目配置
- en: 'To establish the test environment, we must add the bUnit and Moq packages,
    as well as updating the SDK type. The following modifications can be made to the
    xUnit `PassXYZ.Vault.Tests` testing project:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立测试环境，我们必须添加 bUnit 和 Moq 包，以及更新 SDK 类型。以下修改可以应用于 xUnit `PassXYZ.Vault.Tests`
    测试项目：
- en: Add bUnit to the project.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 bUnit 添加到项目中。
- en: 'To incorporate the bUnit library into the project, first navigate to the project
    folder, then execute the following command from a console:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将 bUnit 库集成到项目中，首先导航到项目文件夹，然后在控制台中执行以下命令：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Additionally, we need to include the Moq package, which is a mocking library
    that will be utilized during the test setup process.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还需要包含 Moq 包，这是一个在测试设置过程中将使用的模拟库。
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Change the project configuration.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改项目配置。
- en: To test the Razor components, we also need to change the project’s SDK to `Microsoft.NET.Sdk.Razor`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试 Razor 组件，我们还需要将项目的 SDK 更改为 `Microsoft.NET.Sdk.Razor`。
- en: 'In the `PassXYZ.Vault.Tests.csproj` project file, we need to replace the following
    line:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `PassXYZ.Vault.Tests.csproj` 项目文件中，我们需要替换以下行：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: with
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: with
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once we have the project configuration ready, we can create a simple unit test
    case using bUnit to test our Razor components.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目配置就绪，我们可以使用 bUnit 创建一个简单的单元测试用例来测试我们的 Razor 组件。
- en: Creating a bUnit test case
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 bUnit 测试用例
- en: In our PassXYZ.Vault app, there are two types of Razor components that can be
    tested. The shared Razor components are located in the `PassXYZ.BlazorUI` project
    and serve as generic Razor components, which can be utilized across different
    projects. The second set of Razor components can be found in the `Pages` folder
    of the `PassXYZ.Vault` project. These components are specific to the `PassXYZ.Vault`
    app and make use of shared components from the `PassXYZ.BlazorUI` project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 PassXYZ.Vault 应用中，有两种类型的 Razor 组件可以进行测试。共享的 Razor 组件位于 `PassXYZ.BlazorUI`
    项目中，作为通用 Razor 组件，可以在不同的项目中使用。第二组 Razor 组件可以在 `PassXYZ.Vault` 项目的 `Pages` 文件夹中找到。这些组件特定于
    `PassXYZ.Vault` 应用，并使用来自 `PassXYZ.BlazorUI` 项目的共享组件。
- en: To test the Razor components within the `PassXYZ.BlazorUI` project, we can examine
    each component individually. These test cases are unit test cases. The Razor components
    located in the `Pages` folder of the `PassXYZ.Vault` project serve as UI pages.
    Since these pages utilize UI components from other packages, they possess more
    dependencies. Consequently, these test cases can be regarded as integration test
    cases.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `PassXYZ.BlazorUI` 项目中的 Razor 组件，我们可以单独检查每个组件。这些测试用例是单元测试用例。位于 `PassXYZ.Vault`
    项目 `Pages` 文件夹中的 Razor 组件作为 UI 页面。由于这些页面使用了来自其他包的 UI 组件，它们具有更多的依赖项。因此，这些测试用例可以被视为集成测试用例。
- en: 'To begin, let’s first create a test case for the `ModalDialog` Razor component
    in the `PassXYZ.BlazorUI` project. To test `ModalDialog`, we can generate an xUnit
    test class called `ModalDialogTests`, as illustrated in *Listing 11.3*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `PassXYZ.BlazorUI` 项目中为 `ModalDialog` Razor 组件创建一个测试用例。要测试 `ModalDialog`，我们可以生成一个名为
    `ModalDialogTests` 的 xUnit 测试类，如 *列表 11.3* 所示：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11.3: `ModalDialogTests.cs` ([https://epa.ms/ModalDialogTests11-3](https://epa.ms/ModalDialogTests11-3))'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3：`ModalDialogTests.cs` ([https://epa.ms/ModalDialogTests11-3](https://epa.ms/ModalDialogTests11-3))
- en: As seen in the `ModalDialogTests` unit test class, it bears a strong resemblance
    to the unit test class created for the model layer. We reuse the collection fixture
    established earlier and initialize it in the constructor. In the `ModalDialogInitTest`
    test case, we continue to employ the `Arrange`, `Act`, and `Assert` pattern for
    the implementation of the test case.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 `ModalDialogTests` 单元测试类中所示，它与为模型层创建的单元测试类有很强的相似性。我们重用了之前建立的集合固定装置，并在构造函数中初始化它。在
    `ModalDialogInitTest` 测试用例中，我们继续使用 `Arrange`、`Act` 和 `Assert` 模式来实现测试用例。
- en: All bUnit test classes inherit from `TestContext` **(1)**. During the `Arrange`
    phase, we initialize a local `title` variable, **(2)**, with a predefined string.
    In the `Act` phase, we call a generic method, `RenderComponent<T>`, **(3)**, and
    use the `ModalDialog` type as the type parameter. We pass the `title` variable,
    **(4)**, as the component parameter. The outcome of `RenderComponent<T>` is stored
    in the `cut` variable. In the `Assert` phase, we confirm that the title text after
    rendering is consistent with the argument we pass, utilizing the bUnit method
    `Find` **(5)**. The bUnit method `Find` can be used to find any HTML tag. In `ModalDialog`,
    the title is rendered as an `<h5>` HTML tag.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 bUnit 测试类都继承自 `TestContext` **（1**）。在 `Arrange` 阶段，我们使用预定义的字符串初始化一个局部 `title`
    变量，**（2**）。在 `Act` 阶段，我们调用一个泛型方法 `RenderComponent<T>` **（3**），并使用 `ModalDialog`
    类型作为类型参数。我们将 `title` 变量，**（4**），作为组件参数传递。`RenderComponent<T>` 的结果存储在 `cut` 变量中。在
    `Assert` 阶段，我们确认渲染后的标题文本与传递的参数一致，利用 bUnit 方法 `Find` **（5**）。bUnit 方法 `Find` 可以用来查找任何
    HTML 标签。在 `ModalDialog` 中，标题被渲染为 `<h5>` HTML 标签。
- en: In the `ModalDialogInitTest` test case, we observe the structure of the bUnit
    tests. For bUnit tests, we first render the component being tested. The rendering
    outcome is stored in the `cut` variable, **(3)** which is an instance of the `IRenderedComponent`
    interface. To verify the result, we can refer to the properties or invoke the
    methods of the `IRenderedComponent` instance.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ModalDialogInitTest` 测试用例中，我们观察了 bUnit 测试的结构。对于 bUnit 测试，我们首先渲染被测试的组件。渲染结果存储在
    `cut` 变量中，**（3**），这是一个 `IRenderedComponent` 接口的实例。为了验证结果，我们可以参考 `IRenderedComponent`
    实例的属性或调用其方法。
- en: When Razor components are rendered in the `TestContext`, they exhibit the same
    lifecycle as any other Razor component. We can pass parameters to the components
    being tested, and they can generate output akin to their behavior in a browser.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Razor 组件在 `TestContext` 中渲染时，它们表现出与其他任何 Razor 组件相同的生命周期。我们可以向被测试的组件传递参数，并且它们可以生成类似于在浏览器中的行为的输出。
- en: In the preceding example, when rendering the `ModalDialog` component, we can
    pass component parameters to it using the `Add` method, which belongs to the parameter
    builder of the `ComponentParameterCollectionBuilder<TComponent>` type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当渲染 `ModalDialog` 组件时，我们可以使用 `Add` 方法将其参数传递给它，该方法属于 `ComponentParameterCollectionBuilder<TComponent>`
    类型的参数构建器。
- en: Rendering simple components using C# code may not pose a problem. However, when
    passing multiple parameters to a component, using C# code can be inconvenient.
    By employing bUnit, we can develop test cases in Razor files, which significantly
    improves the experience of unit test development.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 代码渲染简单组件可能不会引起问题。然而，当向组件传递多个参数时，使用 C# 代码可能不太方便。通过使用 bUnit，我们可以在 Razor
    文件中开发测试用例，这显著提高了单元测试开发的经验。
- en: Creating test cases in Razor files
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Razor文件中创建测试用例
- en: To create tests directly in Razor markup files, we can declare components using
    Razor markup, similar to how we utilize them within a Razor page. This approach
    eliminates the need to call Razor components in the C# code or pass parameters
    using function calls. For a Razor page, we can render Razor components using **Razor
    templates**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Razor标记文件中直接创建测试用例，我们可以使用Razor标记声明组件，类似于我们在Razor页面中使用它们的方式。这种方法消除了在C#代码中调用Razor组件或使用函数调用传递参数的需要。对于Razor页面，我们可以使用**Razor模板**来渲染Razor组件。
- en: 'We can illustrate the process of creating tests in Razor markup files by developing
    test cases for a more complex `EditorDialog` component. We previously created
    the `EditorDialog` component in *Chapter 10*, *Implementing Razor Components*.
    In *Listing 11.4*, we will examine the unit tests for this component:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为更复杂的`EditorDialog`组件开发测试用例来展示在Razor标记文件中创建测试的过程。我们之前在*第10章*，*实现Razor组件*中创建了`EditorDialog`组件。在*列表11.4*中，我们将检查此组件的单元测试：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 11.4: `EditorDialogTests.razor` ([https://epa.ms/EditorDialogTests11-4](https://epa.ms/EditorDialogTests11-4))'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4：`EditorDialogTests.razor` ([https://epa.ms/EditorDialogTests11-4](https://epa.ms/EditorDialogTests11-4))
- en: We can develop a new Razor component, called `EditorDialogTests`, within the
    `PassXYZ.Vault.Tests` project. As it serves as a bUnit test class, it is a child
    class of `TestContext` **(1)**. Within this class, we generate test cases in a
    code block by utilizing **Razor templates**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`PassXYZ.Vault.Tests`项目中开发一个新的Razor组件，称为`EditorDialogTests`。作为bUnit测试类，它是`TestContext`的子类**（1**）。在这个类中，我们通过利用**Razor模板**在代码块中生成测试用例。
- en: Let’s first examine the `Edit_OnClose_Clicked` test case. In this scenario,
    we initially render the `EditorDialog` component and then proceed to test the
    close button.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查`Edit_OnClose_Clicked`测试用例。在这种情况下，我们首先渲染`EditorDialog`组件，然后测试关闭按钮。
- en: 'To render the `EditorDialog` component, we invoke the `Render` method **(2)**
    of `TestContext`. Compared to the previous example, in this case, we can render
    the Razor markup directly rather than calling the C# function. The Razor markup
    utilized here is referred to as **Razor templates**. For more information about
    Razor templates, refer to the following Microsoft documentation: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染`EditorDialog`组件，我们调用`TestContext`的`Render`方法**（2**）。与上一个示例相比，在这种情况下，我们可以直接渲染Razor标记而不是调用C#函数。这里使用的Razor标记被称为**Razor模板**。有关Razor模板的更多信息，请参阅以下Microsoft文档：[https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1)。
- en: '`Razor templates` can be defined in the following format:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Razor模板`可以按以下格式定义：'
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It consists of an `@` symbol and a pair of open and closed HTML tags. Razor
    templates can be used in the code block of the Razor file. They cannot be used
    in a C# or C# code-behind file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它由一个`@`符号和一对开闭HTML标签组成。Razor模板可以在Razor文件的代码块中使用。它们不能在C#或C#代码隐藏文件中使用。
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After `EditorDialog` is rendered, we can find the close button and simulate
    the click action, **(3)**:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditorDialog`渲染后，我们可以找到关闭按钮并模拟点击操作**（3**）：'
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `OnCloseHandler` event handler, the `_isOnCloseClicked` variable, **(4)**,
    is set to `true` so that we can assert the result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnCloseHandler`事件处理程序中，`_isOnCloseClicked`变量**（4**）被设置为`true`，这样我们就可以断言结果。
- en: 'In the `Edit_With_KeyEditingEnabled` test case, **(5)**, after the component
    is rendered, we can simulate user interactions to set the key and value fields
    in the component. After that, we can simulate clicking on the save button as we
    can see here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Edit_With_KeyEditingEnabled`测试用例**（5**）中，组件渲染后，我们可以模拟用户交互来设置组件中的键和值字段。之后，我们可以模拟点击保存按钮，如下所示：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Upon clicking the button, the event handler is triggered. Within the `OnSaveClicked`
    event handler, we receive the modified key and value, enabling us to assert the
    result.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，事件处理程序被触发。在`OnSaveClicked`事件处理程序中，我们接收修改后的键和值，使我们能够断言结果。
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As evidenced by these two test cases, designing bUnit tests becomes more straightforward
    when creating tests within a Razor file. By utilizing Razor templates, we can
    render components and also simulate various user interactions, enabling us to
    test the components interactively.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Razor templates serve as an excellent tool for combining Razor markup and C#
    code, allowing us to benefit from the strengths of both approaches. However, there
    are certain limitations when using Razor templates. In the next section, we will
    explore how to overcome these constraints.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Using the RenderFragment delegate
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Razor templates can help to simplify test setups, they have their limitations,
    especially in complex test case scenarios. With intricate test cases, Razor templates
    can become quite lengthy. If we intend to reuse the same Razor templates in another
    test case, we would need to copy them, potentially resulting in a significant
    amount of duplicated code. This is one of the main drawbacks of using Razor templates.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can use a `RenderFragment` delegate. As its name indicates,
    it is the delegate type of `RenderFragment` or `RenderFragment<TValue>`. The data
    type of Razor templates is `RenderFragment` or `RenderFragment<TValue>`. A `RenderFragment`
    delegate is the delegate type for Razor templates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the `RenderFragment` delegate in the following
    Microsoft document: [https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragments-in-code-2](https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragments-in-code-2).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to use the `RenderFragment` delegate, let’s set up a more
    complex test for the `EditorDialog` component. `EditorDialog` can be used to edit
    either `Item` or `Field`. We can use an item-editing case to show how to use the
    `RenderFragment` delegate.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the option to create a new test class, `ItemEditTests`, within the
    `PassXYZ.Vault.Tests` project. To differentiate the Razor markup and C# code,
    we can divide the `ItemEditTests` test class into a Razor file (`ItemEditTests.razor`)
    and a C# code-behind file (`ItemEditTests.razor.cs`). The markup designated for
    testing can be declared in the Razor file, as demonstrated in *Listing 11.5*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 11.5: `ItemEditTests.razor` ([https://epa.ms/ItemEditTests11-5](https://epa.ms/ItemEditTests11-5))'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: We define a `RenderFragment` delegate, `_editorDialog`, in the `@code` block
    of `ItemEditTests.razor`. The `RenderFragment` delegate must accept a parameter
    called `__builder` of the `RenderTreeBuilder` type. In the markup code, we can
    access the variables defined in the test class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the usage of `_editorDialog` in the C# code-behind file in
    *Listing 11.6*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 11.6: `ItemEditTests.razor.cs` ([https://epa.ms/ItemEditTests11-6](https://epa.ms/ItemEditTests11-6))'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Since `_editorDialog` defines the `Item` editing, we can develop multiple test
    cases for it. We can see that we render `_editorDialog`, **(1)**, for multiple
    test cases, such as `Edit_New_Item` and `Edit_Existing_Item`. By employing the
    `RenderFragment` delegate, our testing code appears more elegant and streamlined.
    Without taking this approach, we would need to replicate lengthy markup code in
    multiple locations. Directly using C# code may result in even more duplication
    of code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`_editorDialog`定义了`Item`编辑，我们可以为它开发多个测试用例。我们可以看到，为了多个测试用例，例如`Edit_New_Item`和`Edit_Existing_Item`，我们渲染了`_editorDialog`**（1）**。通过使用`RenderFragment`委托，我们的测试代码看起来更加优雅和简洁。如果不采取这种方法，我们可能需要在多个位置复制大量的标记代码。直接使用C#代码可能会导致更多的代码重复。
- en: In both test cases, we employ a similar process to test the `EditorDialog` by
    setting values and then clicking the `Save` button. In the markup code, we have
    a `<select>` tag defined. We can change the option, **(2)**, of the `<select>`
    tag within the test code. This `<select>` tag is conditionally rendered based
    on the value of the `isNewItem` variable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个测试用例中，我们通过设置值然后点击`Save`按钮来测试`EditorDialog`，采用了一个类似的过程。在标记代码中，我们定义了一个`<select>`标签。我们可以在测试代码中更改`<select>`标签的选项，**（2）**。这个`<select>`标签是根据`isNewItem`变量的值有条件地渲染的。
- en: In the `Edit_Existing_Item` test, we can also examine the negative case when
    the `isNewItem` variable,**(3)**, is set to `false`. In this instance, an exception
    is raised since the `<select>` tag is not rendered. We can observe that bUnit
    can also be utilized to test negative cases by verifying the content of the exception,
    **(4)**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Edit_Existing_Item`测试中，我们还可以检查当`isNewItem`变量**（3）**设置为`false`时的负面情况。在这种情况下，由于`<select>`标签没有被渲染，会抛出一个异常。我们可以观察到bUnit也可以通过验证异常的内容**（4）**来利用测试负面情况。
- en: In the previous examples, we developed bUnit tests for the shared components
    in the `PassXYZ.BlazorUI` project. As these shared components serve as reusable
    building blocks for a high-level UI, many of them declare numerous component parameters.
    Utilizing the `RenderFragment` delegate or **Razor templates** can aid in simplifying
    the test setup process.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为`PassXYZ.BlazorUI`项目中的共享组件开发了bUnit测试。由于这些共享组件作为高级UI的可重用构建块，其中许多声明了多个组件参数。利用`RenderFragment`委托或**Razor模板**可以帮助简化测试设置过程。
- en: Upon examining the Razor pages within the `Pages` folder of the `PassXYZ.Vault`
    project, we find that `Items`, `ItemDetail`, and `Login` also function as Razor
    components. However, they are not designed for reuse. These Razor pages feature
    defined route templates and lack an extensive range of component parameters. The
    component parameters present in these Razor pages serve routing purposes. When
    designing test cases for these Razor pages, it is advisable to implement tests
    in a C# class instead of Razor files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`PassXYZ.Vault`项目的`Pages`文件夹中的Razor页面时，我们发现`Items`、`ItemDetail`和`Login`也充当Razor组件。然而，它们并不是为重用而设计的。这些Razor页面具有定义的路由模板，并且缺乏广泛的组件参数。这些Razor页面中存在的组件参数用于路由目的。在为这些Razor页面设计测试用例时，建议在C#类中而不是在Razor文件中实现测试。
- en: Testing Razor pages
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Razor页面
- en: During the development testing of Razor pages, we will become familiar with
    some highly beneficial bUnit features. Since it is not possible to review all
    the tests of Razor pages in our app, we will use `ItemDetail` as an example. `ItemDetail`
    is a Razor page designed to display the contents of a password entry, and it has
    a defined route.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发测试Razor页面期间，我们将熟悉一些非常有用的bUnit功能。由于我们无法审查我们应用中所有Razor页面的测试，我们将使用`ItemDetail`作为示例。`ItemDetail`是一个设计用来显示密码条目内容的Razor页面，并且它有一个定义的路由。
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we want to display the `ItemDetail` page, we need to pass the `Id` info
    for an `Item` instance to it, and this instance cannot be a group. The initialization
    of the `ItemDetail` page is done in the `OnParametersSet()` lifecycle method,
    as we can see here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要显示`ItemDetail`页面时，我们需要传递一个`Item`实例的`Id`信息给它，并且这个实例不能是一个组。`ItemDetail`页面的初始化是在`OnParametersSet()`生命周期方法中完成的，正如我们在这里可以看到的：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will develop an `ItemDetailTests` test class to cover all the execution
    paths in `OnParametersSet()`. To cover all the execution paths, we can find the
    following test cases:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个`ItemDetailTests`测试类来覆盖`OnParametersSet()`中的所有执行路径。为了覆盖所有执行路径，我们可以找到以下测试用例：
- en: '`Test case 1`: Initialize the `ItemDetail` instance without a selected item
    `Id`. We will get an `InvalidOperationException` exception, **(1)**, in this case.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试用例 1`：初始化没有选择项目`Id`的`ItemDetail`实例。在这种情况下，我们将得到一个`InvalidOperationException`异常，**（1）**。'
- en: '`Test case 2`: Initialize the `ItemDetail` instance with the wrong item `Id`.
    In this case, we will get an `InvalidOperationException` exception, **(2)**.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试用例 2`：使用错误的项目`Id`初始化`ItemDetail`实例。在这种情况下，我们将得到一个`InvalidOperationException`异常，**（2）**。'
- en: '`Test case 3`: Initialize the `ItemDetail` instance with a valid item `Id`,
    but the item type as a group. In this case, we will get an `InvalidOperationException`
    exception, **(3)**.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试用例 3`：使用有效的项目`Id`初始化`ItemDetail`实例，但项目类型为分组。在这种情况下，我们将得到一个`InvalidOperationException`异常，**（3）**。'
- en: '`Test case 4`: Initialize the `ItemDetail` instance with a valid item `Id`
    and the item type is an entry, **(4)**.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试用例 4`：使用有效的项目`Id`和项目类型为条目初始化`ItemDetail`实例，**（4）**。'
- en: 'We can implement these test cases in an `ItemDetailTests` bUnit test class,
    as shown here in *Listing 11.7*:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`ItemDetailTests` bUnit测试类中实现这些测试用例，如下所示在*列表 11.7*中：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 11.7: `ItemDetailTests.cs` ([https://epa.ms/ItemDetailTests11-7](https://epa.ms/ItemDetailTests11-7))'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7：`ItemDetailTests.cs` ([https://epa.ms/ItemDetailTests11-7](https://epa.ms/ItemDetailTests11-7))
- en: The first test case is implemented in `Init_Empty_ItemDetail` **(3)**. During
    the test setup, we attempt to render the `ItemDetail` component directly without
    providing a selected item `Id`. We anticipate encountering an `InvalidOperationException`
    exception as a result.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试用例在`Init_Empty_ItemDetail` **（3）**中实现。在测试设置期间，我们尝试直接渲染`ItemDetail`组件而不提供选择的项目`Id`。我们预计会遇到`InvalidOperationException`异常。
- en: Before executing the test case, we must first address the `IDataStore` dependency.
    `ItemDetail` relies on the `IDataStore<Item>` interface, and we can resolve this
    through dependency injection. In our app, this dependency is registered within
    the `MauiProgram.cs` file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行测试用例之前，我们必须首先解决`IDataStore`依赖项。`ItemDetail`依赖于`IDataStore<Item>`接口，我们可以通过依赖注入来解决这个问题。在我们的应用程序中，这个依赖项在`MauiProgram.cs`文件中注册。
- en: With bUnit, dependency injection is supported using `TestContext`. We can register
    the dependency using `AddSingleton`, **(2)**. To isolate the test, we use the
    `Moq` mocking framework, **(1)**, to replace the actual implementation of `IDataStore`,
    so we can reduce the complexity of the test setup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bUnit，可以通过`TestContext`支持依赖注入。我们可以使用`AddSingleton` **（2）**来注册依赖项。为了隔离测试，我们使用`Moq`模拟框架
    **（1）**来替换`IDataStore`的实际实现，这样我们可以减少测试设置的复杂性。
- en: 'Using `Moq`, we only need to fake the method or property that we need in our
    test setup. It can help to isolate our tests from their dependencies. To use the
    `Moq` framework, we can create a `Moq` object using the interface or class that
    we need as a type parameter. Later, we can define the behavior of the target interface
    or class when we use it. In the constructor, we create a `Mock` object and register
    the `IDataStore<Item>` interface using `dataStore.Object`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Moq`，我们只需要在我们的测试设置中模拟所需的方法或属性。这有助于将我们的测试与其依赖项隔离。要使用`Moq`框架，我们可以使用所需的接口或类作为类型参数创建一个`Moq`对象。稍后，当我们使用它时，我们可以定义目标接口或类的行为。在构造函数中，我们创建一个`Mock`对象，并使用`dataStore.Object`注册`IDataStore<Item>`接口：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After we register `IDataStore` in the constructor, we can execute the first
    test case again. This time, we can get the exception and verify the message is
    what we expect:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在构造函数中注册`IDataStore`之后，我们可以再次执行第一个测试用例。这次，我们可以获取异常并验证消息是否如我们所期望：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let us look at the second test case. In the second test case, we pass
    an invalid `Id` to `ItemDetail` and try to render it:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看第二个测试用例。在第二个测试用例中，我们向`ItemDetail`传递一个无效的`Id`并尝试渲染它：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, we also get an expected exception, and we can verify its content
    using `Assert.Equal`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们也得到了预期的异常，我们可以使用`Assert.Equal`来验证其内容。
- en: 'In the third test case, we provide a valid `Id` to `ItemDetail`, but the item
    is of a group type. This is a scenario that may be challenging to reproduce during
    an integration or user acceptance test. However, in a unit test, it is relatively
    simple to verify, as demonstrated here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个测试用例中，我们向`ItemDetail`提供有效的`Id`，但项目是分组类型。这是一个在集成测试或用户验收测试期间可能难以重现的场景。然而，在单元测试中，验证这一点相对简单，如下所示：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To test this, we need to create a group and assign it to a `testGroup` variable.
    In this test case, we must call the `GetItem` method of `IDataStore`. Since we
    mocked `IDataStore` in our setup, we also need to mock the `GetItem` method here.
    The `Moq` method returns `testGroup` when called. Once the test setup is prepared,
    we can render `ItemDetail` with `testGroup.Id`. The expected outcome of this test
    is the exception that we anticipate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们需要创建一个组并将其分配给 `testGroup` 变量。在这个测试用例中，我们必须调用 `IDataStore` 的 `GetItem`
    方法。由于我们在设置中模拟了 `IDataStore`，因此我们在这里也需要模拟 `GetItem` 方法。当调用时，`Moq` 方法返回 `testGroup`。一旦测试设置准备就绪，我们就可以用
    `testGroup.Id` 渲染 `ItemDetail`。这个测试的预期结果是预期的异常。
- en: 'In the final test case, we will pass a valid Item `Id` and the item type is
    an entry:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的测试用例中，我们将传递一个有效的项目 `Id`，并且项目类型是一个条目：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This test case is similar to the third test case, except we can create an entry
    and assign it to the `testEntry` variable. After we render `ItemDetail` with `testEntry.Id`,
    we can verify that the `<article>` rendered HTML tag is the one that we expect.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例与第三个测试用例类似，除了我们可以创建一个条目并将其分配给 `testEntry` 变量。在用 `testEntry.Id` 渲染 `ItemDetail`
    之后，我们可以验证渲染的 `<article>` HTML 标签是我们预期的。
- en: Thus far, we have explored testing Razor components using bUnit. It is evident
    that we can attain an impressively high level of test coverage with bUnit. This
    serves as one of the advantages of Blazor UI design.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了使用 bUnit 测试 Razor 组件。很明显，我们可以使用 bUnit 达到令人印象深刻的测试覆盖率。这成为 Blazor
    UI 设计的优势之一。
- en: We have now addressed all the topics related to unit test development with .NET
    MAUI in this chapter that we intended to explore.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经解决了本章中我们打算探索的所有与 .NET MAUI 单元测试开发相关的话题。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed unit test development for .NET MAUI apps. Although
    multiple test frameworks are available, we selected xUnit as our framework for
    this chapter. In the MVVM pattern, unit testing of the model layer is consistent
    with any other .NET application. We developed test cases for the `IDataStore`
    interface to evaluate our model layer. For unit testing the view and view model,
    we concentrated on the Blazor Hybrid app utilizing the bUnit test library. By
    combining the xUnit framework and bUnit library, we can develop end-to-end unit
    tests for a Blazor Hybrid app. With bUnit, we addressed topics such as Razor templates,
    the `RenderFragment` delegate, dependency injection, and the Moq framework.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 .NET MAUI 应用程序的单元测试开发。尽管有多个测试框架可用，但我们选择了 xUnit 作为本章的框架。在 MVVM 模式下，模型层的单元测试与任何其他
    .NET 应用程序一致。我们为 `IDataStore` 接口开发了测试用例来评估我们的模型层。对于视图和视图模型的单元测试，我们专注于使用 bUnit 测试库的
    Blazor 混合应用程序。通过结合 xUnit 框架和 bUnit 库，我们可以为 Blazor 混合应用程序开发端到端的单元测试。使用 bUnit，我们解决了有关
    Razor 模板、`RenderFragment` 委托、依赖注入和 Moq 框架等问题。
- en: With the understanding of unit testing acquired in this chapter, you should
    now be capable of developing your own unit tests. For more information on .NET
    unit test development, please refer to the *Further reading* section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本章中获得的单元测试理解，你现在应该能够开发自己的单元测试。有关 .NET 单元测试开发的更多信息，请参阅 *进一步阅读* 部分。
- en: Unit testing can be integrated into a CI/CD pipeline. This setup allows unit
    tests to be executed automatically during the development process. We will explore
    this topic in greater detail in the upcoming chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以集成到 CI/CD 流程中。这种设置允许在开发过程中自动执行单元测试。我们将在下一章中更详细地探讨这个主题。
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Microsoft Visual Studio 2005 Unleashed* by Lars Powers and Mike Snell: [https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194](https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Microsoft Visual Studio 2005 Unleashed》* by 拉尔斯·鲍尔斯和迈克·斯奈尔: [https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194](https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194)'
- en: 'MSTest: [https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MSTest: [https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)'
- en: '*Strengthening Visual Studio Unit Tests* by John Robbins: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests](https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《强化Visual Studio单元测试》* by 约翰·罗宾斯: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests](https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests)'
- en: '*NUnit Pocket Reference* by Bill Hamilton: [https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396](https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*NUnit 快速参考*》由比尔·汉密尔顿著：[https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396](https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396)
- en: 'NUnit Releases at SourceForge: [https://sourceforge.net/projects/nunit/](https://sourceforge.net/projects/nunit/)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SourceForge 上的 NUnit 发布：[https://sourceforge.net/projects/nunit/](https://sourceforge.net/projects/nunit/)
- en: '*Why Did we Build xUnit 1.0:* [https://xunit.net/docs/why-did-we-build-xunit-1.0](https://xunit.net/docs/why-did-we-build-xunit-1.0)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么我们构建 xUnit 1.0:* [https://xunit.net/docs/why-did-we-build-xunit-1.0](https://xunit.net/docs/why-did-we-build-xunit-1.0)'
- en: 'xUnit documentation: [https://xunit.net/](https://xunit.net/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit 文档：[https://xunit.net/](https://xunit.net/)
- en: 'xUnit.NET 2.0 release note: [https://xunit.net/releases/2.0](https://xunit.net/releases/2.0)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit.NET 2.0 版本发布说明：[https://xunit.net/releases/2.0](https://xunit.net/releases/2.0)
- en: Learn more on Discord
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
- en: '![](img/QR_Code166522361691420406.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code166522361691420406.png)'
