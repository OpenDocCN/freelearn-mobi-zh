<html><head></head><body><div id="sbo-rt-content"><section>&#13;
&#13;
                            <header class="header-title chapter-title">&#13;
                    Performance and Responsiveness in Swift&#13;
                </header>&#13;
            &#13;
            <article>&#13;
                &#13;
<p>We have covered a lot of ground in the previous chapters, and we have a lot of Swift tools in our tool belt. Now it's time to delve into more advanced topics, looking at how certain Swift types are implemented, how they can be used, and what their performance characteristics <span>are</span>. We will also look at how we can perform asynchronous tasks using <strong>Grand Central Dispatch</strong> (<strong>GCD</strong>) through the Dispatch framework and the higher-level operations in the Foundation framework that are also built on GCD.</p>&#13;
<p>Understanding the multithreaded environment available on all Apple platforms, as well as the performance profile of the Swift constructs you use, is vital to building a fast and responsive app.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Value and reference semantics</li>&#13;
<li>Using Dispatch queues for concurrency</li>&#13;
<li>Concurrent queues and dispatch groups</li>&#13;
<li>Implementing the operation class</li>&#13;
</ul>&#13;
<h1 id="uuid-5a84f63c-d1c1-4ae2-968a-38bc28f020ac">Technical requirements</h1>&#13;
<p><span>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09</a></span></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3bn2l2O" target="_blank">https://bit.ly/3bn2l2O</a></p>&#13;
<h1 id="uuid-445af282-5b0b-4285-9ed9-5485876d13dc">Value and reference semantics</h1>&#13;
<p>We saw back in <a href="" target="_blank">Chapter 1</a>, <em>Swift Building Blocks</em>, that certain Swift types behave differently from others, specifically regarding ownership and the mutation of properties. We even defined this difference, saying that classes are <em>reference</em> types, while structs and enums are <em>value</em> types. In this recipe, we will examine why these types behave differently and the performance implications this entails.</p>&#13;
<p class="p1"><span class="s1">Let's create the model for an app that allows a user to schedule events that they do every day and reminds them when these events should occur.</span></p>&#13;
<h2 id="uuid-a7324d6a-065d-431f-a26a-fdcf3781cf79">Getting ready</h2>&#13;
<p class="p1"><span class="s1">We need to decide how we will model our daily event. The key to this decision is whether we want our event to have reference semantics or value semantics. We discussed the differences between the two in <a href="f9d48715-ffca-464f-95bf-722958f02e72.xhtml" target="_blank">Chapter 1</a>, <em>Swift Building Blocks</em><span>,</span> but let's re-examine the differences.</span></p>&#13;
<p class="p1"><span class="s1"><em>Value</em><span> </span>types are simple data structures that you can think of as just bundles of data. Swift makes these types more useful by allowing them to have methods, but any change or<span> </span><em>mutation</em><span> </span>of the underlying data results in a whole new bundle of data. In contrast,<span> </span><em>reference</em><span> </span>types are more complex data structures that have an identity outside of their component properties. Therefore, a change in the component properties will be available via any references to the object.</span></p>&#13;
<p class="p1"><span class="s1">A value type's simple composition has the advantage of being very cheap on resources to create and maintain.<span> </span>However, this simplicity comes at the expense of dynamic dispatch, which enables sub-classing.</span></p>&#13;
<h2 id="uuid-bee9be7a-e6ef-4138-bd93-a62157c42b01">How to do it...</h2>&#13;
<p class="p1"><span class="s1">Given this distinction, what behavior do we want for our daily event? If we change the name of our event, should we expect anything that has a reference to it to also see that change? That sounds like the behavior we want, so our daily event should be a reference type:</span></p>&#13;
<pre class="p3"><span class="s2">class</span><span class="s1"> DailyEvent {<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> name: </span><span class="s3">String<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">init</span><span class="s1">(name: </span><span class="s3">String</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">self</span><span class="s1">.</span><span class="s4">name</span><span class="s1"> = name<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">Let's check that this gives us the behavior we expect:</span></p>&#13;
<pre class="p3"><span class="s2">var</span><span class="s1"> event1 = </span><span class="s4">DailyEvent</span><span class="s1">(name: </span><span class="s5">"have bath"</span><span class="s1">)<br/></span><span class="s2">var</span><span class="s1"> event2 = </span><span class="s4">event1<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s1">"Event 1 - </span><span class="s7">\</span><span class="s1">(</span><span class="s4">event1</span><span class="s7">.</span><span class="s4">name</span><span class="s1">)"</span><span class="s7">) </span><span class="s8">// have bath<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s1">"Event 2 - </span><span class="s7">\</span><span class="s1">(</span><span class="s4">event2</span><span class="s7">.</span><span class="s4">name</span><span class="s1">)"</span><span class="s7">) </span><span class="s8">// have bath<br/></span><span class="s4">event1</span><span class="s7">.</span><span class="s4">name</span><span class="s7"> = </span><span class="s1">"have shower"<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s5">"Event 1 - </span><span class="s7">\</span><span class="s5">(</span><span class="s4">event1</span><span class="s7">.</span><span class="s4">name</span><span class="s5">)"</span><span class="s7">) </span><span class="s1">// have shower<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s5">"Event 2 - </span><span class="s7">\</span><span class="s5">(</span><span class="s4">event2</span><span class="s7">.</span><span class="s4">name</span><span class="s5">)"</span><span class="s7">) </span><span class="s1">// have shower</span></pre>&#13;
<p class="p1"><span class="s1">We want to be reminded of our event every day at a certain time, but for our purpose, <kbd>Date</kbd> in <kbd>Foundation</kbd> is a bit of an overkill, since it contains both date and time information, and we only need to maintain time information. Let's create something to represent the time, irrespective of the date. What behavior is most appropriate for our time model? Should it have reference semantics or type semantics?</span></p>&#13;
<p class="p1"><span class="s1">Let's try both and see which seems to most accurately model the situation we are after:</span></p>&#13;
<ol>&#13;
<li><span class="s1">We'll create time as a class, with reference semantics:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">class</span><span class="s1"> ClockTime {<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> hours: </span><span class="s3">Int<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> minutes: </span><span class="s3">Int<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">init</span><span class="s1">(hours: </span><span class="s3">Int</span><span class="s1">, minutes: </span><span class="s3">Int</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">self</span><span class="s1">.</span><span class="s4">hours</span><span class="s1"> = hours<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">self</span><span class="s1">.</span><span class="s4">minutes</span><span class="s1"> = minutes<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<ol start="2">&#13;
<li>Now, let's see how this will behave when its properties are changed:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">let</span><span class="s1"> defaultEventTime = </span><span class="s4">ClockTime</span><span class="s1">(hours: </span><span class="s9">6</span><span class="s1">, minutes: </span><span class="s9">30</span><span class="s1">)<br/></span><span class="s2">var</span><span class="s7"> event1Time = </span><span class="s1">defaultEventTime</span><span class="s7"> </span><span class="s8">// 6:30<br/></span><span class="s2">var</span><span class="s7"> event2Time = </span><span class="s1">defaultEventTime</span><span class="s7"> </span><span class="s8">// 6:30<br/></span><span class="s1">// Event 2 has been moved to 9:30<br/></span><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">hours</span><span class="s7"> = </span><span class="s9">9<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s5">"Event 1 - </span><span class="s7">\</span><span class="s5">(</span><span class="s1">event1Time</span><span class="s7">.</span><span class="s1">hours</span><span class="s5">):</span><span class="s7">\</span><span class="s5">(</span><span class="s1">event1Time</span><span class="s7">.</span><span class="s1">minutes</span><span class="s5">)"</span><span class="s7">) <br/></span><span class="s8">  // Event 1 - 9:30<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s5">"Event 2 - </span><span class="s7">\</span><span class="s5">(</span><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">hours</span><span class="s5">):</span><span class="s7">\</span><span class="s5">(</span><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">minutes</span><span class="s5">)"</span><span class="s7">)<br/>  </span><span class="s8">// Event 2 - 9:30</span></pre>&#13;
<p style="padding-left: 60px">When we change the properties of an instance of <kbd>ClockTime</kbd>, it has the unintended consequence of changing all references to that same instance of <kbd>ClockTime</kbd>. Since <span class="s1">reference semantics aren't a perfect fit for <kbd>ClockTime</kbd>, let's change it to a value type and see whether that is more appropriate.</span></p>&#13;
<ol start="3">&#13;
<li>We now have two o<span class="s1">ptions for value types in Swift; we can model <kbd>ClockTime</kbd> as a <kbd>struct</kbd> or an <kbd>enum</kbd>. Enums are great for modeling concepts that have a small number of finite values. While there are a finite number of minutes in a day, it's not a small number, and we might want to do math calculations on the hours and minutes in <kbd>ClockTime</kbd>, so a <kbd>struct</kbd> is more appropriate:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">struct</span><span class="s1"> ClockTime {<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> hours: </span><span class="s3">Int<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> minutes: </span><span class="s3">Int<br/></span><span class="s1">}</span></pre>&#13;
<ol start="4">&#13;
<li>Let's see how this changes the behavior when we change the properties of a <kbd>ClockTime</kbd> instance:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">let</span><span class="s1"> defaultEventTime = </span><span class="s4">ClockTime</span><span class="s1">(hours: </span><span class="s9">6</span><span class="s1">, minutes: </span><span class="s9">30</span><span class="s1">)<br/></span><span class="s2">var</span><span class="s7"> event1Time = </span><span class="s1">defaultEventTime</span><span class="s7"> </span><span class="s8">// 6:30<br/></span><span class="s2">var</span><span class="s7"> event2Time = </span><span class="s1">defaultEventTime</span><span class="s7"> </span><span class="s8">// 6:30<br/></span><span class="s1">// Event 2 has been moved to 9:30<br/></span><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">hours</span><span class="s7"> = </span><span class="s9">9<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s5">"Event 1 - </span><span class="s7">\</span><span class="s5">(</span><span class="s1">event1Time</span><span class="s7">.</span><span class="s1">hours</span><span class="s5">):</span><span class="s7">\</span><span class="s5">(</span><span class="s1">event1Time</span><span class="s7">.</span><span class="s1">minutes</span><span class="s5">)"</span><span class="s7">) </span><span class="s8">// Event 1 - 6:30<br/></span><span class="s6">print</span><span class="s7">(</span><span class="s5">"Event 2 - </span><span class="s7">\</span><span class="s5">(</span><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">hours</span><span class="s5">):</span><span class="s7">\</span><span class="s5">(</span><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">minutes</span><span class="s5">)"</span><span class="s7">) </span><span class="s8">// Event 2 - 9:30</span></pre>&#13;
<p style="padding-left: 60px">With <kbd>ClockTime</kbd> as a value type, changing a property of a <kbd>ClockTime</kbd> instance results in a new instance, so the change doesn't have the unintended consequences that we saw when it was a reference type.</p>&#13;
<p style="padding-left: 60px">Lastly<span class="s1">, let's consider some of the dynamic features that we will give up by making <kbd>ClockTime</kbd> a value type. Will we ever want to subclass <kbd>ClockTime</kbd>? This doesn't seem likely, and it is right to characterize <kbd>ClockTime</kbd> as a simple bundle of data. So, in this scenario, modeling <kbd>ClockTime</kbd> as a value type is the right decision.</span></p>&#13;
<ol start="5">&#13;
<li>To complete the model, we will add a <kbd>ClockTime</kbd> property to the <kbd>DailyEvent</kbd> class:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">class</span><span class="s1"> DailyEvent {<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> name: </span><span class="s3">String<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> time: </span><span class="s3">ClockTime<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">init</span><span class="s1">(name: </span><span class="s3">String</span><span class="s1">, time: </span><span class="s3">ClockTime</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">self</span><span class="s1">.name = name<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">self</span><span class="s1">.time = time<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<h2 id="uuid-ea1e3aa2-d473-4072-8d3b-cbfb34d4f580" class="p1"><span class="s1">How it works...</span></h2>&#13;
<p class="p1"><span class="s1">We've already covered how value types differ from reference types. Now, let's examine why they behave differently.</span></p>&#13;
<p class="p1"><span class="s1">When storing new instances of a type in memory, Swift has two different data structures that it can use for storage: the <strong>Stack</strong> and the <strong>Heap</strong></span>. T<span class="s1">hese structures are common to many programming languages. Value types are stored on the <strong>Stack</strong></span>, <span class="s1">and</span> reference <span class="s1">types are stored on the <strong>Heap</strong></span><strong>.</strong> <span class="s1">Understanding how data is stored in these structures, even at the superficial level that we will cover, will help us to understand why value types and reference types have differing behaviors.</span></p>&#13;
<p class="p1"><span class="s1">The stack can be thought of as sequential blocks of data. An instance of a type may be represented by multiple blocks of data, and an instance can be referenced using the memory position of its first piece of data. A <strong>Stack Pointer</strong>, which is a reference to the memory position at the end of the stack, is maintained. New instances are always added to the end of the stack, and then the stack pointer's position is updated to the new end of the stack.</span></p>&#13;
<p class="p1"><span class="s1">Let's go through adding a value type instance using a simplified diagram of the stack. </span><span class="s1">Before anything is added, the stack pointer is at the top of the stack:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/a3981653-ae39-4677-87e0-ec80787be9e2.jpg" style="" width="483" height="497"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.1 – Representation of the stack and stack pointer</span></div>&#13;
<p class="p1"><span class="s1">A<span> </span><kbd>ClockTime</kbd></span><span> struct </span><span class="s1">for 07:00 is added to the stack. This takes up three blocks, and the stack pointer moves to the next empty block on the stack:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/aa8bb748-2db5-48e2-82e3-06b4eacb04f2.jpg" style="" width="487" height="491"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.2 – Stack pointer after adding a ClockTime struct for 7:00</span></div>&#13;
<p class="p1"><span class="s1"><span>Another </span><kbd>ClockTime</kbd><span> struct for 09:30 is added to the stack. This has a size of four blocks, and the stack pointer moves to the next empty block on the stack</span>:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/91818305-f75d-4005-b9ba-3637859a4a6a.jpg" style="" width="480" height="491"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span> </span><span>Figure 9.3 – Stack pointer after adding a ClockTime struct for 9:30</span></div>&#13;
<p class="p1"><span class="s1">Once data is placed on the stack, it is immutable. To see why this is an important restriction, let's try and change our first <kbd>ClockTime</kbd> instance on the stack. <span>The simplicity and efficiency of the stack is predicated on the fact that it is a continuous block of memory. If we try and change any data already on the stack, it may take up more space, which will cause data in the subsequent blocks to be overwritten</span>:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/fad6256b-de25-4ba5-8cef-a21b203ba00f.jpg" style="" width="481" height="494"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.4 – Changing the first ClockTime instance on the stack</span></div>&#13;
<p class="p1"><span class="s1">Therefore, any change to a <kbd>struct</kbd> results in a new, changed version of the <kbd>struct</kbd> appended at the end of the stack.</span></p>&#13;
<p>Let's mutate a <kbd>ClockTime</kbd> instance and see how that looks in our simplified stack representation by taking it step by step:</p>&#13;
<ol>&#13;
<li>&#13;
<p class="p1"><span class="s1">We have a<span> </span><kbd>ClockTime</kbd><span> </span>struct for 9:00 assigned to the variable named<span> </span><kbd>event1Time</kbd>:</span></p>&#13;
</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">var</span><span class="s1"> event1Time = </span><span class="s4">ClockTime</span><span class="s1">(hours: </span><span class="s9">9</span><span class="s1">, </span><span class="s1">minutes: </span><span class="s9">0</span><span class="s1">)</span></pre>&#13;
<p style="padding-left: 60px">See <span><span>the following diagram </span></span>for a visual representation of how this may look:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/d0ac446d-b30a-44ed-bfa7-9f7304a5fe25.jpg" style="" width="659" height="514"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.5 – Assigning the event1Time variable to a ClockTime struct for 09:00</span></div>&#13;
<ol start="2">&#13;
<li class="p1">The <span class="s1"><span>value of </span><kbd>event1Time</kbd><span> is also assigned to a new variable, called </span><kbd>event2Time</kbd>:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3"><span class="s2">var</span><span class="s1"> event2Time =</span><span class="s1"> </span><span class="s4">event1Time</span></pre>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/171561e4-439a-48ae-b392-ed8dccf7ed6b.jpg" style="" width="674" height="537"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span> </span><span>Figure 9.6 – Assigning the value of event1Time to event2Time</span></div>&#13;
<ol start="3">&#13;
<li class="p1">When <span class="s1"><span>we mutate </span><kbd>event2Time</kbd><span>, changing the minute value to <kbd>30</kbd>, a new </span><kbd>ClockTime</kbd><span> instance with the changed minute value is placed at the end of the stack</span>:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p6"><span class="s1">event2Time</span><span class="s7">.</span><span class="s1">minutes</span><span class="s7"> </span><span class="s7">= </span><span class="s9">30</span></pre>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/5a7b80e6-e41f-41bd-a1f7-69b005a4543f.jpg" style="" width="656" height="521"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span> Figure 9.7 – The new ClockTime instance placed at the end of the stack</span></div>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">The <kbd>event2Time</kbd> variable now points to this new stack position, while <kbd>event1Time</kbd> continues to point to the stack position of the original <kbd>ClockTime</kbd> struct for 09:00.</span></p>&#13;
<p class="p1"><span class="s1">As the preceding examples show, the stack is a very simple and efficient data structure, and its properties explain the behavior we see when we use value types such as <kbd>struct</kbd> and <kbd>enums</kbd></span>.</p>&#13;
<p class="p1"><span class="s1">In contrast, reference types, such as class objects, are stored on the heap, which enables more dynamic and complex behavior at the expense of efficiency.</span></p>&#13;
<p class="p1"><span class="s1">An accurate look at heap allocations is beyond the scope of this book, but let's take a very simplified look at how a reference type instance is stored on the <strong>Heap</strong>. </span><span class="s1">The heap is not a continuous chain of blocks, but an area of memory that can be free or already allocated:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/699c254b-0e9e-4cda-a47e-b0642d70f6a8.jpg" style="" width="890" height="512"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.8 – Representation of the heap</span></div>&#13;
<p class="p1"><span class="s1"><span>When a class is allocated to the heap,</span><span> it must search through the heap to find a set of free blocks appropriate for its size. The reference type instance may include references to other reference types or value types by storing their stack positions</span>:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/b397d89e-dcc4-4bfd-b03a-1e23c1898178.jpg" style="" width="947" height="507"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.9 – Allocation of a class in the heap</span></div>&#13;
<p class="p1"><span class="s1"><span>Multiple variables can hold references to the same instance</span>:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/58e4a2b8-89de-4e90-9d73-1b0db7cbd05c.jpg" style="" width="953" height="520"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.10 – Multiple variables holding references to the same instances</span></div>&#13;
<p class="p1"><span class="s1">When reference types are modified, they aren't copied. Instead, extra space must be found to accommodate the extra information. All references to the instance<span> </span><span>have the changed information</span>:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/bf8452ee-3324-439e-a907-4244a9233cee.jpg" style="" width="956" height="518"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.11 – Modifying reference types</span></div>&#13;
<p class="p2"><span class="s1">This recipe describes the difference between reference semantics and value semantics, and hopefully illustrates that these behaviors arise from the way in which they are stored in memory.</span></p>&#13;
<p class="p2"><span class="s1">Both have their uses, and it's important to choose the right type when building your model.</span></p>&#13;
<h2 id="uuid-0cf498d5-5621-43ec-9b40-20dff1e8301f">See also</h2>&#13;
<p><strong>Swift blog</strong>: Value and reference types: <a href="http://swiftbook.link/blog/type-semantics" target="_blank">http://swiftbook.link/blog/type-semantics</a><a href="http://swiftbook.link/blog/type-semantics" target="_blank"/></p>&#13;
<p><strong>Apple Developer Videos (developer account needed)</strong>:</p>&#13;
<ul>&#13;
<li>WWDC 2016 - Protocol and Value-Oriented Programming in UIKit Apps: <a href="https://developer.apple.com/videos/play/wwdc2016/419" target="_blank">https://developer.apple.com/videos/play/wwdc2016/419</a><a href="https://developer.apple.com/videos/play/wwdc2016/419" target="_blank"/></li>&#13;
</ul>&#13;
<h1 id="uuid-529f03eb-ec53-46c5-affa-511b1a3360c8"><span>Using</span> Dispatch queues for concurrency</h1>&#13;
<p class="p1"><span class="s1">We live in a multicore computing world. Multicore processors are found in everything, from our laptops and mobile phones to our watches. With these multiple cores comes the ability to work in parallel. These concurrent streams of work are known as</span> <em>threads</em>, <span class="s1">and programming in a multithreaded way enables your code to make the best use of the processor's cores. Deciding how and when to create new threads and manage the available resources are complex tasks, so Apple has built a framework to do the hard work for us. It is called <em>Grand Central Dispatch</em></span>.</p>&#13;
<p class="p1"><span class="s1"><strong>Grand Central Dispatch</strong> (<strong>GCD</strong>) handles the thread maintenance and monitors the available resources while providing a simple, queue-based interface for getting concurrent work done. With the open-sourcing of Swift, Apple also open-sourced GCD in the form of <kbd>libdispatch</kbd>, since Swift does not yet have built-in concurrency features.</span></p>&#13;
<p class="p1"><span class="s1">In this recipe, we will explore some of the features of <kbd>libdispatch</kbd>, also known as the Dispatch framework, and see how we can use concurrency to build apps that are efficient and responsive.</span></p>&#13;
<h2 id="uuid-94cb68cb-0a4f-4583-a332-d555bb8ab55c" class="p1"><span class="s1">Getting ready</span></h2>&#13;
<p class="p1"><span class="s1">We will see how we can improve the responsiveness of an app using GCD, so first, we need to start with an app that requires some improvement. Go to <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups</a>. Here, you will find the repository of an app that takes a collection of photos and turns them into a PDF photo book. You can download the app source files directly from GitHub or by using <kbd>git</kbd></span>:</p>&#13;
<pre class="p3"><strong><span class="s3"><span class="s2">git clone https://github.com/PacktPublishing/Swift-Cookbook-Second-<br/>Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups/<br/></span></span></strong><strong><span class="s3"><span class="s2">PhotobookCreator.git</span></span></strong></pre>&#13;
<p class="p1"><span class="s1">If you build and run the app, you will see a collection of sample images, with the ability to add more:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/2dbb1d24-5525-4173-9c7c-10b3bbe95ec1.png" style="" width="744" height="1327"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.12 – Sample images</span></div>&#13;
<p class="p1"><span class="s1">When you tap on <span class="packt_screen">Generate Photo Book</span>, the app will take the photos you have chosen, resize them to the same size, and save them as a multi-page PDF that can then be exported or shared. Depending on how many photos are included and the performance of the device, this process can take a little time to complete. During this time, the whole interface is unresponsive; for example, you can't scroll through the pictures.</span></p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<h2 id="uuid-dd754f35-dc5f-4fcb-82a9-54fd579bc33d" class="p1"><span class="s1">How to do it...</span></h2>&#13;
<p><span>Let's</span> examine <span>why the app is unresponsive during photo book generation and how we can fix this:</span></p>&#13;
<ol>&#13;
<li><span class="s1">Open up the <kbd>PhotoBookCreator</kbd> project and navigate to <kbd>PhotoCollectionViewController.swift</kbd>. In this file, you will find the following method:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">func</span><span class="s1"> generatePhotoBook(with photos: [</span><span class="s5">UIImage</span><span class="s1">]) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> resizer = PhotoResizer()<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> builder = PhotoBookBuilder()<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">// Scale down (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> photosForBook = resizer.scaleToSmallest(of: photos)<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">// Crop (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>photosForBook = resizer.cropToSmallest(of: photosForBook)<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">// Generate PDF (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> photobookURL = builder.buildPhotobook(with:  <br/>       photosForBook)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> previewController = UIDocumentInteractionController(url: <br/>      photobookURL)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>previewController.delegate = </span><span class="s4">self<br/></span><span class="s1"><span class="Apple-converted-space">    </span>previewController.presentPreview(animated: </span><span class="s4">true</span><span class="s1">)<br/></span><span class="s1">}</span></pre>&#13;
<p style="padding-left: 60px">In this method, we call three functions that can take quite a long time to complete. We take the output of one function and feed it into the next function, and the result is a URL for our photo book, which we then launch with some UI to preview and export.</p>&#13;
<p style="padding-left: 60px" class="mce-root"><span class="s1">This work to resize and crop the photos, and then generate the photo book, is taking place in the same queue where UI touch events are processed, the</span> main queue, which is why our UI is unresponsive.</p>&#13;
<ol start="2">&#13;
<li class="mce-root">To free up the main queue for UI events, we can create our own private q<span class="s1">ueue, which we can use to execute our long-running functions:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">import</span><span class="s1"> Dispatch<br/></span><span class="s4"><br/></span><span class="s4">class</span><span class="s1"> PhotoCollectionViewController</span><span class="s1">: </span><span class="s5">UIViewController</span><span class="s1"> {<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">//...<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> processingQueue = </span><span class="s5">DispatchQueue</span><span class="s1">(label: </span><span class="s7">"Photo processing <br/>      queue"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">func</span><span class="s1"> generatePhotoBook(with photos: [</span><span class="s5">UIImage</span><span class="s1">])</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">processingQueue</span><span class="s6">.</span><span class="s8">async</span><span class="s6"> { [weak self] in<br/></span><span class="s1"><span class="Apple-converted-space"><br/>            let resizer = PhotoResizer()<br/>            let builder = PhotoBookBuilder()            <br/><br/></span></span><span class="s6"><span class="Apple-converted-space">            </span></span><span class="s6"><span class="Apple-converted-space">// Get smallest common size<br/>            let size = resizer.smallestCommonSize(for: photos)<br/> <br/>            // Scale down (can take a while)<br/>            var photosForBook = resizer.scaleWithAspectFill(photos, <br/>              to: size)<br/>                                                                   <br/>            // Crop (can take a while)<br/>            photosForBook = resizer.centerCrop(photosForBook, to: <br/>              size)<br/>            // Generate PDF (can take a while)<br/>            let pbURL = builder.buildPhotobook(with: photosForBook)</span></span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s6"><span class="Apple-converted-space">            </span></span><span class="s1">// Show preview with export options<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">let</span><span class="s1"> previewController = <br/>              UIDocumentInteractionController(url: pbURL)<br/></span><span class="s1">                                                                  </span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">            </span>previewController.delegate = </span><span class="s4">self<br/></span><span class="s1"><span class="Apple-converted-space">            </span>previewController.presentPreview(animated: </span><span class="s4">true</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">By calling the <kbd>async</kbd> method on our <kbd>DispatchQueue</kbd> and providing a block of code, we are scheduling that block to be executed. GCD will execute that block when resources are available. Now, our long-running code isn't blocking the main queue, so our UI will remain responsive; however, if you were to run the app with just this change, you would get some very odd behavior when the app tried to show the preview view controller.</span></p>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">We just discussed the fact that UI touch events are delivered to the main queue, which is why we wanted to avoid blocking it; however, <kbd>UIKit</kbd> expects <em>all</em> UI events to happen on the main queue. Since we are currently creating and presenting the preview view controller from our private queue, we are defying this <kbd>UIKit</kbd> expectation, which can produce a number of bugs, including UI elements that never appear, or appear long after they were presented.</span></p>&#13;
<ol start="3">&#13;
<li>To solve this problem, we need to ensure that when we are ready to present our UI, we do that operation on the main queue:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">func</span><span class="s1"> generatePhotoBook(with photos: [</span><span class="s5">UIImage</span><span class="s1">], using builder:  <br/></span><span class="s5">  PhotoBookBuilder</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>processingQueue.async { [weak self] in<br/></span><span class="s1"><span class="Apple-converted-space"><br/>        let resizer = PhotoResizer()<br/>        let builder = PhotoBookBuilder()        <br/><br/></span></span><span class="s6"><span class="Apple-converted-space">        // Get smallest common size<br/>        let size = resizer.smallestCommonSize(for: photos)<br/> <br/>        // Scale down (can take a while)<br/>        var photosForBook = resizer.scaleWithAspectFill(photos, to: <br/>          size)<br/>        // Crop (can take a while)<br/>        photosForBook = resizer.centerCrop(photosForBook, to: size)<br/>        // Generate PDF (can take a while)<br/>        let pbURL = builder.buildPhotobook(with: photosForBook)</span></span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        DispatchQueue</span>.main.async {<br/></span><span class="s6"><span class="Apple-converted-space">          </span></span><span class="s1">// Show preview with export options<br/></span><span class="s1"><span class="Apple-converted-space">          </span></span><span class="s4">let</span><span class="s1"> previewController = UIDocumentInteractionController<br/>            (url: pbURL)<br/></span><span class="s1"><span class="Apple-converted-space">          </span>previewController.delegate = </span><span class="s4">self<br/></span><span class="s1"><span class="Apple-converted-space">          </span>previewController.presentPreview(animated: </span><span class="s4">true</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span>Now, if you run the app, you will find that you can generate a</span> photo book <span>while still being able to interact with the UI; for instance, being able to scroll the</span> table view<span>.</span></p>&#13;
<h2 id="uuid-7c57d742-9656-4fa2-a6ef-f63fec369d84" class="p1"><span class="s1">How it works...</span></h2>&#13;
<p class="p1"><span class="s1">GCD uses queues to manage blocks of work in a multithreaded environment. Queues operate on a <strong>first in first out</strong> (<strong>FIFO</strong>) policy. When GCD determines that resources are available, it will take the next block from the queue and execute it. Once the block has finished executing, it will be removed from the queue:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/e89ccaf5-a5e4-44f1-b15f-6d0e8d94b819.jpg" width="920" height="250"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.13 – FIFO policy</span></div>&#13;
<p class="p1"><span class="s1">There are two types of <kbd>DispatchQueue</kbd>: <em>serial</em> and</span> <em>concurrent</em>. Wi<span class="s1">th the simplest form of a queue, a serial queue, GCD will only execute one block at a time from the top of the queue. When each block finishes executing, it is removed from the queue, and each block moves up one position.</span></p>&#13;
<p class="p1"><span class="s1">The main queue, which processes all UI events, is an example of a serial queue, and this explains why performing a long-running operation on the main queue will cause your UI to become unresponsive. While your long-running operation is executing, nothing else on the main queue will be executed until the long-running operation has finished.</span></p>&#13;
<p class="p1"><span class="s1">With the second type of queue, a concurrent queue, GCD will execute as many blocks <span>on different threads </span>as resources allow. The next block to execute will be the block closest to the top of the stack that isn't already executing, and blocks are removed from the stack when finished:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/82170dbe-0af1-4bbb-89c3-1d883a108df9.jpg" width="976" height="246"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.14 – Execution when the second type of queue is added</span></div>&#13;
<p class="p1"><span class="s1">Concurrent queues can be really useful when you have numerous operations that are independent of each other. We will look into concurrent queues further in the <em>Concurrent queues and dispatch groups</em> recipe.</span></p>&#13;
<h2 id="uuid-6cca379b-56d3-4c58-b582-067de366ed70" class="p1"><span class="s1">See also</span></h2>&#13;
<ul>&#13;
<li class="p1"><span class="s1">The GitHub repository for <kbd>libdispatch</kbd>:</span> <a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank"><span class="s2">https://github.com/apple/swift-corelibs-libdispatch</span></a><a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank"/></li>&#13;
<li class="p1"><span class="s1">Documentation for dispatch queues: <a href="http://swiftbook.link/docs/dispatchqueue" target="_blank">http://swiftbook.link/docs/dispatchqueue</a></span><a href="https://developer.apple.com/reference/dispatch/dispatchqueue"/></li>&#13;
</ul>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<h1 id="uuid-5d725205-5e23-42ae-b822-bce5deb3c26d">Concurrent queues and dispatch groups</h1>&#13;
<p class="p1"><span class="s1">In the previous recipe, we looked into using a private serial queue to keep our app responsive by moving long-running operations off the main queue. In this recipe, we will break our operations down into smaller, independent blocks and place them on a concurrent queue.</span></p>&#13;
<h2 id="uuid-9c0be820-a29d-46ba-ab1f-0efa41fc26a1" class="p1"><span class="s1">Getting ready</span></h2>&#13;
<p class="p1"><span class="s1">We are going to build on the app we improved in the last recipe, which is an app that will produce a PDF photo book from a collection of photos. You can get the code for this app at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09</a></span> and choose the <kbd><span class="s1">PhotobookCreator_DispatchGroups</span></kbd> <span>folder.</span></p>&#13;
<p class="p1"><span class="s1">Open the project in XCode and navigate to the <kbd>PhotoCollectionViewController.swift</kbd> <span>file.</span></span></p>&#13;
<h2 id="uuid-f7e54e56-b84a-4a45-b81f-e1d0915f7d47" class="p1"><span class="s1">How to do it...</span></h2>&#13;
<p class="p1"><span class="s1">We saw in the last recipe how dispatch queues operate on a FIFO policy. GCD will execute a block from the top of the queue and remove it from the queue when it has finished executing. The number of blocks that GCD will allow to execute at the same time will depend on the type of queue being used. <em>Serial</em> queues will only have one block of code being executed at any time; other blocks in the queues will have to wait until the block at the top of the queue has finished executing. However, for a <em>concurrent</em> queue, GCD will <span>concurrently</span> execute as many blocks as there are resources available. We can make more efficient use of a concurrent queue by breaking down the work into smaller, independent blocks, allowing them to be executed concurrently.</span></p>&#13;
<p class="p1"><span class="s1">Take a look at the current implementation of the <kbd>generatePhotoBook</kbd> <span>method.</span> The only thing that has changed since the last recipe is that we now present the preview UI within a completion that is passed to the <kbd>generatePhotoBook</kbd> method. This simplifies the method and prevents us from needing to weakly capture <kbd>self</kbd> within the <kbd>async</kbd> block:</span></p>&#13;
<pre class="p4"><span class="s4">func</span><span class="s1"> generatePhotoBook(with photos</span><span class="s1">: [</span><span class="s5">UIImage</span><span class="s1">], completion: </span><span class="s4">@escaping</span><span class="s1"> <br/>  (</span><span class="s5">URL</span><span class="s1">) -&gt; </span><span class="s5">Void</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>processingQueue.async {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> resizer = PhotoResizer()<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> builder = PhotoBookBuilder()<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Get smallest common size<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> size = resizer.smallestCommonSize(for: photos)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Scale down (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">var</span><span class="s1"> photosForBook = resizer.scaleWithAspectFill(photos, <br/>          to: size)<br/></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Crop (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>photosForBook = resizer.centerCrop(photosForBook, to: size)<br/></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Generate PDF (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> photobookURL = builder.buildPhotobook(with: photosForBook)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span>DispatchQueue.main.async {<br/></span><span class="s6"><span class="Apple-converted-space">            </span></span><span class="s1">// Fire completion handler which will show the preview UI<br/></span><span class="s1"><span class="Apple-converted-space">            </span>completion(photobookURL)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">The work we are doing is in one block of code that we place on a queue. Let's see whether we can break this down into smaller, independent pieces of work that can be executed concurrently. We can't perform the scale and crop operations concurrently, as they will be operating on the same <kbd>UIImage</kbd> objects, and we will not get the intended result if the image is cropped before it's scaled.</span></p>&#13;
<p class="p1"><span class="s1">However, we can apply the scale and crop operation to each photo separately and perform that operation concurrently on the other photos. Once each photo has been scaled and cropped, we can use the processed images to generate the photo book:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/737635fd-c762-486f-ac2c-9e117e86421c.jpg" style="" width="942" height="810"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.15 – Serial approach and concurrent approach</span></div>&#13;
<div class="p1 packt_infobox"><span class="s1">Splitting the work up in this way may not make the overall operation faster, as there is an overhead to each block of work. The efficiency improvement of dividing the work into concurrent blocks will depend on the operation involved, and how many concurrent operations can run.</span></div>&#13;
<p class="p1"><span class="s1">We now have blocks of work that can run concurrently, but we have given ourselves a new problem; how do we coordinate all these concurrent pieces of work so that we know they are all completed and we can start generating the photo book? Here, GCD can help us. We can use a <kbd>DispatchGroup</kbd> to coordinate our operations on each of the images and be notified when they are all completed.</span></p>&#13;
<p class="p1"><span class="s1">A dispatch group is like a turnstile at a stadium. Every time someone enters the stadium, they pass through the turnstile, and one extra person is counted as being in the stadium, and at the end of the day, as people leave the stadium and pass through the turnstile, the number of people in the stadium decreases. Once there is no one left in the stadium, the lights can be turned off.</span></p>&#13;
<p class="p1">Let's use a dispatch group to coordinate the work of our photo book creator:</p>&#13;
<ol>&#13;
<li><span class="s1">First, we will create a dispatch group:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">let</span><span class="s1"> group = DispatchGroup()</span></pre>&#13;
<ol start="2">&#13;
<li>Every time we start a blockwork to resize a photo, we will enter the group:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s7">group</span><span class="s1">.enter()</span></pre>&#13;
<ol start="3">&#13;
<li>Once the work is finished, we will leave the group:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s7">group</span><span class="s1">.leave()</span></pre>&#13;
<ol start="4">&#13;
<li>Finally, we will ask the group to notify us when the last resize operation has finished and left the group. Then, we can take the processed files and generate the photo book:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s7">group</span><span class="s1">.notify(queue: processingQueue) {<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">//.. generate photo book<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">//.. execute completion handler<br/></span><span class="s1">}</span></pre>&#13;
<ol start="5">&#13;
<li>Let's take a look at our <kbd>generatePhotoBook</kbd> method, now using a concurrent queue and dispatch groups:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1"><span class="s1">let</span><span class="s2"> processingQueue = DispatchQueue(label: </span><span class="s3">"Photo processing <br/>  queue"</span><span class="s2">, attributes: .concurrent)<br/><br/></span><span class="s1">func</span><span class="s2"> generatePhotoBook(with photos: [<span class="s4">UIImage</span><span class="s2">], completion: </span><span class="s1">@escaping</span><span class="s2"> <br/>  (</span><span class="s4">URL</span><span class="s2">) -&gt; </span><span class="s4">Void</span><span class="s2">) {<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">let</span><span class="s2"> resizer = PhotoResizer()<br/></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">let</span><span class="s2"> builder = PhotoBookBuilder()<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s2">// Get smallest common size<br/></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">let</span><span class="s2"> size = resizer.smallestCommonSize(for: photos)<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">let</span><span class="s2"> processedPhotos = NSMutableArray(array: photos)<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">let</span><span class="s2"> group = DispatchGroup()<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">for</span><span class="s2"> (index, photo) </span><span class="s1">in</span><span class="s2"> photos.enumerated() {<br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s2"><span class="Apple-converted-space">        </span>group.enter()<br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s2"><span class="Apple-converted-space">        </span>processingQueue.async {</span><span class="s1"><br/></span><span class="s2"><span class="Apple-converted-space">            <br/></span></span><span class="s5"><span class="Apple-converted-space">            </span></span><span class="s2">// Scale down (can take a while)<br/></span><span class="s2"><span class="Apple-converted-space">            </span></span><span class="s1">var</span><span class="s2"> photosForBook = resizer.scaleWithAspectFill(<br/>              [photo], to: size)<br/></span><span class="s5"><span class="Apple-converted-space">            </span></span><span class="s2">// Crop (can take a while)<br/></span><span class="s2"><span class="Apple-converted-space">            </span>photosForBook = resizer.centerCrop([photo], to: size)<br/></span><span class="s2"><span class="Apple-converted-space">            <br/></span></span><span class="s5"><span class="Apple-converted-space">            </span></span><span class="s2">// Replace original photo with processed photo<br/></span><span class="s2"><span class="Apple-converted-space">            </span>processedPhotos[index] = photosForBook[</span><span class="s6">0</span><span class="s2">]<br/></span><span class="s2"><span class="Apple-converted-space">            <br/></span></span><span class="s2"><span class="Apple-converted-space">            </span>group.leave()<br/></span><span class="s2"><span class="Apple-converted-space">        </span>}<br/></span><span class="s2"><span class="Apple-converted-space">    </span>}<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span>group.notify(queue: processingQueue) {</span><span class="s1"><br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s1">guard</span><span class="s2"> </span><span class="s1">let</span><span class="s2"> photos = processedPhotos </span><span class="s1">as</span><span class="s2">? [</span><span class="s4">UIImage</span><span class="s2">] </span><span class="s1">else</span><span class="s2"> { <br/></span><span class="s1">          return</span><span class="s2"> }<br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s5"><span class="Apple-converted-space">        </span></span><span class="s2">// Generate PDF (can take a while)<br/></span><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s1">let</span><span class="s2"> photobookURL = builder.buildPhotobook(with: photos)<br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s2"><span class="Apple-converted-space">        </span>DispatchQueue.main.async {<br/></span><span class="s2"><span class="Apple-converted-space">            </span>completion(photobookURL)<br/></span><span class="s2"><span class="Apple-converted-space">        </span>}<br/></span><span class="s2"><span class="Apple-converted-space">    </span>}<br/></span><span class="s2">}</span></span></pre>&#13;
<h2 id="uuid-a3cec24b-fafe-4a68-bce3-b2104ca5b899" class="p1"><span class="s1">How it works...</span></h2>&#13;
<p class="p1"><span class="s1">Dispatch queues are serial by default, so to create a concurrent queue instead, we pass the <kbd>.concurrent</kbd> attribute when it is created:</span></p>&#13;
<pre class="p4"><span class="s4">let</span><span class="s1"> processingQueue = DispatchQueue(label: </span><span class="s8">"Photo processing queue"</span><span class="s1">, <br/>                                    attributes: .concurrent)</span></pre>&#13;
<p class="p1"><span class="s1">Before we loop through all the photos, we set up anything that isn't specific to each photo:</span></p>&#13;
<pre class="p1"><span class="s1">let</span><span class="s2"> resizer = PhotoResizer()<br/></span><span class="s1">let</span><span class="s2"> builder = PhotoBookBuilder()<br/></span><span class="s2">// Get smallest common size<br/></span><span class="s1">let</span><span class="s2"> size = </span><span class="s3">resizer</span><span class="s2">.smallestCommonSize(for: photos)<br/></span><span class="s1">let</span><span class="s2"> processedPhotos = NSMutableArray(array: photos)<br/></span><span class="s1">let</span><span class="s2"> group = DispatchGroup()</span></pre>&#13;
<p class="p1"><span class="s1">This includes creating the <kbd>DispatchGroup</kbd>, which we will use to coordinate the work. Since our photo resizing will now be happening concurrently, we need a place to collect the photos once they have been processed. We can use a Swift array for this; however, a Swift array is a value type, so we can't use it from within multiple blocks, as each block will be taking a copy of the array, not the original array itself.</span></p>&#13;
<p class="p1"><span class="s1">To solve this with a Swift array, we would need to make the <kbd>processedPhotos</kbd> array property on the view controller, which would mean we would have to weakly capture self in the blocks that we would need to unwrap. A simpler way to solve this problem is to use a collection that has reference semantics; the <kbd>Foundation</kbd> framework provides that in the form of <kbd>NSArray</kbd> and <kbd>NSMutableArray</kbd>. As we saw earlier in this chapter, it's important to understand the semantics of the construct being used and pick the right tool for the right job:</span></p>&#13;
<pre class="p1"><span class="s1">for</span><span class="s2"> (index, photo) </span><span class="s1">in</span><span class="s2"> photos.enumerated() {<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span>group.enter()<br/></span><span class="s2"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span>processingQueue.async {</span><span class="s1"><br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s2">// Scale down (can take a while)<br/></span><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s1">var</span><span class="s2"> photosForBook = resizer.scaleWithAspectFill([photo], <br/>          to: size)<br/></span><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s2">// Crop (can take a while)<br/></span><span class="s2"><span class="Apple-converted-space">        </span>photosForBook = resizer.centerCrop([photo], to: size)<br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s3"><span class="Apple-converted-space">        </span></span><span class="s2">// Replace original photo with processed photo<br/></span><span class="s2"><span class="Apple-converted-space">        </span>processedPhotos[index] = photosForBook[</span><span class="s4">0</span><span class="s2">]<br/></span><span class="s2"><span class="Apple-converted-space">        <br/></span></span><span class="s2"><span class="Apple-converted-space">        </span>group.leave()<br/></span><span class="s2"><span class="Apple-converted-space">    </span>}<br/></span><span class="s2">}</span></pre>&#13;
<p class="p1"><span class="s1">For each photo, we enter the group and place the resize work on the concurrent queue. We can use the same scale and crop methods that we used previously, just passing an array containing one photo. Once the work is completed, we'll replace the original photo with the processed photo in the array and leave the group.</span></p>&#13;
<p><span>Once every block has</span> left <span>the group, this</span> <kbd>notify</kbd> <span>block will execute. We retrieve the processed photos and use them to generate the photo book. Finally, we ensure that the completion handler is executed on the main queue:</span></p>&#13;
<pre class="p1"><span class="s1">group.notify(queue: processingQueue) {</span><span class="s3"><br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">guard</span><span class="s1"> </span><span class="s3">let</span><span class="s1"> photos = processedPhotos </span><span class="s3">as</span><span class="s1">? [</span><span class="s4">UIImage</span><span class="s1">] </span><span class="s3">else</span><span class="s1"> { </span><span class="s3">return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">// Generate PDF (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">let</span><span class="s1"> photobookURL = builder.buildPhotobook(with: photos)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>DispatchQueue.main.async {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>completion(photobookURL)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">If you build and run the app, you can still generate a photo book and the UI is still responsive, and now GCD can make the best use of the available resources to generate our photo book.</span></p>&#13;
<h2 id="uuid-4baa5988-1f6e-480f-91ec-a8047173457f" class="p1"><span class="s1">See also</span></h2>&#13;
<ul>&#13;
<li class="p1"><span class="s1">Documentation relating to dispatch queues: <a href="http://swiftbook.link/docs/dispatchqueue" target="_blank">http://swiftbook.link/docs/dispatchqueue</a><a href="http://swiftbook.link/docs/dispatchqueue" target="_blank"/></span></li>&#13;
<li class="p1"><span class="s1">Documentation relating to dispatch groups: <a href="http://swiftbook.link/docs/dispatchgroup" target="_blank">http://swiftbook.link/docs/dispatchgroup</a><a href="http://swiftbook.link/docs/dispatchgroup" target="_blank"/></span></li>&#13;
</ul>&#13;
<h1 id="uuid-323cf47f-6b74-414c-bc1b-ed6db244a7eb" class="p1">Implementing the operation class</h1>&#13;
<p class="p1"><span class="s1">In this chapter so far, we have taken our long-running operations and scheduled them as blocks of code, called <strong>closures</strong>, on dispatch queues. This has made it really easy to move long-running code off of the main queue, but if we intend to reuse this long-running code, pass it around, track its state, and generally deal with it in an object-orientated way, a closure is not ideal.</span></p>&#13;
<p class="p1"><span class="s1">To solve this, the <kbd>Foundation</kbd> framework provides an object, <kbd>Operation</kbd>, that allows us to wrap up our block of work within an encapsulated object.</span></p>&#13;
<p class="p1"><span class="s1">In this recipe, we will take the photo book app we used throughout this chapter and convert our long-running blocks to an <kbd>Operation</kbd></span> instance.</p>&#13;
<h2 id="uuid-a4e0672f-b184-4ff3-9b0c-ed1ff0954183" class="p1"><span class="s1">Getting ready</span></h2>&#13;
<p class="p1"><span class="s1">We are going to build on the app we improved in the last recipe, which is an app that will produce a PDF photo book from a collection of photos. You can get the code for this app at<span> <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09</a></span><span> </span>and choose the</span> <span class="s1"><kbd>PhotobookCreator_StartOperations</kbd> <span>folder. </span></span></p>&#13;
<p class="p1"><span class="s1">Open the folder and navigate to the<span> </span><kbd>PhotoCollectionViewController.swift</kbd><span> </span><span>file.</span></span></p>&#13;
<h2 id="uuid-88f67a0f-fa8e-4d0f-a382-39db6e8ae9aa" class="p1"><span class="s1">How to do it...</span></h2>&#13;
<p class="p1"><span class="s1">Let's recap how we broke the work down into independent parts:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/062bde1e-59e3-47eb-be26-9d081791e091.jpg" style="" width="644" height="630"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9.16 – Concurrent Approach blocks</span></div>&#13;
<p class="p1 CDPAlignCenter CDPAlign CDPAlignLeft"><span>We can turn each of these blocks of work into separate operations:</span></p>&#13;
<ol>&#13;
<li class="p1 CDPAlignCenter CDPAlign CDPAlignLeft"><span>Let's create an operation to scale and crop each photo.</span></li>&#13;
<li class="p1 CDPAlignCenter CDPAlign CDPAlignLeft"><span>We define an operation by sub-classing the <kbd>Operation</kbd> class, so in the project, create a new Swift file and call it <kbd>PhotoResizeOperation.swift</kbd>.</span></li>&#13;
</ol>&#13;
<ol start="3">&#13;
<li class="p1 CDPAlignCenter CDPAlign CDPAlignLeft">In the simplest <kbd>Operation</kbd> <span>implementation, we only need to override one method,</span> <kbd>main()</kbd><span>, so let's copy and paste the relevant code from our</span> <kbd>generatePhotobook</kbd> <span>method. This</span> <kbd>main()</kbd> <span>method will be executed when the operation starts:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">import</span><span class="s1"> UIKit<br/><br/></span><span class="s4">class</span><span class="s1"> PhotoResizeOperation: </span><span class="s5">Operation</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">override</span><span class="s1"> </span><span class="s4">func</span><span class="s1"> main() {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Scale down (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">var</span><span class="s1"> photosForBook = resizer.scaleWithAspectFill([photo], <br/>          to: size)<br/></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Crop (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>photosForBook = resizer.centerCrop([photo], to: size)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Replace original photo with processed photo<br/></span><span class="s1"><span class="Apple-converted-space">        </span>processedPhotos[index] = photosForBook[</span><span class="s7">0</span><span class="s1">]<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<ol start="4">&#13;
<li>Copying and pasting the code is not enough, as there are a number of dependencies that <span>were</span> previously being captured by the block. Now we have to explicitly provide these dependencies to the operation:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">class</span><span class="s1"> PhotoResizeOperation: </span><span class="s5">Operation</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> resizer: </span><span class="s5">PhotoResizer<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> size: </span><span class="s5">CGSize<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s6"> photos: </span><span class="s1">NSMutableArray<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> photoIndex: </span><span class="s5">Int<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">init</span><span class="s1">(resizer: </span><span class="s5">PhotoResizer</span><span class="s1">, size: </span><span class="s5">CGSize</span><span class="s1">, <br/>         photos: </span><span class="s5">NSMutableArray</span><span class="s1">, photoIndex: </span><span class="s5">Int</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space"><br/>        </span></span><span class="s4">self</span><span class="s1">.resizer = resizer<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">self</span><span class="s1">.size = size<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">self</span><span class="s1">.photos = photos<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">self</span><span class="s1">.photoIndex = photoIndex<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">override</span><span class="s1"> </span><span class="s4">func</span><span class="s1"> main() {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Retrieve the photo to be resized.<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> photo = </span><span class="s8">photos</span><span class="s1">[</span><span class="s8">photoIndex</span><span class="s1">] </span><span class="s4">as</span><span class="s1">? </span><span class="s5">UIImage</span><span class="s1"> </span><span class="s4">else</span><span class="s1"> { <br/></span><span class="s4">          return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Scale down (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">var</span><span class="s1"> photosForBook = resizer.scaleWithAspectFill([photo], <br/>          to: size)<br/></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Crop (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>photosForBook = resizer.centerCrop(photosForBook, to: size)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span>photos[photoIndex] = photosForBook[</span><span class="s7">0</span><span class="s1">]<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<ol start="5">&#13;
<li>We have converted our resize block to an operation. We now need to do the same for the block that generates the photo book:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">import</span><span class="s1"> UIKit<br/><br/></span><span class="s4">class</span><span class="s1"> GeneratePhotoBookOperation: </span><span class="s5">Operation</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s6"> builder: </span><span class="s1">PhotoBookBuilder<br/></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s6"> photos: </span><span class="s1">NSMutableArray<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> photobookURL: </span><span class="s5">URL</span><span class="s1">?<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s4">init</span><span class="s6">(builder: </span><span class="s1">PhotoBookBuilder</span><span class="s6">, photos: </span><span class="s1">NSMutableArray</span><span class="s6">) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">self</span><span class="s1">.builder = builder<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">self</span><span class="s1">.photos = photos<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">override</span><span class="s1"> </span><span class="s4">func</span><span class="s1"> main() {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> photos = </span><span class="s8">photos</span><span class="s1"> </span><span class="s4">as</span><span class="s1">? [</span><span class="s5">UIImage</span><span class="s1">] </span><span class="s4">else</span><span class="s1"> { </span><span class="s4">return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s6"><span class="Apple-converted-space">        </span></span><span class="s1">// Generate PDF (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>photobookURL = builder.buildPhotobook(with: photos)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p style="padding-left: 60px">We pass the dependencies into the operation, just like in <kbd>PhotoResizeOperation</kbd>. The output of this operation is a URL for the resulting photo book. We expose that as a property on the operation so that it can be retrieved outside the operation.</p>&#13;
<ol start="6">&#13;
<li>With our blocks of work converted to operations, let's switch over to <kbd>PhotoCollectionViewController.swift</kbd> <span>and update our</span> <kbd>generatePhotoBook</kbd> <span>method to use this new operation:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">let</span><span class="s1"> processingQueue = </span><span class="s5">OperationQueue</span><span class="s1">()<br/><br/></span><span class="s4">func</span><span class="s1"> generatePhotoBook(with photos: [</span><span class="s5">U</span><span class="s5">IImage</span><span class="s1">], completion: </span><span class="s4">@escaping<br/></span><span class="s1">  (</span><span class="s5">URL</span><span class="s1">) -&gt; </span><span class="s5">Void</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> resizer = PhotoResizer()<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> builder = PhotoBookBuilder()<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">// Get smallest common size<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> size = resizer.smallestCommonSize(for: photos)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> processedPhotos = </span><span class="s5">NSMutableArray</span><span class="s1">(array: photos)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> generateBookOp = </span><span class="s8">GeneratePhotoBookOperation</span><span class="s1">(builder: <br/>      builder, photos: processedPhotos)<br/>                                                    </span><span class="s1"><span class="Apple-converted-space"><br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">for</span><span class="s1"> index </span><span class="s4">in</span><span class="s1"> </span><span class="s7">0</span><span class="s1">..&lt;processedPhotos.</span><span class="s5">count</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> resizeOp = PhotoResizeOperation(resizer: resizer,<br/></span><span class="s1"><span class="Apple-converted-space">                                          </span>size: size,<br/></span><span class="s1"><span class="Apple-converted-space">                                          </span>photos: processedPhotos,<br/></span><span class="s1"><span class="Apple-converted-space">                                          </span>photoIndex: index)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span>generateBookOp.addDependency(resizeOp)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>processingQueue.addOperation(resizeOp)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>generateBookOp.completionBlock = { [weak generateBookOp] </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> pbURL = generateBookOp?.photobookURL </span><span class="s4">else</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">return<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span>OperationQueue.main.addOperation {<br/></span><span class="s1"><span class="Apple-converted-space">            </span>completion(pbURL)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>processingQueue.addOperation(generateBookOp)<br/></span><span class="s1">}</span></pre>&#13;
<p><span>Let's walk through the changes step by step:</span></p>&#13;
<ol>&#13;
<li><span class="s1">Where<span> </span>we were<span> </span><span>previously</span><span> </span>using a<span> </span><kbd>DispatchQueue</kbd><span> </span>to manage the execution of our blocks,</span><span> operation</span><span class="s1">s are now managed with an<span> </span><kbd>OperationQueue</kbd>:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">let</span><span class="s1"> processingQueue = </span><span class="s5">OperationQueue</span><span class="s1">()</span></pre>&#13;
<ol start="2">&#13;
<li>The<span> </span>method <span>signature in the following code and the dependencies we need to generate upfront remain the same:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">func</span><span class="s1"> generatePhotoBook(with photos: [</span><span class="s5">UIImage</span><span class="s1">], completion: </span><span class="s4">@escaping</span><span class="s1"> (</span><span class="s5">URL</span><span class="s1">) -&gt; </span><span class="s5">Void</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> resizer = PhotoResizer()<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> builder = PhotoBookBuilder()<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">// Get smallest common size<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> size = resizer.smallestCommonSize(for: photos)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> processedPhotos = </span><span class="s5">NSMutableArray</span><span class="s1">(array: photos)</span></pre>&#13;
<ol start="3">&#13;
<li>Next<span>, we create the operation to generate the photo book, passing in the dependencies:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">let</span><span class="s1"> generateBookOp = </span><span class="s8">GeneratePhotoBookOperation</span><span class="s1">(builder: builder, <br/>   photos: processedPhotos)</span></pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<ol start="4">&#13;
<li class="p1">Although the o<span class="s1">peration will be executed last, we create it first so that we can make it dependent on the resize operations we are about to create. An operation does not execute immediately upon creation. It will only execute when the <kbd>start()</kbd> method of <kbd>Operation</kbd> is called, which can be called manually, or, if an <kbd>Operation</kbd> is placed on an <kbd>OperationQueue</kbd>, it will be called by the queue as appropriate:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s4">for</span><span class="s1"> index </span><span class="s4">in</span><span class="s1"> </span><span class="s7">0</span><span class="s1">..&lt;processedPhotos.</span><span class="s5">count</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> resizeOp = PhotoResizeOperation(resizer: resizer,<br/></span><span class="s1"><span class="Apple-converted-space">                                        </span>size: size,<br/></span><span class="s1"><span class="Apple-converted-space">                                        </span>photos: processedPhotos,<br/></span><span class="s1"><span class="Apple-converted-space">                                        </span>photoIndex: index)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>generateBookOp.addDependency(resizeOp)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>processingQueue.addOperation(resizeOp)<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">Now, as you can see from the preceding code, we loop through the number of photos that we intend to process and create a resize operation for each, passing in the dependencies.</span></p>&#13;
<p class="p1"><span class="s1">With our move to use <kbd>Operation</kbd>, one thing we have lost is the use of <kbd>DispatchGroup</kbd>, which we used to ensure that we only generated the photo book once all the photo resize blocks had completed. We can, however, achieve the same goals using operation dependencies. An operation can be declared as dependent on a set of other operations, so it will not begin executing until the operations it depends on have finished. To ensure that the <kbd>generateBookOp</kbd> operation, which we just created, only executes when all the <kbd>PhotoResizeOperation</kbd> operations are complete, we add each of them as a dependency of <kbd>generateBookOp</kbd>.</span></p>&#13;
<p class="p1"><span class="s1">With this done, we can place each <kbd>PhotoResizeOperation</kbd> on the <kbd>OperationQueue</kbd>:</span></p>&#13;
<pre class="p4"><span class="s1">generateBookOp.completionBlock = { [weak generateBookOp] </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> pbURL = generateBookOp?.photobookURL </span><span class="s4">else</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">return<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>OperationQueue.main.addOperation {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>completion(pbURL)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="p1"><span class="s1"><kbd>Operation</kbd> has a <kbd>completionBlock</kbd> property; any block set here will be executed once the operation has completed. We can use this to fire our completion handler on the main queue. Since we need to provide the completion handler with the URL to the photo book created by <kbd>generateBookOp</kbd>, we can retrieve this from within the block, as we know that the operation will be finished and the URL will be there. However, we need to be careful. We are providing a closure to <kbd>generateBookOp</kbd>, which will be retained, and we are using, and therefore capturing and retaining, the <kbd>generateBookOp</kbd> operation in the same block. This will lead to a retain cycle, and <kbd>generateBookOp</kbd> will never get released from memory. To avoid this retain cycle, we specify that we want to weakly capture <kbd>generateBookOp</kbd> in the block we provide, using the <kbd>[weak generateBookOp]</kbd> <span>capture list. T</span>his won't increment the retain count, preventing the retain cycle from happening.</span></p>&#13;
<p class="p1"><span class="s1">Much like <kbd>DispatchQueue</kbd>, <kbd>OperationQueue</kbd> has an available property that provides a reference to the main queue, upon which the UI events are processed. Also, <kbd>OperationQueue</kbd> has a convenience method that will take a block of code, wrap it in an <kbd>Operation</kbd>, and add it to the queue. We use this to ensure that the completion handler is executed on the main queue:</span></p>&#13;
<pre class="p4"><span class="s1">processingQueue.addOperation(generateBookOp)</span></pre>&#13;
<p class="p1"><span class="s1">As the final step, we put the <kbd>generateBookOp</kbd> operation on the processing queue. It's important that we do this as the last step because, once placed on the queue, the operation may be executed immediately, but we don't want it executed immediately. We only want <kbd>generateBookOp</kbd> executed once all the resize operations are complete, and if we placed the operation on the queue before setting up the dependencies, this could happen.</span></p>&#13;
<p class="p1"><span class="s1">Now that we have transitioned our app over to using <kbd>Operation</kbd>, let's build and then run and verify that everything works just as it did before.</span></p>&#13;
<p class="p1"><span class="s1">Users<span> </span>of our photo book app currently do not have the ability to cancel the generation of a photo book once the process has started, so let's add that functionality:</span></p>&#13;
<ol>&#13;
<li class="p1"><span class="s1">We will examine our two operations and look for opportunities to check the<span> </span><kbd>isCancelled</kbd><span> </span>property and exit early. Switch to<span> </span><kbd>PhotoResizeOperation.swift</kbd><span> </span>and add<span> </span><kbd>isCancelled</kbd><span> </span>checks to the<span> </span><kbd>main()</kbd><span> </span>method:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1"><span class="s1"> </span><span class="s1">override</span><span class="s2"> </span><span class="s1">func</span><span class="s2"> main() {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">// Check if operation has been cancelled<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">guard</span><span class="s1"> isCancelled </span><span class="s4">==</span><span class="s1"> </span><span class="s3">false</span><span class="s1"> </span><span class="s3">else</span><span class="s1"> { </span><span class="s3">return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">guard</span><span class="s1"> </span><span class="s3">let</span><span class="s1"> photo = photos[photoIndex] </span><span class="s3">as</span><span class="s1">? </span><span class="s5">UIImage</span><span class="s1"> </span><span class="s3">else</span><span class="s1"> { </span><span class="s3">return</span><span class="s1"> }<br/></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">// Scale down (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">var</span><span class="s1"> photosForBook = resizer.scaleWithAspectFill(<br/>      [photo], to: size)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">// Check if operation has been cancelled<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">guard</span><span class="s1"> isCancelled </span><span class="s4">==</span><span class="s1"> </span><span class="s3">false</span><span class="s1"> </span><span class="s3">else</span><span class="s1"> { </span><span class="s3">return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">// Crop (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>photosForBook = resizer.centerCrop(photosForBook, to: size)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>photos[photoIndex] = photosForBook[</span><span class="s6">0</span><span class="s1">]<br/></span><span class="s1">}</span></pre>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">Before each piece of long-running work, we check the<span> </span><kbd>isCancelled</kbd><span> </span>property, and if it is<span> </span><kbd>true</kbd>, we return early, which will finish the operation.</span></p>&#13;
<ol start="2">&#13;
<li class="p1">We can do th<span class="s1">e same in<span> </span><kbd>GeneratePhotoBookOperation.swift</kbd>:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4"><span class="s1">override</span><span class="s2"> </span><span class="s1">func</span><span class="s2"> main() {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">// Check if operation has been cancelled<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">guard</span><span class="s1"> isCancelled </span><span class="s4">==</span><span class="s1"> </span><span class="s3">false</span><span class="s1"> </span><span class="s3">else</span><span class="s1"> { </span><span class="s3">return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s3">guard</span><span class="s1"> </span><span class="s3">let</span><span class="s1"> photos = photos </span><span class="s3">as</span><span class="s1">? [</span><span class="s5">UIImage</span><span class="s1">] </span><span class="s3">else</span><span class="s1"> { </span><span class="s3">return</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s1">// Generate PDF (can take a while)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>photobookURL = builder.buildPhotobook(with: photos)<br/></span><span class="s1">}</span></pre>&#13;
<ol start="3">&#13;
<li class="p1">Next, we will need t<span class="s1">o add some UI that allows the user to cancel the photo book generation once it is in progress. This is an exercise for the reader, or you can switch to the<span> </span><kbd>end-operations</kbd><span> </span><span>branch</span><span> </span>to see how I have implemented it.</span></li>&#13;
<li class="p1"><span class="s1">Once the user chooses to cancel generating a photo book, we can call the following command:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p6"><span class="s7">processingQueue</span><span class="s2">.</span><span class="s1">cancelAllOperations</span><span class="s2">()</span></pre>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">This will fire the<span> </span><kbd>cancel()</kbd><span> </span>method on all the operations in the queue.</span></p>&#13;
<p class="p1"><span class="s1">We now have an app with a cancelable, long-running operation.</span></p>&#13;
<h2 id="uuid-8f495bee-7bb7-48ef-92db-329d2e429dac" class="p1"><span class="s1">How it works...</span></h2>&#13;
<p class="p1"><span class="s1">How does <kbd>OperationQueue</kbd> know when to start an operation and when to remove it from the queue? It knows by monitoring</span> the operation's <span class="s1">state. The <kbd>Operation</kbd> class goes through a number of state transformations during its life cycle. The following diagram describes how these state transformations occur:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/225f9e07-2d51-4a5c-8cf6-89d829dc3212.jpg" style="" width="974" height="596"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 9.17 – Operation life cycle</span></div>&#13;
<p class="p1"><span class="s1">Information about the operation's state is exposed through a number of Boolean properties on <kbd>Operation</kbd>, and the operation queue uses the properties to know when to perform certain actions on the operations. Let's look at these properties one by one:</span></p>&#13;
<pre class="p4"><span class="s1"> </span><span class="s4">var</span><span class="s1"> isReady: </span><span class="s5">Bool</span></pre>&#13;
<p class="p1"><span class="s1">An operation will return <kbd>true</kbd> for <kbd>isReady</kbd> when all its dependencies are finished. If it doesn't have any dependencies, it will always return <kbd>true</kbd>. The queue will only start executing an operation if <kbd>isReady</kbd> is <kbd>true</kbd>:</span></p>&#13;
<pre class="p4"><span class="s1"> </span><span class="s4">var</span><span class="s1"> isExecuting: </span><span class="s5">Bool</span></pre>&#13;
<p class="p1"><span class="s1">Once <kbd>start</kbd> is called on an operation, either manually or by a queue, <kbd>isExecuting</kbd> will return <kbd>true</kbd>, and when the operation has finished executing, <kbd>isExecuting</kbd> will revert to returning <kbd>false</kbd>.</span></p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="p1"><span class="s1">Since operations remain on the queue until they have finished, the queue uses the <kbd>isExecuting</kbd> property to ensure that it doesn't call <kbd>start</kbd> on an operation that has already started:</span></p>&#13;
<pre class="p4"><span class="s1"> </span><span class="s4">var</span><span class="s1"> isFinished: </span><span class="s5">Bool</span></pre>&#13;
<p class="p1"><span class="s1">Once the operation has finished doing whatever processing is required, <kbd>isFinished</kbd> should return <kbd>true</kbd>. When <kbd>isFinished</kbd> starts to return <kbd>true</kbd>, it will be removed from the queue, and the queue will no longer maintain a reference to the operation. For the simplest implementation of <kbd>Operation</kbd>, as we implemented earlier, <kbd>isFinished</kbd> returns <kbd>true</kbd> automatically when the <kbd>main()</kbd> method has finished executing:</span></p>&#13;
<pre class="p4"><span class="s1"> </span><span class="s4">var</span><span class="s1"> isCancelled: </span><span class="s5">Bool</span></pre>&#13;
<p class="p1"><span class="s1">Operations can be canceled by calling the <kbd>cancel()</kbd> method on the operation. Once called, the <kbd>isCancelled</kbd> property will return true. This can be used to exit early from a long-running operation, but it is up to you to check the <kbd>isCancelled</kbd> method and interrupt any long-running code if it returns <kbd>true</kbd>.</span></p>&#13;
<h2 id="uuid-3aadee5f-e20c-40c1-8879-d8d16e29e2a7" class="p1">See also</h2>&#13;
<p><span class="s1">Documentation relating to the <kbd>Operation</kbd> class: <a href="http://swiftbook.link/docs/operation" target="_blank">http://swiftbook.link/docs/operation</a><a href="http://swiftbook.link/docs/operation" target="_blank"/></span></p>&#13;
&#13;
&#13;
            </article>&#13;
&#13;
            &#13;
        </section>&#13;
    </div></body></html>