<html><head></head><body><p>&#13;
&#13;
                            &#13;
                    Performance and Responsiveness in Swift&#13;
                &#13;
            &#13;
            &#13;
                &#13;
<p>We have covered a lot of ground in the previous chapters, and we have a lot of Swift tools in our tool belt. Now it's time to delve into more advanced topics, looking at how certain Swift types are implemented, how they can be used, and what their performance characteristics are. We will also look at how we can perform asynchronous tasks using <strong>Grand Central Dispatch</strong> (<strong>GCD</strong>) through the Dispatch framework and the higher-level operations in the Foundation framework that are also built on GCD.</p>&#13;
<p>Understanding the multithreaded environment available on all Apple platforms, as well as the performance profile of the Swift constructs you use, is vital to building a fast and responsive app.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Value and reference semantics</li>&#13;
<li>Using Dispatch queues for concurrency</li>&#13;
<li>Concurrent queues and dispatch groups</li>&#13;
<li>Implementing the operation class</li>&#13;
</ul>&#13;
<h1 id="uuid-5a84f63c-d1c1-4ae2-968a-38bc28f020ac">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3bn2l2O" target="_blank">https://bit.ly/3bn2l2O</a></p>&#13;
<h1 id="uuid-445af282-5b0b-4285-9ed9-5485876d13dc">Value and reference semantics</h1>&#13;
<p>We saw back in <a href="" target="_blank">Chapter 1</a>, <em>Swift Building Blocks</em>, that certain Swift types behave differently from others, specifically regarding ownership and the mutation of properties. We even defined this difference, saying that classes are <em>reference</em> types, while structs and enums are <em>value</em> types. In this recipe, we will examine why these types behave differently and the performance implications this entails.</p>&#13;
<p class="p1">Let's create the model for an app that allows a user to schedule events that they do every day and reminds them when these events should occur.</p>&#13;
<h2 id="uuid-a7324d6a-065d-431f-a26a-fdcf3781cf79">Getting ready</h2>&#13;
<p class="p1">We need to decide how we will model our daily event. The key to this decision is whether we want our event to have reference semantics or value semantics. We discussed the differences between the two in <a href="f9d48715-ffca-464f-95bf-722958f02e72.xhtml" target="_blank">Chapter 1</a>, <em>Swift Building Blocks</em>, but let's re-examine the differences.</p>&#13;
<p class="p1"><em>Value</em> types are simple data structures that you can think of as just bundles of data. Swift makes these types more useful by allowing them to have methods, but any change or <em>mutation</em> of the underlying data results in a whole new bundle of data. In contrast, <em>reference</em> types are more complex data structures that have an identity outside of their component properties. Therefore, a change in the component properties will be available via any references to the object.</p>&#13;
<p class="p1">A value type's simple composition has the advantage of being very cheap on resources to create and maintain. However, this simplicity comes at the expense of dynamic dispatch, which enables sub-classing.</p>&#13;
<h2 id="uuid-bee9be7a-e6ef-4138-bd93-a62157c42b01">How to do it...</h2>&#13;
<p class="p1">Given this distinction, what behavior do we want for our daily event? If we change the name of our event, should we expect anything that has a reference to it to also see that change? That sounds like the behavior we want, so our daily event should be a reference type:</p>&#13;
<pre class="p3">class DailyEvent {<br/>    var name: String<br/>    <br/>    init(name: String) {<br/>        self.name = name<br/>    }<br/>}</pre>&#13;
<p class="p1">Let's check that this gives us the behavior we expect:</p>&#13;
<pre class="p3">var event1 = DailyEvent(name: "have bath")<br/>var event2 = event1<br/>print("Event 1 - \(event1.name)") // have bath<br/>print("Event 2 - \(event2.name)") // have bath<br/>event1.name = "have shower"<br/>print("Event 1 - \(event1.name)") // have shower<br/>print("Event 2 - \(event2.name)") // have shower</pre>&#13;
<p class="p1">We want to be reminded of our event every day at a certain time, but for our purpose, <kbd>Date</kbd> in <kbd>Foundation</kbd> is a bit of an overkill, since it contains both date and time information, and we only need to maintain time information. Let's create something to represent the time, irrespective of the date. What behavior is most appropriate for our time model? Should it have reference semantics or type semantics?</p>&#13;
<p class="p1">Let's try both and see which seems to most accurately model the situation we are after:</p>&#13;
<ol>&#13;
<li>We'll create time as a class, with reference semantics:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">class ClockTime {<br/>    var hours: Int<br/>    var minutes: Int<br/>    <br/>    init(hours: Int, minutes: Int) {<br/>        self.hours = hours<br/>        self.minutes = minutes<br/>    }<br/>}</pre>&#13;
<ol start="2">&#13;
<li>Now, let's see how this will behave when its properties are changed:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">let defaultEventTime = ClockTime(hours: 6, minutes: 30)<br/>var event1Time = defaultEventTime // 6:30<br/>var event2Time = defaultEventTime // 6:30<br/>// Event 2 has been moved to 9:30<br/>event2Time.hours = 9<br/>print("Event 1 - \(event1Time.hours):\(event1Time.minutes)") <br/>  // Event 1 - 9:30<br/>print("Event 2 - \(event2Time.hours):\(event2Time.minutes)")<br/>  // Event 2 - 9:30</pre>&#13;
<p style="padding-left: 60px">When we change the properties of an instance of <kbd>ClockTime</kbd>, it has the unintended consequence of changing all references to that same instance of <kbd>ClockTime</kbd>. Since reference semantics aren't a perfect fit for <kbd>ClockTime</kbd>, let's change it to a value type and see whether that is more appropriate.</p>&#13;
<ol start="3">&#13;
<li>We now have two options for value types in Swift; we can model <kbd>ClockTime</kbd> as a <kbd>struct</kbd> or an <kbd>enum</kbd>. Enums are great for modeling concepts that have a small number of finite values. While there are a finite number of minutes in a day, it's not a small number, and we might want to do math calculations on the hours and minutes in <kbd>ClockTime</kbd>, so a <kbd>struct</kbd> is more appropriate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">struct ClockTime {<br/>    var hours: Int<br/>    var minutes: Int<br/>}</pre>&#13;
<ol start="4">&#13;
<li>Let's see how this changes the behavior when we change the properties of a <kbd>ClockTime</kbd> instance:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">let defaultEventTime = ClockTime(hours: 6, minutes: 30)<br/>var event1Time = defaultEventTime // 6:30<br/>var event2Time = defaultEventTime // 6:30<br/>// Event 2 has been moved to 9:30<br/>event2Time.hours = 9<br/>print("Event 1 - \(event1Time.hours):\(event1Time.minutes)") // Event 1 - 6:30<br/>print("Event 2 - \(event2Time.hours):\(event2Time.minutes)") // Event 2 - 9:30</pre>&#13;
<p style="padding-left: 60px">With <kbd>ClockTime</kbd> as a value type, changing a property of a <kbd>ClockTime</kbd> instance results in a new instance, so the change doesn't have the unintended consequences that we saw when it was a reference type.</p>&#13;
<p style="padding-left: 60px">Lastly, let's consider some of the dynamic features that we will give up by making <kbd>ClockTime</kbd> a value type. Will we ever want to subclass <kbd>ClockTime</kbd>? This doesn't seem likely, and it is right to characterize <kbd>ClockTime</kbd> as a simple bundle of data. So, in this scenario, modeling <kbd>ClockTime</kbd> as a value type is the right decision.</p>&#13;
<ol start="5">&#13;
<li>To complete the model, we will add a <kbd>ClockTime</kbd> property to the <kbd>DailyEvent</kbd> class:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">class DailyEvent {<br/>    var name: String<br/>    var time: ClockTime<br/>    <br/>    init(name: String, time: ClockTime) {<br/>        self.name = name<br/>        self.time = time<br/>    }<br/>}</pre>&#13;
<h2 id="uuid-ea1e3aa2-d473-4072-8d3b-cbfb34d4f580" class="p1">How it works...</h2>&#13;
<p class="p1">We've already covered how value types differ from reference types. Now, let's examine why they behave differently.</p>&#13;
<p class="p1">When storing new instances of a type in memory, Swift has two different data structures that it can use for storage: the <strong>Stack</strong> and the <strong>Heap</strong>. These structures are common to many programming languages. Value types are stored on the <strong>Stack</strong>, and reference types are stored on the <strong>Heap</strong><strong>.</strong> Understanding how data is stored in these structures, even at the superficial level that we will cover, will help us to understand why value types and reference types have differing behaviors.</p>&#13;
<p class="p1">The stack can be thought of as sequential blocks of data. An instance of a type may be represented by multiple blocks of data, and an instance can be referenced using the memory position of its first piece of data. A <strong>Stack Pointer</strong>, which is a reference to the memory position at the end of the stack, is maintained. New instances are always added to the end of the stack, and then the stack pointer's position is updated to the new end of the stack.</p>&#13;
<p class="p1">Let's go through adding a value type instance using a simplified diagram of the stack. Before anything is added, the stack pointer is at the top of the stack:</p>&#13;
<div><img src="img/a3981653-ae39-4677-87e0-ec80787be9e2.jpg" style="" width="483" height="497"/></p>&#13;
<p>Figure 9.1 – Representation of the stack and stack pointer</p>&#13;
<p class="p1">A <kbd>ClockTime</kbd> struct for 07:00 is added to the stack. This takes up three blocks, and the stack pointer moves to the next empty block on the stack:</p>&#13;
<div><img src="img/aa8bb748-2db5-48e2-82e3-06b4eacb04f2.jpg" style="" width="487" height="491"/></div>&#13;
<p>Figure 9.2 – Stack pointer after adding a ClockTime struct for 7:00</p>&#13;
<p class="p1">Another <kbd>ClockTime</kbd> struct for 09:30 is added to the stack. This has a size of four blocks, and the stack pointer moves to the next empty block on the stack:</p>&#13;
<div><img src="img/91818305-f75d-4005-b9ba-3637859a4a6a.jpg" style="" width="480" height="491"/></div>&#13;
<p>Figure 9.3 – Stack pointer after adding a ClockTime struct for 9:30</p>&#13;
<p class="p1">Once data is placed on the stack, it is immutable. To see why this is an important restriction, let's try and change our first <kbd>ClockTime</kbd> instance on the stack. The simplicity and efficiency of the stack is predicated on the fact that it is a continuous block of memory. If we try and change any data already on the stack, it may take up more space, which will cause data in the subsequent blocks to be overwritten:</p>&#13;
<div><img src="img/fad6256b-de25-4ba5-8cef-a21b203ba00f.jpg" style="" width="481" height="494"/></div>&#13;
<p>Figure 9.4 – Changing the first ClockTime instance on the stack</p>&#13;
<p class="p1">Therefore, any change to a <kbd>struct</kbd> results in a new, changed version of the <kbd>struct</kbd> appended at the end of the stack.</p>&#13;
<p>Let's mutate a <kbd>ClockTime</kbd> instance and see how that looks in our simplified stack representation by taking it step by step:</p>&#13;
<ol>&#13;
<li>&#13;
<p class="p1">We have a <kbd>ClockTime</kbd> struct for 9:00 assigned to the variable named <kbd>event1Time</kbd>:</p>&#13;
</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">var event1Time = ClockTime(hours: 9, minutes: 0)</pre>&#13;
<p style="padding-left: 60px">See the following diagram for a visual representation of how this may look:</p>&#13;
<div><img src="img/d0ac446d-b30a-44ed-bfa7-9f7304a5fe25.jpg" style="" width="659" height="514"/></div>&#13;
<p>Figure 9.5 – Assigning the event1Time variable to a ClockTime struct for 09:00</p>&#13;
<ol start="2">&#13;
<li class="p1">The value of <kbd>event1Time</kbd> is also assigned to a new variable, called <kbd>event2Time</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p3">var event2Time = event1Time</pre>&#13;
<div><img src="img/171561e4-439a-48ae-b392-ed8dccf7ed6b.jpg" style="" width="674" height="537"/></div>&#13;
<p>Figure 9.6 – Assigning the value of event1Time to event2Time</p>&#13;
<ol start="3">&#13;
<li class="p1">When we mutate <kbd>event2Time</kbd>, changing the minute value to <kbd>30</kbd>, a new <kbd>ClockTime</kbd> instance with the changed minute value is placed at the end of the stack:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p6">event2Time.minutes = 30</pre>&#13;
<div><img src="img/5a7b80e6-e41f-41bd-a1f7-69b005a4543f.jpg" style="" width="656" height="521"/></div>&#13;
<p>Figure 9.7 – The new ClockTime instance placed at the end of the stack</p>&#13;
<p style="padding-left: 60px" class="p1">The <kbd>event2Time</kbd> variable now points to this new stack position, while <kbd>event1Time</kbd> continues to point to the stack position of the original <kbd>ClockTime</kbd> struct for 09:00.</p>&#13;
<p class="p1">As the preceding examples show, the stack is a very simple and efficient data structure, and its properties explain the behavior we see when we use value types such as <kbd>struct</kbd> and <kbd>enums</kbd>.</p>&#13;
<p class="p1">In contrast, reference types, such as class objects, are stored on the heap, which enables more dynamic and complex behavior at the expense of efficiency.</p>&#13;
<p class="p1">An accurate look at heap allocations is beyond the scope of this book, but let's take a very simplified look at how a reference type instance is stored on the <strong>Heap</strong>. The heap is not a continuous chain of blocks, but an area of memory that can be free or already allocated:</p>&#13;
<div><img src="img/699c254b-0e9e-4cda-a47e-b0642d70f6a8.jpg" style="" width="890" height="512"/></div>&#13;
<p>Figure 9.8 – Representation of the heap</p>&#13;
<p class="p1">When a class is allocated to the heap, it must search through the heap to find a set of free blocks appropriate for its size. The reference type instance may include references to other reference types or value types by storing their stack positions:</p>&#13;
<div><img src="img/b397d89e-dcc4-4bfd-b03a-1e23c1898178.jpg" style="" width="947" height="507"/></div>&#13;
<p>Figure 9.9 – Allocation of a class in the heap</p>&#13;
<p class="p1">Multiple variables can hold references to the same instance:</p>&#13;
<div><img src="img/58e4a2b8-89de-4e90-9d73-1b0db7cbd05c.jpg" style="" width="953" height="520"/></div>&#13;
<p>Figure 9.10 – Multiple variables holding references to the same instances</p>&#13;
<p class="p1">When reference types are modified, they aren't copied. Instead, extra space must be found to accommodate the extra information. All references to the instance have the changed information:</p>&#13;
<div><img src="img/bf8452ee-3324-439e-a907-4244a9233cee.jpg" style="" width="956" height="518"/></div>&#13;
<p>Figure 9.11 – Modifying reference types</p>&#13;
<p class="p2">This recipe describes the difference between reference semantics and value semantics, and hopefully illustrates that these behaviors arise from the way in which they are stored in memory.</p>&#13;
<p class="p2">Both have their uses, and it's important to choose the right type when building your model.</p>&#13;
<h2 id="uuid-0cf498d5-5621-43ec-9b40-20dff1e8301f">See also</h2>&#13;
<p><strong>Swift blog</strong>: Value and reference types: <a href="http://swiftbook.link/blog/type-semantics" target="_blank">http://swiftbook.link/blog/type-semantics</a><a href="http://swiftbook.link/blog/type-semantics" target="_blank"/></p>&#13;
<p><strong>Apple Developer Videos (developer account needed)</strong>:</p>&#13;
<ul>&#13;
<li>WWDC 2016 - Protocol and Value-Oriented Programming in UIKit Apps: <a href="https://developer.apple.com/videos/play/wwdc2016/419" target="_blank">https://developer.apple.com/videos/play/wwdc2016/419</a><a href="https://developer.apple.com/videos/play/wwdc2016/419" target="_blank"/></li>&#13;
</ul>&#13;
<h1 id="uuid-529f03eb-ec53-46c5-affa-511b1a3360c8">Using Dispatch queues for concurrency</h1>&#13;
<p class="p1">We live in a multicore computing world. Multicore processors are found in everything, from our laptops and mobile phones to our watches. With these multiple cores comes the ability to work in parallel. These concurrent streams of work are known as <em>threads</em>, and programming in a multithreaded way enables your code to make the best use of the processor's cores. Deciding how and when to create new threads and manage the available resources are complex tasks, so Apple has built a framework to do the hard work for us. It is called <em>Grand Central Dispatch</em>.</p>&#13;
<p class="p1"><strong>Grand Central Dispatch</strong> (<strong>GCD</strong>) handles the thread maintenance and monitors the available resources while providing a simple, queue-based interface for getting concurrent work done. With the open-sourcing of Swift, Apple also open-sourced GCD in the form of <kbd>libdispatch</kbd>, since Swift does not yet have built-in concurrency features.</p>&#13;
<p class="p1">In this recipe, we will explore some of the features of <kbd>libdispatch</kbd>, also known as the Dispatch framework, and see how we can use concurrency to build apps that are efficient and responsive.</p>&#13;
<h2 id="uuid-94cb68cb-0a4f-4583-a332-d555bb8ab55c" class="p1">Getting ready</h2>&#13;
<p class="p1">We will see how we can improve the responsiveness of an app using GCD, so first, we need to start with an app that requires some improvement. Go to <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups</a>. Here, you will find the repository of an app that takes a collection of photos and turns them into a PDF photo book. You can download the app source files directly from GitHub or by using <kbd>git</kbd>:</p>&#13;
<pre class="p3"><strong>git clone https://github.com/PacktPublishing/Swift-Cookbook-Second-<br/>Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups/<br/></strong><strong>PhotobookCreator.git</strong></pre>&#13;
<p class="p1">If you build and run the app, you will see a collection of sample images, with the ability to add more:</p>&#13;
<div><img src="img/2dbb1d24-5525-4173-9c7c-10b3bbe95ec1.png" style="" width="744" height="1327"/></div>&#13;
<p>Figure 9.12 – Sample images</p>&#13;
<p class="p1">When you tap on Generate Photo Book, the app will take the photos you have chosen, resize them to the same size, and save them as a multi-page PDF that can then be exported or shared. Depending on how many photos are included and the performance of the device, this process can take a little time to complete. During this time, the whole interface is unresponsive; for example, you can't scroll through the pictures.</p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<h2 id="uuid-dd754f35-dc5f-4fcb-82a9-54fd579bc33d" class="p1">How to do it...</h2>&#13;
<p>Let's examine why the app is unresponsive during photo book generation and how we can fix this:</p>&#13;
<ol>&#13;
<li>Open up the <kbd>PhotoBookCreator</kbd> project and navigate to <kbd>PhotoCollectionViewController.swift</kbd>. In this file, you will find the following method:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">func generatePhotoBook(with photos: [UIImage]) {<br/>    <br/>    let resizer = PhotoResizer()<br/>    let builder = PhotoBookBuilder()<br/>    <br/>    // Scale down (can take a while)<br/>    var photosForBook = resizer.scaleToSmallest(of: photos)<br/>    // Crop (can take a while)<br/>    photosForBook = resizer.cropToSmallest(of: photosForBook)<br/>    // Generate PDF (can take a while)<br/>    let photobookURL = builder.buildPhotobook(with:  <br/>       photosForBook)<br/>    <br/>    let previewController = UIDocumentInteractionController(url: <br/>      photobookURL)<br/>    previewController.delegate = self<br/>    previewController.presentPreview(animated: true)<br/>}</pre>&#13;
<p style="padding-left: 60px">In this method, we call three functions that can take quite a long time to complete. We take the output of one function and feed it into the next function, and the result is a URL for our photo book, which we then launch with some UI to preview and export.</p>&#13;
<p style="padding-left: 60px" class="mce-root">This work to resize and crop the photos, and then generate the photo book, is taking place in the same queue where UI touch events are processed, the main queue, which is why our UI is unresponsive.</p>&#13;
<ol start="2">&#13;
<li class="mce-root">To free up the main queue for UI events, we can create our own private queue, which we can use to execute our long-running functions:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">import Dispatch<br/><br/>class PhotoCollectionViewController: UIViewController {<br/>    //...<br/>    let processingQueue = DispatchQueue(label: "Photo processing <br/>      queue")<br/>    <br/>    func generatePhotoBook(with photos: [UIImage]) {<br/>        <br/>        processingQueue.async { [weak self] in<br/><br/>            let resizer = PhotoResizer()<br/>            let builder = PhotoBookBuilder()            <br/><br/>            // Get smallest common size<br/>            let size = resizer.smallestCommonSize(for: photos)<br/> <br/>            // Scale down (can take a while)<br/>            var photosForBook = resizer.scaleWithAspectFill(photos, <br/>              to: size)<br/>                                                                   <br/>            // Crop (can take a while)<br/>            photosForBook = resizer.centerCrop(photosForBook, to: <br/>              size)<br/>            // Generate PDF (can take a while)<br/>            let pbURL = builder.buildPhotobook(with: photosForBook)<br/>            <br/>            // Show preview with export options<br/>            let previewController = <br/>              UIDocumentInteractionController(url: pbURL)<br/>                                                                  <br/>            previewController.delegate = self<br/>            previewController.presentPreview(animated: true)<br/>        }<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">By calling the <kbd>async</kbd> method on our <kbd>DispatchQueue</kbd> and providing a block of code, we are scheduling that block to be executed. GCD will execute that block when resources are available. Now, our long-running code isn't blocking the main queue, so our UI will remain responsive; however, if you were to run the app with just this change, you would get some very odd behavior when the app tried to show the preview view controller.</p>&#13;
<p style="padding-left: 60px" class="p1">We just discussed the fact that UI touch events are delivered to the main queue, which is why we wanted to avoid blocking it; however, <kbd>UIKit</kbd> expects <em>all</em> UI events to happen on the main queue. Since we are currently creating and presenting the preview view controller from our private queue, we are defying this <kbd>UIKit</kbd> expectation, which can produce a number of bugs, including UI elements that never appear, or appear long after they were presented.</p>&#13;
<ol start="3">&#13;
<li>To solve this problem, we need to ensure that when we are ready to present our UI, we do that operation on the main queue:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">func generatePhotoBook(with photos: [UIImage], using builder:  <br/>  PhotoBookBuilder) {<br/>    <br/>    processingQueue.async { [weak self] in<br/><br/>        let resizer = PhotoResizer()<br/>        let builder = PhotoBookBuilder()        <br/><br/>        // Get smallest common size<br/>        let size = resizer.smallestCommonSize(for: photos)<br/> <br/>        // Scale down (can take a while)<br/>        var photosForBook = resizer.scaleWithAspectFill(photos, to: <br/>          size)<br/>        // Crop (can take a while)<br/>        photosForBook = resizer.centerCrop(photosForBook, to: size)<br/>        // Generate PDF (can take a while)<br/>        let pbURL = builder.buildPhotobook(with: photosForBook)<br/>        <br/>        DispatchQueue.main.async {<br/>          // Show preview with export options<br/>          let previewController = UIDocumentInteractionController<br/>            (url: pbURL)<br/>          previewController.delegate = self<br/>          previewController.presentPreview(animated: true)<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="p1">Now, if you run the app, you will find that you can generate a photo book while still being able to interact with the UI; for instance, being able to scroll the table view.</p>&#13;
<h2 id="uuid-7c57d742-9656-4fa2-a6ef-f63fec369d84" class="p1">How it works...</h2>&#13;
<p class="p1">GCD uses queues to manage blocks of work in a multithreaded environment. Queues operate on a <strong>first in first out</strong> (<strong>FIFO</strong>) policy. When GCD determines that resources are available, it will take the next block from the queue and execute it. Once the block has finished executing, it will be removed from the queue:</p>&#13;
<div><img src="img/e89ccaf5-a5e4-44f1-b15f-6d0e8d94b819.jpg" width="920" height="250"/></div>&#13;
<p>Figure 9.13 – FIFO policy</p>&#13;
<p class="p1">There are two types of <kbd>DispatchQueue</kbd>: <em>serial</em> and <em>concurrent</em>. With the simplest form of a queue, a serial queue, GCD will only execute one block at a time from the top of the queue. When each block finishes executing, it is removed from the queue, and each block moves up one position.</p>&#13;
<p class="p1">The main queue, which processes all UI events, is an example of a serial queue, and this explains why performing a long-running operation on the main queue will cause your UI to become unresponsive. While your long-running operation is executing, nothing else on the main queue will be executed until the long-running operation has finished.</p>&#13;
<p class="p1">With the second type of queue, a concurrent queue, GCD will execute as many blocks on different threads as resources allow. The next block to execute will be the block closest to the top of the stack that isn't already executing, and blocks are removed from the stack when finished:</p>&#13;
<div><img src="img/82170dbe-0af1-4bbb-89c3-1d883a108df9.jpg" width="976" height="246"/></div>&#13;
<p>Figure 9.14 – Execution when the second type of queue is added</p>&#13;
<p class="p1">Concurrent queues can be really useful when you have numerous operations that are independent of each other. We will look into concurrent queues further in the <em>Concurrent queues and dispatch groups</em> recipe.</p>&#13;
<h2 id="uuid-6cca379b-56d3-4c58-b582-067de366ed70" class="p1">See also</h2>&#13;
<ul>&#13;
<li class="p1">The GitHub repository for <kbd>libdispatch</kbd>: <a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank">https://github.com/apple/swift-corelibs-libdispatch</a><a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank"/></li>&#13;
<li class="p1">Documentation for dispatch queues: <a href="http://swiftbook.link/docs/dispatchqueue" target="_blank">http://swiftbook.link/docs/dispatchqueue</a><a href="https://developer.apple.com/reference/dispatch/dispatchqueue"/></li>&#13;
</ul>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<h1 id="uuid-5d725205-5e23-42ae-b822-bce5deb3c26d">Concurrent queues and dispatch groups</h1>&#13;
<p class="p1">In the previous recipe, we looked into using a private serial queue to keep our app responsive by moving long-running operations off the main queue. In this recipe, we will break our operations down into smaller, independent blocks and place them on a concurrent queue.</p>&#13;
<h2 id="uuid-9c0be820-a29d-46ba-ab1f-0efa41fc26a1" class="p1">Getting ready</h2>&#13;
<p class="p1">We are going to build on the app we improved in the last recipe, which is an app that will produce a PDF photo book from a collection of photos. You can get the code for this app at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09</a> and choose the <kbd>PhotobookCreator_DispatchGroups</kbd> folder.</p>&#13;
<p class="p1">Open the project in XCode and navigate to the <kbd>PhotoCollectionViewController.swift</kbd> file.</p>&#13;
<h2 id="uuid-f7e54e56-b84a-4a45-b81f-e1d0915f7d47" class="p1">How to do it...</h2>&#13;
<p class="p1">We saw in the last recipe how dispatch queues operate on a FIFO policy. GCD will execute a block from the top of the queue and remove it from the queue when it has finished executing. The number of blocks that GCD will allow to execute at the same time will depend on the type of queue being used. <em>Serial</em> queues will only have one block of code being executed at any time; other blocks in the queues will have to wait until the block at the top of the queue has finished executing. However, for a <em>concurrent</em> queue, GCD will concurrently execute as many blocks as there are resources available. We can make more efficient use of a concurrent queue by breaking down the work into smaller, independent blocks, allowing them to be executed concurrently.</p>&#13;
<p class="p1">Take a look at the current implementation of the <kbd>generatePhotoBook</kbd> method. The only thing that has changed since the last recipe is that we now present the preview UI within a completion that is passed to the <kbd>generatePhotoBook</kbd> method. This simplifies the method and prevents us from needing to weakly capture <kbd>self</kbd> within the <kbd>async</kbd> block:</p>&#13;
<pre class="p4">func generatePhotoBook(with photos: [UIImage], completion: @escaping <br/>  (URL) -&gt; Void) {<br/>    <br/>    processingQueue.async {<br/>        <br/>        let resizer = PhotoResizer()<br/>        let builder = PhotoBookBuilder()<br/>        <br/>        // Get smallest common size<br/>        let size = resizer.smallestCommonSize(for: photos)<br/>        <br/>        // Scale down (can take a while)<br/>        var photosForBook = resizer.scaleWithAspectFill(photos, <br/>          to: size)<br/>        // Crop (can take a while)<br/>        photosForBook = resizer.centerCrop(photosForBook, to: size)<br/>        // Generate PDF (can take a while)<br/>        let photobookURL = builder.buildPhotobook(with: photosForBook)<br/>        <br/>        DispatchQueue.main.async {<br/>            // Fire completion handler which will show the preview UI<br/>            completion(photobookURL)<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="p1">The work we are doing is in one block of code that we place on a queue. Let's see whether we can break this down into smaller, independent pieces of work that can be executed concurrently. We can't perform the scale and crop operations concurrently, as they will be operating on the same <kbd>UIImage</kbd> objects, and we will not get the intended result if the image is cropped before it's scaled.</p>&#13;
<p class="p1">However, we can apply the scale and crop operation to each photo separately and perform that operation concurrently on the other photos. Once each photo has been scaled and cropped, we can use the processed images to generate the photo book:</p>&#13;
<div><img src="img/737635fd-c762-486f-ac2c-9e117e86421c.jpg" style="" width="942" height="810"/></div>&#13;
<p>Figure 9.15 – Serial approach and concurrent approach</p>&#13;
<p>Splitting the work up in this way may not make the overall operation faster, as there is an overhead to each block of work. The efficiency improvement of dividing the work into concurrent blocks will depend on the operation involved, and how many concurrent operations can run.</p>&#13;
<p class="p1">We now have blocks of work that can run concurrently, but we have given ourselves a new problem; how do we coordinate all these concurrent pieces of work so that we know they are all completed and we can start generating the photo book? Here, GCD can help us. We can use a <kbd>DispatchGroup</kbd> to coordinate our operations on each of the images and be notified when they are all completed.</p>&#13;
<p class="p1">A dispatch group is like a turnstile at a stadium. Every time someone enters the stadium, they pass through the turnstile, and one extra person is counted as being in the stadium, and at the end of the day, as people leave the stadium and pass through the turnstile, the number of people in the stadium decreases. Once there is no one left in the stadium, the lights can be turned off.</p>&#13;
<p class="p1">Let's use a dispatch group to coordinate the work of our photo book creator:</p>&#13;
<ol>&#13;
<li>First, we will create a dispatch group:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">let group = DispatchGroup()</pre>&#13;
<ol start="2">&#13;
<li>Every time we start a blockwork to resize a photo, we will enter the group:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">group.enter()</pre>&#13;
<ol start="3">&#13;
<li>Once the work is finished, we will leave the group:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">group.leave()</pre>&#13;
<ol start="4">&#13;
<li>Finally, we will ask the group to notify us when the last resize operation has finished and left the group. Then, we can take the processed files and generate the photo book:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">group.notify(queue: processingQueue) {<br/>    //.. generate photo book<br/>    //.. execute completion handler<br/>}</pre>&#13;
<ol start="5">&#13;
<li>Let's take a look at our <kbd>generatePhotoBook</kbd> method, now using a concurrent queue and dispatch groups:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">let processingQueue = DispatchQueue(label: "Photo processing <br/>  queue", attributes: .concurrent)<br/><br/>func generatePhotoBook(with photos: [UIImage], completion: @escaping <br/>  (URL) -&gt; Void) {<br/>    <br/>    let resizer = PhotoResizer()<br/>    let builder = PhotoBookBuilder()<br/>    <br/>    // Get smallest common size<br/>    let size = resizer.smallestCommonSize(for: photos)<br/>    <br/>    let processedPhotos = NSMutableArray(array: photos)<br/>    <br/>    let group = DispatchGroup()<br/>    <br/>    for (index, photo) in photos.enumerated() {<br/>        <br/>        group.enter()<br/>        <br/>        processingQueue.async {<br/>            <br/>            // Scale down (can take a while)<br/>            var photosForBook = resizer.scaleWithAspectFill(<br/>              [photo], to: size)<br/>            // Crop (can take a while)<br/>            photosForBook = resizer.centerCrop([photo], to: size)<br/>            <br/>            // Replace original photo with processed photo<br/>            processedPhotos[index] = photosForBook[0]<br/>            <br/>            group.leave()<br/>        }<br/>    }<br/>    <br/>    group.notify(queue: processingQueue) {<br/>        <br/>        guard let photos = processedPhotos as? [UIImage] else { <br/>          return }<br/>        <br/>        // Generate PDF (can take a while)<br/>        let photobookURL = builder.buildPhotobook(with: photos)<br/>        <br/>        DispatchQueue.main.async {<br/>            completion(photobookURL)<br/>        }<br/>    }<br/>}</pre>&#13;
<h2 id="uuid-a3cec24b-fafe-4a68-bce3-b2104ca5b899" class="p1">How it works...</h2>&#13;
<p class="p1">Dispatch queues are serial by default, so to create a concurrent queue instead, we pass the <kbd>.concurrent</kbd> attribute when it is created:</p>&#13;
<pre class="p4">let processingQueue = DispatchQueue(label: "Photo processing queue", <br/>                                    attributes: .concurrent)</pre>&#13;
<p class="p1">Before we loop through all the photos, we set up anything that isn't specific to each photo:</p>&#13;
<pre class="p1">let resizer = PhotoResizer()<br/>let builder = PhotoBookBuilder()<br/>// Get smallest common size<br/>let size = resizer.smallestCommonSize(for: photos)<br/>let processedPhotos = NSMutableArray(array: photos)<br/>let group = DispatchGroup()</pre>&#13;
<p class="p1">This includes creating the <kbd>DispatchGroup</kbd>, which we will use to coordinate the work. Since our photo resizing will now be happening concurrently, we need a place to collect the photos once they have been processed. We can use a Swift array for this; however, a Swift array is a value type, so we can't use it from within multiple blocks, as each block will be taking a copy of the array, not the original array itself.</p>&#13;
<p class="p1">To solve this with a Swift array, we would need to make the <kbd>processedPhotos</kbd> array property on the view controller, which would mean we would have to weakly capture self in the blocks that we would need to unwrap. A simpler way to solve this problem is to use a collection that has reference semantics; the <kbd>Foundation</kbd> framework provides that in the form of <kbd>NSArray</kbd> and <kbd>NSMutableArray</kbd>. As we saw earlier in this chapter, it's important to understand the semantics of the construct being used and pick the right tool for the right job:</p>&#13;
<pre class="p1">for (index, photo) in photos.enumerated() {<br/>    <br/>    group.enter()<br/>    <br/>    processingQueue.async {<br/>        <br/>        // Scale down (can take a while)<br/>        var photosForBook = resizer.scaleWithAspectFill([photo], <br/>          to: size)<br/>        // Crop (can take a while)<br/>        photosForBook = resizer.centerCrop([photo], to: size)<br/>        <br/>        // Replace original photo with processed photo<br/>        processedPhotos[index] = photosForBook[0]<br/>        <br/>        group.leave()<br/>    }<br/>}</pre>&#13;
<p class="p1">For each photo, we enter the group and place the resize work on the concurrent queue. We can use the same scale and crop methods that we used previously, just passing an array containing one photo. Once the work is completed, we'll replace the original photo with the processed photo in the array and leave the group.</p>&#13;
<p>Once every block has left the group, this <kbd>notify</kbd> block will execute. We retrieve the processed photos and use them to generate the photo book. Finally, we ensure that the completion handler is executed on the main queue:</p>&#13;
<pre class="p1">group.notify(queue: processingQueue) {<br/>    <br/>    guard let photos = processedPhotos as? [UIImage] else { return }<br/>    <br/>    // Generate PDF (can take a while)<br/>    let photobookURL = builder.buildPhotobook(with: photos)<br/>    <br/>    DispatchQueue.main.async {<br/>        completion(photobookURL)<br/>    }<br/>}</pre>&#13;
<p class="p1">If you build and run the app, you can still generate a photo book and the UI is still responsive, and now GCD can make the best use of the available resources to generate our photo book.</p>&#13;
<h2 id="uuid-4baa5988-1f6e-480f-91ec-a8047173457f" class="p1">See also</h2>&#13;
<ul>&#13;
<li class="p1">Documentation relating to dispatch queues: <a href="http://swiftbook.link/docs/dispatchqueue" target="_blank">http://swiftbook.link/docs/dispatchqueue</a><a href="http://swiftbook.link/docs/dispatchqueue" target="_blank"/></li>&#13;
<li class="p1">Documentation relating to dispatch groups: <a href="http://swiftbook.link/docs/dispatchgroup" target="_blank">http://swiftbook.link/docs/dispatchgroup</a><a href="http://swiftbook.link/docs/dispatchgroup" target="_blank"/></li>&#13;
</ul>&#13;
<h1 id="uuid-323cf47f-6b74-414c-bc1b-ed6db244a7eb" class="p1">Implementing the operation class</h1>&#13;
<p class="p1">In this chapter so far, we have taken our long-running operations and scheduled them as blocks of code, called <strong>closures</strong>, on dispatch queues. This has made it really easy to move long-running code off of the main queue, but if we intend to reuse this long-running code, pass it around, track its state, and generally deal with it in an object-orientated way, a closure is not ideal.</p>&#13;
<p class="p1">To solve this, the <kbd>Foundation</kbd> framework provides an object, <kbd>Operation</kbd>, that allows us to wrap up our block of work within an encapsulated object.</p>&#13;
<p class="p1">In this recipe, we will take the photo book app we used throughout this chapter and convert our long-running blocks to an <kbd>Operation</kbd> instance.</p>&#13;
<h2 id="uuid-a4e0672f-b184-4ff3-9b0c-ed1ff0954183" class="p1">Getting ready</h2>&#13;
<p class="p1">We are going to build on the app we improved in the last recipe, which is an app that will produce a PDF photo book from a collection of photos. You can get the code for this app at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09</a> and choose the <kbd>PhotobookCreator_StartOperations</kbd> folder. </p>&#13;
<p class="p1">Open the folder and navigate to the <kbd>PhotoCollectionViewController.swift</kbd> file.</p>&#13;
<h2 id="uuid-88f67a0f-fa8e-4d0f-a382-39db6e8ae9aa" class="p1">How to do it...</h2>&#13;
<p class="p1">Let's recap how we broke the work down into independent parts:</p>&#13;
<div><img src="img/062bde1e-59e3-47eb-be26-9d081791e091.jpg" style="" width="644" height="630"/></div>&#13;
<p>Figure 9.16 – Concurrent Approach blocks</p>&#13;
<p class="p1 CDPAlignCenter CDPAlign CDPAlignLeft">We can turn each of these blocks of work into separate operations:</p>&#13;
<ol>&#13;
<li class="p1 CDPAlignCenter CDPAlign CDPAlignLeft">Let's create an operation to scale and crop each photo.</li>&#13;
<li class="p1 CDPAlignCenter CDPAlign CDPAlignLeft">We define an operation by sub-classing the <kbd>Operation</kbd> class, so in the project, create a new Swift file and call it <kbd>PhotoResizeOperation.swift</kbd>.</li>&#13;
</ol>&#13;
<ol start="3">&#13;
<li class="p1 CDPAlignCenter CDPAlign CDPAlignLeft">In the simplest <kbd>Operation</kbd> implementation, we only need to override one method, <kbd>main()</kbd>, so let's copy and paste the relevant code from our <kbd>generatePhotobook</kbd> method. This <kbd>main()</kbd> method will be executed when the operation starts:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">import UIKit<br/><br/>class PhotoResizeOperation: Operation {<br/>    <br/>    override func main() {<br/>        <br/>        // Scale down (can take a while)<br/>        var photosForBook = resizer.scaleWithAspectFill([photo], <br/>          to: size)<br/>        // Crop (can take a while)<br/>        photosForBook = resizer.centerCrop([photo], to: size)<br/>        <br/>        // Replace original photo with processed photo<br/>        processedPhotos[index] = photosForBook[0]<br/>    }<br/>}</pre>&#13;
<ol start="4">&#13;
<li>Copying and pasting the code is not enough, as there are a number of dependencies that were previously being captured by the block. Now we have to explicitly provide these dependencies to the operation:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">class PhotoResizeOperation: Operation {<br/>    <br/>    let resizer: PhotoResizer<br/>    let size: CGSize<br/>    let photos: NSMutableArray<br/>    let photoIndex: Int<br/>    <br/>    init(resizer: PhotoResizer, size: CGSize, <br/>         photos: NSMutableArray, photoIndex: Int) {<br/><br/>        self.resizer = resizer<br/>        self.size = size<br/>        self.photos = photos<br/>        self.photoIndex = photoIndex<br/>    }<br/>    <br/>    override func main() {<br/>        <br/>        // Retrieve the photo to be resized.<br/>        guard let photo = photos[photoIndex] as? UIImage else { <br/>          return }<br/>        <br/>        // Scale down (can take a while)<br/>        var photosForBook = resizer.scaleWithAspectFill([photo], <br/>          to: size)<br/>        // Crop (can take a while)<br/>        photosForBook = resizer.centerCrop(photosForBook, to: size)<br/>        <br/>        photos[photoIndex] = photosForBook[0]<br/>    }<br/>}</pre>&#13;
<ol start="5">&#13;
<li>We have converted our resize block to an operation. We now need to do the same for the block that generates the photo book:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">import UIKit<br/><br/>class GeneratePhotoBookOperation: Operation {<br/>    <br/>    let builder: PhotoBookBuilder<br/>    let photos: NSMutableArray<br/>    var photobookURL: URL?<br/>    <br/>    init(builder: PhotoBookBuilder, photos: NSMutableArray) {<br/>        self.builder = builder<br/>        self.photos = photos<br/>    }<br/>    <br/>    override func main() {<br/>        <br/>        guard let photos = photos as? [UIImage] else { return }<br/>        <br/>        // Generate PDF (can take a while)<br/>        photobookURL = builder.buildPhotobook(with: photos)<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">We pass the dependencies into the operation, just like in <kbd>PhotoResizeOperation</kbd>. The output of this operation is a URL for the resulting photo book. We expose that as a property on the operation so that it can be retrieved outside the operation.</p>&#13;
<ol start="6">&#13;
<li>With our blocks of work converted to operations, let's switch over to <kbd>PhotoCollectionViewController.swift</kbd> and update our <kbd>generatePhotoBook</kbd> method to use this new operation:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">let processingQueue = OperationQueue()<br/><br/>func generatePhotoBook(with photos: [UIImage], completion: @escaping<br/>  (URL) -&gt; Void) {<br/>    <br/>    let resizer = PhotoResizer()<br/>    let builder = PhotoBookBuilder()<br/>    <br/>    // Get smallest common size<br/>    let size = resizer.smallestCommonSize(for: photos)<br/>    <br/>    let processedPhotos = NSMutableArray(array: photos)<br/>    <br/>    let generateBookOp = GeneratePhotoBookOperation(builder: <br/>      builder, photos: processedPhotos)<br/>                                                    <br/>    for index in 0..&lt;processedPhotos.count {<br/>        <br/>        let resizeOp = PhotoResizeOperation(resizer: resizer,<br/>                                          size: size,<br/>                                          photos: processedPhotos,<br/>                                          photoIndex: index)<br/>        <br/>        generateBookOp.addDependency(resizeOp)<br/>        processingQueue.addOperation(resizeOp)<br/>    }<br/>    <br/>    generateBookOp.completionBlock = { [weak generateBookOp] in<br/>        <br/>        guard let pbURL = generateBookOp?.photobookURL else {<br/>            return<br/>        }<br/>        <br/>        OperationQueue.main.addOperation {<br/>            completion(pbURL)<br/>        }<br/>    }<br/>    <br/>    processingQueue.addOperation(generateBookOp)<br/>}</pre>&#13;
<p>Let's walk through the changes step by step:</p>&#13;
<ol>&#13;
<li>Where we were previously using a <kbd>DispatchQueue</kbd> to manage the execution of our blocks, operations are now managed with an <kbd>OperationQueue</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">let processingQueue = OperationQueue()</pre>&#13;
<ol start="2">&#13;
<li>The method signature in the following code and the dependencies we need to generate upfront remain the same:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">func generatePhotoBook(with photos: [UIImage], completion: @escaping (URL) -&gt; Void) {<br/>    <br/>    let resizer = PhotoResizer()<br/>    let builder = PhotoBookBuilder()<br/>    <br/>    // Get smallest common size<br/>    let size = resizer.smallestCommonSize(for: photos)<br/>    <br/>    let processedPhotos = NSMutableArray(array: photos)</pre>&#13;
<ol start="3">&#13;
<li>Next, we create the operation to generate the photo book, passing in the dependencies:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">let generateBookOp = GeneratePhotoBookOperation(builder: builder, <br/>   photos: processedPhotos)</pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<ol start="4">&#13;
<li class="p1">Although the operation will be executed last, we create it first so that we can make it dependent on the resize operations we are about to create. An operation does not execute immediately upon creation. It will only execute when the <kbd>start()</kbd> method of <kbd>Operation</kbd> is called, which can be called manually, or, if an <kbd>Operation</kbd> is placed on an <kbd>OperationQueue</kbd>, it will be called by the queue as appropriate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">for index in 0..&lt;processedPhotos.count {<br/>    <br/>    let resizeOp = PhotoResizeOperation(resizer: resizer,<br/>                                        size: size,<br/>                                        photos: processedPhotos,<br/>                                        photoIndex: index)<br/>    <br/>    generateBookOp.addDependency(resizeOp)<br/>    processingQueue.addOperation(resizeOp)<br/>}</pre>&#13;
<p class="p1">Now, as you can see from the preceding code, we loop through the number of photos that we intend to process and create a resize operation for each, passing in the dependencies.</p>&#13;
<p class="p1">With our move to use <kbd>Operation</kbd>, one thing we have lost is the use of <kbd>DispatchGroup</kbd>, which we used to ensure that we only generated the photo book once all the photo resize blocks had completed. We can, however, achieve the same goals using operation dependencies. An operation can be declared as dependent on a set of other operations, so it will not begin executing until the operations it depends on have finished. To ensure that the <kbd>generateBookOp</kbd> operation, which we just created, only executes when all the <kbd>PhotoResizeOperation</kbd> operations are complete, we add each of them as a dependency of <kbd>generateBookOp</kbd>.</p>&#13;
<p class="p1">With this done, we can place each <kbd>PhotoResizeOperation</kbd> on the <kbd>OperationQueue</kbd>:</p>&#13;
<pre class="p4">generateBookOp.completionBlock = { [weak generateBookOp] in<br/>    <br/>    guard let pbURL = generateBookOp?.photobookURL else {<br/>        return<br/>    }<br/>    <br/>    OperationQueue.main.addOperation {<br/>        completion(pbURL)<br/>    }<br/>}</pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="p1"><kbd>Operation</kbd> has a <kbd>completionBlock</kbd> property; any block set here will be executed once the operation has completed. We can use this to fire our completion handler on the main queue. Since we need to provide the completion handler with the URL to the photo book created by <kbd>generateBookOp</kbd>, we can retrieve this from within the block, as we know that the operation will be finished and the URL will be there. However, we need to be careful. We are providing a closure to <kbd>generateBookOp</kbd>, which will be retained, and we are using, and therefore capturing and retaining, the <kbd>generateBookOp</kbd> operation in the same block. This will lead to a retain cycle, and <kbd>generateBookOp</kbd> will never get released from memory. To avoid this retain cycle, we specify that we want to weakly capture <kbd>generateBookOp</kbd> in the block we provide, using the <kbd>[weak generateBookOp]</kbd> capture list. This won't increment the retain count, preventing the retain cycle from happening.</p>&#13;
<p class="p1">Much like <kbd>DispatchQueue</kbd>, <kbd>OperationQueue</kbd> has an available property that provides a reference to the main queue, upon which the UI events are processed. Also, <kbd>OperationQueue</kbd> has a convenience method that will take a block of code, wrap it in an <kbd>Operation</kbd>, and add it to the queue. We use this to ensure that the completion handler is executed on the main queue:</p>&#13;
<pre class="p4">processingQueue.addOperation(generateBookOp)</pre>&#13;
<p class="p1">As the final step, we put the <kbd>generateBookOp</kbd> operation on the processing queue. It's important that we do this as the last step because, once placed on the queue, the operation may be executed immediately, but we don't want it executed immediately. We only want <kbd>generateBookOp</kbd> executed once all the resize operations are complete, and if we placed the operation on the queue before setting up the dependencies, this could happen.</p>&#13;
<p class="p1">Now that we have transitioned our app over to using <kbd>Operation</kbd>, let's build and then run and verify that everything works just as it did before.</p>&#13;
<p class="p1">Users of our photo book app currently do not have the ability to cancel the generation of a photo book once the process has started, so let's add that functionality:</p>&#13;
<ol>&#13;
<li class="p1">We will examine our two operations and look for opportunities to check the <kbd>isCancelled</kbd> property and exit early. Switch to <kbd>PhotoResizeOperation.swift</kbd> and add <kbd>isCancelled</kbd> checks to the <kbd>main()</kbd> method:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1"> override func main() {<br/>    <br/>    // Check if operation has been cancelled<br/>    guard isCancelled == false else { return }<br/>    <br/>    guard let photo = photos[photoIndex] as? UIImage else { return }<br/>    // Scale down (can take a while)<br/>    var photosForBook = resizer.scaleWithAspectFill(<br/>      [photo], to: size)<br/>    <br/>    // Check if operation has been cancelled<br/>    guard isCancelled == false else { return }<br/>    <br/>    // Crop (can take a while)<br/>    photosForBook = resizer.centerCrop(photosForBook, to: size)<br/>    <br/>    photos[photoIndex] = photosForBook[0]<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">Before each piece of long-running work, we check the <kbd>isCancelled</kbd> property, and if it is <kbd>true</kbd>, we return early, which will finish the operation.</p>&#13;
<ol start="2">&#13;
<li class="p1">We can do the same in <kbd>GeneratePhotoBookOperation.swift</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p4">override func main() {<br/>    <br/>    // Check if operation has been cancelled<br/>    guard isCancelled == false else { return }<br/>    <br/>    guard let photos = photos as? [UIImage] else { return }<br/>    <br/>    // Generate PDF (can take a while)<br/>    photobookURL = builder.buildPhotobook(with: photos)<br/>}</pre>&#13;
<ol start="3">&#13;
<li class="p1">Next, we will need to add some UI that allows the user to cancel the photo book generation once it is in progress. This is an exercise for the reader, or you can switch to the <kbd>end-operations</kbd> branch to see how I have implemented it.</li>&#13;
<li class="p1">Once the user chooses to cancel generating a photo book, we can call the following command:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p6">processingQueue.cancelAllOperations()</pre>&#13;
<p style="padding-left: 60px" class="p1">This will fire the <kbd>cancel()</kbd> method on all the operations in the queue.</p>&#13;
<p class="p1">We now have an app with a cancelable, long-running operation.</p>&#13;
<h2 id="uuid-8f495bee-7bb7-48ef-92db-329d2e429dac" class="p1">How it works...</h2>&#13;
<p class="p1">How does <kbd>OperationQueue</kbd> know when to start an operation and when to remove it from the queue? It knows by monitoring the operation's state. The <kbd>Operation</kbd> class goes through a number of state transformations during its life cycle. The following diagram describes how these state transformations occur:</p>&#13;
<div><img src="img/225f9e07-2d51-4a5c-8cf6-89d829dc3212.jpg" style="" width="974" height="596"/></div>&#13;
<p>Figure 9.17 – Operation life cycle</p>&#13;
<p class="p1">Information about the operation's state is exposed through a number of Boolean properties on <kbd>Operation</kbd>, and the operation queue uses the properties to know when to perform certain actions on the operations. Let's look at these properties one by one:</p>&#13;
<pre class="p4"> var isReady: Bool</pre>&#13;
<p class="p1">An operation will return <kbd>true</kbd> for <kbd>isReady</kbd> when all its dependencies are finished. If it doesn't have any dependencies, it will always return <kbd>true</kbd>. The queue will only start executing an operation if <kbd>isReady</kbd> is <kbd>true</kbd>:</p>&#13;
<pre class="p4"> var isExecuting: Bool</pre>&#13;
<p class="p1">Once <kbd>start</kbd> is called on an operation, either manually or by a queue, <kbd>isExecuting</kbd> will return <kbd>true</kbd>, and when the operation has finished executing, <kbd>isExecuting</kbd> will revert to returning <kbd>false</kbd>.</p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="p1">Since operations remain on the queue until they have finished, the queue uses the <kbd>isExecuting</kbd> property to ensure that it doesn't call <kbd>start</kbd> on an operation that has already started:</p>&#13;
<pre class="p4"> var isFinished: Bool</pre>&#13;
<p class="p1">Once the operation has finished doing whatever processing is required, <kbd>isFinished</kbd> should return <kbd>true</kbd>. When <kbd>isFinished</kbd> starts to return <kbd>true</kbd>, it will be removed from the queue, and the queue will no longer maintain a reference to the operation. For the simplest implementation of <kbd>Operation</kbd>, as we implemented earlier, <kbd>isFinished</kbd> returns <kbd>true</kbd> automatically when the <kbd>main()</kbd> method has finished executing:</p>&#13;
<pre class="p4"> var isCancelled: Bool</pre>&#13;
<p class="p1">Operations can be canceled by calling the <kbd>cancel()</kbd> method on the operation. Once called, the <kbd>isCancelled</kbd> property will return true. This can be used to exit early from a long-running operation, but it is up to you to check the <kbd>isCancelled</kbd> method and interrupt any long-running code if it returns <kbd>true</kbd>.</p>&#13;
<h2 id="uuid-3aadee5f-e20c-40c1-8879-d8d16e29e2a7" class="p1">See also</h2>&#13;
<p>Documentation relating to the <kbd>Operation</kbd> class: <a href="http://swiftbook.link/docs/operation" target="_blank">http://swiftbook.link/docs/operation</a><a href="http://swiftbook.link/docs/operation" target="_blank"/></p>&#13;
&#13;
&#13;
            &#13;
&#13;
            &#13;
        &#13;
    </div></body></html>