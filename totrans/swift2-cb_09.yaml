- en: Chapter 9. Dealing with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。处理其他语言
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using my old address book
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我的旧地址簿
- en: Compressing a message
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩信息
- en: Using assembly code with Swift
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用汇编代码与Swift
- en: Sharing C++ code with Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Swift共享C++代码
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Swift is a new language in a world of libraries that are already done. Sometimes
    you need the help of other languages otherwise you might need to spend a lot of
    time creating the functionalities that you want.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是在已经完成的库的世界中的新语言。有时你需要其他语言的帮助，否则你可能需要花费大量时间来创建你想要的功能。
- en: As you might know, since the 70s, C has been the default language regardless
    of the platform you want to develop on. There are thousands or maybe millions
    of libraries written in C, and you can find a lot of them that are open source,
    which makes it easier to port them to your iOS or Mac OS project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，自70年代以来，C一直是无论你想要在哪个平台上开发，默认的语言。有成千上万甚至数百万的库是用C编写的，你可以找到很多开源的，这使得它们更容易移植到你的iOS或Mac
    OS项目中。
- en: In this chapter, we are going to learn how to use external languages on a Swift
    project. Here, we are going to see how to use C, C++, and even assembly code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Swift项目中使用外部语言。在这里，我们将看到如何使用C、C++甚至汇编代码。
- en: Using my old address book
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我的旧地址簿
- en: In this recipe, we are going to learn how to use a C code inside a Swift project.
    In this case, let's imagine that we want to recycle one linked list of an address
    book written in C, that way you can read the contacts from the device address
    book and store them in a file. The advantage of storing structures on a file is
    that you can open the same file using other platforms that don't have Swift, such
    as Linux or Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在Swift项目中使用C代码。在这种情况下，让我们假设我们想要回收一个用C编写的地址簿的链表，这样你就可以从设备地址簿中读取联系人并将它们存储在文件中。将结构存储在文件中的优点是，你可以使用没有Swift的其他平台打开相同的文件，例如Linux或Windows。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project called `Chapter 9 Address Book`; make sure that this project
    is a Swift project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter 9 Address Book`的新项目；确保这个项目是一个Swift项目。
- en: We are going to check that a new file will be created inside an application
    subfolder. As you know, we can't see any device application folder without using
    a third-party application. In this case we will download an application that can
    explore your device files called **iFunBox**. This app can be freely downloaded
    from [http://www.i-funbox.com/](http://www.i-funbox.com/) but if you prefer there
    are other free apps and commercial apps such as iBrowser and iPad Folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查在应用程序子文件夹内是否创建了一个新文件。正如你所知，没有使用第三方应用程序，我们无法看到任何设备应用程序文件夹。在这种情况下，我们将下载一个可以探索设备文件的应用程序，称为**iFunBox**。这个应用程序可以从[http://www.i-funbox.com/](http://www.i-funbox.com/)免费下载，但如果你更喜欢，还有其他免费应用程序和商业应用程序，如iBrowser和iPad
    Folder。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Downloading the iFunBox is necessary only if you are going to use a physical
    device, if you are going to use only the simulator you can use a traditional **Finder**
    window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你打算使用物理设备时，下载iFunBox才是必要的，如果你打算只使用模拟器，你可以使用传统的**Finder**窗口。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The first step we need to take is to add a new file; in this case you should
    select a C file:![How to do it…](img/00118.jpeg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要采取的第一个步骤是添加一个新文件；在这种情况下，你应该选择一个C文件：![如何操作…](img/00118.jpeg)
- en: Then it will ask for the filename; let's call it `AddressBook.c` and make sure
    that the option **Also create a header file** is checked:![How to do it…](img/00119.jpeg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会询问文件名；让我们称它为`AddressBook.c`并确保已选中**也创建一个头文件**选项：![如何操作…](img/00119.jpeg)
- en: Select the same folder where the project source codes are stored for storing
    this new file. After that you will see that it will ask you about creating an
    Objective-C bridge file; click on **Yes**:![How to do it…](img/00120.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与项目源代码存储相同的文件夹来存储这个新文件。之后，你会看到它会询问你是否要创建一个Objective-C桥接文件；点击**是**：![如何操作…](img/00120.jpeg)
- en: 'Now you can see that there are three new files: `AddressBook.c`, `AddressBook.h`,
    and `Chapter 9 Address Book-Bridging-Header.h`:![How to do it…](img/00121.jpeg)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以看到有三个新的文件：`AddressBook.c`、`AddressBook.h`和`Chapter 9 Address Book-Bridging-Header.h`：![如何操作…](img/00121.jpeg)
- en: 'Before coding, start by clicking on the bridge file and import the `AddressBook.h`
    file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编码之前，首先点击桥接文件并导入`AddressBook.h`文件：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now go to `AddressBook.h`. The first action we need to take here is to remove
    the `stdio.h` include. After that you have to add the structs that are going to
    be used on our application:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到 `AddressBook.h`。在这里我们需要做的第一件事是移除 `stdio.h` 的包含。之后，您必须添加将在我们的应用程序中使用的结构体：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the structures and other types are defined, we are going to add the function
    headers of the operations that can be done with our contact list: create a new
    contact, initialize the list, destroy the list, add a new contact, and save the
    contacts list into a file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了结构和其他类型，我们将添加可以对我们联系人列表执行的操作的函数头：创建一个新的联系人，初始化列表，销毁列表，添加一个新的联系人，并将联系人列表保存到文件中：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The header file is done. If you wish to complete it with more operations such
    as finding a contact on the list or deleting a contact, feel free to do so. Now
    let''s go to the implementation file (`AddressBook.c`) and let''s code the operations.
    Don''t worry if you don''t understand this code; usually when you are using C
    code in Swift you only need to understand what the operation does by reading its
    header:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头文件已完成。如果您希望添加更多操作，例如在列表中查找联系人或删除联系人，请随意操作。现在让我们转到实现文件（`AddressBook.c`）并编写操作代码。如果您不理解这段代码，请不要担心；通常当您在
    Swift 中使用 C 代码时，您只需要通过阅读其头文件来理解操作的功能：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The C part is done, now you can return to the way we used to create our apps
    by clicking on the storyboard and adding two buttons; one for loading the contacts
    and another one for saving the contacts into a file. Link the first button with
    a function called `fillContacts` and the other one with a function called `saveContacts`.
    Don't implement anything yet, we are going to return to these functions soon.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C部分已完成，现在您可以点击故事板并添加两个按钮来返回我们创建应用的方式；一个用于加载联系人，另一个用于将联系人保存到文件。将第一个按钮链接到名为 `fillContacts`
    的函数，将第二个按钮链接到名为 `saveContacts` 的函数。目前不需要实现任何内容，我们很快将返回这些函数。
- en: As we need to read the contacts from the device address book, we need to add
    it into our project, so click on the project in the project navigator, then make
    sure that the **General Info** tab of the target `Chapter 9 AddressBook` is selected.
    Here, you have to scroll down to the **Linked Frameworks and Libraries** and add
    the framework **AddressBook**:![How to do it…](img/00122.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要从设备地址簿中读取联系人，我们需要将其添加到我们的项目中，因此点击项目导航器中的项目，确保目标 `Chapter 9 AddressBook`
    的 **General Info** 选项卡被选中。在这里，您需要向下滚动到 **Linked Frameworks and Libraries** 并添加框架
    **AddressBook**：![如何操作…](img/00122.jpeg)
- en: 'Return to the view controller, scroll up to the beginning, and import the address
    book:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到视图控制器，向上滚动到开头，并导入地址簿：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the view controller class, we are going to start with the attributes,
    in this case we only need a list as a pointer of `ContactList`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图控制器类内部，我们将从属性开始，在这种情况下，我们只需要一个指向 `ContactList` 的列表：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Even if we have initialized the list assigning a nil value, we still need to
    initialize it using the C-specific function and we can do this on the `viewDidLoad`
    method:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使我们已经通过分配 nil 值初始化了列表，我们仍然需要使用 C 特定的函数来初始化它，我们可以在 `viewDidLoad` 方法中这样做：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you might have noticed, there is also a function that destroys the list,
    meaning that we need to call it on the deinitializer:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，还有一个销毁列表的函数，这意味着我们需要在析构器中调用它：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can implement the button events, let''s start with the button that loads
    the contacts from the device address book:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实现按钮事件，让我们从从设备地址簿中加载联系人的按钮开始：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that in iOS and also in OS X, you can't read the address book without
    the user's permission.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，在 iOS 和 OS X 中，没有用户的许可，您不能读取地址簿。
- en: 'As you can see, there are two calls for the method `readContacts`, so that''s
    the method we need to implement now:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，有两个对方法 `readContacts` 的调用，所以这就是我们现在需要实现的方法：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s implement the button that saves the contacts onto a file; this one
    is much easier because we just need to set the full path for the storing file
    and call the function that saves the contacts:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来实现保存联系人到文件的按钮；这个比较简单，因为我们只需要设置存储文件的完整路径并调用保存联系人的函数：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The application looks finished but if you try compiling it you will get an
    error because there is a missing implementation: the function `copyIntoCString`.
    It''s an auxiliary function that we have to create. As you might need it in other
    projects, let''s implement it on a new file. Create a new file called `CstringUtils.swift`
    and add the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序看起来已经完成了，但是如果你尝试编译它，你会得到一个错误，因为缺少实现：函数 `copyIntoCString`。它是一个辅助函数，我们必须创建它。既然你可能需要在其他项目中使用它，让我们在新的文件中实现它。创建一个名为
    `CstringUtils.swift` 的新文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Good, now the application is done, however you still need to test it. Press
    play, accept every permission when requested, and press the button that retrieves
    the contacts from the address book. When you receive a dialog that the contacts
    were loaded, you can press the save button. On screen the only result that you
    might have is just a dialog like this one:![How to do it…](img/00123.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在应用程序已经完成，但是你仍然需要测试它。按播放键，当请求时接受每个权限，并按按钮从地址簿检索联系人。当你收到联系人已加载的对话框时，你可以按保存按钮。在屏幕上，你可能只有如下对话框的结果：![如何操作…](img/00123.jpeg)
- en: If you think that you didn't receive much visual information you are 100% right,
    because this app wasn't created to do something visual; rather it was created
    for generating a file.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你认为你没有获得很多视觉信息，你完全正确，因为这个应用程序不是为了做视觉上的事情而创建的；相反，它是为了生成文件。
- en: If you are using a physical device, open your iFunBox application, which was
    downloaded at the beginning of this recipe (please note, at the time of writing,
    iFunBox does not run with 8.3 or higher), expand the **User Application** section,
    and click on your app (**Chapter 9 Address Book**). On the right-hand side, double-click
    on the document folder and you should see a file called `contacts.dat`:![How to
    do it…](img/00124.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用物理设备，请打开您在食谱开始时下载的 iFunBox 应用程序（请注意，在撰写本文时，iFunBox 无法在 8.3 或更高版本上运行），展开
    **用户应用程序** 部分，然后点击您的应用（**第 9 章 联系人簿**）。在右侧，双击文档文件夹，你应该会看到一个名为 `contacts.dat` 的文件：![如何操作…](img/00124.jpeg)
- en: You can copy this file if you want, and you can also do the opposite process
    by reading this file on another platform, but this task will be left as homework.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要复制这个文件，你也可以通过在另一个平台上读取这个文件来进行相反的操作，但这个任务将留作作业。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although Xcode asks you about creating an Objective-C bridge file, actually
    it creates a file that can also be a C bridge file. Once your C header files are
    imported here you can use them on Swift. As you might have noticed, C doesn't
    work with objects; the only thing you can do is create a struct (which doesn't
    have methods in C) and send it through some functions as arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Xcode 会询问你是否要创建一个 Objective-C 桥接文件，但实际上它创建了一个也可以作为 C 桥接文件的文件。一旦你的 C 头文件被导入到这里，你就可以在
    Swift 中使用它们。正如你可能已经注意到的，C 不与对象一起工作；你能做的唯一一件事是创建一个结构体（在 C 中没有方法）并通过一些函数将其作为参数传递。
- en: C types have their equivalent type in Swift by prefixing the C on its name,
    as in `CChar`, `CInt`, `CFloat` and structs just keep their names without the
    word `struct` as you can see on the `ContactList` and `Contact`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C 类型在其名称前加上 `C` 前缀就有 Swift 中的等效类型，例如 `CChar`、`CInt`、`CFloat`，而结构体则保持其名称不变，不带
    `struct` 这个词，就像你在 `ContactList` 和 `Contact` 中看到的那样。
- en: Another feature that you have to consider is that C works with pointers. A pointer
    is an information reference like we had on the contact list. When you have pointers
    in C they are converted to `UnsafeMutablePointer` in Swift, double pointers are
    converted to `UnsafeMutablePointer` of `UnsafeMutablePointer`, and so on; that's
    the C style of receiving function arguments by reference.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你必须考虑的特性是 C 使用指针。指针是一种信息引用，就像我们在联系人列表中拥有的那样。当你有 C 中的指针时，它们会被转换为 Swift 中的
    `UnsafeMutablePointer`，双指针会被转换为 `UnsafeMutablePointer` 的 `UnsafeMutablePointer`，依此类推；这是
    C 通过引用接收函数参数的风格。
- en: 'When you want to call a C function that requires an argument by reference,
    you have to use the `&` operator. It means that you are sending the memory address
    of that variable. However, the Swift way of declaring an argument by reference
    is different: you have to add the `inout` attribute before the argument name.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想调用一个需要通过引用传递参数的 C 函数时，你必须使用 `&` 操作符。这意味着你正在发送该变量的内存地址。然而，Swift 声明通过引用传递参数的方式不同：你必须在参数名称之前添加
    `inout` 属性。
- en: Using some C types on Swift sometimes needs some tricks, for example, C doesn't
    have a type of strings; the most similar one is the array of characters, which
    sometimes is converted as `[CChar]` and sometimes it is converted as a tuple of
    `UInt8`. If you need to use a C variable without casting it by retrieving its
    memory address you have to use the function `withUnsafeMutablePointer`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中使用某些C类型有时需要一些技巧，例如，C没有字符串类型；最相似的是字符数组，它有时被转换为`[CChar]`，有时被转换为`UInt8`的元组。如果你需要使用C变量而不通过获取其内存地址进行类型转换，你必须使用`withUnsafeMutablePointer`函数。
- en: Compressing a message
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩消息
- en: Even if you work only on an internal project, you will probably have to use
    a library. Sometimes it is a Swift framework but sometimes it is a C library.
    Using C libraries is very common nowadays, mainly because there are a lot of them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你只在一个内部项目中工作，你可能也需要使用库。有时它是一个Swift框架，但有时它是一个C库。使用C库现在非常普遍，主要是因为有很多这样的库。
- en: 'For this recipe we are going to use a library that can be very useful: BCL.
    This simple library can be easily compiled on Xcode and you can use it every time
    your project needs to compress any information.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用一个非常有用的库：BCL。这个简单的库可以很容易地在Xcode中编译，并且每次你的项目需要压缩任何信息时，你都可以使用它。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start coding this project, let's download the BCL library. It can
    be found at [http://bcl.comli.eu/](http://bcl.comli.eu/) and it's free to download
    the source code. Uncompress the downloaded file and leave its finder window opened.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码这个项目之前，让我们下载BCL库。它可以在[http://bcl.comli.eu/](http://bcl.comli.eu/)找到，并且下载源代码是免费的。解压下载的文件并保持其查找窗口打开。
- en: If you are going to install this application onto a physical device you need
    to download the iFunBox as mentioned in the previous recipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将此应用安装到物理设备上，你需要下载之前提到的iFunBox。
- en: For this recipe, instead of creating a project, start creating a workspace and
    call it `Chapter 9 Compressing Workspace`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，不是创建项目，而是开始创建一个工作区，并将其命名为`Chapter 9 Compressing Workspace`。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, you need to create a project, but in this case instead of creating a
    single view application, select **Cocoa Touch Static Library** from the **Framework
    and Library** section and press **Next**:![How to do it…](img/00125.jpeg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个项目，但在这个情况下，不要创建单个视图应用，而是从**框架和库**部分选择**Cocoa Touch静态库**并按**下一步**：![如何操作…](img/00125.jpeg)
- en: Note
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Selecting **Cocoa Touch Static Library** implies developing it in C, C++, or
    Objective-C. Swift doesn't have a static library.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择**Cocoa Touch静态库**意味着以C、C++或Objective-C进行开发。Swift没有静态库。
- en: Now call your project `Chapter 9 BCL`. Notice that it is not asking whether
    it is a Swift project:![How to do it…](img/00126.jpeg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将你的项目命名为`Chapter 9 BCL`。注意，它并没有询问它是否是一个Swift项目：![如何操作…](img/00126.jpeg)
- en: On the next screen you have to select the destination folder where the project
    is going to be stored, but before pressing the **Create** button, make sure that
    this project belongs to your workspace:![How to do it…](img/00127.jpeg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏，你必须选择项目将要存储的目标文件夹，但在按下**创建**按钮之前，确保此项目属于你的工作区：![如何操作…](img/00127.jpeg)
- en: 'Check that this project starts with two source code files: `Chapter_9_BCL.h`
    and `Chapter_9_BCL.m`. Delete them as they are not needed. While deleting, you
    can move them to trash instead of only removing the reference:![How to do it…](img/00128.jpeg)'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认此项目以两个源代码文件开始：`Chapter_9_BCL.h`和`Chapter_9_BCL.m`。删除它们，因为它们不是必需的。在删除时，你可以将它们移动到垃圾桶而不是仅仅删除引用：![如何操作…](img/00128.jpeg)
- en: Now drag the files that end with `.c` and `.h` from the BCL library (located
    at the `src` folder) into your source code group:![How to do it…](img/00129.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将BCL库（位于`src`文件夹中）中以`.c`和`.h`结尾的文件拖到你的源代码组中：![如何操作…](img/00129.jpeg)
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually you don't need to copy the file `bcltest.c` and `bcl.c` because they
    belong to BCL as a program not as a library, but we are copying them to make life
    easier.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，你不需要复制文件`bcltest.c`和`bcl.c`，因为它们属于BCL作为一个程序而不是作为库，但我们正在复制它们以简化操作。
- en: Although you have the necessary files for building the library you still need
    to indicate the header files that should be used externally. This is a procedure
    you have to do every time you build a library written in C, C++, or Objective-C.
    To do it, select the **Build Phases** tab from the target **Chapter 9 BCL**; after
    that expand the section **Copy Files**:![How to do it…](img/00130.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然您已经有了构建库所需的文件，但您仍然需要指示外部应使用的头文件。这是您每次构建用C、C++或Objective-C编写的库时都必须执行的程序。要执行此操作，请从目标**Chapter
    9 BCL**中选择**构建阶段**选项卡；之后，展开**复制文件**部分：![如何操作…](img/00130.jpeg)
- en: 'Now press the plus sign, which is located on the bottom of this section; a
    new dialog will appear showing the files that can be exported. Select only the
    header files such as `huffman.h`, `shannonfano.h`, and `rle.h`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按此部分底部的加号键；将出现一个新对话框，显示可以导出的文件。仅选择头文件，如`huffman.h`、`shannonfano.h`和`rle.h`：
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can select more than one file by holding the command key and
    clicking over the files.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，您可以通过按住command键并单击文件来选择多个文件。
- en: '![How to do it…](img/00131.jpeg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00131.jpeg)'
- en: The library is done, you need to check whether everything is OK by pressing
    *command* + *b*; you should see a message that the build has succeeded.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库已完成，您需要通过按*command* + *b*来检查一切是否正常；您应该看到一个消息，表明构建已成功。
- en: The next part of this recipe is creating an app that compresses a user message.
    To do it don't close your project and create a new project; this time, instead
    of a static library select a single view application done with Swift and call
    it `Chapter 9 BCLApp`. Something that is very important is that you have to add
    this project to the workspace and group `Chapter 9 Compressing Workspace`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本食谱的下一部分是创建一个压缩用户消息的应用。为此，不要关闭您的项目并创建一个新的项目；这次，不要选择静态库，而选择一个用Swift完成的单视图应用，并将其命名为`Chapter
    9 BCLApp`。非常重要的一点是，您必须将此项目添加到工作区并分组为`Chapter 9 Compressing Workspace`。
- en: Notice that now we have two projects. Make sure that the app is selected by
    clicking on it, then click on the target `Chapter 9 BCLApp` and select the general
    info tab. Scroll down to the **Linked Framework and Libraries** section, expand
    it if necessary and press the plus sign.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，现在我们有两个项目。确保通过单击它来选择应用，然后单击目标`Chapter 9 BCLApp`并选择常规信息选项卡。向下滚动到**链接框架和库**部分，如有必要展开它，然后按加号键。
- en: 'A dialog will appear but this time there will be a new group called **Workspace**;
    here you have to select **libChapter 9 BCL.a**:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个对话框，但这次将有一个新的组称为**工作区**；在这里，您必须选择**libChapter 9 BCL.a**：
- en: Note
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The static libraries always have the prefix `lib` and the extension `.a` on
    their names.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 静态库的名称总是以`lib`为前缀，并以`.a`为扩展名。
- en: '![How to do it…](img/00132.jpeg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00132.jpeg)'
- en: Once you have added the library you will need to add a new header file to your
    project; let's call this file `BridgeHeader.h`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了库，您还需要向项目中添加一个新的头文件；让我们称这个文件为`BridgeHeader.h`。
- en: Before we start coding this file, let's set this file as the bridge file for
    the app; hence you have to go to **Build Settings** of your app, write **Bridging**
    on the search box, and once you have found field **Objective-C Bridging Header**,
    write `Chapter 9 BCLApp/BridgeHeader.h`:![How to do it…](img/00133.jpeg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始编码此文件之前，让我们将此文件设置为应用的桥接文件；因此，您必须转到您应用的**构建设置**，在搜索框中输入**桥接**，一旦找到字段**Objective-C
    桥接头**，请输入`Chapter 9 BCLApp/BridgeHeader.h`：![如何操作…](img/00133.jpeg)
- en: 'Let''s return to `BridgeHead.h` and add a few include statements for using
    the compression library:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`BridgeHead.h`并添加一些包含语句以使用压缩库：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The application is now linked with the library, which means that from now on
    you can return to the Swift programming. Go to the storyboard and add a text view
    and two buttons. Usually the text views come with a text by default; if you want
    you can leave it so it will be handier when testing. Link the text view, naming
    it as `textView`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用现在已链接到库，这意味着从现在起，您可以返回到Swift编程。转到故事板，添加一个文本视图和两个按钮。通常，文本视图默认带有文本；如果您想，您可以保留它，这样在测试时会更方便。将文本视图链接，命名为`textView`：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that you have to add the actions for the buttons. For the first button,
    change its label to Huffman and link with the following action:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您必须添加按钮的动作。对于第一个按钮，将其标签更改为Huffman，并链接到以下动作：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the second button you can do the same; change its label to `lz` and link
    it with this similar code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第二个按钮，您可以执行相同的操作；将其标签更改为`lz`，并用以下类似代码进行链接：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last step as you may imagine, is implementing the save function, which
    can be as easy as this code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所想，最后一步是实现保存功能，这可以通过以下代码轻松实现：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The application is done, however it is still necessary to test it. To do this
    you have to make sure that the app is selected at the schema combo, otherwise
    nothing will happen when you press play:![How to do it…](img/00134.jpeg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经完成，然而，仍然有必要对其进行测试。为此，你必须确保在方案组合中选择应用，否则当你按播放键时，什么都不会发生：![如何做…](img/00134.jpeg)
- en: Now press play, write a message on the text field and press the `huffman` button,
    then press the `lz` button. Similar to the previous recipe, you won't see anything
    visually attractive but if you open your iFunBox, expand the app and open the
    document folder. If you would like to see the file sizes without copying them
    just click on the list view:![How to do it…](img/00135.jpeg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按播放键，在文本字段中写一条消息，然后按`huffman`按钮，接着按`lz`按钮。与之前的食谱类似，你不会看到任何视觉上吸引人的东西，但如果你在iFunBox中展开应用并打开文档文件夹，你会看到文件大小。如果你不想复制文件就查看列表视图：![如何做…](img/00135.jpeg)
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you have a big project you can divide it into small components; to do this,
    you can divide your project into small projects. A good way of doing this is by
    creating workspaces.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个大项目时，你可以将其分解成小组件；为此，你可以将你的项目分解成小项目。这样做的一个好方法是创建工作区。
- en: A workspace is like a connection between projects, making the usage of one project
    (in this case the BCL static library) into the other project (in this case the
    application) easier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 工作区就像项目之间的连接，使得将一个项目（在这个例子中是BCL静态库）的使用应用到另一个项目（在这个例子中是应用）变得更容易。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid creating a huge project, and instead try to divide it into small projects;
    it will make your project easier to maintain, and simplify finding issue solutions
    and even creating unit tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 避免创建一个巨大的项目，相反，尝试将其分解成小项目；这将使你的项目更容易维护，并简化问题解决方案的查找，甚至创建单元测试。
- en: A static library is something that is copied into your project as is, meaning
    that your project will grow in size but you won't be worried about a library update
    that can break your app. Every time you create a static library you must export
    the header files, which contain the functions that can be used publicly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库是直接复制到你的项目中的东西，这意味着你的项目会增大，但你不会担心库更新可能会破坏你的应用。每次你创建一个静态库，你必须导出头文件，这些文件包含可以公开使用的函数。
- en: Remember that even if you have a static library on the same workspace, you still
    need to link it on your project and create a bridge file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，即使你有一个静态库在同一工作区，你仍然需要在你的项目中链接它并创建一个桥接文件。
- en: 'You can also see that we used a new method: `alloc`. The method `alloc` was
    used for creating the C array with a specific size; remember that arrays in C
    are not resizable and if you were to store anything on them, you must have allocated
    enough memory for it.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到我们使用了新的方法：`alloc`。`alloc`方法用于创建具有特定大小的C数组；记住，C中的数组是不可调整大小的，如果你要在它们上存储任何东西，你必须为它分配足够的内存。
- en: 'There is a new type also: `UnsafePointer`. The reason for this is that C functions
    can receive constants or variables as arguments, for example, receiving `const
    char *` is different from `char *`; the first one is considered an `UnsafePointer`
    and the second one is a `UnsafeMutablePointer`. Unsafe mutable pointers can be
    casted to unsafe pointers implicitly, but it is not true the other way round.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一种新的类型：`UnsafePointer`。这样做的原因是C函数可以接收常量或变量作为参数，例如，接收`const char *`与`char *`不同；第一个被认为是`UnsafePointer`，第二个是`UnsafeMutablePointer`。不安全的可变指针可以隐式地转换为不安全的指针，但反过来则不然。
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As you can see, there are more compression types in this library; you can try
    using a few of them to see which one is the best.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个库中有更多压缩类型；你可以尝试使用其中几个，看看哪个是最好的。
- en: In the next recipe we are going to learn how to use assembly code with Swift.
    This feature is very useful if you really need performance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将学习如何使用汇编代码与Swift结合。如果你真的需要性能，这个特性非常有用。
- en: Using assembly code with Swift
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用汇编代码与Swift
- en: In this recipe, we are going to learn how to use assembly code with Swift. Of
    course, nowadays nobody develops using only assembly code, but using it in part
    of an app is very common when you need performance. Image manipulation programs,
    for example, use assembly code as it is much faster when you have to process something
    via hardware than via software.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Swift 与汇编代码。当然，如今没有人仅使用汇编代码进行开发，但在需要性能的部分使用汇编代码是非常常见的。例如，图像处理程序使用汇编代码，因为它在通过硬件处理某些内容时比通过软件要快得多。
- en: Obviously programming with assembly language has its drawbacks, the first one
    being that you might have to rewrite your source code for different processors,
    for example, if you have an assembly code done for old iPhones (32-bit ARM processor)
    you might have to rewrite them for the new devices (64-bit ARM processor), and
    even with both codes you might write your code for a third time if you wish to
    see your app working on the iPhone simulator (Intel processor).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用汇编语言编程有其缺点，第一个缺点是您可能需要为不同的处理器重写源代码，例如，如果您为旧款 iPhone（32 位 ARM 处理器）编写了汇编代码，您可能需要为新设备（64
    位 ARM 处理器）重写它们，即使有了这两段代码，如果您希望看到您的应用程序在 iPhone 模拟器上运行（Intel 处理器），您可能还需要第三次编写代码。
- en: This time we are going to use a very simple code as it is out of the scope of
    this book to teach the ARM architecture. In this case, we are going to create
    a simple variable swap function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将使用一个非常简单的代码，因为本书的范围不包括教授 ARM 架构。在这种情况下，我们将创建一个简单的变量交换函数。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, it is recommended having a physical device but it is not mandatory
    because you can compile from the command line specifying the architecture that
    you want to compile for.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，建议使用物理设备，但这不是强制性的，因为您可以从命令行编译，指定您想要编译的架构。
- en: Create a new Swift single view application called `Chapter 9 Assembly`, add
    a new file called `AssemblyCode.c,` and click on **Yes** when Xcode asks for the
    bridging file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 9 Assembly` 的新 Swift 单视图应用程序，添加一个名为 `AssemblyCode.c` 的新文件，当
    Xcode 询问是否创建桥接文件时，点击 **是**。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, you have to click on the bridging header file (`Chapter 9 Assembly-Bridging-Header.h`)
    and include the file `AssemblyCode.h`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须点击桥接头文件（`Chapter 9 Assembly-Bridging-Header.h`）并包含文件 `AssemblyCode.h`：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, go to `AssemblyCode.h` and add the following header:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 `AssemblyCode.h` 并添加以下头文件：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the definition is done you have to code the implementation on `AssemblyCode.c`.
    Here we are going to use a very simple code that can be used on 32 bits and 64
    bits, but bear in mind that you might need to separate them in the case of more
    complex codes:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义完成后，您必须在 `AssemblyCode.c` 中编写实现代码。这里我们将使用一个非常简单的代码，它可以用于 32 位和 64 位，但请注意，在更复杂的代码中，您可能需要将它们分开：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The assembly part is done; click on the storyboard and create a layout with
    two labels, two text fields, and a button. Change the labels text to **First Number**
    and **Second Number**; on the text fields replace the place holders with some
    sample number, and change the button text to **Swap numbers**. The final result
    should be something similar to the following:![How to do it…](img/00136.jpeg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编部分已完成；点击故事板并创建一个包含两个标签、两个文本字段和一个按钮的布局。将标签文本更改为 **第一个数字** 和 **第二个数字**；在文本字段中用一些示例数字替换占位符，并将按钮文本更改为
    **交换数字**。最终结果应类似于以下内容：![如何操作…](img/00136.jpeg)
- en: Click on each text field on the storyboard and change the keyboard type on the
    attribute inspector to **Number and Punctuation**:![How to do it…](img/00137.jpeg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击故事板上的每个文本字段，并在属性检查器中将键盘类型更改为 **数字和标点符号**：![如何操作…](img/00137.jpeg)
- en: 'After placing the user views into the storyboard you have to link the text
    fields with the view controller and call them `firstNumberTextField` and `secondNumberTextField`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将用户视图放置到故事板后，您必须将文本字段与视图控制器链接，并命名为 `firstNumberTextField` 和 `secondNumberTextField`：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, link the button with this action:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将按钮与以下操作链接：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The application is done, let's test it. First, change the device to the **iPhone
    6** simulator and press play:![How to do it…](img/00138.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已完成，让我们测试它。首先，将设备切换到 **iPhone 6** 模拟器并按播放：![如何操作…](img/00138.jpeg)
- en: If you receive an error message it's alright. Just pay attention that the message
    is the same as the one you wrote on the file `AssemblyCode.c`:![How to do it…](img/00139.jpeg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果收到错误消息，没关系。只需注意消息与您在 `AssemblyCode.c` 文件上写的内容相同：![如何操作…](img/00139.jpeg)
- en: Now plug your Apple device into the computer, select it on the active schema
    and press play again. You should see the app, so type two different numbers (one
    on each text field), and press the swap button. The result is that they exchange
    their text fields.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将你的Apple设备连接到电脑上，在活动方案中选择它，然后再次按播放。你应该能看到应用，所以输入两个不同的数字（每个文本字段一个），然后按交换按钮。结果是它们交换了它们的文本字段。
- en: How it works…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Writing assembly code is something that you need to do on the C or Objective-C
    layer, meaning that you still need to know how these languages are converted to
    Swift. Using the statement as volatile allows you to write assembly code. Inside
    that statement you have up to four parts delimited by a colon:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在C或Objective-C层编写汇编代码是你需要做的事情，这意味着你仍然需要知道这些语言是如何转换为Swift的。使用`as volatile`语句可以让你编写汇编代码。在这个语句内部，你有最多四个部分，由冒号分隔：
- en: The first part is a string (only one) that is your assembly template; we didn't
    write more than one string. Notice that on C and Objective C if you write two
    constant strings they are treated as only one. Here you can specify the variables
    using `%[assembly variable name]` or `%0, %1`….
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分是一个字符串（只有一个）是你的汇编模板；我们没有写多个字符串。注意，在C和Objective-C中，如果你写两个常量字符串，它们被视为一个。在这里，你可以使用`%[assembly
    variable name]`或`%0, %1`等指定变量。
- en: The second part is the output variables; you can name them for your assembly
    template by using square brackets, and between parentheses you can specify the
    equivalent C variable.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分是输出变量；你可以通过使用方括号给你的汇编模板命名，并且在括号内你可以指定等效的C变量。
- en: The third part is the input variables, which work in a similar way as the output
    variables.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分是输入变量，它们的工作方式与输出变量类似。
- en: The last part (which we haven't used) is what is called "clobbers". Clobber
    registers are registers that have their value modified in the assembly chunk.
    Compiler will know not to expect that the old register value is preserved.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的部分（我们还没有使用）被称为“覆盖”。覆盖寄存器是指在汇编代码块中其值被修改的寄存器。编译器将知道不要期望保留旧的寄存器值。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take care writing huge assembly code, as debugging it could be very hard.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意编写大量的汇编代码，因为调试它可能非常困难。
- en: As mentioned before, assembly code is platform dependent, meaning that it can
    be different when you use it on the simulator, on an old Apple device, or using
    the new 64-bit device. To differentiate them you can use the macro `__arm__` for
    32-bit devices and `__arm64__` for new arm devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，汇编代码是平台相关的，这意味着在不同的平台上使用时可能会有所不同，比如在模拟器上、在旧款Apple设备上，或者在使用新的64位设备上。为了区分它们，你可以使用宏`__arm__`用于32位设备，以及`__arm64__`用于新的ARM设备。
- en: Usually you are going to see functions that contain assembly code with the keyword
    `inline`. This is done due to assembly code being used when performance is really
    necessary, and the programmer is trying to tell the compiler to copy the function
    code where it is called instead of jumping to the function implementation. Unfortunately
    to do it you have to implement the function on the header file and Swift doesn't
    accept this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会看到包含汇编代码的函数，并带有`inline`关键字。这样做是因为当性能真正需要时，汇编代码会被使用，程序员试图告诉编译器将函数代码复制到它被调用的地方，而不是跳转到函数实现。不幸的是，为了做到这一点，你必须在头文件中实现函数，而Swift不接受这种方式。
- en: There's more…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Assembly code is also something very interesting when you need to debug an
    application that was compiled on release configuration. There is a good website
    for learning the arm assembly code: [http://www.peter-cockerell.net/aalp/html/frames.html](http://www.peter-cockerell.net/aalp/html/frames.html).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要调试在发布配置下编译的应用程序时，汇编代码也是非常有趣的东西。有一个很好的网站可以学习ARM汇编代码：[http://www.peter-cockerell.net/aalp/html/frames.html](http://www.peter-cockerell.net/aalp/html/frames.html)。
- en: You can also investigate NEON to learn about how to work with vectors, double
    word registers, and so on, and if you would like to know even more you can investigate
    intrinsics, which are C functions that call arm instructions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以研究NEON来了解如何处理向量、双字寄存器等，如果你还想了解更多，你可以研究内联函数，这些是调用ARM指令的C函数。
- en: If you are asking yourself how games that require big performance are developed
    if assembly code is very complicated, the answer by is using C++. In the next
    recipe we are going to use it with Swift.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己在想，如果汇编代码非常复杂，那些需要高性能的游戏是如何开发的，答案是使用C++。在下一个菜谱中，我们将使用它与Swift结合。
- en: Sharing C++ code with Swift
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Swift共享C++代码
- en: If you have some code or an external library written in C++ or Objective-C++,
    you probably had a big surprise when you received Apple's note that you can't
    use C++ on Swift directly as we did with C or Objective C.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些用 C++ 或 Objective-C++ 编写的代码或外部库，当你收到苹果的通知，说你不能像使用 C 或 Objective-C 一样直接在
    Swift 中使用 C++，你可能会感到非常惊讶。
- en: There is still a solution and that is creating your own wrapper. There are some
    attempts like SwiftPP ([https://github.com/sandym/swiftpp](https://github.com/sandym/swiftpp))
    but they are still very immature. In this recipe we are going to see how you can
    wrap your C++ class for using it on Swift.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个解决方案，那就是创建你自己的包装器。有一些尝试，比如 SwiftPP ([https://github.com/sandym/swiftpp](https://github.com/sandym/swiftpp))，但它们仍然非常不成熟。在这个菜谱中，我们将看到如何将你的
    C++ 类包装起来以便在 Swift 中使用。
- en: In this recipe we are going to wrap a C++ xml creator for use on Swift. Don't
    worry if you don't know C++ as the idea of this recipe is just letting you know
    how to create this kind of proxy class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将包装一个用于 Swift 的 C++ XML 创建器。如果你不知道 C++，不要担心，这个菜谱的目的是让你知道如何创建这种类型的代理类。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe we will need to download a pure C++ library for creating XML
    files; in this case the library chosen was `pugixml`. So before we start, open
    your web browser, go to [http://pugixml.org/](http://pugixml.org/) (or just Google
    pugixml) and uncompress it. After that, create a new Swift single view project
    called `Chapter 9 Xml Wrapper`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要下载一个用于创建 XML 文件的纯 C++ 库；在这种情况下，选择的库是 `pugixml`。所以在我们开始之前，打开你的网络浏览器，转到
    [http://pugixml.org/](http://pugixml.org/)（或者直接在 Google 中搜索 pugixml）并解压它。之后，创建一个新的
    Swift 单视图项目，命名为 `第 9 章 Xml 包装器`。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First of all we are going to create two project groups, so right click on the
    source code group and select **New Group** and call it `Pugi`. Repeat the operation
    calling the second group `PugiWrapper`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个项目组，所以右键单击源代码组，选择 **新建组** 并将其命名为 `Pugi`。重复此操作，将第二个组命名为 `PugiWrapper`。
- en: Now return to the **Pugi** source code finder window. Here you have to open
    the folder `src`, then you have to select all files with the shortcut *command*
    + *a* and drag them to the group `Pugi`. Accept the creation of the bridging file
    when it is requested:![How to do it…](img/00140.jpeg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在返回到 **Pugi** 源代码查找器窗口。在这里，你需要打开 `src` 文件夹，然后使用快捷键 *command* + *a* 选择所有文件并将它们拖到
    `Pugi` 组中。当需要创建桥接文件时接受创建：![如何操作…](img/00140.jpeg)
- en: Now go to the `PugiWrapper` group and create a new file; this time you have
    to choose **Cocoa Touch Class** from the **iOS source** section. This file should
    be named `PugiBase`. It must be a subclass of `NSObject` and make sure that Objective-C
    was selected as the language:![How to do it…](img/00141.jpeg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到 `PugiWrapper` 组，创建一个新文件；这次你必须从 **iOS 源** 部分选择 **Cocoa Touch Class**。这个文件应该命名为
    `PugiBase`。它必须是 `NSObject` 的子类，并确保选择了 Objective-C 语言：![如何操作…](img/00141.jpeg)
- en: 'Click on the file `PugiBase.h` that was just created, start including the `pugixml.hpp`
    file in case of being imported from a C++ file:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击刚刚创建的文件 `PugiBase.h`，开始将 `pugixml.hpp` 文件包含进来，以防它来自 C++ 文件：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Now that you have MinGW and MSYS, there's no need to be jealous of those with
    a Linux installation anymore, since they implement in your system the most important
    parts of a Linux development environment.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你有了 MinGW 和 MSYS，你不再需要羡慕那些有 Linux 安装的用户了，因为他们已经在你的系统中实现了 Linux 开发环境的最重要部分。
- en: 'This class is done, so the next step is to create a class that will inherit
    from `PugiBase`. To do this, add a new **Cocoa Touch Class** to the `PugiWrapper`
    group and call it `PugiNodeAttribute`. For this class the only method that we
    are going to create is the `setValue`. Knowing this, go to the `PugiNodeAttribute.h`
    file and add the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类已经完成了，所以下一步是创建一个将继承自 `PugiBase` 的类。为此，向 `PugiWrapper` 组添加一个新的 **Cocoa Touch
    Class** 并将其命名为 `PugiNodeAttribute`。对于这个类，我们将要创建的唯一方法是 `setValue`。了解这一点后，转到 `PugiNodeAttribute.h`
    文件，并添加以下代码：
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implementing this class is easy, however there is an important detail: the
    implementation of this class will have C++; this means that before typing anything,
    rename this file from `PugiNoteAttribute.m` to `PugiNodeAttribute.mm` (Objective-C++
    extension):![How to do it…](img/00142.jpeg)'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这个类很简单，但是有一个重要的细节：这个类的实现将是 C++；这意味着在输入任何内容之前，将这个文件从 `PugiNoteAttribute.m`
    重命名为 `PugiNodeAttribute.mm`（Objective-C++ 扩展）：![如何操作…](img/00142.jpeg)
- en: 'Click on the renamed file and complete the class implementation with the following
    code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击重命名的文件，并使用以下代码完成类的实现：
- en: '[PRE24]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that the attribute is done we can repeat the operation for the node (XML
    tag), so create a Cocoa Touch Class file called `PugiNode`, rename the `.m` to
    `.mm`, go to the header file and add the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在属性已经完成，我们可以重复操作为节点（XML 标签），因此创建一个名为 `PugiNode` 的 Cocoa Touch 类文件，将 `.m` 重命名为
    `.mm`，进入头文件并添加以下代码：
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For finishing the wrapper classes, we only need to create another class that
    represents an XML document. Again, create a new Cocoa Touch Class and this time
    call it `PugiDocument`. Rename the implementation file from `.m` to `.mm` and
    add the following code into the `.h` file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成封装类，我们只需要创建另一个代表 XML 文档的类。再次创建一个新的 Cocoa Touch 类，这次命名为 `PugiDocument`。将实现文件从
    `.m` 重命名为 `.mm`，并将以下代码添加到 `.h` 文件中：
- en: '[PRE26]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The wrapping step has finished, so now we can use these classes in our app,
    but we still need to create another class that is going to be used by our app
    and will store the user information before creating the XML file. This class will
    be a pure Swift one, so add a new Swift file called `Task.swift` into the project
    and add the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装步骤已经完成，因此现在我们可以在我们的应用中使用这些类，但我们仍然需要创建另一个类，这个类将用于我们的应用并在创建 XML 文件之前存储用户信息。这个类将是一个纯
    Swift 类，所以将一个名为 `Task.swift` 的新 Swift 文件添加到项目中，并添加以下代码：
- en: '[PRE27]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before we start coding the view controller, don''t forget that you have to
    import the header files of the wrapper classes into the bridging file. So click
    on the bridging file (`Chapter 9 Xml Wrapper-Bridging-Header.h`) and add the following
    lines:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始编写视图控制器代码之前，别忘了你必须将封装类的头文件导入到桥接文件中。所以点击桥接文件（`Chapter 9 Xml Wrapper-Bridging-Header.h`）并添加以下行：
- en: '[PRE28]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now let's mock up our view by clicking on the storyboard file and adding three
    labels, two buttons, one text field, and one UISwitch, something like the following
    image:![How to do it…](img/00143.jpeg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击故事板文件并添加三个标签、两个按钮、一个文本框和一个 UISwitch 来模拟我们的视图，就像以下图像所示：![如何做…](img/00143.jpeg)
- en: 'Now, connect the text field with the view controller and call it `taskTextField`,
    and the `UISwitch` should be called as `importantSwitch`. So the generated code
    should be like this one:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将文本框与视图控制器连接，并命名为 `taskTextField`，而 `UISwitch` 应该命名为 `importantSwitch`。生成的代码应该像这样：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can add a new attribute for storing the user tasks:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个新的属性来存储用户任务：
- en: '[PRE30]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last thing we need to do is create the events for the buttons. Connect
    the add button with the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是为按钮创建事件。将添加按钮与以下代码连接：
- en: '[PRE31]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Good, now we can finalize by linking the save button with the following action:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们可以通过以下操作将保存按钮最终化：
- en: '[PRE32]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Congratulations, the app is done! Press play and add some tasks, such as **Clean
    the room** or **Study Swift very hard**. Once you've finished you can press the
    **Save** button. What happened? Open your iFunBox or equivalent application and
    check the `Documents` folder of your app.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜，应用完成了！按播放键并添加一些任务，例如 **打扫房间** 或 **努力学习 Swift**。一旦完成，你可以按 **保存** 按钮。发生了什么？打开你的
    iFunBox 或等效应用程序，检查应用的 `Documents` 文件夹。
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: pugixml is a minimalist XML library that can be easily used. In this case we
    wrapped only the minimal necessary code that was the tag attribute, the XML tag
    (called **node**), and the complete XML called document. Of course, there are
    more classes in this library and you can complete the code if you want.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: pugixml 是一个易于使用的极简 XML 库。在这种情况下，我们只封装了必要的最小代码，即标签属性、XML 标签（称为 **node**）以及完整的
    XML 文档。当然，这个库中还有更多类，如果你想的话可以完成代码。
- en: 'As mentioned before, C++ can''t be used directly on Swift, but you can create
    Objective-C class that calls C++. Here there is a big detail: you can create Objective-C
    classes but not Objective-C++ classes, which means that the class interface can''t
    contain any C++ objects.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C++ 不能直接在 Swift 中使用，但你可以创建一个调用 C++ 的 Objective-C 类。这里有一个重要的细节：你可以创建 Objective-C
    类，但不能创建 Objective-C++ 类，这意味着类接口不能包含任何 C++ 对象。
- en: How can we solve this issue? Every C++ object (like attributes or properties)
    must be declared as `void*` (an unsafe pointer to anything) and the arguments
    or returning values must be another wrapper class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？每个 C++ 对象（如属性或属性）都必须声明为 `void*`（指向任何内容的非安全指针）并且参数或返回值必须是另一个封装类。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For better compatibility between Swift and Objective-C, try to use types that
    are common to both languages instead of the C or C++ types, such as `NSString`
    instead of `char*`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地兼容 Swift 和 Objective-C，尽量使用两种语言都通用的类型，而不是 C 或 C++ 类型，例如使用 `NSString` 而不是
    `char*`。
