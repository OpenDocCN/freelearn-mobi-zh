- en: Chapter 9. Dealing with Other Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using my old address book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using assembly code with Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing C++ code with Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is a new language in a world of libraries that are already done. Sometimes
    you need the help of other languages otherwise you might need to spend a lot of
    time creating the functionalities that you want.
  prefs: []
  type: TYPE_NORMAL
- en: As you might know, since the 70s, C has been the default language regardless
    of the platform you want to develop on. There are thousands or maybe millions
    of libraries written in C, and you can find a lot of them that are open source,
    which makes it easier to port them to your iOS or Mac OS project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to use external languages on a Swift
    project. Here, we are going to see how to use C, C++, and even assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: Using my old address book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to use a C code inside a Swift project.
    In this case, let's imagine that we want to recycle one linked list of an address
    book written in C, that way you can read the contacts from the device address
    book and store them in a file. The advantage of storing structures on a file is
    that you can open the same file using other platforms that don't have Swift, such
    as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project called `Chapter 9 Address Book`; make sure that this project
    is a Swift project.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to check that a new file will be created inside an application
    subfolder. As you know, we can't see any device application folder without using
    a third-party application. In this case we will download an application that can
    explore your device files called **iFunBox**. This app can be freely downloaded
    from [http://www.i-funbox.com/](http://www.i-funbox.com/) but if you prefer there
    are other free apps and commercial apps such as iBrowser and iPad Folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Downloading the iFunBox is necessary only if you are going to use a physical
    device, if you are going to use only the simulator you can use a traditional **Finder**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step we need to take is to add a new file; in this case you should
    select a C file:![How to do it…](img/00118.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it will ask for the filename; let's call it `AddressBook.c` and make sure
    that the option **Also create a header file** is checked:![How to do it…](img/00119.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the same folder where the project source codes are stored for storing
    this new file. After that you will see that it will ask you about creating an
    Objective-C bridge file; click on **Yes**:![How to do it…](img/00120.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can see that there are three new files: `AddressBook.c`, `AddressBook.h`,
    and `Chapter 9 Address Book-Bridging-Header.h`:![How to do it…](img/00121.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before coding, start by clicking on the bridge file and import the `AddressBook.h`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now go to `AddressBook.h`. The first action we need to take here is to remove
    the `stdio.h` include. After that you have to add the structs that are going to
    be used on our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the structures and other types are defined, we are going to add the function
    headers of the operations that can be done with our contact list: create a new
    contact, initialize the list, destroy the list, add a new contact, and save the
    contacts list into a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The header file is done. If you wish to complete it with more operations such
    as finding a contact on the list or deleting a contact, feel free to do so. Now
    let''s go to the implementation file (`AddressBook.c`) and let''s code the operations.
    Don''t worry if you don''t understand this code; usually when you are using C
    code in Swift you only need to understand what the operation does by reading its
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The C part is done, now you can return to the way we used to create our apps
    by clicking on the storyboard and adding two buttons; one for loading the contacts
    and another one for saving the contacts into a file. Link the first button with
    a function called `fillContacts` and the other one with a function called `saveContacts`.
    Don't implement anything yet, we are going to return to these functions soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we need to read the contacts from the device address book, we need to add
    it into our project, so click on the project in the project navigator, then make
    sure that the **General Info** tab of the target `Chapter 9 AddressBook` is selected.
    Here, you have to scroll down to the **Linked Frameworks and Libraries** and add
    the framework **AddressBook**:![How to do it…](img/00122.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to the view controller, scroll up to the beginning, and import the address
    book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the view controller class, we are going to start with the attributes,
    in this case we only need a list as a pointer of `ContactList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Even if we have initialized the list assigning a nil value, we still need to
    initialize it using the C-specific function and we can do this on the `viewDidLoad`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you might have noticed, there is also a function that destroys the list,
    meaning that we need to call it on the deinitializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can implement the button events, let''s start with the button that loads
    the contacts from the device address book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that in iOS and also in OS X, you can't read the address book without
    the user's permission.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As you can see, there are two calls for the method `readContacts`, so that''s
    the method we need to implement now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s implement the button that saves the contacts onto a file; this one
    is much easier because we just need to set the full path for the storing file
    and call the function that saves the contacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application looks finished but if you try compiling it you will get an
    error because there is a missing implementation: the function `copyIntoCString`.
    It''s an auxiliary function that we have to create. As you might need it in other
    projects, let''s implement it on a new file. Create a new file called `CstringUtils.swift`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good, now the application is done, however you still need to test it. Press
    play, accept every permission when requested, and press the button that retrieves
    the contacts from the address book. When you receive a dialog that the contacts
    were loaded, you can press the save button. On screen the only result that you
    might have is just a dialog like this one:![How to do it…](img/00123.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you think that you didn't receive much visual information you are 100% right,
    because this app wasn't created to do something visual; rather it was created
    for generating a file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using a physical device, open your iFunBox application, which was
    downloaded at the beginning of this recipe (please note, at the time of writing,
    iFunBox does not run with 8.3 or higher), expand the **User Application** section,
    and click on your app (**Chapter 9 Address Book**). On the right-hand side, double-click
    on the document folder and you should see a file called `contacts.dat`:![How to
    do it…](img/00124.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can copy this file if you want, and you can also do the opposite process
    by reading this file on another platform, but this task will be left as homework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Xcode asks you about creating an Objective-C bridge file, actually
    it creates a file that can also be a C bridge file. Once your C header files are
    imported here you can use them on Swift. As you might have noticed, C doesn't
    work with objects; the only thing you can do is create a struct (which doesn't
    have methods in C) and send it through some functions as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: C types have their equivalent type in Swift by prefixing the C on its name,
    as in `CChar`, `CInt`, `CFloat` and structs just keep their names without the
    word `struct` as you can see on the `ContactList` and `Contact`.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature that you have to consider is that C works with pointers. A pointer
    is an information reference like we had on the contact list. When you have pointers
    in C they are converted to `UnsafeMutablePointer` in Swift, double pointers are
    converted to `UnsafeMutablePointer` of `UnsafeMutablePointer`, and so on; that's
    the C style of receiving function arguments by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to call a C function that requires an argument by reference,
    you have to use the `&` operator. It means that you are sending the memory address
    of that variable. However, the Swift way of declaring an argument by reference
    is different: you have to add the `inout` attribute before the argument name.'
  prefs: []
  type: TYPE_NORMAL
- en: Using some C types on Swift sometimes needs some tricks, for example, C doesn't
    have a type of strings; the most similar one is the array of characters, which
    sometimes is converted as `[CChar]` and sometimes it is converted as a tuple of
    `UInt8`. If you need to use a C variable without casting it by retrieving its
    memory address you have to use the function `withUnsafeMutablePointer`.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you work only on an internal project, you will probably have to use
    a library. Sometimes it is a Swift framework but sometimes it is a C library.
    Using C libraries is very common nowadays, mainly because there are a lot of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe we are going to use a library that can be very useful: BCL.
    This simple library can be easily compiled on Xcode and you can use it every time
    your project needs to compress any information.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start coding this project, let's download the BCL library. It can
    be found at [http://bcl.comli.eu/](http://bcl.comli.eu/) and it's free to download
    the source code. Uncompress the downloaded file and leave its finder window opened.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to install this application onto a physical device you need
    to download the iFunBox as mentioned in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, instead of creating a project, start creating a workspace and
    call it `Chapter 9 Compressing Workspace`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you need to create a project, but in this case instead of creating a
    single view application, select **Cocoa Touch Static Library** from the **Framework
    and Library** section and press **Next**:![How to do it…](img/00125.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Selecting **Cocoa Touch Static Library** implies developing it in C, C++, or
    Objective-C. Swift doesn't have a static library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now call your project `Chapter 9 BCL`. Notice that it is not asking whether
    it is a Swift project:![How to do it…](img/00126.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen you have to select the destination folder where the project
    is going to be stored, but before pressing the **Create** button, make sure that
    this project belongs to your workspace:![How to do it…](img/00127.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check that this project starts with two source code files: `Chapter_9_BCL.h`
    and `Chapter_9_BCL.m`. Delete them as they are not needed. While deleting, you
    can move them to trash instead of only removing the reference:![How to do it…](img/00128.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now drag the files that end with `.c` and `.h` from the BCL library (located
    at the `src` folder) into your source code group:![How to do it…](img/00129.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually you don't need to copy the file `bcltest.c` and `bcl.c` because they
    belong to BCL as a program not as a library, but we are copying them to make life
    easier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although you have the necessary files for building the library you still need
    to indicate the header files that should be used externally. This is a procedure
    you have to do every time you build a library written in C, C++, or Objective-C.
    To do it, select the **Build Phases** tab from the target **Chapter 9 BCL**; after
    that expand the section **Copy Files**:![How to do it…](img/00130.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now press the plus sign, which is located on the bottom of this section; a
    new dialog will appear showing the files that can be exported. Select only the
    header files such as `huffman.h`, `shannonfano.h`, and `rle.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you can select more than one file by holding the command key and
    clicking over the files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00131.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The library is done, you need to check whether everything is OK by pressing
    *command* + *b*; you should see a message that the build has succeeded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next part of this recipe is creating an app that compresses a user message.
    To do it don't close your project and create a new project; this time, instead
    of a static library select a single view application done with Swift and call
    it `Chapter 9 BCLApp`. Something that is very important is that you have to add
    this project to the workspace and group `Chapter 9 Compressing Workspace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that now we have two projects. Make sure that the app is selected by
    clicking on it, then click on the target `Chapter 9 BCLApp` and select the general
    info tab. Scroll down to the **Linked Framework and Libraries** section, expand
    it if necessary and press the plus sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dialog will appear but this time there will be a new group called **Workspace**;
    here you have to select **libChapter 9 BCL.a**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The static libraries always have the prefix `lib` and the extension `.a` on
    their names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00132.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once you have added the library you will need to add a new header file to your
    project; let's call this file `BridgeHeader.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we start coding this file, let's set this file as the bridge file for
    the app; hence you have to go to **Build Settings** of your app, write **Bridging**
    on the search box, and once you have found field **Objective-C Bridging Header**,
    write `Chapter 9 BCLApp/BridgeHeader.h`:![How to do it…](img/00133.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s return to `BridgeHead.h` and add a few include statements for using
    the compression library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application is now linked with the library, which means that from now on
    you can return to the Swift programming. Go to the storyboard and add a text view
    and two buttons. Usually the text views come with a text by default; if you want
    you can leave it so it will be handier when testing. Link the text view, naming
    it as `textView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that you have to add the actions for the buttons. For the first button,
    change its label to Huffman and link with the following action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the second button you can do the same; change its label to `lz` and link
    it with this similar code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step as you may imagine, is implementing the save function, which
    can be as easy as this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application is done, however it is still necessary to test it. To do this
    you have to make sure that the app is selected at the schema combo, otherwise
    nothing will happen when you press play:![How to do it…](img/00134.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now press play, write a message on the text field and press the `huffman` button,
    then press the `lz` button. Similar to the previous recipe, you won't see anything
    visually attractive but if you open your iFunBox, expand the app and open the
    document folder. If you would like to see the file sizes without copying them
    just click on the list view:![How to do it…](img/00135.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a big project you can divide it into small components; to do this,
    you can divide your project into small projects. A good way of doing this is by
    creating workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: A workspace is like a connection between projects, making the usage of one project
    (in this case the BCL static library) into the other project (in this case the
    application) easier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid creating a huge project, and instead try to divide it into small projects;
    it will make your project easier to maintain, and simplify finding issue solutions
    and even creating unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: A static library is something that is copied into your project as is, meaning
    that your project will grow in size but you won't be worried about a library update
    that can break your app. Every time you create a static library you must export
    the header files, which contain the functions that can be used publicly.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that even if you have a static library on the same workspace, you still
    need to link it on your project and create a bridge file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see that we used a new method: `alloc`. The method `alloc` was
    used for creating the C array with a specific size; remember that arrays in C
    are not resizable and if you were to store anything on them, you must have allocated
    enough memory for it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a new type also: `UnsafePointer`. The reason for this is that C functions
    can receive constants or variables as arguments, for example, receiving `const
    char *` is different from `char *`; the first one is considered an `UnsafePointer`
    and the second one is a `UnsafeMutablePointer`. Unsafe mutable pointers can be
    casted to unsafe pointers implicitly, but it is not true the other way round.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are more compression types in this library; you can try
    using a few of them to see which one is the best.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe we are going to learn how to use assembly code with Swift.
    This feature is very useful if you really need performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using assembly code with Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to use assembly code with Swift. Of
    course, nowadays nobody develops using only assembly code, but using it in part
    of an app is very common when you need performance. Image manipulation programs,
    for example, use assembly code as it is much faster when you have to process something
    via hardware than via software.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously programming with assembly language has its drawbacks, the first one
    being that you might have to rewrite your source code for different processors,
    for example, if you have an assembly code done for old iPhones (32-bit ARM processor)
    you might have to rewrite them for the new devices (64-bit ARM processor), and
    even with both codes you might write your code for a third time if you wish to
    see your app working on the iPhone simulator (Intel processor).
  prefs: []
  type: TYPE_NORMAL
- en: This time we are going to use a very simple code as it is out of the scope of
    this book to teach the ARM architecture. In this case, we are going to create
    a simple variable swap function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, it is recommended having a physical device but it is not mandatory
    because you can compile from the command line specifying the architecture that
    you want to compile for.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Swift single view application called `Chapter 9 Assembly`, add
    a new file called `AssemblyCode.c,` and click on **Yes** when Xcode asks for the
    bridging file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, you have to click on the bridging header file (`Chapter 9 Assembly-Bridging-Header.h`)
    and include the file `AssemblyCode.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, go to `AssemblyCode.h` and add the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the definition is done you have to code the implementation on `AssemblyCode.c`.
    Here we are going to use a very simple code that can be used on 32 bits and 64
    bits, but bear in mind that you might need to separate them in the case of more
    complex codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The assembly part is done; click on the storyboard and create a layout with
    two labels, two text fields, and a button. Change the labels text to **First Number**
    and **Second Number**; on the text fields replace the place holders with some
    sample number, and change the button text to **Swap numbers**. The final result
    should be something similar to the following:![How to do it…](img/00136.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on each text field on the storyboard and change the keyboard type on the
    attribute inspector to **Number and Punctuation**:![How to do it…](img/00137.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After placing the user views into the storyboard you have to link the text
    fields with the view controller and call them `firstNumberTextField` and `secondNumberTextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, link the button with this action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application is done, let's test it. First, change the device to the **iPhone
    6** simulator and press play:![How to do it…](img/00138.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you receive an error message it's alright. Just pay attention that the message
    is the same as the one you wrote on the file `AssemblyCode.c`:![How to do it…](img/00139.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now plug your Apple device into the computer, select it on the active schema
    and press play again. You should see the app, so type two different numbers (one
    on each text field), and press the swap button. The result is that they exchange
    their text fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing assembly code is something that you need to do on the C or Objective-C
    layer, meaning that you still need to know how these languages are converted to
    Swift. Using the statement as volatile allows you to write assembly code. Inside
    that statement you have up to four parts delimited by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part is a string (only one) that is your assembly template; we didn't
    write more than one string. Notice that on C and Objective C if you write two
    constant strings they are treated as only one. Here you can specify the variables
    using `%[assembly variable name]` or `%0, %1`….
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part is the output variables; you can name them for your assembly
    template by using square brackets, and between parentheses you can specify the
    equivalent C variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third part is the input variables, which work in a similar way as the output
    variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last part (which we haven't used) is what is called "clobbers". Clobber
    registers are registers that have their value modified in the assembly chunk.
    Compiler will know not to expect that the old register value is preserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Take care writing huge assembly code, as debugging it could be very hard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As mentioned before, assembly code is platform dependent, meaning that it can
    be different when you use it on the simulator, on an old Apple device, or using
    the new 64-bit device. To differentiate them you can use the macro `__arm__` for
    32-bit devices and `__arm64__` for new arm devices.
  prefs: []
  type: TYPE_NORMAL
- en: Usually you are going to see functions that contain assembly code with the keyword
    `inline`. This is done due to assembly code being used when performance is really
    necessary, and the programmer is trying to tell the compiler to copy the function
    code where it is called instead of jumping to the function implementation. Unfortunately
    to do it you have to implement the function on the header file and Swift doesn't
    accept this.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assembly code is also something very interesting when you need to debug an
    application that was compiled on release configuration. There is a good website
    for learning the arm assembly code: [http://www.peter-cockerell.net/aalp/html/frames.html](http://www.peter-cockerell.net/aalp/html/frames.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also investigate NEON to learn about how to work with vectors, double
    word registers, and so on, and if you would like to know even more you can investigate
    intrinsics, which are C functions that call arm instructions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are asking yourself how games that require big performance are developed
    if assembly code is very complicated, the answer by is using C++. In the next
    recipe we are going to use it with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing C++ code with Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have some code or an external library written in C++ or Objective-C++,
    you probably had a big surprise when you received Apple's note that you can't
    use C++ on Swift directly as we did with C or Objective C.
  prefs: []
  type: TYPE_NORMAL
- en: There is still a solution and that is creating your own wrapper. There are some
    attempts like SwiftPP ([https://github.com/sandym/swiftpp](https://github.com/sandym/swiftpp))
    but they are still very immature. In this recipe we are going to see how you can
    wrap your C++ class for using it on Swift.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to wrap a C++ xml creator for use on Swift. Don't
    worry if you don't know C++ as the idea of this recipe is just letting you know
    how to create this kind of proxy class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe we will need to download a pure C++ library for creating XML
    files; in this case the library chosen was `pugixml`. So before we start, open
    your web browser, go to [http://pugixml.org/](http://pugixml.org/) (or just Google
    pugixml) and uncompress it. After that, create a new Swift single view project
    called `Chapter 9 Xml Wrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all we are going to create two project groups, so right click on the
    source code group and select **New Group** and call it `Pugi`. Repeat the operation
    calling the second group `PugiWrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now return to the **Pugi** source code finder window. Here you have to open
    the folder `src`, then you have to select all files with the shortcut *command*
    + *a* and drag them to the group `Pugi`. Accept the creation of the bridging file
    when it is requested:![How to do it…](img/00140.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the `PugiWrapper` group and create a new file; this time you have
    to choose **Cocoa Touch Class** from the **iOS source** section. This file should
    be named `PugiBase`. It must be a subclass of `NSObject` and make sure that Objective-C
    was selected as the language:![How to do it…](img/00141.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the file `PugiBase.h` that was just created, start including the `pugixml.hpp`
    file in case of being imported from a C++ file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have MinGW and MSYS, there's no need to be jealous of those with
    a Linux installation anymore, since they implement in your system the most important
    parts of a Linux development environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This class is done, so the next step is to create a class that will inherit
    from `PugiBase`. To do this, add a new **Cocoa Touch Class** to the `PugiWrapper`
    group and call it `PugiNodeAttribute`. For this class the only method that we
    are going to create is the `setValue`. Knowing this, go to the `PugiNodeAttribute.h`
    file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implementing this class is easy, however there is an important detail: the
    implementation of this class will have C++; this means that before typing anything,
    rename this file from `PugiNoteAttribute.m` to `PugiNodeAttribute.mm` (Objective-C++
    extension):![How to do it…](img/00142.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the renamed file and complete the class implementation with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the attribute is done we can repeat the operation for the node (XML
    tag), so create a Cocoa Touch Class file called `PugiNode`, rename the `.m` to
    `.mm`, go to the header file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For finishing the wrapper classes, we only need to create another class that
    represents an XML document. Again, create a new Cocoa Touch Class and this time
    call it `PugiDocument`. Rename the implementation file from `.m` to `.mm` and
    add the following code into the `.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The wrapping step has finished, so now we can use these classes in our app,
    but we still need to create another class that is going to be used by our app
    and will store the user information before creating the XML file. This class will
    be a pure Swift one, so add a new Swift file called `Task.swift` into the project
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start coding the view controller, don''t forget that you have to
    import the header files of the wrapper classes into the bridging file. So click
    on the bridging file (`Chapter 9 Xml Wrapper-Bridging-Header.h`) and add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's mock up our view by clicking on the storyboard file and adding three
    labels, two buttons, one text field, and one UISwitch, something like the following
    image:![How to do it…](img/00143.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, connect the text field with the view controller and call it `taskTextField`,
    and the `UISwitch` should be called as `importantSwitch`. So the generated code
    should be like this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can add a new attribute for storing the user tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do is create the events for the buttons. Connect
    the add button with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, now we can finalize by linking the save button with the following action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations, the app is done! Press play and add some tasks, such as **Clean
    the room** or **Study Swift very hard**. Once you've finished you can press the
    **Save** button. What happened? Open your iFunBox or equivalent application and
    check the `Documents` folder of your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: pugixml is a minimalist XML library that can be easily used. In this case we
    wrapped only the minimal necessary code that was the tag attribute, the XML tag
    (called **node**), and the complete XML called document. Of course, there are
    more classes in this library and you can complete the code if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, C++ can''t be used directly on Swift, but you can create
    Objective-C class that calls C++. Here there is a big detail: you can create Objective-C
    classes but not Objective-C++ classes, which means that the class interface can''t
    contain any C++ objects.'
  prefs: []
  type: TYPE_NORMAL
- en: How can we solve this issue? Every C++ object (like attributes or properties)
    must be declared as `void*` (an unsafe pointer to anything) and the arguments
    or returning values must be another wrapper class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For better compatibility between Swift and Objective-C, try to use types that
    are common to both languages instead of the C or C++ types, such as `NSString`
    instead of `char*`.
  prefs: []
  type: TYPE_NORMAL
