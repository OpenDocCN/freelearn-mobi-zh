<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Layouts</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining and inflating a layout</li><li class="listitem" style="list-style-type: disc">Using RelativeLayout</li><li class="listitem" style="list-style-type: disc">Using LinearLayout</li><li class="listitem" style="list-style-type: disc">Creating tables – TableLayout and GridLayout</li><li class="listitem" style="list-style-type: disc">Using ListView, GridView, and Adapters</li><li class="listitem" style="list-style-type: disc">Changing layout properties during runtime</li><li class="listitem" style="list-style-type: disc">Optimizing layouts with the Hierarchy Viewer</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Introduction</h1></div></div></div><p>In Android, the User Interface is defined in a<strong> Layout</strong>. A layout<a id="id52" class="indexterm"/> can be declared in XML or created dynamically in code. (It's recommended to declare the layout in XML rather than in code to keep the presentation layer separate from the implementation layer.) A layout can define an individual <code class="literal">ListItem</code>, a fragment, or even the entire Activity. Layout files are stored in the <code class="literal">/res/layout</code> folder and referenced in code with the following identifier: <code class="literal">R.layout.&lt;filename_without_extension&gt;</code>.</p><p>Android provides a useful variety of <code class="literal">Layout</code> classes  that contain and organize individual elements of an activity (such as buttons, checkboxes, and other <code class="literal">Views</code>). The <code class="literal">ViewGroup</code> object is a container object that serves as the base class for Android's family of <code class="literal">Layout</code> classes. The Views placed in a layout form a hierarchy, with the topmost layout being the parent.</p><p>Android provides several built-in layout types designed for specific purposes, such as the <code class="literal">RelativeLayout</code>, which allows Views to be positioned with respect to other elements. The <code class="literal">LinearLayout</code> can stack Views or align them horizontally, depending on the orientation specified. The <code class="literal">TableLayout</code> can be used for laying out a grid of Views. Within various layouts, we can also justify Views with <code class="literal">Gravity</code> and provide proportional size with <code class="literal">Weight</code> control. Layouts and <code class="literal">ViewGroups</code> can be nested within each other to create complex configurations. Over a dozen different Layout objects are provided for managing widgets, lists, tables, galleries, and other display formats, plus you can always derive from the base classes to create your own custom layouts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Defining and inflating a layout</h1></div></div></div><p>When using the <a id="id53" class="indexterm"/>Android Studio wizard to create a new project, it automatically creates <a id="id54" class="indexterm"/>the <code class="literal">res/layout/activity_main.xml</code> file (as shown in the following screenshot). It then inflates the XML file in the <code class="literal">onCreate()</code> callback with <code class="literal">setContentView(R.layout.activity_main)</code>.</p><div><img src="img/05057_02_01.jpg" alt="Defining and inflating a layout"/></div><p>For this recipe, we will create two, slightly different layouts and switch between them with a button.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">InflateLayout</code>. Once the project is created, expand the <code class="literal">res/layout</code> folder so we can edit the <code class="literal">activity_main.xml</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Edit the <code class="literal">res/layout/activity_main.xml</code> file so it includes a button as defined here:<div><pre class="programlisting">&lt;Button
    android:id="@+id/buttonLeft"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Left Button"
    android:layout_centerVertical="true"
    android:layout_alignParentLeft="true"
    android:onClick="onClickLeft"/&gt;</pre></div></li><li class="listitem">Now <a id="id55" class="indexterm"/>make a copy <a id="id56" class="indexterm"/>of <code class="literal">activity_main.xml</code> and call it<code class="literal"> activity_main2.xml</code>. Change the button so it matches the following:<div><pre class="programlisting">&lt;Button
    android:id="@+id/buttonRight"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Right Button"
    android:layout_centerVertical="true"
    android:layout_alignParentRight="true"
    android:onClick="onClickRight"/&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following two methods to handle the button clicks:<div><pre class="programlisting">public void onClickLeft(View view) {
    setContentView(R.layout.activity_main2);
}

public void onClickRight(View view) {
    setContentView(R.layout.activity_main);
}</pre></div></li><li class="listitem">Run this application on a device or emulator to see it in action.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How it works...</h2></div></div></div><p>The key here is the call to <code class="literal">setContentView()</code>, which we have come across before in the autogenerated <code class="literal">onCreate()</code> code. Just pass a layout ID to <code class="literal">setContentView()</code> and it automatically inflates the layout.</p><p>This code is meant to make the concept easy to understand but would be overkill for simply changing the property of a Button (in this example, we could just change the alignment on the button click). Inflating the layout is usually needed once, in the <code class="literal">onCreate()</code> method, but there are times when you may want to manually inflate a layout, as we did here. (If you were manually handling orientation changes, it would be a good example.)</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>There's more...</h2></div></div></div><p>As well as identifying a layout using a resource ID, as we did here, <code class="literal">setContentView()</code>can also take a View as an argument, for example:</p><div><pre class="programlisting">findViewById(R.id.myView)
setContentView(myView);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As mentioned previously, see the <em>Fragment</em> topic, in <a class="link" href="ch05.html" title="Chapter 5. Exploring Fragments, AppWidgets, and the System UI">Chapter 5</a>, <em>Exploring Fragments, AppWidgets, and the System UI</em>, for the alternative method to change the screen layout</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Using RelativeLayout</h1></div></div></div><p>As <a id="id57" class="indexterm"/>mentioned in the <em>Introduction</em>, the <code class="literal">RelativeLayout</code> allows Views to be position-relative to each other and the parent. <code class="literal">RelativeLayout</code> is particularly useful for reducing the number of nested layouts, which is very important for reducing memory and processing requirements.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>Create a new project and call it <code class="literal">RelativeLayout</code>. The default layout uses a <code class="literal">RelativeLayout</code>, which we will use to align Views both horizontally and vertically.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">res/layout/activity_main.xml</code> file and change it as follows:<div><pre class="programlisting">&lt;TextView
    android:id="@+id/textView1"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Centered"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true" /&gt;
&lt;TextView
    android:id="@+id/textView2"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Below TextView1"
    android:layout_below="@+id/textView1"
    android:layout_toLeftOf="@id/textView1" /&gt;
&lt;TextView
    android:id="@+id/textView3"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Bottom Right"
    android:layout_alignParentBottom="true"
    android:layout_alignParentEnd="true" /&gt;</pre></div></li><li class="listitem">Run the code, or view the layout in the <strong>Design</strong> tab</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works...</h2></div></div></div><p>This is<a id="id58" class="indexterm"/> a very straightforward exercise but it demonstrates several of the <code class="literal">RelativeLayout</code> options: <code class="literal">layout_centerVertical</code>, <code class="literal">layout_centerHorizontal</code>, <code class="literal">layout_below</code>, <code class="literal">layout_alignParentBottom</code>, and so on.</p><p>The most commonly used <code class="literal">RelativeLayout</code> layout attributes<a id="id59" class="indexterm"/> include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">layout_below</code>: This <a id="id60" class="indexterm"/>View should be below the View specified</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_above</code>: This <a id="id61" class="indexterm"/>View should be above the View specified</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_alignParentTop</code>: Align<a id="id62" class="indexterm"/> this View to the top edge of the parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_alignParentBottom</code>: Align<a id="id63" class="indexterm"/> this View to the bottom edge of the parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_alignParentLeft</code>: Align this <a id="id64" class="indexterm"/>View to the left edge of the parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_alignParentRight</code>: Align <a id="id65" class="indexterm"/>this View to the right edge of the parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_centerVertical</code>: Center<a id="id66" class="indexterm"/> this View vertically within the parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_centerHorizontal</code>: Center <a id="id67" class="indexterm"/>this View horizontally within the parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout_center</code>: Center <a id="id68" class="indexterm"/>this View both horizontally and vertically within the parent<div><div><h3 class="title"><a id="note07"/>Note</h3><p>For the <a id="id69" class="indexterm"/>complete list of <code class="literal">RelativeLayout</code> parameters, visit: <a class="ulink" href="http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html">http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html</a>.</p></div></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec54"/>There's more...</h2></div></div></div><p>In contrast to what we saw earlier, here is<a id="id70" class="indexterm"/> an example using a <code class="literal">LinearLayout</code> just to center a <code class="literal">TextView</code> (creating the same effect as the <code class="literal">layout_center</code> parameter of <code class="literal">RelativeLayout</code>):</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout 
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"&gt;
    &lt;LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:gravity="center" &gt;
        &lt;TextView
            android:id="@+id/imageButton_speak"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Centered" /&gt;
    &lt;/LinearLayout&gt;
&lt;/LinearLayout&gt;</pre></div><p>Notice this layout is one level deeper than the equivalent <code class="literal">RelativeLayout</code> (which is a <code class="literal">LinearLayout</code> nested within the parent <code class="literal">LinearLayout</code>.) Though a simple example, it's a good idea to avoid unnecessary nesting as it can impact performance, especially when a layout is being repeatedly inflated (such as a <code class="literal">ListItem</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec55"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipe, <em>Using LinearLayout</em>, which will give you an alternative layout</li><li class="listitem" style="list-style-type: disc">See the <em>Optimizing layouts with the Hierarchy Viewer</em> recipe for more information on efficient layout design</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Using LinearLayout</h1></div></div></div><p>Another common<a id="id71" class="indexterm"/> layout option is the <code class="literal">LinearLayout</code>, which arranges the child Views in a single column or single row, depending on the orientation specified. The default orientation (if not specified) is vertical, which aligns the Views in a single column.</p><p>The <code class="literal">LinearLayout</code> has a key feature not offered in the <code class="literal">RelativeLayout</code>—the <code class="literal">weight</code> attribute. We can specify a <code class="literal">layout_weight</code> parameter when defining a View to allow the View to dynamically size based on the available space. Options include having a View fill all the remaining space (if a View has a higher weight), having multiple Views fit within the given space (if all have the same weight), or spacing the Views proportionally by their weight.</p><p>We will create a <code class="literal">LinearLayout</code> with three <code class="literal">EditText</code> Views to demonstrate how the weight attribute can be used. For this example, we will use three <code class="literal">EditText</code> Views—one to enter a <code class="literal">To Address</code> parameter, another to enter a <code class="literal">Subject</code>, and the third to enter a <code class="literal">Message</code>. The <code class="literal">To</code> and <code class="literal">Subject</code> Views will be a single line each, with the remaining space given to the Message View.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec56"/>Getting ready</h2></div></div></div><p>Create a new project and call it <code class="literal">LinearLayout</code>. We will replace the default <code class="literal">RelativeLayout</code> created in <code class="literal">activity_main.xml</code> with a <code class="literal">LinearLayout</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec57"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">res/layout/activity_main.xml</code> file and replace it as follows:<div><pre class="programlisting">&lt;LinearLayout 
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;EditText
        android:id="@+id/editTextTo"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="To" /&gt;
    &lt;EditText
        android:id="@+id/editTextSubject"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Subject" /&gt;
    &lt;EditText
        android:id="@+id/editTextMessage"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:gravity="top"
        android:hint="Message" /&gt;
&lt;/LinearLayout&gt;</pre></div></li><li class="listitem">Run the code, or view the layout in the <strong>Design</strong> tab.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec58"/>How it works...</h2></div></div></div><p>When using vertical <a id="id72" class="indexterm"/>orientation with the <code class="literal">LinearLayout</code>, the child Views are created in a single column (stacked on top of each other). The first two Views use the <code class="literal">android:layout_height="wrap_content" </code>attribute, giving them a single line each. <code class="literal">editTextMessage</code> uses the following to specify the height:</p><div><pre class="programlisting">android:layout_height="0dp"
android:layout_weight="1"</pre></div><p>When using the <code class="literal">LinearLayout</code>, it tells Android to calculate the height based on the weight. A weight of 0 (the default if not specified) indicates the View should not expand. In this example, <code class="literal">editTextMessage</code> is the only View defined with a weight, so it alone will expand to fill any remaining space in the parent layout.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>When using the horizontal orientation, specify <code class="literal">android:layout_height="0dp"</code> (along with the weight) to have Android calculate the width.</p></div></div><p>It might be helpful to think of the weight attribute as a percentage. In this case, the total weight defined is 1, so this View gets 100 percent of the remaining space. If we assigned a weight of 1 to another View, the total would be 2, so this View would get 50 percent of the space. Try adding a weight to one of the other Views (make sure to change the height to <code class="literal">0dp</code> as well) to see it in action.</p><p>If you added a weight to one (or both) of the other Views, did you notice the text position? Without specifying a value for <code class="literal">gravity</code>, the text just remains in the center of the View space. The <code class="literal">editTextMessage</code> specifies: <code class="literal">android:gravity="top"</code>, which forces the text to the top of the View.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec59"/>There's more...</h2></div></div></div><p>Multiple attribute options can be combined using bitwise <code class="literal">OR</code>. (Java uses the pipe character (|) for <code class="literal">OR</code>). For example, we could combine two gravity options to both align along the top of the parent and center within the available space:</p><div><pre class="programlisting">android:layout_gravity="top|center"</pre></div><p>It should be noted that the <code class="literal">layout_gravity</code> and <code class="literal">gravity</code> tags are not the same thing. Where <code class="literal">layout_gravity</code> dictates where in its parent a View should lie, <code class="literal">gravity</code> controls the positioning of the contents within a View—for example, the alignment of text on a button.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec60"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The previous recipe, <em>Using the RelativeLayout</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Creating tables – TableLayout and GridLayout</h1></div></div></div><p>When you need to <a id="id73" class="indexterm"/>create a table in your UI, Android provides two convenient layout options: the <code class="literal">TableLayout</code> (along with <code class="literal">TableRow</code>) and the <code class="literal">GridLayout</code> (added in API 14). Both layout options can create similar looking tables, but each using a different <a id="id74" class="indexterm"/>approach. With the <code class="literal">TableLayout</code>, rows and columns are added <a id="id75" class="indexterm"/>dynamically as you build the table. With the <code class="literal">GridLayout</code>, row  and column sizes are defined in the layout definition.</p><p>Neither layout is better, it's just a matter of using the best layout for your needs. We'll create a 3 x 3 grid using each layout to give a comparison, as you could easily find yourself using both layouts, even within the same application.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Getting ready</h2></div></div></div><p>To stay focused on the layouts and offer an easier comparison, we will create two separate applications for this recipe. Create two new Android projects, the first called <code class="literal">TableLayout</code> and the other called <code class="literal">GridLayout</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Starting with the <code class="literal">TableLayout</code> project, open <strong>activity_main.xml</strong><code class="literal">.</code> Change the root layout to <code class="literal">TableLayout</code>.</li><li class="listitem">Add three <code class="literal">TableRows</code> with three sets of <code class="literal">TextViews</code> to each <code class="literal">TableRow</code> to create a 3 x 3 matrix. For demonstration purposes, the columns are labeled A-C and the rows 1-3, so the first row of <code class="literal">TextViews</code> will be A1, B1, and C1. The final result will look like this:<div><pre class="programlisting">&lt;TableLayout
    
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;TableRow
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="A1"
            android:id="@+id/textView1" /&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="B1"
            android:id="@+id/textView2" /&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="C1"
            android:id="@+id/textView3" /&gt;
    &lt;/TableRow&gt;
    &lt;TableRow
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="A2"
            android:id="@+id/textView4" /&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="B2"
            android:id="@+id/textView5" /&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="C2"
            android:id="@+id/textView6" /&gt;
    &lt;/TableRow&gt;
    &lt;TableRow
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="A3"
            android:id="@+id/textView7" /&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="B3"
            android:id="@+id/textView8" /&gt;
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="C3"
            android:id="@+id/textView9" /&gt;
    &lt;/TableRow&gt;
&lt;/TableLayout&gt;</pre></div></li><li class="listitem">Now, open <a id="id76" class="indexterm"/>the <code class="literal">GridLayout</code> project to edit <code class="literal">activity_main.xml</code>. Change<a id="id77" class="indexterm"/> the root layout to <code class="literal">GridLayout</code>. Add the <code class="literal">columnCount=3</code> and <code class="literal">rowCount=3</code> attributes to the <code class="literal">GridLayout</code><a id="id78" class="indexterm"/> element.</li><li class="listitem">Now, add nine <code class="literal">TextViews</code> to <code class="literal">GridLayout</code>. We will use the same text as the preceding <code class="literal">TableLayout</code> for a consistent comparison. Since the <code class="literal">GridView</code> does not use <code class="literal">TableRows</code>, the first three <code class="literal">TextViews</code> are in Row 1, the next three are in Row 2, and so on. The final result will look like this:<div><pre class="programlisting">&lt;GridLayout
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:columnCount="3"
    android:rowCount="3"&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="A1"
        android:id="@+id/textView1" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="B1"
        android:id="@+id/textView2" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="C1"
        android:id="@+id/textView3" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="A2"
        android:id="@+id/textView4" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="B2"
        android:id="@+id/textView5" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="C2"
        android:id="@+id/textView6" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="A3"
        android:id="@+id/textView7" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="B3"
        android:id="@+id/textView8" /&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="C3"
        android:id="@+id/textView9" /&gt;
&lt;/GridLayout&gt;</pre></div></li><li class="listitem">You can either run the<a id="id79" class="indexterm"/> application or use the <strong>Design</strong> tab to see the results.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How it works...</h2></div></div></div><p>As you can see <a id="id80" class="indexterm"/>when viewing the tables created, the tables basically look the same on <a id="id81" class="indexterm"/>screen. The main difference is the code to create them.</p><p>In the <code class="literal">TableLayout</code> XML, each row is added to the table using a <code class="literal">TableRow</code>. Each View becomes a column. This is not a requirement as cells can be skipped or left empty. (See how to specify the cell location in a <code class="literal">TableRow</code> in the following section.)</p><p>The <code class="literal">GridLayout</code> uses the opposite approach. The number of rows and columns are specified when creating the table. We don't have to specify the row or column information (though we can, discussed as follows). Android will automatically add each View to the cells in order.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec64"/>There's more...</h2></div></div></div><p>First, let's see more similarities<a id="id82" class="indexterm"/> between the layouts. Both layouts have the ability to stretch columns to use the remaining screen space. For the <code class="literal">TableLayout</code>, add the following attribute to the xml declaration:</p><div><pre class="programlisting">android:stretchColumns="1"</pre></div><p>
<code class="literal">stretchColumns</code> specifies the (zero based) index of the columns to stretch. (<code class="literal">android:shrinkColumns</code> is a zero-based index of columns that can shrink, so the table can fit the screen.)</p><p>To achieve the same effect with the <code class="literal">GridLayout</code>, add the following attribute to all the Views in the B column (<code class="literal">textView2</code>, <code class="literal">textView5</code>, and <code class="literal">textView8</code>):</p><div><pre class="programlisting">android:layout_columnWeight="1"</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>All cells in a given column must define the weight or it will not stretch.</p></div></div><p>Now, let's look at some of the<a id="id83" class="indexterm"/> differences, as this is really the key to determine which layout to use for a given task. The first thing to note is how the columns and rows are actually defined. In the <code class="literal">TableLayout</code>, the rows are specifically defined, using a <code class="literal">TableRow</code>. (Android will determine the number of columns in the table based on the row with the most cells.) Use the <code class="literal">android</code>:<code class="literal">layoutColumn</code> attribute when defining the View to specify the column.</p><p>In contrast, with the <code class="literal">GridLayout</code>, the row and column counts are specified when defining the table (using the <code class="literal">columnCount</code> and <code class="literal">rowCount</code> as shown previously.)</p><p>In the preceding example, we just added <code class="literal">TextViews</code> to the <code class="literal">GridLayout</code> and let the system position them automatically. We can alter this behavior by specifying the row and column position when defining the View, such as:</p><div><pre class="programlisting">android:layout_row="2"
android:layout_column="2"</pre></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Android automatically increments the cell counter after adding each View, so the <em>next</em> View should also specify the row and column, otherwise, you may not get the intended result.</p></div></div><p>Like the <code class="literal">LinearLayout</code> shown in the <em>LinearLayout</em> recipe, the <code class="literal">GridLayout</code> also offers the orientation attribute of supporting both horizontal (the default) and vertical. The orientation determines how the cells are placed. (Horizontal fills the columns first, then moves down to the next row. Vertical fills the first column on each row, then moves to the next column.)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Using ListView, GridView, and Adapters</h1></div></div></div><p>The <code class="literal">ListView</code> and <code class="literal">GridView</code> are both descendants of <code class="literal">ViewGroup</code>, but they are used more like a View<a id="id84" class="indexterm"/> since they are data driven. In other words, rather than defining <a id="id85" class="indexterm"/>all the possible Views that might fill a <code class="literal">ListView</code> (or <code class="literal">GridView</code>) at <a id="id86" class="indexterm"/>design time, the contents are created dynamically from the data passed to the View. (The layout of the <code class="literal">ListItem</code> might be created at design time to control the look of the data during runtime.)</p><p>As an example, if you needed to present a list of countries to a user, you could create a <code class="literal">LinearLayout</code> and add a button for each country. There are several problems with this approach: determining the countries available, keeping the list of buttons up to date, having enough screen space to fit all the countries, and so on. Otherwise, you could create a list of countries to populate a <code class="literal">ListView</code>, which will then create a button for each entry.</p><p>We will create an example, using the second approach, to populate a <code class="literal">ListView</code> from an array of country names.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec65"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">ListView</code>. The default <code class="literal">ActivityMain</code> class extends the <code class="literal">Activity</code> class. We will change it to extend the <code class="literal">ListActivity</code> class instead. We will then create a simple string list and bind it to the <code class="literal">ListView</code>, to derivate the buttons at runtime.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <strong>MainActivity.java</strong> file and change the base declaration so it will extend <code class="literal">ListActivity</code> instead of the <code class="literal">Activity</code> class:<div><pre class="programlisting">public class MainActivity extends ListActivity {</pre></div></li><li class="listitem">Change <code class="literal">onCreate()</code> so it matches the following:<div><pre class="programlisting">protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  String[] countries = new String[]{"China", "France", "Germany", "India", "Russia", "United Kingdom", "United States"};

  ListAdapter countryAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, countries);
  setListAdapter(countryAdapter);

    getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, Viewview, int position, long id) {
            String s = ((TextView) view).getText() + " " +position;
            Toast.makeText(getApplicationContext(), s, 
                Toast.LENGTH_SHORT).show();
        }
    });
}</pre></div></li><li class="listitem">Now run the <a id="id87" class="indexterm"/>application on an emulator or device to see the populated <code class="literal">ListView</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec67"/>How it works...</h2></div></div></div><p>We start by creating a simple array<a id="id88" class="indexterm"/> of country names, then use that to populate a <code class="literal">ListAdapter</code>. In <a id="id89" class="indexterm"/>this example, we used an <code class="literal">ArrayAdapter</code> when constructing the <code class="literal">ListAdapter</code>, but Android has several other adapter types available as well. Such as, if your data is stored in a database, you could use the <code class="literal">CursorAdapter</code>. If one of the built-in types doesn't meet your needs, you can always use the <code class="literal">CustomAdapter</code>.</p><p>We create the adapter with this line of code:</p><div><pre class="programlisting">ListAdapter countryAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, countries);</pre></div><p>Here, we instantiate the <code class="literal">ArrayAdapter</code> using our string array (the last parameter). Notice the <code class="literal">android.R.layout.simple_list_item_1</code> parameter? This defines the layout for the button. Here, we are using one of the layouts as provided by Android, but we could create our own layout and pass our ID instead.</p><p>Once we have the adapter ready, we just pass it to the underlying <code class="literal">ListView</code> with the <code class="literal">setListAdapter() </code>call. (The underlying <code class="literal">ListView</code> comes from extending the <code class="literal">ListViewActivity</code>.) Finally, we implement the <code class="literal">setOnItemClickListener</code> to display a Toast when the user presses a button (which represents a country) in the list.</p><p>
<code class="literal">ListViews</code> are very common in Android as they make efficient use of screen space with a scrolling View, which can be very handy on small screens. The <code class="literal">ScrollView</code> layout offers an alternative approach to create a similar scrolling effect. The main difference between the two approaches is that the <code class="literal">ScrollView</code> layout is fully inflated before being shown to the user, whereas the <code class="literal">ListView</code> only inflates the Views that will be visible. For limited data, this may not be an issue, but for larger data sets, the application could run out of memory before the list is even shown.</p><p>Also, since the <code class="literal">ListView</code> is driven by a data adapter, the data can easily be changed. Even in our limited example, adding a new country to the screen is as simple as adding the name to the country list. More importantly, the list can be updated during runtime while the user is using the app (for example, downloading an updated list from a website to show real-time options).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec68"/>There's more...</h2></div></div></div><p>The <code class="literal">ListView</code> also<a id="id90" class="indexterm"/> supports a multiple selection mode using the <code class="literal">setChoiceMode()</code> method. To see it in<a id="id91" class="indexterm"/> action, add the following line of code after <code class="literal">setListAdapter()</code>:</p><div><pre class="programlisting">getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);</pre></div><p>Then, change the <code class="literal">ListItem</code> layout <a id="id92" class="indexterm"/>from <code class="literal">android.R.layout.simple_list_item_1</code> to <code class="literal">android.R.layout.simple_list_item_checked</code>.</p><p>While most applications requiring a scrolling list turn to the <code class="literal">ListView</code>, Android also offers the <code class="literal">GridView</code>. They are very similar in functionality, even using the same data adapters. The main difference is visual which allows multiple columns. For a better understanding, let's change the <code class="literal">ListView</code> example to a <code class="literal">GridView</code>.</p><p>To start, we need to change <code class="literal">MainActivity</code> to extend from <code class="literal">Activity</code> again, instead of <code class="literal">ListActivity</code>. (This will undo the preceding Step 1.) Then, replace <code class="literal">onCreate()</code> with the following code:</p><div><pre class="programlisting">protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    GridView gridView = new GridView(this);
    setContentView(gridView);
    String[] countries = new String[]{"China", "France", "Germany", "India", "Russia", "United Kingdom", "United States"};
    ListAdapter countryAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, countries);
    gridView.setAdapter(countryAdapter);
    gridView.setNumColumns(2);
    gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
                String s = ((TextView) view).getText() + " " + position;
            Toast.makeText(getApplicationContext(), s, Toast.LENGTH_SHORT).show();
        }
    });
}</pre></div><p>As you can see, there's more setup code for the <code class="literal">GridView</code> than there was for the <code class="literal">ListView</code>. The <code class="literal">onCreate()</code> method creates a new <code class="literal">GridView</code> and passes it in the <code class="literal">setContentView()</code> call. (We used this variation of <code class="literal">setContentView</code>, as was mentioned in <em>Defining and inflating a layout</em>, instead of creating a layout with just a <code class="literal">GridView</code>, but the end result is the same.)</p><p>The <code class="literal">ListViewActivity</code> base <a id="id93" class="indexterm"/>class handles much of this, but the <code class="literal">GridView</code> does not have a<a id="id94" class="indexterm"/> corresponding <a id="id95" class="indexterm"/>activity class to extend.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Changing layout properties during runtime</h1></div></div></div><p>In Android <a id="id96" class="indexterm"/>development, it's generally the preferred practice to define the UI with XML and the application code in Java, keeping the User Interface code separate from the application code. There are times where it is much easier or more efficient, to alter (or even build) the UI from the Java code. Fortunately, this is easily supported in Android.</p><p>We saw a small example of modifying the layout from code in the previous recipe, where we set the number of <code class="literal">GridView</code> column to display in the code. In this recipe, we will obtain a reference to the <code class="literal">LayoutParams</code> object to change the margin during runtime.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec69"/>Getting ready</h2></div></div></div><p>Here we will set up a simple layout with XML and use a <code class="literal">LinearLayout.LayoutParams</code> object to change the margins of a View during runtime.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How to do it....</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">activity_main.xml</code> file and change the layout from <code class="literal">RelativeLayout</code> to <code class="literal">LinearLayout</code>. It will look as follows:<div><pre class="programlisting">&lt;LinearLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
&lt;/LinearLayout&gt;</pre></div></li><li class="listitem">Add a TextView and include an ID as follows:<div><pre class="programlisting">android:id="@+id/textView"</pre></div></li><li class="listitem">Add <code class="literal">Button</code> and include an ID as follows:<div><pre class="programlisting">android:id="@+id/button"</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following code to the <code class="literal">onCreate()</code> method to set up an <code class="literal">onClick</code> event listener:<div><pre class="programlisting">Button button = (Button)findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        ((TextView)findViewById(R.id.textView)).setText("Changed at runtime!");
        LinearLayout.LayoutParams params = (LinearLayout.LayoutParams)view.getLayoutParams();
        params.leftMargin += 5;
    }
});</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec71"/>How it works...</h2></div></div></div><p>Every <a id="id97" class="indexterm"/>View (and therefore <code class="literal">ViewGroup</code>) has a set of layout parameters associated with it. In particular, all Views have parameters to inform their parent of their desired height and width. These are defined with the <code class="literal">layout_height</code> and <code class="literal">layout_width</code> parameters. We can access this layout information from the code with the <code class="literal">getLayoutParams()</code> method. The layout information includes the layout height, width, margins, and any class-specific parameters. In this example, we moved the button on each click by obtaining the button <code class="literal">LayoutParams</code> and changing the margin.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Optimizing layouts with the Hierarchy Viewer</h1></div></div></div><p>Before you can start<a id="id98" class="indexterm"/> optimizing your layouts, it helps to <a id="id99" class="indexterm"/>understand the Android layout process. Inflating a layout, begins when the activity first comes into display. Three steps occur:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Measure</strong>: This is <a id="id100" class="indexterm"/>where the Views determine their size, starting with the parent and working through all the children. The parent may have to call its children multiple times to work out the final size.</li><li class="listitem" style="list-style-type: disc"><strong>Layout</strong>: This is <a id="id101" class="indexterm"/>where the parent determines the position of its children</li><li class="listitem" style="list-style-type: disc"><strong>Draw</strong>: This is <a id="id102" class="indexterm"/>where the Views are actually rendered</li></ul></div><p>This process starts <a id="id103" class="indexterm"/>with the parent, which then iterates <a id="id104" class="indexterm"/>through all its children. Those children iterate through their children. This creates the Layout Tree, with the parent becoming the root node in the tree.</p><p>
<strong>Hierarchy Viewer</strong>
<a id="id105" class="indexterm"/>
is a tool included with the <strong>Android SDK</strong>
<a id="id106" class="indexterm"/> for inspecting layouts. It graphically shows the Layout Tree along with timing results for each view/node. By examining the tree layout and the timing; you can look for inefficient design and bottlenecks. Armed with this information, you're in position to optimize your layouts.</p><p>For this recipe, we will use Hierarchy Viewer to inspect the example layout given in the <em>Using RelativeLayout</em> recipe.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec72"/>Getting ready</h2></div></div></div><p>In the <em>There's more…</em> section of the <em>Using RelativeLayout</em> recipe, a <code class="literal">LinearLayout</code> example was shown to highlight the difference between the layouts. The comment was made stating the <code class="literal">LinearLayout</code> required a nested layout. We're going to create a new project called <code class="literal">OptimizingLayouts</code> using the example <code class="literal">LinearLayout</code>. We will then use Hierarchy Viewer to inspect the layout. We will need a rooted Android device or the emulator for this Recipe.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Hierarchy Viewer will only connect to rooted devices, such as an emulator.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">OptimizingLayouts</code> project in Android Studio. Run the project on your rooted device (or emulator) and make sure the screen is visible (unlock if needed).</li><li class="listitem">In Android Studio, start the Android Device Monitor by going to the following menu option: <strong>Tools</strong> | <strong>Android</strong> | <strong>Android Device Monitor</strong>.</li><li class="listitem">In Android Device Monitor, change to the Hierarchy View perspective, by going to <strong>Window</strong> | <strong>Open Perspective…</strong> this will bring up the following dialog:<div><img src="img/05057_02_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Now click on <strong>Hierarchy Viewer</strong> and on <strong>OK</strong>.</li><li class="listitem">In the <strong>Windows</strong> <a id="id107" class="indexterm"/>section on the left is the list <a id="id108" class="indexterm"/>of devices with the running processes. Click on the <code class="literal">OptimizingLayouts</code> process to inspect the layout.<div><img src="img/05057_02_03.jpg" alt="How to do it..."/></div></li><li class="listitem">See the graphical representation of this activity in the <strong>TreeView</strong> section (in the center pane, which occupies most of the Hierarch Viewer perspective).<div><img src="img/05057_02_04.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec74"/>How it works...</h2></div></div></div><p>The Tree Layout<a id="id109" class="indexterm"/> section shows a graphical hierarchy of the<a id="id110" class="indexterm"/> Views that comprise this layout, along with the layout times. (Unfortunately for this demonstration, the render times are too fast for visual color-coding references.) What's important for this example is the nested <code class="literal">LinearLayouts</code> as shown previously. (It's worth taking some time to explore the other Views that make up this layout so you can see what Android is doing for us behind the scenes.)</p><p>As already mentioned in the <code class="literal">RelativeLayout</code> example, the solution is to redesign this layout using the <code class="literal">RelativeLayout</code>. Ideally, we want a wider, flatter layout, rather than deeply nested layouts to reduce the number of iterations required during the sizing step. For timing purposes, this is obviously a trivial example, but even this example can have an impact. Imagine the user flicking through a <code class="literal">ListView</code> with thousands of items based on this inefficient layout. If you experience stuttering while scrolling, your optimizing steps could start by examining the layout in Hierarchy Viewer.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec75"/>There's more...</h2></div></div></div><p>
<strong>Lint</strong> is another tool included with the Android SDK with built-in support by Android Studio. By default, you're already using Lint to check your code for issues such as deprecated API calls, unsupported API calls for the target API level, security issues, and so on. For our Optimizing Layout concerns, some of the conditions that Lint will automatically check include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Deep layouts — the default maximum is 10 levels</li><li class="listitem" style="list-style-type: disc">Nested weights, which are bad for performance</li><li class="listitem" style="list-style-type: disc">Useless parent</li><li class="listitem" style="list-style-type: disc">Useless leaf</li></ul></div><p>If you check the Lint warning in Android Studio for this layout, you will see the following warning on the second <code class="literal">LinearLayout</code> element:</p><div><img src="img/05057_02_05.jpg" alt="There's more..."/></div><p>The <code class="literal">ViewStub</code> <a id="id111" class="indexterm"/>can also be used to optimize a layout. Think <a id="id112" class="indexterm"/>of the <code class="literal">ViewStub</code> as a "lazy load" for your layout. The layout in the <code class="literal">ViewStub</code> will not inflate until it's needed, which reduces the Views needed to inflate. The layout will render faster and use less memory. This is a great way to have functionality that is seldom used, such as a <code class="literal">Print</code> feature, available when needed, but that does not take up memory when not needed. Here's an example of a <code class="literal">ViewStub</code>:</p><div><pre class="programlisting">&lt;ViewStub
    android:id="@+id/viewStubPrint"
    android:inflatedId="@id/print"
    android:layout="@layout/print"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"/&gt;</pre></div><p>There are two ways to actually inflate the <code class="literal">ViewStub</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set the visibility parameter of <code class="literal">ViewStub</code> to <code class="literal">VISIBLE</code>:<div><pre class="programlisting">((ViewStub) findViewById(R.id.viewStubPrint)).setVisibility(View.VISIBLE);</pre></div></li><li class="listitem" style="list-style-type: disc">Call the <code class="literal">inflate()</code> method on the <code class="literal">ViewStub</code>:<div><pre class="programlisting">View view = ((ViewStub) findViewById(R.id.viewStubPrint)).inflate();</pre></div></li></ul></div><p>Once the <code class="literal">ViewStub</code> is<a id="id113" class="indexterm"/> inflated, the <code class="literal">ViewStub</code> ID will be removed<a id="id114" class="indexterm"/> from the layout and replaced with the inflated ID.</p></div></div></body></html>