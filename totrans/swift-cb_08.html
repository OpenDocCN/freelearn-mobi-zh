<html><head></head><body><div id="sbo-rt-content"><section>&#13;
&#13;
                            <header class="header-title chapter-title">&#13;
                    Server-Side Swift&#13;
                </header>&#13;
            &#13;
            <article>&#13;
                &#13;
<p class="p1"><span class="s1">From its very inception, Swift was intended to be a general-purpose programming language, applicable for multiple use cases and on multiple platforms, not just for building apps for Apple platforms. One of the obvious use cases, other than building apps, is creating server-side code. After all, interacting with a server is a vital component of almost any app. The vast majority of servers that power the internet run on Linux, which is arguably more suited to the task than any Apple platform. Therefore, being able to run Swift on Linux is vital to the goal of making Swift a viable server-side programming language option.</span></p>&#13;
<p class="p1"><span class="s1">In this chapter, we will investigate installing the Swift toolchain on Linux, using a web server framework to build a REST API, and hosting our API via a hosting service.</span></p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Running Swift on Linux</li>&#13;
<li>Building a REST API using Vapor and Fluent</li>&#13;
<li><span>Database persistence</span> with Fluent and Postgres</li>&#13;
<li>Hosting your Vapor app on Heroku</li>&#13;
<li>The Swift Package Manager</li>&#13;
<li>Real-time communication using WebSockets</li>&#13;
<li>Packaging and sharing models between server and app</li>&#13;
</ul>&#13;
<h1 id="uuid-52e13e0d-9ba3-43d2-8f2f-455f0a5da460">Technical requirements</h1>&#13;
<p><span>All the code for this chapter can be found in this book's GitHub repository:</span> <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3kgvhxe" target="_blank">https://bit.ly/3kgvhxe</a></p>&#13;
<h1 id="uuid-f37a0780-ed5a-4f4e-a131-7fd5e404ecbe" class="p1">Running Swift on Linux</h1>&#13;
<p>The Linux operating system is a dominant force in the world of backend servers, so to be of any use for server-side development, Swift needs to be available on Linux. Fortunately, part of the open source release of Swift includes the Swift toolchain on Linux. Let's get it up and running with a "Hello World" program in Swift on Linux.</p>&#13;
<h2 id="uuid-3aefc005-f4fa-4709-8845-a1f5c16efbc3">Getting started</h2>&#13;
<p class="p1"><span class="s1">This recipe will use Ubuntu 20.04, as this is a very popular and widely used Linux distribution, and 20.04 is the latest <strong>Long-Term Support</strong> (<strong>LTS</strong>) version. Additionally, pre-built binaries of the Swift toolchain are provided for this distribution by the Swift open source team. As a Mac user, I have tested this process on an instance of Ubuntu, running in the VirtualBox virtualization environment, but there should be no difference when running on bare metal.</span></p>&#13;
<h2 id="uuid-904aaf70-d195-4c64-b818-2b50cd4b8004" class="p1">How to do it...</h2>&#13;
<p>Let's install the Swift toolchain and run our first Swift code on Linux:</p>&#13;
<ol>&#13;
<li><span class="s1">We need to install some dependencies related to the compiler. If you are using Ubuntu with a <strong>Graphical User Interface</strong> (<strong>GUI</strong>), open up a Terminal window and run the following from the prompt to u<span>pdate the software repositories</span>:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>sudo apt-get update</strong></pre>&#13;
<ol start="2">&#13;
<li>Run the next command to install a number of dependencies required for the Swift toolchain:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>sudo apt-get install \</strong><br/><strong>             binutils \</strong><br/><strong>             git \</strong><br/><strong>             gnupg2 \</strong><br/><strong>             libc6-dev \</strong><br/><strong>             libcurl4 \</strong><br/><strong>             libedit2 \</strong><br/><strong>             libgcc-9-dev \</strong><br/><strong>             libpython2.7 \</strong><br/><strong>             libsqlite3-0 \</strong><br/><strong>             libstdc++-9-dev \</strong><br/><strong>             libxml2 \</strong><br/><strong>             libz3-dev \</strong><br/><strong>             pkg-config \</strong><br/><strong>             tzdata \</strong><br/><strong>             zlib1g-dev</strong></pre>&#13;
<p style="padding-left: 60px" class="mce-root"><span class="s1">The Swift team released a prebuilt toolchain for Ubuntu, so we will need to download the latest released version and the associated <kbd>signature</kbd> file. Links for these releases can be found at</span> <a href="https://swift.org/download/#releases">https://swift.org/download/#releases</a>.</p>&#13;
<ol start="3">&#13;
<li>Download the toolchain and PGP signature file for the relevant platform. For example, at the time of writing, the most recent release versions can be downloaded using <kbd>wget</kbd> with the following command:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>wget https://swift.org/builds/swift-5.3-release/ubuntu2004/swift-5.3-RELEASE/swift-5.3-RELEASE-ubuntu20.04.tar.gz</strong><br/><strong>wget https://swift.org/builds/swift-5.3-release/ubuntu2004/swift-5.3-RELEASE/swift-5.3-RELEASE-ubuntu20.04.tar.gz.sig</strong></pre>&#13;
<ol start="4">&#13;
<li class="p1">The signature file that we downloaded can be used to verify that the toolchain archive has not been tampered with or modified during the download. The verification will use public PGP keys provided by the Swift project in conjunction with the signature file. If you haven't done so before, you can use the following command to retrieve the PGP keys and import them into your keyring:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>wget -q -O - https://swift.org/keys/all-keys.asc | gpg --import -</strong></pre>&#13;
<ol start="5">&#13;
<li>Next, we need to check for any key revocation certificates:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>gpg --keyserver hkp://pool.sks-keyservers.net --refresh-keys Swift</strong></pre>&#13;
<ol start="6">&#13;
<li>With all that done, we can verify the integrity of our downloaded toolchain archive (replacing the signature filename below with the one downloaded):</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>gpg --verify swift-5.3-RELEASE-ubuntu20.04.tar.gz.sig</strong></pre>&#13;
<ol start="7">&#13;
<li>The response should contain the <kbd>gpg: Good signature from "Swift 5.x Release Signing Key &lt;swift-infrastructure@swift.org&gt;"</kbd> line; if it does, the archive has been successfully verified, and if not, the download may have been altered and should be retrieved from a trusted source on a trusted network.</li>&#13;
</ol>&#13;
<div class="p1 packt_infobox"><span class="s1">Don't be alarmed if it says the key is not from a trusted <kbd>signature</kbd>. This is because the system can't find an unbroken chain of certificates from your computer to this key; it's okay to ignore this warning.</span></div>&#13;
<ol start="8">&#13;
<li>With our archive verified, let's unzip the archive and see what's inside (replacing the filename that follows with the toolchain downloaded):</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>tar -xzf swift-5.3-RELEASE-ubuntu20.04.tar.gz</strong></pre>&#13;
<p style="padding-left: 60px"><span class="s1">Within the archive is a <kbd>usr</kbd> folder, and within that, a <kbd>bin</kbd> folder, which contains a number of binaries that are related to building Swift; key among them is the <kbd>swift</kbd> binary.</span></p>&#13;
<ol start="9">&#13;
<li>We want to interact with the Swift toolchain using just the command <kbd>swift</kbd>; to do this, we need to tell the system where to look for the Swift binaries. Open up <kbd>~/.profile</kbd> in your preferred text editor, and add the folder containing your Swift toolchain to the <kbd>$PATH</kbd> export command:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">PATH="$HOME/bin:$HOME/.local/bin:&lt;path to extracted swift toolchain&gt;/usr/bin:$PATH"</pre>&#13;
<ol start="10">&#13;
<li>Save your <kbd>.profile</kbd> file.</li>&#13;
<li>Log out and log back in for the changes to take effect.</li>&#13;
<li>Now, when you type <kbd>swift</kbd> and press <em>Enter</em>, the Swift REPL will launch. It stands for the <strong>read–eval–print loop</strong> <span>(</span><span class="s1"><strong>REPL</strong></span><span>)</span><span class="s1">; it's a way to interact with the Swift language in a very quick, easy way, much like a playground.</span></li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">In the REPL, you can write Swift commands and press <em>Enter</em> to have them executed, with each command occurring within the same scope as the previous commands.</span></p>&#13;
<ol start="13">&#13;
<li>In the REPL, type the following Swift expression:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let greeting = "Hello world!"</pre>&#13;
<ol start="14">&#13;
<li>Press <em>Enter</em>, and the REPL will display the outcome of your command, much like a playground does:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">greeting: String = "Hello world!"</pre>&#13;
<ol start="15">&#13;
<li>Now we can print our greeting:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print(greeting)</pre>&#13;
<p style="padding-left: 60px">We get the expected response:</p>&#13;
<pre style="padding-left: 60px">Hello world!</pre>&#13;
<ol start="16">&#13;
<li>To leave the REPL and return to your normal command line, type the following and press <em>Enter</em>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">:quit</pre>&#13;
<p>Congratulations! You just executed Swift code on Ubuntu Linux. The world of server-side Swift awaits.</p>&#13;
<h2 id="uuid-2005343a-0238-4f40-b405-abdaa11ac7fd">There's more...</h2>&#13;
<p>It's great to try out Swift code at the command line using the REPL, but what we really require is the ability to compile our code into an executable binary that we can run on demand. Let's take our "Hello world!" example and compile it into a binary:</p>&#13;
<ol>&#13;
<li>Open your favorite text editor and save the following into a file called <kbd>HelloWorld.swift</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">print("Hello world!")</pre>&#13;
<ol start="2">&#13;
<li>From the command line, in the folder that contains our Swift file, we can compile our binary using <kbd>swiftc</kbd>. We can <span>specify the file or files to compile and use the</span> <kbd>-o</kbd> <span>flag to provide a name for the output binary:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>swiftc HelloWorld.swift -o HelloWorld</strong></pre>&#13;
<ol start="3">&#13;
<li><span>Now, we can run the binary:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>&gt; ./HelloWorld</strong><br/><strong>&gt; Hello world!</strong></pre>&#13;
<p>Compiling one file is great, but to perform any useful work, we are likely to have multiple Swift files that define things like models, controllers, and other logic, so how can we compile them into a single, executable binary?</p>&#13;
<p>When we have multiple files, we need to be able to define one at the entry point of our application. When compiling a Swift binary with multiple files, one of them should be called <kbd>main.swift</kbd>. This file serves as the entry point so that when the binary is run, the code in the <kbd>main.swift</kbd> file is executed from start to end.</p>&#13;
<p>Let's make two Swift files, the first one named <kbd>Model.swift</kbd>:</p>&#13;
<pre>// Model.swift<br/><br/>class Person {<br/>    let name: String<br/>    init(name: String) {<br/>        self.name = name<br/>    }<br/>}</pre>&#13;
<p>Next, we'll create the <kbd>main.swift</kbd> file:</p>&#13;
<pre>// main.swift<br/><br/>let keith = Person(name: "Keith")<br/>print("Hello \(keith.name)")</pre>&#13;
<p>Now, let's compile these two files into a binary called <kbd>Greeter</kbd>:</p>&#13;
<pre>swiftc Model.swift main.swift -o Greeter</pre>&#13;
<p>This can then be executed:</p>&#13;
<pre>&gt; ./Greeter<br/>&gt; Hello Keith!</pre>&#13;
<p>We have now written and compiled a binary from multiple files in Swift on Ubuntu.</p>&#13;
<h1 id="uuid-2752b44d-f46a-4ef6-80ee-7dc4345bf8bf">Building a REST API using Vapor and Fluent</h1>&#13;
<p>One of the main use cases for server-side Swift is building REST APIs. Interacting with network data is a key function of almost any app, and until now, that server-side component had to be built by someone else with the relevant server-side skills. Alternatively, it required an app developer to frequently switch between programming languages and development environments to build both the client-side and the server-side code of an app.</p>&#13;
<p>Swift on the server opens the possibility for a developer to work on everything involved in the app, and move seamlessly between the client side and server side.</p>&#13;
<p>Much has been done by the Swift team to encourage the use of Swift on the server, including creating a new networking framework for running servers. This new framework is called SwiftNIO and is available open-sourced on GitHub: <a href="https://github.com/apple/swift-nio">github.com/apple/swift-nio.</a></p>&#13;
<p>This framework is quite low-level, and a number of higher-level frameworks exist to make creating a REST API easier using Swift.</p>&#13;
<p>In this recipe, we will use one of the more popular frameworks, Vapor, to build a REST API for an app that stores a user's tasks.</p>&#13;
<h2 id="uuid-0e6188bc-4b03-482a-ab0d-1fe838b34b69">Getting started</h2>&#13;
<p>Vapor is a Swift framework for building web services, that makes accomplishing common tasks very easy. At the time of writing, Vapor is at Version 4, which is required with Swift 5.2. More information about Vapor can be found on its website at <a href="http://vapor.codes">http://vapor.codes.</a></p>&#13;
<p>For this recipe, we will assume that you are developing your Swift web service on a Mac, even if it may eventually be deployed to a Linux server.</p>&#13;
<div class="packt_infobox">When writing Swift code that will be deployed on Linux, it's very important to test your code by actually running it on Linux, especially if it's initially developed on macOS. There are significant differences between Swift's operation on macOS and Linux. These differences are often due to the different implementation of the Foundation framework on the different platforms.</div>&#13;
<p>Let's verify that we have the right version of Swift installed to run Vapor. Run the following command in Terminal to check your version of Swift:</p>&#13;
<pre><strong>swift --version</strong></pre>&#13;
<p>The output should indicate at least <kbd>version 5.2</kbd>; if this is not the case, you will need to update your version of Xcode.</p>&#13;
<p><span>We next need to install Vapor Toolbox, which is a set of command-line tools to simplify working with Vapor-based projects. The Vapor CLI is available through Homebrew, which is a package manager for macOS. You can find more details about Homebrew on its website at</span> <span><a href="https://brew.sh">https://brew.sh</a></span><a href="https://brew.sh">.</a></p>&#13;
<p><a href="https://brew.sh"/></p>&#13;
<div class="packt_infobox">At the time of writing, Homebrew has not been updated to support the recently released Apple Silicon Macs. If you are using one of these Macs, please check the Homebrew website for compatibility information.</div>&#13;
<p>If you don't already have Homebrew installed, run the following in Terminal:</p>&#13;
<pre>/usr/bin/ruby -e <span class="s2">"</span><span class="k">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install<span class="k">)</span><span class="s2">"</span></pre>&#13;
<p>With Homebrew installed, we can add the <kbd>tap</kbd> for Vapor:</p>&#13;
<pre><strong><span>brew install vapor</span></strong></pre>&#13;
<p>L<span>et's run Vapor to check whether it's installed correctly. You should see instructions on how to use Vapor:</span></p>&#13;
<pre><strong>vapor</strong></pre>&#13;
<p>We are now ready to use Vapor to build our REST API.</p>&#13;
<h2 id="uuid-f81d1f1e-fccd-4550-9cc2-d17c4cca513f">How to do it...</h2>&#13;
<p>We will create a web service to store and manage tasks from an iOS app:</p>&#13;
<ol>&#13;
<li>Create a new Vapor project called <kbd>TaskAPI</kbd> and then move to the new folder that is created:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>vapor new TaskAPI</strong><br/><strong>cd TaskAPI</strong></pre>&#13;
<p style="padding-left: 60px">During this process, you will be asked <em><strong>Would you like to use Fluent?</strong></em> Answer yes to this. You will then be asked which database you would like to use. Select <strong>Postgres</strong> (this should be the recommended one).</p>&#13;
<p style="padding-left: 60px">Additionally, you will be asked if you would like to install <em><strong>Leaf</strong></em>. Select <strong>No</strong> for now, as this goes slightly outside of the scope of this recipe.</p>&#13;
<p style="padding-left: 60px">You can create your Vapor web service using any IDE, but we are familiar with using Xcode, so let's use that.</p>&#13;
<p class="mce-root"/>&#13;
<ol start="2">&#13;
<li>Vapor has support for creating an Xcode project containing our Vapor code, so let's launch Xcode for our Vapor project:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong> vapor xcode</strong></pre>&#13;
<p style="padding-left: 60px">Xcode will open and the project dependencies will be fetched automatically and appear under <span class="packt_screen">Swift Package Dependencies</span> in the project navigator. Be patient – this can take a few minutes and you might not see any activity straight away.</p>&#13;
<p style="padding-left: 60px">Once all the dependencies have been fetched, the build and run button will become active.</p>&#13;
<ol start="3">&#13;
<li>Build and run the project to launch a local web server, which will handle requests to <kbd>http://127.0.0.1:8080</kbd>.</li>&#13;
<li>Open <kbd>http://127.0.0.1:8080</kbd> <span>in a browser and you will see this web page:</span></li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/52dad583-d066-4208-ad58-32705b7e40e3.png" style="" width="910" height="129"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 8.1 <span>– </span>Vapor project</div>&#13;
<p>It works! You now have your bare-bones Vapor project up and running. Now let's take a look at the Xcode project that Vapor has created for us.</p>&#13;
<p>In the Project Navigator, you will find a <span class="packt_screen">Sources</span> group, and two subgroups: <span class="packt_screen">Run</span> and <span class="packt_screen">App</span>. The <span class="packt_screen">Run</span> group contains <kbd>main.swift</kbd>, the file that will be executed when you run the app. The <span class="packt_screen">App</span> group contains a number of files with some example code for setting up a REST API.</p>&#13;
<p>Open the <kbd>main.swift</kbd> file; it will contain the following template code:</p>&#13;
<pre class="p1">import App<br/>import Vapor<br/><br/>var env = try Environment.detect()<br/>try LoggingSystem.bootstrap(from: &amp;env)<br/>let app = Application(env)<br/>defer { app.shutdown() }<br/>try configure(app)<br/>try app.run()</pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mceNonEditable"/>&#13;
<p class="mce-root"/>&#13;
<p class="mceNonEditable"/>&#13;
<p class="mceNonEditable"/>&#13;
<p>You shouldn't really need to edit this file; it just performs the required setup and starts the web server that serves up our API. What we do need to do is to use this setup process to configure Vapor to provide the API we require.</p>&#13;
<p>Let's look at how the default Vapor template sets things up. In the <span class="packt_screen">App</span> group, open the <kbd>configure.swift</kbd> file:</p>&#13;
<pre class="p1">import Vapor<br/><br/>// configures your application<br/>public func configure(_ app: Application) throws {<br/>    // uncomment to serve files from /Public folder<br/>    // app.middleware.use(FileMiddleware(publicDirectory: <br/>      // app.directory.publicDirectory))<br/><br/><strong>    if let databaseURL = Environment.get("DATABASE_URL"),</strong><br/><strong>       var postgresConfig = PostgresConfiguration(url: databaseURL) {</strong><br/><strong>        postgresConfig.tlsConfiguration =   <br/>          .forClient(certificateVerification: .none)</strong><br/><strong>        app.databases.use(.postgres(configuration: postgresConfig),<br/>          as: .psql)</strong><br/><strong>        </strong><br/><strong>    } else {</strong><br/>        <br/>        app.databases.use(.postgres(<br/>            hostname: Environment.get("DATABASE_HOST") ?? "localhost",<br/>            port: Environment.get("DATABASE_PORT").flatMap(<br/>              Int.init(_:)) ?? PostgresConfiguration.ianaPortNumber,<br/>            username: Environment.get("DATABASE_USERNAME") ?? <br/>              "vapor_username",<br/>            password: Environment.get("DATABASE_PASSWORD") ?? <br/>              "vapor_password",<br/>            database: Environment.get("DATABASE_NAME") ?? <br/>              "vapor_database"<br/>        ), as: .psql)<br/>        <br/><strong>    }</strong><br/><br/>app.migrations.add(CreateTodo())<br/>    // register routes<br/>    try routes(app)<br/>}</pre>&#13;
<p>In this file, we've imported the <kbd>Vapor</kbd> module, which contains all the code to set up and manage the Vapor web server. We've also got our code for our database, but we'll go further into that a little later on. If you look back at <kbd>main.swift</kbd>, you will see that it imports the <kbd>App</kbd> module; this is the module that will contain all of your code for setting up the web server and managing requests and responses.</p>&#13;
<div class="packt_infobox">Note in the preceding code, I've highlighted a required change for the latest version of Vapor which may now be included in the most recent template, if you are unsure, just copy the preceding code into your project from here or take a look at the source files.</div>&#13;
<p>Next, let's switch to <kbd>Routes.swift</kbd>, and we will see that this is where our routes are configured:</p>&#13;
<pre class="p1">import Vapor<br/><br/>func routes(_ app: Application) throws {<br/>    app.get { req in<br/>        return "It works!"<br/>    }<br/><br/>    app.get("hello") { req -&gt; String in<br/>        return "Hello, world!"<br/>    }<br/>}</pre>&#13;
<p>A route defines a type of request that the web server may receive, and the response to send.</p>&#13;
<p><span>You will notice that the <kbd>"plaintext"</kbd> path is defined, which is the URL we visited to determine that everything was correctly configured:</span></p>&#13;
<pre class="p1">app.get("hello") { req -&gt; String in<br/>    return "Hello, world!"<br/>}</pre>&#13;
<p>This route is for a <kbd>GET</kbd> request, with the path string parameter, <kbd>plaintext</kbd>; when our Vapor server was locally run, this related to the URL <kbd>http://0.0.0.0:8080</kbd>. The process of defining a route in Vapor involves providing a closure that takes a <kbd>Request</kbd> object and returns something that conforms to <kbd>ResponseRepresentable</kbd>; Vapor has already defined the string as conforming to <span><kbd>ResponseRepresentable</kbd>, so in the string, <span class="packt_screen">Hello, world!</span> can be returned.</span></p>&#13;
<p>Build and run the <span class="packt_screen">Run</span> scheme, if it's not already running, and visit <kbd>http://0.0.0.0:8080/hello</kbd> to see the JSON defined.</p>&#13;
<h2 id="uuid-e4f7406c-4ac5-420e-b77e-8755f1995905">How it works...</h2>&#13;
<p>The <strong>TaskAPI</strong> will accept new tasks as POST requests containing JSON representations of the tasks and will return all the existing tasks via <kbd>GET</kbd> requests.</p>&#13;
<p>First, let's define a task – in the <span class="packt_screen">App</span> group of your Xcode project, create a new file called <kbd>Task.swift</kbd> in a new group called <span class="packt_screen">Models</span>.</p>&#13;
<p>After creating this file, ensure that it is a member of the <span class="packt_screen">App</span> target and not any others. The <span class="packt_screen">Target Membership</span> panel for our new file should look like this:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/62d8ea0a-aa0f-402c-8ccc-390a12efe1d9.png" style="" width="250" height="1515"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 8.2 – Target membership</span></div>&#13;
<p>Now, let's define our task as having two properties: <kbd>description</kbd> and <kbd>category</kbd>, plus an identifier:</p>&#13;
<pre>class Task { <br/> let id: String <br/> var description: String<br/> var category: String<br/> <br/> init(id: String, description: String, category: String) {<br/> self.id = id<br/> self.description = description<br/> self.category = category<br/> }<br/>}</pre>&#13;
<p>We can now create a <kbd>Task</kbd> in code, like this:</p>&#13;
<pre>let task = Task(id: "1", description: "Remember the milk", category: <br/>  "shopping")</pre>&#13;
<p>However, we will always create our <kbd>Task</kbd> objects from the JSON received by the <kbd>POST</kbd> request, so being able to create our <kbd>Task</kbd> objects directly from JSON will be very helpful, and since we will be returning our <kbd>Task</kbd> objects as JSON, being able to convert them to JSON will also be helpful.</p>&#13;
<p>Vapor has a framework called Content for dealing with JSON data. Content is Vapor's version of Codable (which we learned about in <em><a href="32abd392-d947-461c-a9e9-912b34704c9b.xhtml">Chapter 6</a>, Building iOS Apps with Swift</em>).</p>&#13;
<div class="packt_tip">The Vapor project we created, in turn, creates example code of everything we're about to go through. If you get stuck at any time, simply refer to the template counterpart for guidance as to where you could be going wrong.</div>&#13;
<p>Let's add the <kbd>Content</kbd> conformance to our <kbd>Task</kbd> model object:</p>&#13;
<pre class="p1">import Foundation<br/>import Vapor<br/><br/>final class Task: Content {<br/>    <br/>    let id: String = UUID().uuidString<br/>    <br/>    var description: String<br/>    var category: String<br/>    <br/>}</pre>&#13;
<p>When we are creating a new task, we don't expect the JSON to include the identifier, so if it is missing, we can generate a <kbd>UUID</kbd> using the <kbd>Foundation</kbd> framework.</p>&#13;
<p>Now that we have our <kbd>Task</kbd> model object, which can be converted to and from JSON, let's create some routes for our API.</p>&#13;
<p>In <kbd>Routes.swift</kbd>, we need an array of <kbd>Task</kbd> objects to hold the tasks that get created; for the moment, we can just add that to the top of the file:</p>&#13;
<pre class="p1"><span class="s1">var</span> tasks = [<span class="s2">Task</span>]()</pre>&#13;
<p>Next, we'll add two routes to the <kbd>routes()</kbd> method:</p>&#13;
<pre class="p1">app.post("task") { request -&gt; String in<br/>    let task = try request.content.decode(Task.self)<br/>    tasks.append(task)<br/>    return "Task Added"<br/>}<br/>    <br/>app.get("task") { request in<br/>    return tasks<br/>}</pre>&#13;
<p>In the first route, we look for a <kbd>POST</kbd> request to the <kbd>/task</kbd> path. If the request has JSON, then we can use it to attempt to create a <kbd>Task</kbd> object using the JSON; once created, we can store it in the <kbd>tasks</kbd> array.</p>&#13;
<p>The next route looks for a <kbd>get</kbd> request to that same path – <kbd>/task</kbd> – and returns a JSON representation of the tasks we stored in our array. This makes use of the fact that Vapor has an extension of <kbd>Sequence</kbd>, which <kbd>Array</kbd> conforms to, and if all items in the <kbd>Sequence</kbd> conform to <kbd>JSONRepresentable</kbd>, then the <kbd>Sequence</kbd> can be represented as JSON, too. With these routes defined, let's build and run the <span class="packt_screen">Run</span> scheme and test them out.</p>&#13;
<p>We'll add a task, sending a <kbd>POST</kbd> request to <kbd>http://0.0.0.0:8080/task</kbd>; we can do this using the <kbd>curl</kbd> command:</p>&#13;
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"description":"Remember the Eggs","category":"Shopping"}' http://0.0.0.0:8080/task</strong></pre>&#13;
<p>This should return a JSON representation of the task we just created, which looks like this, although the <kbd>id</kbd> will be different:</p>&#13;
<pre>{<br/>  "id": "CEC93BB9-2487-4207-97D8-E41196B44D24",<br/>  "category": "Shopping",<br/>  "description": "Remember the Eggs"<br/>}</pre>&#13;
<p>Next, let's test our route to show all the existing tasks:</p>&#13;
<pre><strong>curl http://0.0.0.0:8080/task</strong></pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mceNonEditable"/>&#13;
<p>This should return the one <kbd>Task</kbd> we created in an array:</p>&#13;
<pre>[<br/>  {<br/>    "id": "CEC93BB9-2487-4207-97D8-E41196B44D24",<br/>    "category": "shopping",<br/>    "description": "Remember the milk"<br/>  }<br/>]</pre>&#13;
<p>We now have a simple API that stores our tasks.</p>&#13;
<p>Try adding a few more tasks and check whether they are returned from the <kbd>GET</kbd> request.</p>&#13;
<h2 id="uuid-2ddae642-6c64-4fb2-a2f4-0718d01a23eb">There's more...</h2>&#13;
<p>The API we have created so far allows us to perform some operations on a task; namely, to create one and list all the current tasks. Implementing these actions, along with other operations such as modifying, deleting, and listing an individual task, is very common when building a REST API, so Vapor makes this really easy.</p>&#13;
<p>In Vapor, you can define a resource that will define how all these operations are performed, and Vapor handles the setting up of routes that follow standard practice for REST APIs.</p>&#13;
<p>Let's a new file called <kbd>TaskController.swift</kbd> – this will be our new <kbd>TaskControllerAPI</kbd> and will be responsible for housing our REST API response logic and will allow a degree of separation between our routing logic and our business logic:</p>&#13;
<pre class="p1">import Foundation<br/>import Vapor<br/><br/>var tasksByID = [String: Task]()<br/><br/>final class TaskControllerAPI {<br/>    <br/>    typealias Model = Task<br/>                <br/>    func getTasks(req: Request) -&gt; [String: Task] {<br/>        return tasksByID<br/>    }<br/>    <br/>    func createTasks(request: Request) throws -&gt; String {<br/>        let task = try request.content.decode(Task.self)<br/>        tasksByID[task.id] = task<br/>        return "Task Added"<br/>    }<br/>    <br/>}</pre>&#13;
<p><span>We are storing the created tasks in a dictionary, with the key being the task ID; this allows us to easily retrieve them when the ID is passed as a URL parameter.</span></p>&#13;
<p>To create our resource, we provide functions that provide the response for each <kbd>REST</kbd> operation that we would like to support. These areas are listed here:</p>&#13;
<ul>&#13;
<li><kbd>index</kbd></li>&#13;
<li><kbd>store</kbd></li>&#13;
<li><kbd>show</kbd></li>&#13;
<li><kbd>replace</kbd></li>&#13;
<li><kbd>modify</kbd></li>&#13;
<li><kbd>destroy</kbd></li>&#13;
<li><kbd>clear</kbd></li>&#13;
<li><kbd>aboutItem</kbd></li>&#13;
<li><kbd>aboutMultiple</kbd></li>&#13;
</ul>&#13;
<p>As you can see from the preceding code, we've just created a couple to get going. We can add the rest in later as and when we need them.</p>&#13;
<p>Now let's add in an extension that conforms to <strong>RouteCollection</strong>:</p>&#13;
<pre class="p1">extension TaskControllerAPI: RouteCollection {<br/>    <br/>    func boot(routes: RoutesBuilder) throws {<br/>        routes.get("task", use: getTasks)<br/>        routes.post("create", use: createTasks)<br/>    }<br/><br/>}</pre>&#13;
<p>Here is where we take our routes that are specific to the core logic in <kbd>TaskControllerAPI</kbd> and define them as we need. With the routing code added here, we no longer need these in our <kbd>Routes.swift</kbd> file, so head on over there now and replace them with the following single line:</p>&#13;
<pre>try app.register(collection: TaskControllerAPI())</pre>&#13;
<p>Rerun the project and let's test whether everything still works as expected. Let's create a task:</p>&#13;
<pre><strong>curl -H "Content-Type: application/json" </strong><strong>-X POST -d </strong><strong>'{"description":"Remember the milk","category":"shopping"}' </strong><strong>http://0.0.0.0:8080/create</strong></pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mceNonEditable"/>&#13;
<p>Then, fetch all tasks to check our newly created task is returned (notice how we changed the URL to <kbd>create</kbd>):</p>&#13;
<pre><strong>curl http://0.0.0.0:8080/task</strong></pre>&#13;
<p>We've now created a simple REST API for storing and retrieving tasks.</p>&#13;
<p>In the next recipe, we will build on this to make it truly useful.</p>&#13;
<h2 id="uuid-ca2649c5-cc97-46d1-9328-48dc4e052e1e">See also</h2>&#13;
<p>More information about the Vapor framework can be found on its website at <a href="https://vapor.codes">https://vapor.codes</a>.<a href="https://vapor.codes"/></p>&#13;
<p>Here are some other popular Swift web frameworks:</p>&#13;
<ul>&#13;
<li>Kitura: <a href="http://www.kitura.io">http://www.kitura.io</a></li>&#13;
<li>Perfect: <a href="http://perfect.org">http://perfect.org</a></li>&#13;
<li>Zewo: <a href="http://zewo.io/">http://www.zewo.io</a></li>&#13;
</ul>&#13;
<h1 id="uuid-57749ee3-a60c-443f-a7fe-9557b55560ab">Database persistence with Fluent and Postgres</h1>&#13;
<p>In our previous project, our task editor would work a treat as long as the server kept running, but one quick re-start and everything we've saved would be lost forever – which is why persistence, particularly with databases, plays a massive part in software development.</p>&#13;
<p>In this section, we're going to continue to build on our TaskAPI project, adding persistence so that our data is always protected.</p>&#13;
<h2 id="uuid-be8b1d51-f5a3-4e37-b67b-a244a60cedb8">Getting ready</h2>&#13;
<p>For this section, you'll need to install Docker on your Mac. Follow this link for information on Docker and containerization, along with a link to the installer: <a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a>.</p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<h2 id="uuid-59af8ca2-6ad5-4d44-9c13-17cae5f734c9">How to do it...</h2>&#13;
<p>First, we'll need to create our database. Luckily, Vapor can do that for us:</p>&#13;
<ol>&#13;
<li>Start by creating a new file under the <kbd>Migration</kbd> folder called <kbd>CreateTasks.swift</kbd> and copy the following:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct CreateTask: Migration {<br/>    func prepare(on database: Database) -&gt; EventLoopFuture&lt;Void&gt; {<br/>        return database.schema("task")<br/>            .id()<br/>            .field("description", .string, .required)<br/>            .field("category", .string, .required)<br/>            .create()<br/>    }<br/><br/>    func revert(on database: Database) -&gt; EventLoopFuture&lt;Void&gt; {<br/>        return database.schema("task").delete()<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">Notice our struct conforms to <kbd>Migration</kbd> – don't worry, this is normal. Migrations are used even for creating databases. In the preceding code, we're doing the following:</p>&#13;
<ul>&#13;
<li>Creating a database with a schema called <kbd>task</kbd></li>&#13;
<li>Creating fields in our database called <kbd>"description"</kbd>, <kbd>"category"</kbd>, along with an <strong>ID</strong> column</li>&#13;
</ul>&#13;
<p style="padding-left: 60px">And that is it, really – job done. However, we need to tell our server to run the code and perform the migration (the <kbd>create</kbd> for us).</p>&#13;
<ol start="2">&#13;
<li>Go back over to <kbd>Configure.swift</kbd> and add in the following lines:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">app.migrations.add(CreateTask())<br/>    <br/>try app.autoMigrate().wait()</pre>&#13;
<p style="padding-left: 60px">When our server application starts, the database will be created. Don't worry – Vapor only does this once, so if your database already exists, then it won't try and create it again.</p>&#13;
<p class="mce-root"/>&#13;
<ol start="3">&#13;
<li>Next, we need to adjust our code to allow our models to persist to the database matching the properties in our model to the fields we just created. Head back over to the <kbd>Task.swift</kbd> file and make the following highlighted changes:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>import Fluent</strong><br/><br/>final class Task: Content, <strong>Model</strong> {<br/>    <br/>    <strong>static let schema = "task"</strong><br/>    <br/>    <strong>@ID(key: .id)</strong><br/>    var id: UUID?<br/>    <br/>    <strong>@Field(key: "description")</strong><br/>    var description: String<br/>    <br/>    <strong>@Field(key: "category")</strong><br/>    var category: String<br/>    <br/>    <strong>init() { }</strong><br/><br/>    init(id: UUID? = nil, description: String, category: String) {<br/>        self.id = id<br/>        self.description = description<br/>        self.category = category<br/>    }<br/>    <br/>}</pre>&#13;
<p style="padding-left: 60px">We'll go through the structure of this later on in the <em>How it works...</em> section, but for now, you just need to make sure the changes are in.</p>&#13;
<ol start="4">&#13;
<li>Next, head back over to our <kbd>TaskController.swift</kbd> and make the following changes:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><br/>final class TaskControllerAPI {<br/>                    <br/>    func index(req: Request) throws -&gt; EventLoopFuture&lt;[Task]&gt; {<br/>        <strong>return Task.query(on: req.db).all()</strong><br/>    }<br/><br/>    func create(req: Request) throws -&gt; EventLoopFuture&lt;Task&gt; {<br/><strong>        let task = try req.content.decode(Task.self)</strong><br/><strong>        return task.save(on: req.db).map { task }</strong><br/>    }<br/><br/>    func delete(req: Request) throws -&gt; EventLoopFuture&lt;HTTPStatus&gt; {<br/><strong>        return Task.find(req.parameters.get("taskID"), on: req.db)</strong><br/><strong>            .unwrap(or: Abort(.notFound))</strong><br/><strong>            .flatMap { $0.delete(on: req.db) }</strong><br/><strong>            .transform(to: .ok)</strong><br/>    }<br/>    <br/>}<br/><br/><strong>extension TaskControllerAPI: RouteCollection {</strong><br/><strong>    </strong><br/><strong>    func boot(routes: RoutesBuilder) throws {</strong><br/><strong>        let tasks = routes.grouped("tasks")</strong><br/><strong>        tasks.get(use: index)</strong><br/><strong>        tasks.post(use: create)</strong><br/><strong>        tasks.group(":taskID") { task in</strong><br/><strong>            tasks.delete(use: delete)</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/><br/><strong>}</strong><br/></pre>&#13;
<p style="padding-left: 60px">We're almost ready to go. Now we just need to get an instance of our database up and running. We'll achieve this by using a Docker container.</p>&#13;
<ol start="5">&#13;
<li>With Docker installed and running (if you are using Mac, you should have an icon that represents Docker on your toolbar), enter the following command in Terminal:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>$ docker run --name postgres -e POSTGRES_DB=vapor_database \</strong><br/><strong>  -e POSTGRES_USER=vapor_username \</strong><br/><strong>  -e POSTGRES_PASSWORD=vapor_password \</strong><br/><strong>  -p 5432:5432 -d postgres</strong></pre>&#13;
<p style="padding-left: 60px">Notice they perfectly <span>match</span> the details we've got in our <kbd>Configure.swift</kbd> file. Feel free to adjust them accordingly to suit your specific needs/conventions.</p>&#13;
<p style="padding-left: 60px">All being well, you should see the following in Terminal:</p>&#13;
<pre style="padding-left: 60px"><strong>$ Unable to find image 'postgres:latest' locally</strong><br/><strong>$ latest: Pulling from library/postgres</strong></pre>&#13;
<p style="padding-left: 60px">This means everything is going well. Once installed, we're ready to launch our new and improved REST API. Go ahead and run the project from Xcode. You should notice the database migration/creation in Xcode's console window.</p>&#13;
<ol start="6">&#13;
<li>Now launched, use our existing cURL command to add multiple items to our database:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>curl -H "Content-Type: application/json" -X POST -d '{"description":"Remember the eggs","category":"shopping"}' http://0.0.0.0:8080/tasks</strong></pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mceNonEditable"/>&#13;
<p class="mceNonEditable"/>&#13;
<p>Now, restart the server (via Xcode) and call our <kbd>get</kbd> request. You should see a list of all the items we recently persisted. From this, you can now go on to update your API with <kbd>put</kbd> and <kbd>delete</kbd> commands, and many others that adhere to API standards. As this book concentrates on Swift as a programming language, we'll leave that up to you to have a play around with.</p>&#13;
<h2 id="uuid-5743e0a9-6a1f-4f1d-95bc-e116d3ab1fb4">How it works...</h2>&#13;
<p>With our API now up and running, let's dig a little deeper into how we made the persistence work. Let's start by taking a closer look at our <kbd>Task.swift</kbd> class model:</p>&#13;
<pre><strong>import Fluent</strong><br/><br/>final class Task: Content, <strong>Model</strong> {<br/>    <br/>    <strong>static let schema = "task"</strong><br/>    <br/>    <strong>@ID(key: .id)</strong><br/>    var id: UUID?<br/>    <br/>    <strong>@Field(key: "description")</strong><br/>    var description: String<br/>    <br/>    <strong>@Field(key: "category")</strong><br/>    var category: String<br/>    <br/>    <strong>init() { }</strong><br/><br/>    init(id: UUID? = nil, description: String, category: String) {<br/>        self.id = id<br/>        self.description = description<br/>        self.category = category<br/>    }<br/>    <br/>}</pre>&#13;
<p>As you can see, our class now conforms to Model – which is a protocol used by the Fluent framework. This allows us to add attributes to our properties so we can bind these to fields within our database, such as the <kbd>category</kbd> property:</p>&#13;
<pre><strong>@Field(key: "category")</strong><br/>var category: String</pre>&#13;
<p>Without this, Fluent wouldn't know how to bind this causing a failure in persistence. Another added benefit is that our properties are not tied to the naming convention of the database; something that's not a problem when starting from scratch, but this is potentially helpful when working with legacy systems.</p>&#13;
<p class="mce-root"/>&#13;
<p>You'll also notice the <kbd>schema = "task"</kbd> constant we have in there, again another part of the inner workings of our binding that allows our Model to be bound only to a particular database schema.</p>&#13;
<p>Go back over to our <kbd>TaskControllerAPI()</kbd> class and you'll see that the changes we made reference a <kbd>.db</kbd> property. Let's take a look at these:</p>&#13;
<pre>func create(req: Request) throws -&gt; EventLoopFuture&lt;Task&gt; {<br/><strong>    let task = try req.content.decode(Task.self)</strong><br/><strong>    return task.save(on: req.db).map { task }</strong><br/>}</pre>&#13;
<p>In the preceding code, we decode our data using <kbd>content</kbd> to bind this to our Model <kbd>(Task())</kbd>. We are now able to perform a <kbd>.save</kbd> operation on our <kbd>task</kbd> object as this now conforms to <strong>Model</strong> from Fluent.</p>&#13;
<p>The save is being performed on the <kbd>req.db</kbd> and then in turn being <strong>.map</strong>(ed) – once the operation is complete and successful, we can see that the task is returned (which is why we see this in the output window when performing our cURL command).</p>&#13;
<p>If you break down the preceding, the syntax makes a little more sense:</p>&#13;
<pre>func create(req: Request) throws -&gt; EventLoopFuture&lt;Task&gt; {<br/>    let task = try req.content.decode(Task.self)<br/>    return task.save(on: req.db).map {<br/>        task <strong>// Closure here is part of the return function, so will be <br/>          // passed back up</strong><br/>    }<br/>}</pre>&#13;
<p>For those familiar with the previous way of implementing databases in Vapor, you'll certainly appreciate this new and much-improved way of setting up persistence.</p>&#13;
<h2 id="uuid-20c71e9f-328c-4437-b335-704f07ad6f5a">See also</h2>&#13;
<p>Vapor provides a number of other database providers that can be used instead of Postgres:</p>&#13;
<ul>&#13;
<li><strong>MySQL</strong>: <a href="https://github.com/vapor/mysql-provider">https://github.com/vapor/mysql-provider</a></li>&#13;
<li><strong>SQLite</strong>: <a href="https://github.com/vapor-community/sqlite-provider">https://github.com/vapor-community/sqlite-provider</a></li>&#13;
<li><strong>Redis</strong>: <a href="https://github.com/vapor/redis-provider">https://github.com/vapor/redis-provider</a></li>&#13;
<li><strong>Mongo</strong>: <a href="https://github.com/vapor-community/mongo-provider">https://github.com/vapor-community/mongo-provider</a></li>&#13;
</ul>&#13;
<p class="mce-root"/>&#13;
<h1 id="uuid-be274b41-f6fb-4877-a911-a115e62bfc78">Hosting your Vapor app on Heroku</h1>&#13;
<p>In the previous recipes in this chapter, we created a REST API that stores and retrieves information from a Postgres database. We have our Vapor web server running on our local machine and can interact with it over HTTP requests; however, unless you plan on making your machine available to the public internet, this is of limited use, and we need to find somewhere to host our data and REST interface.</p>&#13;
<p>At the time of writing, Swift's support on hosting services is the exception rather than the norm; however, support is growing. Heroku is a popular hosting service that provides dynamic scaling of resources and a really simple deployment mechanism. It also has support for Swift and Postgres, so in this recipe, we will deploy our REST API to Heroku.</p>&#13;
<h2 id="uuid-19cd2265-d8db-49ec-bf54-287534de8730">Getting started</h2>&#13;
<p>Heroku provides simple and scalable infrastructure for your server-side projects. Once deployed, instances of your app are called Dymos, and additional Dymos can be started to cope with increased load.</p>&#13;
<p>Deployment to Heroku happens through a remote Git repository. When you are ready to deploy your app, simply push the code to Heroku.</p>&#13;
<p>First, visit <a href="http://www.heroku.com">http://www.heroku.com</a> and sign up for a free account. Next, we will install the Heroku CLI (<strong>Command-Line Interface</strong>), as this is helpful for interacting with Heroku. Since we installed Homebrew in the previous recipes, we can use it to get the Heroku CLI:</p>&#13;
<pre><strong>brew install heroku</strong></pre>&#13;
<p>Next, we need to log into the Heroku CLI with the account that we just created. Run the <kbd>login</kbd> command and follow the instructions:</p>&#13;
<pre><strong>heroku login</strong></pre>&#13;
<p>We now have our Heroku CLI set up and ready to use.</p>&#13;
<h2 id="uuid-a6b78def-cff0-4c9a-bf17-8ab163798956">How to do it...</h2>&#13;
<p>Since the deployment mechanism for Heroku is Git, we need to create a local Git repo.</p>&#13;
<p class="mce-root"/>&#13;
<p>In Terminal, navigate to the folder containing our <kbd>TaskAPI</kbd> app that we built in the previous recipes, and create a local Git repo:</p>&#13;
<pre><strong>git init</strong></pre>&#13;
<p>Now we need to stage all the files:</p>&#13;
<pre><strong>git add .</strong></pre>&#13;
<p>Then, commit all the code:</p>&#13;
<pre><strong>git commit -m "Initial commit"</strong></pre>&#13;
<p>Next, we will set up this Vapor project to use Heroku and follow the instructions:</p>&#13;
<pre><strong>vapor heroku init</strong></pre>&#13;
<p>You will be asked if you would like a custom name for your app. If you choose not to have a custom app name, then a random app name will be assigned in the form of two words and a number; for example, <kbd>afternoon-bastion-18185</kbd>. Therefore, the app's URL will be <kbd>https://afternoon-bastion-18185.herokuapp.com</kbd>.</p>&#13;
<p>You will also be asked if you want to provide a custom build pack and a custom executable name. You can answer no to both of these.</p>&#13;
<p>We need to associate our local Git repository with the Heroku app we just created. Run the following command, replacing the final parameter with the name of the app that Heroku just created for you:</p>&#13;
<pre class="p1"><strong><span class="s1">heroku git:remote -a afternoon-bastion-18185</span></strong></pre>&#13;
<p>To get our database-backed API up and running on our local machine, we ran a <kbd>Postgresql</kbd> service and configured Vapor's connection to it using a configuration JSON file in <kbd>Config</kbd>/<kbd>secret</kbd>. However, this configuration is specific to our local machine, and so we need to start a <kbd>PostgreSQL</kbd> database service on Heroku and configure Vapor to connect to it.</p>&#13;
<p>Luckily, the Heroku CLI makes this really easy; just run the following:</p>&#13;
<pre><strong>heroku addons:create heroku-postgresql:hobby-dev</strong></pre>&#13;
<p>In this command, <kbd>hobby-dev</kbd> is the pricing plan to use for the database, which is free for up to 10,000 database rows.</p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p>This will cause the database to be made available to your Heroku Dymo whenever your app is deployed. By running <kbd>heroku config</kbd>, we can see that an environment variable called <kbd>DATABASE_URL</kbd> is created, containing the connection URL for the database.</p>&#13;
<p>Now, we need to ensure that Vapor knows how to connect to the database when it's running on Heroku. To do this, we will add a configuration to <kbd>Procfile</kbd>, which is used by Heroku to set up the environment.</p>&#13;
<p>In the root of the project, create a file named <kbd>Procfile</kbd>; open this file and add the following:</p>&#13;
<pre>web: Run serve --env production" --hostname 0.0.0.0 --port \$PORT</pre>&#13;
<p>This will allow Vapor to use the PostgreSQL database set up on Heroku.</p>&#13;
<p>Now, let's commit the change:</p>&#13;
<pre><strong>git add . </strong><br/><strong>git commit -m "Added Procfile with databse URL"</strong></pre>&#13;
<p>We are now ready to push our code to Heroku, which will then be deployed:</p>&#13;
<pre><strong>git push heroku master</strong></pre>&#13;
<div class="packt_infobox">At the time of writing this book - there was/is an open pull request to fix an issue with a missing file <kbd>LinuxTests.swift</kbd><em><strong> </strong></em>if Heroku gives you an error performing the above push, simply create a blank file called <kbd>LinuxTests.swift</kbd><em><strong> </strong></em>and re-commit &amp; push again.</div>&#13;
<p>It may take a while, but eventually, Heroku will report that the code has been deployed and will provide the URL for the deployed app, which will look similar to this:</p>&#13;
<pre>https://afternoon-bastion-18185.herokuapp.com</pre>&#13;
<p>You have a deployed version of our <kbd>TaskAPI</kbd> running on Heroku. You can rerun all the cURL tests from the last recipe, but with the preceding hostname in the place of <kbd>http://0.0.0.0:8080</kbd>.</p>&#13;
<h2 id="uuid-5b36849e-ac27-44fb-a19b-7948cd674515">See also</h2>&#13;
<p class="mce-root">What we have built in this chapter is just the tip of the iceberg of what Vapor is capable of. Vapor has built-in support for authentication, templating, and much more, so check out <a href="http://vapor.codes">http://vapor.codes</a> for the full documentation.</p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root">The team behind Vapor has launched its own hosting service, Vapor Cloud. This really simplifies the process of getting your Vapor app online. At the time of writing, this service is in open beta; you can find out more and sign up at <a href="https://vapor.cloud">https://vapor.cloud</a>.</p>&#13;
<h1 id="uuid-fb54c81a-278c-44bb-a302-7992bce1f8e2">The Swift Package Manager</h1>&#13;
<p>Dependency package management has been around for a while now in software development – the ability to add a dependent framework or snippet to your code base without the need for any major integration has often been seen as a benefit to many.</p>&#13;
<p>Managers such as NuGet and NPM are widely used and maintained by the community. Specifically for iOS development, CocoaPods and Carthage have been the big players; that was until the introduction of the <strong>Swift Package Manager</strong> or <strong>SPM</strong> for short.</p>&#13;
<p>Although it's been around much longer than you might think, it was recently announced at WWDC 2019 that Xcode 11 would have full integration support for the Swift Package Manager.</p>&#13;
<p>In this recipe, we are going to learn how to add a dependency to our project using the Swift Package Manager.</p>&#13;
<h2 id="uuid-f821496d-63d1-40d9-87d4-d6d1cd145440">Getting started</h2>&#13;
<p>For this project, we'll continue using our recent Xcode project where we implemented Fluent and Postgres – you can follow along in the sample recipe from GitHub or alternatively make a copy on disk of your current project and work from that.</p>&#13;
<h2 id="uuid-5040b1cf-6fe1-46a8-98f2-1ea64962bcc1">How to do it...</h2>&#13;
<ol>&#13;
<li>First, open Xcode and from the file tree, locate the following filename:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>Package.swift</strong></pre>&#13;
<ol start="2">&#13;
<li>Here, you should see the start of the following code:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import PackageDescription<br/><br/>let package = Package(<br/>    name: "TaskAPI",<br/>    platforms: [<br/>       .macOS(.v10_15)<br/>    ],<br/><strong>    dependencies: [</strong><br/><strong>        // A server-side Swift web framework.</strong><br/><strong>        .package(url: "https://github.com/vapor/vapor.git", from: <br/>          "4.0.0"),</strong><br/><strong>        .package(url: "https://github.com/vapor/fluent.git", from: <br/>          "4.0.0"),</strong><br/><strong>        .package(url: "https://github.com/vapor/fluent-postgres-<br/>           driver.git", from: "2.0.0"),</strong><br/>    ],<br/><br/>    // ...<br/><br/>)</pre>&#13;
<p style="padding-left: 60px" class="mce-root">In the preceding code, I've highlighted our main area of interest. Here, we currently have a list of existing dependencies – in our case, the Vapor framework and two Fluent dependencies.</p>&#13;
<ol start="3">&#13;
<li>So let's go ahead and add another one in:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">.package(url: "https://github.com/vapor/vapor.git", from: "4.0.0"),<br/>.package(url: "https://github.com/vapor/fluent.git", from: "4.0.0"),<br/>.package(url: "https://github.com/vapor/fluent-postgres-driver.git", <br/>  from: "2.0.0"),<br/><strong>.package(url: "https://github.com/Kitura/BlueSocket.git", from: <br/>  "1.0.0"),</strong></pre>&#13;
<ol start="4">&#13;
<li>Give Xcode a moment or so and it should start to download the new dependency. Failing that, you can push this along a little by using the following command in Terminal:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>$ vapor build</strong></pre>&#13;
<p>If there are any errors with your package file, you'll see them here. Once completed, you'll see your new dependency alongside the existing ones in the File Explorer to the left of Xcode.</p>&#13;
<p class="mce-root"/>&#13;
<p>Xcode also allows you to add package dependencies via the GUI, from Xcode. Select <span class="packt_screen">File</span> | <span class="packt_screen">Swift Packages</span> to see a list of options. Unfortunately, these are only currently supported for <kbd>.xcproject</kbd> files (which Vapor does not use).</p>&#13;
<p class="mce-root"/>&#13;
<h2 id="uuid-f918b074-a1da-47ef-93cb-f3e9f434fba5">How it works...</h2>&#13;
<p>So now we've added in our framework, how does SPM work its magic? We'll start by taking a look at the dependency section of our <kbd>Packages.swift</kbd> file again:</p>&#13;
<pre>.package(url: "https://github.com/vapor/vapor.git", from: "4.0.0"),<br/>.package(url: "https://github.com/vapor/fluent.git", from: "4.0.0"),<br/>.package(url: "https://github.com/vapor/fluent-postgres-driver.git", <br/>  from: "2.0.0"),<br/>.package(url: "<strong>https://github.com/Kitura/BlueSocket.git</strong>", <strong>from: <br/>  "1.0.0"</strong>),</pre>&#13;
<p>I've highlighted two main areas here from our recent addition – the first is the URL. Much like other dependency packages such as Cocoapods and Carthage, SPM pulls its code from a (or your) Git repository.</p>&#13;
<p>Without going into too many details about how a package is actually made, versioning for dependencies is done using tags. In the preceding code, we're looking for any version of the package that starts from 1.0.0 (so the latest could be version 10.2.2, for all we know), but we've made a decision that at the very least, version 1.0.0 is good enough for us.</p>&#13;
<p>But maybe we want to be more specific. Let's see how we'd do that:</p>&#13;
<pre>.package(url: "https://github.com/Kitura/BlueSocket.git", <strong>.exact("1.2.3")</strong>),</pre>&#13;
<p>Here, we're specifying that we only want to use version 1.2.3. The format of the version numbers that we are checking against is what is called semantic versioning.</p>&#13;
<p>This allows us to add additional conditions to our packages such as <kbd>upToNextMajor</kbd> and <kbd>upToNextMinor</kbd> from a specific set version. Here is an example:</p>&#13;
<pre>  .package(url: "https://github.com/Kitura/BlueSocket.git", <br/>    .<strong>upToNextMajor</strong>("1.2.3")),<br/>  .package(url: "https://github.com/Kitura/BlueSocket.git", <br/>    .<strong>upToNextMinor</strong>("1.2.3")),</pre>&#13;
<p><kbd>upToNextMajor</kbd> will include any version up to version 2.0.0.</p>&#13;
<p><kbd>upToNextMinor</kbd> <span>will include any version up to version 1.3.0 (so 1.2.x basically).</span></p>&#13;
<p>More often than not, you won't really need to worry about this, but with a framework dependent on other frameworks, sometimes this can really come in handy to keep everything nice and tidy in your project.</p>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<h2 id="uuid-e004e58d-4736-41d4-b2d0-b9af5d7f5165">There's more...</h2>&#13;
<p>Finally, let's take a look at the remaining code in our <kbd>Packages.swift</kbd> file – let's start at the top:</p>&#13;
<pre>// swift-tools-version:5.2</pre>&#13;
<p>Although this appears to be commented out, it actually plays a big part in our packages file. Here, we're setting the version of Swift that our dependencies must comply with. So if a dependency being downloaded is built with an older version of Swift and is currently unsupported, SPM will let us know about it.</p>&#13;
<p>On the flip side too, if our dependency is newer than our version of Swift, this will be handled.</p>&#13;
<p>Next, let's take a look at the targets section. At first glance, you might feel a little overwhelmed as to what is going on in here, but it is actually straightforward, and for those familiar with other dependency management tools, this will be familiar ground:</p>&#13;
<pre>targets: [<br/><strong>    .target(</strong><br/><strong>        name: "App",</strong><br/><strong>        dependencies: [</strong><br/><strong>            .product(name: "Fluent", package: "fluent"),</strong><br/><strong>            .product(name: "FluentPostgresDriver", package: "fluent-<br/>               postgres-driver"),</strong><br/><strong>            .product(name: "Vapor", package: "vapor")</strong><br/><strong>        ],</strong><br/>        <strong>swiftSettings</strong>: [<br/>            // Enable better optimizations when building in Release <br/>              // configuration. Despite the use of<br/>            // the `.unsafeFlags` construct required by SwiftPM, this<br/>              // flag is recommended for Release<br/>            // builds. See &lt;https://github.com/swift-<br/>               // server/guides#building-for-production&gt; for details.<br/>            .unsafeFlags(["-cross-module-optimization"], <br/>              .when(configuration: .release))<br/>        ]<br/>    )<br/><br/>    // ..<br/><br/>]</pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p>In the preceding code, I've highlighted some key areas. The first is the list of targets. All we are doing here is identifying one of our targets (in our case our <strong>App</strong> target) and adding a list of specific dependencies for that target.</p>&#13;
<p>These names are the actual package names once installed – not the Git URL. These are defined outside the targets array on a more global scale for our project. Here, we are simply cherry-picking what should be used for what specific target.</p>&#13;
<p>The same goes for <kbd>swiftSettings</kbd> too, a place where we can set Swift-specific optimizations for the build when in either release or debug mode (but generally we do this for release builds).</p>&#13;
<h2 id="uuid-88533db6-489b-4b21-a44e-aafc21846edb">See also</h2>&#13;
<p>For more information, refer to the following links:</p>&#13;
<ul>&#13;
<li>Semantic versioning: <a href="https://semver.org">https://semver.org</a></li>&#13;
<li>Building for production: <a href="https://github.com/swift-server/guides#building-for-production">https://github.com/swift-server/guides#building-for-production</a></li>&#13;
<li>CocoaPods: <a href="https://cocoapods.org">https://cocoapods.org</a></li>&#13;
<li>Carthage: <a href="https://github.com/Carthage/Carthage">https://github.com/Carthage/Carthage</a></li>&#13;
</ul>&#13;
<h1 id="uuid-52f7bd21-ccd3-4c51-81ec-99c300b91f2b"><span>Real-time communication using WebSockets</span></h1>&#13;
<p>Communicating via WebSockets has been around for a long time and plays an integral part in server-to-server, server-to-client, and client-to-server communications. WebSockets allow open and constant communication between both parties, thus allowing data to be sent and received without the need for "polling" for changes.</p>&#13;
<p>A commonplace where you might see WebSockets being used would be a chat window – a constant line of communication between each device (usually via a server). Think of it as the "telephone line" of the internet (which is actually not too far from the truth).</p>&#13;
<p>In this section, we are going to take our previously built Vapor project and communicate in real time with a companion iOS app.</p>&#13;
<h2 id="uuid-5e2ab783-a08a-463a-95aa-a800096f3c85">Getting started</h2>&#13;
<p class="mce-root">For this section, you'll need the completed project from our previous section. Feel free to continue to work on the sample project found in the Git repository.</p>&#13;
<p>In addition, you'll need the <strong>TaskAPIApp</strong> project.</p>&#13;
<h2 id="uuid-efcd5770-b5dc-42fb-9611-3f56f10bffb2">How to do it...</h2>&#13;
<p>First of all, let's head over to our <kbd>Routes.swift</kbd> file and add in the following:</p>&#13;
<pre>app.webSocket("talk-back") { req, ws in<br/>                <br/>}</pre>&#13;
<p>Look familiar? Here, we are ultimately creating an "endpoint" for our WebSocket called <kbd>"talk-back"</kbd>. When successfully connected, all data will be received via the <kbd>ws</kbd> parameter in the function. But how can we intercept this? Well, there are a couple of ways actually. Let's take a look:</p>&#13;
<pre>app.webSocket("talk-back") { req, ws in<br/>                <br/><strong>    ws.onText { ws, text in</strong><br/><strong>        print(text)</strong><br/><strong>    }</strong><br/><strong>        </strong><br/><strong>    ws.onBinary { (ws, buffer) in</strong><br/><strong>        print(buffer)</strong><br/><strong>    }</strong><br/><br/>}</pre>&#13;
<p>Our client, when connected to our server via WebSockets, can send a number of specific commands, such as sending plain text or sending binary text. For this recipe, we'll just be using <kbd>onText</kbd>.</p>&#13;
<p>Add the following code and run your server:</p>&#13;
<pre>app.webSocket("talk-back") { req, ws in<br/>        <br/>    ws.onText { ws, text in<br/><strong>        if text.lowercased() == "hello" {</strong><br/><strong>            ws.send("Is it me your are looking for...?")</strong><br/><strong>        }</strong><br/>    }<br/><br/>}</pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p>So, essentially, what we are doing here is listening for a message from our client (any message), but if the message meets our specific condition, we're going to send a response straight back.</p>&#13;
<p>Now, from the GitHub repository, fire up the <strong>TaskAPIApp</strong> project in Xcode. Here, you'll notice we're using a third-party dependency called Starscream to enable our app as a WebSocket client – we could have gone through and built our own but that was a little out of scope and unnecessary for this recipe.</p>&#13;
<p>One thing to note: we used SPM in order to obtain the Starscream dependency – take a look in the Xcode project and compare it to our Vapor project to see how it matches up!</p>&#13;
<p>Okay, with the iOS app loaded, check out the <kbd>ViewController.swift</kbd> file and make sure the localhost URL is correct as per your current setup (it should be the same if you are following along):</p>&#13;
<pre>guard let url = URL(string: "<strong>http://127.0.0.1:8080/talk-back</strong>") else {<br/>  return }</pre>&#13;
<p>If you take a closer look in the <kbd>ViewController.swift</kbd> file, you'll see the following hooked up to an <kbd>IBAction</kbd>:</p>&#13;
<pre>@IBAction func onSendRequest(_ sender: Any) {<br/>    <strong>socket.write(string: "Hello")</strong><br/>}</pre>&#13;
<p>We've got the option to send a String via our WebSocket connection – boom!</p>&#13;
<p>Launch the project (still making sure your Vapor server is running locally) and click the button. What do you see? All being well, you should see the words <span class="packt_screen">Is it me you are looking for...?</span> appear in the <kbd>UILabe</kbd><kbd>l</kbd> – nice!</p>&#13;
<h2 id="uuid-70592298-b20c-44ff-b5fa-115b42ee49a8">How it works...</h2>&#13;
<p>WebSockets in Vapor act in a similar way to routes. Just as we said about our talk-back endpoint we created that the only difference was that the connection was open, <span>the difference here is there have been no additional calls made – our server didn't need to rebuild and re-connect a new URL request, so there's no additional authorization or authentication. Our client (much like our server) was just listening for a response.</span></p>&#13;
<p class="mce-root"/>&#13;
<p>All WebSocket calls are asynchronous – and don't reply in the usual request/response pattern that we see with HTTP. However, it is <span>up to</span> you, the client or the server, to manage this connection, checking to make sure it is still not alive, and being ready to handle the requests at any time.</p>&#13;
<h2 id="uuid-fa6a1faa-ca9b-4ce0-8239-a27618ea6d1f">There's more...</h2>&#13;
<p>We touched earlier on the <kbd>onText</kbd> and <kbd>onBinary</kbd> functions available to us when receiving a message from our client, but by default, WebSockets constantly ping each other to make sure they are still active (or alive). We can monitor these requests by intercepting them with the following functions:</p>&#13;
<pre>ws.onPong { (ws) in }<br/>ws.onPing { (ws) in }</pre>&#13;
<p>Alternately, we can use our Vapor project to connect to a WebSocket too:</p>&#13;
<pre>WebSocket.connect(to: "ws://talk-back.websocket.org", on: eventLoop) {<br/>  ws in<br/>    print(ws)<br/>}</pre>&#13;
<p>Sending messages whilst connected as a client is performed in the same way as we sent a message earlier, either through plain text or binary:</p>&#13;
<pre>ws.send("Is it me your are looking for...?") // Plain "String" Text<br/>ws.send([1, 2, 3]) // Binary as UIInt</pre>&#13;
<p>While sending messages is done asynchronously, sometimes we would like to know if our message has been sent successfully – we can do this with the use of the <kbd>eventLoop</kbd> promise:</p>&#13;
<pre>let promise = eventLoop.makePromise(of: Void.self)<br/>ws.send("Hello", promise: promise)<br/>promise.futureResult.whenComplete { result in<br/>    // Succeeded or failed to send.<br/>}</pre>&#13;
<p>And finally, we have these options to close and handle our open WebSocket connections:</p>&#13;
<pre>ws.close()<br/>ws.close(promise: nil)<br/>ws.onClose.whenComplete { result in<br/>    // Succeeded or failed to close.<br/>}</pre>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mce-root"/>&#13;
<p class="mceNonEditable"/>&#13;
<p>WebSockets really are a way of opening up your server in terms of real-time connectivity to your client. There are usually many things that it can be used for, such as dashboard reporting and chat messaging.</p>&#13;
<h2 id="uuid-924a90b5-4131-485c-a4e1-acb4572fc807">See also</h2>&#13;
<p>WebSockets: <a href="https://docs.vapor.codes/4.0/websockets/">https://docs.vapor.codes/4.0/websockets/</a></p>&#13;
<h1 id="uuid-3415f01f-9a52-4567-9aee-b15e4338e1b8">Packaging and sharing models between server and app</h1>&#13;
<p>Server-side Swift is credited for the fact that web application developers can harness the power of the Swift programming language first hand. This, along with the power of the open source community behind it – even in what is still classed as its infancy - means that server-side Swift is already a worthy production-quality option.</p>&#13;
<p>But what about other advantages, specifically for iOS developers who now build their apps using Swift? Other than knowledge of syntax and specific APIs, what else can they benefit from?</p>&#13;
<p>As we saw earlier in this chapter, with the integration of the Swift Package Manager into Xcode, we can now build out some of our code into a module that we can reuse in both our server-side Swift apps and our iOS apps.</p>&#13;
<h2 id="uuid-9e7a80bd-1079-4324-963b-0a03309f75d8">Getting started</h2>&#13;
<p>For this section, we'll continue to work on our Vapor project and will continue to work on a Mac using Xcode.</p>&#13;
<h2 id="uuid-03daf462-167c-49d6-b41c-8d3da3c4a615" class="mce-root">How to do it...</h2>&#13;
<p>For a moment, let's take a step away from our Vapor app. We'll start by creating a new Swift package module. In Xcode, click on <strong>File</strong> | <strong>New</strong> | <strong>Swift Package –</strong> call it <kbd>TaskModule</kbd> and click <span class="packt_screen">Save</span>. You should now be presented with a brand-new project.</p>&#13;
<p class="mce-root"/>&#13;
<p>If you take a look at File Explorer, you'll see some familiar files, such as <kbd>Packages.swift</kbd>. Our main concern is the files that live inside the <span class="packt_screen">Sources</span> folder – here is where your files and classes will live and will grow as part of the module you want to use:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/05cee1ff-cdd9-453a-8d40-c311d61f65de.png" width="259" height="204"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 8.3 – Sources folder</span></div>&#13;
<p>Let's start by creating a new file called <kbd>TaskViewModel.swift</kbd> – this file will be a view model to the model we created in our Vapor project.</p>&#13;
<div class="packt_infobox">A view model is basically a model that only houses data based on what is required to render a particular view, for example, a response model from a server might have 20 properties all containing information such as date timestamps, created by, and so on, but our rendered view may only be interested in a handful of that information or may want to manipulate or compute some of the data into one single property.</div>&#13;
<p>Add the following code:</p>&#13;
<pre>import Foundation<br/><br/>enum Category: String {<br/>    case shopping = "shopping"<br/>    case work = "work"<br/>}<br/><br/>public final class TaskViewModel {<br/>    <br/>    var category: Category?<br/>    var title: String?<br/>    <br/>    var imageUrl: URL?<br/>    <br/>    public convenience init(title: String, category: String) {<br/>        self.init()<br/>        <br/>        self.category = Category(rawValue: category)<br/>        self.title = title<br/>        <br/>        self.imageUrl = URL(string: "https://www.test.com/\(category)")<br/>        <br/>    }<br/><br/>}</pre>&#13;
<p>In the preceding code, we are building a very basic view model, an enum class to bind our category to a 1-1 match on our title property, and a computed property for an image URL.</p>&#13;
<p>As it stands, that code can be used in either our server-side Swift project or an iOS app – but how do we get it to do both? Well, easy! As we've created this as a Swift package, we can just import it as a Swift package . Close this project from Xcode (important) and head on over to <kbd>Packages.swift</kbd> in your Vapor app.</p>&#13;
<p>Add the following highlighted changes. Note that the local path must be the one on your machine – this needs to point to the directory where your <kbd>Packages.swift</kbd> file lives:</p>&#13;
<pre>dependencies: [<br/>        // A server-side Swift web framework.<br/>    .package(url: "https://github.com/vapor/vapor.git", from: "4.0.0"),<br/>    .package(url: "https://github.com/vapor/fluent.git", from: <br/>      "4.0.0"),<br/>    .package(url: "https://github.com/vapor/fluent-postgres-<br/>      driver.git", from: "2.0.0"),<br/><strong>    .package(path: "/path/to/your/TaskModule")</strong><br/>],<br/>targets: [<br/>    .target(<br/>        name: "App",<br/>        dependencies: [<br/>            .product(name: "Fluent", package: "fluent"),<br/>            .product(name: "FluentPostgresDriver", package: "fluent-<br/>               postgres-driver"),<br/>            .product(name: "Vapor", package: "vapor"),<br/><strong>           .product(name: "TaskModule", package: "TaskModule"),</strong><br/>],</pre>&#13;
<p>Here, we're doing just as we did previously – adding in our package and then referencing a module name to the package for our specific target.</p>&#13;
<p class="mce-root"/>&#13;
<p>Give Xcode a moment to pick up this change and, as if by magic, you'll see our recently created module inside our dependency tree. Let's go ahead and try and use it.</p>&#13;
<p class="mce-root"/>&#13;
<p>For now, let's add this into our <kbd>TaskControllerAPI()</kbd> file as it is in here that we find bind our original <strong>Task</strong> model from our response.</p>&#13;
<p>We'll start by importing our Module:</p>&#13;
<pre>import TaskModule</pre>&#13;
<p>All being well, this should resolve nicely. Now let's try and access our view model:</p>&#13;
<pre>let viewTask = TaskViewModel(title: "", category: "")</pre>&#13;
<p>And it really is as simple as that. Let's take a look at this from the other side now and see how we can use this same module in our iOS app:</p>&#13;
<ol>&#13;
<li>First, we need to make sure that our <kbd>TaskModule</kbd> folder is initialized as a Git repo and there is an initial commit performed – I'll explain why shortly, but for now, just simply perform the following commands in Terminal to initialize a repository for the project:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">$ <strong>git init</strong><br/>$ <strong>git add .</strong><br/>$ <strong>git commit -m "Initial commit"</strong></pre>&#13;
<p>Now open our existing project, <kbd>TaskAPIApp</kbd>, in Xcode and select <span class="packt_screen"><strong>File</strong></span> | <strong><span class="packt_screen">Swift</span></strong> <span class="packt_screen"><strong>Package</strong></span> | <strong><span class="packt_screen">Add Package Dependency</span></strong>.</p>&#13;
<p>You'll be presented with a GUI asking for the URL for a Git repository. As ours is currently local, we need to give it in the following format:</p>&#13;
<pre>file:///Users/chris/Source/TaskModule</pre>&#13;
<p>Xcode requires an active Git repository in order to pull a dependency – so we've just created one locally, as opposed to remotely. Xcode is happy and will allow us to continue:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/d1f46004-0502-416e-abe3-40c38b64f0dc.png" style="" width="498" height="250"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 8.4 – Choose a package repository</span></div>&#13;
<p>The next screen should now look like this:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/6db05d2b-d16a-4a36-bb36-1e126ae45fbd.png" style="" width="522" height="272"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 8.5 – Choose the package option</span></div>&#13;
<p>Specify a <strong><span class="packt_screen">Branch</span></strong> and enter <kbd>master</kbd> and click <strong><span class="packt_screen">Next</span></strong>. All being well, Xcode should be ready to import your dependency – click <span class="packt_screen">Finish</span>.</p>&#13;
<p class="mce-root"/>&#13;
<p>Go back over to your Xcode project and you'll now see <kbd>TaskModule</kbd> successfully imported into your project. Let's make sure this is all working as expected. Head on over to your <kbd>ViewControler.swift</kbd> file and let's try and use our view model.</p>&#13;
<p>We'll start by importing our <kbd>TaskModule</kbd>:</p>&#13;
<pre>import TaskModule</pre>&#13;
<p>And now we should be able to access our view model perfectly from anywhere within our iOS code base:</p>&#13;
<pre>let _ = TaskViewModel(title: "", category: "")</pre>&#13;
<p>Wonderful – we've now successfully created and reused our view model in both our iOS and server-side Swift project.</p>&#13;
<h2 id="uuid-36b42bb5-74cf-4b2f-936d-a36515e6292b" class="mce-root">How it works...</h2>&#13;
<p><span>The beauty of being able to use our code in both server-side Swift and iOS projects doesn't have to stop at things like view models; specific computed logic can sit in here too, but you just have to be aware of a couple of things: remember your server-side Swift project is 99% likely to be running on a Linux server, so frameworks such as UIKit won't be available for use; however, this works both ways too.</span></p>&#13;
<p><span>Our <kbd>Codable</kbd> equivalent <kbd>Content</kbd> on Vapor which won't be available in our iOS project (as it simply just isn't needed there), so think carefully about how you want to split and share your logic. Take time to understand your requirements and separation of concerns when developing your application.</span></p>&#13;
<p>That aside, there are ways to target specific operating systems that our apps could be running on. Let's have a look at how we would achieve this:</p>&#13;
<pre class="mce-root"><strong>#if os(Linux)</strong><br/>import LinuxModule<br/><strong>#else</strong><br/>import GlobalModule<br/><strong>#endif</strong></pre>&#13;
<p>If you need to be a bit more specific, you can identify operating systems with the following:</p>&#13;
<pre>#if os(macOS)<br/>#if os(iOS)<br/>#if os(watchOS)<br/>#if os(tvOS)</pre>&#13;
<p class="mce-root"/>&#13;
<p>Again, if you're running your server-side Swift project on macOS, you'll be fine – but you're not really future-proofing your code as you may find at some point in the future, it's going to be more cost-effective and versatile to run your app on a Linux box.</p>&#13;
<p>Looking a little deeper into how the Swift Package Manager works is not as complex as you might think – although, I may add, it has exceptional convenience and power.</p>&#13;
<p>For those familiar with workspaces in Xcode, this follows a not too dissimilar pattern – essentially, your module is a link to the project we created earlier. The version of the code that is pulled into your project is defined by the <kbd>version number</kbd>, <kbd>branch</kbd>, or even <kbd>commit</kbd> we specify.</p>&#13;
<h2 id="uuid-9c6b1fc5-37d4-4a2c-a9b2-62727ed6e4c6" class="mce-root">There's more...</h2>&#13;
<p>Creating a package to use internally is one thing, but distributing it to others – either within your organization or the community – is another.</p>&#13;
<p>This is where hosting your package in a remote Git repository comes in handy. This not only allows you to version-control the changes in your package independently, but you can choose to administer these with a private repository, allowing for controlled internal use.</p>&#13;
&#13;
&#13;
            </article>&#13;
&#13;
            &#13;
        </section>&#13;
    </div></body></html>