<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Creational Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Creational Patterns</h1></div></div></div><p>The creational patterns are designed to deal with the object creation mechanism in software designing. A system using these patterns becomes independent of how objects are created, which means it is independent of how concrete classes are instantiated.</p><p>These patterns encapsulate the use of concrete classes and favor the use of interfaces in the relationship between objects, allowing to have better abstraction of the global system conception.</p><p>Thus, if we analyze the <a class="indexterm" id="id0"/>
<span class="strong"><strong>singleton</strong></span> pattern, a pattern designed to instantiate only one instance of a class, we find that the mechanism that controls the unique access to this instance is fully encapsulated in the class, which means that this is completely transparent to the client consuming the instance of the class.</p><p>In this chapter, we will introduce you to the five<a class="indexterm" id="id1"/> creational patterns and discuss how we can use them with Swift:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The prototype pattern</li><li class="listitem" style="list-style-type: disc">The factory method pattern</li><li class="listitem" style="list-style-type: disc">The singleton pattern</li><li class="listitem" style="list-style-type: disc">The abstract factory pattern</li><li class="listitem" style="list-style-type: disc">The builder pattern</li></ul></div><p>The objectives of these patterns are described in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pattern</p>
</th><th style="text-align: left" valign="bottom">
<p>Objective</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>The prototype pattern</p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id2"/> pattern<a class="indexterm" id="id3"/> allows you to create new objects by duplicating existing objects called prototypes. This pattern has the cloning capability.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The factory method pattern</p>
</td><td style="text-align: left" valign="top">
<p>This pattern<a class="indexterm" id="id4"/> introduces you to an abstract method<a class="indexterm" id="id5"/> that allows you to create an object by telling its subclasses about the effective creation of the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The singleton pattern</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id6"/>pattern<a class="indexterm" id="id7"/> ensures that a class has only one instance. This class provides a unique point of access that returns this instance.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The abstract factory pattern</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id8"/>pattern<a class="indexterm" id="id9"/> allows you to create an object that is grouped in families by hiding the concrete classes that are needed to create these objects.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The builder pattern</p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id10"/> pattern <a class="indexterm" id="id11"/>allows you to separate the creation of complex objects from their implementation. This permits a client to create complex objects having different representations.</p>
</td></tr></tbody></table></div><div class="section" title="The prototype pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The prototype pattern</h1></div></div></div><p>Our first <a class="indexterm" id="id12"/>pattern will be the prototype pattern; we will <a class="indexterm" id="id13"/>see how we can use it to accelerate the creation of an instance. We will see how we can use it to copy an existing instance, and eventually, we will see how to modify the new one to our needs.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id14"/>prototype pattern is used to create a new object by duplicating existing objects called <span class="strong"><strong>prototypes</strong></span>, and they have a cloning capability.</p><p>This pattern is used in the following <a class="indexterm" id="id15"/>use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When you need to create an instance without knowing the hierarchy of a class</li><li class="listitem" style="list-style-type: disc">When you need to create class instances that are dynamically loaded</li><li class="listitem" style="list-style-type: disc">When you need to have a simple object system and not include a parallel hierarchy of a factory class</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id16"/> following diagram shows the generic class of the prototype pattern:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_01_01.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Participants</h2></div></div></div><p>Participant to this pattern are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: This <a class="indexterm" id="id17"/>class contains a list of objects called prototypes that are instances of the <code class="literal">AbstractPrototype</code> abstract class. The <code class="literal">Client</code> class needs to clone these prototypes without having to know their internal structure and subclass hierarchy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AbstractPrototype</code>: This is <a class="indexterm" id="id18"/>an abstract class that can duplicate itself. This class contains a cloning method called <code class="literal">clone()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcretePrototype1</code> and <code class="literal">ConcretePrototype2</code>: These <a class="indexterm" id="id19"/>are concrete classes <a class="indexterm" id="id20"/>that inherit from the <code class="literal">AbstractPrototype</code> class. They define a prototype and have both a cloning method called <code class="literal">clone()</code>.</li></ul></div></div><div class="section" title="Collaborations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Collaborations</h2></div></div></div><p>The<a class="indexterm" id="id21"/> client asks to one or more prototypes to clone themselves.</p></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Illustration</h2></div></div></div><p>A <a class="indexterm" id="id22"/>simple and real example of where this pattern can be applied is the famous game <span class="emphasis"><em>HeartStone</em></span> from <span class="emphasis"><em>Blizzard</em></span> (the creator of <span class="emphasis"><em>World of Warcraft</em></span>). In this strategy card game, when you spend "mana" to use spells, weapons, or put a minion on the board, there is a special minion that has the ability to clone a particular card. When a player uses this card, it selects the minion that he or she wants to clone and the card becomes an exact copy of the selected card. The following card represent the "HeartStone" card that have this behavior:</p><div class="mediaobject"><img alt="Illustration" src="graphics/4852_01_02.jpg"/></div></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Implementation</h2></div></div></div><p>The following code represent the implementation of the pattern using Swift:</p><div class="informalexample"><pre class="programlisting">import UIKit

class AbstractCard {
  var name: String?
  var mana: Int?
  var attack: Int?
  var defense: Int?
  
  init(name:String?, mana:Int?, attack:Int?, defense:Int?) {
    self.name = name
    self.attack = attack
    self.defense = defense
    self.mana = mana
  }
  
  func clone() -&gt; AbstractCard {
    return AbstractCard(name: self.name, mana: self.mana, attack: self.attack, defense: self.defense)
  }
}

class Card: AbstractCard {
  
  override init(name:String?, mana:Int?, attack:Int?, defense:Int? ) {
    super.init(name: name,mana: mana,attack: attack,defense: defense)

  }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The <code class="literal">AbstractPrototype</code> class is our <code class="literal">AbstractCard</code> class, where we implement a way to return a copy of itself using the <code class="literal">clone()</code> method.</p></div></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Usage</h2></div></div></div><p>The following code simulate how the client will interact with the <code class="literal">Card</code> object which implement the prototype pattern:</p><div class="informalexample"><pre class="programlisting">// Simulate our client

// This is the card that we will copy
let raidLeader = Card(name: "Raid Leader", mana: 3, attack: 2, defense: 2)

// Now we use our faceless Manipulator card to clone the raidleader
let facelessManipulator = raidLeader.clone()

print("\(facelessManipulator.name, facelessManipulator.mana, facelessManipulator.attack, facelessManipulator.defense)")</pre></div><p>Since the code is written in a Playground file, you should consider it as the code that you'll put in the <code class="literal">Client</code> class.</p><p>First, we instantiate a new card named <code class="literal">Raid Leader</code>. This is a concrete prototype class. Let say that you have the "Faceless Manipulator" card and you want to use it to clone the "Raid Leader" card, then you simply need to use the <code class="literal">raidLeader.clone()</code> method that will return a new instance with the exact same properties as "Raid Leader".</p><p>By checking the details on the right-hand side of the Playground file, you'll see that the <code class="literal">facelessManipulator</code> constant <a class="indexterm" id="id23"/>has exactly the same properties as <code class="literal">raidLeader</code> (line 39), as shown in the following screenshot:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_01_03.jpg"/></div></div></div></div>
<div class="section" title="The factory method pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The factory method pattern</h1></div></div></div><p>Our <a class="indexterm" id="id24"/>second pattern is a very well-known pattern. It introduces you to the famous concept: "Program to an interface, not an implementation." The instantiation is done in the factory class that depends on the type that we need and the type that needs to be returned to the client.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id25"/>factory method pattern is one of the most used patterns in software designs. The purpose of this pattern is to abstract the creation of an object. The factory method lets a class defer instantiation to subclasses.</p><p>You'll see from that time to time that we have mentioned "program to an interface." This is exactly what this pattern does. With Swift, instead of an interface, you'll code with the "protocol" instead of the class itself.</p><p>This pattern is used in the following <a class="indexterm" id="id26"/>use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A class only knows about abstract classes or interfaces of objects with whom it has some relationships</li><li class="listitem" style="list-style-type: disc">A class wants its subclasses to instantiate the object in order to benefit of polymorphism mechanism</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Design</h2></div></div></div><p>The following <a class="indexterm" id="id27"/>diagram shows the generic class of the factory method pattern:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_01_04.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Participants</h2></div></div></div><p>Participant to this pattern are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Product interface</strong></span>: This<a class="indexterm" id="id28"/> class contains the definition of our product. We will define what a card is here.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstract product</strong></span>: This abstract <a class="indexterm" id="id29"/>class implements the signature of our cards and some methods. You'll see that we keep the prototype pattern that allows us to eventually clone a card. These classes define the properties of our products.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete product</strong></span>: This <a class="indexterm" id="id30"/>class defines our product; in our example, the <code class="literal">Raid Leader</code> card is a concrete product, such as the <code class="literal">Faceless Manipulator</code> card.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete creator</strong></span>: This<a class="indexterm" id="id31"/> class implements our factory method.</li></ul></div></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Illustration</h2></div></div></div><p>In <a class="indexterm" id="id32"/>our previous pattern, you would have seen the following line:</p><div class="informalexample"><pre class="programlisting">let raidLeader = Card(name: "Raid Leader", mana: 3, attack: 2, defense: 2)</pre></div><p>Here, we directly program an implementation. We need a way to create some cards, but without having the knowledge to know exactly how to construct the card; we can only tell to create the <code class="literal">raidLeader</code> and <code class="literal">Faceless Manipulator</code> cards. At this point of time, the client doesn't want to know that the <code class="literal">Raid Leader</code> card needs three manas, so it provides two points of attack and two points of defense.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Implementation</h2></div></div></div><p>The implementation of the factory method pattern is as follows:</p><div class="informalexample"><pre class="programlisting">import UIKit
import Foundation

//Define what a card is
protocol Card {
  var name: String? {get set}
  var attack: Int? {get set}
  var defense: Int? {get set}
  var mana: Int? {get set}
  func clone() -&gt; Card
  func toString() -&gt; String
}

// AbstractCard
// implements the signature and some properties
class AbstractCard: NSObject, Card {
  private var _name: String?
  private var _mana: Int?
  private var _attack: Int?
  private var _defense: Int?
  
  init(name: String?, mana: Int?, attack: Int?, defense: Int?) {
    self._name = name
    self._attack = attack
    self._defense = defense
    self._mana = mana
    super.init()
  }
 
  override init(){
    super.init()
  }
  
  //property name
  var name: String?{
    get{ return _name }
    set{ _name = newValue }
  }
  
  //property mana
  var mana: Int? {
    get{ return _mana }
    set{ _mana = newValue }
  }
  
  //property attack
  var attack: Int? {
    get{ return _attack }
    set{ _attack = newValue }
  }
  
  //property attack
  var defense: Int? {
    get{ return _defense }
    set{ _defense = newValue }
  }
  
  func clone() -&gt; Card {
    return AbstractCard(name: self.name, mana: self.mana, attack: self.attack, defense: self.defense)
  }
  
  func toString() -&gt; String{
    return ("\(self.name, self.mana, self.attack,self.defense)")
  }
}

enum CardType {
  case FacelessManipulator, RaidLeader
}

// our Factory Class
// Depending what we need, this class return an instance of the 
// appropriate object.
class CardFactory{
  class func createCard(cardtype: CardType) -&gt; Card?{
    
    switch cardtype {
    case .FacelessManipulator:
      return FacelessManipulatorCard()
    case .RaidLeader:
      return RaidLeaderCard()
    default:
      return nil
    }
  }
}

//Concrete Card "Raid Leader"
//This is the full definition of the Raid Leader Card
class RaidLeaderCard: AbstractCard {
  override init()
  {
    super.init()
    self._mana = 3
    self._attack = 2
    self._defense = 2
    self._name = "Raid Leader"
  }
}

//Concrete Card "Faceless Manipulator"
//this is the full definition of the FacelessManipulator Card.
class FacelessManipulatorCard: AbstractCard {
  override init()
  {
    super.init()
    self._mana = 5
    self._attack = 3
    self._defense = 3
    self._name = "Faceless Manipulator"
    
  }
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Usage</h2></div></div></div><p>To simulate the use of the factory method pattern by a client, we can write the card creation as follows:</p><div class="informalexample"><pre class="programlisting">//simulate our client

var c = CardFactory.createCard(.FacelessManipulator)
c?.toString()</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>To simulate our client, we simply tell the <code class="literal">CardFactory</code> method that we want a <code class="literal">FacelessManipulator</code> card.</p><p>To do this, we use the <code class="literal">createCard</code> method (our factory method), and this method will delegate the instantiation of the card that was asked.</p><p>The variable <code class="literal">c</code> has the type <code class="literal">Card</code> and not <code class="literal">FacelessManipulator</code>.</p></div></div></div></div>
<div class="section" title="The singleton pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>The singleton pattern</h1></div></div></div><p>This <a class="indexterm" id="id33"/>pattern is certainly the pattern that every <a class="indexterm" id="id34"/>developer learns first. It is often used with a factory or abstract factory class to ensure that there is only one instance of the class.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Roles</h2></div></div></div><p>The<a class="indexterm" id="id35"/> singleton pattern ensures that a class has only one instance and provides a global point of access to it, and at this point, it returns an instance of this class.</p><p>In some cases, it can be useful to have some classes that have only one instance; for example, in the case of the abstract factory, where it is not useful to have several instances.</p></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id36"/> following figure shows the generic UML class diagram of the singleton pattern. There are many way to write the singleton pattern using Swift.</p><p>Here, we use the easiest way to do this. With Swift, you'll see that we can change the way in which we apply it, thanks to the class constant:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_01_05.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Participants</h2></div></div></div><p>There is <a class="indexterm" id="id37"/>only one participant in this pattern: the <code class="literal">Singleton</code> class.</p><p>This class provides a method that returns only one instance of the class. The mechanism locks the creation of other instances. It was introduced with Swift 1.2. We can now use class constants.</p><p>With Swift 1.2, we will use the class constants to provide us with a way to ensure the unique creation of the instance.</p><p>A class constant is defined as follows:</p><div class="informalexample"><pre class="programlisting">static let myVariable = myObject()</pre></div></div><div class="section" title="Collaborations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Collaborations</h2></div></div></div><p>Every <a class="indexterm" id="id38"/>client will have access to the unique instance of the <code class="literal">Singleton</code> class by calling the <code class="literal">Instance</code> method.</p><p>With Swift, the approach we'll consider is the one that accesses our unique instance of the <code class="literal">Singleton</code> class using the class constant that we will call <code class="literal">sharedInstance</code>.</p></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Illustration</h2></div></div></div><p>You are <a class="indexterm" id="id39"/>developing your card game and you need to manage all the data of the current game. In our game, we have two players; each player has a deck, mana reserve, name, and so on. We have a board (the table where we put our cards) and a game state (who is currently playing). To manage all of this information, you'll need a <code class="literal">BoardManager</code> class. This class will be a singleton class because we will not have several boards at the same time (we only allow one game at a time). The singleton pattern can be something interesting that can be used here in order to make sure that we access the good data.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Implementation</h2></div></div></div><p>The<a class="indexterm" id="id40"/> following approach supports lazy initialization, and it is thread safe by the definition of <code class="literal">let</code>:</p><div class="informalexample"><pre class="programlisting">import UIKit

class BoardGameManager {
  
  static let sharedInstance = BoardGameManager()
  init() {
    println("Singleton initialized");
  }
  
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Usage</h2></div></div></div><p>To <a class="indexterm" id="id41"/>use our singleton object, each client will access it using the following code :</p><div class="informalexample"><pre class="programlisting">let boardManager = BoardGameManager.sharedInstance</pre></div><p>The <code class="literal">boardManager</code> variable contains all the members available in our singleton object and will be initialized only once.</p><p>This pattern is used in the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We must have only one instance of a class</li><li class="listitem" style="list-style-type: disc">This instance must be accessible to clients from a well-known access point</li></ul></div></div></div>
<div class="section" title="The abstract factory pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>The abstract factory pattern</h1></div></div></div><p>We <a class="indexterm" id="id42"/>already introduced you to a very popular concept in<a class="indexterm" id="id43"/> design patterns: <span class="strong"><strong>factories</strong></span>. Factories <a class="indexterm" id="id44"/>are the classes that handle the instantiation of related objects without subclassing. The factory method pattern that we have already seen hides the class name from where an object is instantiated. The abstract factory pattern is more complete as it creates families of related or dependent objects.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Roles</h2></div></div></div><p>The<a class="indexterm" id="id45"/> abstract factory pattern is designed to build objects grouped in families without having to know the concrete class needed to create the object.</p><p>This pattern is <a class="indexterm" id="id46"/>generally used in the following domains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A system that uses products needs to stay independent of how these products are grouped and instantiated</li><li class="listitem" style="list-style-type: disc">A system can have several product families that can evolve</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id47"/> following diagram represents the generic structure of the abstract factory pattern. You will see how products and families are decoupled:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_01_06.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>Participants</h2></div></div></div><p>The abstract <a class="indexterm" id="id48"/>factory pattern has a lot of participants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Abstract</code> <code class="literal">Factory</code>: This <a class="indexterm" id="id49"/>abstract class defines the signature of the different methods that create our products.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteFactory1</code> and <code class="literal">ConcreteFactory2</code>: These<a class="indexterm" id="id50"/> are our concrete classes that <a class="indexterm" id="id51"/>implement our methods for each products' families. By knowing the family and product, the factory is able to create an instance of the product for that family.</li><li class="listitem" style="list-style-type: disc"><code class="literal">IProductA</code> and <code class="literal">IProductB</code>: These <a class="indexterm" id="id52"/>are our interfaces that define our products that are independent of their family. A family is<a class="indexterm" id="id53"/> introduced in their concrete subclasses.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ProductA</code> and <code class="literal">ProductB</code>: These<a class="indexterm" id="id54"/> are the <a class="indexterm" id="id55"/>concrete classes that implement <code class="literal">IProductA</code> and <code class="literal">IProductB</code>, respectively.</li></ul></div></div><div class="section" title="Collaborations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Collaborations</h2></div></div></div><p>The <code class="literal">Client</code> class <a class="indexterm" id="id56"/>uses one instance of one of the concrete factories to create products throughout the interface of the abstract factory.</p></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>Illustration</h2></div></div></div><p>Our <a class="indexterm" id="id57"/>company specializes in manufacturing watches. Our watches are built in two parts: a band and dial. Our watches come in two sizes, so we must adapt the manufacturing of the band and dial according to the size of our watch.</p><p>In order to simplify how to manage the manufacturing of our watches, the direction team decided to use one manufacturer who specializes in products that are adapted to the 38 mm model of our watch, and another manufacturer whose products are adapted to the 42 mm model of our watch.</p><p>Each of these manufacturers will build a dial and band that are adapted to the dimension of the watch.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>Implementation</h2></div></div></div><p>To<a class="indexterm" id="id58"/> implement our pattern, we first need to identify our actors. The two manufacturers represent the <code class="literal">ConcreteFactory1</code> and <code class="literal">ConcreteFactory2</code> classes. These two factories implement the <code class="literal">AbstractFactory</code> method, which tell us that we can create a band or dial. Of course, the concrete factories will create the dial adapted to the size of the watch produced in that manufacture.</p><p>Our <code class="literal">ConcreteProductA</code> and <code class="literal">ConcreteProductB</code> classes are the band and the dial; each of these products implements their respective <code class="literal">IProductA</code> and <code class="literal">IProductB</code> interfaces, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import UIKit

//Our interfaces
protocol IWatchBand {
  var color: UIColor{get set}
  var size: BandSize{get set}
  var type: BandType{get set}
  init(size: BandSize)
}

protocol IWatchDial {
  var material: MaterialType{get set}
  var size: WatchSize{get set}
  init(size: WatchSize)
}

//Enums
enum MaterialType: String {
  case Aluminium = "Aluminium",
  StainlessSteel = "Stainless Steel",
  Gold = "Gold"
}

enum BandType: String {
  case Milanese = "Milanese",
  Classic = "Classic",
  Leather = "Leather",
  Modern = "Modern",
  LinkBracelet = "LinkBracelet",
  SportBand = "SportBand"
}

enum WatchSize: String {
  case _38mm = "38mm", _42mm = "42mm"
}

enum BandSize: String {
  case SM = "SM", ML = "ML"
}

//prepare our Bands components
class MilaneseBand: IWatchBand {
  var color = UIColor.yellowColor()
  var size: BandSize
  var type = BandType.Milanese
  required init(size _size: BandSize) {
    size = _size
  }
 }

class Classic: IWatchBand {
  var color = UIColor.yellowColor()
  var size: BandSize
  var type = BandType.Classic
  required init(size _size: BandSize) {
    size = _size
  }
}
class Leather:IWatchBand{
  var color = UIColor.yellowColor()
  var size:BandSize
  var type = BandType.Leather
  required init(size _size: BandSize) {
    size = _size
  }
}
class Modern: IWatchBand {
  var color = UIColor.yellowColor()
  var size: BandSize
  var type = BandType.Modern
  required init(size _size: BandSize) {
    size = _size
  }
}

class LinkBracelet: IWatchBand {
  var color = UIColor.yellowColor()
  var size: BandSize
  var type = BandType.LinkBracelet
  required init(size _size: BandSize) {
    size = _size
  }
}
class SportBand: IWatchBand {
  var color = UIColor.yellowColor()
  var size: BandSize
  var type = BandType.SportBand
  required init(size _size: BandSize) {
    size = _size
  }
}


//Dials
class AluminiumDial: IWatchDial {
  var material: MaterialType = MaterialType.Aluminium
  var size: WatchSize
  required init(size _size:WatchSize){
    size = _size
  }
}

class StainlessSteelDial: IWatchDial {
  var material: MaterialType = MaterialType.StainlessSteel
  var size: WatchSize
  required init(size _size:WatchSize){
    size = _size
  }
}

class GoldDial: IWatchDial {
  var material: MaterialType = MaterialType.Gold
  var size: WatchSize
  required init(size _size:WatchSize){
    size = _size
  }
}


//Our AbstractFactory
class WatchFactory {
  
  func createBand(bandType: BandType) -&gt; IWatchBand {
    fatalError("not implemented")
  }
  func createDial(materialtype: MaterialType) -&gt; IWatchDial{
    fatalError("not implemented")
  }
  
  //our static method that return the appropriated factory.
  final class func getFactory(size: WatchSize) -&gt; WatchFactory{
    var factory: WatchFactory?
    switch(size){
    case ._38mm:
      factory = Watch38mmFactory()
    case ._42mm:
      factory = Watch42mmFactory()
    }
    return factory!
  }

}


// Concrete Factory 1 for 42 mm
class Watch42mmFactory: WatchFactory {
  override func createBand(bandType: BandType) -&gt; IWatchBand {
    switch bandType {
    case .Milanese:
      return MilaneseBand(size: .ML)
    case .Classic:
      return Classic(size: .ML)
    case .Leather:
      return Leather(size: .ML)
    case .LinkBracelet:
      return LinkBracelet(size: .ML)
    case .Modern:
      return Modern(size: .ML)
    case .SportBand:
      return SportBand(size: .ML)
    default:
      return SportBand(size: .ML)
    }
  }
  
  override func createDial(materialtype: MaterialType) -&gt; IWatchDial {
    switch materialtype{
    case MaterialType.Gold:
      return GoldDial(size: ._42mm)
    case MaterialType.StainlessSteel:
      return StainlessSteelDial(size: ._42mm)
    case MaterialType.Aluminium:
      return AluminiumDial(size: ._42mm)
    }
  }
}

//Concrete Factory 2 for 38mm
class Watch38mmFactory: WatchFactory{
  override func createBand(bandType:BandType) -&gt; IWatchBand {
    switch bandType {
    case .Milanese:
      return MilaneseBand(size: .SM)
    case .Classic:
      return Classic(size: .SM)
    case .Leather:
      return Leather(size: .SM)
    case .LinkBracelet:
      return LinkBracelet(size: .SM)
    case .Modern:
      return Modern(size: .SM)
    case .SportBand:
      return SportBand(size: .SM)
    default:
      return SportBand(size: .SM)
    }
  }
  
  override func createDial(materialtype: MaterialType) -&gt; IWatchDial {
    switch materialtype{
    case MaterialType.Gold:
      return GoldDial(size: ._38mm)
    case MaterialType.Gold:
      return StainlessSteelDial(size: ._38mm)
    case MaterialType.Gold:
      return AluminiumDial(size: ._38mm)
    default:
      return AluminiumDial(size: ._38mm)
      
    }
  }
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>Usage</h2></div></div></div><p>To<a class="indexterm" id="id59"/> simulate our client, we will use the following code:</p><div class="informalexample"><pre class="programlisting">//Here we deliver products from the Manufacture 1 specialized in
//products for the 38 mm Watch
let manufacture1 = WatchFactory.getFactory(WatchSize._38mm)
let productA = manufacture1.createBand(BandType.Milanese)
productA.color
productA.size.rawValue
productA.type.rawValue

let productB = manufacture1.createDial(MaterialType.Gold)
productB.material.rawValue
productB.size.rawValue


//Here we delivers products from the Manufacture 2 specialized in
//products for the 42 mm Watch
let manufacture2 = WatchFactory.getFactory(WatchSize._42mm)
let productC = manufacture2.createBand(BandType.LinkBracelet)
productC.color
productC.size.rawValue
productC.type.rawValue

let productD = manufacture2.createDial(MaterialType.Gold)
productD.material.rawValue
productD.size.rawValue</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The Playground <a class="indexterm" id="id60"/>file will display our product's properties, depending on the factory used. The details of product <span class="emphasis"><em>A</em></span> (the band) and product <span class="emphasis"><em>B</em></span> (the dial) from the <code class="literal">manufacture1</code> object are shown in the following screenshot:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_01_07.jpg"/></div><p>The details of product <span class="emphasis"><em>C</em></span> (the band) and product <span class="emphasis"><em>D</em></span> (the dial) from the <code class="literal">manufacture2</code> object are shown in the following screenshot:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_01_08.jpg"/></div><p>The sizes <a class="indexterm" id="id61"/>of the band and the dial adapt to the manufacturer who delivers the product.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>We should use the singleton pattern to ensure that we have only one instance of our abstract factory. This instance can be shared between several clients.</p></div></div></div></div>
<div class="section" title="The builder pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The builder pattern</h1></div></div></div><p>Unlike<a class="indexterm" id="id62"/> the <a class="indexterm" id="id63"/>abstract factory pattern, which will produce parts of products of the same family, the builder pattern will help us build the finalized product that consists of several parts.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>Roles</h2></div></div></div><p>The main purpose <a class="indexterm" id="id64"/>of the builder pattern is to abstract the building of complex objects from its actual construction. Having the same construction process can create different representations of the product.</p><p>This pattern<a class="indexterm" id="id65"/> can be used when:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A client needs to construct complex objects without having to know its implementation</li><li class="listitem" style="list-style-type: disc">A client needs to construct complex objects that need to have several implementations or representations</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id66"/> following figure shows the generic UML class diagram of the builder pattern:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_01_09.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>Participants</h2></div></div></div><p>This pattern <a class="indexterm" id="id67"/>is quite simple as it has only a few participants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Director</code>: This class constructs the product using the interface of the <code class="literal">AbstractBuilder</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AbstractBuilder</code>: This class defines the method signature that allows the construction of all the parts of the product, and it contains a signature of a method that returns the product once this is built.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteBuilder</code>: This is the <code class="literal">Concrete</code> class that implements the method of the <code class="literal">AbstractBuilder</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Product</code>: This is the finalized product. The product contains all the parts of the watch.</li></ul></div></div><div class="section" title="Collaborations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>Collaborations</h2></div></div></div><p>The <a class="indexterm" id="id68"/>client creates the <code class="literal">ConcreteBuilder</code> and <code class="literal">Director</code> classes. The <code class="literal">Director</code> class will then build an object if the client asks him to do so by invoking the constructor and returns the finalized product to the client.</p></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>Illustration</h2></div></div></div><p>Using<a class="indexterm" id="id69"/> the <code class="literal">AbstractFactory</code> method, we can use the builder pattern to build a watch. As we've seen that a watch has several parts: a dial and band. A watch can have two sizes too, and as we have already seen, the representation of the dial or band depends on the size of the watch too.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec41"/>Implementation</h2></div></div></div><p>If we <a class="indexterm" id="id70"/>want to build some watches that are represented with a dial and band, we will define a <code class="literal">Director</code> class that will define the construction order of all the parts of our watches and return the finalized watch to the client.</p><p>The <code class="literal">Director</code> class will call all the constructors who are in charge to construct one part of the watch. To implement this, we will reuse the existing code of the abstract factory pattern and add the following code.</p><p>Open the <code class="literal">Builder.playground</code> file in Xcode to see the added code at the bottom of the file:</p><div class="informalexample"><pre class="programlisting">//Our builder1
class BuilderGoldMilanese38mmWatch: AbstractWatchBuilder {
  override func buildDial() {
    watch.band = MilaneseBand(size: BandSize.SM)
  }
  override func buildBand() {
    watch.dial = GoldDial(size: WatchSize._38mm)
  }
}

//Our builder2
class BuilderAluminiumSportand42mmWatch:AbstractWatchBuilder {
  override func buildDial() {
    watch.band = SportBand(size: BandSize.ML)
  }
  override func buildBand() {
    watch.dial = AluminiumDial(size: WatchSize._42mm)
  }
}

//our Director class
class Director {
  var builder: AbstractWatchBuilder?
  init(){
    
  }
  
  func buildWatch(builder: AbstractWatchBuilder){
    builder.buildBand()
    builder.buildDial()
  }
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec42"/>Usage</h2></div></div></div><p>To <a class="indexterm" id="id71"/>simulate our client, we will tell our director to create two watches:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A 42 mm aluminium dial with a sports band</li><li class="listitem" style="list-style-type: disc">A 38 mm gold dial with a milanese band</li></ul></div><p>The code for the example is as follows:</p><div class="informalexample"><pre class="programlisting">//We will build 2 Watches :
//First is the Aluminium Dial of 42mm with Sport Band
let director = Director()
var b1 = BuilderAluminiumSportand42mmWatch()
director.buildWatch(b1)

// our watch 1
var w1 = b1.getResult()
w1.band?.color
w1.band?.type.rawValue
w1.band?.size.rawValue
w1.dial?.size.rawValue
w1.dial?.material.rawValue

//Our 2nd watch is a Gold 38mm Dial with Milanese Band
var b2 = BuilderGoldMilanese38mmWatch ()
director.buildWatch(b2)

// Our watch 1
var w2 = b2.getResult()
w2.band?.color
w2.band?.type.rawValue
w2.band?.size.rawValue
w2.dial?.size.rawValue
w2.dial?.material.rawValue</pre></div><p>The result is<a class="indexterm" id="id72"/> shown in Playground like this:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_01_10.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Swift allows the use of closure that simplifies the creation of our complex objects. Regarding the example that we provided earlier, we can write the following code to build our two watches.</p></div></div></div><div class="section" title="Implementation using closures"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec43"/>Implementation using closures</h2></div></div></div><p>Here, we don't need to<a class="indexterm" id="id73"/> use the <code class="literal">Director</code> and <code class="literal">ConcreteBuilder</code> classes. Instead, we will tell our <code class="literal">Watch</code> class that the builder will be in the closure.</p><p>In the previous example, remove the <code class="literal">Director</code>, <code class="literal">AbstractBuilder</code>, and <code class="literal">ConcreteBuilder</code> classes.</p><p>We just need to write the <code class="literal">Watch</code> class, as shown in the following code (you can find the following code in the <code class="literal">BuilderClosures.playground</code> file accompanying this chapter):</p><div class="informalexample"><pre class="programlisting">//our Product Class : a Watch
//The builder will be in the closure
class Watch{
  var dial:IWatchDial?
  var band:IWatchBand?
  typealias buildWatchClosure = (Watch) -&gt; Void
  
  init(build:buildWatchClosure){
    build(self)
  }
}</pre></div><p>Then, to simulate<a class="indexterm" id="id74"/> our client, we can write the following code which will call the appropriate constructor assigned to the band or dial property of the <code class="literal">Watch</code> object:</p><div class="informalexample"><pre class="programlisting">//Simulate our clients

let Gold42mmMilaneseWatch = Watch(build: {
  $0.band = MilaneseBand(size: BandSize.ML)
  $0.dial = GoldDial(size: WatchSize._42mm)
})</pre></div><p>The result is as follows:</p><div class="mediaobject"><img alt="Implementation using closures" src="graphics/4852_01_11.jpg"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>Well, I hope that this chapter was a good introduction to the use of patterns using Swift. We learned the five creational patterns: the prototype pattern, the factory method pattern, the singleton pattern, the abstract factory pattern, and the builder pattern. We also learned when to use them and how to implement them.</p><p>In the next chapter, we will introduce you to three structural patterns that are designed to ease the relationship between entities.</p></div></body></html>