- en: 'Chapter 2. User Interface: Views'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving user input with buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using labels to display text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and editing text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying content larger than the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through content divided into pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application's user interface is essential for providing the user with an
    easy way of communicating with a device, be it a computer, a mobile phone, or
    a tablet. On a mobile device, the user interface is not only essential but the
    only way to interact with the user. Developers have to cope with various limitations
    and restrictions when developing for mobile devices. The processing power does
    not match desktop CPUs and the screens are smaller, making the process of choosing
    what sort of information will be displayed each time somewhat more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the key components of an iOS application''s
    UI. We will see how to use and customize these components to create rich application
    user interfaces and discuss their similarities and differences they have with
    their desktop equivalents. Here is a list of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIView:` It is a customizable container, which is the base object of most
    iOS user interface controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIButton:` It is the equivalent of a `Button` in .NET world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UILabel:` It is the equivalent of a `Label` in .NET world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIImageView:` It is a view that allows us to display and create basic animations
    with images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UITextView:` It is a view, which allows us to display editable text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UITextField:` It is similar to .NET''s `TextBox` control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIProgressView:` It displays known length progress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIScrollView:` It provides the ability to display scrollable content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIPageControl:` It provides navigation functionality to content, divided into
    different pages or screens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIToolbar:` It provides a toolbar at the bottom of the screen that accepts
    customizable buttons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also talk about how to programmatically create instances of these components
    and use them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this task, we will discuss how to add and customize a `UIView` with **Interface
    Builder**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding views with Interface Builder is a simple task. Let's start by creating
    a new **iPhone Single View Application** project in MonoDevelop. Name the project
    `FirstViewApp`, and open the `FirstViewAppViewController.xib` file with Interface
    Builder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a view to the project, drag-and-drop a `UIView` object from the **Library**
    pad onto the main view. Make sure it fits the entire window area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the `UIView` accessible, create an outlet for it, and name it `subView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of outlets and how to use them is discussed in detail in [Chapter
    1](ch01.html "Chapter 1. Development Tools"),Accessing the UI with Outlets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the view that we just added and go to the **Inspector** pad. Select the
    **Attributes** tab, and in the **Background** drop-down list, select **Light Gray
    Color**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **Size** tab and reduce the view's height by `60` points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile and run the application on the simulator. The result should look like
    the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The gray portion of the simulator's screen is the view that we have just added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully created an application that contains one view. Of course,
    this application does not provide any functionality. It is only meant to show
    how to add a view and display it.
  prefs: []
  type: TYPE_NORMAL
- en: Views are the essential components of an iOS application interface. Every visual
    UI object inherits from the `UIView` class. The concept is somewhat different
    than a `Form` in .NET. A view manages content drawing, accepts other views as
    subviews, provides auto-sizing features, can accept touch events for itself and
    its subviews, and many of its properties can even be animated. Even `UIWindow`
    inherits from `UIView`. It is this class or its inheritors that iOS developers
    will use most frequently.
  prefs: []
  type: TYPE_NORMAL
- en: When a view, which is added with Interface Builder, is first instantiated at
    runtime, it sets its `Frame` property with values that are set through the **Inspector**
    window's **Size** tab. The `Frame` property is of type `RectangleF` and defines
    the location of the view in its superview's coordinate system, in our case the
    main window, and its size in points.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Objective-C, the `Frame` property of `UIView` is of the type `CGRect`. This
    type has not been bound in MonoTouch, and the more familiar `System.Drawing.RectangleF`
    was used instead.
  prefs: []
  type: TYPE_NORMAL
- en: A superview is a view's parent view, while subviews are its child views. Views
    that have the same superview are described as siblings.
  prefs: []
  type: TYPE_NORMAL
- en: The default coordinate system in iOS originates from the top-left corner and
    extends towards the bottom and the right. The coordinate origin is always the
    same and cannot be changed programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinate system of iOS is displayed in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1468EXP_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the `Frame` property is set, it adjusts the `Bounds` property. The `Bounds`
    property defines the location of the view in its own coordinate system and its
    size in points. It is also of the type `RectangleF`. The default location for
    the `Bounds` property is `(0,0)`, and its size is always the same as the view's
    `Frame` value. Both these properties' sizes are connected to each other, so when
    you change the size of the `Frame`, the size of the `Bounds` changes accordingly
    and vice versa. You can change the `Bounds` property to display different parts
    of the view. A view's `Frame` can exceed the screen in both location and position.
    That is to say that a view's frame with values (x = -50, y = -50, width = 1500,
    height = 1500) is perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another thing to note is that the `UIView` class inherits from `UIResponder`.
    The `UIResponder` class is responsible for responding to and handling events.
    When a view is added to another view, it becomes part of its responder chain.
    The `UIView` class exposes the properties and methods of `UIResponder`, and the
    ones we are interested in describing for now are the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsFirstResponder` **property:** It returns a boolean value indicating whether
    the view is the first responder. Basically, it indicates if the view has focus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ResignFirstResponder():` It causes the view to lose focus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding views programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we would like to add a view programmatically, we would use the `UIView.AddSubview(UIView)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSubview()` method adds its parameter, which is of the type `UIView`,
    to the list of the caller's subviews and sets its `Superview` parameter to the
    caller. A view will not be displayed unless it is added to a parent view with
    the `AddSubview()` method. Also, if a view already has a superview and it is added
    to another view with its `AddSubview()` method, then its `Superview` is changed
    to that of the new caller. What this means is that a view can only have only one
    superview each time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding a view as a subview with Interface Builder, it is not required to
    use the `AddSubview()` method to display the subview. It is required to call the
    `AddSubview()` method, however, when adding views programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: For removing a view from its superview programmatically, call its `RemoveFromSuperview()`
    method. Calling this method on a view, which has no superview, does nothing. Care
    must be taken when we want to reuse the view we want to remove. We must keep a
    reference to it, or it might be released after the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: View content layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important property of `UIView` is `ContentMode. ContentMode` accepts
    values of the enumeration type `UIViewContentMode`. This property sets how the
    `UIView` will display its content. The default value of this property is `UIViewContentMode.ScaleToFill`,
    which scales the content to fit the exact view's size, distorting it if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a custom view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"), Accessing the UI with
    Outlets.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating the UI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing the UI with outlets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 3, *User Interface: View Controllers:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*View controllers* and *views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving user input with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use buttons to receive and respond to user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used buttons in [Chapter 1](ch01.html "Chapter 1. Development Tools"), *Accessing
    the UI with Outlets* to discuss how to use Interface Builder to add controls to
    the user interface. In this task, we will describe the `UIButton` class in more
    detail. Open the project `FirstViewApp` that we created in the previous task in
    MonoDevelop. Increase the main view's height to cover the entire screen in Interface
    Builder, and save the document.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will programmatically add a button in our interface that will change our
    view's background color when tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `FirstViewAppViewController.cs` file, and enter the following code
    in the class::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in the `ViewDidLoad()` method, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the application on the simulator. When the button is tapped,
    the result should be similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we have added a button to the user interface that changes the
    background color of the superview. Furthermore, we have accomplished this without
    using Interface Builder at all.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see what the code does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a field that will hold the button object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `CreateButton()` method, we create the button and set some properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we assign the view''s `Frame` to a new variable named `viewFrame`. Then,
    we create a new `RectangleF` object named `buttonFrame`, which will be assigned
    to the button''s `Frame` property. Now that we have a frame for our button, we
    can initialize it, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The button is initialized with the static method `UIButton.FromType(UIButtonType)`.
    This method takes one parameter of the type `UIButtonType` and returns predefined
    types of buttons that are included in iOS SDK. The `UIButtonType.RoundedRect`
    button enumeration value, used here, is the default type of iOS button with rounded
    corners. After the `buttonChangeColor` object is initialized, we set its `Frame`
    to the `RectangleF` value we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have provided initialization code for the button, we will set its
    titles (that''s right, more than one):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We call the `UIButton.SetTitle(string, UIControlState)` method twice. This
    method is responsible for setting the button''s title for each given button state.
    The string parameter is the actual title that will be shown. The second parameter
    is an enumeration of the type UIControlState that indicates the different control
    states that apply to controls. These control states are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Normal:` The default idle state of an enabled control'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Highlighted:` The state of the control when a touch-up event occurs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled:` The control is disabled and does not accept any events'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selected:` The control is selected. In most cases, this state does not apply.
    It is useful, however, when a selection state is required, such as in a `UISegmentedControl`
    object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application:` An additional control state values for application use'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reserved:` For internal framework use'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with the method `UIButton.SetTitle(string, UIControlState)` , we have set
    the title that will be displayed when the button is in its default state and the
    title that will be displayed while it is being tapped.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: After that, we set the button's handler for the `TouchUpInside` event, and add
    it as a subview to the `subView:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `buttonChangeColor_TouchUpInside` event, we change the background
    color of the view, according to the boolean field that we have declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is done by setting the view's `BackgroundColor` property to the appropriate
    `UIColor` class instance we want, as shown in the highlighted code previously.
    The `UIColor` object is a class with many different static methods and properties
    that allow us to create different color objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you compile and run the application on the simulator, notice not only the
    view's color change when you tap the button, but also how the button's title changes
    while the mouse cursor (or finger on the device) is touching the button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this task, we used the `UIButton.FromType(UIButtonType)` static method to
    initialize the button. A brief description of each of the enumeration flags of
    `UIButtonType` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Custom:` It''s a borderless transparent button. Use this flag when creating
    custom buttons with images as backgrounds. The button''s title is not transparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RoundedRect:` It''s the default type of button with rounded corners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetailDisclosure:` It''s a round blue button that reveals additional information
    related to an item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InfoLight:` It''s a light-colored button with the letter (i), representing
    information display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InfoDark:` It''s the same as `InfoLight`, shown with dark color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContactAdd:` It''s a round blue button with a white plus sign (+). Usually
    displayed to present contact information to add to an item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For creating custom buttons with the type `UIButtonType.Custom`, use the `UIButton`
    class' `SetBackgroundImage()` and `SetImage()` methods. They both accept one `UIImage`
    and one `UIControlState` parameters, so that different images for different control
    states can be set. When setting images for buttons, whether creating a custom
    button or not, be sure to set the `UIButton.ContentMode` property accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality provided by the methods `SetImage` and `SetBackgroundImage`
    can also be accomplished in the corresponding **Image** and **Background** fields
    in the **Attributes** tab of the **Inspector** pad in Interface Builder. Select
    the state for which to set the desired image(s) from the drop-down list box, and
    set the path to the image file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom buttons](img/1468EXP_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding and customizing views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Displaying images*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a custom view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"), *Development Tools:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating the UI*,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing the UI with Outlets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using labels to display text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display informative text to the user with
    labels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we will describe the `UILabel` class in more detail. Once again,
    all of the work will be done without the help of Interface Builder. Open the project
    `FirstViewApp` that we modified in the previous recipe in MonoDevelop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will programmatically create a label, which will display some static guidance
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `FirstViewAppViewcontroller.cs`, and enter the following code
    in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in the `FinishedLaunching()` method, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the application on the simulator. The output should look like
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully created a label and put some information text in it. Let's
    step through the code and see what actually goes on.
  prefs: []
  type: TYPE_NORMAL
- en: We first create the `labelInfo` field that will hold our `UILabel` object in
    the `FirstViewAppViewController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create the method `CreateLabel()`, which will instantiate and customize
    the label. Like the button we created in the previous task, our label needs a
    frame. So, we create one, again depending on the view''s `Frame` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We just set its height to be higher than the button''s, to `100` points. Now
    that we have a `Frame` for the label, we initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor is used, so that the Frame property will be set immediately
    upon initialization. The Lines property determines the total number of lines the
    text on the label text will be divided to. The TextAlignment property accepts
    values of the enumeration type UITextAlignment, which contains the usual text
    alignment flags: Center, Left, and Right. To make the Frame of the label completely
    invisible, so that only our text will be visible, we set the BackgroundColor property
    to the color UIColor.Clear.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next part is quite interesting. Apart from being able to set the font color
    of the `label`, we can also set a shadow at the displayed text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The TextColor property accepts `UIColor` values. To set a shadow for the text
    of the label, set a UIColor to the ShadowColor property. Then, set a SizeF structure
    to the ShadowOffset property. This property determines the exact location of the
    shadow. The width parameter of SizeF defines the horizontal placement of the shadow,
    and the height parameter defines the vertical placement. Negative values are acceptable.
    A negative value for width means that the shadow will be positioned towards the
    left, while a negative value for the height means that the shadow will be positioned
    above the text. The value we have set in the previous code means that the shadow
    will be displayed 1 point to the right and 1 point below the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have prepared how the `label` will render its text. To assign the text the
    `label` will display, set its `Text` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we have defined quite a long string for the `label` to display.
    Finally, add the `label` to the view to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code gives the result shown in the *How to do it* section of this task.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous code, there is also one more line of code, which is commented
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AdjustsFontSizeToFitWidth` property accepts a boolean value. If set to
    `true`, it instructs the `label` to automatically change the font size so that
    it can fit inside the width of the `label`. Setting this property to `true` has
    absolutely no effect if the `label` supports more than one line. So, just to see
    how this property works, uncomment it and set the `Lines` property to `1`. The
    result will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1468EXP_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the text on the `label` needs a magnifying glass to read, so
    it does not work for us properly here. The `AdjustsFontSizeToFitWidth` property,
    however, is very useful when there is limited space for the width of the `label`
    on the screen and we want our text to fit that space. To prevent a situation like
    this, set the `MinimumFontSize` property to the desired value. Just as its name
    suggests, the size of the font will not be smaller than this property's value.
  prefs: []
  type: TYPE_NORMAL
- en: UILabel fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting the font of the displayed text in a `label` is easy. Set its `Font`
    property with the `UIFont.FromName(string, float)` static method. The `string`
    parameter represents the name of the font to set and can include both the font
    family and style, while the `float` parameter determines its size. For example,
    to set the font of the `label` to `Helvetica Bold`, call the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the font name is not found, the `FromName` static method returns `null`.
    Care must be taken for this, since when the `UILabel.Font` property is set to
    `null`, an exception will occur. The available styles for a font family can be
    determined by calling the `UIFont.FontNamesForFamilyName(string)` method, which
    returns a `string[]` containing all the available font styles. If the `Helvetica`
    font family is passed to this method, it will return a `string[]` with the following
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: Helvetica-BoldOblique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helvetica
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Helvetica-Bold
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Helvetica-Oblique
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying and editing text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"), Accessing the UI with
    Outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating the UI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 11, Graphics and Animation:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Display blinking text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIImageView` class to display
    images on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we will see how to bundle and display images in a project. An
    image file will be needed for display. The image file used here is named `Toroni.jpg`.
    Create a new **iPhone Single View Application** project in MonoDevelop, and name
    it `ImageViewerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `ImageViewerAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIImageView` object on its view. Connect the `UIImageView` object with
    an outlet named `imageDisplay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, in the `ImageViewerAppViewController` class, enter the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the project in the **Solution** pad and select **Add | Add Files**.
    Select the image file you want to display, and click on **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the image file you have just added, and click on **Build Action
    | Content**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, compile and run the application on the simulator. The image you added
    to the project should be displayed on the screen, as shown in the following Image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIImageView` class is basically a view customized for displaying images.
    When adding an image in a project, its **Build Action** must be set to **Content**
    in the **Solution** pad, otherwise the image will not be copied into the application
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ContentMode` property is very important when displaying images. It sets
    the way the `UIView` (UIImageView, in this case) object will display the image.
    We have set it to `UIViewContentMode.ScaleAspectFit`, so that it will be resized
    to fit the area of `UIImageView`, keeping the aspect ratio intact at the same
    time. If the `ContentMode` field was left at its default `Scale To Fill` value,
    the output would be something like the following Image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1468EXP_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To set the image that the `UIImageView` should display, we set its `Image`
    property with a `UIImage` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContentMode` property accepts an enumeration type named `UIViewContentMode`.
    The values provided are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ScaleToFill:** This is the default value of the base **UIView** object. It
    scales the content to fit the size of the view, changing the aspect ratio as necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ScaleAspectFit:** It scales the content to fit the size of the view, maintaining
    its aspect ratio. The remaining area of the view''s content becomes transparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ScaleAspectFill:** Scales the content to fill the size of the view, maintaining
    its aspect ratio. Some part of the content may be left out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redraw:** When a view''s bounds are changed, its content is not redrawn.
    This value causes the content to be redrawn. Drawing content is an expensive operation
    in terms of CPU cycles, so think twice before using this value with large contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Center:** Places the content at the center of the view, keeping its aspect
    ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top, Bottom, Left, Right, TopLeft, TopRight, BottomLeft**, and **BottomRight:**
    Aligns the content in the view, with the corresponding value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIImage` class is the object that represents image information. The file
    formats it supports are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File Format | File Extension |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Portable Network Graphics (PNG) | .png |'
  prefs: []
  type: TYPE_TB
- en: '| Joint Photographic Experts Group (JPEG) | .jpg, .jpeg |'
  prefs: []
  type: TYPE_TB
- en: '| Tagged Image File Format (TIFF) | .tiff, .tif |'
  prefs: []
  type: TYPE_TB
- en: '| Graphic Interchange Format | .gif |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Bitmap Format | .bmp |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Icon Format | .ico |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Cursor | .cur |'
  prefs: []
  type: TYPE_TB
- en: '| XWindow bitmap | .xbm |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animated GIF image files are not supported by the `UIImageView` class. When
    an animated GIF is set to the `Image` property of a `UIImageView`, only its first
    frame will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Using images for different screen sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating images for backgrounds provides developers with the ability to produce
    rich and elegant user interfaces for their applications. The preferred image file
    format for creating backgrounds for views is `PNG`. But, since the iPhone 4 was
    released, the screen resolution was increased. To support both screen resolutions
    in an application, the iOS SDK provides an easy solution. Just save the image
    in the higher resolution and add a `@2x` suffix to the filename, just before the
    extension. For example, the name of a higher resolution version of a file named
    `Default.png` would be `Default@2x.png`. Also, no extra code is required to use
    both files.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the `UIImage.FromBundle(string)` static method, passing the filename
    without extension, and iOS takes care of loading the appropriate file, depending
    on the device the application is running on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding only applies to PNG image files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding and customizing views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Multimedia Resources"),Multimedia Resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Loading an Image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and editing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display simple text blocks with editing
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we will discuss the usage of `UITextView` and how to display editable
    text with it. Create a new **iPhone Single View Application** project in MonoDevelop,
    and name it `TextViewApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open `TextViewAppViewController.xib` in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UIButton near the top of its view and a UITextView below it. Connect both
    objects to their outlets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, enter the following `ViewDidLoad` method in the `TextViewAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap somewhere in the text view and the keyboard will appear. Type some text
    and then tap on the **Finished** button to hide the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UITextView` class provides an object that displays editable blocks of
    text. To respond to the events of our text view, we have implemented a class that
    inherits from `UITextViewDelegate` that will act as the text view''s delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We declared a constructor that accepts a `TextViewAppViewController` object,
    so that we can have an instance of our controller available to access our controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we override three methods of the `UITextViewDelegate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These methods are the handlers that will get called whenever a corresponding
    event is triggered. When tapping on the text, the `EditingStarted()` method gets
    called. We enable the **Finished** button in it. When we type some text in the
    text view, the `Changed()` method gets called, and we can see the output of the
    `Console.WriteLine()` method in MonoDevelop's **Application Output** pad. Finally,
    when we tap on the **Finished** button, the keyboard hides and the `EditingEnded()`
    method gets called that allows us to disable the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ViewDidLoad` method, we assign a handler to the `TouchUpInside` event
    of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the text view''s `ResignFirstResponder()` method in it so that when
    the button is tapped, the text view will lose focus, causing the keyboard to hide.
    Then, we assign a new instance of the delegate that we created to the text view''s
    `Delegate` property, passing the instance of the `TextViewAppViewController` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates in Objective-C are somewhat different than delegates in C#. Although
    in both worlds their most common usage is to provide access to some form of event
    notification mechanism, in Objective-C this mechanism is a bit more complex. A
    C# delegate is much like a function pointer in C or C++ programming languages.
    It is an object that holds a reference to a method of a specific signature. On
    the other hand, an Objective-C delegate is a certain type of object that conforms
    to a specific protocol. It is basically an object that wraps one or more methods
    (and/or other members) that act as event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Objective-C protocol is similar to an interface in C#.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of Delegate objects might seem confusing at first, but it is not
    difficult to comprehend. Regarding the event notification mechanism, MonoTouch
    simplifies things for .NET developers by providing events for most objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UITextView` class is suitable for displaying simple blocks of text, without
    formatting. For displaying formatted text, use the `UIWebView` class instead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the keyboard*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Displaying Data"), Displaying Data:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying and formatting text*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss some important aspects of the virtual keyboard
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous two tasks, we discussed the types of text input available. In
    this task, we will discuss some of the things we can, or even must, do to use
    the keyboard effectively. Create a new **iPhone Single View Application** project
    in MonoDevelop, and name it `KeyboardApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `KeyboardAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UITextField` object in the bottom-half portion of the view and connect
    it to an outlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, enter the following code in the `KeyboardAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the text field and watch it moving upwards to avoid being hidden from
    the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Done** button on the keyboard and watch the text field returning to
    its original position when the keyboard hides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various types of keyboards in iOS. Since not all keys can be displayed
    at once due to the restricted screen size, it is good practice to set the appropriate
    type of keyboard, according to the text input we need the user to provide. In
    this project, we have set the keyboard to the **Email Address** type. We have
    also customized the type of the **Return** key by setting it to **Done**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the keyboard is displayed, it is the developer's responsibility to make
    sure it does not obstruct essential UI elements. In this case, since we provide
    the user with the ability to enter some text input, we have to make sure that
    the text field is visible so the user will be able to see what is being typed.
    For this, we add two observers in the default notification center.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: An `NSNotificationCenter` provides a notification mechanism for various notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We access the runtime''s default notification center through the `NSNotificationCenter.DefaultCenter`
    static property. An observer is added with the `AddObserver()` method, which accepts
    two parameters. The first parameter represents an `NSString` value, which informs
    the notification center of what type of notification to watch. The `UIKeyboard`
    class contains pre-defined static properties with the types of keyboard notifications
    we need. The `UIKeyboard.WillShowNotification` is passed, stating that the observer
    will observe and inform when the keyboard will be ready to appear. The second
    parameter is of the type `Action<NSNotification>` and represents the handler that
    will be executed when the notification occurs. Inside the `anonymous()` method,
    we call the `UIKeyboard.FrameEndNotification(NSNotification)` method that returns
    the keyboard''s bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we store the text field''s frame in a variable and reduce its `Y` position
    value so that the text field will move upwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the new frame is set to the `emailField`, it will move to the new position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The second observer is needed for moving the text field back to its original
    position. It is almost the same as the first observer, except for two differences.
    The `UIKeyboard.DidHideNotification NSString` is passed, instructing the observer
    to trigger the handler after the keyboard has been dismissed, and the `Y` value
    of the text field's frame is increased to make the text field return to its original
    position.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two fields of the type `NSObject` in the class hold information about the
    observers we added. For removing the two observers we have added here, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Care must be taken when developing an application that uses the keyboard and
    supports multiple interface orientations. If, for example, the keyboard appears
    in portrait orientation and the user changes to landscape orientation, both the
    keyboard's bounds and the text field's frame will be different and must be adjusted
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying and editing text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. Interacting with Device Hardware"),Interacting
    with Device Hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rotating the device*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adjusting the UI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to display progress of a known length.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we will talk about the `UIProgressView` control. This control
    provides similar functionality to the **ProgressBar** in .NET. Create a **iPhone
    Single View Application** project in MonoDevelop, and name it `ProgressApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps for using the `UIProgressView` class. Note that in this
    recipe, we will add all controls programmatically, without the use of Interface
    Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `using` directives in the `ProgressAppViewController` class
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `ViewDidLoad` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the button and watch the progress bar fill.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current value of `UIProgressView` is represented by its `Progress` property.
    Its acceptable value range is always from `0` to `1`. So, when initializing it,
    we set it to `0` to make sure that the bar is not filled at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since the `UIProgressView` has a specific range, we need to assign the value
    we want it to be incremented by, depending on the number of items we need to process,
    in this case `10:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the button''s `TouchUpInside` handler, we disable the button and start our
    progress by asynchronously invoking a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `StartProgress()` method, we start a loop that will process the work
    that needs to be done. Since the work executes in an asynchronous method, when
    we want to make changes to the controls, it must be done on the main UI thread
    by calling the `BeginInvokeOnMainThread()` method of `UIApplicationDelegate`,
    which accepts a parameter of the type `NSAction`. An `NSAction` can accept anonymous
    methods as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIProgressView` supports one more style other than the default. Set its
    `Style` property to `UIProgressViewStyle.Bar` so that the bar will look like the
    one in the Mail application when receiving new e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Receiving user input with buttons*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying content larger than the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display content that extends beyond the
    screen's bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we will discuss the `UIScrollView` control. Create an **iPhone
    Single View Application** project, and name it `ScrollApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ScrollAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIScrollView` object on its view and connect it to an outlet. And save
    the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, add the following code in the `ScrollAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, add an image to the project and set its **Build Action** to **Content**.
    An image larger than the simulator's screen, a size of **320x480** pixels, is
    preferable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the application on the simulator. Tap-and-drag on the image
    to display different portions. By press *Alt* *+* mouse-click, you can simulate
    the pinch zooming function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIScrollView` is capable of managing content that expands beyond the screen
    size. The size of the content the scroll view will display must be set in its
    `ContentSize` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContentOffset` property defines the position of the content inside the
    scroll view''s bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What this means is that the image's (x=200, y=50) point will be displayed at
    the origin (x=0, y=0) of the `UIScrollView`. To provide zooming functionality
    for the content, we first set the `MinimumZoomScale` and `MaximumZoomScale` properties
    that set the minimum and maximum zoom scale for the content. A value of `2` means
    the content will be double in size, while a value of `0.5` means the content will
    be half the size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For the actual zooming operation, we need to set the `ViewForZoomingInScrollView`
    property, which accepts a delegate of the type `UIScrollViewGetZoomView` and returns
    a `UIView`. Here, the image view we created is returned, but another higher resolution
    image view can be used instead to provide better image quality when zooming. After
    the delegate is assigned, the initial zoom scale is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the scroll view''s indicator style is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Indicators are the two lines that appear when scrolling or zooming: one on
    the vertical-right side and one on the horizontal-bottom side of the scroll view,
    which informs the user of the position of the content. Much like scroll bars.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To provide a more pleasing scrolling and zooming effect to the user, the `UIScrollView`
    exposes the `Bounce` property. By default, it is set to `true`, but we have the
    option to disable it by setting it to `false`. Bouncing the content gives immediate
    feedback to the user that the bounds of the content have been reached, in either
    a horizontal or vertical direction. Furthermore, the `AlwaysBounceHorizontal`
    and `AlwaysBounceVertical` properties can be set individually. Setting one or
    both of these properties will make the scroll view always bounce the content in
    each respective direction, even if the content is equal to or smaller than the
    scroll view's bounds. Hence, no actual scrolling is needed.
  prefs: []
  type: TYPE_NORMAL
- en: UIScrollView events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UIScrollView` class exposes some very useful events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scrolled:` This event occurs while the content is being scrolled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DecelerationStarted:` This event occurs when the user has started scrolling
    the content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DecelerationEnded:` This event occurs when the user has finished scrolling
    and the content has stopped moving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a handler has been assigned to the `Scrolled` event, and the `ContentOffset`
    property is set, the event will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying images*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Displaying and editing text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Navigating through content divided into pages*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through content divided into pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIPageControl` class to provide
    page navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIPageControl` provides a simple visual representation of multiple pages
    or screens in an iOS app, indicated as dots. The dot that corresponds to the current
    page is highlighted. It is usually combined with the `UIScrollView`. Create a
    new **iPhone Single View Application** project in MonoDevelop, and name it `PageNavApp`.
    Add three image files in the project and set their **Build Action** to **Content**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PageNavAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIPageControl` to the bottom of the view and `UIScrollView` above it.
    Resize the scroll view to take up all the remaining space of the view, and save
    the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, enter the following code in the `PageNavAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. Scroll on the scroll view
    to change page. Likewise, tap or scroll on the page control to change page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is set the `UIScrollView.PagingEnabled` property
    to `true`, which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This property instructs the scroll view to perform scrolling at multiples of
    the scroll view''s bounds, hence providing paging functionality. After that, the
    image views that will be displayed in different pages are prepared. Here, we take
    care of adjusting each image view''s frame so that they will be positioned next
    to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We have attached handlers for two events. The first one is the `UIScrollView.DecelerationEnded`
    event, which will adjust the page control''s current page when the user scrolls
    the scroll view. The current page is determined by the scroll view''s `ContentOffset`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The second event we attach a handler to is the `UIPageControl.ValueChanged`
    event. In this handler, we make sure the content is scrolled when the user taps
    or drags on the page control. The scroll is performed when the `ContentOffset`
    property is set to the desired image view''s `Frame.X` property, using the `UIScrollView.SetContentOffset(PointF,
    bool)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter of the `SetContentOffset()` method instructs the scroll
    view to animate while scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, different `UIImageView` objects have been used. Any kind of
    `UIView` objects can be used, according to the type of content we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: Proper usage of the UIPageControl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users expect that scrolling to other pages will occur when tapping or dragging
    on the page control. It is not good practice to use it for displaying page indexing
    only, without being a fully active control.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying images*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Displaying content larger than the screen*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add and use toolbars in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIToolbar` class provides a toolbar that holds various buttons. It is the
    bar that resides at the bottom of views. Create a new **iPhone Single View Application**
    project in MonoDevelop, and name it `ToolbarApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ToolbarAppViewController.xib` file in Interface Builder and add a
    `UIToolbar` object at the bottom of its view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the button it contains by default and set its **Identifier** in the **Attributes
    Inspector** pad to **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Flexible Space Bar Button Item** object to the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another button on the toolbar, on the right side of the previous object,
    and set its **Identifier** to **Reply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UILabel` object on the view and connect all controls, apart from the
    flexible space item, to outlets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, enter the following code in the `ToolBarAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. Tap on both of the toolbar's
    buttons and see the status string display on the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The toolbar holds items of the type `UIBarButtonItem`. These items are special
    kinds of buttons and spacers. A `UIBarButtonItem` can have a custom type, or any
    of the predefined types that are listed in the **Identifier** attribute in Interface
    Builder. When the item is a button and the behavior it provides is included in
    these identifiers, it is recommended to use them. Each one of these identifiers
    basically provides a specific icon to the button, according to its intended usage,
    and the user is quite familiar with them since they are used by most iOS applications.
    Notice that the **Flexible Space Bar Button Item** we added to the toolbar is
    also a **UIBarButtonItem**, with a specific identifier. Its purpose is to keep
    two buttons apart, changing their in-between distance in situations where this
    is required, for example, when rotating the device at a landscape orientation
    and the toolbar resizes to fit the new width.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just rotating the device will not make the **UIToolbar** resize. This kind
    of behavior will be discussed in [Chapter 3](ch03.html "Chapter 3. User Interface:
    View Controllers"),User Interface: View Controllers'
  prefs: []
  type: TYPE_NORMAL
- en: This kind of bar button is displayed in Interface Builder, but not at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, we add handlers to the bar buttons'' `Clicked` event, whose purpose
    is quite familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It is being triggered when the user taps on the button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIBarButtonItem` class has a `Style` property that determines the button's
    style. It can be used only when the button item's identifier is set to `Custom`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a UIToolbar's items programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set bar button items to a `UIToolbar`, use one of the overloads of its `SetItems()`
    method. An example for setting two bar button items in a `UIToolbar` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"),User Interface:
    View Controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Navigating through different view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to override the `UIView` class and/or classes
    that derive from it, to create custom views.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have discussed many of the available views there are to create iOS
    applications. There will be many cases, however, that we will need to implement
    our own custom views. In this task, we will see how to create a custom view and
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating custom views is very useful when we want to capture touches or implement
    other custom behavior, such as drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **iPhone Single View Application** project in MonoDevelop, and
    name it `CustomViewApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to complete this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new C# class file in the project, and name it `MyView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `CustomViewAppViewController.xib` file in Interface Builder, and add
    a `UIView` object on the main view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect it to an outlet and set its **Class** field in the **Identity Inspector**
    to `MyView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the application on the simulator. Tap-and-drag on the view,
    and watch the touch coordinates being displayed in the label at the bottom of
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to note when creating custom views is to derive them from the
    `UIView` class and to decorate them with the `Register` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `Register` attribute basically exposes our class to the Objective-C world.
    Note that the name we pass as its parameter must be the same name that we enter
    in the **Class** field in the **Identity Inspector**. It is important to create
    the following constructor that overrides the base class' `UIView(IntPtr)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor is always being called when a view is initialized through
    native code. If we do not override it, an exception will occur upon initialization
    of the object when the runtime tries to recreate it if it has been removed when
    a memory warning is issued. The other constructor that is used in this example
    is just provided as guidance on what might be used if the view was initialized
    programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Both these constructors call the `Initialize()` method that performs the initialization
    we need, such as creating the label that will be used, set background colors,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `TouchesMoved` method is overridden. This is the method that is executed
    when the user drags a finger on the view. Inside the method, we retrieve the `UITouch`
    object from the method''s `NSSet` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `NSSet` object is a collection of data that are not in particular order.
    It is similar to an array. Its `AnyObject` parameter returns an object from the
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UITouch` object contains information about user touches. We retrieve the
    touch''s current location from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Its `LocationInView` method accepts a parameter of the type `UIView` that declares
    in which view's coordinate system the location will be calculated. In this case,
    we are interested in the coordinates of `MyView`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we would like to initialize the custom view that we created programmatically,
    we would enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding and customizing views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"),User Interface:
    View Controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*View controllers and views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
