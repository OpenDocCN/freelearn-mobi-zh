<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Collections and Data Operations in Kotlin</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In the previous chapters, we have covered a wide range of topics, starting from data types, classes, and objects in Kotlin and moving on to immutability, functions, delegates, and coroutines in the last chapter. </span>In this chapter, we are going to discuss the collections framework and data operations in Kotlin. Kotlin inherits collections framework from Java, but has significant changes from it in favor of functional programming.</p>
<p>The collections framework that Kotlin provides is more functional than Java and, as the signature of Kotlin, it is easier to use and understand.</p>
<p>We will start this chapter with the fundamentals of collections and gradually move on to data operations that collections support in Kotlin. The following is the list of topics that we are going to cover in this chapter:</p>
<ul>
<li>An introduction to collections</li>
<li>The <kbd>Iterator</kbd> and <kbd>Iterable</kbd> interfaces</li>
<li>Collection types in Kotlin—<kbd>Array</kbd>, <kbd>List</kbd>, <kbd>Map</kbd>, and <kbd>Set</kbd></li>
<li>Mutability and immutability</li>
<li>Working with lists</li>
<li>Various data operations—<kbd>map</kbd>, <kbd>sort</kbd>, <kbd>filter</kbd>, <kbd>flatMap</kbd>, <kbd>partition</kbd>, <kbd>fold</kbd>, and <kbd>group by</kbd></li>
</ul>
<p>So, what are we waiting for? Let's get started with collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to collections</h1>
                </header>
            
            <article>
                
<p>The <strong>collections framework</strong> is a set of classes and interfaces that provides a unified architecture for performing common groups of data related operations, such as the following:</p>
<ul>
<li>Searching</li>
<li>Sorting</li>
<li>Insertion</li>
<li>Deletion</li>
<li>Manipulation</li>
</ul>
<p>All the lists, maps, and sets we use in our programs everyday are part of this collections framework.</p>
<p>All collections frameworks contain the following things:</p>
<ul>
<li><strong>Interfaces</strong>: These are abstract data types are used to represent collections. Interfaces allow collections to be manipulated independent of the details of their representation. In object-oriented languages, these are generally interfaces form a hierarchy.</li>
<li><strong>Implementations</strong>: These are concrete implementations of the collection of interfaces. In essence, these are reusable data structures.</li>
<li><strong>Algorithms</strong>: Methods that perform useful computations, such as searching and sorting (as listed earlier), on objects that implement collection interfaces. These algorithms are said to be <strong>polymorphic</strong>. The same method can be used on many different implementations of the appropriate collection interface. In short, algorithms are a reusable functionality.</li>
</ul>
<p>Apart from the Java and Kotlin collections framework, the best-known examples of collections framework are the <strong>C++ Standard Template Library</strong> (<strong>STL</strong>) and Smalltalk's collection hierarchy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The advantages of a collections framework</h1>
                </header>
            
            <article>
                
<p>So, what is the benefit of having a collections framework? There are several benefits, but, most importantly, it reduces the programming time and effort. The collections framework provides a developer with high-quality (in terms of performance and code optimization) implementations of useful data structures and algorithms, while providing you with interoperability between unrelated APIs. You can use these implementations in your program, thus reducing your programming effort and time.</p>
<p>So, as we have got to know what the collections framework is, let us now have a look at the hierarchy of classes and interfaces in the collections framework.</p>
<p>So, let's go through the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img height="308" width="433" src="assets/fed6486d-41c8-4e4d-8e06-95b502f14c07.png"/></div>
<p>As we mentioned earlier, the collections framework is a set of data types and classes that lets us work with a group (or groups) of data. That group may be in the form of a simple list/map/set or any other data structure.</p>
<p>The preceding figure represents the collections framework of Kotlin. Just like Java, all collection interfaces in Kotlin are originated from the <kbd>Iterable</kbd> interface. However, the Kotlin collections framework is a bit different than that of Java; Kotlin distinguishes between mutable and immutable collections.</p>
<p>Kotlin has two base collection interfaces, namely <kbd>Iterable</kbd> and <kbd>MutableIterable</kbd>. The <kbd>Iterable</kbd> interface is extended by the <kbd>Collection</kbd> interface, which defines basic read-only collection operations (like <kbd>size</kbd>, <kbd>isEmpty()</kbd>, <kbd>contains()</kbd>, and so on).</p>
<p>The <kbd>MutableCollection</kbd> interface extends the <kbd>Collection</kbd> interface and the <kbd>MutableIterable</kbd> interface, adding the read-write feature.</p>
<p>Before the collections framework was introduced in Java, developers used to use arrays, vectors, and HashTables to work with a group of data. The problem with this approach was that none of them have some common methods. The collections framework was thus created to make a developer's life easier by providing common methods and operations across various types of collections.</p>
<div class="packt_tip">The collection framework was introduced in Java before formation of the Kotlin language and it has been included in Kotlin from the very beginning.</div>
<p>Aren't you curious about why there are so many collection types? Let's find out the purpose of some of the most commonly used collection types as we cover them in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List and MutableList</h1>
                </header>
            
            <article>
                
<p>List is one of the most commonly used collection data types. It is an implementation of the <kbd>Collection</kbd> interface used to work with a group of ordered data.</p>
<div class="packt_tip">The data in a list may be ordered based on when it was added (like if we add <kbd>3</kbd> after <kbd>4</kbd> to an <kbd>Int List</kbd>, then <kbd>4</kbd> will appear in the list before <kbd>3</kbd>, much like an array) or may even be ordered based on other ordering algorithms.</div>
<p>As we mentioned earlier, Kotlin distinguishes between mutable and read-only collection types; so, the <kbd>List</kbd> interface, which is immutable, contains only the read-only functions, as follows:</p>
<ul>
<li><kbd>fun get(index: Int):E</kbd>: This method is used to get an element from the list at the given index.</li>
<li><kbd>fun indexOf(element: @UnsafeVariance E):Int</kbd>: This method is used to identify the index of an element in the list. This method will search for the specified element inside the whole list and return the position of the element if it's in the list. Otherwise, it will return <kbd>-1</kbd>.</li>
<li><kbd>fun listIterator(): ListIterator&lt;E&gt;</kbd>: In case you want to get an instance of <kbd>ListIterator</kbd> (this will be covered later in this chapter, while we discuss <kbd>Iterator</kbd> and <kbd>Iterable</kbd>).</li>
<li><kbd>fun subList(fromIndex: Int, toIndex: Int): List&lt;E&gt;</kbd>: Returns a portion of the list with the specified <kbd>fromIndex</kbd> and <kbd>toIndex</kbd> value.</li>
</ul>
<p>So considering this, it contains only read-only functions, how can we have a list with data? While you cannot put data into an immutable list after it gets created, you can definitely create an immutable list with pre-populated data (obviously, otherwise there wouldn't be any purpose in having immutable lists). You can achieve that in many ways, but the most popular one is to use the <kbd>listOf</kbd> function.</p>
<p>The <kbd>listOf</kbd> function declaration looks like the following (which can be found inside <kbd>Collections.kt</kbd>, in the <kbd>kotlin.collections</kbd> package):</p>
<pre>public fun &lt;T&gt; listOf(vararg elements: T): List&lt;T&gt; </pre>
<p>As we can see in the function declaration, the function takes a <kbd>vararg</kbd> parameter of a generic type as an element; the function will return a <kbd>list</kbd> instance containing those elements. As you already know, the significance of a <kbd>vararg</kbd> argument is that it can contain 0 to almost 64K <span>arguments </span>(if each argument is of 1 byte, a function can have a maximum of 64K bytes allocation, so actually it would be less) within it; so, while creating <kbd>list</kbd> with the <kbd>listOf</kbd> function, you can call it even without parameters to create an empty list, or call the function with as many arguments as you need (assuming you don't need more than 64K bytes) to create the read-only <kbd>list</kbd> with them.</p>
<p>The following program is an example of the <kbd>listOf</kbd> function:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
<strong>    val list = listOf&lt;Int&gt;(1,2,3,4,5,6,7,8,9,10)</strong> 
     
    for (i in list) { 
        println("Item $i") 
    } 
} </pre>
<p>In the preceding program, we created a <kbd>list</kbd> value containing numbers <kbd>1</kbd> through <kbd>10</kbd>. We then used a <kbd>for</kbd> loop to loop through each element in the <kbd>list</kbd> value and print it.</p>
<p>Let's have a look at the following output to validate that:</p>
<div class="CDPAlignCenter CDPAlign"><img height="256" width="370" src="assets/12e2918f-eeba-4e45-bbb8-de68a825215d.png"/></div>
<p>The <kbd>i in list</kbd> inside the braces of the <kbd>for</kbd> loop, tells the <kbd>for</kbd> loop to iterate through all the elements inside the <kbd>list</kbd> value and copy the element to a temporary variable <kbd>i</kbd> for each of the iterations.</p>
<p>We will look at more ways to work with collections later in this chapter, but first let us learn different types of collections.</p>
<p>So, continuing our discussions on lists, we've seen how to create an immutable list with pre-defined elements; now, we will look at how to create and work with mutable lists, but before that let's have a look at the ways to create an empty list.</p>
<p>Let's go through the following program:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
<strong>    val emptyList1 = listOf&lt;Any&gt;()</strong><strong>    val emptyList2 = emptyList&lt;Any&gt;()</strong> 
     
    println("emptyList1.size = ${emptyList1.size}") 
    println("emptyList2.size = ${emptyList2.size}") 
} </pre>
<p>So, in the preceding program, we created empty lists, one with a <kbd>listOf</kbd> function with no arguments, another one is with an <kbd>emptyList</kbd> function. Please note that the <kbd>listOf</kbd> function, if called without any arguments, calls an <kbd>emptyList</kbd> function internally.</p>
<p>The following is the screenshot of the output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="107" width="395" src="assets/996b36b3-22db-44b0-ab46-dbe9dbeb4b26.png"/></div>
<p>So, we've seen how to work with immutable lists with a pre-defined bunch of elements, but what if we need to add items to the <kbd>list</kbd> value dynamically? Kotlin provides you with mutable lists for this purpose.</p>
<p>The following example will help you understand immutable lists:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
<strong>    val list = mutableListOf(1,2,4)//(1)</strong> 
 
    for (i in list) { 
        println("for1 item $i") 
    } 
 
    println("-----Adding Items-----") 
 
<strong>    list.add(5)//(2)</strong><strong>    list.add(2,3)//(3)</strong><strong>    list.add(6)//(4)</strong> 
 
    for (i in list) { 
        println("for2 item $i") 
    } 
} </pre>
<p>The following is the output of the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="291" width="418" src="assets/46f5c310-a7fc-460e-bd34-12381e8a332f.png"/></div>
<p>Now, let us explain the program. So, at first, we created the <kbd>list</kbd> value with <kbd>mutableListOf</kbd> function on comment <kbd>(1)</kbd>, with the items <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>4</kbd>. Note, we skipped the type parameter here, it's not important if you pass the elements to the function, as Kotlin has type interference. We printed the <kbd>list</kbd> values before moving ahead to add items.</p>
<div class="packt_tip">For <kbd>listOf</kbd> or any other collections function, type interference is an issue. So, you'll not need to specify the generic type of the collection in use if you pass the elements or if you've provided the type of the collection itself.</div>
<p>On comment <kbd>(2)</kbd>, we added item <kbd>5</kbd> to the <kbd>list</kbd>, with the <kbd>List$add()</kbd> function, which appends the provided item to the <kbd>list</kbd> array.</p>
<p>Then, on comment <kbd>(3)</kbd>, we used the <kbd>add</kbd> function with an index parameter, to add item <kbd>4</kbd> to the second position (counting from <kbd>0</kbd>, as usual).</p>
<p>Then, again we appended the <kbd>list</kbd> array with <kbd>5</kbd>.</p>
<p>So, we added elements to a <kbd>list</kbd> array and accessed all the items through the <kbd>for</kbd> loop, but what about accessing a single element? Let's have an example to access and modify single elements in Kotlin. Go through the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = listOf( 
            "1st Item", 
            "2nd Item", 
            "3rd Item", 
            "4th Item", 
            "5th Item" 
    ) 
 
    println("3rd Item on the list - ${list.get(2)}") 
    println("4rd Item on the list - ${list[3]}") 
} </pre>
<p>We accessed the third element with index <kbd>2</kbd> and the fourth element with index <kbd>3</kbd>. The reason is simple and straightforward as, with arrays and in lists, counting begins at <kbd>0</kbd>.</p>
<p>The thing to notice here is that Kotlin provides out-of-the-box support for lists and provides you with a square bracket operator (<kbd>[]</kbd>) to access elements of the <kbd>list</kbd> value just like an array. In the first <kbd>get</kbd> statement, we used the <kbd>get</kbd> function with an index to get the element of that index; in the second <kbd>get</kbd> statement, we used the square brackets, which, in turn, call that <kbd>get</kbd> function.</p>
<div class="packt_tip">As lists store items as per their order/index, it's easy to get items from a list with an index; you can easily skip a loop if you want just a particular element from that list and if you know the index for the element you want. Just pass the element to the <kbd>get</kbd> function and you have the element.<br/>
This <kbd>get</kbd> element by index is not supported by other collection interfaces like <kbd>set</kbd> (though <kbd>OrderedSet</kbd> supports them), which doesn't support the ordering of elements.</div>
<p>So, as we have got a little grip on lists, let us move ahead and have a look at the sets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Set and MutableSet</h1>
                </header>
            
            <article>
                
<p>Just like <kbd>List</kbd>, <kbd>Set</kbd> also has the following two variants in Kotlin:</p>
<ul>
<li><kbd>Set</kbd></li>
<li><kbd>MutableSet</kbd></li>
</ul>
<p><kbd>Set</kbd> is read-only and <kbd>MutableSet</kbd> is the mutable version of <kbd>Set</kbd>, which contains the read-write functionalities.</p>
<div class="packt_infobox">Just like with list, set values also have read-only functions and properties like <kbd>size</kbd>, <kbd>iterator()</kbd>, and so on. We are skipping mentioning them here to avoid redundant contents in this book. Also, please note that set doesn't do ordering like list (unless you use <kbd>OrderedSet</kbd>). So, it lacks the functions which involve orders like <kbd>indexOf(item)</kbd>, <kbd>add(index, item)</kbd>, and so on.</div>
<p>Sets in collections represent mathematical sets (as in set theory).</p>
<p>The following is an example with <kbd>MutableSet</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val set = mutableSetOf(1,2,3,3,2) 
 
    println("set $set") 
 
    set.add(4) 
    set.add(5) 
    set.add(5) 
    set.add(6) 
 
    println("set $set") 
} </pre>
<p>The following is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="110" width="426" src="assets/e5486b76-2bb9-4eed-ac21-6e4bbcba1367.png"/></div>
<p>The output clearly shows that, even though we added multiple duplicate items to the <kbd>set</kbd>, both at the time of initialization and later, only unique items got inserted and all duplicate items got ignored.</p>
<p>Now, you may be curious as to whether the same will happen with custom classes and data classes; let us check with the following example:</p>
<pre>data class MyDataClass (val someNumericValue:Int, val someStringValue:String)<br/>class MyCustomClass (val someNumericValue:Int, val someStringValue:String) {<br/>    override fun toString(): String {<br/>      return "MyCustomClass(someNumericValue=$someNumericValue, someStringValue=$someStringValue)"<br/>    }<br/>  }<br/>fun main(args: Array&lt;String&gt;) {<br/>    val dataClassSet = setOf(<br/>         MyDataClass(1,"1st obj"),<br/>         MyDataClass(2,"2nd obj"),<br/>         MyDataClass(3,"3rd obj"),<br/>         MyDataClass(2,"2nd obj"),<br/>         MyDataClass(4,"4th obj"),<br/>         MyDataClass(5,"5th obj"),<br/>         MyDataClass(2,"will be added"),<br/>         MyDataClass(3,"3rd obj")<br/>    )<br/>    println("Printing items of dataClassSet one by one")<br/>    for(item in dataClassSet) {<br/>      println(item)<br/>    }<br/>    val customClassSet = setOf(<br/>      MyCustomClass(1,"1st obj"),<br/>      MyCustomClass(2,"2nd obj"),<br/>      MyCustomClass(3,"3rd obj"),<br/>      MyCustomClass(2,"2nd obj"),<br/>      MyCustomClass(4,"4th obj"),<br/>      MyCustomClass(5,"5th obj"),<br/>      MyCustomClass(5,"5th Obj"),<br/>      MyCustomClass(3,"3rd obj")<br/>    )<br/>    println("Printing items of customClassSet one by one")<br/>    for(item in customClassSet) {<br/>      println(item)<br/>    }<br/> }</pre>
<p>In this program, we first created a data class and a custom class, then we created sets with them and inserted duplicate items.</p>
<p>Let us see the following output to check whether the sets are free of duplicate items:</p>
<div class="CDPAlignCenter CDPAlign"><img height="350" width="473" src="assets/49fedff6-df68-4e79-b4c8-61511cfd80a9.png"/></div>
<p>Have a look at the preceding output carefully. While, as is the case with data classes,  <kbd>set</kbd> ignored the duplicate items, when trying the same with a normal class, it was unable to detect the duplicate insertions and kept them.</p>
<div class="packt_tip">The last item that got added in <kbd>dataClassSet</kbd>—<kbd>MyDataClass(2,"will be added")</kbd> if you think it was a duplicate item then check again, while the value of <kbd>someNumericValue</kbd> for this object is identical to a previous one, the <kbd>someStringValue</kbd> value differs from that previous object's <kbd>someStringValue</kbd>.</div>
<p>Why is this an anomaly? The answer is short and simple—the collections framework internally uses <kbd>hashCode()</kbd> and <kbd>equals()</kbd> functions to perform equality checks while adding items to the <kbd>set</kbd> values and they are missing from the custom class.</p>
<div class="packt_tip">In Kotlin, the compiler automatically extracts the <kbd>hashCode()</kbd> and <kbd>equals()</kbd> functions. Thus, the <kbd>set</kbd> values were able to distinguish between duplicate items without custom implementations of those functions. For more information on data classes visit the following link: <a href="https://kotlinlang.org/docs/reference/data-classes.html"><span class="URLPACKT">https://kotlinlang.org/docs/reference/data-classes.html</span></a></div>
<p>So, if we implement those functions, then <kbd>set</kbd> will be able to distinguish between the duplicate items in the <kbd>customClassSet</kbd> values as well. Obviously, that's how it works for data classes as well. Just add the following code to the <kbd>MyCustomClass</kbd> definition and run the program to see the difference yourself:</p>
<pre>override fun hashCode() = someStringValue.hashCode()+someNumericValue.hashCode() 
 
    override fun equals(other: Any?): Boolean { 
        return other is MyCustomClass &amp;&amp; other.someNumericValue == someNumericValue &amp;&amp; other.someStringValue==someStringValue 
    } </pre>
<p>Cool, isn't it? So, we are done with <kbd>List</kbd> and <kbd>Set</kbd>. Let us now have a look at the <kbd>Map</kbd> interface; then, we will discuss the data operation functions provided by the collections framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Map and MutableMap</h1>
                </header>
            
            <article>
                
<p>The <kbd>Map</kbd> interface in the collections framework is a bit different than all others interfaces we have covered earlier; unlike others it works with key-value pairs. No, this is not similar to <kbd>Pair</kbd>; <kbd>Pair</kbd> is just a pair of two values combined together, while a map is a collection of key-value pairs.</p>
<p>In a map, keys are unique and cannot be duplicated. If you add two values with the same key, then the later one will replace the previous one. Values, on the other hand can be redundant/duplicate. The reason behind this behavior is that in a map, a value is stored and retrieved with respect to its key, so redundant keys will make it impossible to distinguish them from each-other and to fetch their values.</p>
<p>The declaration of <kbd>Map</kbd> in Kotlin reads like interface <kbd>Map&lt;K, out V&gt;</kbd>, the <kbd>K</kbd> value is the generic type of the key and <kbd>V</kbd> is the generic type of value.</p>
<p>To learn more about collections, let us have a look at a few of the functions and properties. Go through the following list:</p>
<ul>
<li><kbd>val size: Int</kbd>: This function indicates the size of the <kbd>Map</kbd> interface, that is, the number of key-value pairs residing inside the map.</li>
<li><kbd>fun isEmpty(): Boolean</kbd>: This function helps in checking whether a <kbd>Map</kbd> interface is empty or not.</li>
<li><kbd>fun containsKey(key: K): Boolean</kbd>: This function checks for the provided <kbd>key</kbd> inside the collection of key-value pairs it has and returns <kbd>true</kbd> if it is found.</li>
<li><kbd>operator fun get(key: K): V?</kbd>: This function cum operator (if used by square brackets (<kbd>[]</kbd>) like an array) returns the value corresponding to a key or null if the key doesn't exist within it.</li>
<li><kbd>val keys: Set&lt;K&gt;</kbd>: This function indicates the collection of keys available in that map at that point of time. As keys cannot be duplicated and they are not ordered, a <kbd>Set</kbd> value is the best data-structure to hold them.</li>
<li><kbd>val values: Collection&lt;V&gt;</kbd>: Contains all the values of the <kbd>map</kbd> value as a collection.</li>
<li><kbd>interface Entry&lt;out K, out V&gt;</kbd>: This function is defined inside the <kbd>Map</kbd> interface. An <kbd>Entry</kbd> represents a single key-value pair in the <kbd>Map</kbd> interface. The key-value pairs are stored as an entry inside the <kbd>map</kbd> value.</li>
<li><kbd>val entries: Set&lt;Map.Entry&lt;K, V&gt;&gt;</kbd>: This function gets you all the entries in the map.</li>
</ul>
<p>The previous were read-only interfaces of <kbd>Map</kbd> as it only supports read-only operations. For read-write access, you've to use the <kbd>mutableMap</kbd> function. So, let us now have a look at the read-write interfaces provided by <kbd>mutableMap</kbd> as seen in the following list:</p>
<ul>
<li><kbd>fun put(key: K, value: V): V?</kbd> : This interface adds a key-value pair to the <kbd>Map</kbd> and returns the previous value associated with the key (if any or null if the key wasn't present in the <kbd>Map</kbd> earlier).</li>
<li><kbd>fun remove(key: K): V?</kbd> : This interface removes a key-value pair from the map with the key and returns the value and returns null if the key doesn't exist in the <kbd>Map</kbd> interface.</li>
<li><kbd>fun putAll(from: Map&lt;out K, V&gt;): Unit</kbd> : This interface adds the key-value pairs from the provided <kbd>map</kbd> value.</li>
<li><kbd>fun clear(): Unit</kbd>: As the name suggests, this instance clears the <kbd>map</kbd> value. It removes everything that the <kbd>map</kbd> value contains—every key and every value.</li>
</ul>
<p>So, as we now know the interfaces and functions the <kbd>Map</kbd> interfaces has to offer, let's now have an example with <kbd>Map</kbd>.</p>
<p>Let's go through the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val map = mapOf( 
            "One".to(1), 
            "Two".to(2), 
            "Three".to(3), 
            "Four".to(4), 
            "Five".to(0),//(1) We placed 0 instead of 5 here, will be replaced later 
            "Six".to(6), 
            "Five".to(5)//(2) This will replace earlier map of "Five".to(0) 
            ) 
 
    println("The value at Key `Four` is ${map["Four"]}") 
 
    println("Contents in map") 
    for(entry in map) { 
        println("Key ${entry.key}, Value ${entry.value}") 
    } 
 
    val mutableMap = mutableMapOf&lt;Int,String&gt;() 
 
    mutableMap.put(1,"Item 1") 
    mutableMap.put(2,"Item 2") 
    mutableMap.put(3,"Item 3") 
    mutableMap.put(4,"Item 4") 
 
    println("Replacing value at key 1 - ${mutableMap.put(1,"Item 5")}")//(3) 
 
    println("Contents in mutableMap") 
    for(entry in mutableMap) { 
        println("Key ${entry.key}, Value ${entry.value}") 
    } 
} </pre>
<p>So, we demonstrated the use of the following two types of maps:</p>
<ul>
<li>Read-only <kbd>Map</kbd></li>
<li>Read-write <kbd>MutableMap</kbd></li>
</ul>
<p>Kotlin provides you with a version of the <kbd>mapOf()</kbd> function that accepts <kbd>vararg</kbd> parameters of the <kbd>Pair</kbd> <span>type.</span> This makes it easy for you to create read-only maps—just pass the key-value pairs as the instances of <kbd>Pair</kbd> to the <kbd>mapOf()</kbd> function.</p>
<p>Let us see the output before further inspecting and discussing the program. See the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="324" width="348" src="assets/011bf909-bf9d-4205-90bf-cfa0e42bcfb0.png"/></div>
<p>While creating the map, on comment <kbd>(1),</kbd> we passed a <kbd>"Five".to(0)</kbd> p<span>air </span>and on comment <kbd>(2)</kbd>, we passed the <kbd>"Five".to(5)</kbd> <span>pair </span>to the same <kbd>mapOf</kbd> function, to check which value the <kbd>map</kbd> stores for the <kbd>"Five"</kbd> <span>key;</span> the output suggests that the <kbd>map</kbd> took the second value—<kbd>5</kbd>, as we described earlier that a <kbd>map</kbd> value always takes the last value for the same key.</p>
<p>Also note that Kotlin supports array-like square brackets in <kbd>Map</kbd> as well. Instead of an index, you can pass the key.</p>
<p>So, as we got our hands dirty with three most important interfaces in Kotlin's collection framework: <kbd>List</kbd>, <kbd>Set</kbd>, and <kbd>Map</kbd>. Let's now move forward and get ourselves introduced to data operations in a collection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data operations in a collection</h1>
                </header>
            
            <article>
                
<p>Kotlin provides out-of-the-box support for its collection framework. As a result, the collections framework in Kotlin is full of interesting features that make it stand apart from the collections framework in other languages, such as Java. You already got introduced with some of those features, such as separate interfaces for read-only and mutable collections, square box operator-like arrays, and so on. What I'm going to introduce now is probably the most interesting feature of Kotlin's collections framework, but goes mostly unnoticed—data operation functions.</p>
<p>Kotlin supports data operation functions for all of its collections framework interfaces, objects, and classes. By data operation functions, I mean the operators and functions by which we can access, process or operate on data from a collection; if you are familiar with ReactiveX framework/RxJava/RxKotlin, you'll find it similar as Kotlin picked them mostly from there.</p>
<p>The following is a list of a few of the collection data operation functions that we are going to cover here:</p>
<ul>
<li>The <kbd>map</kbd> function</li>
<li>The <kbd>filter</kbd> function</li>
<li>The <kbd>flatMap</kbd> function</li>
<li>The <kbd>drop</kbd> functions</li>
<li>The <kbd>take</kbd> functions</li>
<li>The <kbd>zip</kbd> functions</li>
</ul>
<p>So, what are we waiting for? Let us get started.</p>
<div class="mce-root packt_tip">Though, the data operation functions with collections make you feel like you're working with streams/Rx, they are in no way similar to streams/Rx. What they do is simply use high order functions and extension functions to provide you with stream-like interfaces and internally they operate on the same loops (yes, you read it right, they use loops to produce results and then return it from the function just like a simple imperial program). It is advisable to avoid bigger chains of these functions in your program, as you'll end up with multiple loops. Using <kbd>forEach</kbd> or your own loop in such scenarios is a better choice, as you will be able to perform multiple operations with a single loop with <kbd>forEach</kbd> or with your own loop. However, for a single operation or small chains, you can definitely use these functions to make your code well organized.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The map function</h1>
                </header>
            
            <article>
                
<p>The <kbd>map</kbd> function allows you to apply an algorithm to a collection all-together and obtain the results as a resultant set. It's helpful in making your code well-organized and writing loops (though it'll use loop internally, you're freed from writing those boilerplate codes).</p>
<p>The <kbd>map</kbd> function receives all the elements of the collection as each iteration and should return the computed resultant item that should be placed in the resultant list in place of the passed item.</p>
<p>Go through the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = listOf&lt;Int&gt;(1,2,3,4,5,6,7,8,9,10) 
    val modifiedList = list.map { it*2 } 
 
    println("modifiedList -&gt; $modifiedList") 
} </pre>
<p>So, we had a list of <kbd>Int</kbd>, we needed to multiply each item from the <kbd>list</kbd> value with <kbd>2</kbd>, and we did it with ease with just a single line of code—<kbd>list.map { it*2 }</kbd>, which would normally take us two or three lines more of boilerplate. Insane, isn't it?</p>
<p>The following is the output of the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="88" width="445" src="assets/b178834e-cece-4c43-9e2e-c0bf9ae395bb.png"/></div>
<p>As expected, the <kbd>map</kbd> function applied the provided lambda to each of the elements of the list and returned the resultant list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The filter function</h1>
                </header>
            
            <article>
                
<p>Think of a situation where you need to filter the items in a collection. For example, when you want to obtain only even numbers from a list of integers. The <kbd>filter</kbd> function is there to help you in these scenarios.</p>
<p>The <kbd>filter</kbd> function receives all the elements of the collection as each iteration and should return <kbd>true</kbd> or <kbd>false</kbd>, based on its determination of whether the passed item should be on the resultant list or not.</p>
<p>Go through the following program:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = 1.until(50).toList()//(1) 
    val filteredListEven = list.filter { it%2==0 }//(2) 
 
    println("filteredListEven -&gt; $filteredListEven") 
 
    val filteredListPSquare = list.filter { 
        val sqroot = sqrt(it.toDouble()).roundToInt() 
        sqroot*sqroot==it 
    }//(3) 
 
    println("filteredListPSquare -&gt; $filteredListPSquare") 
} </pre>
<p>In this program, we first obtained a list of <kbd>Int</kbd> containing numbers from <kbd>1</kbd> to <kbd>50</kbd> with the help of <kbd>IntRange</kbd>. We then filtered the list to obtain even numbers on comment <kbd>(2)</kbd> and printed them. On comment <kbd>(3)</kbd>, we filtered the list (the original list containing <kbd>Int</kbd> values from <kbd>1</kbd> to <kbd>50</kbd>) to obtain perfect squares and printed them.</p>
<p>The following is the output of the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="155" width="390" src="assets/4f0bbb4f-4034-4041-89ed-e9fb2c5d9b48.png"/></div>
<p>The previous code snippet and its output show just how much boilerplate code can be eliminated with the help of these data operation functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The flatMap function</h1>
                </header>
            
            <article>
                
<p>Another awesome function available with collections framework is the <kbd>flatMap</kbd> function.</p>
<p>Like the <kbd>map</kbd> function, it receives each of the items in the collection as an iteration, but, unlike the <kbd>map</kbd> function, it should return another collection for each of the items passed. These returned collections are then combined to create the resultant collection.</p>
<p>Have a look at the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = listOf(10,20,30) 
 
    val flatMappedList = list.flatMap { 
        it.rangeTo(it+2).toList() 
    } 
 
    println("flatMappedList -&gt; $flatMappedList") 
} </pre>
<p>The output looks like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="87" width="414" src="assets/3ba5c3b3-b4dd-4360-bd5f-eb3bdab9141b.png"/></div>
<p>While the original list contained only three numbers—<kbd>10</kbd>, <kbd>20</kbd>, and <kbd>30</kbd>, the resultant list contains three more numbers for each of the numbers in the original list, all thanks to the <kbd>flatMap</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The drop functions</h1>
                </header>
            
            <article>
                
<p>There may be some scenarios when you want to drop a portion (say, the first 5 or the last 10) of the collection and work on the remaining parts. Kotlin's collection framework provides you with a set of the <kbd>drop</kbd> functions that can help you in these scenarios. Have a look at the following program:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = 1.until(50).toList() 
 
    println("list.drop(25) -&gt; ${list.drop(25)}")//(1) 
    println("list.dropLast(25) -&gt; ${list.dropLast(25)}")//(2) 
} </pre>
<p>In the preceding program, we've dropped the first <kbd>25</kbd> items from the list on comment <kbd>(1)</kbd>, and on comment <kbd>(2)</kbd>, I've dropped the last <kbd>25</kbd> items.</p>
<p>The following screenshot shows the output of the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="181" width="434" src="assets/d75cc5be-d87a-479e-a934-9025fbeafeff.png"/></div>
<p>Worked perfectly, didn't it?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The take functions</h1>
                </header>
            
            <article>
                
<p>The <kbd>take</kbd> functions work in just the opposite way to the <kbd>drop</kbd> functions. You can take a selection from the collection and ignore the rest.</p>
<p>Have a look at the following program:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = 1.until(50).toList() 
 
    println("list.take(25) -&gt; ${list.take(25)}")//(1) 
    println("list.takeLast(25) -&gt; ${list.takeLast(25)}")//(2) 
    println("list.takeWhile { it&lt;=10 } -&gt; ${list.takeWhile { it&lt;=10 }}")//(3) 
    println("list.takeLastWhile { it&gt;=40 } -&gt; ${list.takeLastWhile { it&gt;=40 }}")//(4) 
} </pre>
<p>While statements on comment <kbd>(1)</kbd> and comment <kbd>(2)</kbd> are opposite to the <kbd>drop</kbd> functions earlier, they just take and print the <kbd>25</kbd> items from the list.</p>
<p>The statement on comment <kbd>(3)</kbd> is a bit different, here we used the <kbd>takeWhile</kbd> function. The <kbd>takeWhile</kbd> function takes a predicate and keeps taking items on the resultant collection while the predicate returns <kbd>true</kbd>; once the predicate returns <kbd>false</kbd> the <kbd>takeWhile</kbd> value will stop checking for any more items and will return the resultant collection.</p>
<p>The <kbd>takeLastWhile</kbd> values work in a similar way but in reverse.</p>
<p>The following is a screenshot of the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="248" width="430" src="assets/df4ae23a-0073-4ee7-898b-0f9e55ff1e2f.png"/></div>
<p>Let's now move ahead with the <kbd>zip</kbd> functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The zip function</h1>
                </header>
            
            <article>
                
<p>The <kbd>zip</kbd> function does exactly what it sounds like, it zips collections. Confusing? Let's have a look at the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list1 = listOf(1,2,3,4,5) 
    val list2 = listOf( 
            "Item 1", 
            "Item 2", 
            "Item 3", 
            "Item 4", 
            "Item 5" 
    ) 
 
    val resultantList = list1.zip(list2) 
 
    println(resultantList) 
} </pre>
<p>We created two lists—one with <kbd>Int</kbd> and the other with <kbd>String</kbd>. We then created a resultant list by zipping the <kbd>Int</kbd> list with the <kbd>String</kbd> list and printed the resultant list.</p>
<p>So, what does the <kbd>resultantList</kbd> value contain? What operation did the <kbd>zip</kbd> function perform?</p>
<p>Let us decide it ourselves by having a look at the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="112" width="366" src="assets/f158d2ea-32e5-44bc-9911-b32f07745d98.png"/></div>
<p>Amazing, isn't it? The <kbd>zip</kbd> function takes another collection, combines the source collection with the provided collection, and creates a <kbd>Pair</kbd> value for each of the items. But what if the collections differ in item counts? What if we want to combine each item in a list with the next item in the same list?</p>
<p>Let's take another example. Have a look at the following code:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list1 = listOf(1,2,3,4,5,6,7,8) 
    val list2 = listOf( 
            "Item 1", 
            "Item 2", 
            "Item 3", 
            "Item 4", 
            "Item 5" 
    ) 
 
    println("list1.zip(list2)-&gt; ${list1.zip(list2)}") 
 
    println("list1.zipWithNext() -&gt; ${list1.zipWithNext()}") 
} </pre>
<p>So, the first <kbd>println</kbd> statement here answers our first question—it tries to combine two lists with asymmetrical item counts.</p>
<p>On the second <kbd>println</kbd> statement, we used the <kbd>zipWithNext</kbd> function, which zips one item of a collection with the next item of the same collection. So, let's have a look at the output to find out what happens.</p>
<p>The following is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="149" width="399" src="assets/1ccd9aa4-3a4b-446d-9fb4-a76c1d876257.png"/></div>
<p>So, the <kbd>zip</kbd> operator only zipped those items of <kbd>list1</kbd>, for which it could find a pair in <kbd>list2</kbd> and skipped the remaining. The <kbd>zipWithNext</kbd> operator on the other hand, worked as expected.</p>
<p>So, we are done with data operation functions in Kotlin collection framework. However, Kotlin provides you with more capabilities for collections; so, let's move ahead and see what more it has to offer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grouping collections</h1>
                </header>
            
            <article>
                
<p>Kotlin's collection framework allows you to group collections based on your requirements. For example, if you have a list of strings and want to group them with respect to their size, you can easily do that with the help of the <kbd>groupBy</kbd> function, which groups a collection based on the logic provided and returns <kbd>Map</kbd> with that group of collections.</p>
<p>So, the following is a short example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val list = 1.rangeTo(50).toList() 
 
    println(list.groupBy { it%5 }) 
} </pre>
<p>So, what we did here is as follows: we created a list of <kbd>Int</kbd> containing numbers from <kbd>1</kbd> to <kbd>50</kbd> (both inclusive) then, we tried to group them based on their remnants when divided by <kbd>5</kbd>.</p>
<p>So, there should be five groups, from <kbd>0</kbd> to <kbd>5</kbd>, and each of them should contain 10 numbers. Let's check the following output to see if that happened or not:</p>
<div class="CDPAlignCenter CDPAlign"><img height="159" width="368" src="assets/0d47e4fd-5eba-4647-8a73-9540bc7d9d44.png"/></div>
<p>So, the <kbd>groupBy</kbd> function just worked as expected and returned <kbd>Map&lt;Int,List&lt;Int&gt;&gt;</kbd> that contained the grouped list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>So, this chapter was on collections and data operations in Kotlin. We started the chapter by exploring the collection framework in Kotlin and data structure of collections, and we gradually moved towards learning the data operations and functions that Kotlin collection framework provides out of the box.</p>
<p>In the next chapter, we will learn how to work with functional programming, reactive programming, and OOP altogether. We believe Kotlin is the best language for this, as it lets you take the benefits of both worlds—functional programming and OOP. In the next chapter, we will see how to take advantage of this.</p>
<p>In the next chapter, we will also introduce ourselves to the ReactiveX framework, which is among the most popular frameworks for functional reactive programming.</p>
<p>So, lets move ahead; the next chapter is just a page turn away.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>