<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. User Interface – View Controllers</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading a view with a view controller</li><li class="listitem" style="list-style-type: disc">Navigating through different view controllers</li><li class="listitem" style="list-style-type: disc">Providing controllers in tabs</li><li class="listitem" style="list-style-type: disc">Modal view controllers</li><li class="listitem" style="list-style-type: disc">Creating a custom view controller</li><li class="listitem" style="list-style-type: disc">Using view controllers efficiently</li><li class="listitem" style="list-style-type: disc">iPad view controllers</li><li class="listitem" style="list-style-type: disc">UI flow design with storyboards</li><li class="listitem" style="list-style-type: disc">Unwinding in storyboards</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Introduction</h1></div></div></div><p>So far, we have discussed views and how to use them. In most cases of real world app scenarios, views alone are not enough. Apple provides another base class, the <code class="literal">UIViewController</code> class, which is responsible for managing views. A view controller can respond to<a id="id203" class="indexterm"/> device notifications, such as when the device rotates, or can provide different ways to display and dismiss multiple views or even other view controllers. There are a number of view controllers available for us to use. In this chapter, we will discuss  the most important ones.</p><p>These view controllers are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>UIViewController</strong>: This<a id="id204" class="indexterm"/> is the base class<a id="id205" class="indexterm"/> of all view controllers.</li><li class="listitem" style="list-style-type: disc"><strong>UINavigationController</strong>: This is the view controller that provides various ways <a id="id206" class="indexterm"/>of navigating through different <a id="id207" class="indexterm"/>view controllers.</li><li class="listitem" style="list-style-type: disc"><strong>UITabBarController</strong>: This <a id="id208" class="indexterm"/>is a view controller<a id="id209" class="indexterm"/> that displays multiple view controllers in a tab-like interface.</li><li class="listitem" style="list-style-type: disc"><strong>iPad-specific view controllers</strong>: These are the view controllers that only apply <a id="id210" class="indexterm"/>to the iPad device.</li></ul></div><p>Furthermore, we <a id="id211" class="indexterm"/>will learn how to create our own custom view controllers, and we will create an app whose user interface will be created with storyboard files.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Loading a view with a view controller</h1></div></div></div><p>In this recipe, we will learn how to use the <code class="literal">UIViewController</code> class to manage views.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec101"/>Getting ready</h2></div></div></div><p>Create a<a id="id212" class="indexterm"/> new iPhone <strong>Empty Project</strong> in Xamarin Studio and name it <code class="literal">ViewControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec102"/>How to do it...</h2></div></div></div><p>Perform <a id="id213" class="indexterm"/>the following steps to load a view with a view controller:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new file to the project.</li><li class="listitem">Right-click on the project in the <strong>Solution</strong> pad and go to <strong>Add</strong> | <strong>New File…</strong>.</li><li class="listitem">In the dialog that will appear, select <strong>iPhone View Controller</strong> from the <strong>iOS</strong> section. Name it <code class="literal">MainViewController</code> and click on the <strong>New</strong> button. Xamarin Studio will create a new XIB file and will automatically open the <code class="literal">MainViewController.cs</code> source file. This file contains a class that overrides the <code class="literal">UIViewController</code> class, and we can implement any code related to our view controller in it.</li><li class="listitem">Open the <code class="literal">MainViewController.xib</code> file in Interface Builder.</li><li class="listitem">Add <code class="literal">UILabel</code> on the view.</li><li class="listitem">Create and connect an outlet for it inside the <code class="literal">MainViewController</code> class and name it <code class="literal">myLabel</code>.</li><li class="listitem">Enter the text <code class="literal">View in controller!</code> in the label.</li><li class="listitem">Save the XIB document.</li><li class="listitem">In Xamarin Studio, enter the following code in the <code class="literal">FinishedLaunching</code> method of the <code class="literal">AppDelegate</code> class, right after the window initialization line:<div><pre class="programlisting">MainViewController mainController = new MainViewController ();
window.RootViewController = mainController;</pre></div></li><li class="listitem">Compile and run the app on the simulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec103"/>How it works...</h2></div></div></div><p>When <a id="id214" class="indexterm"/>we add a new <code class="literal">iPhone View Controller</code> file in a project, in this case <code class="literal">MainViewController</code>, Xamarin Studio basically<a id="id215" class="indexterm"/> creates and adds the following three files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MainViewController.xib</code>: This is the XIB file that contains the controller.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MainViewController.cs</code>: This is the C# source file that implements the class of our controller.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MainViewController.designer.cs</code>: This is the autogenerated source file that reflects the changes we make to the controller in Interface Builder.</li></ul></div><p>Notice that we do not need to add an outlet for the view as this is taken care of by Xamarin Studio. We initialize the controller through its class, as follows:</p><div><pre class="programlisting">MainViewController mainController = new MainViewController ();</pre></div><p>Then, we assign the controller to the <code class="literal">window.RootViewController</code> property, as follows:</p><div><pre class="programlisting">window.RootViewController = mainController.</pre></div><p>Our view controller is now the root view controller of our app's window, and it is the first one that will be shown when the app starts.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec104"/>There's more...</h2></div></div></div><p>The project we have just created only shows how we can add a controller with a view. Notice that we created the outlet for the label inside the <code class="literal">MainViewController</code> class, which acts as the file's owner object in the XIB file. To provide some functionality for the <code class="literal">MainViewController</code> class, add the following method in the <code class="literal">MainViewController</code> class in the <code class="literal">MainViewController.cs</code> file:</p><div><pre class="programlisting">public override void ViewDidLoad ()
{
  this.myLabel.Text = "View loaded!";
}</pre></div><p>This method overrides the <code class="literal">UIViewController.ViewDidLoad()</code> method, which is executed after the controller has loaded its view.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec30"/>UIViewController methods to override</h3></div></div></div><p>The <code class="literal">UIViewController</code> class contains a number of methods that allow us to manage the view controller's life cycle. These methods are called by the system on the view controller, and we can override them to add our own implementation. Some of these methods are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ViewWillAppear</code>: This <a id="id216" class="indexterm"/>method is called when the controller's view is about to appear.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewDidAppear</code>: This <a id="id217" class="indexterm"/>method is called when the controller's view has been displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewWillDisappear</code>: This method is called when the controller's view is about<a id="id218" class="indexterm"/> to disappear, for example, when another controller will be displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewDidDisappear</code>: This<a id="id219" class="indexterm"/> method is called when the view has disappeared.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec105"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Navigating through different view controllers</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Creating an iOS project with Xamarin Studio</em> and <em>Accessing the UI with Outlets</em> recipes from <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <em>Development Tools</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Navigating through different view controllers</h1></div></div></div><p>In this recipe, we will learn how to use the <code class="literal">UINavigationController</code> class to navigate among multiple view controllers.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec106"/>Getting ready</h2></div></div></div><p>The <code class="literal">UINavigationController</code> class is a controller that provides hierarchical navigation <a id="id220" class="indexterm"/>functionality with <a id="id221" class="indexterm"/>multiple view controllers. Create a new iPhone <strong>Empty Project</strong> in Xamarin Studio and name it <code class="literal">NavigationControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec107"/>How to do it...</h2></div></div></div><p>Perform the following steps to create navigation among multiple view controllers:</p><div><ol class="orderedlist arabic"><li class="listitem">Add three new iPhone view controllers in the project and name them <code class="literal">MainController</code>, <code class="literal">ViewController1</code>, and <code class="literal">ViewController2</code>.</li><li class="listitem">Open the <code class="literal">AppDelegate.cs</code> file and add the following code in the <code class="literal">FinishedLaunching</code> method:<div><pre class="programlisting">MainController mainController = new MainController();
mainController.Title = "Main View";
UINavigationController navController = new UINavigationController(mainController);
window.RootViewController = navController;</pre></div></li><li class="listitem">Open <code class="literal">MainController.xib</code> in Interface Builder and add two buttons with their <a id="id222" class="indexterm"/>corresponding outlets. Set their titles to <code class="literal">First View</code> and <code class="literal">Second View</code>, respectively.</li><li class="listitem">Add <a id="id223" class="indexterm"/>the following code in the <code class="literal">ViewDidLoad</code> method of the <code class="literal">MainController</code> class:<div><pre class="programlisting">this.buttonFirstView.TouchUpInside += (sender, e) =&gt; {

        ViewController1 v1 = new ViewController1();
        v1.Title = "First View";
        this.NavigationController.PushViewController(v1, true);

      } ;
      this.buttonSecondView.TouchUpInside += (sender, e) =&gt; {

        ViewController2 v2 = new ViewController2();v2.Title = "Second View";
        this.NavigationController.PushViewController(v2, true);

        };</pre></div></li><li class="listitem">Add a button in each of the <code class="literal">ViewController1</code> and <code class="literal">ViewController2</code> controllers in Interface Builder with the title <code class="literal">Pop to root</code>. Then, add the following code in both of these controllers' <code class="literal">ViewDidLoad</code> methods:<div><pre class="programlisting">this.buttonPop.TouchUpInside += (sender, e) =&gt; {
  this.NavigationController.PopToRootViewController(true);
};</pre></div></li><li class="listitem">Run the app on the simulator. </li><li class="listitem">Click on the buttons and see how the user interface navigates from one controller to another.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec108"/>How it works...</h2></div></div></div><p>The <code class="literal">UINavigationController</code> class preserves a stack of controllers. The <code class="literal">UIViewController</code> class has a property named <code class="literal">NavigationController</code>. In normal situations, this property returns null. However, if the controller is pushed into a navigation controller's stack, it returns the instance of the navigation controller. In this case, all of our controllers' <code class="literal">NavigationController</code> property will return the instance of our navigation controller. So this way, at any point in the hierarchy of controllers, access to the <a id="id224" class="indexterm"/>navigation controller is <a id="id225" class="indexterm"/>provided. To push a view controller to the navigation stack, we call the <code class="literal">UINavigationController.PushViewController(UIViewController, bool)</code> method, using the following line of code:</p><div><pre class="programlisting">this.NavigationController.PushViewController (v1, true);</pre></div><p>Notice that the <code class="literal">MainController</code> class is the topmost or root controller in the navigation stack. A navigation controller must have at least one view controller that will act as its root controller. We can provide it upon initialization of the navigation controller, as follows:</p><div><pre class="programlisting">UINavigationController navController = new UINavigationController(mainController);</pre></div><p>To return to the root controller, we call the <code class="literal">PopToRootViewController(bool)</code> method inside the current controller, as follows:</p><div><pre class="programlisting">this.NavigationController.PopToRootViewController (true);</pre></div><p>The boolean parameters in both methods are used for animating the transition between the view controllers. Setting it to <code class="literal">false</code> will result in the controllers instantly snapping onto the screen, which in most cases does not provide a very good user experience.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec109"/>There's more...</h2></div></div></div><p>In this simple example, we provided backward navigation to the root controller with buttons. Notice that there is an arrow-shaped button at the top bar, as shown in the following screenshot:</p><div><img src="img/8924OT_03_01.jpg" alt="There's more..."/></div><p>This top bar is called the navigation bar and is of the <code class="literal">UINavigationBar</code> type. The arrow-shaped button is called the back button and is of the <code class="literal">UIBarButtonItem</code> type. The back button, when it <a id="id226" class="indexterm"/>exists, always navigates <a id="id227" class="indexterm"/>to the previous controller in the navigation stack. If the previous controller in the stack has its <code class="literal">Title</code> property set, the back button will display that title. If it does not have a title, the back button will be titled <code class="literal">Back</code>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec31"/>Managing navigation bar buttons</h3></div></div></div><p>To <a id="id228" class="indexterm"/>change, add, and hide the buttons of the navigation bar, we can use the following methods of our currently displayed view controller's <code class="literal">NavigationItem</code> property:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SetLeftBarButtonItem</code>: This method adds a custom button on the left-hand <a id="id229" class="indexterm"/>side of the navigation bar, replacing the default back button.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetRightBarButtonItem</code>: This method adds a custom button on the right-hand <a id="id230" class="indexterm"/>side of the navigation bar.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetHidesBackButton</code>: This <a id="id231" class="indexterm"/>method sets the visibility of the default back button.</li></ul></div><p>To remove or hide the custom buttons on the left or right-hand side of the navigation bar, call the appropriate methods passing null instead of a <code class="literal">UIBarButtonItem</code> object.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec110"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Modal view controllers</em> and <em>Using view controllers efficiently</em> recipes</li><li class="listitem" style="list-style-type: disc">The <em>Animating views</em> recipe in <a class="link" href="ch11.html" title="Chapter 11. Graphics and Animation">Chapter 11</a>, <em>Graphics and Animation</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Providing controllers in tabs</h1></div></div></div><p>In this<a id="id232" class="indexterm"/> recipe, we will learn how to display<a id="id233" class="indexterm"/> multiple view controllers in a tabbed interface.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec111"/>Getting ready</h2></div></div></div><p>The <code class="literal">UITabBarController</code> class provides a way to display different view controllers on the same hierarchy level divided into a tab-like interface. Create a new iPhone <strong>Empty Project</strong> in Xamarin Studio and name it <code class="literal">TabControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec112"/>How to do it…</h2></div></div></div><p>Perform <a id="id234" class="indexterm"/>the following steps to provide <a id="id235" class="indexterm"/>controllers in tabs:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two iPhone view controllers to the project. Name them <code class="literal">MainController</code> and <code class="literal">SettingsController</code>.</li><li class="listitem">Add the following code to the <code class="literal">ViewDidLoad</code> method of <code class="literal">MainController</code>:<div><pre class="programlisting">this.View.BackgroundColor = UIColor.Blue;</pre></div></li><li class="listitem">Add the following code to the <code class="literal">ViewDidLoad</code> method of <code class="literal">SettingsController</code>:<div><pre class="programlisting">this.View.BackgroundColor = UIColor.Yellow;</pre></div></li><li class="listitem">Add the following code to the <code class="literal">FinishedLaunching</code> method of the <code class="literal">AppDelegate</code> class:<div><pre class="programlisting">MainController mainController = new MainController();
SettingsController settingsController = new SettingsController();
UITabBarController tabController = new UITabBarController();
tabController.SetViewControllers(new UIViewController[] {
  mainController,
  settingsController
}, true);
tabController.TabBar.Items[0].Title = "Main";
tabController.TabBar.Items[1].Title = "Settings";
window.RootViewController = tabController;</pre></div></li><li class="listitem">Run the app on the simulator. Click on each of the tabs at the bottom. The interface should be similar to the following screenshot when <code class="literal">MainController</code> is selected:<div><img src="img/8924OT_03_02.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec113"/>How it works...</h2></div></div></div><p>The <code class="literal">UITabBarController</code> class displays one tab for each of the controllers it manages. That tab <a id="id236" class="indexterm"/>is of the <code class="literal">UITabBarItem</code> type that can<a id="id237" class="indexterm"/> accept both text and images. We set the controllers it will display through its <code class="literal">SetViewControllers</code> property, as follows:</p><div><pre class="programlisting">tabController.SetViewControllers(new UIViewController[] {
  mainController,
  settingsController
}, true);</pre></div><p>After we have added the controllers, we can access its tab bar items through the <code class="literal">TabBar</code> property. In this case, we set the tab's <code class="literal">Title</code> attribute:</p><div><pre class="programlisting">tabController.TabBar.Items[0].Title = "Main";</pre></div><p>Each <code class="literal">UIViewController</code> contains a <code class="literal">TabController</code> property. Similar to the <code class="literal">NavigationController</code> property, when the controller is part of a tab controller, the property will return the instance of that tab controller.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec114"/>There's more...</h2></div></div></div><p>The controller can accept as many controllers as we want but if we add six or more, four will be<a id="id238" class="indexterm"/> displayed with their tabs, while a <a id="id239" class="indexterm"/>fifth predefined <strong>More</strong> tab will represent all the remaining controllers. This is to keep the interface easily accessible to the user by keeping the tabs to a specific size suitable for human fingers. When we add more than six controllers in a tab bar controller interface, by default, the object provides an <strong>Edit</strong> button on top in the <strong>More</strong> tab that allows the user to rearrange the order of controllers. If we want to exclude some controllers from this functionality, we have to remove it from the <code class="literal">CustomizableViewControllers</code> array.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec32"/>Useful UITabBarController properties</h3></div></div></div><p>Some more useful properties of the <code class="literal">UITabBarController</code> class are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ViewControllers</code>: This is an array containing all the controllers that the tab controller <a id="id240" class="indexterm"/>holds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SelectedIndex</code>: This <a id="id241" class="indexterm"/>is the zero-based index of the selected tab. Setting this property to the desired index programmatically selects the corresponding controller.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SelectedViewController</code>: This<a id="id242" class="indexterm"/> is the currently selected controller.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec33"/>Determining tab selection</h3></div></div></div><p>To determine<a id="id243" class="indexterm"/> when the user has selected a tab on a tab controller, we can subscribe to its <code class="literal">ViewControllerSelected</code> event:</p><div><pre class="programlisting">tabController.ViewControllerSelected += (sender, e) =&gt; {
  // Do something with e.ViewController.
};</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec115"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using view controllers efficiently</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Modal view controllers</h1></div></div></div><p>In this recipe, we will discuss how to display view controllers modally.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec116"/>Getting ready</h2></div></div></div><p>A modal view controller<a id="id244" class="indexterm"/> is any controller that is presented<a id="id245" class="indexterm"/> above other views or controllers. The concept is similar to displaying a Windows Form as a dialog, which takes control of the interface and does not allow access to other windows of the application unless it is dismissed. Create a new iPhone <strong>Empty Project</strong> in Xamarin Studio and name it <code class="literal">ModalControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec117"/>How to do it…</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two view controllers to the project and name them <code class="literal">MainController</code> and <code class="literal">ModalController</code>.</li><li class="listitem">Open the <code class="literal">MainController.xib</code> file in Interface Builder and add a button on its view with the title <code class="literal">Present</code>. Create and connect the appropriate outlet for the button.</li><li class="listitem">In the <code class="literal">MainController</code> class, add the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.buttonPresent.TouchUpInside += async (s, e) =&gt; {
  ModalController modalController = new ModalController();
  await this.PresentViewControllerAsync(modalController, true);
};</pre></div></li><li class="listitem">Open the <code class="literal">ModalController.xib</code> file. Add a button on its view with the title <code class="literal">Dismiss</code> and create the appropriate outlet for it.</li><li class="listitem">Set its view background color to something other than white. Save the document and enter the following code in the <code class="literal">ViewDidLoad</code> method of <code class="literal">ModalController</code>:<div><pre class="programlisting">    
  this.buttonDismiss.TouchUpInside += async (s, e) =&gt; {
    await this.DismissViewControllerAsync (true);
  };</pre></div></li><li class="listitem">Finally, add code to display the main controller in the <code class="literal">FinishedLaunching</code> method:<div><pre class="programlisting">MainController mainController = new MainController();
window.RootViewController = mainController;</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click on the <strong>Present</strong> button and watch the modal controller present itself on top of the main controller. Click on the <strong>Dismiss</strong> button to hide it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec118"/>How it works...</h2></div></div></div><p>Each<a id="id246" class="indexterm"/> controller object has two methods that handle presenting <a id="id247" class="indexterm"/>and dismissing controllers modally. In our example, we call the <code class="literal">PresentViewControllerAsync(UIViewController, bool)</code> method to present a controller, as follows:</p><div><pre class="programlisting">this.buttonPresent.TouchUpInside += async (s, e) =&gt; {
  ModalController modal = new ModalController ();
  await this.PresentViewControllerAsync (modal, true);
};</pre></div><p>Its first parameter represents the controller we want to display modally, and the second parameter determines if we want the presentation to be animated. To dismiss the controller, we call its <code class="literal">DismissViewControllerAsync(bool)</code> method, as follows:</p><div><pre class="programlisting">await this.DismissViewControllerAsync (true);</pre></div><p>It accepts only one parameter that toggles the animation for the dismissal.</p><p>In this example, we use <code class="literal">async</code>/<code class="literal">await</code> and the methods with the <code class="literal">Async</code> suffix to present and dismiss a controller modally. These methods are included in Xamarin.iOS for convenience. We can also use <code class="literal">PresentViewController</code> and <code class="literal">DismissViewController</code>; both accept another parameter of the <code class="literal">NSAction</code> type that represents the callback of the completion. However, no need to get into all that "trouble", right?</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec119"/>There's more...</h2></div></div></div><p>We can define the transition style for a modal view controller presentation with the controller's <code class="literal">ModalTransitionStyle</code> property. Enter the following line of code before presenting the modal controller:</p><div><pre class="programlisting">modalController.ModalTransitionStyle = UIModalTransitionStyle.FlipHorizontal;</pre></div><p>The main controller will flip to present the modal controller, giving the impression it is attached behind it.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec34"/>Accessing a modal controller</h3></div></div></div><p>Each <a id="id248" class="indexterm"/>controller that presents another controller modally provides access to its "child" controller through the <code class="literal">ModalController</code> property. If you need to access the modal controller through this property, make sure to do it before the <a id="id249" class="indexterm"/>
<code class="literal">DismissViewControllerAsync</code> method is called.</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec01"/>How many modal controllers?</h4></div></div></div><p>In theory, we can present an unlimited number of modal controllers. Of course, there are two restrictions<a id="id250" class="indexterm"/> on this, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Memory is not unlimited</strong>: View controllers consume memory, so the more view controllers we present, the worst performance we get.</li><li class="listitem" style="list-style-type: disc"><strong>Bad user experience</strong>: Presenting many controllers modally might confuse the user.</li></ul></div><p>In general, it is advised to not present more than one consecutive controller modally.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec120"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Navigating through different view controllers</em> and <em>Providing controllers in tabs</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Creating a custom view controller</h1></div></div></div><p>In this recipe, we <a id="id251" class="indexterm"/>will learn how to create a subclass of <code class="literal">UIViewController</code> and use it to derive view controllers that were created in Interface Builder.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec121"/>Getting ready</h2></div></div></div><p>In this recipe, we will create a custom view controller that will act as a base controller, providing common functionality among its inheritors. Create a new iPhone <strong>Empty Project</strong> in Xamarin Studio and name it <code class="literal">CustomControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec122"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Right-click on the project in the <strong>Solution</strong> pad and go to <strong>Add</strong> | <strong>New File…</strong>.</li><li class="listitem">In the dialog that appears, navigate to <strong>General</strong> | <strong>Empty Class</strong>. Name the file <code class="literal">BaseController</code> and click on the <strong>New</strong> button.</li><li class="listitem">Open the <code class="literal">BaseController.cs</code> file that was just created and modify it to match the following code:<div><pre class="programlisting">using System;
using MonoTouch.UIKit;
using MonoTouch.Foundation;
using System.Drawing;

namespace CustomControllerApp {
public class BaseController : UIViewController {

  //Constructor
  public BaseController (string nibName, NSBundle bundle) : base(nibName, bundle) {}

  public override void TouchesMoved (NSSet touches, UIEventevt)
  {
    base.TouchesMoved (touches, evt);
    // Capture the position of touches
    UITouch touch = touches.AnyObject as UITouch;
    if (null != touch) {
      PointF locationInView = touch.LocationInView (this.View);
      Console.WriteLine ("Touch coordinates: {0}", locationInView);
  }
}</pre></div></li><li class="listitem">Now, add an iPhone view controller to the project and name it <code class="literal">DerivedController</code>. Change the class it inherits from <code class="literal">UIViewController</code> to <code class="literal">BaseController</code> in its class definition: <code class="literal">public partial class DerivedController : BaseController</code>.</li><li class="listitem">Set the <a id="id252" class="indexterm"/>derived controller to be the root view controller of the main window (in <code class="literal">AppDelegate.cs</code>):<div><pre class="programlisting">DerivedController derivedController = new DerivedController();
window.RootViewController = derivedController;</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click-and-drag the mouse pointer on the white surface and watch Xamarin Studio's application output pad displaying the current position of the pointer on the simulator's screen.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec123"/>How it works...</h2></div></div></div><p>What we have done here is that we have created a base controller class that can be used in multiple Xamarin.iOS projects. The functionality we have added to this controller is to respond to user touches. Any controller that inherits it will inherit the same functionality. The code we have added to create the <code class="literal">BaseController</code> class is fairly simple. To make this work, we have added the following constructor to the class:</p><div><pre class="programlisting">public BaseController (string nibName, NSBundle bundle) : base(nibName, bundle) {}</pre></div><p>This is the base constructor that will get called when we initialize the <code class="literal">DerivedController</code> class with the new keyword, <code class="literal">this.derivedController = new DerivedController();</code>, through our derived object's <code class="literal">DerivedController()</code> constructor. So, what this practically means is that we can normally use inheritance with controllers that are loaded from XIB files.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec124"/>There's more...</h2></div></div></div><p>We can <a id="id253" class="indexterm"/>also create base controllers from XIB files. However, if the XIB files contain outlets, we need to make sure to populate these outlets in our derived classes; otherwise, they will not be available in our derived controllers. For example, if we have an outlet for a button named <code class="literal">btnStart</code> in the base XIB file, we would have to create the following property in our derived class:</p><div><pre class="programlisting">[Outlet("btnStart")]
public UIButton BtnStart {
  get { return base.btnStart; }
  set { base.btnStart = value; }
}</pre></div><p>The <code class="literal">Outlet</code> attribute tells the runtime that the specific property is an outlet. Not only that, it also helps Xamarin Studio in creating the Xcode project when we are using the derived class in a XIB.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec125"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Loading a view with a view controller</em>, <em>Using view controllers efficiently</em>, and <em>UI flow design with storyboards recipes</em></li><li class="listitem" style="list-style-type: disc">The <em>Adding and customizing views</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. User Interface – Views">Chapter 2</a>, <em>User Interface – Views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Using view controllers efficiently</h1></div></div></div><p>iOS is very <a id="id254" class="indexterm"/>strict about memory usage. If an app uses too much memory, iOS will issue memory warnings. If we do not respond to these memory warnings accordingly by releasing resources that are not needed, it is very likely that iOS will terminate the app.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec126"/>Getting ready</h2></div></div></div><p>Let's see what we can do to avoid this situation. Create a new project in Xamarin Studio and name it <code class="literal">EfficientControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec127"/>How to do it…</h2></div></div></div><p>Perform <a id="id255" class="indexterm"/>the following steps to complete this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a view controller to the project and name it <code class="literal">MainController</code>.</li><li class="listitem">Enter the following code in the <code class="literal">DidReceiveMemoryWarning</code> method of the <code class="literal">MainController</code> class:<div><pre class="programlisting">Console.WriteLine("Main controller received memory warning!");</pre></div></li><li class="listitem">Make the controller the root view controller of the app in <code class="literal">AppDelegate.cs</code> as follows:<div><pre class="programlisting">MainController mainController = new MainController();
window.RootViewController = mainController;</pre></div></li><li class="listitem">Compile and run the app on the simulator.</li><li class="listitem">With iOS Simulator window active, navigate to <strong>Hardware</strong> | <strong>Simulate Memory Warning</strong> on the menu bar, as shown in the following screenshot:<div><img src="img/8924OT_03_03.jpg" alt="How to do it…"/></div></li><li class="listitem">Check the <strong>Application Output</strong> pad in Xamarin Studio. You should see an output <a id="id256" class="indexterm"/>similar to the following:<div><pre class="programlisting">2013-12-04 08:09:47.695 EfficientControllerApp[1383:80b] Received memory warning.
2013-12-04 08:09:47.709 EfficientControllerApp[1383:80b] Main controller received memory warning!</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec128"/>How it works...</h2></div></div></div><p>This project does not provide any useful functionality. Its main purpose is to show how to get notified on memory warnings issued by iOS.</p><p>When a memory warning is issued, the <code class="literal">DidReceiveMemoryWarning</code> method will be called on all instantiated view controllers that are currently in memory. When this method is called, we should make sure we release the resources that are not currently required. This way, we are making more memory available to the system.</p><p>iOS Simulator provides the option of simulating memory warnings so that we can test how our app will behave when memory is low. On a real device, we cannot force the system to issue memory warnings on demand. Note that although we can practically simulate an unlimited number of memory warnings on the simulator, the app will never be terminated. On the other hand, on the device, the app will be terminated after two or three memory warnings (the actual number varies according to memory usage), so we need to take this into account.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec129"/>There's more...</h2></div></div></div><p>View controllers<a id="id257" class="indexterm"/> are not the only object that can receive memory warnings. We can capture memory warning notifications by overriding the <code class="literal">UIApplicationDelegate.ReceiveMemoryWarning(UIApplication)</code> method inside the <code class="literal">AppDelegate</code> class, as follows:</p><div><pre class="programlisting">public override void ReceiveMemoryWarning(UIApplication application)
{  //...    }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec130"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a custom view controller</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Interface Builder</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <em>Development Tools</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>iPad view controllers</h1></div></div></div><p>All the controllers we have worked with so far can be used in both iPhone and iPad applications. There are, however, two controllers that are only available to the iPad. These are the <code class="literal">UISplitViewController</code> and <code class="literal">UIPopoverController</code> classes. In this recipe, we <a id="id258" class="indexterm"/>will create an iPad project that uses<a id="id259" class="indexterm"/> the <code class="literal">UISplitViewController</code> class.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec131"/>Getting ready</h2></div></div></div><p>Create a new iPad <strong>Empty Project</strong> and name it <code class="literal">SplitControllerApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec132"/>How to do it…</h2></div></div></div><p>Perform the following steps to complete this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two iPad view controllers to the project and name them <code class="literal">FirstController</code> and <code class="literal">SecondController</code>. Set the background colors of their views to different colors, for example, blue for <code class="literal">FirstController</code> and yellow for <code class="literal">SecondController</code>.</li><li class="listitem">Open <code class="literal">SecondController.xib</code> in Interface Builder and add <code class="literal">UIToolbar</code> close to the top of its view. Connect the toolbar to an outlet named <code class="literal">myToolbar</code>.</li><li class="listitem">By default, the properties that represent the outlets are created as private by Xamarin Studio. Add the following property in the <code class="literal">SecondController</code> class to <a id="id260" class="indexterm"/>expose the toolbar outlet:<div><pre class="programlisting">public UIToolbar MyToolbar {
  get { return this.myToolbar; }
}</pre></div></li><li class="listitem">Add <a id="id261" class="indexterm"/>the following class to the project:<div><pre class="programlisting">public class SplitControllerDelegate : UISplitViewControllerDelegate
  {
    public SplitControllerDelegate (SecondController controller)
    {  
      this.secondController = controller;
    }
    private SecondController secondController;
    public override void WillHideViewController (UISplitViewController svc, UIViewController aViewController, UIBarButtonItem barButtonItem, UIPopoverController pc)
    {
      barButtonItem.Title = "First";
      this.secondController.MyToolbar.SetItems (new UIBarButtonItem[] { barButtonItem }, true);
    }
    public override void WillShowViewController (UISplitViewController svc, UIViewController aViewController, UIBarButtonItem button)
    {
      this.secondController.MyToolbar.SetItems (new UIBarButtonItem[0], true);
    }
  }</pre></div></li><li class="listitem">Add the following code in the <code class="literal">FinishedLaunching</code> method of the <code class="literal">AppDelegate</code> class:<div><pre class="programlisting">FirstController firstController = new FirstController();
SecondController secondController = new SecondController();
UISplitViewController splitController = new UISplitViewController();
splitController.ViewControllers = new UIViewController[] {
    firstController,
    secondController
  };
  splitController.Delegate = new SplitControllerDelegate(secondController);
  window.RootViewController = splitController;</pre></div></li><li class="listitem">Compile and run the app on the simulator.</li><li class="listitem">Click on<a id="id262" class="indexterm"/> the <strong>First</strong> button on the <a id="id263" class="indexterm"/>toolbar. <code class="literal">FirstController</code> should slide in from the side. The result is similar to the following screenshot:<div><img src="img/8924OT_03_04.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec133"/>How it works...</h2></div></div></div><p>The <code class="literal">UISplitViewController</code> class helps to take full advantage of the iPad's larger screen. It provides a way of displaying two different views simultaneously on the same screen area. It does this by displaying one controller in fullscreen in the portrait orientation and a secondary controller whenever is needed, in a smaller size.</p><p>To provide access to both controllers in our project to the user, we have implemented a class that inherits from <code class="literal">UISplitViewControllerDelegate</code> and assigned it to our split controller inside the <code class="literal">FinishedLaunching</code> method. The <code class="literal">Delegate</code> object we created overrides two methods. In the first method, we assign a button to the toolbar, as follows:</p><div><pre class="programlisting">public override void WillHideViewController (UISplitViewController svc, UIViewController aViewController, UIBarButtonItem barButtonItem, UIPopoverController pc)
{
  barButtonItem.Title = "First";
  this.secondController.MyToolbar.SetItems (new UIBarButtonItem[] { barButtonItem }, true);
}</pre></div><p>The <code class="literal">WillHideViewController</code> method is executed whenever <code class="literal">UISplitViewController</code> changes orientation from landscape to portrait and its smaller controller<a id="id264" class="indexterm"/> is about to be hidden. So to display<a id="id265" class="indexterm"/> it, we provide a button on the fullscreen controller's toolbar. When we click on that button, the other controller will slide in from the side. When the orientation changes from portrait to landscape, the smaller controller appears beside the larger controller automatically. So, we no longer need the button on the toolbar; hence, we override the <code class="literal">WillShowViewController</code> method to remove it. We do this by assigning an empty <code class="literal">UIBarButtonItem[]</code> array, as follows:</p><div><pre class="programlisting">public override void WillShowViewController (UISplitViewController svc, UIViewController aViewController, UIBarButtonItem button)
{
  this.secondController.Toolbar.SetItems (new UIBarButtonItem[0], true);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec134"/>There's more...</h2></div></div></div><p>To rotate the simulator to (and from) the landscape orientation, press <em>Cmd</em> and the left arrow key (or the right arrow key) with the app running on iOS Simulator. The following screenshot shows iOS Simulator rotated in landscape orientation. No other action was taken to make both controllers appear at the same time, as the split controller handles this for us:</p><div><img src="img/8924OT_03_05.jpg" alt="There's more..."/></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec35"/>iPad-specific controller usage</h3></div></div></div><p>Although all <a id="id266" class="indexterm"/>other controllers are available to both the iPhone and iPad, an exception will occur if a <code class="literal">UISplitViewController</code> method is used in an app that runs on an iPhone.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec135"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Adjusting UI orientation</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Interacting with Device Hardware">Chapter 9</a>, <em>Interacting with Device Hardware</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>UI flow design with storyboards</h1></div></div></div><p>Back when iOS 5 was released, Apple introduced <strong>storyboards</strong>. A storyboard is a new type of <a id="id267" class="indexterm"/>user interface file that accepts multiple view controllers, but it also holds information about how all these controllers relate to each other in the hierarchy of an application. Storyboards are very helpful when designing the screens of an application, as they are more efficient than loading different controllers from individual XIB files; they also keep a group of view controllers together in a single file.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec136"/>Getting ready</h2></div></div></div><p>Create a new iPhone <strong>Empty Project</strong> in Xamarin Studio and name it <code class="literal">StoryboardApp</code>.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>Xamarin Studio includes a number of project templates for storyboard applications. We will, however, use an empty iPhone project because it will help us to better comprehend how storyboards work.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec137"/>How to do it...</h2></div></div></div><p>Here are the steps to complete this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two new C# classes (not view controllers) to the project and name them <code class="literal">FirstController</code> and <code class="literal">SecondController</code>.</li><li class="listitem">Derive <a id="id268" class="indexterm"/>both classes from <code class="literal">UIViewController</code> and decorate them with the <code class="literal">Register</code> attribute. Make sure that you pass a different name for each controller in the attribute, as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">FirstController</code> class:<div><pre class="programlisting">[Register("FirstController")]
public class FirstController : UIViewController
{ //..</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">SecondController</code> class:<div><pre class="programlisting">[Register("SecondController")]
public class SecondController : UIViewController
{ //..</pre></div></li></ul></div></li><li class="listitem">Add the <code class="literal">IntPtr</code> constructor of <code class="literal">UIViewController</code> in both classes:<div><pre class="programlisting">public FirstController(IntPtr handle) : base(handle)
{} </pre></div></li><li class="listitem">Add an <code class="literal">Empty iPhone Storyboard</code> file to the project and name it <code class="literal">MainStoryboard</code>.</li><li class="listitem">Open the <code class="literal">MainStoryboard.storyboard</code> file that was created in Interface Builder. Just like opening XIBs, double-click on the file in Xamarin Studio.</li><li class="listitem">Drag <code class="literal">UINavigationController</code> on the empty canvas. By default, Xcode adds a table view when adding navigation controllers. Select it and delete it by pressing the <em>Backspace</em> key; we only need the navigation controller.</li><li class="listitem">Add two <code class="literal">UIViewController</code> objects to the canvas. By selecting each view controller individually, set their <strong>Class</strong> field in the <strong>Identity Inspector</strong> window to the classes we created in the preceding steps. The following screenshot shows the <strong>Class</strong> field of the first controller set to <strong>FirstController</strong>:<div><img src="img/8924OT_03_06.jpg" alt="How to do it..."/></div></li><li class="listitem">We now need to connect the controllers. Just like adding an outlet, press <em>Ctrl</em> and drag <a id="id269" class="indexterm"/>from the navigation controller to <code class="literal">FirstController</code>. In the context menu that will appear when you release the button, select <strong>root view</strong>.</li><li class="listitem">Add <code class="literal">UIButton</code> on <code class="literal">FirstController</code>. Press <em>Ctrl</em> and drag from the button to <code class="literal">SecondController</code>. Select <strong>push</strong> in the context menu that will appear. No need to connect the button to an outlet.</li><li class="listitem">Back in Xamarin Studio, add the following code in the <code class="literal">FinishedLaunching</code> method:<div><pre class="programlisting">UIStoryboard storyboard = UIStoryboard.FromName("MainStoryboard", NSBundle.MainBundle);
UINavigationController navController = (UINavigationController)storyboard.InstantiateInitialViewController();
window.RootViewController = navController;</pre></div></li><li class="listitem">Compile and run the app on the simulator. Clicking on the button will push the second controller into display.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec138"/>How it works...</h2></div></div></div><p>As you see, we managed to create the user interface for the application with minimal code. Inside storyboard files, we need to connect each element with each other, according to how we want the screen hierarchy to appear. We first set <code class="literal">FirstController</code> as a root view controller to the navigation controller. Then, we assigned a relationship to the button with the <code class="literal">SecondController</code> class. So, when the button is clicked, the <code class="literal">SecondController</code> class will be pushed into the navigation controller's stack, just as if we were calling the <code class="literal">UINavigationController.PushViewController</code> method. This relationship is called <a id="id270" class="indexterm"/>
<strong>segue</strong>. In a storyboard file, we can individually select segues and set their properties. For example, we can set an identifier string or change its behavior from <strong>push</strong> to <strong>modal</strong>.</p><p>In the <code class="literal">FinishedLaunching</code> method, we first instantiate a <code class="literal">UIStoryboard</code> instance through<a id="id271" class="indexterm"/> the static <code class="literal">UIStoryboard.FromName</code> method, as follows:</p><div><pre class="programlisting">UIStoryboard storyboard = UIStoryboard.FromName("MainStoryboard", NSBundle.MainBundle);</pre></div><p>We then call the <code class="literal">InstantiateInitialViewController</code> method to get the initial controller of the storyboard, as follows. In this case, the initial controller is <code class="literal">UINavigationController</code>:</p><div><pre class="programlisting">UINavigationController navController = (UINavigationController)storyboard.InstantiateInitialViewController();</pre></div><p>Note that we need to cast the return value to the correct type of controller, as its return type is <code class="literal">NSObject</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec139"/>There's more...</h2></div></div></div><p>We can also initiate segues programmatically. To do this, we first need to select the segue in Xcode and set an identifier for it through the <strong>Attributes</strong> inspector tab. Then, we can trigger it through code by calling the <code class="literal">PerformSegue</code> method of the <code class="literal">UIViewController</code> instance it belongs to, as follows:</p><div><pre class="programlisting">this.PerformSegue("MyPushSegue", null);</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec36"/>Passing data</h3></div></div></div><p>With <a id="id272" class="indexterm"/>storyboards, the system is instantiating the view controllers we need. We can have access to the view controller that will be displayed through a segue by overriding the <code class="literal">PrepareForSegue</code> method on the controller that is the owner, or source of the segue, as follows:</p><div><pre class="programlisting">public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    if (segue.Identifier == "MyPushSegue")
    {
      SecondController secondController = 
        (SecondController)segue.DestinationViewController;
      // Create a public method or property in SecondController 
      // for passing data to it.
    }//end if
}</pre></div><p>As you can see, there is also a <code class="literal">UIStoryboardSegue</code> class which provides us with the necessary information.</p><p>The <code class="literal">PrepareForSegue</code> method is called after the involving view controllers have been instantiated<a id="id273" class="indexterm"/> and before the segue starts. So, by determining which segue triggered the preparation method through the <code class="literal">Identifier</code> property, we retrieve the controller that the segue will display through the <code class="literal">DestinationViewController</code> property.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>The <code class="literal">PrepareForSegue</code> method will be called regardless if the segue was triggered programmatically through the <code class="literal">PerformSegue</code> method or was just set to a button in the storyboard file.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec140"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Interface Builder</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <em>Development Tools</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Unwinding in storyboards</h1></div></div></div><p>Another very useful feature of storyboards is <strong>unwinding</strong>. Unwinding is a process similar to that of a segue, but instead of presenting the next view controller, it reverses to a previous view<a id="id274" class="indexterm"/> controller in a storyboard. The great thing about it is that it <a id="id275" class="indexterm"/>allows us to go back to any view controller, not just the one that is right before the current controller we are in. This recipe will show how to use unwinding.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec141"/>Getting ready</h2></div></div></div><p>For this recipe, we will need the project <code class="literal">StoryboardApp</code> we created in the previous recipe. Open it in Xamarin Studio.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec142"/>How to do it…</h2></div></div></div><p>Perform <a id="id276" class="indexterm"/>the following steps to implement unwinding:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new class to the project and name it <code class="literal">ModalController</code>.</li><li class="listitem">Make the class a custom view controller, similar to <code class="literal">FirstController</code> and <code class="literal">SecondController</code> in the project, as follows:<div><pre class="programlisting">[Register("ModalController")]
public class ModalController : UIViewController
{
  public ModalController (IntPtr handle) : base(handle)
  {
  }
}</pre></div></li><li class="listitem">Add the following method in the <code class="literal">FirstController</code> class:<div><pre class="programlisting">[Action("unwindFromModalController<code class="literal">:")]</code>
<code class="literal">public void UnwindFromModalController(</code>UIStoryboardSegue segue)
{
}</pre></div></li><li class="listitem">Open the <code class="literal">MainStoryboard.storyboard</code> file in Xcode and add another <code class="literal">UIViewController</code>. Set this controller's <strong>Class</strong> to <strong>ModalController</strong>.</li><li class="listitem">Add <strong>UIButton</strong> to <code class="literal">SecondController</code> and set its title to <code class="literal">Show modal</code>.</li><li class="listitem">Press <em>Ctrl</em> and <a id="id277" class="indexterm"/>drag from the button to <code class="literal">ModalController</code>. Set <a id="id278" class="indexterm"/>this segue to <strong>modal</strong>.</li><li class="listitem">Add another button, this time on <code class="literal">ModalController</code>. Set its title to <code class="literal">Unwind to first</code>.</li><li class="listitem">Press <em>Ctrl</em> and drag from the button to the <strong>Exit</strong> item on the controller's dock, as shown in the following screenshot:<div><img src="img/8924OT_03_07.jpg" alt="How to do it…"/></div></li><li class="listitem">Select <strong>unwindFromModalController</strong> in the context menu that will appear.</li><li class="listitem">Compile<a id="id279" class="indexterm"/> and run the app on the simulator. Flow<a id="id280" class="indexterm"/> through the screens until you reach the modal controller and click on the <strong>Unwind to first</strong> button. The user interface will flow back to the first controller.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec143"/>How it works…</h2></div></div></div><p>By using unwinding or <strong>unwind segues</strong>, we can get back to any controller in the hierarchy. The basic requirement is to add a method decorated with the <code class="literal">Action</code> attribute to the controller <a id="id281" class="indexterm"/>you want to unwind to, as follows:</p><div><pre class="programlisting">[Action("unwindFromModalController:")]
public void UnwindFromModalController(UIStoryboardSegue segue) {}</pre></div><p>The attribute <a id="id282" class="indexterm"/>will basically expose the method as an action to Xcode so that when the storyboard file is opened, we will be able to add the unwind segue. This is how the action <strong>unwindFromModalController</strong> appeared when we dragged to the <strong>Exit</strong> item. It doesn't matter if the action is inside another class Xcode is smart enough to search all classes in the storyboard.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>The <strong>Exit</strong> item in the dock of every view controller is responsible for creating unwind segues. It represents the exit of a view controller, which is determined by how the controller was displayed.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec144"/>There's more…</h2></div></div></div><p>We can have<a id="id283" class="indexterm"/> access to the controller that initiated the unwind segue through the <code class="literal">UIStoryboardSegue</code> object that is passed to the unwind action, as follows:</p><div><pre class="programlisting">//..
ModalControllermodalController = (ModalController)segue.SourceViewController;</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec37"/>Where is the unwind segue in the storyboard?</h3></div></div></div><p>When we <a id="id284" class="indexterm"/>create unwind segues, there is no apparent <a id="id285" class="indexterm"/>change in Xcode's appearance or an indication that we created something, like when we create segues. After creating the unwind, we can find it by expanding the document outline, as shown in the following screenshot:</p><div><img src="img/8924OT_03_08.jpg" alt="Where is the unwind segue in the storyboard?"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec145"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Navigating through different view controllers</em> and <em>Modal view controllers</em> recipes</li></ul></div></div></div></body></html>