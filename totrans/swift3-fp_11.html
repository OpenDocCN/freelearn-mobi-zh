<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Case Study &#x2013; Developing an iOS Application with the FP and OOP Paradigms"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Case Study – Developing an iOS Application with the FP and OOP Paradigms</h1></div></div></div><p>In the previous chapters, we covered a variety of concepts and techniques. We started with FP paradigms and explored related topics in detail. Also, in the previous chapter, we covered other paradigms such as OOP, FRP, and POP, and mixing them together. In this chapter, we will create a simple application using those paradigms.</p><p>Most of iOS applications need a backend to be able to provide advanced functionalities such as integration with other systems. In this chapter, we will create a simple backend with Swift that is going to be used as a Todo application rest API. Then, we will develop an iOS application that will leverage our backend and provide some essential functionality such as listing and updating Todo items coming from the backend. Also, iOS application will be able to create new Todo items. Our iOS application development will include FP, OOP, POP, and FRP paradigms.</p><p>This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Requirement specifications</li><li class="listitem" style="list-style-type: disc">High-level design</li><li class="listitem" style="list-style-type: disc">Backend development<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Environment configuration</li><li class="listitem" style="list-style-type: disc">Swift Package Manager</li><li class="listitem" style="list-style-type: disc">Vapor</li><li class="listitem" style="list-style-type: disc">Application development</li></ul></div></li><li class="listitem" style="list-style-type: disc">Frontend development<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CocoaPods dependency management configuration</li><li class="listitem" style="list-style-type: disc">Third-party libraries</li><li class="listitem" style="list-style-type: disc">Backend communication</li><li class="listitem" style="list-style-type: disc">JSON parsing and model mapping</li><li class="listitem" style="list-style-type: disc">State management</li><li class="listitem" style="list-style-type: disc">Listing items with a UITableView</li><li class="listitem" style="list-style-type: disc">Updating and creating items</li><li class="listitem" style="list-style-type: disc">Filtering items</li></ul></div></li></ul></div><div class="section" title="Requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Requirements</h1></div></div></div><p>This section presents the requirements for our case study. Since the focus of this book is not requirement engineering, we will define very simple requirements. This section does not present best practices for requirements engineering.</p><p>The requirements for the iOS application user are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Users should be able to list Todo items</li><li class="listitem" style="list-style-type: disc">Users should be able to see the details of each item</li><li class="listitem" style="list-style-type: disc">Users should be able to modify items</li><li class="listitem" style="list-style-type: disc">Users should be able to create a new item</li><li class="listitem" style="list-style-type: disc">Users should be able to filter items by their status</li></ul></div></div></div>
<div class="section" title="High-level design"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec90"/>High-level design</h1></div></div></div><p>This section explains the high-level design of the frontend and backend.</p><div class="section" title="Frontend"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec95"/>Frontend</h2></div></div></div><p>Application design follows a slightly different version of the <span class="strong"><strong>Model-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) pattern, with the addition of the <code class="literal">
Actions
</code>, <code class="literal">Store</code>, <code class="literal">State</code>, and <code class="literal">Communication</code> layers to simplify the controller layer of traditional iOS application MVC pattern. All application layers are explained in the following sections.</p><div class="section" title="Models"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec96"/>Models</h3></div></div></div><p>Plain old model structures. These models do not have any logic and only consist of properties. There are four types of models:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TodoRequest</strong></span>: This is a struct that is used in backend request calls and conforms to <code class="literal">RequestProtocol</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Todo</strong></span>: This is a struct that represents the Todo data, and uses the <span class="strong"><strong>Argo</strong></span> and <span class="strong"><strong>Curry</strong></span> libraries to decode the object from JSON</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TodoViewModel and TodosViewModel</strong></span>: These structs represent data and are used in views and shown to the user</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TodoLens</strong></span>: These lenses modify the Todo model</li></ul></div><p>All the aforementioned models are immutable value types.</p></div><div class="section" title="Views"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec97"/>Views</h3></div></div></div><p>We have two View subclasses: one to provide a custom <code class="literal">UITableViewCell</code> called <code class="literal">TodoTableViewCell</code> and a subclass of <code class="literal">UIView</code> named <code class="literal">FooterView</code>.</p><p>Both of these Views are subclasses of iOS SDK-provided classes. Besides these classes, we will have our <code class="literal">UIViewController</code> scenes in the storyboard.</p></div><div class="section" title="ViewController"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec98"/>ViewController</h3></div></div></div><p>
<code class="literal">ViewController</code> is a subclass of <code class="literal">UIViewController</code> or <code class="literal">UITableViewController</code>, and it connects views to logic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MasterViewController:</strong></span> This is a subclass of <code class="literal">UITableViewController</code> to present Todo items</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>DetailsViewController:</strong></span> This is a subclass of <code class="literal">UIViewController</code> to present details of each Todo item to the user</li></ul></div><p>To develop iOS applications, we have to rely on iOS SDK-provided classes such as <code class="literal">UIViewController</code> and <code class="literal">UITableViewController</code>. The <code class="literal">ViewController</code> and <code class="literal">UIView</code> subclasses are the only classes that will be used in this case study.</p></div><div class="section" title="State"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec99"/>State</h3></div></div></div><p>In iOS application development, we need to handle states. We use the Delta and ReactiveCocoa libraries to manage our <code class="literal">Todo</code> App's state.</p><p>Delta takes an App that has custom state management spread throughout all the <code class="literal">ViewControllers</code> and simplifies it by providing a simple interface to change state and subscribe to its changes.</p><p>ReactiveCocoa is a FRP cocoa framework that provides APIs for composing and transforming streams of values over time.</p><p>We will implement a <code class="literal">State</code> struct that will provide the <code class="literal">observable</code> properties.</p></div><div class="section" title="Store"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec100"/>Store</h3></div></div></div><p>Our <code class="literal">Store</code> struct will wrap the <code class="literal">State</code> struct and provide properties to observe its changes. <code class="literal">Store</code> conforms to the Delta library's <code class="literal">StoreType</code> protocol, which defines the storage of an observable state and dispatch methods to modify it. Also, <code class="literal">Store</code> uses ReactiveCocoa's <code class="literal">MutableProperty</code> value and allows observation of its changes in a thread-safe manner.</p></div><div class="section" title="Actions"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec101"/>Actions</h3></div></div></div><p>Actions are structs that conform to the <code class="literal">ActionType</code> protocol from the Delta library. <code class="literal">ActionType</code> is used when we want to make modifications to the store's state. All changes to the store go through this type.</p><p>We will develop the following actions in the application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ClearCompletedTodosAction</code>: This is used to delete completed Todo items from the list</li><li class="listitem" style="list-style-type: disc"><code class="literal">CreateTodoAction</code>: This is used to create a new Todo item</li><li class="listitem" style="list-style-type: disc"><code class="literal">DeleteTodoAction</code>: This is used to delete a Todo item</li><li class="listitem" style="list-style-type: disc"><code class="literal">DetailsTodoAction</code>: This is used to present the details of an item</li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadTodosAction</code>: This is used to list all Todo items</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetFilterAction</code>: This is used to filter Todo items</li><li class="listitem" style="list-style-type: disc"><code class="literal">ToggleCompletedAction</code>: This is used to mark a Todo item as completed</li><li class="listitem" style="list-style-type: disc"><code class="literal">UpdateTodoAction</code>: This is used to update a Todo item</li></ul></div></div><div class="section" title="Manager"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec102"/>Manager</h3></div></div></div><p>
<code class="literal">TodoManager</code> provides global functions to handle backend API calls and JSON payload mapping. <code class="literal">TodoManager</code> uses <code class="literal">WebServiceManager</code> for backend calls and the Argo library to map JSON payloads to the <code class="literal">Todo</code> model. Also, <code class="literal">TodoManager</code> will update the <code class="literal">State</code> in the <code class="literal">Store</code> through <code class="literal">Lenses</code> and <code class="literal">Action</code>.</p></div><div class="section" title="Communication"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec103"/>Communication</h3></div></div></div><p>The communication layer is responsible for backend communication. It includes the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">WebServiceManager</code>: This provides a global function named <code class="literal">sendRequest</code> that is used by <code class="literal">TodoManager</code> to call the backend API. Also, it uses <code class="literal">configureHeaders</code> to perform a reflection on request to get its properties and respective values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Urls</code>: This enum provides a proper HTTP request method and a full URL address by pattern matching and extension.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Alamofire</code>: This is a library that is used by <code class="literal">WebServiceManager</code> for HTTP request handling.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Argo</code>: This library maps model objects from and to JSON functionally.</li></ul></div></div><div class="section" title="Communication between layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec104"/>Communication between layers</h3></div></div></div><p>Application uses closures and <code class="literal">ReactiveCocoa</code> signals for communication between layers.</p></div><div class="section" title="Third-party libraries"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec105"/>Third-party libraries</h3></div></div></div><p>The following third-party libraries/frameworks are used in our iOS application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Alamofire</strong></span>: This is a web service calling and management framework</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Argo</strong></span>: This is a functional JSON parsing library</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CocoaPods</strong></span>: This is responsible for dependency management</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Delta</strong></span>: This is the state management library</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ReactiveCocoa</strong></span>: This is a <span class="strong"><strong>Functional Reactive Programming</strong></span> (<span class="strong"><strong>FRP</strong></span>) library to handle signals and streams</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Quick</strong></span>: This is a behavior-driven development framework used for unit testing</li></ul></div></div><div class="section" title="Cross-cutting concerns"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec106"/>Cross-cutting concerns</h3></div></div></div><p>This section explains cross-cutting concerns such as error management, exception handling, and so on.</p><div class="section" title="Error management and exception handling"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec33"/>Error management and exception handling</h4></div></div></div><p>As discussed in previous chapters of this book.</p></div><div class="section" title="Crash reporting"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec34"/>Crash reporting</h4></div></div></div><p>We will use <span class="strong"><strong>Crashlytics</strong></span>, which is a part of <code class="literal">fabric.io</code> offering by Twitter.</p></div><div class="section" title="Analytics"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec35"/>Analytics</h4></div></div></div><p>We will use <code class="literal">fabric.io</code>
<span class="strong"><strong>Answers</strong></span> to monitor application usage. There are other analytics services such as <span class="strong"><strong>Google Analytics</strong></span>, <span class="strong"><strong>Flurry</strong></span>, and Mixpanel that can be used for this case study. We are going to use Answers for the sake of simplicity.</p></div></div><div class="section" title="Tools"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec107"/>Tools</h3></div></div></div><p>Tools We will use Xcode to develop our application. AppCode by JetBrains is another IDE for iOS application development with better refactoring capabilities that can be used for this case study.</p></div></div><div class="section" title="Backend"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec96"/>Backend</h2></div></div></div><p>There are various web framework and HTTP servers for Swift, which are works-in-progress. <span class="strong"><strong>Kitura</strong></span>, <span class="strong"><strong>Perfect</strong></span>, and Vapor are three of the most popular ones. None of them are designed and developed in FP style. We will use Vapor in our example to provide a backend that can be leveraged by our frontend application.</p><div class="section" title="Vapor"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec108"/>Vapor</h3></div></div></div><p>Vapor (<a class="ulink" href="https://github.com/qutheory/vapor">https://github.com/qutheory/vapor</a>) is a popular Laravel/Lumen-inspired web framework that is MIT-licensed. It is purely written in Swift and is modular.</p><p>Vapor provides CLI tools to simplify building and running Vapor applications.</p><p>
<code class="literal">vapor new &lt;project-name&gt;</code> can be used to create a new project, <code class="literal">vapor build</code> can be used to build the project and download dependencies, <code class="literal">vapor xcode</code> can be used to create Xcode project, and <code class="literal">vapor run</code> can be used to run the project.</p><p>Vapor uses <span class="strong"><strong>Swift Package Manager</strong></span> (<span class="strong"><strong>SPM</strong></span>) as the dependency manager and starting an application with Vapor is as easy as importing Vapor and adding the following lines to the <code class="literal">main</code> file:</p><pre class="programlisting">let app = Application()&#13;
app.start(port: 8080)&#13;
</pre><div class="section" title="Routing"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec36"/>Routing</h4></div></div></div><p>Routing in Vapor is simple:</p><pre class="programlisting">app.get("welcome") { request in&#13;
    return "Hello, World"&#13;
}&#13;
</pre><p>Adding the preceding code to the main file will make our web application respond to all <code class="literal">GET</code> requests to <code class="literal">localhost:8080/welcome</code> with the string <code class="literal">Hello, World</code>.</p></div><div class="section" title="JSON"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec37"/>JSON</h4></div></div></div><p>It is easy to respond with JSON:</p><pre class="programlisting">app.get("version") { request in&#13;
    return Json(["version": "0.1"])&#13;
}&#13;
</pre><p>The preceding code responds to all <code class="literal">GET</code> requests to <code class="literal">localhost:8080/version</code> with the JSON dictionary <code class="literal">{"version": "0.1"}</code> and <code class="literal">Content-Type: application/json</code>.</p></div><div class="section" title="Requesting data"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec38"/>Requesting data</h4></div></div></div><p>Every route call gets passed a <code class="literal">request</code> object that can be used to grab query and path parameters.</p><p>The following example shows how to access JSON, Query, and form-encoded data from the request:</p><pre class="programlisting">app.post("hello") { request in&#13;
    guard let name = request.data["name"]?.string else {&#13;
        return "Please include a name"&#13;
    }&#13;
&#13;
    return "Hello, \(name)!"&#13;
}&#13;
</pre><p>In this example, we read the request data and return a string.</p><p>Vapor also provides the means for session management, database connection, and view responses with HTML or Stencil template-included HTML pages. There is an example Vapor project (<a class="ulink" href="https://github.com/qutheory/vapor-example">https://github.com/qutheory/vapor-example</a>) that can be used and modified for our purposes. We are not going to explore Vapor in depth since it is still in a work-in-progress.</p></div></div><div class="section" title="SPM"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec109"/>SPM</h3></div></div></div><p>SPM is an open source build and dependency management tool provided for Swift 3.0. It is integrated with the Swift build system to automate the process of downloading, compiling, and linking dependencies.</p><p>Vapor uses SPM and to create a Vapor project we need to add the following dependency to the <code class="literal">Packages.swift</code> file:</p><pre class="programlisting">.Package(url: "https://github.com/qutheory/vapor.git",&#13;
  majorVersion: xx, minor: x),&#13;
.Package(url: "https://github.com/qutheory/vapor-zewo-mustache.git",&#13;
  majorVersion: xx, minor: xx)</pre><p>As stated in the <span class="emphasis"><em>Vapor</em></span> section, we can use Vapor CLI tools to build and run the application with SPM.</p><p>It is recommended to read more about Vapor and SPM since we do not cover most of the related topics in this book. In the following section, we will develop a very simple backend with Vapor.</p></div></div></div>
<div class="section" title="Backend development"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec91"/>Backend development</h1></div></div></div><p>We want to develop a very simple backend for a Todo application.</p><div class="section" title="Model"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec97"/>Model</h2></div></div></div><p>We will start by creating our model. The code is as follows:</p><pre class="programlisting">import Vapor&#13;
&#13;
final class Todo {&#13;
    var id: Int&#13;
    var name: String&#13;
    var description: String&#13;
    var notes: String&#13;
    var completed: Bool&#13;
    var synced: Bool&#13;
 &#13;
    init(id: Int, name: String, description: String, notes: String,&#13;
      completed: Bool, synced: Bool) {&#13;
        self.id = id&#13;
        self.name = name&#13;
        self.description = description&#13;
        self.notes = notes&#13;
        self.completed = completed&#13;
        self.synced = synced&#13;
    }&#13;
}&#13;
</pre><p>This class imports Vapor and includes some of the <code class="literal">Todo</code>-related properties as well as an <code class="literal">init</code> method.</p><p>To be able to pass this model into JSON arrays and dictionaries, we need to extend a protocol called <code class="literal">JsonRepresentable</code>:</p><pre class="programlisting">extension Todo: JSONRepresentable {&#13;
    func makeJson() -&gt; JSON {&#13;
 &#13;
        return JSON([&#13;
            "id":id,&#13;
          "name": "\(name)",&#13;
   "description": "\(description)",&#13;
         "notes": "\(notes)",&#13;
     "completed": completed,&#13;
        "synced": synced&#13;
        ])&#13;
    }&#13;
}&#13;
</pre></div><div class="section" title="Store"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec98"/>Store</h2></div></div></div><p>Then we want to store list of Todo items in memory. To be able to achieve this, we will create a new class called <code class="literal">TodoStore</code>. The code is as follows:</p><pre class="programlisting">import Vapor&#13;
&#13;
final class TodoStore {&#13;
 &#13;
    static let sharedInstance = TodoStore()&#13;
    private var list: [Todo] = Array&lt;Todo&gt;()&#13;
    private init() {&#13;
    }&#13;
}&#13;
</pre><p>For the sake of simplicity, we make this class a singleton that stores a list of Todo items. Also, we make the <code class="literal">init</code> method <code class="literal">private</code> to avoid non-shared instance initiation.</p><p>To allow instances of Todo to be passed into JSON arrays and dictionaries as if it were a native JSON type, we will need to extend our <code class="literal">TodoStore</code> by conforming to <code class="literal">JSONRepresentable</code> as follows:</p><pre class="programlisting">extension TodoStore: JSONRepresentable {&#13;
    func makeJson() -&gt; JSON {&#13;
        return JSON([&#13;
            "list": "\(list)"&#13;
        ])&#13;
    }&#13;
}</pre><p>Next, we add the following methods:</p><pre class="programlisting">func addtem(item: Todo) {&#13;
    self.list.append(item)&#13;
}&#13;
 &#13;
func listItems() -&gt; [Todo] {&#13;
    return self.list&#13;
}&#13;
</pre><p>As the names suggest, these methods will be used for adding and listing items. We will need a very simple find method, so let's develop it:</p><pre class="programlisting">func find(id: Int) -&gt; Todo? {&#13;
    return self.list.index { $0.id == id }.map { self.list[$0] }&#13;
}&#13;
</pre><p>Here, we use <code class="literal">index</code> and <code class="literal">map</code> higher-order functions to find the index and return the respective array element.</p><p>Then, we will need to develop <code class="literal">update</code> and <code class="literal">delete</code> methods:</p><pre class="programlisting">func delete(id: Int) -&gt; String {&#13;
    if self.find(id: id) != nil {&#13;
        self.list = self.list.filter { $0.id != id }&#13;
        return "Item is deleted"&#13;
    }&#13;
    return "Item not found"&#13;
}&#13;
&#13;
func deleteAll() -&gt; String {&#13;
    if self.list.count &gt; 0 {&#13;
        self.list.removeAll()&#13;
        return "All items were deleted"&#13;
    }&#13;
    return "List was empty"&#13;
&#13;
}&#13;
&#13;
func update(item: Todo) -&gt; String {&#13;
    if let index = (self.list.index { $0.id == item.id }) {&#13;
        self.list[index] = item&#13;
        return "item is up to date"&#13;
    }&#13;
    return "item not found"&#13;
}&#13;
</pre><p>Also, we can combine add and update as follows:</p><pre class="programlisting">func addOrUpdateItem(item: Todo) {&#13;
    if self.find(item.id) != nil {&#13;
        update(item)&#13;
    } else {&#13;
        self.list.append(item)&#13;
    }&#13;
}&#13;
</pre><p>At this point, our <code class="literal">TodoStore</code> is capable of all CRUD operations.</p></div><div class="section" title="Controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec99"/>Controller</h2></div></div></div><p>The next step will be developing routing, request, and response handling. For the sake of simplicity, we will modify <code class="literal">main.swift</code> in the Vapor example.</p><p>We will need to make our changes after the following definition:</p><pre class="programlisting">let app = Application()&#13;
</pre><div class="section" title="Posting a new Todo item"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec110"/>Posting a new Todo item</h3></div></div></div><p>The first step will be to develop a post method to create a Todo item as follows:</p><pre class="programlisting">/// Post a todo item&#13;
app.post("postTodo") { request in&#13;
    guard let id = request.headers.headers["id"]?.values,&#13;
        name = request.headers.headers["name"]?.values,&#13;
        description = request.headers.headers["description"]?.values,&#13;
        notes = request.headers.headers["notes"]?.values,&#13;
        completed = request.headers.headers["completed"]?.values,&#13;
        synced = request.headers.headers["synced"]?.values&#13;
    else {&#13;
        return JSON(["message": "Please include mandatory parameters"])&#13;
    }&#13;
 &#13;
    let todoItem = Todo(id: Int(id[0])!,&#13;
                      name: name[0],&#13;
               description: description[0],&#13;
                     notes: notes[0],&#13;
                 completed: completed[0].toBool()!,&#13;
                    synced: synced[0].toBool()!)&#13;
&#13;
    let todos = TodoStore.sharedInstance&#13;
    todos.addOrUpdateItem(item: todoItem)&#13;
 &#13;
    let json:[JSONRepresentable] = todos.listItems().map { $0 }&#13;
    return JSON(json)&#13;
}&#13;
</pre><p>The preceding example is going to create a Todo item. First, we check if the API user is provided with all the necessary HTTP headers with a guard expression and then we use our <code class="literal">addItem()</code> method in the <code class="literal">TodoStore</code> class to add that specific item. In the preceding code example, we needed to convert <code class="literal">completed</code> from <code class="literal">Bool</code> to <code class="literal">String</code>, so we extended the <code class="literal">String</code> function as follows and we called <code class="literal">toBool()</code> on <code class="literal">completed</code>:</p><pre class="programlisting">extension String {&#13;
    func toBool() -&gt; Bool? {&#13;
        switch self {&#13;
        case "True", "true", "yes", "1":&#13;
            return true&#13;
        case "False", "false", "no", "0":&#13;
            return false&#13;
        default:&#13;
            return nil&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>We will need to build and run our backend app with the <code class="literal">vapor build</code> and <code class="literal">vapor run</code> directives in the terminal application. At this point, we should get the following prompt:</p><p>
</p><div class="mediaobject"><img alt="Posting a new Todo item" src="graphics/image_11_001.jpg"/></div><p>
</p><p>If we point to localhost 8080 in a web browser, we should see Vapor up and running. Also, we can use the <span class="strong"><strong>curl</strong></span> tool to test our post method in the terminal by copying and pasting the following code:</p><pre class="programlisting">curl -X "POST" "http://localhost:8080/postTodo/" \&#13;
   -H "Cookie: test=123" \&#13;
   -H "id: 3" \&#13;
   -H "notes: do not forget to buy potato chips" \&#13;
   -H "Content-Type: application/json" \&#13;
   -H "description: Our first todo item" \&#13;
   -H "completed: false" \&#13;
   -H "name: todo 1" \&#13;
   -d "{}"&#13;
</pre><p>The result will resemble the following:</p><p>
</p><div class="mediaobject"><img alt="Posting a new Todo item" src="graphics/image_11_002.jpg"/></div><p>
</p><p>As we can see from the screenshot, we received a JSON response that includes our added Todo item.</p></div><div class="section" title="Getting a list of Todo items"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec111"/>Getting a list of Todo items</h3></div></div></div><p>Our post call returns the list of items. Also, we can get items with this:</p><pre class="programlisting">/// List todo items&#13;
app.get("todos") { request in&#13;
 &#13;
    let todos = TodoStore.sharedInstance&#13;
    let json:[JSONRepresentable] = todos.listItems().map { $0 }&#13;
    return JSON(json)&#13;
}&#13;
</pre><p>We will build and run our application with Vapor CLI again and we can test this get request like this:</p><pre class="programlisting">curl -X "GET" "http://localhost:8080/todos" \&#13;
   -H "Cookie: test=123"&#13;
</pre></div><div class="section" title="Getting a specific Todo item"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec112"/>Getting a specific Todo item</h3></div></div></div><p>The preceding call retrieves all the items. If we want to get a specific item, we can do that too:</p><pre class="programlisting">/// Get a specific todo item&#13;
app.get("todo") { request in&#13;
&#13;
    guard let id = request.headers.headers["id"]?.values else {&#13;
        return JSON(["message": "Please provide the id of todo item"])&#13;
    }&#13;
&#13;
    let todos = TodoStore.sharedInstance.listItems()&#13;
    var json = [JSONRepresentable]()&#13;
&#13;
    let item = todos.filter { $0.id == Int(id[0])! }&#13;
    if item.count &gt; 0 {&#13;
        json.append(item[0])&#13;
    }&#13;
 &#13;
    return JSON(json)&#13;
}&#13;
</pre><p>Here, we check for the existence of headers and use the <code class="literal">listItems()</code> method in our <code class="literal">TodoStore</code> class to retrieve that specific item. We can test it in curl by executing the following commands in the terminal:</p><pre class="programlisting">curl -X "GET" "http://localhost:8080/todo/" \&#13;
   -H "id: 1" \&#13;
   -H "Cookie: test=123"&#13;
</pre></div><div class="section" title="Deleting an item and deleting all Todo items"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec113"/>Deleting an item and deleting all Todo items</h3></div></div></div><p>The next operation that we need to implement is deleting items from our <code class="literal">TodoStore</code>. Let's implement the <code class="literal">delete</code> and <code class="literal">deleteAll</code> methods:</p><pre class="programlisting">/// Delete a specific todo item&#13;
app.delete("deleteTodo") { request in&#13;
    guard let id = request.headers.headers["id"]?.values else {&#13;
        return JSON(["message": "Please provide the id of todo item"])&#13;
    }&#13;
 &#13;
    let todos = TodoStore.sharedInstance&#13;
    todos.delete(id: Int(id[0])!)&#13;
&#13;
    return JSON(["message": "Item is deleted"])&#13;
}&#13;
&#13;
/// Delete all items&#13;
app.delete("deleteAll") { request in&#13;
    TodoStore.sharedInstance.deleteAll()&#13;
 &#13;
    return JSON(["message": "All items are deleted"])&#13;
}&#13;
</pre><p>To test the delete functionality, we can execute the following commands in the terminal:</p><pre class="programlisting">curl -X "DELETE" "http://localhost:8080/deleteTodo/" \&#13;
   -H "id: 1" \&#13;
   -H "Cookie: test=123"&#13;
</pre><p>To test the <code class="literal">deleteAll</code> functionality, we can execute the following commands in the terminal:</p><pre class="programlisting">curl -X "DELETE" "http://localhost:8080/deleteAll" \&#13;
   -H "Cookie: test=123"&#13;
</pre></div><div class="section" title="Updating a Todo item"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec114"/>Updating a Todo item</h3></div></div></div><p>Finally, we want to be able to update an item in our Todo list to complete it or take some notes:</p><pre class="programlisting">/// Update a specific todo item&#13;
app.post("updateTodo") { request in&#13;
    guard let id = request.headers.headers["id"]?.values,&#13;
        name = request.headers.headers["name"]?.values,&#13;
        description = request.headers.headers["description"]?.values,&#13;
        notes = request.headers.headers["notes"]?.values,&#13;
        completed = request.headers.headers["completed"]?.values,&#13;
        synced = request.headers.headers["synced"]?.values&#13;
    else {&#13;
        return JSON(["message": "Please include mandatory parameters"])&#13;
    }&#13;
 &#13;
    let todoItem = Todo(id: Int(id[0])!,&#13;
                      name: name[0],&#13;
               description: description[0],&#13;
                     notes: notes[0],&#13;
                 completed: completed[0].toBool()!,&#13;
                    synced: synced[0].toBool()!)&#13;
 &#13;
    let todos = TodoStore.sharedInstance&#13;
    todos.update(item: todoItem)&#13;
    return JSON(["message": "Item is updated"])&#13;
}&#13;
</pre><p>Here, we check for the headers first and, if they are present, we use the update method in <code class="literal">TodoStore</code> to update a specific item in our store. We can test it like this:</p><pre class="programlisting">curl -X "POST" "http://localhost:8080/updateTodo" \&#13;
   -H "Cookie: test=123" \&#13;
   -H "id: 3" \&#13;
   -H "notes: new note" \&#13;
   -H "name: updated name" \&#13;
   -H "description: updated description" \&#13;
   -H "completed : yes"&#13;
</pre><p>At this point, we should have a simple backend API to create, list, update, and delete todo items in memory. In the next section, we will develop an iOS application to leverage this API.</p></div></div></div>
<div class="section" title="iOS application development"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec92"/>iOS application development</h1></div></div></div><p>So far, we looked into requirements, discussed a high-level design, and developed a simple backend API. Now, we are going to develop an iOS application that will leverage the latter.</p><div class="section" title="Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec100"/>Configuration</h2></div></div></div><p>We will start our application development using CocoaPods (<a class="ulink" href="https://cocoapods.org/">https://cocoapods.org/</a>). We can install it by executing the following command in the terminal:</p><pre class="programlisting">sudo gem install cocoapods&#13;
</pre><p>Then, we will create a folder using <span class="strong"><strong>Finder</strong></span> or simply execute the following command in the terminal:</p><pre class="programlisting">mkdir Frontend&#13;
</pre><p>Next, we will create a <span class="strong"><strong>Single View Application</strong></span> project in Xcode:</p><p>
</p><div class="mediaobject"><img alt="Configuration" src="graphics/image_11_003.jpg"/></div><p>
</p><p>We are going to name it <code class="literal">TodoApp</code> and provide an organization name and identifier. The programming language is going to be <span class="strong"><strong>Swift</strong></span>, and <span class="strong"><strong>Devices</strong></span> will be <span class="strong"><strong>Universal</strong></span>. Now, we can close the project and go back to the terminal.</p><p>In the terminal, we will execute the following code:</p><pre class="programlisting">cd Frontend/TodoApp&#13;
pod init&#13;
</pre><p>This will create a file named <code class="literal">Podfile</code>. This is where we define our dependencies.</p><p>Uncomment the first and third line so it becomes like this:</p><pre class="programlisting">platform :ios, '8.0'&#13;
use_frameworks!&#13;
&#13;
target 'TodoApp' do&#13;
&#13;
end&#13;
</pre><p>Now, we need to define dependencies for our target. We can go to <a class="ulink" href="https://cocoapods.org/">https://cocoapods.org/</a> and search for any dependency, copy the definition, and paste it into our <code class="literal">Podfile</code>:</p><pre class="programlisting">platform :ios, '8.0'&#13;
use_frameworks!&#13;
&#13;
target 'TodoApp' do&#13;
    pod 'Alamofire'&#13;
    pod 'Argo'&#13;
    pod 'Curry'&#13;
    pod 'ReactiveCocoa'&#13;
    pod 'Delta', :git =&gt; "https://github.com/thoughtbot/Delta.git"&#13;
end&#13;
</pre><p>Now, we can save and close our <code class="literal">Podfile</code> and move on to the terminal application. In the terminal application, we will execute the following command:</p><pre class="programlisting">Pod install&#13;
</pre><p>This directive will create a workspace, download all dependencies, and link them as frameworks into our project. Now, we can open <code class="literal">TodoApp.xcworkspace</code> with Xcode.</p><p>In the workspace, we will see two projects: <code class="literal">TodoApp</code> and <code class="literal">Pods</code>. Pods will contain all the dependencies.</p><p>Next, let's create a folder hierarchy to organize our workspace. In the workspace, right-click on a folder and select <span class="strong"><strong>Show In Finder</strong></span>. Here, we will create the following folders and files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Actions</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Communication</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Controllers</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Extensions</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Managers</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Models</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Resources</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">State</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Views</code></li></ul></div><p>Next, we will add these folders to our project by right-clicking on the <code class="literal">TodoApp</code> folder and selecting <span class="strong"><strong>Add Files to "TodoApp"</strong></span>, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img alt="Configuration" src="graphics/image_11_004.jpg"/></div><p>
</p><p>At this point, we can move <code class="literal">ViewController</code> to <code class="literal">Controllers</code> and any images to the <code class="literal">Resources</code> folder.</p><p>When we are done with our application, the folder and file hierarchy will be as follows:</p><p>
</p><div class="mediaobject"><img alt="Configuration" src="graphics/image_11_005.jpg"/></div><p>
</p><p>Since our backend does not comply with security policies enforced by Apple, we will need to set the <code class="literal">NSAllowsArbitraryLoads</code> key to <code class="literal">YES</code> under the <code class="literal">NSAppTransportSecurity</code> dictionary in our <code class="literal">.plist</code> file.</p></div><div class="section" title="Models"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec101"/>Models</h2></div></div></div><p>Obviously, we can use the <code class="literal">Todo</code> model we have used in our backend example, but we want to make our frontend application as functional as possible. There is a great functional JSON parsing library named Argo that we can leverage. Let's define our <code class="literal">Todo</code> model with Argo:</p><pre class="programlisting">import Argo&#13;
import Curry&#13;
&#13;
enum TodoFilter: Int {&#13;
    case all&#13;
    case active&#13;
    case completed&#13;
    case notSyncedWithBackend&#13;
    case selected&#13;
}&#13;
&#13;
struct Todo {&#13;
    let id: Int&#13;
    let name: String&#13;
    let description: String&#13;
    let notes: String?&#13;
    let completed: Bool&#13;
    let synced: Bool&#13;
    let selected: Bool?&#13;
}&#13;
&#13;
extension Todo: Decodable {&#13;
    static func decode(json: JSON) -&gt; Decoded&lt;Todo&gt; {&#13;
        return curry(Todo.init)&#13;
        &lt;^&gt; json &lt;| "id"&#13;
        &lt;*&gt; json &lt;| "name"&#13;
        &lt;*&gt; json &lt;| "description"&#13;
        &lt;*&gt; json &lt;|? "notes"&#13;
        &lt;*&gt; json &lt;| "completed"&#13;
        &lt;*&gt; json &lt;| "synced"&#13;
        &lt;*&gt; json &lt;|? "selected"&#13;
    }&#13;
}&#13;
&#13;
extension Todo: Equatable {}&#13;
&#13;
func == (lhs: Todo, rhs: Todo) -&gt; Bool {&#13;
    return lhs.id == rhs.id&#13;
}&#13;
</pre><p>First of all, we import two libraries: Argo and Curry. Curry provides convenient currying functionalities. Although currying is going to be removed from Swift and returning closures will be the norm, it will be safe to use the Curry library.</p><p>Our <code class="literal">Todo</code> model becomes a <code class="literal">struct</code>, and then we extend our <code class="literal">struct</code> by conforming to a <code class="literal">protocol</code> named <code class="literal">Decodable</code>. To conform to this protocol, we need to implement the <code class="literal">decode</code> function. This function takes a <code class="literal">JSON</code> payload and returns a decoded <code class="literal">Todo</code> object.</p><p>In the body of the function, we will use the currying and custom operators. According to the Argo documentation, currying allows us to partially apply the <code class="literal">init</code> function over the course of the decoding process. This basically means that we can build up the <code class="literal">init</code> function call bit by bit, adding one parameter at a time, if (and only if) Argo can successfully decode them. If any of the parameters do not meet our expectations, Argo will skip the <code class="literal">init</code> call and return a special failure state. Let's check the syntax of Curry:</p><pre class="programlisting">public func curry&lt;A, B, C, D, E, F&gt;(function: (A, B, C, D, E) -&gt; F) -&gt; A&#13;
  -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F {&#13;
    return { (`a`: A) -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F in { (`b`: B) -&gt; C -&gt; D -&gt; E&#13;
      -&gt; F in { (`c`: C) -&gt; D -&gt; E -&gt; F in { (`d`: D) -&gt; E -&gt; F in { (`e`:&#13;
      E) -&gt; F in function(`a`, `b`, `c`, `d`, `e`) } } } } }&#13;
}&#13;
</pre><p>The <code class="literal">curry</code> function takes a function that has five parameters <code class="literal">A</code> to <code class="literal">E</code> and returns <code class="literal">F</code>, that is, <code class="literal">curry</code> returns <span class="emphasis"><em>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</em></span>.</p><p>This enables us to partially apply our <code class="literal">init</code> method.</p><div class="section" title="Operators"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec115"/>Operators</h3></div></div></div><p>We will discuss the different custom infix operators now:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;^&gt;</code> to map a function over a value conditionally</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;*&gt;</code> to apply a function with context to a value with context</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;|</code> to decode a value at the specific key into the requested type</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;|?</code> to decode an optional value at the specific key into the requested type</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;||</code> to decode an array of values at the specific key into the requested type</li></ul></div><div class="section" title="&lt;^&gt;"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec39"/>&lt;^&gt;</h4></div></div></div><p>Our first operator in the decoding process, <code class="literal">&lt;^&gt;</code>, is used to map our curried <code class="literal">init</code> method over a value. The definition is as follows:</p><pre class="programlisting">public func &lt;^&gt; &lt;T, U&gt;(@noescape f: T -&gt; U, x: Decoded&lt;T&gt;) -&gt; Decoded&lt;U&gt; {&#13;
    return x.map(f)&#13;
}&#13;
func map&lt;U&gt;(@noescape f: T -&gt; U) -&gt; Decoded&lt;U&gt; {&#13;
    switch self {&#13;
        case let .Success(value): return .Success(f(value))&#13;
        case let .Failure(error): return .Failure(error)&#13;
    }&#13;
}&#13;
</pre></div><div class="section" title="&lt;*&gt;"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec40"/>&lt;*&gt;</h4></div></div></div><p>The <code class="literal">&lt;*&gt;</code> operator is used to conditionally apply the other parameters to our curried init method. The definition is as follows:</p><pre class="programlisting">public func &lt;*&gt; &lt;T, U&gt;(f: Decoded&lt;T -&gt; U&gt;, x: Decoded&lt;T&gt;) -&gt; Decoded&lt;U&gt; {&#13;
    return x.apply(f)&#13;
}&#13;
func apply&lt;U&gt;(f: Decoded&lt;T -&gt; U&gt;) -&gt; Decoded&lt;U&gt; {&#13;
    switch f {&#13;
        case let .Success(function): return self.map(function)&#13;
        case let .Failure(error): return .Failure(error)&#13;
    }&#13;
}&#13;
</pre></div><div class="section" title="&lt;|"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec41"/>&lt;|</h4></div></div></div><p>The <code class="literal">&lt;|</code> operator is used to decode a value at the specified key path into the requested type. This operator uses a function named <code class="literal">flatReduce</code> that reduces and flattens the sequence:</p><pre class="programlisting">public func &lt;| &lt;A where A: Decodable, A == A.DecodedType&gt;(json: JSON, keys:&#13;
  [String]) -&gt; Decoded&lt;A&gt; {&#13;
    return flatReduce(keys, initial: json, combine: decodedJSON)&#13;
      &gt;&gt;- A.decode&#13;
}&#13;
</pre></div><div class="section" title="&lt;|?"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec42"/>&lt;|?</h4></div></div></div><p>The <code class="literal">&lt;|?</code> operator is used to decode an optional value at the specified key path into the requested type:</p><pre class="programlisting">public func &lt;|? &lt;A where A: Decodable, A == A.DecodedType&gt;(json: JSON, key:&#13;
  String) -&gt; Decoded&lt;A?&gt; {&#13;
    return .optional(json &lt;| [key])&#13;
}&#13;
</pre></div><div class="section" title="&lt;||"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec43"/>&lt;||</h4></div></div></div><p>The <code class="literal">&lt;||</code> operator is used to decode an array of values at a specific key into the requested type:</p><pre class="programlisting">public func &lt;|| &lt;A where A: Decodable, A == A.DecodedType&gt;(json: JSON,&#13;
  keys: [String]) -&gt; Decoded&lt;[A]&gt; {&#13;
    return flatReduce(keys, initial: json, combine: decodedJSON) &gt;&gt;-&#13;
      Array&lt;A&gt;.decode&#13;
}&#13;
</pre></div></div><div class="section" title="Using Argo models"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec116"/>Using Argo models</h3></div></div></div><p>Whenever we receive a JSON payload from the backend, we will be able to use the <code class="literal">decode</code> function to decode our <code class="literal">JSON</code> payload to our model:</p><pre class="programlisting">let json: AnyObject? = try?NSJSONSerialization.JSONObjectWithData(data,&#13;
  options: [])&#13;
 &#13;
if let j: AnyObject = json {&#13;
    let todo: Todo? = decode(j)&#13;
}&#13;
</pre><p>We can see that Argo is a great FP library that can be leveraged as an example to master lots of FP paradigms. Using Argo, Curry, and custom operators, we are able to parse and decode JSON payloads to our model objects declaratively. Also, our models become immutable value types that we can use in our applications without being concerned about mutability.</p><p>Also, we defined an <code class="literal">enum</code> called <code class="literal">TodoFilter</code>. We will use this <code class="literal">enum</code> to filter items.</p></div><div class="section" title="ViewModel"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec117"/>ViewModel</h3></div></div></div><p>We will have two <code class="literal">viewModel</code>, one for each <code class="literal">ViewController</code>.</p><pre class="programlisting">import ReactiveCocoa&#13;
&#13;
struct TodosViewModel {&#13;
    let todos: [Todo]&#13;
 &#13;
    func todoForIndexPath(indexPath: NSIndexPath) -&gt; Todo {&#13;
        return todos[indexPath.row]&#13;
    }&#13;
}&#13;
</pre><p>We will use <code class="literal">TodosViewModel</code> to list <code class="literal">Todo</code> items in our table view.</p><pre class="programlisting">struct TodoViewModel {&#13;
    let todo: Todo?&#13;
}&#13;
</pre><p>We will use <code class="literal">TodoViewModel</code> to present each <code class="literal">Todo</code> item's details.</p></div></div><div class="section" title="Communication"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec102"/>Communication</h2></div></div></div><p>So far, we have a backend API that we can use to CRUD <code class="literal">Todo</code> items and we have models in our iOS application. Let's examine how we can communicate with our backend and populate our models with received payloads.</p><div class="section" title="Request protocol"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec118"/>Request protocol</h3></div></div></div><p>First, we need to define a protocol for our request models:</p><pre class="programlisting">protocol RequestProtocol {&#13;
    subscript(key: String) -&gt; (String?, String?) { get }&#13;
}&#13;
&#13;
extension RequestProtocol {&#13;
    func getPropertyNames()-&gt; [String] {&#13;
        return Mirror(reflecting: self).children.filter {&#13;
$0.label !=&#13;
          nil }.map&#13;
        { $0.label! }}&#13;
}&#13;
</pre><p>Here, we defined <code class="literal">protocol</code> and we extended the protocol to be able to reflect the object and get properties and their values.</p><p>Also, we added <code class="literal">subscript</code> to our protocol, which any <code class="literal">struct</code> that wants to conform to this protocol should implement.</p></div><div class="section" title="Conforming to a request protocol"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec119"/>Conforming to a request protocol</h3></div></div></div><p>Now, let's create a request model named <code class="literal">TodoRequest</code>:</p><pre class="programlisting">struct TodoRequest: RequestProtocol {&#13;
 &#13;
    let id: Int&#13;
    let name: String&#13;
    let description: String&#13;
    let notes: String&#13;
    let completed: Bool&#13;
    let synced: Bool&#13;
 &#13;
    subscript(key: String) -&gt; (String?, String?) {&#13;
        get {&#13;
            switch key {&#13;
            case "id": return (String(id), "id")&#13;
            case "name": return (name, "name")&#13;
            case "description": return (description, "description")&#13;
            case "notes": return (notes, "notes")&#13;
            case "completed": return (String(completed), "completed")&#13;
            case "synced": return (String(synced), "synced")&#13;
            default: return ("Cookie","test=123")&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>As shown in the preceding code, this <code class="literal">struct</code> conforms to <code class="literal">RequestProtocol</code>. You might wonder why we have done this. First of all, this is an example of POP and second we will use this request model in our post web service call.</p></div><div class="section" title="WebServiceManager"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec120"/>WebServiceManager</h3></div></div></div><p>We will create a file named <code class="literal">WebServiceManager</code> and add a function in it:</p><pre class="programlisting">import Alamofire&#13;
func sendRequest(method: Alamofire.Method, request: RequestProtocol) {&#13;
&#13;
    // Add Headers&#13;
    let headers = configureHeaders(request)&#13;
&#13;
    // Fetch Request&#13;
    Alamofire.request(method, "http://localhost:8080/todo/",&#13;
      headers: headers, encoding: .JSON)&#13;
    .validate()&#13;
    .responseJSON { response in&#13;
        if (response.result.error == nil) {&#13;
            debugPrint("HTTP Response Body: \(response.data)")&#13;
        }&#13;
        else {&#13;
            debugPrint("HTTP Request failed: \(response.result.error)")&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func configureHeaders(request: RequestProtocol) -&gt; [String: String] {&#13;
    let listOfProperties = request.getPropertyNames()&#13;
    var configuredRequestHeaders = Dictionary&lt;String, String&gt;()&#13;
    for property in listOfProperties {&#13;
        let (propertyValue, propertyName) = request[property]&#13;
        if propertyName != nil {&#13;
            configuredRequestHeaders[propertyName!] = propertyValue&#13;
        }&#13;
    }&#13;
    return configuredRequestHeaders&#13;
}&#13;
</pre><p>Our <code class="literal">sendRequest</code> function takes two parameters. The first one is the HTTP request method and the second one is the type of <code class="literal">RequestProtocol</code>. Here, using the implemented protocol function called <code class="literal">getPropertyNames</code>, we prepare the header and send a request to our backend using <code class="literal">Alamofire</code>.</p><p>So far, we have a working communication layer. At this point, we need to develop managers and <code class="literal">viewController</code> to handle the logic and show the results to the user.</p><p>We will start by testing our communication layer in our <code class="literal">MasterViewController</code> and will move the respective code to our <code class="literal">managers</code>.</p></div><div class="section" title="Creating a Todo item"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec121"/>Creating a Todo item</h3></div></div></div><p>To create a Todo item, we can call the <code class="literal">sendRequest</code> function in our <code class="literal">MasterViewController viewDidLoad()</code> method to be sure that it is working:</p><pre class="programlisting">let newRequest = TodoRequest(id: 1,&#13;
                             name: "First request",&#13;
                             description:"description",&#13;
                             notes: "notes",&#13;
                             completed: "no")&#13;
    sendRequest(Alamofire.Method.POST, request: newRequest)&#13;
</pre><p>This should add a new <code class="literal">Todo</code> item to our backend.</p><p>Our <code class="literal">sendRequest</code> method is incomplete and it does not provide a call back to receive the data. Let's improve it:</p><pre class="programlisting">func sendRequest(method: Alamofire.Method,&#13;
                 request: RequestProtocol,&#13;
                 completion:(responseData: AnyObject?, error: NSError?) -&gt; Void) {&#13;
     &#13;
    // Add Headers &#13;
    let headers = configureHeaders(request) &#13;
     &#13;
    // Fetch Request&#13;
    Alamofire.request(method, "http://localhost:8080/todo/", &#13;
      headers: headers, encoding: .JSON)&#13;
        .validate() &#13;
        .responseJSON { response in &#13;
        if (response.result.error == nil) { &#13;
            debugPrint("HTTP Response Body: \(response.data)") &#13;
            completion(responseData: response.result.value, error: nil) &#13;
        } &#13;
        else { &#13;
            debugPrint("HTTP Request failed: \(response.result.error)") &#13;
            completion(responseData: nil, error: response.result.error) &#13;
        } &#13;
    } &#13;
}&#13;
</pre><p>We added a closure as the function argument and called the closure in the body of the function. To test it, we will update our call in <code class="literal">MasterViewController</code>:</p><pre class="programlisting">let newRequest = TodoRequest(id: 1,&#13;
                             name: "First request",&#13;
                             description:"description",&#13;
                             notes: "notes", &#13;
                             completed: "no")&#13;
sendRequest(Alamofire.Method.POST, request: newRequest) {&#13;
    (response, error) in&#13;
    if error == nil {&#13;
        let todos: [Todo]? = decode(response!)&#13;
        print("request was successful: \(todos)")&#13;
    } else {&#13;
        print("Error")&#13;
    }&#13;
}&#13;
</pre><p>Here, we pass a trailing closure in our call; once it is called, we receive the response or error. Importing and using Argo, we can map the payload to our model. We called this function only for testing and we need to move this call to the proper place. After all, none of our <code class="literal">MasterViewController</code> classes will be able to call this function directly and they have to go through other objects. Also, we will need to improve our <code class="literal">sendRequest</code> function to take the proper <code class="literal">url</code>:</p><pre class="programlisting">import Alamofire&#13;
&#13;
enum Urls {&#13;
    case postTodo&#13;
    case getTodos&#13;
    case getTodo&#13;
    case deleteTodo&#13;
    case deleteAll&#13;
    case update&#13;
}&#13;
&#13;
extension Urls {&#13;
    func httpMethodUrl() -&gt; (Alamofire.Method, String) {&#13;
        let baseUrl = "http://localhost:8080/"&#13;
        switch self {&#13;
        case .postTodo:&#13;
            return (.POST, "\(baseUrl)postTodo")&#13;
        case .getTodos:&#13;
            return (.GET, "\(baseUrl)todos")&#13;
        case .getTodo:&#13;
            return (.GET, "\(baseUrl)todo")&#13;
        case .deleteTodo:&#13;
            return (.DELETE, "\(baseUrl)deleteTodo")&#13;
        case .deleteAll:&#13;
            return (.DELETE, "\(baseUrl)deleteAll")&#13;
        case .update:&#13;
            return (.POST, "\(baseUrl)updateTodo")&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>Here, we define an <code class="literal">enum</code> and extend it. In our <code class="literal">httpMethodUrl</code> function, we perform pattern matching to return a tuple consisting of an HTTP request method and the full <code class="literal">url</code>. We need to change our <code class="literal">sendRequest</code> function as follows:</p><pre class="programlisting">import Alamofire&#13;
&#13;
func sendRequest(url: Urls,&#13;
             request: RequestProtocol,&#13;
          completion: (responseData: AnyObject?,&#13;
               error: NSError?) -&gt; Void) {&#13;
    // Add headers&#13;
    let headers = configureHeaders(request)&#13;
    // Get request method and full url&#13;
    let (method, url) = url.httpMethodUrl()&#13;
 &#13;
    // Fetch request&#13;
    Alamofire.request(method, url, headers: headers, encoding: .JSON)&#13;
    .validate()&#13;
    .responseJSON { response in&#13;
        if (response.result.error == nil) {&#13;
            debugPrint("HTTP Response Body: \(response.data)")&#13;
            completion(responseData: response.result.value, error: nil)&#13;
        } else {&#13;
            debugPrint("HTTP Request failed: \(response.result.error)")&#13;
            completion(responseData: nil, error: response.result.error)&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>Our function call should be changed as follows:</p><pre class="programlisting">let newRequest = TodoRequest(id: 1,&#13;
                           name: "First request",&#13;
                    description: "description",&#13;
                          notes: "notes",&#13;
                      completed: false)&#13;
&#13;
sendRequest(Urls.postTodo, request: newRequest) { (response, error) in&#13;
    if error == nil {&#13;
        let todos: [Todo]? = decode(response!)&#13;
        print("request was successful: \(todos)")&#13;
    } else {&#13;
        print("Error")&#13;
    }&#13;
}&#13;
</pre></div><div class="section" title="Listing Todo items"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec122"/>Listing Todo items</h3></div></div></div><p>To retrieve all Todo items, unlike our post call, we do not need to pass any header parameters, just cookie information. So, we add the following <code class="literal">struct</code> to handle this scenario:</p><pre class="programlisting">struct RequestModel: RequestProtocol {&#13;
&#13;
    subscript(key: String) -&gt; (String?, String?) {&#13;
        get {&#13;
            switch key {&#13;
                default: return ("Cookie","test=123")&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>Then, we can retrieve the list of <code class="literal">Todo</code> items using the following code:</p><pre class="programlisting">sendRequest(Urls.getTodos, request: RequestModel()) { (response, error) in&#13;
    if error == nil {&#13;
        let todos: [Todo]? = decode(response!)&#13;
        print("request was successful: \(todos)")&#13;
    } else {&#13;
        print("Error: \(error?.localizedDescription)")&#13;
    }&#13;
}&#13;
</pre><p>Although we added better error printing, we need to improve it further.</p><p>Let's extract the preceding function calls, create a Swift file named <code class="literal">TodoManager</code>, and put these functions in it:</p><pre class="programlisting">import Alamofire&#13;
import Argo&#13;
&#13;
func addTodo(completion:(responseData:[Todo]?, error: NSError?) -&gt; Void) {&#13;
    let newRequest = TodoRequest(id: 1,&#13;
                               name: "Saturday Grocery",&#13;
                        description: "Bananas, Pineapple, Beer,&#13;
                          Orange juice, ...",&#13;
                              notes: "Cehck expiry date of orange juice",&#13;
                          completed: false,&#13;
                             synced: true)&#13;
 &#13;
    sendRequest(Urls.postTodo, request: newRequest) {&#13;
        (response, error) in&#13;
        if error == nil {&#13;
            let todos: [Todo]? = decode(response!)&#13;
            completion(responseData: todos, error: nil)&#13;
            print("request was successfull: \(todos)")&#13;
        } else {&#13;
            completion(responseData: nil, error: error)&#13;
            print("Error: \(error?.localizedDescription)")&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func listTodos(completion:(responseData:[Todo]?, error: NSError?) -&gt; Void) {&#13;
    sendRequest(Urls.getTodos, request: RequestModel()) {&#13;
        (response, error) in&#13;
        if error == nil {&#13;
            let todos: [Todo]? = decode(response!)&#13;
            completion(responseData: todos, error: nil)&#13;
            print("request was successfull: \(todos)")&#13;
        } else {&#13;
            completion(responseData: nil, error: error)&#13;
            print("Error: \(error?.localizedDescription)")&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>Finally, we will develop two other functions: one adds or updates a <code class="literal">Todo</code> item and the other only updates a specific <code class="literal">Todo</code> item. Deleting items will be easy to implement as well. The code is as follows:</p><pre class="programlisting">func addOrUpdateTodo(todo: [Todo]?, completion:(responseData:[Todo]?, error: NSError?) -&gt; Void) {&#13;
    if let todoItem = todo?.first {&#13;
        let newRequest = TodoRequest(id: todoItem.id,&#13;
                                   name: todoItem.name,&#13;
                            description: todoItem.description,&#13;
                                  notes: todoItem.notes!,&#13;
                              completed: todoItem.completed,&#13;
                                 synced: true)&#13;
 &#13;
        sendRequest(Urls.postTodo, request: newRequest) {&#13;
            (response, error) in&#13;
            if error == nil {&#13;
                let todos: [Todo]? = decode(response!)&#13;
                let newTodo = todoSyncedLens.set(true, todoItem)&#13;
                store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
                completion(responseData: todos, error: nil)&#13;
                print("request was successfull: \(todos)")&#13;
            } else {&#13;
                completion(responseData: nil, error: error)&#13;
                print("Error: \(error?.localizedDescription)")&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func updateTodo(todo: [Todo]?, completion:(responseData:[Todo]?,&#13;
  error: NSError?) -&gt; Void) {&#13;
    if let todoItem = todo?.first {&#13;
        let newRequest = TodoRequest(id: todoItem.id,&#13;
                                   name: todoItem.name,&#13;
                            description: todoItem.description,&#13;
                                  notes: todoItem.notes!,&#13;
                              completed: todoItem.completed,&#13;
                                 synced: true)&#13;
 &#13;
        sendRequest(Urls.update, request: newRequest) {&#13;
            (response, error) in&#13;
            if error == nil {&#13;
                let todos: [Todo]? = decode(response!)&#13;
                let newTodo = todoSyncedLens.set(true, todoItem)&#13;
                store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
                completion(responseData: todos, error: nil)&#13;
                print("request was successfull: \(todos)")&#13;
            } else {   &#13;
                completion(responseData: nil, error: error)&#13;
                print("Error: \(error?.localizedDescription)")&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>In these functions, there are concepts that we have not yet covered in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dispatch</code>: This function dispatches an action (here, <code class="literal">UpdateTodoAction</code>) by settings the state's value to the result of calling its <code class="literal">reduce</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">todoSyncedLens</code>: This is a <code class="literal">Lens</code> to modify the synced property of the <code class="literal">todo</code> item. We will define these lenses in an upcoming section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">UpdateTodoAction</code>: This is a <code class="literal">struct</code> that conforms to <code class="literal">ActionType</code>, which is used when we want to make modifications to the <code class="literal">State</code> of the <code class="literal">Store</code>. All changes to the <code class="literal">Store</code> go through this type. We will define our actions in an upcoming section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">State</code>: This is a <code class="literal">struct</code> that will be used to manage the <code class="literal">State</code>. We will define it later.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Store</code>: As the name suggests, this is where we store the <code class="literal">State</code>. We will define it later.</li></ul></div></div></div><div class="section" title="Lens"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec103"/>Lens</h2></div></div></div><p>We will use lenses to modify our <code class="literal">Todo</code> item. Each of the following lenses will be used to modify a part of the <code class="literal">Todo</code> item:</p><pre class="programlisting">struct Lens&lt;Whole, Part&gt; {&#13;
    let get: Whole -&gt; Part&#13;
    let set: (Part, Whole) -&gt; Whole&#13;
}&#13;
&#13;
let todoNameLens: Lens&lt;Todo, String&gt; = Lens(&#13;
    get: { $0.name},&#13;
    set: {&#13;
        Todo(id: $1.id,&#13;
           name: $0,&#13;
    description: $1.description,&#13;
          notes: $1.notes,&#13;
      completed: $1.completed,&#13;
         synced: $1.synced,&#13;
       selected: $1.selected)&#13;
})&#13;
&#13;
let todoDescriptionLens: Lens&lt;Todo, String&gt; = Lens(&#13;
    get: { $0.description},&#13;
    set: {&#13;
        Todo(id: $1.id,&#13;
           name: $1.name,&#13;
    description: $0,&#13;
          notes: $1.notes,&#13;
      completed: $1.completed,&#13;
         synced: $1.synced,&#13;
       selected: $1.selected)&#13;
})&#13;
&#13;
let todoNotesLens: Lens&lt;Todo, String&gt; = Lens(&#13;
    get: { $0.notes!},&#13;
    set: {&#13;
        Todo(id: $1.id,&#13;
           name: $1.name,&#13;
    description: $1.description,&#13;
          notes: $0,&#13;
      completed: $1.completed,&#13;
         synced: $1.synced,&#13;
       selected: $1.selected)&#13;
})&#13;
&#13;
let todoCompletedLens: Lens&lt;Todo, Bool&gt; = Lens(&#13;
    get: { $0.completed},&#13;
    set: {&#13;
        Todo(id: $1.id,&#13;
           name: $1.name,&#13;
    description: $1.description,&#13;
          notes: $1.notes,&#13;
      completed: $0,&#13;
         synced: $1.synced,&#13;
       selected: $1.selected)&#13;
})&#13;
&#13;
let todoSyncedLens: Lens&lt;Todo, Bool&gt; = Lens(&#13;
    get: { $0.synced},&#13;
    set: {&#13;
        Todo(id: $1.id,&#13;
           name: $1.name,&#13;
    description: $1.description,&#13;
          notes: $1.notes,&#13;
      completed: $1.completed,&#13;
         synced: $0,&#13;
       selected: $1.selected)&#13;
})&#13;
</pre></div><div class="section" title="State"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec104"/>State</h2></div></div></div><p>In our application, we need to manage states to keep the state management code as declarative as possible. We will use a library named <code class="literal">Delta</code>.</p><p>Delta will be used along with ReactiveCocoa to manage states and state changes reactively. The code is as follows:</p><pre class="programlisting">import ReactiveCocoa&#13;
import Delta&#13;
&#13;
extension MutableProperty: Delta.ObservablePropertyType {&#13;
    public typealias ValueType = Value&#13;
}&#13;
</pre><p>In the preceding code, we extend the ReactiveCocoa library's <code class="literal">MutableProperty</code> by conforming to <code class="literal">Delta.ObservablePropertyType</code>.</p><p>The <code class="literal">ObservablePropertyType</code> protocol must be implemented by the <code class="literal">State</code> that is held by <code class="literal">Store</code>. To use a custom <code class="literal">State</code> type, this protocol must be implemented on that object.</p><p>
<code class="literal">MutableProperty</code> creates a mutable property of type value and allows observation of its changes in a thread-safe way.</p><p>Using extended <code class="literal">MutableProperty</code>, our <code class="literal">State</code> objects become the following:</p><pre class="programlisting">import ReactiveCocoa&#13;
&#13;
private let initialTodos: [Todo] = []&#13;
&#13;
struct State {&#13;
    let todos = MutableProperty(initialTodos)&#13;
    let filter = MutableProperty(TodoFilter.all)&#13;
    let notSynced = MutableProperty(TodoFilter.notSyncedWithBackend)&#13;
    let selectedTodoItem = MutableProperty(TodoFilter.selected)&#13;
}&#13;
</pre></div><div class="section" title="Store"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec105"/>Store</h2></div></div></div><p>We will store the state in our <code class="literal">Store</code> object:</p><pre class="programlisting">import ReactiveCocoa&#13;
import Delta&#13;
&#13;
struct Store: StoreType {&#13;
    var state: MutableProperty&lt;State&gt;&#13;
&#13;
    init(state: State) {&#13;
        self.state = MutableProperty(state)&#13;
    }&#13;
}&#13;
&#13;
var store = Store(state: State())&#13;
</pre><p>
<code class="literal">Store</code> conforms to the <code class="literal">StoreType</code> protocol declared in the <code class="literal">Delta</code> library. The <code class="literal">StoreType</code> protocol defines the storage of an observable state and dispatch methods to modify it.</p><p>Here, we create a <code class="literal">MutableProperty</code> as <code class="literal">state</code> and store it in <code class="literal">Store</code>.</p><p>We need to define properties to access and modify our state properly, so we extend our <code class="literal">Store</code> as follows:</p><pre class="programlisting">import ReactiveCocoa&#13;
import Result&#13;
&#13;
// MARK: Properties&#13;
extension Store {&#13;
    var todos: MutableProperty&lt;[Todo]&gt; {&#13;
        return state.value.todos&#13;
    }&#13;
&#13;
    var activeFilter: MutableProperty&lt;TodoFilter&gt; {&#13;
        return state.value.filter&#13;
    }&#13;
&#13;
    var selectedTodoItem: MutableProperty&lt;TodoFilter&gt; {&#13;
        return state.value.selectedTodoItem&#13;
    }&#13;
&#13;
}&#13;
&#13;
// MARK: SignalProducers&#13;
extension Store {&#13;
    var activeTodos: SignalProducer&lt;[Todo], NoError&gt; {&#13;
        return activeFilter.producer.flatMap(.Latest) {&#13;
            filter -&gt; SignalProducer&lt;[Todo], NoError&gt; in&#13;
                switch filter {&#13;
                case .all: return self.todos.producer&#13;
                case .active: return self.incompleteTodos&#13;
                case .completed: return self.completedTodos&#13;
                case .notSyncedWithBackend: return&#13;
                  self.notSyncedWithBackend&#13;
                case .selected: return self.selectedTodo&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    var completedTodos: SignalProducer&lt;[Todo], NoError&gt; {&#13;
        return todos.producer.map {&#13;
            todos in&#13;
            return todos.filter { $0.completed }&#13;
        }&#13;
    }&#13;
 &#13;
    var incompleteTodos: SignalProducer&lt;[Todo], NoError&gt; {&#13;
        return todos.producer.map {&#13;
            todos in&#13;
            return todos.filter { !$0.completed }&#13;
        }&#13;
    }&#13;
 &#13;
    var incompleteTodosCount: SignalProducer&lt;Int, NoError&gt; {&#13;
        return incompleteTodos.map { $0.count }&#13;
    }&#13;
 &#13;
    var allTodosCount: SignalProducer&lt;Int, NoError&gt; {&#13;
        return todos.producer.map { $0.count }&#13;
    }&#13;
 &#13;
    var todoStats: SignalProducer&lt;(Int, Int), NoError&gt; {&#13;
        return allTodosCount.zipWith(incompleteTodosCount)&#13;
    }&#13;
 &#13;
    var notSyncedWithBackend: SignalProducer&lt;[Todo], NoError&gt; {&#13;
        return todos.producer.map {&#13;
            todos in&#13;
            return todos.filter { !$0.synced }&#13;
        }&#13;
    }&#13;
 &#13;
    var selectedTodo: SignalProducer&lt;[Todo], NoError&gt; {&#13;
        return todos.producer.map {&#13;
            todos in&#13;
            return todos.filter {&#13;
                todo in&#13;
                if let selected = todo.selected {&#13;
                    return selected&#13;
                } else {&#13;
                    return false&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
 &#13;
    func producerForTodo(todo: Todo) -&gt; SignalProducer&lt;Todo, NoError&gt; {&#13;
        return store.todos.producer.map {&#13;
            todos in&#13;
            return todos.filter { $0 == todo }.first&#13;
        }.ignoreNil()&#13;
    }&#13;
}&#13;
</pre><p>In our store, we use ReactiveCocoa's <code class="literal">SignalProducer</code> to create observable signals. We will observe these signals in other objects and react to signal changes.</p></div><div class="section" title="Action"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec106"/>Action</h2></div></div></div><p>Actions are structs that conform to the <code class="literal">ActionType</code> protocol from the <code class="literal">Delta</code> library. <code class="literal">ActionType</code> is used when we want to make modifications to the store's state. All changes to the <code class="literal">Store</code> go through this type. Let's examine one example:</p><pre class="programlisting">import Delta&#13;
&#13;
struct UpdateTodoAction: ActionType {&#13;
    let todo: Todo&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.todos.value = state.todos.value.map {&#13;
            todo in&#13;
            guard todo == self.todo else { return todo }&#13;
 &#13;
            return Todo(id: todo.id,&#13;
                      name: self.todo.name,&#13;
               description: self.todo.description,&#13;
                     notes: self.todo.notes,&#13;
                 completed: self.todo.completed,&#13;
                    synced: !todo.synced,&#13;
                  selected: todo.selected)&#13;
        }&#13;
 &#13;
        return state&#13;
    }&#13;
}&#13;
</pre><p>In our manager, we had a call like this:</p><pre class="programlisting">store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
</pre><p>The <code class="literal">dispatch</code> method call on <code class="literal">store</code> with the <code class="literal">UpdateTodoAction</code> will call the <code class="literal">reduce</code> method of <code class="literal">UpdateTodoAction</code>. It will also make modifications on the state and return a new version of it. This is the only place where changes to <code class="literal">State</code> are permitted; therefore, any changes to state should go through an action.</p><p>Let's define other actions as well:</p><pre class="programlisting">import Delta&#13;
&#13;
struct ClearCompletedTodosAction: DynamicActionType {&#13;
    func call() {&#13;
        let todos = store.completedTodos.first()?.value ?? []&#13;
&#13;
        todos.forEach { todo in&#13;
            store.dispatch(DeleteTodoAction(todo: todo))&#13;
        }&#13;
    }&#13;
}&#13;
 &#13;
struct CreateTodoAction: ActionType {&#13;
    let id: Int&#13;
    let name: String&#13;
    let description: String&#13;
    let notes: String&#13;
&#13;
    var todo: Todo {&#13;
        return Todo(id: id,&#13;
                  name: name,&#13;
           description: description,&#13;
                 notes: notes,&#13;
             completed: false,&#13;
                synced: false,&#13;
              selected: false)&#13;
    }&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.todos.value = state.todos.value + [todo]&#13;
&#13;
        return state&#13;
    }&#13;
}&#13;
&#13;
struct DeleteTodoAction: ActionType {&#13;
    let todo: Todo&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.todos.value = state.todos.value.filter { $0 != self.todo }&#13;
&#13;
        return state&#13;
    }&#13;
}&#13;
&#13;
struct DetailsTodoAction: ActionType {&#13;
    let todo: Todo&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.todos.value = state.todos.value.map { todo in&#13;
            guard todo == self.todo else {&#13;
&#13;
                return Todo(id: todo.id,&#13;
                          name: todo.name,&#13;
                   description: todo.description,&#13;
                         notes: todo.notes,&#13;
                     completed: todo.completed,&#13;
                        synced: todo.synced,&#13;
                      selected: false)&#13;
            }&#13;
&#13;
            return Todo(id: self.todo.id,&#13;
                      name: self.todo.name,&#13;
               description: self.todo.description,&#13;
                     notes: self.todo.notes,&#13;
                 completed: self.todo.completed,&#13;
                    synced: self.todo.synced,&#13;
                  selected: true)&#13;
        }&#13;
&#13;
        return state&#13;
    }&#13;
}&#13;
 &#13;
struct LoadTodosAction: ActionType {&#13;
    let todos: [Todo]&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.todos.value = state.todos.value + todos&#13;
        return state&#13;
    }&#13;
}&#13;
&#13;
struct SetFilterAction: ActionType {&#13;
    let filter: TodoFilter&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.filter.value = filter&#13;
        return state&#13;
    }&#13;
}&#13;
&#13;
struct ToggleCompletedAction: ActionType {&#13;
    let todo: Todo&#13;
&#13;
    func reduce(state: State) -&gt; State {&#13;
        state.todos.value = state.todos.value.map {&#13;
            todo in&#13;
            guard todo == self.todo else { return todo }&#13;
&#13;
            return Todo(id: todo.id,&#13;
                      name: todo.name,&#13;
               description: todo.description,&#13;
                     notes: todo.notes,&#13;
                 completed: !todo.completed,&#13;
                    synced: !todo.synced,&#13;
                  selected: todo.selected)&#13;
        }&#13;
&#13;
        return state&#13;
    }&#13;
}&#13;
</pre></div><div class="section" title="Views"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec107"/>Views</h2></div></div></div><p>The user will be able to list <code class="literal">Todo</code> items from the backend, toggle to mark an item as complete, or swipe left to access functionalities such as <span class="strong"><strong>Details</strong></span> and <span class="strong"><strong>Delete</strong></span>.</p><p>Our application will look like this:</p><p>
</p><div class="mediaobject"><img alt="Views" src="graphics/image_11_006.jpg"/></div><p>
</p><div class="mediaobject"><img alt="Views" src="graphics/image_11_007.jpg"/></div><p>
</p><p>
</p><div class="mediaobject"><img alt="Views" src="graphics/image_11_008.jpg"/></div><p>
</p><p>
</p><div class="mediaobject"><img alt="Views" src="graphics/image_11_009.jpg"/></div><p>
</p><p>We can design these screens in the storyboard. We will need to implement a custom <code class="literal">UITableViewCell</code> as shown here to be able to show the proper data on TableView:</p><pre class="programlisting">class TodoTableViewCell: UITableViewCell {&#13;
&#13;
    var todo: Todo? {&#13;
        didSet {&#13;
            updateUI()&#13;
        }&#13;
    }&#13;
&#13;
    var attributedText: NSAttributedString {&#13;
        guard let todo = todo else { return NSAttributedString() }&#13;
&#13;
        let attributes: [String : AnyObject]&#13;
        if todo.completed {&#13;
            attributes = [NSStrikethroughStyleAttributeName:&#13;
              NSUnderlineStyle.StyleSingle.rawValue]&#13;
        } else {&#13;
            attributes = [:]&#13;
        }&#13;
&#13;
        return NSAttributedString(string: todo.name,&#13;
          attributes: attributes)&#13;
    }&#13;
&#13;
    override func setSelected(selected: Bool, animated: Bool) {&#13;
        super.setSelected(selected, animated: animated)&#13;
    }&#13;
&#13;
    func configure(todo: Todo) {&#13;
        store.producerForTodo(todo).startWithNext { nextTodo in&#13;
            self.todo = nextTodo&#13;
        }&#13;
    }&#13;
&#13;
    func updateUI() {&#13;
        guard let todo = todo else { return }&#13;
&#13;
        textLabel?.attributedText = attributedText&#13;
        accessoryType = todo.completed ? .Checkmark : .None&#13;
    }&#13;
&#13;
}&#13;
</pre><p>The only interesting piece in this class is the <code class="literal">configure</code> method. It will be called in our <code class="literal">cellForRowAtIndexPath</code> method of <code class="literal">TableViewController</code> to create a <code class="literal">Signal</code> from the producer, then to add exactly one observer to the <code class="literal">Signal</code>, which will invoke the given callback when next events are received.</p></div><div class="section" title="ViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec108"/>ViewController</h2></div></div></div><p>We will have two ViewController subclasses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MasterViewController</code>: This will list the <code class="literal">Todo</code> items</li><li class="listitem" style="list-style-type: disc"><code class="literal">DetailViewController</code>: This will present and modify the details of each item</li></ul></div><div class="section" title="MasterViewController"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec123"/>MasterViewController</h3></div></div></div><p>We will present a list of items to the user in <code class="literal">MasterViewController</code>:</p><pre class="programlisting">import UIKit&#13;
&#13;
class MasterViewController: UITableViewController {&#13;
&#13;
    @IBOutlet weak var filterSegmentedControl: UISegmentedControl!&#13;
&#13;
    var viewModel = TodosViewModel(todos: []) {&#13;
        didSet {&#13;
            tableView.reloadData()&#13;
        }&#13;
    }&#13;
&#13;
    override func viewDidLoad() {&#13;
        super.viewDidLoad()&#13;
&#13;
        listTodos() {&#13;
            (response, error) in&#13;
            if error == nil {&#13;
                store.dispatch(LoadTodosAction(todos: response!))&#13;
            } else {&#13;
                print("Error: \(error?.localizedDescription)")&#13;
            }&#13;
        }&#13;
&#13;
        filterSegmentedControl.addTarget(self, action:&#13;
          #selector(ViewController.filterValueChanged),&#13;
          forControlEvents: .ValueChanged)&#13;
 &#13;
        store.activeFilter.producer.startWithNext {&#13;
            filter in&#13;
            self.filterSegmentedControl.selectedSegmentIndex =&#13;
              filter.rawValue&#13;
        }&#13;
 &#13;
        store.activeTodos.startWithNext {&#13;
            todos in&#13;
            self.viewModel = TodosViewModel(todos: todos)&#13;
        }&#13;
 &#13;
        store.notSyncedWithBackend.startWithNext {&#13;
            todos in&#13;
            addOrUpdateTodo(todos) { (response, error) in&#13;
                if error == nil {&#13;
                    print("Success")&#13;
                } else {&#13;
                    print("Error: \(error?.localizedDescription)")&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>We have <code class="literal">viewModel</code>, which is a computed property. In <code class="literal">viewDidLoad</code>, we list the <code class="literal">Todo</code> items from our backend and we store them in <code class="literal">State</code> using <code class="literal">LoadTodosAction</code>. Then, we define observations to change our <code class="literal">viewModel</code> and to sync changed items with the backend.</p><div class="section" title="IBActions"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec44"/>IBActions</h4></div></div></div><p>We will need to define two <code class="literal">IBAction</code>, one to add a new item to the list and the other to filter the items:</p><pre class="programlisting">// MARK: Actions&#13;
extension MasterViewController {&#13;
    @IBAction func addTapped(sender: UIBarButtonItem) {&#13;
        let alertController = UIAlertController(&#13;
          title: "Create",&#13;
        message: "Create a new todo item",&#13;
 preferredStyle: .Alert)&#13;
 &#13;
    alertController.addTextFieldWithConfigurationHandler() {&#13;
        textField in&#13;
        textField.placeholder = "Id"&#13;
    }&#13;
 &#13;
    alertController.addTextFieldWithConfigurationHandler() {&#13;
        textField in&#13;
        textField.placeholder = "Name"&#13;
    }&#13;
 &#13;
    alertController.addTextFieldWithConfigurationHandler() {&#13;
        textField in&#13;
        textField.placeholder = "Description"&#13;
    }&#13;
 &#13;
    alertController.addTextFieldWithConfigurationHandler() {&#13;
        textField in&#13;
        textField.placeholder = "Notes"&#13;
    }&#13;
 &#13;
    alertController.addAction(UIAlertAction(title: "Cancel",&#13;
      style: .Cancel) { _ in })&#13;
 &#13;
    alertController.addAction(UIAlertAction(title: "Create",&#13;
      style: .Default) { _ in&#13;
        guard let id = alertController.textFields?[0].text,&#13;
        name = alertController.textFields?[1].text,&#13;
        description = alertController.textFields?[2].text,&#13;
        notes = alertController.textFields?[3].text&#13;
        else { return }&#13;
 &#13;
        store.dispatch(CreateTodoAction(&#13;
          id: Int(id)!,&#13;
        name: name,&#13;
 description: description,&#13;
       notes: notes))&#13;
        })&#13;
        presentViewController(alertController, animated: false,&#13;
          completion: nil)&#13;
    }&#13;
 &#13;
    func filterValueChanged() {&#13;
        guard let newFilter = TodoFilter(rawValue:&#13;
          filterSegmentedControl.selectedSegmentIndex)&#13;
        else { return }&#13;
 &#13;
        store.dispatch(SetFilterAction(filter: newFilter))&#13;
    }&#13;
}&#13;
</pre><p>In the <code class="literal">addTapped</code> method, we use <code class="literal">createTodoAction</code> to add an item to the list with the <code class="literal">completed</code> and <code class="literal">synced</code> values as <code class="literal">false</code>. Therefore, <code class="literal">store.notSyncedWithBackend.startWithNext</code> in <code class="literal">viewDidLoad</code> will observe this item as not synced and will sync it with the backend.</p></div><div class="section" title="TableView Delegates and DataSource"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec45"/>TableView Delegates and DataSource</h4></div></div></div><p>Finally, we need to implement the <code class="literal">delegates</code> and <code class="literal">datasource</code> methods for <code class="literal">UITableViewController</code>. The code is as follows:</p><pre class="programlisting">// MARK: UITableViewController&#13;
extension MasterViewController {&#13;
    override func tableView(tableView: UITableView,&#13;
      numberOfRowsInSection section: Int) -&gt; Int {&#13;
        return viewModel.todos.count&#13;
    }&#13;
 &#13;
    override func tableView(tableView: UITableView, cellForRowAtIndexPath&#13;
      indexPath: NSIndexPath) -&gt; UITableViewCell {&#13;
        let cell = tableView.dequeueReusableCellWithIdentifier("todoCell",&#13;
          forIndexPath: indexPath) as! TodoTableViewCell&#13;
        let todo = viewModel.todoForIndexPath(indexPath)&#13;
 &#13;
        cell.configure(todo)&#13;
 &#13;
        return cell&#13;
    }&#13;
 &#13;
    override func tableView(tableView: UITableView, didSelectRowAtIndexPath&#13;
      indexPath: NSIndexPath) {&#13;
        let todo = viewModel.todoForIndexPath(indexPath)&#13;
        store.dispatch(ToggleCompletedAction(todo: todo))&#13;
        tableView.deselectRowAtIndexPath(indexPath, animated: true)&#13;
    }&#13;
 &#13;
    override func tableView(tableView: UITableView, commitEditingStyle&#13;
      editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath&#13;
      indexPath: NSIndexPath) {&#13;
&#13;
    }&#13;
 &#13;
    override func tableView(tableView: UITableView,&#13;
      editActionsForRowAtIndexPath indexPath: NSIndexPath)&#13;
      -&gt; [UITableViewRowAction]? {&#13;
        let delete = UITableViewRowAction(style: .Normal, title: "Delete")&#13;
          { action, index in&#13;
            let todo = self.viewModel.todoForIndexPath(indexPath)&#13;
            store.dispatch(DeleteTodoAction(todo: todo))&#13;
        }&#13;
        delete.backgroundColor = UIColor.redColor()&#13;
 &#13;
        let details = UITableViewRowAction(style: .Normal,&#13;
          title: "Details") { action, index in&#13;
            let todo = self.viewModel.todoForIndexPath(indexPath)&#13;
            store.dispatch(DetailsTodoAction(todo: todo))&#13;
 &#13;
            self.performSegueWithIdentifier("segueShowDetails",&#13;
              sender: self)&#13;
        }&#13;
        details.backgroundColor = UIColor.orangeColor()&#13;
 &#13;
        return [details, delete]&#13;
    }&#13;
 &#13;
    override func tableView(tableView: UITableView, canEditRowAtIndexPath&#13;
      indexPath: NSIndexPath) -&gt; Bool {&#13;
        // the cells you would like the actions to appear need to&#13;
          be editable&#13;
        return true&#13;
    }&#13;
}&#13;
</pre><p>In the preceding code, we use <code class="literal">DeleteTodoAction</code> to delete an item by swiping to the left and selecting <span class="strong"><strong>Delete</strong></span>. We use <code class="literal">ToggleCompletedAction</code> to mark an item as completed when we tap on any item on the list, and we use <code class="literal">DetailsTodoAction</code> to navigate to the details page when we swipe to the left and select <span class="strong"><strong>Details</strong></span>.</p></div></div><div class="section" title="DetailsViewController"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec124"/>DetailsViewController</h3></div></div></div><p>We will use <code class="literal">viewController</code> to present the details of a <code class="literal">Todo</code> item and modify it. We will have three <code class="literal">textField</code> and a switch. We will observe the changes in the UI and modify the <code class="literal">State</code> and backend. The code is as follows:</p><pre class="programlisting">import UIKit&#13;
import ReactiveCocoa&#13;
&#13;
class DetailsViewController: UIViewController {&#13;
 &#13;
    @IBOutlet weak var txtFieldName: UITextField!&#13;
    @IBOutlet weak var txtFieldDescription: UITextField!&#13;
    @IBOutlet weak var txtFieldNotes: UITextField!&#13;
    @IBOutlet weak var switchCompleted: UISwitch!&#13;
 &#13;
    var viewModel = TodoViewModel(todo: nil)&#13;
 &#13;
    override func viewDidLoad() {&#13;
        super.viewDidLoad()&#13;
        store.selectedTodo.startWithNext { todos in&#13;
            let model = todos.first!&#13;
            self.txtFieldName.text = model.name&#13;
            self.txtFieldDescription.text = model.description&#13;
            self.txtFieldNotes.text = model.notes&#13;
            self.switchCompleted.on = model.completed&#13;
            self.viewModel = TodoViewModel(todo: model)&#13;
        }&#13;
        setupUpdateSignals()&#13;
    }&#13;
 &#13;
    func setupUpdateSignals() {&#13;
        txtFieldName.rac_textSignal().subscribeNext {&#13;
            (next: AnyObject!) -&gt; () in&#13;
            if let newName = next as? String {&#13;
                let newTodo = todoNameLens.set(newName,&#13;
                  self.viewModel.todo!)&#13;
                store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
            }&#13;
        }&#13;
 &#13;
        txtFieldDescription.rac_textSignal().subscribeNext {&#13;
            (next: AnyObject!) -&gt; () in&#13;
            if let newDescription = next as? String {&#13;
                let newTodo = todoDescriptionLens.set(newDescription,&#13;
                  self.viewModel.todo!)&#13;
                store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
            }&#13;
        }&#13;
 &#13;
        txtFieldNotes.rac_textSignal().subscribeNext {&#13;
            (next: AnyObject!) -&gt; () in&#13;
            if let newNotes = next as? String {&#13;
                let newTodo = todoNotesLens.set(newNotes,&#13;
                  self.viewModel.todo!)&#13;
                store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
&#13;
            }&#13;
        }&#13;
 &#13;
        switchCompleted.rac_newOnChannel().subscribeNext {&#13;
            (next: AnyObject!) -&gt; () in&#13;
            if let newCompleted = next as? Bool {&#13;
                let newTodo = todoCompletedLens.set(newCompleted,&#13;
                  self.viewModel.todo!)&#13;
                store.dispatch(UpdateTodoAction(todo: newTodo))&#13;
&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>In our <code class="literal">viewDidLoad</code> method, we look for the selected item in <code class="literal">MasterViewController</code> before navigating to <code class="literal">DetailsViewController</code>. We will also set the <code class="literal">UITextField</code> and <code class="literal">UISwitch</code> initial values. We will subscribe to changes in the UI, use lenses to update the <code class="literal">Todo</code> item, and change the state via <code class="literal">UpdateTodoAction</code>. Any item change will set synced as false. Since this property is observed in <code class="literal">MasterViewController</code>, any changes to the UI in <code class="literal">DetailsViewController</code> will be synced with the backend without any extra effort.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec93"/>Summary</h1></div></div></div><p>In this chapter, we developed a backend with Swift Vapor library that handles the <code class="literal">Todo</code> items <code class="literal">POST</code>, <code class="literal">GET</code>, and <code class="literal">DELETE</code>. Then, we developed a frontend iOS application that leverages functional programming, reactive programming, and state management techniques declaratively. We started by developing our <code class="literal">Todo</code> model in a functional style, and then we developed <code class="literal">Store</code> and its extensions to handle <code class="literal">State</code> storage and <code class="literal">Action</code> to handle <code class="literal">State</code> changes. We defined and used <code class="literal">Lens</code> to modify our properties and a <code class="literal">WebServiceManager</code> with reflection techniques to request for backend resources.</p><p>In this case study, we were able to use value types such as <code class="literal">struct</code> and <code class="literal">enum</code> and avoid classes. In fact, the only four classes in this case study are related to the iOS SDK (<code class="literal">UIViewController</code>, <code class="literal">UITableViewController</code>, <code class="literal">UITableViewCell</code>, and <code class="literal">UIView</code> subclasses). We were able to centralize all state mutations into <code class="literal">Store</code> only using <code class="literal">Action</code> to change the <code class="literal">State</code> in the <code class="literal">Store</code>. Although we did not develop any unit test cases, it is recommended that you explore functional programming unit testing libraries such as <span class="strong"><strong>Quick</strong></span> to ensure the quality of code.</p></div></body></html>