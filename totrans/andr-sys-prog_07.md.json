["```kt\npublic WifiManager(Context context, IWifiManager service, Looper looper) { \n    mContext = context; \n    mService = service; \n    mLooper = looper; \n    mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion; \n} \n\n```", "```kt\npublic final class WifiServiceImpl extends IWifiManager.Stub { \n    private static final String TAG = \"WifiService\"; \n    private static final boolean DBG = true; \n    private static final boolean VDBG = false; \n\n    final WifiStateMachine mWifiStateMachine; \n      private final Context mContext; \n... \n\n```", "```kt\npublic class WifiNative { \n... \n    static { \n        /* Native functions are defined in libwifi-service.so */ \n        System.loadLibrary(\"wifi-service\"); \n        registerNatives(); \n    } \n\n    private static native int registerNatives(); \n\n    public native static boolean loadDriver(); \n... \n\n```", "```kt\n/* User to register native functions */ \nextern \"C\" \njint Java_com_android_server_wifi_WifiNative_registerNatives(JNIEnv* env, jclass clazz) { \n    return AndroidRuntime::registerNativeMethods(env, \n            \"com/android/server/wifi/WifiNative\", gWifiMethods,  \n            NELEM(gWifiMethods)); \n} \n\n```", "```kt\nstatic jboolean android_net_wifi_loadDriver(JNIEnv* env, jobject) \n{ \n    return (::wifi_load_driver() == 0); \n} \n\n```", "```kt\nint wifi_load_driver() \n{ \n    char driver_status[PROPERTY_VALUE_MAX]; \n    #ifdef WIFI_DRIVER_MODULE_PATH \n    FILE *proc; \n    char line[sizeof(DRIVER_MODULE_TAG)+10]; \n    #endif \n\n    if (!property_get(DRIVER_PROP_NAME, driver_status, NULL) \n    || strcmp(driver_status, \"ok\") != 0) { \n        return 0;  /* driver not loaded */ \n    } \n    #ifdef WIFI_DRIVER_MODULE_PATH \n    /* \n     * If the property says the driver is loaded, check to \n     * make sure that the property setting isn't just left \n     * over from a previous manual shutdown or a runtime \n     * crash. \n     */ \n    if ((proc = fopen(MODULE_FILE, \"r\")) == NULL) { \n        ALOGW(\"Could not open %s: %s\", MODULE_FILE, strerror(errno)); \n        property_set(DRIVER_PROP_NAME, \"unloaded\"); \n        return 0; \n    } \n    while ((fgets(line, sizeof(line), proc)) != NULL) { \n        if (strncmp(line, DRIVER_MODULE_TAG, strlen(DRIVER_MODULE_TAG)) \n        == 0) \n        { \n            fclose(proc); \n            return 1; \n        } \n    } \n    fclose(proc); \n    property_set(DRIVER_PROP_NAME, \"unloaded\"); \n    return 0; \n    #else \n    return 1;  \n    #endif  \n} \n\n```", "```kt\nstatic jboolean android_net_wifi_startHal(JNIEnv* env, jclass cls) { \n    JNIHelper helper(env); \n    wifi_handle halHandle = getWifiHandle(helper, cls); \n    if (halHandle == NULL) { \n        if(init_wifi_hal_func_table(&hal_fn) != 0 ) { \n            ALOGD(\"Can not initialize the basic function pointer \n            table\"); \n            return false; \n        } \n\n        wifi_error res = init_wifi_vendor_hal_func_table(&hal_fn); \n        if (res != WIFI_SUCCESS) { \n            ALOGD(\"Can not initialize the vendor function pointer \n            table\"); \n            return false; \n        } \n\n        int ret = set_iface_flags(\"wlan0\", 1); \n        if(ret != 0) { \n            return false; \n        } \n\n        res = hal_fn.wifi_initialize(&halHandle); \n        if (res == WIFI_SUCCESS) { \n            helper.setStaticLongField(cls, WifiHandleVarName, \n            (jlong)halHandle); \n            ALOGD(\"Did set static halHandle = %p\", halHandle); \n        } \n        env->GetJavaVM(&mVM); \n        mCls = (jclass) env->NewGlobalRef(cls); \n        ALOGD(\"halHandle = %p, mVM = %p, mCls = %p\", halHandle, mVM, \n        mCls); \n        return res == WIFI_SUCCESS; \n    } else { \n        return (set_iface_flags(\"wlan0\", 1) == 0); \n    } \n} \n\n```", "```kt\n-netdev user,id=mynet1,net=10.0.2.0/24,dhcpstart=10.0.2.50 -device virtio-net,netdev=mynet1 \n\n```", "```kt\n$ emulator @a25x86 -qemu -netdev user,id=mynet1,net=10.0.2.0/24,dhcpstart=10.0.2.50 -device virtio-net,netdev=mynet1  \n\n```", "```kt\nBOARD_WPA_SUPPLICANT_DRIVER := WIRED \nWPA_SUPPLICANT_VERSION      := VER_0_8_X VER_2_1_DEVEL \nBOARD_WLAN_DEVICE           := eth1 \n\n```", "```kt\nifneq ($(BOARD_WPA_SUPPLICANT_DRIVER),) \n  CONFIG_DRIVER_$(BOARD_WPA_SUPPLICANT_DRIVER) := y \nendif \n\n```", "```kt\nctrl_interface=eth1 \nap_scan=2 \nupdate_config=1 \ndevice_name=x86emu \nmanufacturer=unknown \nserial_number= \ndevice_type=10-0050F204-5 \nconfig_methods=physical_display virtual_push_button \nexternal_sim=1 \n\nnetwork={ \n   ssid=\"WiredSSID\" \n   key_mgmt=NONE \n   engine=1 \n   priority=1 \n} \n\n```", "```kt\n# Wi-Fi support \nPRODUCT_PROPERTY_OVERRIDES := \\ \n    wifi.interface=eth1 \n\nPRODUCT_PACKAGES += \\ \n    libwpa_client \\ \n    hostapd \\ \n    dhcpcd.conf \\ \n    wlutil \\ \n    wpa_supplicant \\ \n    wpa_supplicant.conf \n\n# These are the hardware-specific features \nPRODUCT_COPY_FILES += \\    frameworks/native/data/etc/android.hardware.wifi.xml:system/etc/ \npermissions/android.hardware.wifi.xml \n\n# For android_filesystem_config.h \nPRODUCT_PACKAGES += \\ \n   fs_config_files \n\nPRODUCT_COPY_FILES += \\    device/generic/x86emu/wpa_supplicant.conf:data/misc/wifi/\nwpa_supplicant.conf \\  \n\n```", "```kt\n#include <private/android_filesystem_config.h> \n\n#define NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS \n/* static const struct fs_path_config android_device_dirs[] = { }; */ \n\n/* Rules for files. \n** These rules are applied based on \"first match\", so they \n** should start with the most specific path and work their \n** way up to the root. Prefixes ending in * denotes wildcard \n** and will allow partial matches. \n*/ \nstatic const struct fs_path_config android_device_files[] = { \n    { 00555, AID_WIFI, AID_WIFI, 0, \"data/misc/wifi/wpa_supplicant.conf\" }, \n#ifdef NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS \n    { 00000, AID_ROOT, AID_ROOT, 0, \"system/etc/fs_config_dirs\" }, \n#endif \n}; \n\n```", "```kt\n#!/system/bin/sh \n\n# Setup networking when boot starts \nifconfig eth0 10.0.2.15 netmask 255.255.255.0 up \nroute add default gw 10.0.2.2 dev eth0 \n... \n\n```", "```kt\nifconfig eth1 up \ndhcpcd -d eth1 \n\n```", "```kt\n... \nservice goldfish-setup /system/etc/init.goldfish.sh \n    user root \n    group root \n    oneshot  \n... \n\n```", "```kt\nservice wpa_supplicant /system/bin/wpa_supplicant -ieth1 -Dwired -c/data/misc/wifi/wpa_supplicant.conf -e/data/misc/wifi/entropy.bin -g@android:wpa_eth1 \n    class main \n    socket wpa_eth1 dgram 660 wifi wifi \n    disabled \n    oneshot \n\n```", "```kt\nint wifi_start_supplicant(int p2p_supported) \n{ \n    char supp_status[PROPERTY_VALUE_MAX] = {'\\0'};  \n    ... \n    property_get(\"wlan.interface\", primary_iface, WIFI_TEST_INTERFACE); \n\n    property_set(\"ctl.start\", supplicant_name); \n    sched_yield(); \n    ... \n} \n\n```", "```kt\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<manifest> \n\n  <remote  name=\"github\" \n           revision=\"refs/tags/android-7.1.1_r4_x86emu_ch07_r2\" \n           fetch=\".\" /> \n\n  <remote  name=\"aosp\" \n           fetch=\"https://android.googlesource.com/\" /> \n  <default revision=\"refs/tags/android-7.1.1_r4\" \n           remote=\"aosp\" \n           sync-c=\"true\" \n           sync-j=\"1\" /> \n\n  <!-- github/shugaoye --> \n  <project path=\"kernel\" name=\"goldfish\" remote=\"github\" /> \n  <project path=\"device/generic/x86emu\" name=\"x86emu\" remote=\"github\" /> \n  <project path=\"bootable/newinstaller\"   \n  name=\"platform_bootable_newinstaller\"  \n   remote=\"github\" /> \n  <project path=\"device/generic/goldfish\" \n  name=\"device_generic_goldfish\" \n   remote=\"github\" groups=\"pdk\" /> \n\n  <!-- aosp --> \n  <project path=\"build\" name=\"platform/build\" groups=\"pdk,tradefed\" > \n    <copyfile src=\"img/root.mk\" dest=\"Makefile\" /> \n  </project> \n\n  ... \n</manifest> \n\n```", "```kt\n$ repo init https://github.com/shugaoye/manifests -b android-7.1.1_r4_x86emu_ch07_r2\n$ repo sync  \n\n```", "```kt\n$ . build/envsetup.sh\n$ lunch x86emu_x86-eng\n$ make -j4  \n\n```", "```kt\nqcow2_img: \n   mkdir -p ${OUT}/system/x86emu_ch07 \n   cp ${OUT}/ramdisk.img ${OUT}/system/x86emu_ch07 \n   cd ../../..;make qcow2_img USE_SQUASHFS=0 \n\n```", "```kt\n... \ncheck_root() \n{ \n   if [ \"`dirname $1`\" = \"/dev\" ]; then \n         [ -e $1 ] || return 1 \n         blk=`basename $1` \n         [ ! -e /dev/block/$blk ] && ln $1 /dev/block \n         dev=/dev/block/$blk \n   else \n         dev=$1 \n   fi \n   try_mount ro $dev /mnt || return 1 \n   if [ -n \"$iso\" -a -e /mnt/$iso ]; then \n         mount --move /mnt /iso \n         mkdir /mnt/iso \n         mount -o loop /iso/$iso /mnt/iso \n         SRC=iso \n   elif [ ! -e /mnt/$SRC/ramdisk.img ]; then \n         return 1 \n   fi \n   zcat /mnt/$SRC/ramdisk.img | cpio -id > /dev/null \n   if [ -e /mnt/$SRC/system.sfs ]; then \n         mount -o loop /mnt/$SRC/system.sfs /sfs \n         mount -o loop /sfs/system.img system \n   elif [ -e /mnt/$SRC/system.img ]; then \n         remount_rw \n         mount -o loop /mnt/$SRC/system.img system \n   elif [ -d /mnt/$SRC/system ]; then \n         remount_rw \n         mount --bind /mnt/$SRC/system system \n   else \n echo Moving mount point to /android/system mount --move /mnt /android/system \n   fi \n   mkdir mnt \n   echo \" found at $1\" \n   rm /sbin/mke2fs \n   hash -r \n} \n... \necho -n Detecting x86emu... export DEBUG=2 export SRC=x86emu_ch07 \n... \n\n```", "```kt\n$ cd device/generic/x86emu\n$ make qcow2_img\n...\nCreated filesystem with 1976/81920 inodes and 158476/327680 blocks\nInstall system fs image: out/target/product/x86emu/system.img\nout/target/product/x86emu/system.img+ maxsize=1370278272 blocksize=2112 total=1342177280 reserve=13842048\nrm -rf out/target/product/x86emu/installer\nout/host/linux-x86/bin/acp -pr bootable/newinstaller/initrd out/target/product/x86emu/installer\nln -s /bin/ld-linux.so.2 out/target/product/x86emu/installer/lib\nmkdir -p out/target/product/x86emu/installer/android out/target/product/x86emu/installer/iso out/target/product/x86emu/installer/mnt out/target/product/x86emu/installer/proc out/target/product/x86emu/installer/sys out/target/product/x86emu/installer/tmp out/target/product/x86emu/installer/sfs out/target/product/x86emu/installer/hd\necho \"VER=x86emu_ch07\" > out/target/product/x86emu/installer/scripts/00-ver\nout/host/linux-x86/bin/mkbootfs out/target/product/x86emu/installer | gzip -9 > out/target/product/x86emu/initrd.img\nqemu-img convert -c -f raw -O qcow2 out/target/product/x86emu/system.img out/target/product/x86emu/system-qcow2.img\nmake[1]: Leaving directory `/home/roger/src/android-6'\n\n#### make completed successfully (03:30 (mm:ss)) ####\n\n```", "```kt\n$ cd $OUT \n$ emulator @a25x86 -ranchu -verbose -show-kernel -system ./system-qcow2.img -ramdisk ./initrd.img -initdata ./userdata-qcow2.img -kernel ./kernel -qemu -netdev user,id=mynet1,net=10.0.2.0/24,dhcpstart=10.0.2.50 -device virtio-net,netdev=mynet1 \n\n```", "```kt\n$ cd $OUT\n$ emulator @a25x86 -ranchu -verbose -show-kernel -system ./system-qcow2.img **-ramdisk ./ramdisk.img** -initdata ./userdata-qcow2.img -kernel ./kernel -qemu -netdev user,id=mynet1,net=10.0.2.0/24,dhcpstart=10.0.2.50 -device virtio-net,netdev=mynet1\n\n```", "```kt\n$ adb logcat -s \"wpa_supplicant\"  \n\n```", "```kt\nservice wpa_supplicant /system/bin/wpa_supplicant -ieth1 -Dwired -c/data/misc/wifi/wpa_supplicant.conf -e/data/misc/wifi/entropy.bin -g@android:wpa_eth1 -dd \n    class main \n    socket wpa_eth1 dgram 660 wifi wifi \n    disabled \n    oneshot \n\n```"]