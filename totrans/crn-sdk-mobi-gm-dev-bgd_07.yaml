- en: 'Chapter 7. Physics: Falling Objects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many variations on how to incorporate the physics engine using display
    objects. So far we have worked with removing objects with collisions, moving objects
    through the stage area, and launching objects by applying force against gravity,
    just to name a few. Now we're going to explore another mechanism that allows gravity
    to control the environment. The next game we'll be creating deals with falling
    physical objects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Points that will be discussed in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with more physics bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the body construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the objects caught
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with post-collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating falling objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's to creating another fun simple game in this segment. Let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating our new game: Egg Drop'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every step taken so far has taught us more about game development on the iOS/Android
    devices. In this new segment, our game will include sound effects, which will
    enhance the sensory experience in our games.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure that you are using the latest stable build of Corona SDK Version 2011.704.
  prefs: []
  type: TYPE_NORMAL
- en: The new game we will be creating is called **Egg Drop.** The player controls
    the main character, which is a lumberjack with a frying pan. During gameplay,
    eggs start falling from the sky and it is the lumberjack's job to catch the eggs
    in his frying pan and not let them hit the ground. Every egg caught earns 500
    points. The player starts with 3 lives. When an egg fails to hit the frying pan
    and hits the ground, a life is lost. When all 3 lives are gone, the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: When starting the new game project, be sure to grab the `Egg Drop` file from
    the `Chapter 7` folder. You can download the project files accompanying this book
    from the Packt website [www.packt.com](http://www.packt.com). It contains all
    the necessary files that are built-out for you, such as the `build.settings, config.lua,
    ui.lua`, audio files, and art assets needed for the game. You'll then have to
    create a brand new `main.lua` file in the project folder before you start coding.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our new game: Egg Drop](img/1888_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will be our first full game setup filled with notable Corona SDK features.
    We'll be combining our base knowledge of what we learned so far with variables,
    display objects, the physics engine, touch/accelerometer events, and audio. Many
    of Corona's APIs are easy to use and understand. This shows the fast learning
    curve with Corona just by having basic to no knowledge of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—setting up the variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with introducing the variables we'll be using to create our
    game. There will be a combination of display objects, integers to keep count,
    and pre-loading the main sound effects during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Hide the status bar and add in `display.newGroup()` called `gameGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Include the external modules in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the display objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the egg boundaries and density.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the accelerometer and audio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have continued creating a similar setup of our variables like in the Panda
    Star Catcher game. It's more efficient to organize them by separating groups,
    display objects, audio, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the variables displayed have designated integers that fulfill the goals
    of gameplay. This includes values such as `gameLives = 3` and `eggCount = 0`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the main character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accelerometer events work best with the main scope of the game. It enables you
    to view the full real estate of the game environment without having to interact
    with touches on the screen. Necessary touch events would make sense for user interface
    buttons such as pause, menu, play, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—moving the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eggs will be falling in all different areas of the screen from the sky. Let's
    prepare our main character to move through all potential areas on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new local function called `moveChar()` with an `event` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the accelerometer movement for the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create character boundaries where they moves on the screen. This enables the
    character to stay within the game screen and not go past the offscreen boundaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for landscape mode,
    `xGravity` and `yGravity` values are switched to compensate for the events to
    work properly.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the code in step 3 keeps the `charObject` from going past
    any wall border boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—adding touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The character is currently controlled by the accelerometer. Another option to
    control the character is through a touch event. Try replacing the event listener
    with`"touch"` and using event parameters so the touch event works properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember how we incorporated the paddle movement with Breakout in [Chapter
    3](ch03.html "Chapter 3. Building our First Game: Breakout"), *Building our First
    Game: Breakout* and [Chapter 4](ch04.html "Chapter 4. Game Controls"), *Game Controls*
    for the simulator, it should be very similar.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the score is updated, it refers to our text display objects and translates
    the value from the number into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, you will notice that we have set a values of `100`
    to `gameScore`. In the following lines for `scoreText`, the `gameScore` is used
    to concatenate the string,`"Score: "` and the value of `gameScore`. Doing so displays
    the value of `gameScore` in a string format by `scoreText`.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—setting the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Who doesn't like some friendly competition? We're familiar with scoreboards
    from the games we've made in the previous chapters. So we are no strangers on
    how to track the score.
  prefs: []
  type: TYPE_NORMAL
- en: Create a local function called `setScore()` with a parameter called `scoreNum`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set variables to count the score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Have the score updated when points are earned in gameplay and close the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `setScore(scoreNum)` is called within any function, it will refer to all
    methods using the variable `gameScore`. Assuming that the `gameScore = 0` at the
    start of the application, the value increments to what the `gameScore` is set
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `scoreText.text = "Score: " .. gameScore, "Score: "` is the string that
    displays on the device during gameplay. `gameScore` takes the current value given
    to the variable and displays it as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A logical setting for your display objects helps the player envision the relationship
    between the main character and the environment. Since our main character is a
    lumberjack, it would make sense to have him set in a forest or an area focused
    entirely on nature.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—drawing the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be filling the screen with our environment display objects.
    This includes our background and ground objects respectively and adding physical
    elements to our ground so that we can designate collision events for it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a local function called `drawBackground()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the background image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the ground elements and create the ground physical boundary. Close the
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `background` and `ground` display objects are placed in the function called
    `drawBackground()`. The function `display.newImageRect()` is used since we are
    incorporating **Dynamic Scaling** on some of our images. The `ground` display
    object has a customized physical shape that is not of the same size as the original
    display object.
  prefs: []
  type: TYPE_NORMAL
- en: Our `background` object is centered to the dimensions of the device screen area
    and inserted into `gameGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ground` display object is placed near the bottom of the display area. It
    is assigned a name through `ground.myName = "ground"`. We'll be using the name`"ground"`
    later on for determining collision events. A customized physical boundary is made
    for ground through `groundShape`. This allows the body of the ground to affect
    the assigned dimensions of the display object. When `physics.addBody()` is initialized,
    we use `groundShape` as the shape parameter. Next, `ground` is set to `gameGroup`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the heads-up display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In gaming, the **heads-up display (HUD)** is the method used to relay information
    visually to the player. In many games, the common features displayed are health/lives,
    time, weapons, menus, maps, and so on. This keeps your player on alert to what
    is currently happening during gameplay. When it comes to tracking your lives,
    you want to be informed how many are left before your character runs out of chances
    to continue playing and the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—designing the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While trying to make the player's gaming experience an enjoyable one, it's important
    that the information displayed is relevant to the game and placed strategically
    so it doesn't interfere with the main gaming area.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new local function called `hud()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Display the text for the eggs that are caught during gameplay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the text to track the lives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in text for the score and close the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—designing the HUD](img/1888_07_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `eggText` display object will be found near the bottom-right corner of
    the screen. It''s still in view to the user while in gameplay and stays out of
    the main focus point at the same time. Notice that `eggText = display.newText(
    "Caught: " .. eggCount, 0, 0, "Arial", 45 )` will refer to `eggCount` when the
    value is updated.'
  prefs: []
  type: TYPE_NORMAL
- en: The `livesText` display object setup is similar to `eggText`. It is placed in
    the top right-hand corner of the screen. The placement for this object is rather
    prominent because of its importance in the game. It's in an area that is noticeable
    from the background and allows the player to refer to during the game. `livesText`
    decrements the number when `gameLives` is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The initial setup for `scoreText` starts in the `hud()` function. It is placed
    on the top left-hand corner of the screen, opposite from `livesText`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game lives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are no consequences in a game, then there is no sense of urgency to
    complete the main objectives. To keep a player engaged during gameplay, introducing
    elements that add some challenging aspects will keep the competitiveness and excitement
    going. Adding consequences in a game creates tension for the player and gives
    them more motivation to stay alive.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—counting the lives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking the lives left in the game keeps the player updated on how much sooner
    it will be until the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the function called `livesCount()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Display the text for lives every time the number is decremented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`livesCount()` is a separate function that updates `gameLives`. It makes sure
    that you''re aware that `gameLives = gameLives -1`. This decreases the set value
    instantiated at the beginning of the code. When `gameLives` changes values, it
    displays the update through `livesText`. The `print` statement is used towards
    the end of the function to track the count in the terminal window.'
  prefs: []
  type: TYPE_NORMAL
- en: When `gameLives < 1`, the `callGameOver()` function will be called, which will
    show the game over elements of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—adding images for the game lives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the game uses display text on screen to show the count of how many
    lives are left during gameplay. A way to make the HUD display more appealing is
    by creating/adding small icons that correlate with the game such as eggs or a
    frying pan.
  prefs: []
  type: TYPE_NORMAL
- en: Three separate display objects need to be created and placed in an orderly fashion
    so that when a life is taken away, the alpha of the object is reduced to `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: A method needs to be created so that all the three display objects are affected
    when the game lives are reduced to `0.`
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the main character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our main character will be animated for every action applied during gameplay.
    We will also create a **complex body construction** since the focus on its collision
    points will be towards the object he is holding and not his entire body.
  prefs: []
  type: TYPE_NORMAL
- en: Complex body construction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to construct a body from multiple elements. Each body element
    is specified as a separate polygon shape with its own physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: Since collision polygons in **Box2D** must be convex, any game object with a
    concave shape must be constructed by appending multiple body elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for a complex body is the same as the simple polygon body constructor,
    except with more than one body element listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Each body element may have its own physical properties, along with a shape
    definition for its collision boundaries. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As in simpler cases, the `bodyType` attribute is optional and will default to`"dynamic"`
    if not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—creating the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main character was created with a sprite sheet and needs to be set up to
    view the animation it provides. Other display images that will make an appearance
    include a cracked egg when a collision to a physical object has been made.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new local function called `createChar()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the sprite sheet for the main character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the starting position and physical properties for the main character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the transition image after the egg has made a collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—creating the character](img/1888_07_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sprite sheet being referred to is called `spriteSet` and takes the first
    `4` frames of animation from`"charSprite.png"`. We created an animation set through
    `sprite.add( spriteSet, "move", 1, 4, 400, 0 )`. Every time`"move"` is called,
    it starts the animation from frame `1` and plays `4` frames from the start at
    `400` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The main display object is called `charObject` that takes on the characteristics
    of `spriteSet`. When it calls `prepare("move")`, that animation sequence plays
    when the `play()` command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: An important change to the physical body of the character is that its main collision
    point will be directed towards the frying pan used in the animation. Any collision
    detection on the character's body will not be read. The `charObject` is given
    a name called`"character"`, which will be used to detect the collision even with
    the falling egg.
  prefs: []
  type: TYPE_NORMAL
- en: We have also placed the fried egg in this function for preparation on the collision.
  prefs: []
  type: TYPE_NORMAL
- en: Adding post-collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to make sure that an event type occurs right after an object has interacted
    with another object. At the instance of a post-collision, we can confirm the collision
    force between two objects. This helps us determine that the object that is destroyed
    was completed with a set amount of force.
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful on how you handle the Box2D physics engine. It will crash during
    a collision if Corona code attempts to modify objects still involved in the collision,
    since Box2D is still working out iterated mathematics on them.
  prefs: []
  type: TYPE_NORMAL
- en: For crash-proof collision detection, do not have collisions occur immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Do not modify/create/destroy physics objects during a collision in order to
    prevent crashing.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to modify/create/destroy an object as a result of a collision, your
    collision handler should set a flag or add a time delay so the change can occur
    later with `timer.performWithDelay()`.
  prefs: []
  type: TYPE_NORMAL
- en: Body properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the native Box2D methods have been made into simpler dot properties
    for display objects. The following examples show that a body, `newBody`, has been
    created using one of the constructor methods.
  prefs: []
  type: TYPE_NORMAL
- en: body.isAwake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for the current awake state. By default, all bodies automatically
    *go to sleep* when there is no interaction with them for a couple of seconds.
    Bodies stop simulating until some kind of collision or other interaction wakes
    them up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: body.isBodyActive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for the active state of a body. Inactive bodies are not destroyed,
    but they are removed from the simulation and cease to interact with other bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: body.isBullet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body that is treated like a *bullet*. Bullets are subject
    to continuous collision detection. The default is `false.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: body.isSensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean property that sets the `isSensor` property across all elements
    in the body. A sensor passes through other objects instead of bouncing off them,
    but detects some collision. This property acts across all body elements and will
    override any `isSensor` settings on the elements themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: body.isSleepingAllowed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body that is allowed to go to sleep. A body that is
    awake is useful in cases such as tilt-gravity since sleeping bodies do not respond
    to changes in global gravity. The default is `true.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: body.isFixedRotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body whose rotation should be locked, even if the body
    is about to load or subjected to off-center forces. The default is `false.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: body.angularVelocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value of the current rotational velocity in degrees per second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: body.linearDamping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value for how much the linear motion of a body is damped. This is
    the rate of decrease of angular velocity over time. The default is `0`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: body.angularDamping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value for how much the rotation of a body should be damped. The default
    is `0.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: body.bodyType
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a string value for the type of physical body being simulated. The available
    values are`"static", "dynamic"`, and`"kinematic":`
  prefs: []
  type: TYPE_NORMAL
- en: '`static` bodies don''t move or interact with each other. Examples of static
    objects would include the ground or the walls of a maze.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic` bodies are affected by gravity and collisions with other body types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kinematic` objects are affected by forces but not by gravity. Bodies that
    are draggable objects should be set to`"kinematic"` for the duration of the drag
    event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default body type is`"dynamic"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Time for action—creating the egg collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have handled collisions in the previous sample games we created. Handling
    post-collisions requires the introduction of force to execute the completion of
    a post-collision event.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new local function called `onEggCollision()` with two parameters called
    `self` and `event`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an `if` statement when force is greater than `1` and `not self.isHit`.
    Add in the `eggCaughtSound` sound effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make `self` invisible and inactive and replace it with the `friedEgg` display
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a function that transitions the `friedEgg` display object and makes it
    fade on the stage using the `onComplete` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `if event.other.myName == "character"`, update the `eggCount` when the
    main character catches the eggs. Also update the `gameScore` by `500` points for
    every collision. If the egg hits the ground, use `elseif event.other.myName ==
    "ground"` and decrement the lives using `livesCount()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—creating the egg collision](img/1888_07_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `onEggCollision( self, event )`, we set up the function with the `if`
    statement for `event.force > 1 and not self.isHit`. When both statements return
    `true`, the sound effect for the egg plays. The initial egg falling from the sky
    is removed from the scene upon collision and replaced by the `friedEgg` display
    object in the same location using `friedEgg.x = self.x; friedEgg.y = self.y`.
  prefs: []
  type: TYPE_NORMAL
- en: The function `fadeEgg()` makes the newly replaced egg object appear in `50`
    milliseconds by `transition.to( eggCrack, { time=50, alpha=1.0, onComplete=fadeCrack
    } )` and then with the `onComplete` command, returns the object to an invisible
    state with `transition.to( eggCrack, { time=500, alpha=0 } )`.
  prefs: []
  type: TYPE_NORMAL
- en: When the name`"character"` is called from `event.other.myName`, every collision
    is assigned to that name increments `eggCount + 1`. Therefore, the `eggText` is
    updated with `eggCount` value. `setScore( newScore )` increments the score by
    `500` with every collision made to`"character"`. When a collision is made to`"ground"`,
    the `livesCount()` function is called, which subtracts a life by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Making the display objects fall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to apply the main asset by learning how to add physical objects
    to the scene and have them fall in random areas in the game. The physics engine
    will take into account a dynamic physics body that we will create for the egg
    display object.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding the egg object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a world full of falling eggs. It's not entirely too realistic, but in
    this game, we're creating this element. At least we'll be making sure that the
    gravity and real-world physics will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new local function called `eggDrop()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `egg` display object properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `postCollision` event for the `egg` display object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—adding the egg object](img/1888_07_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set the `egg` value for `x` to `240 + mRand( 120 )`. The `mRand` function
    equals to `math.random` , which will allow the `egg` to appear in randomized places
    in an area of `120` pixels starting at 50 in the x-direction.
  prefs: []
  type: TYPE_NORMAL
- en: It is vital to make sure `egg.isHit = false` for the collision event to apply
    correctly. The physics body is set to`"dynamic"` so it reacts to gravity and makes
    the object fall. There is a customized density and shape made for the `egg` that
    we created, which is already made at the beginning of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The last important detail for the collision to work is adding `egg` to the `onEggCollision()`
    function with `egg.postCollision = onEggCollision` and then making the event listener
    use the`"postCollision"` event with `egg:addEventListener( "postCollision", egg
    )`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—making the egg drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to execute the timer for the egg so they can start dropping them
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Create a local function called `eggTimer()` and use `timer.performWithDelay`
    to drop an egg every 1 second (1000 milliseconds) repeatedly. Use `eggDrop()`
    to activate the drop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the first `if` statement in the `onEggCollision()` function, cancel the
    timer using the `timerID, startDrop`. Add the statement `if gameLives < 1` to
    stop the eggs from falling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for the eggs to start dropping from the sky, we created a function
    called `eggTimer()`. It activates the `eggDrop()` function by letting an egg drop
    after `1000` milliseconds (1 second) every time infinitely using `startDrop =
    timer.performWithDelay( 1000, eggDrop, 0 )`.
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking to `onEggCollision()`, we want to check that `gameLives` has reached
    less than `1`. When this statement is true, the eggs will stop dropping. This
    is done by `timer.cancel( startDrop ). startDrop` is the `timerID` we set in `eggTimer()`.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the gameplay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every start of a game always has an ending. Whether it is a simple *You Win*
    or *You lose* or just a *Game Over* it gives closure for the player. It's important
    to notify a player of such events so that they can reflect on the achievements
    earned.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—calling game over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to make sure that when a **Game Over** display screen pops up,
    any of our display objects currently in motion stop moving and the event listeners
    are deactivated. Aside from the visual display of our **Game Over** screen, we'll
    be adding a sound notification that will also help to trigger the event.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new local function called `callGameOver()` and place it after the `setScore()`
    function and before the `drawBackground()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduce the sound effects when the **Game Over** display pops up. Have `gameIsActive`
    set to `false` and pause the physics in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a shade that overlays over the current background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Display the **Game Over** window and reiterate the final score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Have the **Score** displayed on the **Game Over** screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—calling game over](img/1888_07_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `gameOver()` function triggers our `gameOverSound` sound effect that we
    pre-loaded at the beginning of our code. We made sure no events such as the motion
    from the accelerometer are disabled through `gameIsActive = false`.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of our display objects appear at this point in time with `shade,
    gameOverScreen`, and `scoreText`.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, `scoreText` disappears when gameplay has ended by `scoreText.isVisible
    = false` and then reappears in a different area of the screen using `timer.performWithDelay(
    0, function() scoreText.isVisible = true; end, 1 )`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to activate all the remaining functions and have them run accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—activating the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the gameplay elements set in place, it is time to get the application
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new local function called `gameActivate()` and insert `gameIsActive
    = true`. Place the function above the `moveChar()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initialize all the game actions by making a new function called `gameStart()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the physics property and set the gravity for the falling object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Activate all the functions instantiated. Add an event listener for the `charObject`
    using the`"touch"` for the `moveChar()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instantiate the `gameStart()` function and return the group `gameGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember, in the beginning of our code, we set `gameIsActive = false`.
    We then changed that status through the `gameActivate()` function and made `gameIsActive
    = true`. We made the `gameStart()` function apply all the initial gameplay elements.
    This included the start of the physics engine and gravity. At the same time, we
    took the remainder of all the functions and initialize them.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the functions are activated, `gameGroup` needs to be returned so that
    all the display objects appear during the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that your physical object boundaries for your display objects are
    in the right place, use `physics.setDrawMode( "hybrid" )` in the `gameStart()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz—animating the graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What retrieves or sets the text string of a text object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `object.text`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `object.size`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `object:setTextColor()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What function converts any argument into a string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `tonumber()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `print()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `tostring()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. `nil`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What body type is affected by gravity and collisions with other body types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Dynamic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. Kinematic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. Static
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The gameplay construction of our application is now completed. Now that we're
    familiar with a variety of ways to use the physics engine, it goes to show the
    ease of using Box2D and designing other games that involve physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a better idea of:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the uses of dynamic and static physics bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a customized shape for the physical properties of our display objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the number of objects caught using values from variables that are given
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using post-collisions to switch out images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will complete the gaming experience by creating versatile
    menu screens using **Storyboard API**. We will also learn how to add the pause
    action, save high scores, and understand more about data saving and unloading
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Using Corona SDK has helped us design and develop games in a minimal amount
    of time. Let us continue adding the final touches to our game!
  prefs: []
  type: TYPE_NORMAL
