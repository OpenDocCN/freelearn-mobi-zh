<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Types and Type casting</h1></div></div></div><p>This chapter starts with explaining types, touching on the concept of type in the category theory very briefly. Then, it explains value and reference types and compares them in detail. Finally, it talks about equality, identity, and type casting.</p><p>This chapter will cover the following topics with coding examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Types</li><li class="listitem" style="list-style-type: disc">Value versus reference types<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Value and reference type constants</li><li class="listitem" style="list-style-type: disc">Mixing value and reference types</li><li class="listitem" style="list-style-type: disc">Copying</li><li class="listitem" style="list-style-type: disc">Value type characteristics</li></ul></div></li><li class="listitem" style="list-style-type: disc">Equality, identity, and comparing</li><li class="listitem" style="list-style-type: disc">Type checking and casting</li></ul></div><p>You may have heard that functional programming uses concepts of the category theory. This link is the reason why some people find functional programming closer to mathematics. In an upcoming chapter, we will talk briefly about the category theory so we are not going to dive into those concepts now. At this point, it is good to know that theoretically category refers to a collection that contains the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A collection of objects (types in Swift)</li><li class="listitem" style="list-style-type: disc">A collection of morphisms, each of which ties two objects together (functions in Swift)</li><li class="listitem" style="list-style-type: disc">A notion of composition of the morphisms (function composition in Swift)</li></ul></div><p>We have already discussed functions and function composition and now we are going to explore types.</p><p>It is possible to categorize types in two different ways. The first is the concept of named types and compound types in Swift. The second is the categorization of types based on value versus reference.</p><p>Any type that we can give a name to while we define it is a named type. For instance, if we create a class named <code class="literal">OurClass</code>, any instance of <code class="literal">OurClass</code> will be of the <code class="literal">OurClass</code> type.</p><p>Function types and tuple types are compound types. A compound type may contain named types and other compound types. For instance, <code class="literal">(String, (Double, Double))</code> is a compound type and in fact is a tuple of <code class="literal">String</code> and another tuple of the <code class="literal">(Double, Double)</code> type.</p><p>We can use named types and compound types in type annotation, identification, and aliasing.</p><p>In previous chapters, we have seen that we can use Swift inference that infers the types unless we want to specify the type explicitly. We annotate the type in case we need to specify the type explicitly.</p><p>Also, we did not talk a lot about reference versus value types and type casting. In the following sections of this chapter, we will explore these concepts.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Value versus reference types</h1></div></div></div><p>In Swift, there are two kinds of types: value and reference.</p><p>Value type instances keep a copy of their data. Each type has its own data and is not referenced by another variable. <code class="literal">Structures</code>, <code class="literal">enums</code>, and <code class="literal">tuples</code> are value types; therefore, they do not share data between their instances. Assignments copy the data of an instance to the other and there is no reference counting involved. The following example presents a <code class="literal">struct</code> with copying:</p><pre class="programlisting">struct ourStruct {&#13;
    var data: Int = 3&#13;
}&#13;
&#13;
var valueA = ourStruct()&#13;
var valueB = valueA // valueA is copied to valueB&#13;
valueA.data = 5 // Changes valueA, not valueB&#13;
print("\(valueA.data), \(valueB.data)") // prints "5, 3"&#13;
</pre><p>As seen from the preceding example, changing <code class="literal">valueA.data</code> does not change <code class="literal">valueB.data</code>.</p><p>In Swift, arrays, dictionaries, strings, and sets are all value types.</p><p>On the other hand, reference type instances share the same copy of the data. Classes and closures are reference types so assignment only adds a reference but does not copy the data. In fact, initialization of a reference type creates a shared instance that will be used by different instances of a reference type such as class or closure. Two variables of the same class type will refer to a single instance of the data, so if we modify the data in one of the variables, it will also affect the other variable. The following example presents a class with referencing:</p><pre class="programlisting">class ourClass {&#13;
    var data: Int = 3&#13;
}&#13;
var referenceA = ourClass()&#13;
var referenceB = referenceA // referenceA is copied to referenceB&#13;
referenceA.data = 5 // changes the instance referred to by&#13;
  referenceA and referenceB&#13;
print("\(referenceA.data), \(referenceB.data)") // prints "5, 5"&#13;
</pre><p>As seen from the preceding example, changing <code class="literal">referenceA.data</code> also changes <code class="literal">referenceB.data</code> as they refer to the same shared instance.</p><p>This fundamental difference between value and reference types can have a huge impact on our system architecture. In functional programming, it is recommended to prefer value types over reference types as it is easier to trace and reason about value types. As we always get a unique copy of data and the data is not shared among instances, we can reason that no other part of our program is going to change the data. This feature of value types makes them especially helpful in multithreaded environments where a different thread will be able to change our data without informing us. This can create bugs that are very hard to debug and fix.</p><p>To be able to use this feature in Swift with classes, we can develop immutable classes using only immutable stored properties and avoiding exposing any APIs that can alter state. However, Swift does not provide any language mechanism to enforce class immutability the way it enforces immutability for <code class="literal">struct</code> and <code class="literal">enum</code>. Any API user can subclass our provided class and make it mutable unless we define them as <strong>final</strong>. This is not the case with <code class="literal">struct</code>, <code class="literal">enum</code>, and <code class="literal">tuples</code> as basically we cannot subclass them.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Value and reference type constants</h2></div></div></div><p>Constants behave differently if they are value or reference types. We will be able to change the variables in a constant class but we cannot change them for structs.</p><p>Let's examine the following example:</p><pre class="programlisting">class User {&#13;
    var name: String&#13;
    init(name: String) {&#13;
        self.name = name&#13;
    }&#13;
}&#13;
&#13;
let julie = User(name: "Julie")&#13;
let steve = User(name: "Steve")&#13;
&#13;
struct Student {&#13;
    var user: User&#13;
}&#13;
&#13;
let student = Student(user: julie)&#13;
student.user = steve // compiler error - cannot assign to&#13;
  property: 'student' is a 'let' constant</pre><p>In this example, we have a class named <code class="literal">User</code> and two constants that point to the instance of the class. Also, we have a <code class="literal">Student</code>
<code class="literal">struct</code> that has a variable of the <code class="literal">User</code> type.</p><p>We create <code class="literal">student</code> using the <code class="literal">Student</code> structure. If we try to change the <code class="literal">user</code> variable in <code class="literal">student</code>, the compiler gives us an error telling that <code class="literal">student</code> is a constant even though we defined <code class="literal">user</code> as a variable.</p><p>So we cannot change any variable in <code class="literal">struct</code> if we instantiate it as a constant. In other words, <code class="literal">let student = Student(user: julie)</code> makes the whole <code class="literal">struct</code> immutable.</p><p>Let's try the same operation with classes. In the following code, we change the name of <code class="literal">steve</code>, which is defined as a constant. The compiler does not give us an error and accepts this assignment.</p><pre class="programlisting">steve.name = "Steve Jr." &#13;
steve.name // prints "Steve Jr." &#13;
</pre><p>Even though we defined <code class="literal">steve</code> as a constant, we could change the <code class="literal">name</code> variable as it was a <code class="literal">class</code>.</p><p>From the preceding examples, we have seen that we can change the value of a variable on a constant that is an instance of a <code class="literal">class</code> (reference type), but we cannot change the value of a variable on a constant that is an instance of a <code class="literal">struct</code> (value type).</p><p>As <code class="literal">steve</code> is an instance of a reference type, it refers to the instance of <code class="literal">User</code>. When we change <code class="literal">name</code>, we are not actually changing what <code class="literal">steve</code> is, which is a reference to <code class="literal">User</code>. We change the name that we made mutable by defining it as a variable. This is not the case for our <code class="literal">student</code> constant as it is a value type. Defining it as a constant makes its variables constant too.</p><p>This property of reference types makes them hard to track and since we are defining them as constants, it is not going to make them immune to changes. To be able to make them immutable, we will need to define their properties as constants.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Mixing value and reference types</h2></div></div></div><p>In real-world problems, we may need to mix reference types with value types. For instance, we may need to have a reference to <code class="literal">class</code> in <code class="literal">struct</code> like our previous example or we may need to have a <code class="literal">struct</code> variable in <code class="literal">class</code>. How would we reason about the assignments and copying in these circumstances?</p><p>Let's examine the following example:</p><pre class="programlisting">class User {&#13;
    var name: String&#13;
    init(name: String) {&#13;
        self.name = name&#13;
    }&#13;
}&#13;
let julie = User(name: "Julie")&#13;
&#13;
struct Student {&#13;
    var user: User&#13;
}&#13;
&#13;
let student = Student(user:julie)&#13;
student.user.name // prints "Julie"&#13;
let anotherStudent = student&#13;
julie.name = "Julie Jr."&#13;
anotherStudent.user.name // prints "Julie Jr."&#13;
</pre><p>In this example, we have a <code class="literal">User</code> class, a <code class="literal">Student</code> struct that has the user variable. We define a constant, <code class="literal">student</code> with <code class="literal">julie</code>, which is of the <code class="literal">class</code> type. If we print <code class="literal">student.user.name</code>, the result will be <code class="literal">julie</code>.</p><p>Now if we define <code class="literal">anotherStudent</code> and copy <code class="literal">student</code> to it by assignment, changing the name of Julie will change the name of <code class="literal">anotherStudent</code> too.</p><p>We would expect <code class="literal">anotherStudent</code> to have a copy of <code class="literal">student</code> but <code class="literal">name</code> has been changed. It is changed because the <code class="literal">user</code> variable is of the <code class="literal">User</code> type, which is <code class="literal">class</code> and therefore a reference type.</p><p>This example presents the complexity of using reference types in value types. To avoid these complications, it is recommended to avoid using reference type variables inside value types. If we need to use reference types in our value types, as we have stated before, we should define them as constants.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Copying</h2></div></div></div><p>Assignment operations on value types copy values from one value type to another value type. There are two types of copying in different programming languages, shallow and deep copying.</p><p>Shallow copying duplicates as little as possible. For instance, a shallow copy of a collection is a copy of the collection structure, not its elements. With a shallow copy, two collections share the same individual elements.</p><p>Deep copying duplicates everything. For instance, a deep copy of a collection results in another collection with all of the elements in the original collection duplicated.</p><p>Swift does the shallow copying and does not provide a mechanism for deep copying. Let's examine an example to understand shallow copying:</p><pre class="programlisting">let julie = User(name: "Julie")&#13;
let steve = User(name: "Steve")&#13;
let alain = User(name: "Alain")&#13;
let users = [alain, julie, steve]&#13;
</pre><p>In the preceding example, we created a new <code class="literal">User</code> named <code class="literal">alain</code> and added three users to a new array named <code class="literal">users</code>. In the following example, we copy the <code class="literal">users</code> array to a new array named <code class="literal">copyOfUsers</code>. Then we change the name of one of our users in the <code class="literal">users</code> array as follows:</p><pre class="programlisting">let copyOfUsers = users&#13;
users[0].name = "Jean-Marc"&#13;
&#13;
print(users[0].name) // prints "Jean-Marc"&#13;
print(copyOfUsers[0].name) // prints "Jean-Marc"&#13;
</pre><p>Printing <code class="literal">users</code> and <code class="literal">copyOfUsers</code> will show us that changing <code class="literal">name</code> of <code class="literal">Alain</code> to <code class="literal">Jean-Marc</code> in the <code class="literal">users</code> array has changed the name of <code class="literal">Alain</code> in <code class="literal">copyOfUsers</code> to <code class="literal">Jean-Marc</code> too. The <code class="literal">users</code> and <code class="literal">copyOfUsers</code> are arrays, and we would expect assignment expression to copy the values from <code class="literal">users</code> to <code class="literal">copyOfUsers</code> as arrays are value types but, as we have seen from the preceding example, changing the name of <code class="literal">user</code> in one array changed the username in the copied array. There are two reasons for this behavior. First of all, <code class="literal">User</code> is a type of <code class="literal">class</code>. So it is a reference type. Secondly, Swift does the shallow copying.</p><p>Shallow copying does not provide a distinct copy of an instance as we have seen in this example. Shallow copying duplicates the references to the same elements of the instance. So again, this example presents complications with using reference types in value types as Swift does not provide deep copying to overcome these complications.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Copying reference types</h2></div></div></div><p>Two variables can point to the same object so changing one variable changes the other too. Having lots of objects point to the same data can be useful in some circumstances, but mostly we will want to modify copies so that modifying one object doesn't have an effect on the others. To make this work, we need to do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our class should be of the <code class="literal">NSObject</code> type</li><li class="listitem" style="list-style-type: disc">Our class should conform to the <code class="literal">NSCopying</code> protocol (which is not mandatory but makes our intent clear for our API user)</li><li class="listitem" style="list-style-type: disc">Our class should implement the <code class="literal">copy(with: NSZone)</code> method</li><li class="listitem" style="list-style-type: disc">To copy the object, we will need to call the <code class="literal">copy()</code> method on the object</li></ul></div><p>Here's an example of a <code class="literal">Manager</code> class that conforms fully to the <code class="literal">NSCopying</code> protocol:</p><pre class="programlisting">class Manager: NSObject, NSCopying {&#13;
    var firstName: String&#13;
    var lastName: String&#13;
    var age: Int&#13;
 &#13;
    init(firstName: String, lastName: String, age: Int) {&#13;
        self.firstName = firstName&#13;
        self.lastName = lastName&#13;
        self.age = age&#13;
    }&#13;
 &#13;
    func copy(with: NSZone? = nil) -&gt; AnyObject {&#13;
        let copy = Manager(firstName: firstName, lastName: lastName,&#13;
          age: age)&#13;
        return copy&#13;
    }&#13;
}&#13;
</pre><p>The <code class="literal"> copyWithZone()</code> function is implemented by creating a new <code class="literal">Manager</code> object using the information of current <code class="literal">Manager</code>. To test our class, we create two instances and copy one instance over the other as follows:</p><pre class="programlisting">let john = Manager(firstName: "John", lastName: "Doe", age: 35)&#13;
let jane = john.copy() as! Manager&#13;
&#13;
jane.firstName = "Jane"&#13;
jane.lastName = "Doe"&#13;
jane.age = 40&#13;
&#13;
print("\(john.firstName) \(john.lastName) is \(john.age)")&#13;
print("\(jane.firstName) \(jane.lastName) is \(jane.age)")&#13;
</pre><p>The result will be as follows:</p><pre class="programlisting">"John Doe is 35"&#13;
"Jane Doe is 40"&#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Value type characteristics</h2></div></div></div><p>We have examined the notion of value types and reference types. We have looked into simple scenarios of value type versus reference type usage. We understand that using value types makes our code simpler and easier to trace and reason. Now let's look into the characteristics of value types in more detail.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec48"/>Behavior</h3></div></div></div><p>Value types do not behave. A value type stores data and provides methods to use its data. A value type can only have a single owner and it does not have deinitializers as there are no references involved. Some of the value type methods may cause the value type to mutate itself, but control flow is rigidly controlled by the single owner of the instance. As the code will only execute when directly invoked by a single owner and not from many sources, it is easy to reason about the value type code execution flow.</p><p>On the other hand, a reference type might subscribe itself as a target of other systems. It might receive notifications from other systems. This sort of interactions require reference types as they can have multiple owners. It's unnecessarily difficult to develop value types that perform side effects on their own in most of the cases.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec49"/>Isolation</h3></div></div></div><p>A typical value type has no implicit dependencies on the behavior of any external system. Therefore, a value type is isolated. It interacts only with its owner and it is easy to understand how it interacts in comparison to a reference type's interactions with multiple number of owners.</p><p>If we access a reference to a mutable instance, we have an implicit dependency on all its other owners and they could change the instance at any time without notifying us.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec50"/>Interchangeability</h3></div></div></div><p>As a value type is copied when it is assigned to a new variable, all of those copies are completely interchangeable.</p><p>We can safely store a value that is passed to us, then later utilize this value as if it were a new value. It will not be possible to compare the instance with another instance using anything but its data.</p><p>Interchangeability also means that it does not matter how a given value was defined. Two value types are equal by all means if comparing them via <code class="literal">==</code> results in equality.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec51"/>Testability</h3></div></div></div><p>There is no need for a mocking framework to write unit tests that deal with value types. We can directly define values indistinguishable from the instances in our applications.</p><p>If we use reference types that behave, we have to test the interactions between the reference type that we will test and the rest of the system. This typically means a lot of mocking or extensive setup code to establish the required relationships.</p><p>In contrast, value types are isolated and interchangeable, so we can directly define a value, call a method, and examine the result. Simpler tests with greater coverage yield a code that is easier to change and maintain.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec52"/>Threats</h3></div></div></div><p>While the structure of value types encourages testability, isolation, and interchangeability, one can define value types that diminish these advantages. Value types containing code that executes without being called by its owner are generally hard to track and reason about, and should often be avoided.</p><p>Also, value types containing reference types are not necessarily isolated. Using reference types in value types should generally be avoided as they are dependent on all other owners of that referent. These kinds of value types are also not easily interchangeable as the external reference might interact with the rest of the system and cause some complications.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Using value and reference types</h2></div></div></div><p>
<em>The Swift Programming Language (Swift 3.0)</em> by<em>Apple Inc.</em> has a section on comparing structs (value type) and classes (reference type) and how to prefer one over the other. It is highly recommended to read that section to understand why we prefer one over the other. Although we touched on the topic briefly in <em>

<a class="link" href="ch01.html" title="Chapter 1. Getting Started with Functional Programming in Swift">Chapter 1</a>

</em>, <em>Getting Started With Functional Programming in Swift</em>, we will explore this topic further as the distinction between reference and value types is very important in functional programming.</p><p>In object-oriented programming, we model real-world objects as classes and interfaces. For instance, to model an Italian restaurant with different types of pizzas, we may have a pizza object and subclasses of it such as margherita, napoletana, or romana. Each of these pizzas will have different ingredients. Different restaurants may make them slightly differently, and whenever we read their recipes in different books or websites, we may understand it differently. This level of abstraction enables us to refer to a specific pizza without caring about how other people really imagine that pizza. Whenever we talk about that pizza, we do not transfer it, we just refer to it.</p><p>On the other hand, in our Italian restaurant, we will need to provide bills to our customers. Whenever they ask for the bill, we are going to provide real information about quantity and prices. Anyone has the same perception about quantities, prices in dollars, and in fact values. Our customers can calculate the invoice total. If our customers modify the bill, it is not going to modify the source that we used to provide the bill. No matter if they write something on the bill or spill wine on it, the value and bill total amount is not going to change. The preceding example presents a simple real-world usage of reference versus value types. Value types and reference types have their own usages in the Swift programming language and in web, mobile, or desktop application programming.</p><p>Value types enable us to make architectures clearer, simpler, and more testable. Value types typically have fewer or no dependencies on the outside state, so there's less that we have to consider when reasoning about them.</p><p>Also, value types are essentially more reusable because they are interchangeable.</p><p>As we use more value types and immutable entities, our system will become easier to test and maintain over time.</p><p>In contrast, reference types are acting entities in the system. They have identity. They can behave. Their behavior is often complex and hard to reason about, but some of the details can usually be represented by simple values and isolated functions involving those values.</p><p>Reference types maintain state defined by values, but these values can be considered independently of the reference type.</p><p>Reference types perform side effects such as I/O, file and database operations, and networking.</p><p>Reference types can interact with other reference types, but they generally send values, not references, unless they truly plan to create a persistent connection with the external system.</p><p>It is important to use value types (<code class="literal">enums</code>, <code class="literal">tuples</code>, or <code class="literal">structs</code>) as much as possible unless we need to create a shared mutable state. There are cases where we have to use classes. For instance, when we work with <strong>Cocoa</strong>, many APIs expect subclasses of <code class="literal">NSObject</code> so we have to use classes in these cases. Whenever we need to use classes, we avoid variables; we define our properties as constants and avoid exposing any APIs that can alter states.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Equality versus identity</h1></div></div></div><p>Two instances are equal if they have the same value. Equality is used to determine the equality of two value types. For instance, two <code class="literal">Strings</code> are equal if they have the same text value. The <code class="literal">==</code> operator is used to check for equality. The following example presents equality checking for two <code class="literal">Int</code> numbers (<code class="literal">Int</code> is a value type):</p><pre class="programlisting">let firstNumber = 1&#13;
let secondNumber = 1&#13;
&#13;
if firstNumber == secondNumber {&#13;
    print("Two numbers are equal") // prints "Two numbers are equal\n"&#13;
}&#13;
</pre><p>On the other hand, two instances are identical if they refer to the same instance of memory. Identity is used to determine if two reference types are identical. The <code class="literal">===</code> operator is used to check for identity. The following example presents identity checking for two instances of the <code class="literal">User</code> class that we have defined earlier:</p><pre class="programlisting">let julie = User(name: "Julie")&#13;
let steve = User(name: "Steve")&#13;
&#13;
if julie === steve {&#13;
    print("Identical")&#13;
} else {&#13;
    print("Not identical")&#13;
}&#13;
</pre><p>The identity checking operator is available only for reference types.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Equatable and Comparable</h1></div></div></div><p>We are able to compare two value types such as <code class="literal">String</code>, <code class="literal">Int</code>, and <code class="literal">Double</code>, but we cannot compare two value types that we have developed. To make our custom value types comparable, we need to implement Equatable and Comparable protocols. Let's first examine an example of equality checking without conforming to protocols:</p><pre class="programlisting">struct Point {&#13;
    let x: Double&#13;
    let y: Double&#13;
}&#13;
&#13;
let firstPoint = Point(x: 3.0, y: 5.5)&#13;
let secondPoint = Point(x: 7.0, y: 9.5)&#13;
&#13;
let isEqual = (firstPoint == secondPoint)&#13;
</pre><p>In this example, the compiler will complain that <strong>Binary operator '==' cannot be applied to two 'Point' operands</strong>. Let's fix this problem by conforming to the <code class="literal">Equatable</code> protocol:</p><pre class="programlisting">struct Point: Equatable {&#13;
    let x: Double&#13;
    let y: Double&#13;
}&#13;
&#13;
func ==(lhs: Point, rhs:Point) -&gt; Bool {&#13;
    return (lhs.x == rhs.x) &amp;&amp; (lhs.y == lhs.y)&#13;
}&#13;
&#13;
let firstPoint = Point(x: 3.0, y: 5.5)&#13;
let secondPoint = Point(x: 7.0, y: 9.5)&#13;
&#13;
let isEqual = (firstPoint == secondPoint)&#13;
</pre><p>The value for <code class="literal">isEqual</code> is going to be false as they are not equal. To be able to compare two points, we need to conform to the <code class="literal">Comparable</code> protocol. Our example becomes as follows:</p><pre class="programlisting">struct Point: Equatable, Comparable {&#13;
    let x: Double&#13;
    let y: Double&#13;
}&#13;
&#13;
func ==(lhs: Point, rhs:Point) -&gt; Bool {&#13;
    return (lhs.x == rhs.x) &amp;&amp; (lhs.y == lhs.y)&#13;
}&#13;
&#13;
func &lt;(lhs: Point, rhs: Point) -&gt; Bool {&#13;
    return (lhs.x &lt; rhs.x) &amp;&amp; (lhs.y &lt; rhs.y)&#13;
}&#13;
&#13;
let firstPoint = Point(x: 3.0, y: 5.5)&#13;
let secondPoint = Point(x: 7.0, y: 9.5)&#13;
&#13;
let isEqual = (firstPoint == secondPoint)&#13;
let isLess = (firstPoint &lt; secondPoint)&#13;
</pre><p>The result of the comparison will be true.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Type checking and casting</h1></div></div></div><p>Swift provides type checking and type casting. We can check the type of a variable with the <code class="literal">is</code> keyword. It is most commonly used in <code class="literal">if</code> statements, as shown in the following code:</p><pre class="programlisting">let aConstant = "String"&#13;
&#13;
if aConstant is String {&#13;
    print("aConstant is a String")&#13;
} else {&#13;
    print("aConstant is not a String")&#13;
}&#13;
</pre><p>As <code class="literal">String</code> is a value type and the compiler can infer the type, the Swift compiler will issue a warning because it already knows that <code class="literal">aConstant</code> is <code class="literal">String</code>. Another example can be the following, where we check whether <code class="literal">anyString</code> is <code class="literal">String</code>:</p><pre class="programlisting">let anyString: Any = "string"&#13;
&#13;
if anyString is String {&#13;
    print("anyString is a String")&#13;
} else {&#13;
    print("anyString is not a String")&#13;
}&#13;
</pre><p>Using the <code class="literal">is</code> operator is useful to check the type of a class instance, specifically, the ones that have subclasses. We can use the <code class="literal">is</code> operator to determine if an object is an instance of a specific class.</p><p>Similarly, we can use the <code class="literal">as</code> operator to actually coerce an object to another type than what the compiler has inferred it to be. The <code class="literal">as</code> operator comes in two flavors: the plain <code class="literal">as</code> operator and <code class="literal">as?</code>. The former casts the object into the desired type without asking. If the object cannot be cast to that type, a runtime error is thrown. The <code class="literal">as?</code> operator asks an object if it can be cast to a given type. If the object can be cast, then <em>some</em> value is returned; otherwise, <code class="literal">nil</code> is returned. The <code class="literal">as?</code> operator is most often used as part of an <code class="literal">if</code> statement.</p><p>Obviously, it's best to use <code class="literal">as?</code> whenever possible. We should use <code class="literal">as</code> only if we know it will not result in a runtime error.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we looked into types in general and explored reference versus value types in detail. We covered topics such as value and reference type constants, mixing value and reference types, and copying. Then we learned the characteristics of value types, key differences between value and reference types, and how we should decide which one to use. We continued by exploring equality, identity, type checking, and casting topics. Even though we explored the topic of value types, we did not explore a related topic—immutability—in this chapter. 
<a class="link" href="ch09.html" title="Chapter 9. Importance of Immutability">Chapter 9</a>
, <em>Importance of Immutability</em> will cover the importance of immutability.Furthermore, for in depth coverage of these concepts it is recommended to watch the following videos from: WWDC 2015 - Session 414, WWDC 2016 - Session 418, and WWDC 2016 - Session 419.</p><p>In the following chapter, we will explore the enumeration and pattern matching topics. We will familiarize ourselves with associated and raw values. We will be introduced to algebraic data types and finally, we will cover patterns and pattern matching.</p></div></body></html>