- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Breathing App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at the SwiftUI fundamentals, some of the modifiers we
    can use to alter a view in a certain way, and many of the properties that can
    be animated. Now it’s time to put that knowledge to work and build our first project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build an animation that is similar to the breathing
    apps that are popular on Apple watches and iPhones. There will be three animations
    that we will combine to make six circle views move, recreating the slow, rhythmic
    motions of the Apple app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: There is not a lot of code needed to make this app work; however, as we move
    through the book, we will build upon this project and gradually ramp up the difficulty.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps needed to complete the project are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project with Xcode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a background color
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the circles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the circles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the completed project from GitHub in the `Chapter 3` folder:
    [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project with Xcode
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by opening Xcode. Then, choose either the **iOS** option to just
    build your project on an iPhone or choose **Multiplatform** if you want to build
    this project so it runs on an iPhone, iPad, or a Mac. After that, from the list
    of templates, choose the one called **App**, and click **Next**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Now, give the project a name. I’m calling mine `Animating Circles`, but you
    can name it whatever you like. Then, fill out the rest of the details on this
    page. The two checkboxes can be left unchecked, as we are not using **Core Data**
    or **Tests**. Finally, select a location to save the project. I usually just save
    them on my desktop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We are then taken to the Xcode interface; you’ll notice that Xcode automatically
    imports the SwiftUI framework, so we can get right into our project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to add some variables to keep track of the animations. There
    will be three animations, so in `ContentView`, we need three boolean variables
    for them. We need to give them an initial value of `false`, which will be changed
    to `true` when the app first starts up:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variables are called `scaleUpDown`, `rotateInOut`, and `MoveInOut`. Usually,
    when you name your variables, you want to make them as descriptive as possible,
    so you don’t have to guess what they are used for and can recognize them right
    away, as we did here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: All the variables are now in place, so let’s move on to looking at the background
    of our animation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a background color
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the background, we will go into the `body` computed property. This is where
    we add our views that will be seen on the screen by the user. The first thing
    we want to add is a `ZStack`; this is the main stack that’s going to hold all
    of the views:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason we use the `ZStack` versus an `HStack` or a `VStack` is we want the
    views stacked on each other, so they appear as only one view, and later we will
    animate them separately with different modifiers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ZStack`而不是`HStack`或`VStack`的原因是我们希望视图堆叠在一起，这样它们就只显示为一个视图，稍后我们将使用不同的修饰符分别对它们进行动画处理。
- en: 'Inside the `ZStack`, let’s set a black background for the screen by using the
    `.foregroundColor` modifier, and specify the color to use; we will use black in
    this case:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ZStack`内部，让我们通过使用`.foregroundColor`修饰符为屏幕设置黑色背景，并指定要使用的颜色；在这种情况下，我们将使用黑色：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following figure shows the result of that code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了该代码的结果：
- en: '![Figure 3.1: Adding a black background ](img/B18674_03_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：添加黑色背景](img/B18674_03_01.jpg)'
- en: 'Figure 3.1: Adding a black background'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：添加黑色背景
- en: As you can see, when adding a background in SwiftUI, it will cover most of the
    iPhone screen, but there is an area on an iPhone that is known as the “safe area.”
    This is the area reserved for the iPhone notch at the top (the earpiece area)
    and the very bottom of the phone where the colored background can’t reach.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在SwiftUI中添加背景时，它将覆盖iPhone屏幕的大部分区域，但iPhone上有一个称为“安全区域”的区域。这是为iPhone顶部（听筒区域）和手机底部预留的区域，那里彩色背景无法达到。
- en: 'SwiftUI lets us hide the safe areas by using the `.edgesIgnoringSafeArea` modifier,
    then passing in the value `.all`, which extends the black color to the edges of
    the iPhone screen on all sides. To do this, add this line of code just underneath
    the `.fourgroundColor(Color.black)` line you previously added:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI允许我们使用`.edgesIgnoringSafeArea`修饰符隐藏安全区域，然后传入值`.all`，这将黑色颜色扩展到iPhone屏幕的所有边缘。为此，只需在之前添加的`.fourgroundColor(Color.black)`行下面添加这一行代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This produces a completely covered iPhone screen with a black background, as
    shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个完全覆盖的iPhone屏幕，背景为黑色，如下所示：
- en: '![ Figure 3.2: Using the .edgesIgnoringSafeArea modifier ](img/B18674_03_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：使用 .edgesIgnoringSafeArea 修饰符](img/B18674_03_02.jpg)'
- en: 'Figure 3.2: Using the .edgesIgnoringSafeArea modifier'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：使用 .edgesIgnoringSafeArea 修饰符
- en: There are also `.vertical`, `.horizontal`, `.leading`, and `.trailing` values
    that you can use to make the `.edgesIgnoringSafeArea` modifier more specific depending
    on what part of the device you want to be ignored.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`.vertical`、`.horizontal`、`.leading`和`.trailing`值，您可以使用这些值使`.edgesIgnoringSafeArea`修饰符更具体，取决于您想忽略设备的部分。
- en: So, we’ve set up the background of our animation. Now it’s time to add the circles.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经设置了动画的背景。现在，是时候添加圆圈了。
- en: Adding the circles
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加圆圈
- en: Let’s briefly review the goal of this project. We want to make six circles grow
    and shrink, and at the same time rotate them, and move them in and out. The six
    circles will be overlapping each other, which adds a nice look as they will be
    partially translucent.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这个项目的目标。我们希望使六个圆圈生长和收缩，同时旋转它们，并使它们进出。六个圆圈将相互重叠，这会给它们增添一种美观，因为它们将是部分透明的。
- en: 'To make this work, we need some more ZStacks, and then to place the circles,
    in pairs, into them. How the circles are aligned in relation to each other can
    be likened to the numbers on a clock. Going with this clock analogy, we need a
    `ZStack` to hold the three pairs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，我们需要更多的`ZStack`，然后将圆圈成对地放入其中。圆圈相对于彼此的对齐方式可以比作时钟上的数字。按照这个时钟类比，我们需要一个`ZStack`来容纳三对：
- en: The first pair of circles will be placed in the 12 and 6 o’clock positions
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一对圆圈将放置在12点和6点位置
- en: The second pair of circles will be placed in the 2 and 7 o’clock positions
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二对圆圈将放置在2点和7点位置
- en: The third pair of circles will be placed in the 10 and 4 o’clock positions
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三对圆圈将放置在10点和4点位置
- en: Let’s see how to add these three pairs of circles.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何添加这三对圆圈。
- en: Adding the first pair of circles
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加第一对圆圈
- en: 'The first pair of circles we will add will be placed in the 12 and 6 o’clock
    positions. The following is the code we need to accomplish that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的第一对圆圈将放置在12点和6点位置。以下是我们需要完成此操作的代码：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code creates two circles using the circle shape initializer. Each circle
    gets a gradient color that makes them lighter toward the center of the screen,
    and darker in the opposite direction. The gradient works by filling the circles
    with a smooth transition between two colors. In this case, the gradient goes from
    green to white. The `LinearGradient` struct is used to create the gradient, and
    it takes a `gradient` parameter, which is an instance of the `Gradient` struct.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用圆形状初始化器创建了两个圆圈。每个圆圈都获得了一种渐变色，使得它们在屏幕中心部分更亮，而在相反方向上更暗。渐变通过在两种颜色之间填充平滑过渡来工作。在这种情况下，渐变从绿色过渡到白色。`LinearGradient`
    结构体用于创建渐变，它接受一个 `gradient` 参数，这是一个 `Gradient` 结构体的实例。
- en: The `Gradient` struct takes a parameter called `colors`, which is an array of
    color values. In this case, the `colors` parameter is set to `[.green, .white]`,
    which means that the gradient will transition from green to white.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gradient` 结构体接受一个名为 `colors` 的参数，它是一个颜色值的数组。在这种情况下，`colors` 参数被设置为 `[.green,
    .white]`，这意味着渐变将从绿色过渡到白色。'
- en: The `startPoint` and `endPoint` parameters of the `LinearGradient` struct determine
    the direction of the gradient. The `startPoint` parameter is set to `.top` and
    the `endPoint` parameter is set to `.bottom` for the first circle, which means
    that the gradient will start at the top of the circle and go toward the bottom.
    For the second circle, the `startPoint` parameter is set to `.bottom` and the
    `endPoint` parameter is set to `.top`, which means that the gradient will start
    at the bottom of the circle and go toward the top. The look we are going for is
    a whiter shade of green toward the part of the circles that are just touching
    each other, and a darker shade of green on the opposite parts of the circles.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearGradient` 结构体的 `startPoint` 和 `endPoint` 参数决定了渐变的方向。`startPoint` 参数被设置为
    `.top`，而 `endPoint` 参数被设置为 `.bottom`，对于第一个圆圈来说，这意味着渐变将从圆圈的顶部开始，向下延伸。对于第二个圆圈，`startPoint`
    参数被设置为 `.bottom`，而 `endPoint` 参数被设置为 `.top`，这意味着渐变将从圆圈的底部开始，向上延伸。我们追求的效果是，在圆圈相互接触的部分呈现出更浅的绿色，而在圆圈的相对部分呈现出更深的绿色。'
- en: 'All the circles will be of the same size to start out with, which is 120 points
    for the width and height, and that’s accomplished using the `frame` modifier.
    Because we are in a `ZStack`, the two circles will be stacked on top of each other.
    If you would like to see both circles now, then change the `moveInOut` state property
    to `true`. The `moveInOut` property will be changed to true later when we add
    the `onAppear` modifier code, but for now, to see how the UI is shaping up, go
    ahead and change that property to `true`, and this is what you should see:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的圆圈最初都将具有相同的大小，宽度为 120 点，高度也为 120 点，这是通过使用 `frame` 修改器来实现的。因为我们处于 `ZStack`
    中，所以两个圆圈将堆叠在一起。如果你现在想同时看到这两个圆圈，那么请将 `moveInOut` 状态属性更改为 `true`。当我们在后面添加 `onAppear`
    修改器代码时，`moveInOut` 属性将被设置为 `true`，但为了现在看到 UI 的形状，请将此属性更改为 `true`，你应该看到的是：
- en: '![Figure 3.3: Twelve and six o’clock circles ](img/B18674_03_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：十二点和六点钟的圆圈](img/B18674_03_03.jpg)'
- en: 'Figure 3.3: Twelve and six o’clock circles'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：十二点和六点钟的圆圈
- en: Let’s look at the `moveInOut` variable now. Remember that I said the naming
    of our variables should be descriptive and should be related to what they do?
    Well, the `moveInOut` variable is an example of that descriptive naming, because
    it will move the circles in and out of each other. It does this by controlling
    the vertical offset of the circles that are contained within the `ZStack`. The
    ternary operator is responsible for setting the `moveInOut` value by choosing
    between two different numbers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `moveInOut` 变量。记得我提到过我们的变量命名应该是描述性的，并且应该与它们的功能相关吗？嗯，`moveInOut` 变量就是这种描述性命名的例子，因为它将使圆圈相互进入和退出。它通过控制包含在
    `ZStack` 中的圆圈的垂直偏移来实现这一点。三元运算符负责通过在两个不同的数字之间进行选择来设置 `moveInOut` 的值。
- en: When `moveInOut` is `true`, the first circle has a `y` offset of `-60`, which
    moves it upward by 60 points. The second circle has a `y` offset of `60`, which
    moves it downward by 60 points. This results in the two circles moving toward
    the top and bottom of the `ZStack` respectively. When `moveInOut` is `false`,
    the first circle has a `y` offset of `0`, which keeps it in the center of the
    `ZStack`, and the second circle also has a `y` offset of `0`, which keeps it in
    the center of the `ZStack` as well. This results in the two circles staying in
    the center, overlaying each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Next, by adding the opacity modifier at the end of the `ZStack`, both circles
    are set to a 50% opacity. This makes it easy to see through them and the other
    circles that we will add, as they overlap each other during the animation, and
    that also makes for a nice visual as the colors blend together and darken during
    the overlap.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Adding the second pair of circles
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, for the next set of circles, we’re doing almost the exact same thing...
    almost. Staying with our clock analogy, we need circles at the 2 and 7 o’clock
    marks. First, I will show you the code, then I will explain the parts that are
    new:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’re creating two circles with a gradient of green and white colors, which
    have the same width and height of 120 points, and they get offset by the animation
    variable, `moveInOut`. Again, depending on whether `moveInOut` is `true` or `false`
    will determine the placement of the circle. If it’s `true`, the circles will separate,
    and if `false`, they will come to the middle with one circle placed over the second
    circle. Next, we set the opacity of these circles to 50%, as we did with the first
    set of circles, to make them slightly transparent, so we can see them overlap.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: What’s different for this set of circles is that we need to use the `rotationEffect`
    modifier on them. This modifier lets us rotate the placement of the circles by
    passing in a value for the amount of rotation we want.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this modifier is placed on the end of the `ZStack` that holds the
    two circles. This placement will make the entire `ZStack` and its children rotate,
    so it saves us some code as we don’t need to place the modifier on both child
    circles individually.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: I’m using a value of `60` for the `.degrees` parameter, which will rotate this
    `ZStack` 60 degrees from the previous pair of circles. The value of `60` for the
    rotation is half of 120, which is the width of each circle, so this rotation will
    cause the circles to overlap each other by half.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, if you want to see how the two pairs of circles look, change the `moveInOut`
    property to `true`, and this is the result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Two and seven o’clock circles ](img/B18674_03_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Two and seven o’clock circles'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we didn’t have to rotate the first pair of circles using the `rotationEffect`
    modifier; that’s because they’re not overlapping any other circles as they are
    the first pair on the screen. If we don’t use the `rotationEffect` modifier here,
    though, this second pair of circles will be placed exactly over the first pair
    of circles, and we won’t see them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Adding the third pair of circles
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, for the last pair of circles on our clock, they need to be placed
    at the 10 and 4 o’clock marks. Here is the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Looking at this code, we can again see that very little is different from the
    other sets of circles. We’re adding two circles with a gradient of green and white,
    and with a size of 120 points. They move in and out 60 points or -60 points on
    the `y` axis, as we have seen, but for this pair of circles, we’re rotating them
    by 120 degrees, which places them at the 10 and 4 o’clock positions and completes
    the clock of circles. The result is shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Ten and four o’clock circles – the complete design ](img/B18674_03_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Ten and four o’clock circles – the complete design'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so we’ve added all of the circles. Now it’s time to add the fun part –
    the animation – and make them move.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Animating the circles
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all our circle pairs in place, it’s time to start animating them.
    I’m going to add the animation code. It may look a bit strange at first, but not
    to worry, I will explain it line by line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line of code calls the `rotationEffect` modifier. For its `.degrees`
    parameter, I’m passing in the `rotateInOut` variable, which is then checked by
    a ternary operator. The ternary operator has one of two values to choose from,
    `90` or `0`. If the `rotateInOut` variable is `true`, then the `rotationEffect`
    modifier will rotate the `ZStack` that contains all of the pairs of circles by
    90 degrees. When `rotateInOut` is `false`, the `rotationEffect` modifier rotates
    the `ZStack` back to `0`. So, all of the circles get rotated at once to either
    90 degrees or back to zero, depending on the value that `rotateInOut` contains.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code is the scale effect animation. For the `scaleEffect` modifier,
    we pass in another ternary operator that has two values to set, either `1` or
    `1/4`. When the `scaleUpDown` property is `true`, all the circles will be at full
    scale, which is reflected by the value `1`; otherwise, when the `scaleUpDown`
    property is `false`, all the circles will scale down to one-fourth of their size.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `.animation` function. This is the magic function
    that applies the animation to any view we put it on. We are putting it on the
    end of the `ZStack` that contains all of the circles, so when any values change,
    for example, the variables change from `true` to `false` and vice versa, then
    the new values will be applied to the view, which is the `ZStack` and its children.
    Those new values don’t get applied instantly; they are interpolated over, so the
    animation happens smoothly and fluidly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码调用`.animation`函数。这是一个神奇的功能，可以将动画应用于我们放置的任何视图。我们将它放在包含所有圆圈的`ZStack`的末尾，所以当任何值发生变化时，例如，变量从`true`变为`false`或相反，新的值将被应用于视图，即`ZStack`及其子项。这些新值不会立即应用；它们是插值过的，所以动画可以平滑流畅地进行。
- en: I’m using the `easeInEaseOut` timing curve type and also adding the `.repeatForever`
    modifier, which will keep the animation going for as long as the app is running.
    And by passing the `true` value to the `autoreverses` parameter, the animation
    reverses itself when it completes its animations in one direction, so it can continue
    and animate in the opposite direction.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`easeInEaseOut`时间曲线类型，并添加了`.repeatForever`修饰符，这将使动画在应用运行期间持续进行。通过将`true`值传递给`autoreverses`参数，当动画完成一个方向的动画时，它会反转自身，因此它可以继续并在相反方向上动画化。
- en: We can also set the speed of the animation. I’m using `1/8` as the value inside
    the `.speed` modifier, for a relatively slow animation. Since this project is
    similar to the familiar breathing app, I thought a slower animation rather than
    a faster one would be more appropriate, as the slow pace is helpful when focusing
    on breathing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置动画的速度。我在`.speed`修饰符内部使用`1/8`作为值，以实现相对较慢的动画。由于这个项目类似于熟悉的呼吸应用，我认为较慢的动画比快速的动画更合适，因为缓慢的节奏有助于集中注意力进行呼吸。
- en: The `value` parameter requires one of our `@State` variables so it can monitor
    it for changes. All of the variables we are using are `@State`, and they will
    have their values changed at some point, so any one of them will work fine in
    this parameter for this code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`参数需要一个我们的`@State`变量，以便它可以监控其变化。我们使用的所有变量都是`@State`，它们将在某个时刻改变其值，所以任何一个都可以在这个参数中正常工作。'
- en: The final part of the project is to change the values in each of our variables
    so the animation can work. Remember we looked at different triggers for animations
    by using the `.onAppear` modifier. This will perform an action when the screen
    or view first appears and then trigger the animation. The action we want to perform
    as soon as the app starts up is to toggle each of the variables to their opposite
    states. We gave them initial values of `false`, but inside `onAppear`, they get
    toggled to `true`, which starts the animation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的最后一部分是改变我们每个变量的值，以便动画可以工作。记住我们通过使用`.onAppear`修饰符查看动画的不同触发器。这将执行一个动作，当屏幕或视图首次出现时，然后触发动画。我们想要在应用启动时立即执行的操作是将每个变量切换到其相反的状态。我们给它们初始值`false`，但在`onAppear`内部，它们被切换到`true`，从而启动动画。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you tested out the app earlier and changed the `moveInOut` variable to `true`,
    make sure to set it back to `false` again, so the animations will get triggered
    in the `onAppear` modifier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前测试了应用并更改了`moveInOut`变量为`true`，请确保将其再次设置为`false`，这样动画就会在`onAppear`修饰符中被触发。
- en: 'And now we have three animations happening simultaneously:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个动画同时发生：
- en: The circles are moving in and out from each other. When moving inward, the circles
    will overlap each other completely, and when moving out, they will separate until
    their edges are just touching. Again, this animation is monitored by the `moveInOut`
    state variable.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆圈在彼此之间移动进出。当向内移动时，圆圈将完全重叠，当向外移动时，它们将分离，直到它们的边缘刚好接触。同样，这个动画由`moveInOut`状态变量监控。
- en: The second animation is scaling the circles by using the `scaleEffect` modifier.
    It takes a single parameter, which is a value between `0` and `1` that represents
    the amount of scaling to be applied. In this case, the `scaleUpDown` variable
    is being used to control the value passed to the `scaleEffect` modifier.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个动画是通过使用`scaleEffect`修饰符来缩放圆圈。它接受一个参数，这是一个介于`0`和`1`之间的值，表示要应用的缩放量。在这种情况下，`scaleUpDown`变量被用来控制传递给`scaleEffect`修饰符的值。
- en: The final animation is rotating all of the circles by 90 degrees when `rotateInOut`
    is `true`, and rotating them back to 0 when `rotateInOut` is `false`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`rotateInOut`为`true`时，最终动画将使所有圆圈旋转90度，而当`rotateInOut`为`false`时，将它们旋转回0度。
- en: 'Run the application and have a play around with it. The following figure shows
    the sequence the animation will take:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并对其进行一些操作。以下图显示了动画将采取的序列：
- en: '![Figure 3.6: Animation sequence ](img/B18674_03_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：动画序列](img/B18674_03_06.jpg)'
- en: 'Figure 3.6: Animation sequence'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：动画序列
- en: The best way to understand how the different modifiers and functions work is
    to pass in different values and by experimenting. Always feel free to use your
    own creativity for everything – for the parameters, things such as the color of
    the gradients, the size of the circles, the speed, the location, the amount of
    rotation, and so on. Changing the parameter values to your liking will give you
    a better understanding of how each modifier acts on a view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 理解不同修饰符和函数如何工作的最佳方式是通过传递不同的值并进行实验。在所有事情上——对于参数、例如渐变的颜色、圆圈的大小、速度、位置、旋转量等等——始终可以自由发挥你的创造力。将参数值调整到你喜欢的样子，这将帮助你更好地理解每个修饰符是如何作用于视图的。
- en: Later in the book, you will learn how to add sounds and music to a project,
    as well as how to add buttons and slider controls. When you know how to do that,
    you can come back to this project and tweak it to incorporate some music, and
    perhaps a slider to change the speed of the animations. For example, as this is
    a breathing app, and some people might want to relax by taking deep breaths and
    holding them for a second or more, you can alter the animation to pause for any
    amount of time to signify the holding of one’s breath, all done through the use
    of various controls that you will learn about in upcoming projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，你将学习如何向项目中添加声音和音乐，以及如何添加按钮和滑动控件。当你知道如何做到这一点时，你可以回到这个项目，对其进行调整以包含一些音乐，也许还有一个滑动条来改变动画的速度。例如，由于这是一个呼吸应用，有些人可能希望通过深呼吸并保持几秒钟来放松，你可以调整动画以暂停任意长的时间来表示呼吸的保持，所有这些都可以通过使用你将在即将到来的项目中了解到的各种控件来完成。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Great job on the completion of this first project! By creating a breathing app,
    you’ve got to explore how to rotate, scale, and move a view to another location,
    all by using SwiftUI’s intuitive modifiers and design tools. We also used a special
    modifier that does a lot of the work in the background for us, the `.animation`
    modifier, which interpolates over values after we define a start and end point,
    and creates a smooth seamless animation from those values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个第一个项目方面做得很好！通过创建一个呼吸应用，你不得不探索如何使用SwiftUI直观的修饰符和设计工具来旋转、缩放和移动视图到另一个位置。我们还使用了一个特殊的修饰符，它在后台为我们做了很多工作，即`.animation`修饰符，它在定义起始点和终点后对值进行插值，并从这些值创建出平滑无缝的动画。
- en: In the next chapter, we will continue our journey into animation and build a
    record player. This project will look at how to animate a view around one of its
    anchor points, rather than from the center, as well as adding sound and a button
    to start the animation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的动画之旅，并构建一个唱机。这个项目将探讨如何围绕视图的一个锚点进行动画，而不是从中心开始，以及添加声音和按钮以启动动画。
