- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Breathing App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at the SwiftUI fundamentals, some of the modifiers we
    can use to alter a view in a certain way, and many of the properties that can
    be animated. Now it’s time to put that knowledge to work and build our first project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build an animation that is similar to the breathing
    apps that are popular on Apple watches and iPhones. There will be three animations
    that we will combine to make six circle views move, recreating the slow, rhythmic
    motions of the Apple app.
  prefs: []
  type: TYPE_NORMAL
- en: There is not a lot of code needed to make this app work; however, as we move
    through the book, we will build upon this project and gradually ramp up the difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps needed to complete the project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project with Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a background color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the completed project from GitHub in the `Chapter 3` folder:
    [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project with Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by opening Xcode. Then, choose either the **iOS** option to just
    build your project on an iPhone or choose **Multiplatform** if you want to build
    this project so it runs on an iPhone, iPad, or a Mac. After that, from the list
    of templates, choose the one called **App**, and click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, give the project a name. I’m calling mine `Animating Circles`, but you
    can name it whatever you like. Then, fill out the rest of the details on this
    page. The two checkboxes can be left unchecked, as we are not using **Core Data**
    or **Tests**. Finally, select a location to save the project. I usually just save
    them on my desktop.
  prefs: []
  type: TYPE_NORMAL
- en: We are then taken to the Xcode interface; you’ll notice that Xcode automatically
    imports the SwiftUI framework, so we can get right into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to add some variables to keep track of the animations. There
    will be three animations, so in `ContentView`, we need three boolean variables
    for them. We need to give them an initial value of `false`, which will be changed
    to `true` when the app first starts up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The variables are called `scaleUpDown`, `rotateInOut`, and `MoveInOut`. Usually,
    when you name your variables, you want to make them as descriptive as possible,
    so you don’t have to guess what they are used for and can recognize them right
    away, as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: All the variables are now in place, so let’s move on to looking at the background
    of our animation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a background color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the background, we will go into the `body` computed property. This is where
    we add our views that will be seen on the screen by the user. The first thing
    we want to add is a `ZStack`; this is the main stack that’s going to hold all
    of the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The reason we use the `ZStack` versus an `HStack` or a `VStack` is we want the
    views stacked on each other, so they appear as only one view, and later we will
    animate them separately with different modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `ZStack`, let’s set a black background for the screen by using the
    `.foregroundColor` modifier, and specify the color to use; we will use black in
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the result of that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Adding a black background ](img/B18674_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Adding a black background'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when adding a background in SwiftUI, it will cover most of the
    iPhone screen, but there is an area on an iPhone that is known as the “safe area.”
    This is the area reserved for the iPhone notch at the top (the earpiece area)
    and the very bottom of the phone where the colored background can’t reach.
  prefs: []
  type: TYPE_NORMAL
- en: 'SwiftUI lets us hide the safe areas by using the `.edgesIgnoringSafeArea` modifier,
    then passing in the value `.all`, which extends the black color to the edges of
    the iPhone screen on all sides. To do this, add this line of code just underneath
    the `.fourgroundColor(Color.black)` line you previously added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a completely covered iPhone screen with a black background, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 3.2: Using the .edgesIgnoringSafeArea modifier ](img/B18674_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Using the .edgesIgnoringSafeArea modifier'
  prefs: []
  type: TYPE_NORMAL
- en: There are also `.vertical`, `.horizontal`, `.leading`, and `.trailing` values
    that you can use to make the `.edgesIgnoringSafeArea` modifier more specific depending
    on what part of the device you want to be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ve set up the background of our animation. Now it’s time to add the circles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the circles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s briefly review the goal of this project. We want to make six circles grow
    and shrink, and at the same time rotate them, and move them in and out. The six
    circles will be overlapping each other, which adds a nice look as they will be
    partially translucent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, we need some more ZStacks, and then to place the circles,
    in pairs, into them. How the circles are aligned in relation to each other can
    be likened to the numbers on a clock. Going with this clock analogy, we need a
    `ZStack` to hold the three pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: The first pair of circles will be placed in the 12 and 6 o’clock positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second pair of circles will be placed in the 2 and 7 o’clock positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third pair of circles will be placed in the 10 and 4 o’clock positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how to add these three pairs of circles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first pair of circles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first pair of circles we will add will be placed in the 12 and 6 o’clock
    positions. The following is the code we need to accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code creates two circles using the circle shape initializer. Each circle
    gets a gradient color that makes them lighter toward the center of the screen,
    and darker in the opposite direction. The gradient works by filling the circles
    with a smooth transition between two colors. In this case, the gradient goes from
    green to white. The `LinearGradient` struct is used to create the gradient, and
    it takes a `gradient` parameter, which is an instance of the `Gradient` struct.
  prefs: []
  type: TYPE_NORMAL
- en: The `Gradient` struct takes a parameter called `colors`, which is an array of
    color values. In this case, the `colors` parameter is set to `[.green, .white]`,
    which means that the gradient will transition from green to white.
  prefs: []
  type: TYPE_NORMAL
- en: The `startPoint` and `endPoint` parameters of the `LinearGradient` struct determine
    the direction of the gradient. The `startPoint` parameter is set to `.top` and
    the `endPoint` parameter is set to `.bottom` for the first circle, which means
    that the gradient will start at the top of the circle and go toward the bottom.
    For the second circle, the `startPoint` parameter is set to `.bottom` and the
    `endPoint` parameter is set to `.top`, which means that the gradient will start
    at the bottom of the circle and go toward the top. The look we are going for is
    a whiter shade of green toward the part of the circles that are just touching
    each other, and a darker shade of green on the opposite parts of the circles.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the circles will be of the same size to start out with, which is 120 points
    for the width and height, and that’s accomplished using the `frame` modifier.
    Because we are in a `ZStack`, the two circles will be stacked on top of each other.
    If you would like to see both circles now, then change the `moveInOut` state property
    to `true`. The `moveInOut` property will be changed to true later when we add
    the `onAppear` modifier code, but for now, to see how the UI is shaping up, go
    ahead and change that property to `true`, and this is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Twelve and six o’clock circles ](img/B18674_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Twelve and six o’clock circles'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the `moveInOut` variable now. Remember that I said the naming
    of our variables should be descriptive and should be related to what they do?
    Well, the `moveInOut` variable is an example of that descriptive naming, because
    it will move the circles in and out of each other. It does this by controlling
    the vertical offset of the circles that are contained within the `ZStack`. The
    ternary operator is responsible for setting the `moveInOut` value by choosing
    between two different numbers.
  prefs: []
  type: TYPE_NORMAL
- en: When `moveInOut` is `true`, the first circle has a `y` offset of `-60`, which
    moves it upward by 60 points. The second circle has a `y` offset of `60`, which
    moves it downward by 60 points. This results in the two circles moving toward
    the top and bottom of the `ZStack` respectively. When `moveInOut` is `false`,
    the first circle has a `y` offset of `0`, which keeps it in the center of the
    `ZStack`, and the second circle also has a `y` offset of `0`, which keeps it in
    the center of the `ZStack` as well. This results in the two circles staying in
    the center, overlaying each other.
  prefs: []
  type: TYPE_NORMAL
- en: Next, by adding the opacity modifier at the end of the `ZStack`, both circles
    are set to a 50% opacity. This makes it easy to see through them and the other
    circles that we will add, as they overlap each other during the animation, and
    that also makes for a nice visual as the colors blend together and darken during
    the overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the second pair of circles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, for the next set of circles, we’re doing almost the exact same thing...
    almost. Staying with our clock analogy, we need circles at the 2 and 7 o’clock
    marks. First, I will show you the code, then I will explain the parts that are
    new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’re creating two circles with a gradient of green and white colors, which
    have the same width and height of 120 points, and they get offset by the animation
    variable, `moveInOut`. Again, depending on whether `moveInOut` is `true` or `false`
    will determine the placement of the circle. If it’s `true`, the circles will separate,
    and if `false`, they will come to the middle with one circle placed over the second
    circle. Next, we set the opacity of these circles to 50%, as we did with the first
    set of circles, to make them slightly transparent, so we can see them overlap.
  prefs: []
  type: TYPE_NORMAL
- en: What’s different for this set of circles is that we need to use the `rotationEffect`
    modifier on them. This modifier lets us rotate the placement of the circles by
    passing in a value for the amount of rotation we want.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this modifier is placed on the end of the `ZStack` that holds the
    two circles. This placement will make the entire `ZStack` and its children rotate,
    so it saves us some code as we don’t need to place the modifier on both child
    circles individually.
  prefs: []
  type: TYPE_NORMAL
- en: I’m using a value of `60` for the `.degrees` parameter, which will rotate this
    `ZStack` 60 degrees from the previous pair of circles. The value of `60` for the
    rotation is half of 120, which is the width of each circle, so this rotation will
    cause the circles to overlap each other by half.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, if you want to see how the two pairs of circles look, change the `moveInOut`
    property to `true`, and this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Two and seven o’clock circles ](img/B18674_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Two and seven o’clock circles'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we didn’t have to rotate the first pair of circles using the `rotationEffect`
    modifier; that’s because they’re not overlapping any other circles as they are
    the first pair on the screen. If we don’t use the `rotationEffect` modifier here,
    though, this second pair of circles will be placed exactly over the first pair
    of circles, and we won’t see them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the third pair of circles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, for the last pair of circles on our clock, they need to be placed
    at the 10 and 4 o’clock marks. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at this code, we can again see that very little is different from the
    other sets of circles. We’re adding two circles with a gradient of green and white,
    and with a size of 120 points. They move in and out 60 points or -60 points on
    the `y` axis, as we have seen, but for this pair of circles, we’re rotating them
    by 120 degrees, which places them at the 10 and 4 o’clock positions and completes
    the clock of circles. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Ten and four o’clock circles – the complete design ](img/B18674_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Ten and four o’clock circles – the complete design'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so we’ve added all of the circles. Now it’s time to add the fun part –
    the animation – and make them move.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the circles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all our circle pairs in place, it’s time to start animating them.
    I’m going to add the animation code. It may look a bit strange at first, but not
    to worry, I will explain it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code calls the `rotationEffect` modifier. For its `.degrees`
    parameter, I’m passing in the `rotateInOut` variable, which is then checked by
    a ternary operator. The ternary operator has one of two values to choose from,
    `90` or `0`. If the `rotateInOut` variable is `true`, then the `rotationEffect`
    modifier will rotate the `ZStack` that contains all of the pairs of circles by
    90 degrees. When `rotateInOut` is `false`, the `rotationEffect` modifier rotates
    the `ZStack` back to `0`. So, all of the circles get rotated at once to either
    90 degrees or back to zero, depending on the value that `rotateInOut` contains.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code is the scale effect animation. For the `scaleEffect` modifier,
    we pass in another ternary operator that has two values to set, either `1` or
    `1/4`. When the `scaleUpDown` property is `true`, all the circles will be at full
    scale, which is reflected by the value `1`; otherwise, when the `scaleUpDown`
    property is `false`, all the circles will scale down to one-fourth of their size.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `.animation` function. This is the magic function
    that applies the animation to any view we put it on. We are putting it on the
    end of the `ZStack` that contains all of the circles, so when any values change,
    for example, the variables change from `true` to `false` and vice versa, then
    the new values will be applied to the view, which is the `ZStack` and its children.
    Those new values don’t get applied instantly; they are interpolated over, so the
    animation happens smoothly and fluidly.
  prefs: []
  type: TYPE_NORMAL
- en: I’m using the `easeInEaseOut` timing curve type and also adding the `.repeatForever`
    modifier, which will keep the animation going for as long as the app is running.
    And by passing the `true` value to the `autoreverses` parameter, the animation
    reverses itself when it completes its animations in one direction, so it can continue
    and animate in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set the speed of the animation. I’m using `1/8` as the value inside
    the `.speed` modifier, for a relatively slow animation. Since this project is
    similar to the familiar breathing app, I thought a slower animation rather than
    a faster one would be more appropriate, as the slow pace is helpful when focusing
    on breathing.
  prefs: []
  type: TYPE_NORMAL
- en: The `value` parameter requires one of our `@State` variables so it can monitor
    it for changes. All of the variables we are using are `@State`, and they will
    have their values changed at some point, so any one of them will work fine in
    this parameter for this code.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the project is to change the values in each of our variables
    so the animation can work. Remember we looked at different triggers for animations
    by using the `.onAppear` modifier. This will perform an action when the screen
    or view first appears and then trigger the animation. The action we want to perform
    as soon as the app starts up is to toggle each of the variables to their opposite
    states. We gave them initial values of `false`, but inside `onAppear`, they get
    toggled to `true`, which starts the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you tested out the app earlier and changed the `moveInOut` variable to `true`,
    make sure to set it back to `false` again, so the animations will get triggered
    in the `onAppear` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we have three animations happening simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: The circles are moving in and out from each other. When moving inward, the circles
    will overlap each other completely, and when moving out, they will separate until
    their edges are just touching. Again, this animation is monitored by the `moveInOut`
    state variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second animation is scaling the circles by using the `scaleEffect` modifier.
    It takes a single parameter, which is a value between `0` and `1` that represents
    the amount of scaling to be applied. In this case, the `scaleUpDown` variable
    is being used to control the value passed to the `scaleEffect` modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final animation is rotating all of the circles by 90 degrees when `rotateInOut`
    is `true`, and rotating them back to 0 when `rotateInOut` is `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the application and have a play around with it. The following figure shows
    the sequence the animation will take:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Animation sequence ](img/B18674_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Animation sequence'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand how the different modifiers and functions work is
    to pass in different values and by experimenting. Always feel free to use your
    own creativity for everything – for the parameters, things such as the color of
    the gradients, the size of the circles, the speed, the location, the amount of
    rotation, and so on. Changing the parameter values to your liking will give you
    a better understanding of how each modifier acts on a view.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, you will learn how to add sounds and music to a project,
    as well as how to add buttons and slider controls. When you know how to do that,
    you can come back to this project and tweak it to incorporate some music, and
    perhaps a slider to change the speed of the animations. For example, as this is
    a breathing app, and some people might want to relax by taking deep breaths and
    holding them for a second or more, you can alter the animation to pause for any
    amount of time to signify the holding of one’s breath, all done through the use
    of various controls that you will learn about in upcoming projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great job on the completion of this first project! By creating a breathing app,
    you’ve got to explore how to rotate, scale, and move a view to another location,
    all by using SwiftUI’s intuitive modifiers and design tools. We also used a special
    modifier that does a lot of the work in the background for us, the `.animation`
    modifier, which interpolates over values after we define a start and end point,
    and creates a smooth seamless animation from those values.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our journey into animation and build a
    record player. This project will look at how to animate a view around one of its
    anchor points, rather than from the center, as well as adding sound and a button
    to start the animation.
  prefs: []
  type: TYPE_NORMAL
