<html><head></head><body>
		    <div class="readerChapterContent">
		      <div>
  <h1 class="Title-1"><span>Chapter 3. Set up and Build – the Emulator Way</span></h1>

  <p><span>In the previous chapter, we learned how to retrieve the source code and we had an overview of the folder's structure. We now know how the branching model works and how to contribute to the project. This is an important topic, because Android is an open source prot, but it's managed in a very different way compared to other popular open source projects.</span></p>

  <p><span>In this chapter, we will set up the whole environment to get ready to build our first Android system and flash it to a real target. Our efforts will be focused to create a fully-working version for the official Android emulator.</span></p>

  <p><span>The user will learn how to use tools such as </span><code class="literal"><span>adb</span></code><span> and </span><code class="literal"><span>fastboot</span></code><span>, two of the most important tools that Google provides.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Preparing the host system</span></h2>

  <p><span>To build a complex system such as Android, we need to satisfy a few hardware and software requirements. First of all the host system.</span></p>

  <p><span>The official Linux distribution supporting the Android build environment is </span><code class="literal"><span>Ubuntu Linux</span></code><span>. Google periodically releases new Android builds for its devices and all of them are created using Ubuntu. Currently, Google is using Ubuntu 14.04 even if this is not the latest version available.</span></p>

  <p><span>Every example in this book will be developed and executed on a common notebook, with an Intel i5 CPU and 4 GB of RAM, running Ubuntu Linux 15.05, that's the latest available version. Using a different Linux version proves that if all the requirements are satisfied, you could build Android with any Linux distribution or even Mac OS X— if you can't set up Ubuntu, trying with a different version will be challenging, but will be worth trying, as a learning experience.</span></p>

  <p><span>If you are a Microsoft Windows user, it is sad to say, you won't be able to build Android using the native operative system. A possible solution is using a virtual machine running Ubuntu, for instance.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Hardware requirements</span></h3>

  <p><span>Digging into hardware requirements, you will just need a recent personal computer. As anticipated in the previous section, we are going to use a middle-end notebook for our examples. It's a Lenovo x220, with Intel i5 CPU and 4GB of RAM: it's enough to do the job and it's affordable, but the build time won't be small.</span></p>

  <p><span>To speed up the build time, using a high-end PC is advisable. A faster CPU, with more cores, and more RAM will take advantage of multithreading and parallel building and will significantly reduce the build time, allowing you to experiment more during the journey.</span></p>

  <p><span>A critical point of the environment setup is the necessary hard disk free space. The required amount is considerable—the source code alone needs approximately 100 GB to be stored. The whole build process will require approximately 150GB. If we are trying to build as fast as possible, probably we will enable the building system caching option, </span><code class="literal"><span>ccache</span></code><span>. The caching system will require even more free space.</span></p>

  <p><span>The following table will give you a rough estimation about minimum and recommended hardware:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_34.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_34" style="max-width:519px;max-height:246px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Software requirements</span></h3>

  <p><span>In this book, we are going to build the system using Ubuntu Linux 15.04. If you cannot obtain this version, you can successfully use an older version, like the guys at Google, a totally different distribution or even a Virtual Machine.</span></p>

  <p><span>One of the basic requirements, when it comes to the operating system, is the architecture: if we are planning to build Android 2.3 or greater, we will need a 64-bit system. Older versions of Android will do fine with a 32-bit system, but that's an improbable scenario.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Installing Java JDK</span></h4>

  <p><span>Oracle's </span><span class="emphasis"><em><span>Java Development Kit</span></em></span><span> is a crucial requirement, essential to be able to build Android. Every Android version needs a specific JDK version. According to what version we want to build, we are going to install:</span></p>

  <ul>
    <li><span>JDK 5 for Cupcake to Froyo</span></li>

    <li><span>JDK 6 for Gingerbread to KitKat</span></li>

    <li><span>JDK 7 for KitKat, Lollipop, and Marshmallow</span></li>
  </ul>

  <p><span>We are going to build Android Lollipop 5.1.1 and we are going to need at least JDK 7. Installing JDK on Ubuntu is quite straightforward. Let's start by opening a Terminal and firing the following command:</span></p>
  <pre><span class="strong"><strong>~$ sudo apt-get install openjdk-7-jdk</strong></span>
</pre>

  <p><span>The </span><code class="literal"><span>apt-get</span></code><span> command will resolve all the dependencies, download all the required packages and install them. If you are a </span><span class="emphasis"><em><span>Mouse and icons</span></em></span><span> user, you can achieve the same goal using </span><span class="strong"><strong><span>Ubuntu Software Center</span></strong></span><span>, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_35.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_35" style="max-width:735px;max-height:672px"/></div>

  <p><span>If you are a Java developer or you plan to build different Android versions for specific reasons, Ice Cream Sandwich and Lollipop, for instance, you could end up having more than just one version of the Java Development Kit. This multipurpose scenario brings a few more steps of configuration. We need to specify which JDK version will be used as the default one in the system. Using our trusted Terminal, let's run these commands:</span></p>
  <pre><span class="strong"><strong>~$ sudo update-alternative –config javac</strong></span>
</pre>

  <p><span>The following screenshot shows the output. As you can see, it lists all the available JDK versions and lets you pick the one to set as default. In our scenario, we are using JDK 7 because we are planning to build Android 5 or greater.</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_36.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_36" style="max-width:670px;max-height:306px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>Installing system dependencies</span></h4>

  <p><span>Even if Java is a key player in the Android world, we also need a few </span><span class="emphasis"><em><span>low-level</span></em></span><span> tools to satisfy all the Android build system requirements. Some of them are common tools and there is a chance that they are already installed, but our goal is to set up a whole system from scratch: we can't risk missing a dependency.</span></p>

  <p><span>Using your Terminal, run the following </span><code class="literal"><span>apt-get</span></code><span> command:</span></p>
  <pre><span class="strong"><strong>~$ sudo apt-get install bison g++-multilib git gperf libxml2-utils \</strong></span>
<span class="strong"><strong>    make python-networkx zlib1g-dev:i386 zip</strong></span>
</pre>

  <p><span>As usual, </span><code class="literal"><span>apt-get</span></code><span> will resolve all the dependencies and install all the required packages. The following screenshot shows the output of the command in the scenario in which you already have all the required packages, lucky you:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_37.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_37" style="max-width:646px;max-height:354px"/></div>

  <p><span>At this point, your Ubuntu contains all the required packages and applications to build the world's most popular mobile operating system.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Setting up a Mac OS X environment</span></h3>

  <p><span>One of the most important requirements to build Android is a case-sensitive filesystem. If you are planning to build Android using OS X, the most practical way to satisfy this requirement is to create a partition or a disk image containing a case-sensitive filesystem.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Creating a case-sensitive disk image</span></h4>

  <p><span>OS X provides a handy graphical utility to create a new disk image. Fire up </span><code class="literal"><span>Spotlight</span></code><span> and launch </span><code class="literal"><span>Disk Utility</span></code><span>. The upper toolbar contains a </span><span class="strong"><strong><span>New Image</span></strong></span><span> button that takes you to the disk image creation screen, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_38.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_38" style="max-width:744px;max-height:644px"/></div>

  <p><span>As you can see from the preceding screenshot, the crucial setting is the </span><span class="strong"><strong><span>Format</span></strong></span><span>: it has to be </span><code class="literal"><span>Case-sensitive, Journaled</span></code><span>. For the </span><span class="strong"><strong><span>Size</span></strong></span><span> setting, the larger the better, keeping in mind that an Android build could use hundreds of gigabytes in no time. As minimal size, we suggest at least 50 GB.</span></p>

  <p><span>If you are more a </span><span class="emphasis"><em><span>command line</span></em></span><span> type, it's possible to create this disk image using the Terminal and </span><code class="literal"><span>hdiutil</span></code><span>, as shown in the following command:</span></p>
  <pre><span class="strong"><strong>~$ hdiutil create -type SPARSE -fs 'Case-sensitive Journaled HFS+' \-size 50g ~/android.dmg</strong></span>
</pre>

  <p><span>If the disk image creation succeeded, we now have a </span><code class="literal"><span>.dmg</span></code><span> or </span><code class="literal"><span>.dmg.sparsefile</span></code><span> file on our disk. Once we have mounted it, we can use it as a normal hark disk—downloading Android source code and proceeding with the building procedure.</span></p>

  <p><span>The two following commands will give you the ability to mount and unmount the disk image:</span></p>
  <pre><span class="strong"><strong>~$ hdiutil attach ~/android.dmg -mountpoint /Volumes/android-disk;</strong></span>
<span class="strong"><strong>~$ hdiutil detach /Volumes/android-disk;</strong></span>
</pre>

  <h4 class="Title-3 sigil_not_in_toc"><span>Note</span></h4>

  <p><span>If you run out of space, the following command will give you the opportunity to resize the disk image and allow you to continue working on your desired Android build:</span></p>
  <pre><span class="strong"><strong>~$ hdiutil resize -size &lt;new-size-you-want&gt;g ~/android.dmg.sparseimage</strong></span>
</pre>

  <h4 class="Title-3 sigil_not_in_toc"><span>Installing the required software</span></h4>

  <p><span>Once we have our installation disk image, the same as for Linux, we need to install all those software requirements we need to properly build the system.</span></p>

  <p><span>Installing the Java Development Kit is very straightforward: just download the proper </span><code class="literal"><span>.dmg</span></code><span> file from </span><a class="ulink" href="http://www.oracle.com"><span>http://www.oracle.com</span></a><span> and install it. The same rules about Android target version and required Java version apply here too.</span></p>

  <p><span>Further, we will need:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Xcod</span></strong></span><span>e: The installation is well documented at </span><a class="ulink" href="https://developer.apple.com"><span>https://developer.apple.com</span></a><span> as Xcode is the main player of iOS development.</span></li>

    <li><span class="strong"><strong><span>MacPorts</span></strong></span><span>: It's an open source project that will help us to install lots of useful tools. You can install it following the installation info at </span><a class="ulink" href="http://www.macports.org/install.php"><span>http://www.macports.org/install.php</span></a><span>.</span></li>
  </ul>

  <p><span>Once we have these two main pieces of the puzzle in place, we need to install </span><code class="literal"><span>make</span></code><span>, </span><code class="literal"><span>git</span></code><span>, </span><code class="literal"><span>bison</span></code><span>, and </span><code class="literal"><span>GPG</span></code><span> packages, using MacPorts, with the following command on your Terminal:</span></p>
  <pre><span class="strong"><strong>~$ POSIXLY_CORRECT=1 sudo port install gmake bison libsdl git gnupg</strong></span>
</pre>

  <p><span>Last but not least, we need to increase the maximum number of possible file descriptors. OS X comes with a tiny value—the average user does not need all those file descriptors, but we are going to need a bigger amount due to the hundreds of files involved in the Android build procedure. To increase this value, we will need to launch our Terminal and run the following command:</span></p>
  <pre><span class="strong"><strong>~$ ulimit –S –n 1024 </strong></span>
</pre>

  <p><span>Now, the limit is up to 1,024 files. We can make this value persistent by adding this to the </span><code class="literal"><span>~/.bash_profile</span></code><span> file, in your </span><code class="literal"><span>home</span></code><span> folder.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>The Android build system</span></h2>

  <p><span>Before digging into configuring and building your first Android system, we will have an overview of the build system itself, the tools involved, and the unique approach to the whole process Google has.</span></p>

  <p><span>There is very little official documentation available about creating new modules and about the build system itself. Most of your knowledge at the end of this journey will come from your own hands-on experience and from our experience that we put in these pages.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>An overview</span></h3>

  <p><span>As with lots of projects out there, open source or closed source, Android uses the powerful tool </span><code class="literal"><span>make</span></code><span> to build the whole system, but compared to all other projects, Android uses it in a completely different way.</span></p>

  <p><span>The common approach of using </span><code class="literal"><span>make</span></code><span> would be to use a hierarchy of Makefiles: one single root Makefile retrieves and runs every other Makefile, contained in some of the subfolders of the project. Usually, every subfolder represents a submodule of the main project and it can be built alone or could depend upon other modules. Unlike other projects, Android has no </span><code class="literal"><span>menuconfig</span></code><span> or any other graphical configuration utility to customize the build system, enable or disable modules. Every sort of build configuration is done using environment variables that we will show in the next sections.</span></p>

  <p><span>Moreover, the whole module building is unconventional. Taking the Linux kernel as an example, usually, when a module is built, in the same folder with the source code, we have the compiled files. Module after module, the build system compiles everything and, at the very end, it retrieves the required files, links them together, and generates the final output. Android works in a different way. As you will notice approaching the build completion, Android tries to keep every module folder as clean as possible—every compiled file ends up in the </span><code class="literal"><span>/out</span></code><span> folder, so that it's easier to clean everything, just delete this folder and have everything perfectly in order in a blink of an eye.</span></p>

  <p><span>As you could guess at this point, the build system is completely custom made by Google. Everything has been designed and developed from scratch, using existent tools, but approaching the problem in an unusual way. Android developers created a single huge Makefile, containing all the needed information to build every single module and to assemble the final system image.</span></p>

  <p><span>The whole build system is contained in the </span><code class="literal"><span>build/</span></code><span> folder. This folder contains:</span></p>

  <ul>
    <li><span>Utility shell scripts</span></li>

    <li><span>Utility Python scripts</span></li>

    <li><span>A set of .</span><code class="literal"><span>mk</span></code><span> files containing all the necessary information to create all the system modules</span></li>
  </ul>

  <p><span>Every single module has its own folder. This folder contains the most important file to build the module </span><code class="literal"><span>Android.mk</span></code><span>. This file contains all the information needed to perform a smooth compilation of the module source code and generate a binary file.</span></p>

  <p><span>Module </span><code class="literal"><span>Android.mk</span></code><span> files are the first step of the building procedure—the build system scans every folder looking for these files and includes them into the single huge Makefile that it will use for further steps.</span></p>

  <p><span>The source code root folder contains a Makefile with the following content:</span></p>
  <pre>### DO NOT EDIT THIS FILE ###
include build/core/main.mk
### DO NOT EDIT THIS FILE ###</pre>

  <p><span>The file looks pretty empty, but it contains the most important </span><code class="literal"><span>.mk</span></code><span> file of all—</span><code class="literal"><span>main.mk</span></code><span>. This file, located in </span><code class="literal"><span>build/core</span></code><span>, contains a sequence of checks and all the needed operations to retrieve all the </span><code class="literal"><span>Android.mk</span></code><span> files to build all the modules.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Note</span></h4>

  <p><span>Without special configuration, the Android build system only creates the Android system image. To generate CTS, NDK, and SDK, we will need a bit more setup effort as we will see later.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Bootstrap</span></h3>

  <p><span>The whole build system is fired up, thanks to a single shell script—</span><code class="literal"><span>build/envsetup.sh</span></code><span>. As you can see in the following screenshot, this script is in charge of preparing the building environment. It sets up a few configurations and provides useful tools that make our work much easier: it's the Swiss Army knife of the Android build system.</span></p>

  <p><span>Fire up your Terminal and run the script as follows:</span></p>
  <pre><span class="strong"><strong>~$ . build/envsetup.sh</strong></span>
</pre>

  <p><span>Here is the output:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_39.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_39" style="max-width:646px;max-height:434px"/></div>

  <p><span>The previous screenshot shows the output of </span><code class="literal"><span>envsetup.sh</span></code><span>, that brings the system to be fully operational and ready to build. To have a list of all the commands that we now have available, on your Terminal, run:</span></p>
  <pre><span class="strong"><strong>:~$ hmm</strong></span>
</pre>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_40.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_40" style="max-width:1000px;max-height:671px"/></div>

  <p><span>The previous screenshot shows the output of the </span><code class="literal"><span>hmm</span></code><span> command. We will have a look at lots of them later, but as a yummy anticipation:</span></p>

  <ul>
    <li><code class="literal"><span>lunch</span></code><span>: This command helps you configure everything we need for a specific target with one single command</span></li>

    <li><code class="literal"><span>mm</span></code><span>: This command lets you compile just the module contained in your current folder</span></li>
  </ul>

  <h3 class="Title-2 sigil_not_in_toc"><span>Setup</span></h3>

  <p><span>A proper configuration environment is one of the most important things for a build system. Every build system provides a clear way to specify, for instance, which module to build of which platform we are targeting. Having the Linux kernel as a great example, we can say that it provides a handy graphical menu to perform all the necessary configurations:</span></p>
  <pre><span class="strong"><strong>$ make menuconfig</strong></span>
</pre>

  <p><span>Menuconfig lets you enable or disable modules to be built, select the desired platform, and tons of other different possible configurations. Every single configuration bit is saved in a </span><code class="literal"><span>.config</span></code><span> file that can be easily read or edited and reused for the build procedure.</span></p>

  <p><span>As we anticipated, Android is based on something completely different. There is no graphical interface to perform the configuration. The only sort of interactive or automatic configuration system is </span><code class="literal"><span>envsetup.sh</span></code><span>, which we already learned about. So why does Android not have any cool tools to configure the build system? Simply, because it does not need one! We are not supposed to disable all the modules we don't want to build, so Android just does not provide an easy way.</span></p>

  <p><span>Let's say that we are building Android for a new device we have just created and it does not have a camera on-board. We might want to remove that part of the system that manages the camera. There is no official way to do it. If we want to do it, we need to get our hands dirty and with time and pages we will be able to do it.</span></p>

  <p><span>We can safely say that the whole Android build system configuration can be stripped down to setting a few environment variables. The build system will use these variables to figure out which device we are targeting or which toolchain it is supposed to use.</span></p>

  <p><span>The most important variables are:</span></p>

  <ul>
    <li><span>TARGET_PRODUCT</span></li>

    <li><span>TARGET_BUILD_VARIANT</span></li>

    <li><span>TARGET_BUILD_TYPE</span></li>

    <li><span>TARGET_TOOLS_PREFIX</span></li>

    <li><span>TARGET_PREBUILT_KERNEL</span></li>

    <li><span>OUT_DIR</span></li>
  </ul>

  <p><span>In the upcoming sections, we are going to learn all about these variables we can manipulate to perfect our build.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>The TARGET_PRODUCT variable</span></h4>

  <p><span>This variable contains the information to specify the device we are preparing the system for. We are currently targeting the official emulator, so we are going to set the variable as </span><code class="literal"><span>aosp_arm</span></code><span>. If we want to build the system for Google's Nexus 6, we will set the variable to </span><code class="literal"><span>aosp_shamu</span></code><span>, or to </span><code class="literal"><span>aosp_hummerhead</span></code><span> for Google's Nexus 5.</span></p>

  <p><span>For quick access to all the values, specific for all the supported devices, we have provided a handy table as follows:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_41.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_41" style="max-width:950px;max-height:1036px"/></div>

  <p><span>As you can imagine, every device supports a specific version of the system. For instance, with our current downloaded source base, tag android-5.1.1:</span></p>

  <ul>
    <li><span>aosp_arm</span></li>

    <li><span>aosp_arm64</span></li>

    <li><span>aosp_mips</span></li>

    <li><span>aosp_mips64</span></li>

    <li><span>aosp_x86</span></li>

    <li><span>aosp_x86_64</span></li>

    <li><span>aosp_manta</span></li>

    <li><span>aosp_flounder</span></li>

    <li><span>mini_emulator_x86_64</span></li>

    <li><span>mini_emulator_mips</span></li>

    <li><span>mini_emulator_x86</span></li>

    <li><span>mini_emulator_arm64</span></li>

    <li><span>m_e_arm</span></li>

    <li><span>aosp_mako</span></li>

    <li><span>aosp_hammerhead</span></li>

    <li><span>aosp_shamu</span></li>

    <li><span>full_fugu</span></li>

    <li><span>aosp_fugu</span></li>

    <li><span>aosp_deb</span></li>

    <li><span>aosp_tilapia</span></li>

    <li><span>aosp_flo</span></li>

    <li><span>aosp_grouper</span></li>
  </ul>

  <p><span>Once we have decided on the target device, fire up a Terminal and run:</span></p>
  <pre><span class="strong"><strong>$ export TARGET_PRODUCT=aosp_arm</strong></span>
</pre>

  <h4 class="Title-3 sigil_not_in_toc"><span>The TARGET_BUILD_VARIANT variable</span></h4>

  <p><span>Every </span><code class="literal"><span>Android.mk</span></code><span> file refers to this variable to enable and disable the sections of its codebase to be compiled or not. This variable has three possible values and it specifies the build variant. We can set it to:</span></p>

  <ul>
    <li><code class="literal"><span>eng</span></code><span>: Here, every module tagged with user, debug, and </span><code class="literal"><span>eng</span></code><span> is enabled</span></li>

    <li><code class="literal"><span>userdebug</span></code><span>: Here, every module tagged with the user and debug is enabled</span></li>

    <li><code class="literal"><span>user</span></code><span>: Here, every module tagged with the user is enabled</span></li>
  </ul>

  <p><span>We can use the variable as follows:</span></p>
  <pre><span class="strong"><strong>$ export TARGET_BUILD_VARIANT=eng</strong></span>
</pre>

  <h4 class="Title-3 sigil_not_in_toc"><span>The TARGET_BUILD_TYPE variable</span></h4>

  <p><span>This variable specifies which type of build we are going to perform for every module. If we are going to create a development system, we are going to need more logging information, for instance. For this scenario, we are going to set this variable as </span><code class="literal"><span>debug</span></code><span>, build, and test our system. After this phase, we will rebuild the system with this variable set to </span><code class="literal"><span>release</span></code><span>, to disable the verbose logging and all the development perks.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>The TARGET_TOOLS_PREFIX variable</span></h4>

  <p><span>This variable specifies the path for a custom toolchain to be used during the build process. Usually, it stays empty, but, gaining experience, you should try different toolchains, freely available on the Internet. One of the most famous and optimized custom toolchains is developed and distributed by the </span><code class="literal"><span>Linaro</span></code><span> team.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>The OUT_DIR variable</span></h4>

  <p><span>If for some specific reason we want to override the default path of the </span><code class="literal"><span>out/</span></code><span> folder, we can use this variable to specify a custom path. This variable is extremely useful in all the scenarios that have multiple hard drives or network shares. For instance, we could run the build process on a fast SSD disk and store the output on a standard old-fashioned disk or even a network disk, to share it with our teammates.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>The TARGET_PREBUILT_KERNEL variable</span></h4>

  <p><span>This is a quite advanced variable. It allows us to provide the system with a kernel different from the default one. Every target device comes with a precompiled default kernel because the Android build system is not going to build it—it's already there.</span></p>

  <p><span>Injecting a custom kernel is a very interesting topic that opens lots of interesting scenarios. In </span><a class="link" href="" title="Chapter 5. Customizing Kernel and Boot Sequence"><span>Chapter 5</span></a><span>, </span><span class="emphasis"><em><span>Customizing Kernel and Boot Sequence</span></em></span><span>, we are going to build a custom kernel and inject it into our Android system, to create a fully customized Android experience: this variable will be one of the most important pieces of the puzzle.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>The buildspec.mk file</span></h4>

  <p><span>If we want to persist these variables, we can add them to a </span><code class="literal"><span>buildspec.mk</span></code><span> file. Every time we will run </span><code class="literal"><span>make</span></code><span>, the system will check this file, evaluate all the variables, and move forward accordingly. The </span><code class="literal"><span>buildspec.mk</span></code><span> file comes in a handy template version in the </span><code class="literal"><span>build/</span></code><span> folder as </span><code class="literal"><span>buildspec.mk.default</span></code><span>. This template file contains every available variable. Every variable is commented, disabled by default, and comes with a small note about its purpose and how to use it.</span></p>

  <p><span>We could consider this file the equivalent of the Linux kernel </span><code class="literal"><span>.config</span></code><span> file, even if we have a smaller amount of possible configurations.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>The lunch command</span></h4>

  <p><span>A few sections ago, we had a first bite at </span><code class="literal"><span>lunch</span></code><span> already. If we don't want to manually set all those environment variables or we don't want to use </span></p></div>
<div><p><code class="literal"><span>buildspec.mk</span></code><span>, we can use </span><code class="literal"><span>lunch</span></code><span>. We can find it available in the system, after we have executed </span><code class="literal"><span>envsetup.sh</span></code><span>.</span></p>

  <p><span>Let's have a look at the command. Open a Terminal and reach your </span><code class="literal"><span>WORKING_DIRECTORY</span></code><span>. Be sure to have launched </span><code class="literal"><span>envsetup.sh</span></code><span> and then run:</span></p>
  <pre><span class="strong"><strong>$ lunch</strong></span>
</pre>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_42.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_42" style="max-width:646px;max-height:602px"/></div>

  <p><span>The preceding screenshot shows the output of the command and, as you can easily see, it helps us to pick the exact combination on the variable we want. Every specific Android version has its own </span><code class="literal"><span>lunch</span></code><span> command and every lunch command version has its output. The preceding screenshot shows the output for tag android-5.1.1.</span></p>

  <p><span>Once you have picked the desired configuration, </span><code class="literal"><span>lunch</span></code><span> will show a summary of every variable it's going to set up and goes back to the Terminal, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_43.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_43" style="max-width:646px;max-height:426px"/></div>

  <p><span>We are now ready to fire out the </span><code class="literal"><span>make</span></code><span> command and build our first Android version!</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Building the system</span></h3>

  <p><span>You have downloaded the source code, initialized the whole environment using </span><code class="literal"><span>envsetup.sh</span></code><span> and configured every system variable with </span><code class="literal"><span>lunch</span></code><span>. You are now ready to build the system. Open a Terminal and run:</span></p>
  <pre><span class="strong"><strong>:~$ make –j8</strong></span>
</pre>

  <p><span>The building system will fire up, looking for all those modules and </span><code class="literal"><span>Android.mk</span></code><span> files to include into the build process and perform the compilation.</span></p>

  <p><span>If you want to enjoy a more verbose compilation output, you can run:</span></p>
  <pre><span class="strong"><strong>:~$ make –j8 showcommands</strong></span>
</pre>

  <p><span>With this extra parameter, the build system will print all </span><span class="emphasis"><em><span>GCC</span></em></span><span> compilation logs and all </span><code class="literal"><span>javac</span></code><span> compilation logs, to give you as much information as possible during the building process.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>More about make</span></h4>

  <p><span>The </span><code class="literal"><span>make</span></code><span> command offers a few interesting options that come handy in specific scenarios.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>Building a module</span></h4>

  <p><span>For instance, if you want to build just one single module, you can run:</span></p>
  <pre><span class="strong"><strong>~$ make art</strong></span>
</pre>

  <p><span>In this example, we are building only </span><code class="literal"><span>art</span></code><span>. The module name is contained in the </span><code class="literal"><span>Android.mk</span></code><span> file of the </span><code class="literal"><span>module</span></code><span> folder. Just scroll the file and you will find a variable </span><code class="literal"><span>LOCAL_MODULE</span></code><span> that represents the exact module name to use with </span><code class="literal"><span>make</span></code><span>.</span></p>

  <p><span>We can retrieve the module name also using the </span><code class="literal"><span>mm</span></code><span> command. With a Terminal, just reach the module folder and run:</span></p>
  <pre><span class="strong"><strong>$ mm</strong></span>
</pre>

  <h4 class="Title-4 sigil_not_in_toc"><span>Cleaning a module</span></h4>

  <p><span>If we are not satisfied after the module building is completed, we can clean all the compilation files and have a fresh start. Open a Terminal, reach the module folder, and run:</span></p>
  <pre><span class="strong"><strong>~$ make clean-&lt;module&gt;</strong></span>
</pre>

  <h4 class="Title-4 sigil_not_in_toc"><span>Cleaning everything</span></h4>

  <p><span>If you want to clean the whole project and prepare the system for a new from-scratch build, open a Terminal, reach the </span><code class="literal"><span>WORKING_DIRECTORY</span></code><span>, and run:</span></p>
  <pre><span class="strong"><strong>~$ make clean</strong></span>
</pre>

  <p><span>This command removes every compilation file from the folder we have specified in the </span><code class="literal"><span>OUT_DIR</span></code><span> variable.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>Listing modules</span></h4>
  <pre><span class="strong"><strong>$ make modules</strong></span>
</pre>

  <p><span>This command shows the list of every module available in the AOSP architecture. The amount of available modules is massive: we will have to wait for a few seconds to see any output from this command.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>Recreating an image</span></h4>

  <p><span>This command recreates the system images, based on the current status of the source base, using an incremental building approach, as shown here:</span></p>
  <pre><span class="strong"><strong>$ make snod</strong></span>
</pre>

  <p><span>This is a crucial command during development. Think about developing a single module. When you reach a development milestone, you build the module with:</span></p>
  <pre><span class="strong"><strong>$ make module_name</strong></span>
</pre>

  <p><span>If everything is working, you might like to inject your brand new module into your Android system image. You can achieve this with:</span></p>
  <pre><span class="strong"><strong>:$ make module_name snod</strong></span>
</pre>

  <h4 class="Title-4 sigil_not_in_toc"><span>Building tools</span></h4>

  <p><span>The following command will create and provide us with two of the most important tools for an Android expert—</span><code class="literal"><span>adb</span></code><span> and </span><code class="literal"><span>fastboot</span></code><span>:</span></p>
  <pre><span class="strong"><strong>:$ make tools</strong></span>
</pre>

  <p><span>We will have plenty of time to learn about them in the next pages.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Beyond the system image</span></h4>

  <p><span>We are currently building a system image ready to be flashed to a device. Unfortunately, this procedure keeps out a few useful tools that we want to build as well: NDK, SDK, and CTS.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>Android SDK</span></h4>

  <p><span>Google provides the official Android SDK via the Android Developers website. It's already compiled for every platform and ready to be downloaded. In a more advanced scenario, you might need to extend the SDK and redistribute it as your own. Building a custom SDK is a three command job, with those we already learned about in the previous sections:</span></p>
  <pre><span class="strong"><strong>~$ . build/envsetup.sh</strong></span>
<span class="strong"><strong>~$ lunch sdk-eng</strong></span>
<span class="strong"><strong>~$ make</strong></span>
</pre>

  <p><span>The output of this procedure will be a brand new custom Android SDK in </span><code class="literal"><span>out/host/linux-x86/sdk/</span></code><span>.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>Android NDK</span></h4>

  <p><span>Android NDK is the native equivalent, based on C/C++, of the Android SDK, based on Java. To build the NDK, open a Terminal, reach </span><code class="literal"><span>WORKING_DIRECTORY</span></code><span>, and run:</span></p>
  <pre><span class="strong"><strong>~$ cd ndk/build/tools</strong></span>
<span class="strong"><strong>~$ export ANDROID_NDK_ROOT=path/to/WORKING_DIRECTORY/ndk</strong></span>
<span class="strong"><strong>~$ ./make-release</strong></span>
</pre>

  <p><span>The system will alert you about the possible long duration of the process. Just accept the message and prepare some coffee in the meantime.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>Android CTS</span></h4>

  <p><span>CTS is a well-known tool. We learned everything about it in the previous chapters. To build our own version, we need only one command:</span></p>
  <pre><span class="strong"><strong>~$ make cts</strong></span>
</pre>

  <h3 class="Title-2 sigil_not_in_toc"><span>Inside an AOSP module</span></h3>

  <p><span>The AOSP project is incredibly huge. The amount of modules contained in the source base is massive. Android 5 Lollipop contains about 4,000 different modules. They go from native modules, written in C/C++, to providing system components: daemons, libraries, and Java modules, to provide everything that is needed from APKs to JAR files.</span></p>

  <p><span>Every module contains an Android.mk file. This file contains every single piece of information needed to build the module. The Android build system does not use a recursive-make approach, but merges every Android.mk file to create one single huge Makefile to build the system: every Android.mk file is a piece of the puzzle.</span></p>

  <p><span>In addition to Android.mk, the module folder also contains </span><code class="literal"><span>CleanSpeck.mk</span></code><span>. This file helps the system to properly clean every compiled file when we execute a module clean command.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Diving into Android.mk</span></h4>

  <p><span>The quickest path to knowledge is getting your hands dirty. We are going to analyze a real Android.mk file from the Android source code to understand structure and purpose. In the previous chapter, we learned that the </span><code class="literal"><span>external/</span></code><span> folder contains lots of third-party tools that enrich the Android system. One of these tools is </span><code class="literal"><span>netcat</span></code><span>. Let's see its Android.mk file:</span></p>
  <pre>LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_SRC_FILES:=\
        netcat.c \
        atomicio.c

LOCAL_CFLAGS:=-O2 -g

LOCAL_MODULE_TAGS := eng

LOCAL_MODULE_PATH := $(TARGET_OUT_OPTIONAL_EXECUTABLES)

LOCAL_MODULE:=nc

# gold in binutils 2.22 will warn about the usage of mktemp
LOCAL_LDFLAGS += -Wl,--no-fatal-warnings

include $(BUILD_EXECUTABLE)</pre>

  <p><span>A few cryptic lines that need more detailed study:</span></p>
  <pre>LOCAL_PATH:= $(call my-dir)</pre>

  <p><span>This line specifies the </span><code class="literal"><span>LOCAL_PATH</span></code><span> variable and sets it to the current module path. As you can guess, the </span><code class="literal"><span>$(call my-dir)</span></code><span> function returns the current module path.</span></p>

  <p><span>This function is part of a collection of useful functions that the system provides to be used during the development of new modules. The whole list is contained in </span><code class="literal"><span>build/core/definitions.mk</span></code><span>. Every function comes with code, obviously, and a tiny, but effective description of its purpose, as shown in the next screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_44.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_44" style="max-width:646px;max-height:562px"/></div>
  <pre>include $(CLEAR_VARS)</pre>

  <p><span>This line solves one big issue due to the nature of the Android build system—having all the Android.mk files merged into one single Makefile creates a dangerous scenario in which </span><code class="literal"><span>LOCAL_</span></code><span> variables from module A could be improperly used by module B. The </span><code class="literal"><span>$(CLEAR_VARS)</span></code><span> function resets all the previously set variables and allows the current module to safely access its local variables, using this code:</span></p>
  <pre>LOCAL_SRC_FILES:=\
        netcat.c \
        atomicio.c</pre>

  <p><span>The following line specifies the source files contained in the current module:</span></p>
  <pre>LOCAL_CFLAGS:=-O2 -g</pre>

  <p><span>The following line specifies which argument we are going to pass to the compiler:</span></p>
  <pre>LOCAL_MODULE_TAGS := eng</pre>

  <p><span>This line specifies which variant this module belongs to. This is closely related to the environment variable </span><code class="literal"><span>TARGET_BUILD_VARIANT</span></code><span> we learned about in the previous sections. Specifying </span><code class="literal"><span>eng</span></code><span> here will make this module available when we will build the </span><code class="literal"><span>eng</span></code><span> build variant of the system:</span></p>
  <pre>LOCAL_MODULE_PATH := $(TARGET_OUT_OPTIONAL_EXECUTABLES)</pre>

  <p><span>This line specifies where to install the compiled executable file when the build process succeeds. In this specific case, the final file will be placed in the </span><code class="literal"><span>xbin/</span></code><span> folder of the system image. This variable is optional. The system will act based on default values, already specified in the global configuration. We can use this variable to specify a </span><span class="emphasis"><em><span>different</span></em></span><span> destination folder:</span></p>
  <pre>LOCAL_MODULE:=nc</pre>

  <p><span>This line has been anticipated a few sections ago. This specifies the module name. It has to be unique and it will also be the executable file's final name. In this case, our </span><code class="literal"><span>netcat</span></code><span> utility will become the </span><code class="literal"><span>nc</span></code><span> exectutable, as commonly seen on </span><code class="literal"><span>*nix</span></code><span> systems:</span></p>
  <pre>LOCAL_LDFLAGS += -Wl,--no-fatal-warnings</pre>

  <p><span>As for the compiler also, the linker will have its set of specific arguments. This line specifies which options the linker will operate according to:</span></p>
  <pre>include $(BUILD_EXECUTABLE)</pre>

  <p><span>This line specifies which type of module we are trying to build. Our current module is an executable utility, so we are going to specify </span><code class="literal"><span>$(BUILD_EXECUTABLE)</span></code><span> and the system will properly produce an executable file from all the module source code.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Android.mk variables ecosystem</span></h4>

  <p><span>In the previous section, we analyzed a real-world Android.mk. This gave us a bit of confidence about creating our own Android module. In this section, we will continue our journey with an overview about all the variables we can use in our Android.mk.</span></p>

  <p><code class="literal"><span>LOCAL_</span></code><span> variables are all those variables necessary to achieve the proper module configuration and compilation. These kinds of variables get canceled by </span><code class="literal"><span>$(CLEAN_VARS)</span></code><span> and are by far the most common kind in all Android.mk files.</span></p>

  <p><span>The </span><code class="literal"><span>INTERNAL_</span></code><span>, </span><code class="literal"><span>HOST_</span></code><span>, and </span><code class="literal"><span>TARGET_</span></code><span> variables should not be used for custom purposes because they are commonly used by the build system itself.</span></p>

  <p><span>The </span><code class="literal"><span>BUILD_</span></code><span> variables specify the build type, as we already saw in a previous example where we used </span><code class="literal"><span>BUILD_EXECUTABLE</span></code><span>.</span></p>

  <p><span>Technically speaking, we could use any kind of variable, but that's a dangerous game. It is hard to predict how the build system will manipulate our Android.mk files to create its Makefile: order might be not respected, names could be overridden, and scopes could be invalidated. To play safely and rely on the build system architecture, let's focus on using only </span><code class="literal"><span>LOCAL_</span></code><span> variables for our tasks.</span></p>

  <p><span>There is no official documentation about these variables. The upcoming list is the result of hard work, taking risks, guessing, and scavenging bits of information from all around the build system.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>The LOCAL_ variables</span></h4>

  <p><span>When it comes to </span><code class="literal"><span>LOCAL_</span></code><span> variables, we can customize our module according to this list:</span></p>

  <ul>
    <li><code class="literal"><span>LOCAL_PATH</span></code><span>: This specifies the path of the module. Usually, the value is retrieved using the </span><code class="literal"><span>$(call my-dir)</span></code><span> function.</span></li>

    <li><code class="literal"><span>LOCAL_MODULE</span></code><span>: This specifies the name of the module and, if we are dealing with an executable module, the name of the executable.</span></li>

    <li><code class="literal"><span>LOCAL_MODULE_CLASS</span></code><span>: This specifies the class the module belongs to. Based on its class, every result of the module building process will be placed in the proper folder. The examples of possible classes are </span><code class="literal"><span>EXECUTABLE</span></code><span>, </span><code class="literal"><span>ETC</span></code><span>, </span><code class="literal"><span>SHARED_LIBRARY</span></code><span>, </span><code class="literal"><span>STATIC_LIBRARY</span></code><span>, and </span><code class="literal"><span>APPS</span></code><span>.</span></li>

    <li><code class="literal"><span>LOCAL_SRC_FILES</span></code><span>: This specifies the list of all source files contained in the module, separated by whitespace.</span></li>

    <li><code class="literal"><span>LOCAL_PACKAGE_NAME</span></code><span>: This specifies the name of the app, for instance: Contacts, Phone, Calculator, and so on.</span></li>

    <li><code class="literal"><span>LOCAL_SHARED_LIBRARIES</span></code><span>: This specifies the shared libraries that may be required.</span></li></ul></div>
<div><ul><li/>

    <li><code class="literal"><span>LOCAL_MODULE_TAGS</span></code><span>: This specifies a tag, such as </span><code class="literal"><span>eng</span></code><span>, and the system will include this module in every build that will target the </span><code class="literal"><span>eng</span></code><span> type as </span><code class="literal"><span>TARGET_BUILD_VARIANT</span></code><span>.</span></li>

    <li><code class="literal"><span>LOCAL_MODULE_PATH</span></code><span>: This specifies a custom installation path to override the one specified in the </span><code class="literal"><span>BUILD_</span></code><span> template.</span></li>

    <li><code class="literal"><span>LOCAL_CC</span></code><span>: This specifies a different C compiler to be used.</span></li>

    <li><code class="literal"><span>LOCAL_CXX</span></code><span>: This specifies a different C++ compiler to be used.</span></li>

    <li><code class="literal"><span>LOCAL_CFLAGS</span></code><span>: This helps to add mode flags to the C compiler command line.</span></li>

    <li><code class="literal"><span>LOCAL_CPPFLAGS</span></code><span>: This helps to add mode flags to the C++ compiler command line.</span></li>

    <li><code class="literal"><span>LOCAL_CPP_EXTENSION</span></code><span>: This specifies a custom extension for C++ files, if for some reason the actual extension is not </span><code class="literal"><span>.cpp</span></code><span>.</span></li>

    <li><code class="literal"><span>LOCAL_C_INCLUDE</span></code><span>: This specifies the path for custom C header files needed to build the module.</span></li>

    <li><code class="literal"><span>LOCAL_LDFLAGS</span></code><span>: This helps to add mode flags to the linker command line.</span></li>

    <li><code class="literal"><span>LOCAL_PREBUILT_EXECUTABLES</span></code><span>: During the creation of a </span><code class="literal"><span>BUILD_PREBUILD</span></code><span> kind of module, this variable will contain every binary executable that will be part of the final system image. We are going to learn more about this in the next chapters.</span></li>

    <li><code class="literal"><span>LOCAL_PREBUILT_LIBS</span></code><span>: During the creation of a </span><code class="literal"><span>BUILD_PREBUILD</span></code><span> kind of module, this variable will contain every library that will be part of the final system image.</span></li>

    <li><code class="literal"><span>LOCAL_PREBUILT_PACKAGE</span></code><span>: During the creation of a </span><code class="literal"><span>BUILD_PREBUILD</span></code><span> kind of module, this variable will contain every prebuild APK that will be part of the final system image.</span></li>
  </ul>

  <h4 class="Title-4 sigil_not_in_toc"><span>The BUILD_ variables</span></h4>

  <p><span>The following list contains the most common </span><code class="literal"><span>BUILD_</span></code><span> variables available during the development of a custom module:</span></p>

  <ul>
    <li>
      <code class="literal"><span>BUILD_EXECUTABLE</span></code><span>: When necessary to build using native C/C++ code, we can add this line to our configuration:

      </span><pre>include $(BUILD_EXECUTABLE)</pre>
    </li>

    <li><code class="literal"><span>BUILD_PREBUILT</span></code><span>: This allows us to add binary components to our final image.</span></li>

    <li><code class="literal"><span>BUILD_MULTI_PREBUILT</span></code><span>: This allows us to create modules that inject the final image with binarie components of the same category. It's usually used with </span><code class="literal"><span>LOCAL_MODULE_CLASS</span></code><span> to specify the class and the position to place the binary files.</span></li>

    <li><code class="literal"><span>BUILD_PACKAGE</span></code><span>: This allows us to create modules that generate APK files.</span></li>

    <li><code class="literal"><span>BUILD_SHARED_LIBRARY</span></code><span>: This allows us to create modules that generate shared library files.</span></li>

    <li><code class="literal"><span>BUILD_STATIC_LIBRARY</span></code><span>: This allows us to create modules that generate static library files.</span></li>

    <li><code class="literal"><span>BUILD_JAVA_LIBRARY</span></code><span>: This allows us to create modules that generate Java library files.</span></li>
  </ul>

  <h4 class="Title-3 sigil_not_in_toc"><span>Module template examples</span></h4>

  <p><span>In this section, we are going to analyze real-world module template snippets, to have a clear idea about what a fully operational module template looks like.</span></p>

  <h4 class="Title-4 sigil_not_in_toc"><span>The native executable template</span></h4>

  <p><span>If you are going to work on a generic native single-file executable application, for example, </span><code class="literal"><span>your_executable.c</span></code><span>, you can use the following snippet to build it:</span></p>
  <pre>LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)         

LOCAL_SRC_FILES:= your_executable.c       
LOCAL_MODULE:= your_executable            

include $(BUILD_EXECUTABLE)</pre>

  <h4 class="Title-4 sigil_not_in_toc"><span>The shared library template</span></h4>

  <p><span>This snippet comes in handy if you are working with a so-called shared library: your library would be composed of a set of files, that is, </span><code class="literal"><span>foo.c</span></code><span> and </span><code class="literal"><span>bar.c</span></code><span>, and would be built accordingly:</span></p>
  <pre>LOCAL_PATH:= $(call my-dir)     
include $(CLEAR_VARS)
 
LOCAL_SRC_FILES:= foo.c bar.c
LOCAL_MODULE:= libmysharedlib
LOCAL_PRELINK_MODULE := false   # Prevent from prelink error

include $(BUILD_SHARED_LIBRARY) </pre>

  <h4 class="Title-4 sigil_not_in_toc"><span>The application template</span></h4>

  <p><span>If you are going to work on a whole application, you could use the following snippet:</span></p>
  <pre>LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS:= eng
LOCAL_SRC_FILES:= $(call all-java-files-under src)
LOCAL_PACKAGE_NAME:= MyApplication

include $(BUILD_PACKAGE)</pre>

  <p><span>This snippet will build every </span><code class="literal"><span>.java</span></code><span> file in the specified path and package everything as </span><code class="literal"><span>MyApplication</span></code><span>.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Creating a custom device</span></h2>

  <p><span>During our journey, you learned how to retrieve the source code and how to set up the build system. In this section, you are going to learn how to create a new target device and add it to the build system. The device we are going to create now has specific hardware features. It's a proof-of-concept device, with the only purpose of showing you how easily and quickly you can create a brand new device and then customize it.</span></p>

  <p><span>Every device definition is contained in the </span><code class="literal"><span>device/</span></code><span> folder. First level folders contains all the manufacturer's folders. Every manufacturer folder contains its own devices. Let's create our own manufacturer and device folders: our brand is Irarref and our model is an F488. Open a Terminal, reach the </span><code class="literal"><span>WORKING_DIRECTORY</span></code><span> folder, and run:</span></p>
  <pre><span class="strong"><strong>~$ mkdir –p device/irarref/f488</strong></span>
</pre>

  <p><span>Once we have the folder structure in place, we need to create all those files that will allow the build system to detect our device and make it available as a target for the build system. We are going to create the following files:</span></p>

  <ul>
    <li><code class="literal"><span>Android.mk</span></code><span>: Describes in a generic way how to compile the source files. Essentially, it represents a snippet of the global Makefile that will be later incorporated by the build system at the appropriate time.</span></li>

    <li><code class="literal"><span>AndroidProducts.mk</span></code><span>: This file contains a </span><code class="literal"><span>PRODUCS_MAKEFILEs</span></code><span> variable, with a list of all the available products. In our scenario, we only have one device and it's represented by these files.</span></li>

    <li><code class="literal"><span>full_f488.mk</span></code><span>: This file specifies any relevant information about the device.</span></li>

    <li><code class="literal"><span>BoardConfig.mk</span></code><span>: This file specifies any relevant information about the device board.</span></li>

    <li><code class="literal"><span>vendorsetup.sh</span></code><span>: This script makes the device available to </span><code class="literal"><span>envsetup.sh</span></code><span> and </span><code class="literal"><span>lunch</span></code><span>.</span></li>
  </ul>

  <h3 class="Title-2 sigil_not_in_toc"><span>Diving into device configuration</span></h3>

  <p><span>As we know, our first device is quite simple, but very instructive. Let's see how our device specification is spread inside all our configuration files:</span></p>

  <ul>
    <li>
      <code class="literal"><span>Android.mk</span></code><span>:</span><span>
</span><span>
</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><pre>LOCAL_PATH:= $(call my-dir)
Include $(CLEAN_VARS)

Ifneq ($(filter f488, $(TARGET_DEVICE)),)
Include $(call all-makefile-unter, $(LOCAL_PATH))
Endif</pre>
    </li>

    <li>
      <code class="literal"><span>AndroidProducts.mk</span></code><span>:</span><span>
</span><span>
</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><pre>PRODUCT_MAKEFILES:= $(LOCAL_DIR)/full_f488.mk</pre>
    </li>

    <li>
      <code class="literal"><span>full_f488.mk</span></code><span>:</span><span>
</span><span>
</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><pre>$(call inherit-product, 
$(SRC_TARGET_DIR)/product/aosp_base.mk
#
DEVICE_PACKAGE_OVERLAY:=

PRODUCT_PACKAGE+=
PRODUCT_COPY_FILES+=
PRODUCT_NAME:= full_f488
PRODUCT_DEVICE:= f488
PRODUCT_MODEL:= Android for Irarref F488</pre>
    </li>

    <li>
      <code class="literal"><span>BoardConfig.mk</span></code><span>:</span><span>
</span><span>
</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><pre>TARGET_NO_BOOTLOADER := true
TARGET_NO_KERNEL := true
TARGET_CPU_ABI := armeabi
HAVE_HTC_AUDIO_DRIVER := true
BOARD_USES_GENERIC_AUDIO := true

# no hardware camera
USE_CAMERA_STUB := true

# CPU
TARGET_ARCH_VARIANT := armv7-a-neon
ARCH_ARM_HAVE_TLS_REGISTER := true</pre>
    </li>

    <li>
      <code class="literal"><span>vendorsetup.sh</span></code><span>:</span><span>
</span><span>
</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><pre>add_lunch_combo full_f488-eng</pre>
    </li>
  </ul>

  <p><span>Our </span><code class="literal"><span>Android.mk</span></code><span> is pretty standard and completely based on what we have learned in the previous sections. </span><code class="literal"><span>AndroidProducts.mk</span></code><span> just includes </span><code class="literal"><span>full_f488.mk</span></code><span>, as expected.</span></p>

  <p><span>The </span><code class="literal"><span>full_f488.mk</span></code><span> file contains a few interesting lines. First of all, it includes </span><code class="literal"><span>aosp_base.mk</span></code><span>, a configuration file provided by the system, common to lots of real devices.</span></p>

  <p><span>Moving on, we found a few interesting variables:</span></p>

  <ul>
    <li><code class="literal"><span>DEVICE_PACKAGE_OVERLAY:=</span></code><span>: This variable allows us to create a custom overlay, customizing, for instance, some settings of specific modules in the AOSP system. If you check, for instance, this variable in the equivalent file for the </span><code class="literal"><span>shamu</span></code><span> device, you can notice that they are using it to customize a few settings in the launcher application.</span></li>

    <li><code class="literal"><span>PRODUCT_PACKAGE+=</span></code><span>: This variable allows us to add packages to the compilation process.</span></li>

    <li><code class="literal"><span>PRODUCT_COPY_FILES+=</span></code><span>: This variable performs a file copy operation. The syntax is pretty straight forward: </span><code class="literal"><span>source_file:dest_file</span></code></li>

    <li><code class="literal"><span>PRODUCT_NAME:= full_f488</span></code><span>: This variable specifies the product name. This is the exact same value that </span><code class="literal"><span>lunch</span></code><span> will print as </span><code class="literal"><span>TARGET_PRODUCT</span></code><span>.</span></li>

    <li><code class="literal"><span>PRODUCT_DEVICE:= f488</span></code><span>: This variable specifies the device name.</span></li>

    <li><code class="literal"><span>PRODUCT_MODEL:=</span></code><span>: Android for Irarref F488: This variable specifies the device model label that we will find in our Android system under </span><span class="strong"><strong><span>Settings</span></strong></span><span> | </span><span class="strong"><strong><span>About phone</span></strong></span><span> | </span><span class="strong"><strong><span>Model Number</span></strong></span><span>.</span></li>
  </ul>

  <p><span>With all these files in place, you can now relaunch </span><code class="literal"><span>envsetup.sh</span></code><span> and our brand new proof-of-concept device will be in the list of the available devices.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>From zero to the screenlock</span></h2>

  <p><span>So far we have gathered an incredible amount of information about the architecture, about how to configure the build system, and our PoC device. It's time to create our first image for a real device and use it! We want to keep away all the possible hardware-related issues, so we will target the simplest nonhardware Android device: the Android emulator.</span></p>

  <p><span>We are going to build the latest available Android Lollipop source code. As we learned, we are going to download it, configure it to target the emulator, build it, and try it on the device.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Setup</span></h3>

  <p><span>Let's set up our </span><code class="literal"><span>WORKING_DIRECTORY</span></code><span> and download our precious source code. Open a Terminal and run the following commands:</span></p>
  <pre><span class="strong"><strong>:$ mkdir WORKING_DIRECTORY</strong></span>
<span class="strong"><strong>:$ cd WORKING_DIRECTORY</strong></span>
<span class="strong"><strong>:$ repo init –u https://android.googlesource.com/platform/manifest -b \</strong></span>
<span class="strong"><strong>android-5.1.1_r9</strong></span>
<span class="strong"><strong>:$ repo sync</strong></span>
</pre>

  <p><span>After the download is completed, we can configure the environment. Let's run:</span></p>
  <pre><span class="strong"><strong>:$ build/envsetup.sh</strong></span>
</pre>

  <p><span>This will create all those handy tools we will need during the work. We now have </span><code class="literal"><span>lunch</span></code><span>, for instance, and running it we can keep on configuring the environment:</span></p>
  <pre><span class="strong"><strong>:$ lunch</strong></span>
</pre>

  <p><span>Let's choose a target device:</span></p>
  <pre><span class="strong"><strong>aosp_arm-eng</strong></span>
</pre>

  <p><span>The </span><code class="literal"><span>lunch</span></code><span> command will set up everything and show us a configuration report, as shown in the next screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_45.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_45" style="max-width:646px;max-height:434px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Build</span></h3>

  <p><span>Everything is in place. We need only one command to launch the build procedure:</span></p>
  <pre><span class="strong"><strong>:$ make –j8</strong></span>
</pre>

  <p><span>Once the build process is over, head to </span><code class="literal"><span>out/target/product/generic/</span></code><span>. This folder will contain our built images. The following screenshot shows the result of the build process: a folder full of </span><code class="literal"><span>.img</span></code><span> files, ready to be flashed into the device:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_46.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_46" style="max-width:646px;max-height:354px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Run</span></h3>

  <p><span>To launch the emulator, Android provides the </span><code class="literal"><span>emulator</span></code><span> command. This command will be available the moment the compilation ends. Using the </span><code class="literal"><span>.img</span></code><span> files, we have in the </span><code class="literal"><span>out/</span></code><span> folder, we can run it like this:</span></p>
  <pre><span class="strong"><strong>$ emulator -system out/target/product/generic/system.img -ramdisk out/target/product/generic/ramdisk.img -data out/target/product/generic/userdata-qemu.img</strong></span>
</pre>

  <p><span>After a few moments, the emulator window will pop up and you will see something like the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_47.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_47" style="max-width:795px;max-height:565px"/></div>

  <p><span>You can use the emulator with mouse and keyboard, performing the same operations you would do on a real device. Android emulator is a powerful tool and the amount of possibilities is almost endless. If you would like to dig into the topic, the Android Developers website provides a specific page for it: </span><a class="ulink" href="http://developer.android.com/tools/help/emulator.html"><span>http://developer.android.com/tools/help/emulator.html</span></a><span>.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Summary</span></h2>

  <p><span>This chapter was a great run! You prepared your system to build your first Android system. You learned how to configure and customize the build system. You learned the basic skills to create a custom module and include it into your system image. You created a system image from scratch and tested it on the Android emulator.</span></p>

  <p><span>In the next chapter, we will raise the bar. We are going to move our efforts to a real hardware device. We will work with a smartphone, the Nexus 5, and a development board, the UDOO. We will manipulate the bootloader and the recovery partition to take complete control of the system.</span></p>
</div>
		    </div>
		  </body></html>