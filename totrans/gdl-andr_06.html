<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Running Tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Running Tests</h1></div></div></div><p>To ensure the quality of any app or library, having automated tests is important. For a long time, the Android development tools lacked support for automated tests, but recently, Google has put in a lot of effort to make it easier for developers to get started with tests. Some old frameworks have been updated, and new frameworks have been added to make sure we can thoroughly test apps and libraries. We can run them not only from Android Studio, but also directly from the command-line interface, using Gradle.</p><p>In this chapter, we will explore the different ways to test Android apps and libraries. We will also look at how Gradle can help to automate the testing process.</p><p>We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit tests</li><li class="listitem" style="list-style-type: disc">Functional tests</li><li class="listitem" style="list-style-type: disc">Test coverage</li></ul></div><div class="section" title="Unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Unit tests</h1></div></div></div><p>Having well-written unit tests<a id="id228" class="indexterm"/> in your project does not only assure quality, it also makes it easy to check if new code breaks any functionality. Android Studio and the Gradle Android plugin have native support for unit tests, but you need to configure a few things before you can use them.</p><div class="section" title="JUnit"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>JUnit</h2></div></div></div><p>
<span class="strong"><strong>JUnit</strong></span> <a id="id229" class="indexterm"/>is an extremely popular unit testing library that has been around for over a decade. It makes it easy to write tests while making sure that they are also easy to read. Keep in mind that these particular unit tests are only useful for testing business logic and not code that is related to the Android SDK.</p><p>Before you can start writing JUnit tests for your Android project, you need to create a directory for the tests. By convention, this directory is called <code class="literal">test</code> and it should be on the same level as your main directory. The directory structure should look like this:</p><div class="informalexample"><pre class="programlisting">app
└─── src
     ├─── main
     │    ├─── java
     │    │    └─── com.example.app
     │    └───res
     └─── test
          └─── java
               └─── com.example.app</pre></div><p>You can then<a id="id230" class="indexterm"/> create test classes in <code class="literal">src/test/java/com.example.app</code>.</p><p>To make use of the latest features in JUnit, use JUnit version 4. You can ensure this by adding a dependency for the test build:</p><div class="informalexample"><pre class="programlisting">dependencies {
    testCompile 'junit:junit:4.12'
}</pre></div><p>Notice that we are using <code class="literal">testCompile</code> instead of <code class="literal">compile</code> here. We use this configuration to make sure that the dependency is only built when running the tests, and not when packaging the app for distribution. Dependencies added with <code class="literal">testCompile</code> will never be included in the APK releases generated by the regular assemble tasks.</p><p>If you have any special conditions in one of your build types or product flavors, it is possible to add a test-only dependency to that specific build alone. For example, if you only want to add JUnit tests to your paid flavor, you can do that as follows:</p><div class="informalexample"><pre class="programlisting">dependencies {
    testPaidCompile 'junit:junit:4.12'
}</pre></div><p>When everything is set up, it is time to start writing some tests. Here is a simple example of a class that tests a method adding two numbers:</p><div class="informalexample"><pre class="programlisting">import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class LogicTest {
    @Test
    public void addingNegativeNumberShouldSubtract() {
        Logic logic = new Logic();

        assertEquals("6 + -2 must be 4", 4, logic.add(6, -2));
        assertEquals("2 + -5 must be -3", -3, logic.add(2, -5));
    }
}</pre></div><p>To run all tests with Gradle, just execute <code class="literal">gradlew</code> test. If you only want to run the tests on a certain build variant, simply add the name of the variant. If you want to run the tests on only the debug variant, for example, execute <code class="literal">gradlewtestDebug</code>. If a test fails, Gradle prints the error message in the command-line interface. If all the tests run smoothly, Gradle shows the regular <span class="strong"><strong>BUILD SUCCESSFUL</strong></span> message.</p><p>A single <a id="id231" class="indexterm"/>failed test causes the <code class="literal">test</code> task to fail, halting the entire process immediately. This means that not all of your tests are executed in case of a failure. If you want to make sure the entire test suite is executed for all build variants, use the <code class="literal">continue</code> flag:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradlew test --continue</strong></span>
</pre></div><p>You can also write tests specifically for a certain build variant by storing the tests class in the corresponding directory. For example, if you want to test specific behavior in the paid version of your app, put the test class in <code class="literal">src/testPaid/java/com.example.app</code>.</p><p>If you do not want to run the entire test suite, but only the tests for a particular class, you can use the tests flag like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradlew testDebug --tests="*.LogicTest"</strong></span>
</pre></div><p>Executing the test task does not only run all the tests, but also creates a test report, which can be found at a<code class="literal">pp/build/reports/tests/debug/index.html</code>. This report makes it easy to find the issues if there are any failures, and is particularly useful in situations where tests are executed automatically. Gradle will create a report for every build variant that you run the tests on.</p><p>If all your tests run successfully, your unit test report will look like this:</p><div class="mediaobject"><img src="graphics/B01061_06_01.jpg" alt="JUnit"/></div><p>You can also<a id="id232" class="indexterm"/> run the tests within Android Studio. When you do that, you get immediate feedback in the IDE, and you can click on failed tests to navigate to the corresponding code. If all your tests pass, the <span class="strong"><strong>Run</strong></span> tool window will look like this:</p><div class="mediaobject"><img src="graphics/B01061_06_02.jpg" alt="JUnit"/></div><p>If you want to test parts of your code that contain references to Android-specific classes or resources, regular unit tests are not ideal. You may have already tried and run into the <code class="literal">java.lang.RuntimeException: Stub!</code> error. To fix this, you would need to implement every method in the Android SDK yourself, or use a mocking framework. Luckily, several libraries exist that have taken care of the Android SDK. The most popular of those libraries is Robolectric, which provides an easy way to test Android functionality, without the need for a device or emulator.</p></div><div class="section" title="Robolectric"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Robolectric</h2></div></div></div><p>With Robolectric, you can <a id="id233" class="indexterm"/>write tests that make use of the Android SDK and resources, while still running tests inside the Java Virtual Machine. This means that you do not need a running device or emulator to make use of Android resources in your tests, thus making it a lot faster to test the behavior of UI components of an app or library.</p><p>To get started with Robolectric, you need to add a few test dependencies. Besides Robolectric itself, you also need to include JUnit, and, if you make use of the support library, you also need the Robolectric shadow classes to use it:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'org.robolectric'
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'

    testCompile 'junit:junit:4.12'
    testCompile'org.robolectric:robolectric:3.0'
    testCompile'org.robolectric:shadows-support:3.0'
}</pre></div><p>Robolectric tests classes should be created in the <code class="literal">src/test/java/com.example.app</code> directory, just like regular unit tests. The difference is that you can now write tests that involve Android classes and resources. For example, this test validates that the text of a certain <code class="literal">TextView</code> changes after clicking on a specific <code class="literal">Button</code>:</p><div class="informalexample"><pre class="programlisting">@RunWith(RobolectricTestRunner.class)
@Config(manifest = "app/src/main/AndroidManifest.xml", sdk = 18)
public class MainActivityTest {
    @Test
    public void clickingButtonShouldChangeText() {
        AppCompatActivity activity = Robolectric.buildActivity(MainActivity.class).create().get();
        Button button = (Button) activity.findViewById(R.id.button);
        TextView textView = (TextView) activity.findViewById(R.id.label);

        button.performClick();

        assertThat(textView.getText().toString(), equalTo(activity.getString(R.string.hello_robolectric)));
    }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Robolectric <a id="id234" class="indexterm"/>has some known issues with Android Lollipop and the compatibility library. If you run into errors that mention missing resources related to the compatibility library, there is a fix for that.</p><p>You need to add a file to the module called <code class="literal">project.properties</code>, and add these lines to it:</p><div class="informalexample"><pre class="programlisting">android.library.reference.1=../../build/intermediates/exploded-aar/com.android.support/appcompat-v7/22.2.0
android.library.reference.2=../../build/intermediates/exploded-aar/com.android.support/support-v4/22.2.0</pre></div><p>This will help Robolectric find the compatibility library resources.</p></div></div></div></div></div>
<div class="section" title="Functional tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Functional tests</h1></div></div></div><p>
<span class="strong"><strong>Functional tests</strong></span> <a id="id235" class="indexterm"/>are used to test whether several components of an app work together as expected. For example, you can create a functional test to confirm that tapping a certain button opens a new <code class="literal">Activity</code>. There are several functional testing frameworks for Android, but the easiest way to get started with functional testing is using the Espresso framework.</p><div class="section" title="Espresso"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Espresso</h2></div></div></div><p>Google created <span class="strong"><strong>Espresso</strong></span><a id="id236" class="indexterm"/> to make it easier for developers to write functional tests. The library is provided through the Android support repository, so you can install it using the SDK Manager.</p><p>In order to run tests on a device, you need to define a test runner. Through the testing support library, Google provides the <code class="literal">AndroidJUnitRunner</code> test runner, which helps you run JUnit test classes on Android devices. The test runner will load the app APK and the test APK to a device, run all the tests, and then build the reports with the test results.</p><p>Provided you have downloaded the testing support library, this is how you should set up the test runner:</p><div class="informalexample"><pre class="programlisting">defaultConfig {
    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
}</pre></div><p>You also need to set up a few dependencies before you can start using Espresso:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'

    androidTestCompile 'com.android.support.test:runner:0.3'
    androidTestCompile 'com.android.support.test:rules:0.3'
    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2'
    androidTestCompile 'com.android.support.test.espresso:espresso-contrib:2.2'
}</pre></div><p>You need to reference the testing support library and <code class="literal">espresso-core</code> to get started with Espresso. The last dependency, <code class="literal">espresso-contrib</code>, is a library with features that supplement Espresso, but are not part of the core library.</p><p>Notice that these dependencies use the <code class="literal">androidTestCompile</code> configuration, instead of the <code class="literal">testCompile</code> configuration we used earlier. This is to make a distinction between unit tests and functional tests.</p><p>If you were to try to run the test build at this point, you would run into this error:</p><div class="informalexample"><pre class="programlisting">Error: duplicate files during packaging of APK app-androidTest.apk
  Path in archive: LICENSE.txt
  Origin 1: ...\hamcrest-library-1.1.jar
  Origin 2: ...\junit-dep-4.10.jar</pre></div><p>The error itself is very <a id="id237" class="indexterm"/>descriptive. Gradle cannot complete the build because of a duplicate file. Luckily, it is just a license description, so we can strip it out of the build. The error itself contains information on how to do that as well:</p><div class="informalexample"><pre class="programlisting">You can ignore those files in your build.gradle:
  android {
  packagingOptions {
      exclude 'LICENSE.txt'
    }
  }</pre></div><p>Once the build file is set up, you can start adding tests. Functional tests are placed in a different directory than the regular unit tests. Just like with the dependency configurations, you need to use <code class="literal">androidTest</code> instead of just test, so the correct directory for functional tests is <code class="literal">src/androidTest/java/com.example.app</code>. Here is an example of a test class that checks whether the text of <code class="literal">TextView</code> in <code class="literal">MainActivity</code> is correct:</p><div class="informalexample"><pre class="programlisting">@RunWith(AndroidJUnit4.class)
@SmallTest
public class TestingEspressoMainActivityTest {
    @Rule
    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(MainActivity.class);

    @Test
    public void testHelloWorldIsShown() {
        onView(withText("Hello world!")).check(matches(isDisplayed()));
    }
}</pre></div><p>Before you can run Espresso tests, you need to make sure you have a device or emulator. If you forget to connect a device, trying to execute the test task will throw this exception:</p><div class="informalexample"><pre class="programlisting">Execution failed for task ':app:connectedAndroidTest'.
&gt;com.android.builder.testing.api.DeviceException: java.lang.RuntimeException: No connected devices!</pre></div><p>Once you have connected a device or started an emulator, you can run your Espresso tests using <code class="literal">gradlewconnectedCheck</code>. This task will execute both <code class="literal">connectedAndroidTest</code> to run all tests for the debug build on all the connected devices, and <code class="literal">createDebugCoverageReport</code> to create a test report.</p><p>You can find the<a id="id238" class="indexterm"/> generated test reports in the app directory under <code class="literal">build/outputs/reports/androidTests/connected</code>. Open <code class="literal">index.html</code> to view the report, which looks like this:</p><div class="mediaobject"><img src="graphics/B01061_06_03.jpg" alt="Espresso"/></div><p>The functional test report shows which device and Android version the tests are run on. You can run these tests on multiple devices at the same time, so the device information makes it easier to find device- or version-specific bugs.</p><p>If you want to get <a id="id239" class="indexterm"/>feedback on your tests within Android Studio, set up a run/debug configuration to run the tests directly from the IDE. A run/debug configuration represents a set of run/debug startup properties. The Android Studio toolbar has a configuration picker, where you can select the run/debug configuration that you want to use.</p><div class="mediaobject"><img src="graphics/B01061_06_04.jpg" alt="Espresso"/></div><p>To set up a new configuration, open the configuration editor by clicking on <span class="strong"><strong>Edit Configurations…</strong></span> and then create a new Android tests configuration. Select the module and specify the instrumentation runner to be <code class="literal">AndroidJUnitRunner</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B01061_06_05.jpg" alt="Espresso"/></div><p>Once you <a id="id240" class="indexterm"/>save this new configuration, you can select it in the configuration picker and click on the <span class="strong"><strong>Run</strong></span> button to run all tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Running Espresso tests from Android Studio has one caveat: the test report is not generated. The reason for this is that Android Studio executes the <code class="literal">connectedAndroidTest</code> task instead of <code class="literal">connectedCheck</code>, and <code class="literal">connectedCheck</code> is the task that takes care of generating the test report.</p></div></div></div></div>
<div class="section" title="Test coverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Test coverage</h1></div></div></div><p>Once you start writing tests for your <a id="id241" class="indexterm"/>Android projects, it is good to know how much of your code base is covered by tests. There are plenty of test coverage tools for Java, but <span class="strong"><strong>Jacoco</strong></span> is the most popular one. It is also included by default, which makes it easy to get started.</p><div class="section" title="Jacoco"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Jacoco</h2></div></div></div><p>Enabling <a id="id242" class="indexterm"/>coverage reports is very easy. You just need to set <code class="literal">testCoverageEnabled = true</code> on the build type that you are testing. Enable test coverage for the debug build type like this:</p><div class="informalexample"><pre class="programlisting">buildTypes {
  debug {
    testCoverageEnabled = true
  }
}</pre></div><p>When you enable <a id="id243" class="indexterm"/>test coverage, the coverage reports are created when you execute <code class="literal">gradlew connectedCheck</code>. The task that creates the report itself is <code class="literal">createDebugCoverageReport</code>. Even though it is not documented, and it does not appear in the task list when you run <code class="literal">gradlew tasks</code>, it is possible to run it directly. However, because <code class="literal">createCoverageReport</code> depends on <code class="literal">connectedCheck</code>, you cannot execute them separately. The dependency on <code class="literal">connectedCheck</code> also means that you need a connected device or emulator to generate the test coverage report.</p><p>After the task is<a id="id244" class="indexterm"/> executed, you can find the coverage report in the <code class="literal">app/build/outputs/reports/coverage/debug/index.html</code> directory. Every build variant has its own directory for reports, because each variant can have different tests. The test coverage report will look something like this:</p><div class="mediaobject"><img src="graphics/B01061_06_06.jpg" alt="Jacoco"/></div><p>The report shows a nice overview of the coverage on the class level, and you can click through to get more information. In the most detailed view, you can see which lines are tested, and which ones are not, in a useful color-coded file view.</p><p>If you want to specify a particular version of Jacoco, simply add a Jacoco configuration block to the build type, defining the version:</p><div class="informalexample"><pre class="programlisting">jacoco {
  toolVersion = "0.7.1.201405082137"
}</pre></div><p>However, explicitly defining a version is not necessary; Jacoco will work regardless.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we looked at several options to test Android apps and libraries. We started out with simple unit tests, and then looked at more Android-specific testing with Robolectric. Then we covered functional tests and getting started with Espresso. Finally, we looked at enabling test coverage reports to see where the test suite needs to be improved. Now that you know how to run the entire test suite with Gradle and Android Studio, and you can generate coverage reports, there are no excuses not to write tests. In <a class="link" href="ch08.html" title="Chapter 8. Setting Up Continuous Integration">Chapter 8</a>, <span class="emphasis"><em>Setting Up Continuous Integration</em></span>, we will look at more ways to automate tests with continuous integration tools.</p><p>The next chapter covers one of the most important aspects of customizing the build process: creating custom tasks and plugins. The chapter also includes a short introduction to Groovy. This will not only help when creating tasks and plugins, but will also make it easier to understand how Gradle works.</p></div></body></html>