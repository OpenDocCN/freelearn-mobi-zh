<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Using Autorelease Pools</h1></div></div></div><p class="calibre8">Consider that you are returning an object you've created (and therefore own) to a caller. If it's released inside your method, the returning object will be an invalid one. On the other hand, there is the basic rule that you have to release the objects you own; then, how do you release them? Simply put the object in the autorelease pool. The object is then released when the autorelease pool is drained.</p><p class="calibre8">We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Understanding the autorelease pool mechanism</li><li class="listitem">How autorelease pool helps</li><li class="listitem">Autoreleased classes</li><li class="listitem">Autoreleased pool blocks and threads</li><li class="listitem">Memory model in Objective-C</li><li class="listitem">ARC with weak references</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec21" class="calibre1"/>Understanding the autorelease pool mechanism</h1></div></div></div><p class="calibre8">When you first <a id="id45" class="calibre1"/>start developing for Cocoa (iOS or Mac OS) you quickly learn to follow the standard <code class="email">alloc</code>, <code class="email">init</code>, and (eventually) <code class="email">release</code> cycles:</p><div><pre class="programlisting">// Allocate and init
NSMutableDictionary *dictionary = [[NSDictionary alloc] init];

// Do something with dictionary
// ...

// Release
[dictionary release];</pre></div><p class="calibre8">This is great until you discover the convenience of just doing the following:</p><div><pre class="programlisting">// Allocate and init
NSMutableDictionary *dictionary = [NSDictionary dictionary];

// Do something with dictionary
// …</pre></div><p class="calibre8">Let's look inside and see what actually happens:</p><div><pre class="programlisting">NSMutableDictionary *dictionary = [[NSDictionary alloc] init];
return [dictionary autorelease];</pre></div><p class="calibre8">This approach is called autorelease pools and they are a part of the <a id="id46" class="calibre1"/><strong class="calibre2">Automated Reference Counting</strong> (<strong class="calibre2">ARC</strong>) memory management model used by the Cocoa platform.</p><p class="calibre8">The ARC compiler <a id="id47" class="calibre1"/>will autorelease any object for you, unless it's returned from a method that starts with <code class="email">new</code>, <code class="email">alloc</code>, <code class="email">init</code>, <code class="email">copy</code>, or <code class="email">mutableCopy</code> in its name. As before, these objects are placed into an autorelease pool, but in order to introduce a new language construct, <code class="email">NSAutoreleasePool</code> has been replaced by <code class="email">@autoreleasepool</code>, a compiler directive. Even using ARC, we are still free to use <code class="email">autorelease</code> messages to drain/create our pool at any time. It doesn't affect the compiler when implementing <code class="email">retain</code> and <code class="email">release</code> messages, but provides hints when it's safe to make autoreleased objects go out of scope.</p><p class="calibre8">Cocoa frameworks (Foundation Kit, Application Kit, and Core Data) have some suitable methods to handle basic classes that inherit from <code class="email">NSObject</code>, as <code class="email">NSString</code>, <code class="email">NSArray</code>, <code class="email">NSDictionary</code>, and many more. These methods quickly allocate, initialize, and return the created object for you, which will also be autoreleased without you worrying about it so much.</p><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">Note that I really meant "without worrying so much", not "without worrying at all" because even with these handy frameworks that create and clear the object for you, there will be cases when you want to take more control and create additional autorelease pools yourself.</p></div><p class="calibre8">Basically, an autorelease pool stores objects and when it's drained, it just sends the object a <code class="email">release</code> message. The <code class="email">NSAutoreleasePool</code> class is used to support Cocoa's reference-counted memory management system.</p><p class="calibre8">Autorelease pools were made by Apple and have been part of the language itself since OS X 10.7. If a program references the <code class="email">NSAutoreleasePool</code> class while in ARC mode, it's considered invalid and is rejected in the build phase. Instead, in ARC mode, you need to replace it with <code class="email">@autoreleasepool</code> blocks, thus defining a region where an autorelease pool is valid, as you can see in the following code:</p><div><pre class="programlisting">// Code in non-ARC mode NSAutoreleasePool *myPool = [[NSAutoreleasePool alloc] init];
// Taking advantage of a local autorelease pool.
[myPool release];</pre></div><p class="calibre8">In ARC mode, however, you should write:</p><div><pre class="programlisting">@autoreleasepool {
    // Taking advantage of a local autorelease pool.
}</pre></div><p class="calibre8">Even if you don't use ARC, you can take advantage of <code class="email">@autoreleasepool</code> blocks that are far more effective than the <code class="email">NSAutoreleasePool</code> class.</p><p class="calibre8">Opposite to <a id="id48" class="calibre1"/>an environment that uses garbage collection, in one with reference counting, every object that receives an <code class="email">autorelease</code> message is placed into an <code class="email">NSAutoreleasePool</code> object. This <code class="email">NSAutoreleasePool</code> class is like a collection of these objects and goes one by one sending a release message when it's drained. It drains the pool when you're out of scope. Then, every object retain's count is decreased by 1. By using an autorelease as an alternative to a release message, you extend the object's lifetime, this time maybe even longer if the object is later retained or at least until the <code class="email">NSAutoreleasePool</code> class is drained. If you put an object into the same pool more than once, for each time, it will receive a <code class="email">release</code> message.</p><p class="calibre8">While into an environment with reference counting, Cocoa presumes there will always be an autorelease pool available; otherwise, objects that have received an <code class="email">autorelease</code> message won't get released. This practice will leak memory and generate proper warning messages.</p><p class="calibre8">At the beginning of a cycle of the event loop, an autorelease pool is created by the Application Kit (one of the Cocoa frameworks, also known as AppKit). It provides code to create and interact with GUI, and it's drained at the end of this cycle, then every autoreleased object created when processing an event is just released. It means you don't need to create the pools yourself as the Application Kit does it for you. However, if there are many autoreleased objects created by your application, you should consider the creation of "local" autorelease pools; this is an advantage to avoid the peak memory footprint.</p><p class="calibre8">To create an <code class="email">NSAutoreleasePool</code> object, you can use the regular <code class="email">alloc</code> and <code class="email">init</code> methods and use <code class="email">drain</code> to dismiss it. A pool cannot be retained; the consequences of <code class="email">drain</code> is like a deallocation, and it's very important to do so in the same context you created it.</p><p class="calibre8">Every thread has its own stack of autorelease pools. These stacks contain <code class="email">NSAutoreleasePool</code> objects, which in turn contain autoreleased objects. Every new autoreleased object is placed on the top of the pool and every new pool is placed on the top of the stack. A pool is removed from a stack when it's drained. Before a thread is finished, it drains every autorelease pool on its stack. Despite the fact that an autorelease pool can be manually created and objects can be manually added to it, ARC still drains the pool automatically: you're not allowed to do it yourself.</p><p class="calibre8">To ensure that you don't have to worry about ownership, this is what ARC does: easily create autorelease pools, and make them temporarily handle the holding and releasing of autoreleased objects for you.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec22" class="calibre1"/>Autorelease pool mechanism</h1></div></div></div><p class="calibre8">There will be<a id="id49" class="calibre1"/> times when you need to renounce an object's ownership and a good way to do it is by using autorelease pool blocks. Those blocks provide a mechanism where you can renounce it and avoid any chance of the object's immediate deallocation. Even if sometimes you will need to create your own blocks, or it will be in your advantage to do this way, you normally don't need to create them, but there are situations where you may need it.</p><p class="calibre8">As in the following code, an autorelease pool block is marked by the usage of <code class="email">@autoreleasepool</code>:</p><div><pre class="programlisting">@autoreleasepool {
     //-----
	 // Here you create autoreleased objects.
	 //-----
}</pre></div><p class="calibre8">Objects that were created inside the block receive a release message when the block is terminated. An object receives release messages as many times as it receives an autorelease message inside the block.</p><p class="calibre8">Autorelease pool blocks can be nested as well:</p><div><pre class="programlisting">@autoreleasepool {
    // . . .
    @autoreleasepool {
        // . . .
    }
    //. . .
}</pre></div><p class="calibre8">If an autorelease message is not sent inside the autorelease pool block, Cocoa will return error messages and your application will leak memory. You generally don't need to create your own autorelease pool blocks, but there are three situations where you will be required to:</p><div><ul class="itemizedlist"><li class="listitem">While creating a program that is not based on UI, such as a command-line one</li><li class="listitem">While creating a loop that generates a large number of temporary objects</li><li class="listitem">When a secondary thread has to be created</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec07" class="calibre1"/>Reducing peak memory footprint with autorelease pool blocks</h2></div></div></div><p class="calibre8">Memory footprint <a id="id50" class="calibre1"/>is basically the primary amount of memory used by a program in runtime. Temporary autoreleased <a id="id51" class="calibre1"/>objects are created in countless applications, and they add to the application's memory footprint until the block is ended. Allowing this accumulation until the current event loop finally ends, in some cases, may result in an exorbitant overhead and you might want to quickly get rid of those temporary objects; after all, they are highly adding to the memory footprint. In this case, the creation of your own "local" autorelease pool blocks is a solution. In the end, all objects are released, consequently deallocated, beneficially reducing the memory footprint.</p><p class="calibre8">Here, you can see how to use an autorelease pool block for a <code class="email">for</code> loop:</p><div><pre class="programlisting">NSArray *myUrls = &lt;# Sample Array of URLs #&gt;;
for (NSURL *url in myUrls) {
    @autoreleasepool {

/* Two objects are created inside this pool:
NSString "contents", NSError "error"
At the end of the pool, they are released. */

       NSError *error;
       NSString *contents = [NSString
        stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];

         /* Here you can process the NSString contents,
    thus creating and autoreleasing more objects. */
    }
}</pre></div><p class="calibre8">There is <code class="email">NSArray</code> with many files' URLs and the loop processes one file at a time. Every object created inside the block is released when it's ended.</p><p class="calibre8">Every object that was autoreleased inside the autorelease pool block is considered disposed of after the block's termination. If you want to keep a temporary object and use it after the autorelease pool block is ended, you must do two things: inside the block, send a <code class="email">retain</code> message to that object and then, only after the block, send the <code class="email">autorelease</code> message, as we can see in the following code sample:</p><div><pre class="programlisting">– (id)findTheMatchingObject:(id)myObject {
 
   id myMatch;
   while (myMatch == nil) {
  @autoreleasepool {

  /*
      This search creates a large number of temporary      
      objects
  */
           myMatch = [self expensiveSearchForObject:myObject];
 
           if (myMatch != nil) {
	/*
      Keep myMatch in order to use it even after the block is
      ended.
    */
      [myMatch retain];
      break;
            }
        }
    }
     /*
        Here - outside the block - you send it an autorelease message and return it to the method's invoker
    */
    return [myMatch autorelease];
}</pre></div><p class="calibre8">As the comments <a id="id52" class="calibre1"/>in the preceding code explain, by sending a <code class="email">retain</code> message to <code class="email">myMatch</code> inside the <a id="id53" class="calibre1"/>autorelease pool block and then, only after the block, sending it an <code class="email">autorelease</code> message increases this object's lifetime, making it available to receive messages outside and properly return it to the method's invoker.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec23" class="calibre1"/>An overview of Apple autoreleased classes</h1></div></div></div><p class="calibre8">As it was<a id="id54" class="calibre1"/> said before, the Cocoa framework provides factory methods with autorelease for many of the basic classes<a id="id55" class="calibre1"/> such as <code class="email">NSString</code>, <code class="email">NSArray</code>, <code class="email">NSDictionary</code>, <code class="email">NSColor</code>, and <code class="email">NSDate</code>. However, in the same time, there are some classes that deserve special attention.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec08" class="calibre1"/>NSRunLoop</h2></div></div></div><p class="calibre8">While using<a id="id56" class="calibre1"/> <code class="email">NSRunLoop</code>, at the beginning <a id="id57" class="calibre1"/>of every run loop, an autorelease pool will be created, and it will only be destroyed at the end of this run loop. To clarify, every temporary object created inside it will be deallocated at the end of the running iteration. It might not be beneficial if you are creating a large number of temporary objects inside the block; in this case, you should consider creating a new autorelease pool, as shown here:</p><div><img src="img/00005.jpeg" alt="NSRunLoop" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The following code demonstrates what was discussed earlier:</p><div><pre class="programlisting">id myPool = [NSAutoreleasePool new];
[myObject somethingThatCreatesManyObjects];
[myPool drain];</pre></div><p class="calibre8">Notice that<a id="id58" class="calibre1"/> in order to end the autorelease pool, instead of sending a <code class="email">release</code> message, we sent a <code class="email">drain</code> message. It was done this way because in garbage collector mode, Objective-C runtime will simply ignore <code class="email">release</code> messages, while the <code class="email">drain</code> message won't be ignored, providing a hint to the collector; however, it doesn't destroy the autorelease pool.</p><p class="calibre8">Application Kit creates<a id="id59" class="calibre1"/> an autorelease pool in the main thread at the beginning of each iteration, event, and releases it at the end of each iteration, thus exempting all autorelease objects created during the processing of the event.</p><p class="calibre8">Basically, the run loop in iOS waits for the complete execution of an event until the application does something else. These events can be touchscreen interactions, incoming calls, and so on.</p><p class="calibre8">For each iOS event handling, a new autorelease pool is created at the beginning and released (drained) when the event's processing is completed. Theoretically, it can be any number of nested autorelease pools, but remember they are created at the beginning of the event's processing.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec09" class="calibre1"/>NSException</h2></div></div></div><p class="calibre8">Exceptions <a id="id60" class="calibre1"/>may happen, and if they do occur, autorelease pools <a id="id61" class="calibre1"/>are automatically cleaned up after them. Autorelease pools prove to be a handful tool in order to write exception-safe code.</p><p class="calibre8">Even an exception object itself should be autoreleased:</p><div><pre class="programlisting">// This exception will be autoreleased
 +[NSException exceptionWithName:...]

// Or the alternative below
 +[NSException raise:...]</pre></div><p class="calibre8">Using one of the preceding patterns will properly free the memory if an exception is thrown. It will free the memory in garbage collector mode as well, even if it's not required in this GC mode:</p><div><pre class="programlisting">    id myObj = [[[SampleClass alloc] init] autorelease];
    ThisMightThrowAnException();
  
    id myObj = [[SampleClass alloc] init];
    @try {
        ThisMightThrowAnException();
    } @finally {
        [myObj release];
    }</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>ARC and autorelease</h1></div></div></div><p class="calibre8">ARC does<a id="id62" class="calibre1"/> still use autorelease as a mechanism, but besides that, its compiled code is created to interoperate with no problem with MRC compiled code, thus autorelease is present.</p><p class="calibre8">Despite the fact that ARC does a good job handling the memory management for us, there is still a situation when you need to use autorelease. Sometimes, we create a large number of temporary objects and many of them are only used once. In this case, you might want to free up the memory used by them.</p><p class="calibre8">In order to dealloc those objects into the autorelease pool instead of waiting for them to be freed naturally, check out the following code sample in a non-ARC environment:</p><div><pre class="programlisting">/*
  -------------------------------------------------------
  Non-ARC Environment with Memory Leaks
*/
@autoreleasepool 
{
  // No autorelease call here
   MyObject *obj = [[MyObject alloc] init];

   /* Since MyObject is never released its
     a leak even when the pool exits
  */
}

  /*
  -------------------------------------------------------
  Non-ARC Environment with NO Memory Leaks
*/
@autoreleasepool 
{
  // Memory is freed once the block ends
  MyObject *obj = [[[MyObject alloc] init] autorelease]; 
}</pre></div><p class="calibre8">The following sample code is for an ARC environment:</p><div><pre class="programlisting">/*
  -------------------------------------------------------
  ARC Environment
*/
@autoreleasepool 
{

    MyObject *obj = [[MyObject alloc] init]; 
  /* 
     No need to do anything once the obj variable
     is out of scope. There are no strong pointers
     so the memory will be free
  */

}

/*
  -------------------------------------------------------
  ARC Environment
*/
MyObject *obj; // Strong pointer from elsewhere in scope

@autoreleasepool 
{
    obj = [[MyObject alloc] init]; 
    // Not freed still has a strong pointer 
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>Autorelease pool blocks and threads</h1></div></div></div><p class="calibre8">You will <a id="id63" class="calibre1"/>need to create your own autorelease pool if you are making Cocoa calls outside the main thread of the Application Kit. It may happen that you create a foundation-only application for example, or separate a thread.</p><p class="calibre8">If your application generates a large number of autoreleased objects, instead of maintaining a single autorelease pool, you are highly advised to drain the autorelease pool and create a new one frequently. This behavior is used by Application Kit on the main thread. If you neglect this, your autoreleased objects don't deallocate, growing the memory footprint. On the other hand, if your thread doesn't make Cocoa calls, you can easily ignore this advice.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we reviewed autorelease pools and how to properly use them. We also highlighted the differences between <code class="email">NSAutoreleasePool</code> and the new <code class="email">@autoreleasepool</code> classes and its benefits.</p><p class="calibre8">In the next chapter, we will talk about a few concepts related to object creation and initialization, such as immutability, inheritance, and so on. We will delve into design patterns such as singletons, which are commonly used in the iOS SDK, such as the <code class="email">UIApplication</code> class that has a method called <code class="email">sharedApplication</code>. We will also look into properties as a way to define the information that a class intends to encapsulate. We will also look into custom methods and format specifiers in <a class="calibre1" title="Chapter 4. Object Creation and Storage" href="part0032_split_000.html#page">Chapter 4</a>, <em class="calibre9">Object Creation and Storage</em>. We will cover a lot of materials in the next chapter, so sit tight and hang on while we head to <a class="calibre1" title="Chapter 4. Object Creation and Storage" href="part0032_split_000.html#page">Chapter 4</a>, <em class="calibre9">Object Creation and Storage</em>!</p></div></body></html>