- en: Anko Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Anko 布局
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下菜谱：
- en: Setting up Anko library for Anko layouts in Gradle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Gradle 中为 Anko 布局设置 Anko 库
- en: Creating user-interface programmatically
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式创建用户界面
- en: Working with the old code of XML layouts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用旧版 XML 布局代码
- en: Using the provided AnkoComponent interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提供的 AnkoComponent 接口
- en: Setting theme for Android views in Anko
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Anko 中为 Android 视图设置主题
- en: Setting layout parameters for Anko views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Anko 视图设置布局参数
- en: Adding listeners to Anko views
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Anko 视图添加监听器
- en: Inserting XML layouts into DSL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 XML 布局插入到 DSL 中
- en: Converting XML files into DSL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 XML 文件转换为 DSL
- en: Showing Snackbar
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示 Snackbar
- en: Showing Toasts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示 Toast
- en: Accessing views using synthetic properties
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合成属性访问视图
- en: Accessing views of view groups using extension functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展函数访问视图组中的视图
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Anko is a Kotlin library that makes Android development a lot faster and easier.
    It also makes the code clean and concise. Most of us are used to writing XML layouts
    for UI in Android, which is redundant and neither type safe nor null safe. It
    also eats CPU time and battery to parse XML on a device. Some who programmatically
    write layouts know how large the code becomes, and it is also very difficult to
    maintain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 是一个 Kotlin 库，它使 Android 开发变得更快、更简单。它还使代码更简洁。我们大多数人习惯于为 Android 的 UI 编写
    XML 布局，这是冗余的，既不类型安全也不为空安全。它还会消耗设备上的 CPU 时间和电池来解析 XML。一些程序化编写布局的人知道代码会变得多么庞大，而且维护起来也非常困难。
- en: With Anko, we can use DSL to define layouts. The advantages of using DSL is
    that they are easy to read and write and they have no runtime overhead. If you
    are familiar with Android development and XML layouts, this chapter will help
    you quickly get started with Anko layouts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Anko，我们可以使用 DSL 来定义布局。使用 DSL 的优点是它们易于阅读和编写，并且没有运行时开销。如果您熟悉 Android 开发和 XML
    布局，本章将帮助您快速开始使用 Anko 布局。
- en: Setting up Anko library for Anko layouts in Gradle
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Gradle 中为 Anko 布局设置 Anko 库
- en: The first and foremost thing to do to start using any library is adding its
    dependencies to our project so as to be able to use its methods and functionalities
    in our project. In this recipe, we will explore how to add dependencies of Anko
    layouts to our project using gradle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用任何库，首先要做的事情是将它的依赖项添加到我们的项目中，以便能够在我们的项目中使用它的方法和功能。在本菜谱中，我们将探讨如何使用 gradle
    将 Anko 布局的依赖项添加到我们的项目中。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write the code, as it is the latest right
    now. You can get started by creating a new project in Kotlin with a blank activity
    in Android Studio 3+ as we won't be using any code from other recipes. You also
    need an intermediate understanding of Android development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码，因为它是目前最新的。您可以通过在 Android Studio 3+ 中创建一个新的 Kotlin
    项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对 Android 开发有一个中级理解。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we will add Anko to our project:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将向我们的项目中添加 Anko：
- en: 'We can add all Anko features and components in one go by adding the following
    line to our `build.gradle` dependencies:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在 `build.gradle` 依赖项中添加以下行一次添加所有 Anko 功能和组件：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `$anko_version` is the latest version of Anko. You can replace it with
    the latest version of Anko at this time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$anko_version` 是 Anko 的最新版本。您可以用 Anko 当前最新版本替换它。
- en: 'After that, sync your `build.gradle` file. Now, Anko dependencies have been
    added to your project. Let''s check this by simply using Anko commons to create
    and show an alert dialog. Create a button in your activity by defining it in your
    XML layout and adding `onClickListener` on it, clicking on which should run the following
    code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，同步您的 `build.gradle` 文件。现在，Anko 依赖项已经添加到您的项目中。让我们通过简单地使用 Anko 公共库来创建并显示一个警报对话框来检查这一点。通过在您的
    XML 布局中定义它并在上面添加 `onClickListener` 来在您的活动中创建一个按钮，点击它应该运行以下代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If on clicking the button, an alert shows up that we successfully added Anko
    library in our project, this is how the alert dialog looks:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果点击按钮后出现一个警报，显示我们已经成功将 Anko 库添加到我们的项目中，这就是警报对话框的样式：
- en: '![](img/95d25970-98af-4373-b94c-5d9008010679.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95d25970-98af-4373-b94c-5d9008010679.jpeg)'
- en: However, most of the time we just need to add a single feature of Anko to our
    project. For example, Anko layouts in this case. So let's try to add just Anko
    layouts library to our project. Remove the previous code from `build.gradle` and
    your `Activity` and let's start over.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，大多数时候我们只需要在我们的项目中添加 Anko 的单个功能。例如，本例中的 Anko 布局。所以让我们尝试只添加 Anko 布局库到我们的项目中。从
    `build.gradle` 和您的 `Activity` 中移除之前的代码，然后重新开始。
- en: 'Now add the following lines to your project''s app-level `build.gradle` dependencies:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下行添加到您的项目 app 级 `build.gradle` 依赖项中：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sync your `build.gradle` and if there are no errors, you can now use Anko layouts
    in your project. At this point, we should also add dependencies of Anko coroutines,
    as we will obviously need listeners on our layouts. You can add those dependencies
    by adding the following lines to your `build.gradle` file:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步您的 `build.gradle` 文件，如果没有错误，您现在可以在项目中使用 Anko 布局。在此阶段，我们还应该添加 Anko 协程的依赖项，因为我们显然需要在布局上添加监听器。您可以通过将以下行添加到您的
    `build.gradle` 文件中来添加这些依赖项：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Done! Now, let''s check whether everything is working perfectly. To do that,
    let''s add a basic DSL layout to our main activity. Check out the following code
    of the `onCreate()` method of our target activity:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成！现在，让我们检查一切是否运行得完美。为此，让我们向我们的主活动添加一个基本的 DSL 布局。查看以下目标活动 `onCreate()` 方法的代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now run the app on your phone; if the layout works correctly, that is, you
    have a button on your screen with text HELLO WORLD BUTTON!, then we have successfully
    added Anko layouts dependencies to our project. This is how our layout looks:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在您的手机上运行应用程序；如果布局工作正确，即屏幕上有一个带有文本 HELLO WORLD BUTTON! 的按钮，那么我们已经成功地将 Anko
    布局依赖项添加到我们的项目中。这就是我们的布局看起来像这样：
- en: '![](img/400a93a9-857e-493e-a527-b1b50375d247.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/400a93a9-857e-493e-a527-b1b50375d247.jpeg)'
- en: 'Also, on clicking on the button, we get a toast like this:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当点击按钮时，我们会得到如下 toast 信息：
- en: '![](img/40644d34-7e53-4a7f-a3f9-74106ff1d2ec.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40644d34-7e53-4a7f-a3f9-74106ff1d2ec.jpeg)'
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By adding project dependencies in our `build.gradle` file, the amazing gradle
    takes care of what libraries and dependencies are needed by our project. The dependencies
    are located by gradle on our machine or in a remote repository, and any transitive
    dependencies are automatically included. Gradle makes adding project dependencies
    extremely easy and  quick, and we can invest most of our time in creating our
    amazing software, rather than maintaining and resolving dependencies that becomes
    extremely difficult in large projects with lots of dependencies.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的 `build.gradle` 文件中添加项目依赖项，惊人的 Gradle 会负责处理我们的项目所需的库和依赖项。Gradle 会在我们机器上或远程仓库中定位依赖项，并且任何传递依赖项都会自动包含。Gradle
    使得添加项目依赖项变得极其简单和快速，我们可以将大部分时间投入到创建我们惊人的软件中，而不是维护和解决在大型项目中变得极其困难的依赖项。
- en: There's more…
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you do not use Gradle and do not want to use it in your project, you can
    directly add Anko's library JAR from the **jcenter repository** ([https://jcenter.bintray.com/org/jetbrains/anko/](https://jcenter.bintray.com/org/jetbrains/anko/))
    as library dependencies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用 Gradle 并且不想在项目中使用它，您可以直接从 **jcenter 仓库**（[https://jcenter.bintray.com/org/jetbrains/anko/](https://jcenter.bintray.com/org/jetbrains/anko/)）添加
    Anko 库 JAR 作为库依赖项。
- en: Creating user-interface programmatically
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式创建用户界面
- en: Writing UI in XML is not type safe or null safe, and it also eats CPU and battery.
    Writing UI programmatically (especially in Java) becomes bulky and unmanageable
    for large and complex UIs. That is when Anko layouts come to the rescue. We can
    easily create layouts in DSL using Anko layouts, and it also has no runtime overhead.
    In this recipe, we will see how to create layouts using DSL.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XML 编写 UI 既不安全也不安全，它还会消耗 CPU 和电池。以编程方式编写 UI（尤其是在 Java 中）对于大型和复杂的 UI 来说变得庞大且难以管理。这就是
    Anko 布局出现的时候。我们可以使用 Anko 布局轻松地使用 DSL 创建布局，并且它也没有运行时开销。在本菜谱中，我们将了解如何使用 DSL 创建布局。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*, in this
    chapter).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。您可以通过在 Android Studio 3+ 中创建一个新的 Kotlin 项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对
    Android 开发有一个中级理解。请确保您已经将 Anko 布局依赖项添加到您的项目中（在本章中遵循菜谱 *在 gradle 中设置 Anko 库用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start with a simple example where we use Anko to create a layout for
    our target activity (the activity in which you want to create a layout):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 Anko 为我们的目标活动（您想要创建布局的活动）创建布局的简单示例开始：
- en: 'Here''s the code for the `onCreate()` method that you need to put in your target
    activity:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是您需要在目标活动中放置的 `onCreate()` 方法的代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Basically, in the preceding code, we want to create a basic "contact us" form.
    For this, we have created a vertical linear layout with a 20 dip padding and,
    inside the vertical linear layout, we have added two edit texts for name and message,
    respectively. On clicking on the button, we take the data and show the user a
    confirmation that the message has been recorded through toast. This is how part
    of the screen looks:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们想要创建一个基本的“联系我们”表单。为此，我们创建了一个带有20 dip填充的垂直线性布局，并在垂直线性布局内部添加了两个用于姓名和消息的编辑文本。点击按钮时，我们获取数据并通过toast向用户显示消息已记录的确认。这是屏幕部分的外观：
- en: '![](img/13c8cc9e-f05b-4991-a1e6-2863d647df53.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13c8cc9e-f05b-4991-a1e6-2863d647df53.jpeg)'
- en: Anko layouts DSL is a great way to build UI in fewer lines of code. It is simple
    to read and write, and it's clean and concise. It has no runtime overhead as there
    is in XML layouts. Anko layouts support XML too, and you can use custom components
    and also use coroutines for listeners. You can also get a preview of the DSL layout
    in Android Studio when using `AnkoComponent` interface, which we will learn later
    in this chapter.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Anko布局DSL是一种在更少的代码行中构建UI的绝佳方式。它易于阅读和编写，且简洁。它没有XML布局中存在的运行时开销。Anko布局也支持XML，您可以使用自定义组件，也可以为监听器使用协程。您还可以在Android
    Studio中使用`AnkoComponent`接口预览DSL布局，我们将在本章后面学习。
- en: 'Let''s try another example where we fit the preceding layout in a coordinator
    layout with a toolbar. To be able to use a coordinator layout, we need to add
    dependencies for Anko design support library. Add the following lines to your
    `build.gradle` and sync your project:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试另一个例子，在这个例子中，我们将前面的布局放入一个带有工具栏的协调器布局中。为了能够使用协调器布局，我们需要添加Anko设计支持库的依赖项。将以下行添加到您的`build.gradle`文件中，并同步您的项目：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are a lot of artifacts by Anko for various Android support libraries
    out there. The following is the list:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前市面上有很多Anko为各种Android支持库提供的工具。以下是一个列表：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now what we need is a coordinator layout that fits the whole width and height
    of the parent and, inside it, we need an app bar with a toolbar and below the
    app bar we need our vertical layout from earlier. I suggest that you try to code
    this one on your own before checking out my method, which is as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要的是一个能够适应父元素整个宽度和高度的`coordinator layout`，在其内部，我们需要一个带有工具栏的应用栏，在应用栏下方我们需要之前提到的垂直布局。我建议你在查看我的方法之前先自己尝试编写这段代码，方法如下：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`lparams` used in the preceding function is the extension function used to
    add layout parameter to a view. This is how the layout looks in our app:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的函数中使用的`lparams`是用于向视图添加布局参数的扩展函数。这就是在我们的应用中布局的外观：
- en: '![](img/bcc64095-494e-47c4-8b98-60eabc6a28ae.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcc64095-494e-47c4-8b98-60eabc6a28ae.jpeg)'
- en: Creating layouts using DSL is a bit similar to XML itself, which is intentional,
    given the previous experience of developers with XML, and it also gives us the
    power to calculate things on the fly, while dynamically adding views.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DSL创建布局与XML本身有些相似，这是故意的，因为开发者之前有XML的经验，这也让我们能够在动态添加视图的同时即时计算事物。
- en: How it works…
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: XML Parsing is done at compile time (except for a few things). It introduces
    CPU and battery overheads. For very complex layouts, it also introduces latency
    in the app and at times, severely affects user experience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: XML解析是在编译时完成的（除了少数几件事情）。它引入了CPU和电池开销。对于非常复杂的布局，它还引入了应用中的延迟，有时甚至严重影响了用户体验。
- en: In Anko layouts, the DSL builds the layout at runtime and hence we can include
    anything. It also avoids runtime overhead, and we can avoid null pointer exception.
    Also, we do not need casting and can dodge the `findViewById` calls as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Anko布局中，DSL在运行时构建布局，因此我们可以包含任何内容。它还避免了运行时开销，我们可以避免空指针异常。此外，我们不需要进行类型转换，也可以避免`findViewById`调用。
- en: Working with the old code of XML layouts
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XML布局的旧代码
- en: The best thing about Anko layouts is the flexibility to be able to work with
    our XML layouts as well. Also, Anko makes things easier by providing us view properties.
    In this recipe, we will see how to use XML layouts and still be able to improve
    things using Anko Layouts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Anko布局的最好之处在于其灵活性，能够与我们的XML布局一起工作。Anko还通过提供视图属性使事情变得简单。在本食谱中，我们将看到如何使用XML布局，同时仍然能够使用Anko布局来改进事物。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+ as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*, in this
    chapter).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。您可以通过在Android Studio 3+中创建一个新的Kotlin项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对Android开发有中级理解。请确保您已经将Anko布局依赖项添加到项目中（遵循本章中的菜谱*在gradle中设置Anko库以用于Anko布局*）。
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we will learn how to work with XML layouts, along with
    Anko layouts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何使用XML布局和Anko布局一起工作：
- en: 'Let''s start by first having an old XML file to work on. Add the following
    code to an XML layout that you will add as the content view of your target activity:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从先有一个旧的XML文件开始工作。将以下代码添加到您将要添加为目标活动内容视图的XML布局中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Traditionally, we used `findViewById()` and `onClickListener()` in our activity
    to manipulate properties of the elements of layout and handle events. However,
    with Anko layouts, this becomes as easy as the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统上，我们在活动中使用`findViewById()`和`onClickListener()`来操作布局元素的属性并处理事件。然而，使用Anko布局，这变得和以下一样简单：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding is the `onCreate()` method of the target activity. Note that the
    `find()` method is a lot simpler than `findViewById()`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上文是目标活动的`onCreate()`方法。请注意，`find()`方法比`findViewById()`简单得多。
- en: 'We can get and set view properties and also attach listeners to view events.
    Another thing is that the Kotlin''s Android extension functions also let us deal
    with views without using the `find` method. Check out the following code, whereby
    it becomes super easy to get and set view properties using synthetic extension
    properties:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以获取和设置视图属性，还可以将监听器附加到视图事件。另一件事是，Kotlin的Android扩展函数还允许我们处理视图而不使用`find`方法。查看以下代码，它使使用合成扩展属性获取和设置视图属性变得超级简单：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `name`, `message`, and `btn_send` are the IDs of the views in XML layout,
    respectively.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，`name`、`message`和`btn_send`分别是XML布局中视图的ID。
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Anko provides us with these extension functions and properties that make it
    easier to access the views. Some of these functions and properties are prearranged
    into type-safe builders that are generated using Android JAR files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Anko为我们提供了这些扩展函数和属性，使得访问视图变得更加容易。其中一些函数和属性被预先安排成类型安全的构建器，这些构建器是通过Android JAR文件生成的。
- en: There's more…
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is worth understanding how Kotlin's synthetic properties work. Kotlin generates
    some extra code that helps us use our views like properties, naming the variables
    similar to that  of the ID of the view. Basically, it is running `findViewById()`
    the first time we try to access a view as property and storing it in cache so
    that all the consecutive calls to the same view invoke `findCachedViewById()`,
    thus making the access a lot faster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 值得理解Kotlin的合成属性是如何工作的。Kotlin生成一些额外的代码，帮助我们像使用属性一样使用视图，变量命名类似于视图的ID。基本上，它是在我们第一次尝试将视图作为属性访问时运行`findViewById()`，并将其存储在缓存中，以便所有对同一视图的连续调用都调用`findCachedViewById()`，从而使访问变得更快。
- en: Using the provided AnkoComponent interface
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用提供的AnkoComponent接口
- en: We can define an activity's layout DSL directly in the `onCreate()` method,
    but it is sometimes convenient to separate UI into another class. In this recipe,
    we will see how to use the `AnkoComponent` interface to do that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在`onCreate()`方法中定义活动布局DSL，但有时将UI分离到另一个类会更方便。在这个菜谱中，我们将看到如何使用`AnkoComponent`接口来实现这一点。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+ as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。您可以通过在Android Studio 3+中创建一个新的Kotlin项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对Android开发有中级理解。请确保您已经将Anko布局依赖项添加到项目中（遵循本章中的菜谱*在gradle中设置Anko库以用于Anko布局*）。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the given steps, we will learn how to work with the AnkoComponent interface:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的步骤中，我们将学习如何使用AnkoComponent接口进行工作：
- en: 'Let''s start by adding our UI in a different class that implements the `AnkoComponent`
    interface like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在实现`AnkoComponent`接口的不同类中添加我们的UI。如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the preceding class implements the `AnkoComponent` interface. We
    need to override the `createView()` method and return DSL layout from it. Now,
    let''s see how to get this layout and set it to our activity. Check out the modified
    `onCreate()` method in our activity:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，前面的类实现了`AnkoComponent`接口。我们需要重写`createView()`方法并从中返回DSL布局。现在，让我们看看如何获取这个布局并将其设置到我们的活动中。检查我们活动中的修改后的`onCreate()`方法：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s try to access these views inside our activity, which we should
    be able to do if the layout has been properly set to our activity. We will access
    them just as we would have accessed a view from XML layout:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在我们的活动中访问这些视图，如果我们已经正确设置了布局，我们应该能够做到这一点。我们将像访问XML布局中的视图一样访问它们：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next image is how the screen will look:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一张图片将展示屏幕的显示效果：
- en: '![](img/9ac986b5-5853-4125-9aeb-a664d30efc4b.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ac986b5-5853-4125-9aeb-a664d30efc4b.jpeg)'
- en: 'Also, on entering the details and clicking on the button, we see the toast,
    as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在输入详细信息并点击按钮后，我们会看到如下所示的toast：
- en: '![](img/1c4f479b-13d1-44a8-b29f-18d4d93ff86a.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c4f479b-13d1-44a8-b29f-18d4d93ff86a.jpeg)'
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `verticalLayout` (which is a vertical linear layout) block is an extension
    function provided by Anko, which creates a new view instance and adds it to the
    parent. There are such extension functions for every view in the Android framework.
    For example, we used button and edit text as well in the preceding example. We
    can also use it as `button()`, which accepts a string parameter for text on the
    button or `button{}` if we want to set any properties on that view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`verticalLayout`（这是一个垂直线性布局）块是Anko提供的扩展函数，它创建一个新的视图实例并将其添加到父级。对于Android框架中的每个视图都有这样的扩展函数。例如，我们在前面的例子中也使用了按钮和编辑文本。我们也可以将其用作`button()`，它接受一个字符串参数作为按钮上的文本，或者`button{}`如果我们想设置该视图的任何属性。'
- en: There's more…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If we use the `AnkoComponent` interface for creating our DSL in another class,
    we can also preview our layout DSL using the Anko support plugin.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在另一个类中使用`AnkoComponent`接口来创建我们的DSL，我们也可以使用Anko支持插件预览我们的布局DSL。
- en: For doing so, first add Anko support plugin from plugins in Android Studio settings.
    After that, put the cursor somewhere inside the `MainActivityUI` declaration,
    open the Anko Layout Preview tool window by clicking on View|Tool Windows|Anko
    Layout Preview, and press Refresh.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这样做，首先从Android Studio设置中的插件中添加Anko支持插件。之后，将光标放在`MainActivityUI`声明内部，通过点击视图|工具窗口|Anko布局预览打开Anko布局预览工具窗口，然后按刷新。
- en: 'If the layout preview is not being rendered properly, rebuild the project.
    This is how the window looks:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布局预览没有正确渲染，请重新构建项目。这是窗口的显示方式：
- en: '![](img/89494c5e-aa01-46f5-a39d-f5675d954d92.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89494c5e-aa01-46f5-a39d-f5675d954d92.png)'
- en: Setting theme for Android views in Anko
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Anko中为Android视图设置主题
- en: Our Android apps won't be so beautiful if we won't be able to style our views.
    Anko layouts give us the power to apply custom themes to our views. In this recipe,
    we will learn how to create themed views in Anko.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法为视图设置样式，我们的Android应用将不会那么美观。Anko布局让我们能够将自定义主题应用到我们的视图上。在本菜谱中，我们将学习如何在Anko中创建主题视图。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。您可以通过在Android Studio 3+中创建一个新的Kotlin项目并包含一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对Android开发有一个中级理解。请确保您已经将Anko布局依赖项添加到项目中（遵循本章中的菜谱*在gradle中设置Anko库的Anko布局*）。
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the given steps, we will learn how to set the theme for Android views using
    Anko:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的步骤中，我们将学习如何使用Anko为Android视图设置主题：
- en: 'Let''s start by first creating a style for a button. Custom styles are created
    in `styles.xml` inside the `res/values/` directory. Let''s create a button style
    and name it `newButton`. Add the following code in `styles.xml`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为按钮创建一个样式。自定义样式是在`res/values/`目录中的`styles.xml`文件内创建的。让我们创建一个按钮样式，命名为`newButton`。在`styles.xml`中添加以下代码：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s use this style to create a themed button in our target activity.
    Let''s keep our UI in another class using the `AnkoComponent` interface. The following
    is how we create a button with a custom theme in a DSL layout (focus on the bold
    parts of the code):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个样式在我们的目标活动中创建一个主题按钮。让我们使用`AnkoComponent`接口将我们的UI保持在另一个类中。以下是如何在DSL布局中创建一个具有自定义主题的按钮的示例（注意代码中的粗体部分）：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, to set this layout of our activity, we add the `LayoutActivity().setContentView(this)`
    line in the `onCreate()` method, as follows (focus on the bold parts of the code):'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了设置我们活动的布局，我们在`onCreate()`方法中添加了`LayoutActivity().setContentView(this)`这一行，如下所示（注意代码中的粗体部分）：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is how the top part of our app screen looks, with themed button
    taking background color as the accent color as defined in our `colors.xml` file
    in the `res/values/` directory. The text color is white, just as we set in our
    custom style:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们应用屏幕顶部的样子，主题按钮的背景颜色与我们在`res/values/`目录下的`colors.xml`文件中定义的强调颜色一致。文字颜色为白色，正如我们在自定义样式中设置的那样：
- en: '![](img/fa224439-0019-41fd-a6ab-4bec9c3ba685.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa224439-0019-41fd-a6ab-4bec9c3ba685.jpeg)'
- en: This is how we set themes on views, by appending themed keywords before the
    view name and making it camel case. We pass the theme as a parameter to the function.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们设置视图主题的方式，通过在视图名称之前附加主题关键字并将其转换为驼峰式来设置。我们将主题作为参数传递给函数。
- en: Themed views are also Kotlin extension functions provided by Anko layouts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 主题视图也是Anko布局提供的Kotlin扩展函数。
- en: Setting layout parameters for Anko views
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Anko视图设置布局参数
- en: Without layout parameters, there is not much we can do with our layouts. In
    this recipe, we will see how to use layout parameters with views in our layout
    DSL.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 没有布局参数，我们几乎无法对布局做任何事情。在这个菜谱中，我们将看到如何在我们布局DSL中的视图中使用布局参数。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。您可以通过在Android Studio 3+中创建一个新的Kotlin项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对Android开发有中级理解。请确保您已经将Anko布局依赖项添加到项目中（遵循本章中的菜谱*在gradle中设置Anko库以用于Anko布局*）。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we will learn how to set the layout parameters for
    Anko views:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何为Anko视图设置布局参数：
- en: 'Let''s start with creating our view in an external class that inherits from
    the `AnkoComponent` interface. To add layout parameters to a view (which we add
    using the extension functions provided by Anko), we use the `lparams()` extension
    function, which we add at the end of our view block in DSL, and is something like
    this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个继承自`AnkoComponent`接口的外部类中的视图开始。为了向视图添加布局参数（我们使用Anko提供的扩展函数添加），我们使用`lparams()`扩展函数，它在DSL视图块的末尾添加，类似于这样：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s try a simple example with vertical layouts; check out the following
    code block (focus on the bold parts of the code):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个简单的垂直布局示例；查看以下代码块（注意代码中的粗体部分）：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `themedEditText` and `themedButton` extension functions are provided by
    Anko to create an edit text and button with theme. If you do not wish to use themed
    views, simply call `editText()` and `button()` without passing the theme as a
    parameter.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`themedEditText`和`themedButton`扩展函数是由Anko提供的，用于创建具有主题的编辑文本和按钮。如果您不想使用主题视图，只需调用`editText()`和`button()`而不传递主题参数即可。'
- en: '![](img/c8f5c45a-b5bd-4c55-98dc-066fe7b0e503.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8f5c45a-b5bd-4c55-98dc-066fe7b0e503.jpeg)'
- en: 'Let''s go through another example where we have a toolbar with the title of
    the page in it. Check out the next example that uses coordinator layout, app bar
    layout, and toolbar. The given code generates the layout as shown in the screenshot
    following the code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过另一个示例来了解，在这个示例中我们有一个包含页面标题的工具栏。查看下一个示例，它使用协调布局、应用栏布局和工具栏。给定的代码生成与代码后面的截图一致的布局：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is how the layout looks in our app:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用中的布局外观：
- en: '![](img/a9d7e371-cd4e-4066-9c30-8c3567c14e18.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9d7e371-cd4e-4066-9c30-8c3567c14e18.jpeg)'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`lparams` is also an Anko extension function that is added to views, and we
    can define layout parameters as properties. If you omit width and/or height while
    using `lparams()`, their values automatically default to `wrapContent`, just like
    in XML. The parameters passed are named arguments. Some of the properties are `horizontalMargin`,
    `verticalMargin`, and `margin`. For different layouts, we have different layout
    parameters, just as in XML. For example, for relative layout, we have `alignParentBottom()`, `alignParentTop()`, `alignParentStart()`,`leftOf(viewIdOfReferenceView)`,`topOf(viewIdOfReferenceView)` and
    so on.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`lparams` 也是一个添加到视图的 Anko 扩展函数，我们可以将布局参数定义为属性。如果您在使用 `lparams()` 时省略宽度或高度，它们的值将自动默认为
    `wrapContent`，就像在 XML 中一样。传递的参数是命名参数。一些属性包括 `horizontalMargin`、`verticalMargin`
    和 `margin`。对于不同的布局，我们有不同的布局参数，就像在 XML 中一样。例如，对于相对布局，我们有 `alignParentBottom()`、`alignParentTop()`、`alignParentStart()`、`leftOf(viewIdOfReferenceView)`、`topOf(viewIdOfReferenceView)`
    等等。'
- en: 'Check out the following example, which has the relative layout as root layout:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例，它具有作为根布局的相对布局：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how the preceding layout looks:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面布局的外观：
- en: '![](img/e3d9375a-f000-462e-8451-c24a3885ed22.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3d9375a-f000-462e-8451-c24a3885ed22.jpeg)'
- en: Adding listeners to Anko views
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Anko 视图添加监听器
- en: We have event listeners on views in Android. Let's understand how Anko makes
    this easier by providing us with listener helpers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Android 中的视图中具有事件监听器。让我们了解 Anko 如何通过为我们提供监听器辅助工具来简化这一过程。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。您可以通过在 Android Studio 3+ 中创建一个新的 Kotlin 项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。您还需要对
    Android 开发有一个中级理解。请确保您已将 Anko 布局依赖项添加到项目中（遵循本章中的菜谱 *在 gradle 中设置 Anko 库以用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps, we will learn how to add an event listener to Anko
    views:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何向 Anko 视图添加事件监听器：
- en: 'Let''s start with a simple example where we listen for click events on a button.
    Here''s the code for attaching an `onClick` listener on a button with the `btn_send` ID:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从监听按钮上的点击事件的一个简单示例开始。以下是给具有 `btn_send` ID 的按钮附加 `onClick` 监听器的代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code is the same as this:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码与以下代码相同：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s create a layout having a button and a rating bar. We will attach
    an `onLongPress` listener on the button and an `onRatingBarChange` listener on
    the rating bar. Check out this code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含按钮和评分栏的布局。我们将在按钮上附加一个 `onLongPress` 监听器，并在评分栏上附加一个 `onRatingBarChange`
    监听器。查看以下代码：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Focus on the bold text in the preceding code. We can attach listeners by directly
    putting them inside the defined views. This is how our layout looks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重点关注前面代码中的粗体文本。我们可以通过直接将它们放在定义的视图内部来附加监听器。这就是我们的布局外观：
- en: '![](img/f3ae98ad-9b75-44c7-9632-e1a10e0a98f7.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3ae98ad-9b75-44c7-9632-e1a10e0a98f7.jpeg)'
- en: 'On long-pressing the button in the preceding screen with text SEND, we see
    a toast just as expected. Check out the following screen:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面屏幕上长按具有文本“发送”的按钮时，我们会看到预期的 toast。查看以下屏幕：
- en: '![](img/a2c65883-314f-4693-82fe-682536df04a2.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2c65883-314f-4693-82fe-682536df04a2.jpeg)'
- en: Similarly, if we choose a rating from the rating bar, we get a toast for the
    rating that we chose.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，如果我们从评分栏中选择一个评分，我们会得到一个显示我们选择的评分的 toast。
- en: '![](img/e419135c-3718-4975-a0c0-eed669200a16.jpeg)  ![](img/8fd219c1-7963-4e9d-9f93-a04814ce2d6e.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e419135c-3718-4975-a0c0-eed669200a16.jpeg)  ![](img/8fd219c1-7963-4e9d-9f93-a04814ce2d6e.jpeg)'
- en: 'We can also keep the listeners separate from the layout, as in the following
    code. However, we do need the ID of the view we are setting the listener on for
    this to work:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以将监听器与布局分开，如下面的代码所示。但是，我们需要设置监听器的视图的 ID 才能使此操作生效：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Anko provides event listeners as extension functions to help ease the process
    of adding event listeners. We can also pass coroutines to these listener helpers
    and partially define listeners that have a lot of methods, that is, we can define
    each listener method separately and then they are merged by Anko if they are on
    the same view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 提供事件监听器作为扩展函数，以帮助简化添加事件监听器的过程。我们还可以将这些监听器辅助工具传递给协程，并部分定义具有许多方法的监听器，即我们可以分别定义每个监听器方法，然后
    Anko 如果它们在同一个视图中，则将它们合并。
- en: There's more…
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Coroutines are used for writing asynchronous non-blocking code. You can also
    say that coroutines are threads managed by the user.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 协程用于编写异步非阻塞代码。你也可以说协程是由用户管理的线程。
- en: Inserting XML layouts into DSL
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 XML 布局插入到 DSL 中
- en: Sometimes a situation may arise where we might need to include an XML layout
    inside a DSL layout. Anko provides a solution for this. In this recipe, we will
    understand how to include XML layouts into DSL.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能会出现这样的情况，我们可能需要在 DSL 布局中包含一个 XML 布局。Anko 提供了一个解决方案。在这个菜谱中，我们将了解如何将 XML 布局包含到
    DSL 中。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+ as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以在 Android Studio 3+ 中创建一个新的 Kotlin 项目，并包含一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对
    Android 开发有一个中级理解。确保你已经将 Anko 布局依赖项添加到你的项目中（遵循本章中的菜谱 *在 gradle 中设置 Anko 库以用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we will learn how to insert an XML layout into a DSL
    layout:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何将 XML 布局插入到 DSL 布局中：
- en: 'To include an XML layout in a DSL, we use the `include()` method. We can add
    view properties to the view created using the `include()` method by simply adding
    `{}` and defining our view properties inside it. We can also add layout parameters
    to the view, just as we do it in DSL views. Check out the syntax given here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 DSL 中包含 XML 布局，我们使用 `include()` 方法。我们可以通过简单地添加 `{}` 并在其中定义我们的视图属性来向使用 `include()`
    方法创建的视图添加视图属性。我们也可以向视图添加布局参数，就像我们在 DSL 视图中做的那样。查看以下语法：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s create a layout in XML, which we will then include in our DSL layout.
    Let''s create a button in a linear layout and save it in a file called `test.xml`.
    Check out the following code for the layout that we will save in `text.xml`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 XML 中创建一个布局，然后将其包含在我们的 DSL 布局中。让我们在线性布局中创建一个按钮，并将其保存到名为 `test.xml` 的文件中。查看以下我们将保存到
    `text.xml` 中的布局代码：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is how our `test.xml` XML layout looks, a button with `10dp`
    space around it:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们 `test.xml` XML 布局的示例，它周围有 `10dp` 的空间：
- en: '![](img/4db591eb-9f93-410c-b939-9587190c813f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4db591eb-9f93-410c-b939-9587190c813f.png)'
- en: 'Now you need to try to include the layout you just created in a DSL layout
    on your own. You can add the DSL layout to the activity''s `onCreate()` method
    or in an external class that implements the `AnkoComponent` interface. Check out
    the following code for DSL layout (focus on the bold text in the given code):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要尝试将你刚刚创建的布局包含在你的 DSL 布局中。你可以在活动的 `onCreate()` 方法中或在一个实现 `AnkoComponent`
    接口的外部类中添加 DSL 布局。查看以下 DSL 布局的代码（注意给定代码中的粗体文本）：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how our layout looks after we include `test.xml` in our DSL:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将 `test.xml` 包含到我们的 DSL 中后的布局外观：
- en: '![](img/9a9882dd-1c6a-450e-a8c7-94ed845f05bd.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a9882dd-1c6a-450e-a8c7-94ed845f05bd.jpeg)'
- en: 'We can attach listeners and get/set properties of included views by accessing
    them using Kotlin''s synthetic properties, using Anko''s `find()` method, or using
    the `findViewById()`. Each of the preceding methods needs the view to have an
    ID. Check out the following code for attaching an on-click listener on the button
    in `test.xml` that has a `btn_test` ID:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Kotlin 的合成属性、Anko 的 `find()` 方法或 `findViewById()` 来附加监听器并获取/设置包含视图的属性。上述每种方法都需要视图有一个
    ID。查看以下代码，为具有 `btn_test` ID 的 `test.xml` 中的按钮附加点击监听器：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I have imported all views from `test.xml` by importing the synthetic properties
    of `test.xml`, as shown:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经通过导入 `test.xml` 的合成属性导入了所有视图，如下所示：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Converting XML files into DSL
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 XML 文件转换为 DSL
- en: If you are already an Anko fan and would love to port your old projects' XML
    to DSL without doing it manually, then this recipe will help you learn how to
    go about doing that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是 Anko 的粉丝，并且想要将旧项目中的 XML 转换为 DSL 而不手动操作，那么这个菜谱将帮助你学习如何进行这项操作。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以通过在 Android Studio 3+ 中创建一个新的 Kotlin 项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对
    Android 开发有一个中级理解。确保你已经将 Anko 布局依赖项添加到你的项目中（遵循本章中的菜谱 *在 gradle 中设置 Anko 库以用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by creating a blank activity and working on the XML layout to
    have something to convert to DSL. I have the following XML layout that I will
    convert to DSL next:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个空白活动并开始工作于 XML 布局开始，以便有一个可以转换为 DSL 的东西。我将以下 XML 布局转换为 DSL：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Showing Snackbar
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示 Snackbar
- en: Snackbars are a great way to show feedback and messages to the users. Snackbars
    show a message at the bottom of a mobile or lower-left on larger devices. They
    can also have an action button. They automatically disappear after the timeout
    or after user interaction or if the user swipes on the snackbar.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Snackbars 是向用户显示反馈和消息的绝佳方式。Snackbars 在移动设备的底部或在大设备上的左下角显示消息。它们还可以有一个操作按钮。它们在超时后、用户交互后或用户在
    snackbar 上滑动后自动消失。
- en: '![](img/8a787462-2070-41ea-b6be-b5dad2112ea5.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a787462-2070-41ea-b6be-b5dad2112ea5.jpeg)'
- en: In this recipe, we will learn how to easily show a Snackbar using Anko layouts.
    Showing Snackbars in the traditional way is a bit long; Anko makes it simpler
    to quickly show snackbars. Let's see how.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Anko 布局轻松地显示 Snackbar。使用传统方式显示 Snackbar 有点长；Anko 使其变得简单，可以快速显示
    snackbars。让我们看看如何操作。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以通过在 Android Studio 3+ 中创建一个新的 Kotlin 项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对
    Android 开发有一个中级理解。确保你已经将 Anko 布局依赖项添加到你的项目中（遵循本章中的菜谱 *在 gradle 中设置 Anko 库以用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the below steps, we will learn how to show a snackbar using Anko library:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何使用 Anko 库显示 snackbar：
- en: 'Let''s create a few buttons, each for different snackbars. We will create a
    snackbar inside the `onClick` listener of each button. Here are the syntaxes of
    some snackbars. I suggest you try to code this on your own before moving to the
    solution:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建几个按钮，每个按钮对应不同的 snackbars。我们将在每个按钮的 `onClick` 监听器内部创建一个 snackbar。以下是某些 snackbars
    的语法。我建议你在查看解决方案之前先自己尝试编写代码：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Check out one possible solution:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看一个可能的解决方案：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is how the layout looks:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是布局的外观：
- en: '![](img/7568c19d-9994-4e89-a016-ddd5b36d760a.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7568c19d-9994-4e89-a016-ddd5b36d760a.jpeg)'
- en: 'The following screenshot is how a snackbar without an action button looks:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了没有操作按钮的 snackbar：
- en: '![](img/d50ce622-f5b4-4088-a528-5a692466ad5f.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d50ce622-f5b4-4088-a528-5a692466ad5f.jpeg)'
- en: 'This is the one with an action button:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有操作按钮的一个：
- en: '![](img/076740a7-48f0-45e9-bab6-3bf02031e1d2.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/076740a7-48f0-45e9-bab6-3bf02031e1d2.jpeg)'
- en: Showing Toasts
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示 Toasts
- en: Toasts are used to show feedback or message as a popup in android. Toasts automatically
    disappear after their timeout. Showing toasts in Anko is extremely easy. Let's
    see how.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Toasts 用于在 Android 中以弹出窗口的形式显示反馈或消息。Toast 在超时后自动消失。在 Anko 中显示 Toasts 非常简单。让我们看看如何操作。
- en: Getting started
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以通过在 Android Studio 3+ 中创建一个新的 Kotlin 项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对
    Android 开发有一个中级理解。确保你已经将 Anko 布局依赖项添加到你的项目中（遵循本章中的菜谱 *在 gradle 中设置 Anko 库以用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s create a few buttons in our layout, clicking on them will show a toast:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在布局中创建一些按钮，点击它们将显示一个托盘：
- en: 'This is the syntax of toasts using Anko:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是使用 Anko 的托盘语法：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I suggest that you try showing toasts on the click of a button on your own,
    before moving on to the solution. Let's make a layout with three buttons that
    show toast on clicking using the preceding syntaxes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在继续到解决方案之前，先尝试自己在一个按钮点击时显示托盘。让我们使用前面的语法创建一个包含三个按钮的布局，点击这些按钮将显示托盘。
- en: 'The following is one way of creating a layout with three buttons where we have
    put our code to show toast inside `onClick` listener of the buttons. You can also
    put your layout in an external class that implements the `AnkoComponent` interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在三个按钮中创建布局的一种方法，我们在按钮的 `onClick` 监听器中放置了显示托盘的代码。你也可以将布局放在一个实现 `AnkoComponent`
    接口的外部类中：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is how our layout looks, and how the toasts appear on clicking
    on buttons:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们布局的外观，以及点击按钮时托盘的显示方式：
- en: '![](img/febd8d08-1b88-45c1-9bb5-46cfbf5841b6.jpeg)   ![](img/e547fbb8-eac8-4238-bc54-c56b7f2b59ef.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/febd8d08-1b88-45c1-9bb5-46cfbf5841b6.jpeg)   ![](img/e547fbb8-eac8-4238-bc54-c56b7f2b59ef.jpeg)'
- en: Accessing views using synthetic properties
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合成属性访问视图
- en: So we know how Anko makes handling views and layouts easy, but Kotlin makes
    accessing views and getting/setting properties of views real fun. If you have
    tried using `findViewById()`, you already know how error-prone clunky code it
    is. There are a lot of libraries out there that provide a solution to this, but
    Kotlin provides a built-in plugin for this issue. Let's understand how to use
    that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道 Anko 如何使处理视图和布局变得简单，但 Kotlin 使得访问视图以及获取/设置视图属性变得非常有趣。如果你尝试过使用 `findViewById()`，你已经知道这是一段多么容易出错的笨拙代码。现在有很多库提供了解决方案，但
    Kotlin 为此问题提供了一个内置插件。让我们了解如何使用它。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko layouts dependencies to
    your project (follow the recipe *Setting up Anko library for Anko layouts in gradle*,in
    this chapter).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以在 Android Studio 3+ 中创建一个新的 Kotlin 项目，并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对
    Android 开发有一个中级理解。确保你已经将 Anko 布局依赖项添加到你的项目中（遵循本章中的菜谱 *在 gradle 中设置 Anko 库用于 Anko
    布局*）。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following steps, we will learn how to access views using synthetic properties:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何使用合成属性访问视图：
- en: 'Let''s start with an XML layout and an activity that uses this XML layout.
    Start with creating a blank activity and create an XML layout that you wish to
    work with. I am working with the following layout file:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 XML 布局和一个使用此 XML 布局的 Activity 开始。从创建一个空白 Activity 开始，并创建你希望工作的 XML 布局。我正在使用以下布局文件：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To use synthetic properties of a view, we need to import them inside the activity,
    as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用视图的合成属性，我们需要在活动中导入它们，如下所示：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is how we can directly use view ID to provide reference to our
    view and get/set properties of the view:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们如何直接使用视图 ID 提供对视图的引用并获取/设置视图属性的方法：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is how our layout looks and works:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的布局外观和工作方式：
- en: '![](img/e4beab0f-4f11-4d22-a267-4ebb13ebda87.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4beab0f-4f11-4d22-a267-4ebb13ebda87.jpeg)'
- en: Accessing views of view groups using extension functions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展函数访问视图组的视图
- en: We can use extension functions to add new behaviors to a class that we may not
    even have access to. We can also add extension functions to view groups. One such
    view group is recycler view. Let's see how we can access views of a recycler view
    using extension functions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展函数向一个我们可能甚至无法访问的类添加新行为。我们还可以向视图组添加扩展函数。其中一个这样的视图组是回收视图。让我们看看我们如何使用扩展函数访问回收视图的视图。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以在 Android Studio 3+ 中创建一个新的 Kotlin 项目，并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对
    Android 开发有一个中级理解。
- en: How to do it…
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Kotlin has some operators that we can use on a class. We will be overloading
    one of these operators to get views of our view group:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有一些我们可以用于类的运算符。我们将重载这些运算符之一以获取视图组的视图：
- en: 'We can access views of a view group by overloading the `get` operator like
    this:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过重载`get`运算符来访问视图组的视图，如下所示：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, in order to get a view from the view group, we can use either of the following
    methods:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了从视图组获取视图，我们可以使用以下任一方法：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, use the following method because we used operator overloading,
    and `el.get(index)` matches with the array-like `el[index]` operation:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，使用以下方法，因为我们使用了运算符重载，`el.get(index)`与类似数组的`el[index]`操作匹配：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Extension functions provide the ability to add new functionalities to a class
    without modifying the class or inheriting it or using any design pattern. Extension
    functions are resolved statically and bear no connection with the class they extend.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数提供了在不修改类、继承它或使用任何设计模式的情况下向类添加新功能的能力。扩展函数是静态解析的，与它们扩展的类没有关联。
- en: By operator overloading, Kotlin gives us the ability to provide implementations
    of a predefined set of operators. To overload an operator, we can use a member
    function or an extension function, which we used in the preceding case.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运算符重载，Kotlin为我们提供了提供预定义运算集实现的能力。要重载运算符，我们可以使用成员函数或扩展函数，正如我们在前面的例子中所使用的。
