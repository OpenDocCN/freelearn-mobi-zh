<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Layouts</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Defining and inflating a layout</li>
<li>Using <kbd>RelativeLayout</kbd></li>
<li>Using <kbd>LinearLayout</kbd></li>
<li>Creating tables—<kbd>TableLayout</kbd> and <kbd>GridLayout</kbd></li>
<li><kbd>RecyclerView</kbd> replaces <kbd>ListView</kbd></li>
<li>Changing layout properties during runtime</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In Android, the user interface is defined in a <strong>layout</strong>. A layout can be declared in XML or created dynamically in code. (It's recommended to declare the layout in XML rather than in code to keep the presentation layer separate from the implementation layer.) A layout can define an individual <kbd>ListItem</kbd>, a fragment, or even the entire activity. Layout files are stored in the <kbd>/res/layout</kbd> folder and referenced in code with the following identifier: <kbd>R.layout.&lt;filename_without_extension&gt;</kbd>.</p>
<p>Android provides a useful variety of <kbd>Layout</kbd> classes that contain and organize individual elements of an activity (such as buttons, checkboxes, and other Views). The <kbd>ViewGroup</kbd> object is a container object that serves as the base class for Android's family of <kbd>Layout</kbd> classes. The Views placed in a layout form a hierarchy, with the topmost layout being the parent.</p>
<p>Android provides several built-in layout types designed for specific purposes, such as <kbd>RelativeLayout</kbd>, which allows Views to be positioned with respect to other elements. The <kbd>LinearLayout</kbd> can stack Views or align them horizontally, depending on the orientation specified. The <kbd>TableLayout</kbd> can be used for laying out a grid of Views. Within various layouts, we can also justify Views with <kbd>Gravity</kbd> and provide proportional size with <kbd>Weight</kbd> control. Layouts and <kbd>ViewGroups</kbd> can be nested within each other to create complex configurations. Over a dozen different Layout objects are provided for managing widgets, lists, tables, galleries, and other display formats, plus you can always derive from base classes to create your own custom layouts.</p>
<p>Google has released a new layout called <kbd>ConstraintLayout</kbd>. This layout is similar to <kbd>ReleativeLayout</kbd> in that Views are positioned relative to each other and to the parent, as well as a new element called guidelines. The focus of the layout is to keep the layout itself as flat as possible (deeply nested layouts can cause performance issues) and for a visual layout editor. Giving the best visual editing experience while keeping the editor in sync with the underlying class is such a priority for Google, that the same team develops both. <span><kbd>ConstraintLayout</kbd> is now the default layout created when using the Android Studio and is the basis for most of the examples in this book. (The other layouts are still available and are used when their layout provides the cleanest XML.) Here's the link to the <kbd>ConstraintLayout</kbd> class, but for the best experience, it's recommended to use the visual editor in Android Studio: <a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout">https://developer.android.com/reference/android/support/constraint/ConstraintLayout</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining and inflating a layout</h1>
                </header>
            
            <article>
                
<p>When using the Android Studio wizard to create a new project, it automatically creates the <kbd>res/layout/activity_main.xml</kbd> file (as shown in the following screenshot). It then inflates the XML file in the <kbd>onCreate()</kbd> callback with <kbd>setContentView(R.layout.activity_main)</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b1287040-1470-4e57-99f6-72b7def8a274.png" style="width:29.33em;height:18.58em;"/></div>
<p>For this recipe, we will create two slightly different layouts and switch between them with a button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>InflateLayout</kbd>. Once the project is created, expand the <kbd>res/layout</kbd> folder so we can edit the <kbd>activity_main.xml</kbd> file. <span>Use the default </span><span class="packt_screen">Phone &amp; Tablet<span> </span></span><span>settings o</span><span>n the </span><span class="packt_screen">Target Android devices </span><span>and select </span><span class="packt_screen">Empty Activity</span><span> on the </span><span class="packt_screen">Add an Activity to Mobile</span><span> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Edit the <kbd>res/layout/activity_main.xml</kbd> file so it includes a button as defined here:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/buttonLeft"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_alignParentLeft=</span><span>"true"<br/></span><span>    </span><span>android</span><span>:layout_centerVertical=</span><span>"true"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"onClickLeft"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Left Button"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintHorizontal_bias=</span><span>"0.0"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"</span><span>/&gt;</span></pre>
<ol start="2">
<li>Now make a copy of <kbd>activity_main.xml</kbd> and call it <kbd>activity_main2.xml</kbd>. Change the button so it matches the following:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/buttonLeft"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_alignParentLeft=</span><span>"true"<br/></span><span>    </span><span>android</span><span>:layout_centerVertical=</span><span>"true"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"onClickRight"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Right Button"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintHorizontal_bias=</span><span>"1.0"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"</span><span>/&gt;</span></pre>
<ol start="3">
<li>Open <kbd>MainActivity.java</kbd> and add the following two methods to handle the button clicks:</li>
</ol>
<pre style="padding-left: 60px">public void onClickLeft(View view) { 
    setContentView(R.layout.activity_main2); 
} 
 
public void onClickRight(View view) { 
    setContentView(R.layout.activity_main); 
} </pre>
<ol start="4">
<li>Run this application on a device or emulator to see it in action.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The key here is the call to <kbd>setContentView()</kbd>, which we have come across before in the autogenerated <kbd>onCreate()</kbd> code. Just pass a layout ID to <kbd>setContentView()</kbd> and it automatically inflates the layout.</p>
<p>This code is meant to make the concept easy to understand but would be overkill for simply changing the property of a button (in this example, we could just change the alignment on the button click). Inflating the layout is usually needed once, in the <kbd>onCreate()</kbd> method, but there are times when you may want to manually inflate a layout, as we did here. (If you were manually handling orientation changes, it would be a good example.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As well as identifying a layout using a resource ID, as we did here, <kbd>setContentView()</kbd> can also take a View as an argument, for example:</p>
<pre>findViewById(R.id.myView) 
setContentView(myView); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, read about <em>Fragments</em><em> </em>in <a href="ca4c7951-15e6-409d-a157-dd154977ef69.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Fragments</em>, for creating reusable screen components for your activities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using RelativeLayout</h1>
                </header>
            
            <article>
                
<p>As mentioned in the <em>Introduction</em> section, <kbd>RelativeLayout</kbd> allows Views to be position-relative to each other and the parent. <kbd>RelativeLayout</kbd> is particularly useful for reducing the number of nested layouts, which is very important for reducing memory and processing requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project and call it <kbd>RelativeLayout</kbd>. Android Studio defaults to using a <kbd>ConstraintLayout</kbd> , which we will replace with a <kbd>RelativeLayout</kbd> for this example. <span>Use the default </span><span class="packt_screen">Phone &amp; Tablet<span> </span></span><span>settings o</span><span>n the </span><span class="packt_screen">Target Android devices </span><span>and select </span><span class="packt_screen">Empty Activity</span><span> on the </span><span class="packt_screen">Add an Activity to Mobile</span><span> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open the <kbd>res/layout/activity_main.xml</kbd> file and change it as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;RelativeLayout<br/></span><span>    </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent" </span><span>&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textView1"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"Centered"<br/></span><span>        </span><span>android</span><span>:layout_centerVertical=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_centerHorizontal=</span><span>"true" </span><span>/&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textView2"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"Below Left"<br/></span><span>        </span><span>android</span><span>:layout_below=</span><span>"@+id/textView1"<br/></span><span>        </span><span>android</span><span>:layout_toLeftOf=</span><span>"@id/textView1" </span><span>/&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textView3"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"Bottom Right"<br/></span><span>        </span><span>android</span><span>:layout_alignParentBottom=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_alignParentRight=</span><span>"true" </span><span>/&gt;<br/></span><span>&lt;/RelativeLayout&gt;</span></pre>
<ol start="2">
<li>Run the code, or view the layout in the <span class="packt_screen">Design</span> tab</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This is a very straightforward exercise but it demonstrates several of the <kbd>RelativeLayout</kbd> options: <kbd>layout_centerVertical</kbd>, <kbd>layout_centerHorizontal</kbd>, <kbd>layout_below</kbd>, <kbd>layout_alignParentBottom</kbd>, and so on.</p>
<p>The most commonly used <kbd>RelativeLayout</kbd> layout attributes include the following:</p>
<ul>
<li><kbd>layout_below</kbd>: This View should be below the View specified.</li>
<li><kbd>layout_above</kbd>: This View should be above the View specified.</li>
<li><kbd>layout_alignParentTop</kbd>: Align this View to the top edge of the parent.</li>
<li><kbd>layout_alignParentBottom</kbd>: Align this View to the bottom edge of the parent.</li>
<li><kbd>layout_alignParentLeft</kbd>: Align this View to the left edge of the parent.</li>
<li><kbd>layout_alignParentRight</kbd>: Align this View to the right edge of the parent.</li>
<li><kbd>layout_centerVertical</kbd>: Center this View vertically within the parent.</li>
<li><kbd>layout_centerHorizontal</kbd>: Center this View horizontally within the parent.</li>
<li><kbd>layout_center</kbd>: Center this View both horizontally and vertically within the parent.</li>
</ul>
<div class="packt_infobox">For the complete list of <kbd>RelativeLayout</kbd> parameters, visit <a href="http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html"><span class="URLPACKT">http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In contrast to what we saw earlier, here is an example using <kbd>LinearLayout</kbd> just to center <kbd>TextView</kbd> (creating the same effect as the <kbd>layout_center</kbd> parameter of <kbd>RelativeLayout</kbd>):</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
    android:orientation="horizontal" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    android:gravity="center"&gt; 
    &lt;LinearLayout 
        android:layout_width="0dp" 
        android:layout_height="wrap_content" 
        android:layout_weight="1" 
        android:gravity="center" &gt; 
        &lt;TextView 
            android:id="@+id/imageButton_speak" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="Centered" /&gt; 
    &lt;/LinearLayout&gt; 
&lt;/LinearLayout&gt; </pre>
<p>Notice this layout is one level deeper than the equivalent <kbd>RelativeLayout</kbd> (which is <kbd>LinearLayout</kbd> nested within the parent <kbd>LinearLayout</kbd>.) Though a simple example, it's a good idea to avoid unnecessary nesting as it can impact performance, especially when a layout is being repeatedly inflated (such as <kbd>ListItem</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The next recipe, <em>Using LinearLayout</em>, will give you an alternative layout.</p>
<p>See the <em>Optimizing layouts with the Hierarchy Viewer</em> recipe for more information on efficient layout design.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using LinearLayout</h1>
                </header>
            
            <article>
                
<p>Another common layout option is <kbd>LinearLayout</kbd>, which arranges the child Views in a single column or single row, depending on the orientation specified. The default orientation (if not specified) is vertical, which aligns the Views in a single column.</p>
<p><kbd>LinearLayout</kbd> has a key feature not offered in <kbd>RelativeLayout</kbd>—the <kbd>weight</kbd> attribute. We can specify a <kbd>layout_weight</kbd> parameter when defining a View to allow the View to dynamically size based on the available space. Options include having a View fill all the remaining space (if a View has a higher weight), having multiple Views fit within the given space (if all have the same weight), or spacing the Views proportionally by their weight.</p>
<p>We will create <kbd>LinearLayout</kbd> with three <kbd>EditText</kbd> Views to demonstrate how the <kbd>weight</kbd> attribute can be used. For this example, we will use three <kbd>EditText</kbd> Views-one to enter a <kbd>To Address</kbd> parameter, another to enter <kbd>Subject</kbd>, and the third to enter <kbd>Message</kbd>. The <kbd>To</kbd> and <kbd>Subject</kbd> Views will be a single line each, with the remaining space given to the <kbd>Message</kbd> View.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project and call it <kbd>LinearLayout</kbd>. We will replace the default <kbd>RelativeLayout</kbd> created in <kbd>activity_main.xml</kbd> with <kbd>LinearLayout</kbd>. <span>Use the default </span><span class="packt_screen">Phone &amp; Tablet<span> </span></span><span>settings o</span><span>n the </span><span class="packt_screen">Target Android devices </span><span>and select </span><span class="packt_screen">Empty Activity</span><span> on the </span><span class="packt_screen">Add an Activity to Mobile</span><span> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open the <kbd>res/layout/activity_main.xml</kbd> file and replace it as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;LinearLayout  
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"&gt; 
    &lt;EditText 
        android:id="@+id/editTextTo" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:hint="To" /&gt; 
    &lt;EditText 
        android:id="@+id/editTextSubject" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:hint="Subject" /&gt; 
    &lt;EditText 
        android:id="@+id/editTextMessage" 
        android:layout_width="match_parent" 
        android:layout_height="0dp" 
        android:layout_weight="1" 
        android:gravity="top" 
        android:hint="Message" /&gt; 
&lt;/LinearLayout&gt; </pre>
<ol start="2">
<li>Run the code, or view the layout in the <span class="packt_screen">Design</span> tab.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When using vertical orientation with <kbd>LinearLayout</kbd>, the child Views are created in a single column (stacked on top of each other). The first two Views use the <kbd>android:layout_height="wrap_content"</kbd> attribute, giving them a single line each. T<span>o specify the height, </span><kbd>editTextMessage</kbd> <span>uses the following:</span></p>
<pre>android:layout_height="0dp" 
android:layout_weight="1" </pre>
<p>When using <kbd>LinearLayout</kbd>, it tells Android to calculate the height based on the weight. A weight of 0 (the default if not specified) indicates the View should not expand. In this example, <kbd>editTextMessage</kbd> is the only View defined with a weight, so it alone will expand to fill any remaining space in the parent layout.</p>
<div class="packt_tip">When using the horizontal orientation, specify <kbd>android:layout_height="0dp"</kbd> (along with the weight) to have Android calculate the width.</div>
<p>It might be helpful to think of the weight attribute as a percentage. In this case, the total weight defined is 1, so this View gets 100 percent of the remaining space. If we assigned a weight of 1 to another View, the total would be 2, so this View would get 50 percent of the space. Try adding a weight to one of the other Views (make sure to change the height to <kbd>0dp</kbd> as well) to see it in action.</p>
<p>If you added a weight to one (or both) of the other Views, did you notice the text position? Without specifying a value for <kbd>gravity</kbd>, the text just remains in the center of the View space. The <kbd>editTextMessage</kbd> View specifies <kbd>android:gravity="top"</kbd>, which forces the text to the top of the View.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Multiple attribute options can be combined using bitwise <kbd>OR</kbd>. (Java uses the pipe character (|) for <kbd>OR</kbd>). For example, we could combine two gravity options to both align along the top of the parent and center within the available space:</p>
<pre>android:layout_gravity="top|center" </pre>
<p>It should be noted that the <kbd>layout_gravity</kbd> and <kbd>gravity</kbd> tags are not the same thing. Where <kbd>layout_gravity</kbd> dictates where in its parent a View should lie, <kbd>gravity</kbd> controls the positioning of the contents within a View, for example, the alignment of text on a button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The previous recipe, <em>Using RelativeLayout</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating tables – TableLayout and GridLayout</h1>
                </header>
            
            <article>
                
<p>When you need to create a table in your UI, Android provides two convenient layout options: <kbd>TableLayout</kbd> (along with <kbd>TableRow</kbd>) and <kbd>GridLayout</kbd> (added in API 14). Both layout options can create similar-looking tables, but each using a different approach. With <kbd>TableLayout</kbd>, rows and columns are added dynamically as you build the table. With <kbd>GridLayout</kbd>, row and column sizes are defined in the layout definition.</p>
<p>Neither layout is better, it's just a matter of using the best layout for your needs. We'll create a 3 x 3 grid using each layout to give a comparison, as you could easily find yourself using both layouts, even within the same application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To stay focused on the layouts and offer an easier comparison, we will create two separate applications for this recipe. Create two new Android projects, the first called <kbd>TableLayout</kbd> and the other called <kbd>GridLayout</kbd>.  <span>Use the default </span><span class="packt_screen">Phone &amp; Tablet<span> </span></span><span>settings o</span><span>n the </span><span class="packt_screen">Target Android devices </span><span>and select </span><span class="packt_screen">Empty Activity</span><span> on the </span><span class="packt_screen">Add an Activity to Mobile</span><span> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Starting with the <kbd>TableLayout</kbd> project, open <kbd>activity_main.xml</kbd>. Change the root layout to <kbd>TableLayout</kbd>.</li>
<li>Add three <kbd>TableRow</kbd> objects with three sets of <kbd>TextView</kbd> objects to each <kbd>TableRow</kbd> to create a 3 x 3 matrix. For demonstration purposes, the columns are labeled A-C and the rows 1-3, so the first row of <kbd>TextView</kbd> objects will be A1, B1, and C1. The final result will look like this:</li>
</ol>
<pre style="padding-left: 60px">&lt;TableLayout 
     
     
    android:layout_width="match_parent" 
    android:layout_height="match_parent"&gt; 
    &lt;TableRow 
        android:layout_width="match_parent" 
        android:layout_height="match_parent"&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="A1" 
            android:id="@+id/textView1" /&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="B1" 
            android:id="@+id/textView2" /&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="C1" 
            android:id="@+id/textView3" /&gt; 
    &lt;/TableRow&gt; 
    &lt;TableRow 
        android:layout_width="match_parent" 
        android:layout_height="match_parent"&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="A2" 
            android:id="@+id/textView4" /&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="B2" 
            android:id="@+id/textView5" /&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="C2" 
            android:id="@+id/textView6" /&gt; 
    &lt;/TableRow&gt; 
    &lt;TableRow 
        android:layout_width="match_parent" 
        android:layout_height="match_parent"&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="A3" 
            android:id="@+id/textView7" /&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="B3" 
            android:id="@+id/textView8" /&gt; 
        &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="C3" 
            android:id="@+id/textView9" /&gt; 
    &lt;/TableRow&gt; 
&lt;/TableLayout&gt; </pre>
<ol start="3">
<li>Now, open the <kbd>GridLayout</kbd> project to edit <kbd>activity_main.xml</kbd>. Change the root layout to <kbd>GridLayout</kbd>. Add the <kbd>columnCount=3</kbd> and <kbd>rowCount=3</kbd> attributes to the <kbd>GridLayout</kbd> element.</li>
</ol>
<ol start="4">
<li>Now, add nine <kbd>TextView</kbd> objects to <kbd>GridLayout</kbd>. We will use the same text as the preceding <kbd>TableLayout</kbd> for a consistent comparison. Since <kbd>GridView</kbd> does not use <kbd>TableRow</kbd> objects, the first three <kbd>TextView</kbd> objects are in row 1, the next three are in row 2, and so on. The final result will look like this:</li>
</ol>
<pre style="padding-left: 60px">&lt;GridLayout 
     
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    android:columnCount="3" 
    android:rowCount="3"&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="A1" 
        android:id="@+id/textView1" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="B1" 
        android:id="@+id/textView2" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="C1" 
        android:id="@+id/textView3" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="A2" 
        android:id="@+id/textView4" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="B2" 
        android:id="@+id/textView5" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="C2" 
        android:id="@+id/textView6" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="A3" 
        android:id="@+id/textView7" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="B3" 
        android:id="@+id/textView8" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="C3" 
        android:id="@+id/textView9" /&gt; 
&lt;/GridLayout&gt; </pre>
<ol start="5">
<li>You can either run the application or use the <span class="packt_screen">Design</span> tab to see the results.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you can see when viewing the tables created, the tables basically look the same on screen. The main difference is the code to create them.</p>
<p>In the <kbd>TableLayout</kbd> XML, each row is added to the table using <kbd>TableRow</kbd>. Each View becomes a column. This is not a requirement as cells can be skipped or left empty. (See how to specify the cell location in <kbd>TableRow</kbd> in the following section.)</p>
<p><kbd>GridLayout</kbd> uses the opposite approach. The number of rows and columns are specified when creating the table. We don't have to specify the row or column information (though we can, as discussed later). Android will automatically add each View to the cells in order.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>First, let's see more similarities between the layouts. Both layouts have the ability to stretch columns to use the remaining screen space. For <kbd>TableLayout</kbd>, add the following attribute to the XML declaration:</p>
<pre>android:stretchColumns="1" </pre>
<p>The <kbd>stretchColumns</kbd> attribute specifies the (zero-based) index of the columns to stretch (<kbd>android:shrinkColumns</kbd> is a zero-based index of columns that can shrink, so the table can fit the screen).</p>
<p>To achieve the same effect with <kbd>GridLayout</kbd>, add the following attribute to all the Views in the B column (<kbd>textView2</kbd>, <kbd>textView5</kbd>, and <kbd>textView8</kbd>):</p>
<pre>android:layout_columnWeight="1" </pre>
<div class="packt_infobox">All cells in a given column must define the weight or it will not stretch.</div>
<p>Now, let's look at some of the differences, as this is really the key to determining which layout to use for a given task. The first item to note is how the columns and rows are actually defined. In <kbd>TableLayout</kbd>, the rows are specifically defined, using <kbd>TableRow</kbd>. (Android will determine the number of columns in the table based on the row with the most cells.) Use the <kbd>android:layoutColumn</kbd> attribute when defining the View to specify the column.</p>
<p>In contrast, with <kbd>GridLayout</kbd>, the row and column counts are specified when defining the table (using <kbd>columnCount</kbd> and <kbd>rowCount</kbd> as shown previously).</p>
<p>In the preceding example, we just added <kbd>TextView</kbd> objects to <kbd>GridLayout</kbd> and let the system position them automatically. We can alter this behavior by specifying the row and column position when defining the View, such as the following:</p>
<pre>android:layout_row="2" 
android:layout_column="2" </pre>
<div class="packt_tip">Android automatically increments the cell counter after adding each View, so the <em>next </em>View should also specify the row and column, otherwise, you may not get the intended result.</div>
<p>Like <kbd>LinearLayout</kbd>, shown in the <em>Using LinearLayout</em> recipe, <kbd>GridLayout</kbd> also offers the orientation attribute of supporting both horizontal (the default) and vertical. The orientation determines how the cells are placed. (Horizontal fills the columns first, then moves down to the next row. Vertical fills the first column on each row, then moves to the next column.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RecyclerView replaces ListView</h1>
                </header>
            
            <article>
                
<p>As the name implies, <kbd>ListView</kbd> is designed for displaying lists of information.  If you have prior experience on Android, you’ve probably come across the <kbd>ListView</kbd> and possibly <kbd>GridView</kbd> controls before. If not while coding, most likely you’ve used it as an app, as it’s one of the most commonly used controls available. For most applications and users, the old <kbd>ListView</kbd> was probably sufficient and didn’t pose any problems. As an example, most users could probably see their list of emails in their inbox without any problems.  But for some, they might have so many emails in their inbox that when scrolling through their list, their device would stutter (slight pauses when scrolling). Unfortunately, <kbd>ListView</kbd> has many such performance problems.</p>
<p>The most significant performance issue with <kbd>ListView</kbd> is caused by creating new item objects for each item when scrolling. Though much of the performance problem could be eliminated with a properly implemented data adapter, the implementation was optional. As the name implies, <kbd>RecyclerView</kbd> is based on recycling the list items (the part that was optional in the <kbd>ListView</kbd> adapter). There are other changes to the control as well. Whereas <kbd>ListView</kbd> has many features built-in, <kbd>RecyclerView</kbd> is very basic and relies on additional helper classes to achieve the same functionality. For some, this feels like a step backward with the new control but this design allows it to be expanded much easier.</p>
<p>Where <kbd>RecylerView</kbd> really shines is with the flexibility when extending it and animations. Our example here uses a static list so it doesn’t show off the built-in animations, but with dynamic data, your list will take advantage of the Material Design look and feel. Though <kbd>ListView</kbd> is not officially deprecated, it is recommended to use <kbd>RecyclerView</kbd> for new projects.  It’s a bit more work to get started, but this recipe will give you all the code to get set up.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio called <kbd>RecyclerView</kbd>.  Use the default <span class="packt_screen">Phone &amp; Tablet</span> settings o<span>n the </span><span class="packt_screen">Target Android devices </span>and select <span class="packt_screen">Empty Activity</span> on the <span class="packt_screen">Add an Activity to Mobile</span> dialog.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Creating <kbd>RecyclerView</kbd> is as simple as placing the control on the screen.  Most of the work is with the adapter, which we'll create from a static list. <kbd>RecyclerView</kbd> is distributed in a separate library so it needs to be added to the project as a dependency.  The steps are as follows: </p>
<ol>
<li>Either add the dependency through the Android Studio UI or add the following code to the <kbd>dependencies</kbd> section of the<span> <kbd>build.gradle (Module: app)</kbd> file</span>:<br/>
<kbd>implementation 'com.android.support:recyclerview-v7:27.1<br/></kbd></li>
</ol>
<div class="packt_infobox">NOTE: v7:27.1 is current at the time of this writing, but should be updated to the latest version.  (The IDE will likely give you a warning if you're not using the latest version.)</div>
<ol start="2">
<li> Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>&lt;TextView /&gt;</kbd> block with the following <kbd>RecyclerView</kbd> widget:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;android.support.v7.widget.RecyclerView<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/recyclerView"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent" </span><span>/&gt;</span></pre>
<ol start="3">
<li>We need another layout for the adapter to create the individual items in the list. To do this, create a new file in the <kbd>res\layout</kbd> folder called <kbd>item.xml</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:orientation=</span><span>"vertical"</span><span>&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textView"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"TextView" </span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<ol start="4">
<li class="mce-root">Now <span>comes the heart of</span> <kbd>RecyclerView</kbd> <span>– the adapter. Create a new Java file called</span> <kbd>MyAdapter.java</kbd><span>. Our new class will extend from the</span> <kbd>RecylerView.Adapter</kbd> <span>class so there are several key methods we need to override. We’ll discuss the details of this class later, but the full code is as follows:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {<br/><br/>    private List&lt;String&gt; nameList;<br/><br/>    public MyAdapter(List&lt;String&gt; list) {<br/>        nameList = list;<br/>    }<br/><br/>    @Override<br/>    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {<br/>        LayoutInflater inflater = LayoutInflater.from(parent.getContext());<br/>        View view = inflater.inflate(R.layout.item, parent, false);<br/>        MyViewHolder myViewHolder = new MyViewHolder(view);<br/>        return myViewHolder;<br/>    }<br/><br/>    @Override<br/>    public void onBindViewHolder(@NonNull MyViewHolder holder, final int position) {<br/>        final String name = nameList.get(position);<br/>        holder.textView.setText(name);<br/>    }<br/><br/>    @Override<br/>    public int getItemCount() {<br/>        if (nameList==null) {<br/>            return 0;<br/>        } else {<br/>            return nameList.size();<br/>        }<br/>    }<br/><br/>    public class MyViewHolder extends RecyclerView.ViewHolder {<br/>        public TextView textView;<br/><br/>        public MyViewHolder(View itemVieww) {<br/>            super(itemVieww);<br/>            textView = itemView.findViewById(R.id.textView);<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li class="mce-root"><span>With all the pieces set up, the final step is to put it all together. Open the</span> <kbd>MainActivity.java</kbd> <span>file and add the following code to the existing</span> <kbd>onCreate()</kbd> <span>method:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>list.add("China");<br/>list.add("France");<br/>list.add("Germany");<br/>list.add("India");<br/>list.add("Russia");<br/>list.add("United Kingdom");<br/>list.add("United States");<br/><br/>RecyclerView recyclerView = findViewById(R.id.recyclerView);<br/><br/>recyclerView.setHasFixedSize(true);<br/>LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);<br/>linearLayoutManager.setOrientation(LinearLayoutManager.VERTICAL);<br/>recyclerView.setLayoutManager(linearLayoutManager);<br/><br/>MyAdapter myAdapter = new MyAdapter(list);<br/>recyclerView.setAdapter(myAdapter);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We’ve purposely kept this recipe basic, but as you can see, there are still many steps even for this basic implementation.  The good news is, with this foundation set, you can easily expand and modify <kbd>RecyclerView</kbd> as needed. Want your list to scroll sideways instead?  You can easily accomplish this by using <kbd>LinearLayoutManager.HORIZONTAL</kbd> in the <kbd>setOrientation()</kbd> call. </p>
<p>If you have ever worked with Android <kbd>ListView</kbd> before, then the preceding steps will look very familiar.  The concept is the same: we create an adapter to hold a list of items.  Steps 1 and 2 set up <kbd>RecyclerView</kbd> on the activity. In step 3,  <span>we specify the visual layout and pass it to the adapter.</span> In step 4, we created the adapter by extending the <kbd>RecycerView.Adapter</kbd> class.  As you can see from the code, there are three methods we need to override: <kbd>onCreateViewHolder()</kbd>,  <kbd>onBindViewHolder()</kbd>, and <kbd>getItemCount()</kbd>.  The key concept behind <kbd>RecylerView</kbd> is to recycle or reuse the item Views.  This means, when you have a very large list of items, instead of creating a new view object for each item (which is very costly in terms of performance and memory usage), the item Views are reused.  So as a user scrolls through a long list, as a view goes off the screen, it's reused for the next item being shown.  Even if we added all the countries in the world to our list, there wouldn't be enough items to see the performance difference, but when you’re working with a list of thousands of items, especially if those items include images, the performance when scrolling will be noticeable. </p>
<p>Now that you understand the concept behind <kbd>RecyclerView</kbd>, hopefully the methods we need to override are self-explanatory.  The adapter only calls <kbd>onCreateViewHolder()</kbd> to create enough items to show on the screen (plus a few extra for scrolling), whereas <kbd>onBindViewHolder()</kbd> is called for each item as it’s displayed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There’s more…</h1>
                </header>
            
            <article>
                
<p>If you ran the code, then you saw it’s a very simple app. In fact, it doesn’t do anything more than just display the list in a scrollable container. Most apps will require some interaction with the list so how do we respond to click events? Unlike the older <kbd>ListView</kbd>, <kbd>RecyclerView</kbd> does not have any click events built-in. It's up to you, the programmer, to create the events you need. (For basic items like in our example, this may seem like more work for the programmer, but when you get to complex list items with buttons and other interactive controls, <kbd>ListView</kbd> would often get in your way and you’d need to implement custom events anyway.)</p>
<p>To respond to item clicks, add the following code to the <kbd>MyAdapter</kbd> class:</p>
<pre><span>private void </span><span>remove</span>(<span>int </span>position) {<br/>    <span>nameList</span>.remove(position)<span>;<br/></span><span>    </span>notifyItemRemoved(position)<span>;<br/></span>}</pre>
<p>Then add the following code to the <kbd>onBindViewHolder()</kbd> method created in step 4:</p>
<pre>holder.<span>itemView</span>.setOnClickListener(<span>new </span>View.OnClickListener() {<br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>onClick</span>(View v) {<br/>        remove(<span>position</span>)<span>;<br/></span><span>    </span>}<br/>})<span>;</span></pre>
<p>Now, when you run the code, the app will respond to the click event by removing the clicked item.  You may also notice the smooth animation when removing the item.  By calling the <kbd>notifyItemRemoved()</kbd> and <kbd>notifyItemInserted()</kbd> methods of <span><kbd>RecyclerView</kbd>, we can take advantage of the widget’s built-in Material Design animations. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing layout properties during runtime</h1>
                </header>
            
            <article>
                
<p>In Android development, it's generally the preferred practice to define the UI with XML and the application code in Java, keeping the user interface code separate from the application code. There are times where it is much easier or more efficient, to alter (or even build) the UI from the Java code. Fortunately, this is easily supported in Android.</p>
<p>In this recipe, we will obtain a reference to the <kbd>LayoutParams</kbd> object to change the margin during runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Here, we will set up a simple layout with XML and use a <kbd>LinearLayout.LayoutParams</kbd> object to change the margins of a View during runtime.  Create a new project using with an <span class="packt_screen">Empty Activity</span> called <kbd>RuntimeProperties</kbd>. <span>Use the default </span><span class="packt_screen">Phone &amp; Tablet<span> </span></span><span>settings o</span><span>n the </span><span class="packt_screen">Target Android devices </span><span>and select </span><span class="packt_screen">Empty Activity</span><span> on the </span><span class="packt_screen">Add an Activity to Mobile</span><span> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We can create or manipulate any of the standard layouts or controls through code. For this example, we will work with <kbd>LinearLayout</kbd>:  </p>
<ol>
<li>Open the <kbd>activity_main.xml</kbd> file and change the layout as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent" </span><span>&gt;<br/></span><span><br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<ol start="2">
<li>Add <kbd>TextView</kbd> with an ID value of <kbd>textView</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;TextView<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/textView"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"</span><span><br/></span><span>    </span><span>android</span><span>:text=</span><span>"TextView" </span><span>/&gt;</span></pre>
<ol start="3">
<li>Add <kbd>Button</kbd> with an ID value of <kbd>button</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"</span><span><br/></span><span>    </span><span>android</span><span>:text=</span><span>"Button" </span><span>/&gt;</span></pre>
<ol start="4">
<li>Open <kbd>MainActivity.java</kbd> and add the following code to the <kbd>onCreate()</kbd> method to respond to the button click:</li>
</ol>
<pre style="padding-left: 60px">Button button = (Button)findViewById(R.id.<span>button</span>)<span>;<br/></span>button.setOnClickListener(<span>new </span>View.OnClickListener() {<br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>onClick</span>(View view) {<br/>        ((TextView)findViewById(<br/>                R.id.<span>textView</span>)).setText(<span>"Changed at runtime!"</span>)<span>;<br/></span><span>        </span>LinearLayout.LayoutParams params = (LinearLayout.<br/>                LayoutParams)view.getLayoutParams()<span>;<br/></span><span>        </span>params.<span>leftMargin </span>+= <span>5</span><span>;<br/></span><span>    </span>}<br/>})<span>;</span></pre>
<ol start="5">
<li>Run the program on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Every View (and therefore <kbd>ViewGroup</kbd>) has a set of layout parameters associated with it. In particular, all Views have parameters to inform their parent of their desired height and width. These are defined with the <kbd>layout_height</kbd> and <kbd>layout_width</kbd> parameters. We can access this layout information from the code with the <kbd>getLayoutParams()</kbd> method. The layout information includes the layout height, width, margins, and any class-specific parameters.</p>
<p>In this example, we moved the button on each click by obtaining the current button <kbd>LayoutParams</kbd> and increasing the margin.</p>


            </article>

            
        </section>
    </body></html>