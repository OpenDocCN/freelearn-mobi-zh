<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Generics and Associated Type Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Generics and Associated Type Protocols</h1></div></div></div><p>Generics enable us to write flexible reusable functions, methods, and types that can work with any type. This chapter explains how to define and use generics and introduces the problems that can be solved with generics in the Swift programming language with examples.</p><p>This chapter will cover the following topics with coding examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generic functions and methods</li><li class="listitem" style="list-style-type: disc">Generic parameters</li><li class="listitem" style="list-style-type: disc">Generic type constraints and where clauses</li><li class="listitem" style="list-style-type: disc">Generic data structures</li><li class="listitem" style="list-style-type: disc">Associated type protocols</li><li class="listitem" style="list-style-type: disc">Extending generic types</li><li class="listitem" style="list-style-type: disc">Subclassing generic classes</li></ul></div><div class="section" title="What are generics and what kind of problems do they solve?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>What are generics and what kind of problems do they solve?</h1></div></div></div><p>Swift is a type-safe language. Whenever we work with types, we need to specify them. For instance, a function can have specific parameters and return types. We cannot pass any type but the ones that are specified. What if we need a function that can handle more than one type?</p><p>We already know that Swift provides <code class="literal">Any</code> and <code class="literal">AnyObject</code> but it is not a good practice to use them unless we have to. Using <code class="literal">Any</code> and <code class="literal">AnyObject</code> will make our code fragile as we will not be able to catch type mismatching during compile time. Generics are the solution to our requirement. Let's examine an example first. The following function simply swaps two values (<code class="literal">a</code> and <code class="literal">b</code>). The values <code class="literal">a</code> and <code class="literal">b</code> are of the <code class="literal">Int</code> type. We have to pass only <code class="literal">Int</code> values to this function to be able to compile the application:</p><pre class="programlisting">func swapTwoValues( a: inout Int, b: inout Int) {&#13;
    let tempA = a&#13;
    a = b&#13;
    b = tempA&#13;
}&#13;
</pre><p>Type safety is supposed to be a good thing but it makes our code less generic in this case. What if we want to swap two <code class="literal">Strings</code>? Should we duplicate this function with a new one?</p><pre class="programlisting">func swapTwoValues( a: inout String, b: inout String) {&#13;
    let tempA = a&#13;
    a = b&#13;
    b = tempA&#13;
}&#13;
</pre><p>The bodies of these two functions are identical. The only difference relies on the function signature, more specifically, parameter types. Some may think it is a good idea to change these parameters' type to <code class="literal">Any</code> or <code class="literal">AnyObject</code>. Remembering that <code class="literal">AnyObject</code> can represent an instance of any class type and <code class="literal">Any</code> can represent an instance of any type, excluding function types, let's assume that we change the types to <code class="literal">Any</code>:</p><pre class="programlisting">func swapTwoValues(a: Any, b: Any) -&gt; (a: Any, b: Any) {&#13;
    let temp = a&#13;
    let newA = b&#13;
    let newB = temp&#13;
    return (newA, newB)&#13;
}&#13;
</pre><p>Our API user can go ahead and send any types as parameters. They may not match. The compiler is not going to complain. Let's examine the following example:</p><pre class="programlisting">var name = "John Doe"&#13;
var phoneNumber = 5141111111&#13;
&#13;
let (a, b) = swapTwoValues(a: name, b: phoneNumber)&#13;
</pre><p>Our function is called by <code class="literal">String</code> and <code class="literal">Int</code> parameters. Our function swaps two values so the returned <code class="literal">a</code> becomes <code class="literal">Int</code> and <code class="literal">b</code> becomes <code class="literal">String</code>. This will make our code easily breakable and very hard to follow.</p><p>We do not want to be that flexible. We do not want to use <code class="literal">Any</code> and <code class="literal">AnyObject</code> but we still need some level of flexibility. Generics are the solution to our problem. We can make this function generic and robust using generics. Let's examine the following example:</p><pre class="programlisting">func swapTwoValues&lt;T&gt;(a: T, b: T) -&gt; (a: T, b: T) {&#13;
    let temp = a&#13;
    let newA = b&#13;
    let newB = temp&#13;
    return (newA, newB)&#13;
}&#13;
</pre><p>In this example, we replaced <code class="literal">Any</code> with <code class="literal">T</code>. It could be anything that is not defined already in our code or not a part of SDK. We put this type inside <code class="literal">&lt;&gt;</code> after the function name and before its parameters. Then we use this type in the parameter or return type. This way, we tell the compiler that our function accepts a generic type. Any type can be passed to this function but both parameters and return types have to be of the same type. So, our API user is not going to be able to pass <code class="literal">String</code> and <code class="literal">Int</code> as follows:</p><pre class="programlisting">var name = "John Doe"&#13;
var phoneNumber = 5141111111&#13;
&#13;
let (a, b) = swapTwoValues(a: name, b: phoneNumber) // Compile error -&#13;
  Cannot convert value of type 'Int' to expected argument type 'String'&#13;
</pre><p>The compiler will complain about the type mismatch. This way, our code is type-safe and flexible so that we can use it for different types without worrying about type mismatching problems.</p><p>Generics are great tools in functional programming because with them, we are able to develop powerful, multipurpose, and generic functions. Let's examine a functional example of generics usage.</p><p>In 
<a class="link" href="ch02.html" title="Chapter 2. Functions and Closures">Chapter 2</a>
, <span class="emphasis"><em>Functions and Closures</em></span>, we had an example such as the following one.</p><p>Suppose that we need to develop a function that adds two <code class="literal">Int</code> values, as follows:</p><pre class="programlisting">func addTwoValues(a: Int, b: Int) -&gt; Int {&#13;
    return a + b&#13;
}&#13;
</pre><p>Also, we need to develop a function to calculate the square of an <code class="literal">Int</code> value:</p><pre class="programlisting">func square(a: Int) -&gt; Int {&#13;
    return a * a&#13;
}&#13;
</pre><p>Suppose that we need to add two squared values:</p><pre class="programlisting">func addTwoSquaredValues(a: Int, b: Int) -&gt; Int {&#13;
    return (a * a) + (b * b)&#13;
}&#13;
</pre><p>What if we needed to develop functions to multiply, subtract, or divide two squared values?</p><p>The answer was using higher-order functions to write a flexible function, as follows:</p><pre class="programlisting">typealias AddSubtractOperator = (Int, Int) -&gt; Int&#13;
typealias SquareTripleOperator = (Int) -&gt; Int&#13;
&#13;
func calcualte(a: Int,&#13;
               b: Int,&#13;
           funcA: AddSubtractOperator,&#13;
           funcB: SquareTripleOperator) -&gt; Int {&#13;
 &#13;
    return funcA(funcB(a), funcB(b))&#13;
}&#13;
</pre><p>This higher-order function takes two other functions as parameters and uses them. We can call it for different scenarios such as the following one:</p><pre class="programlisting">print("The result of adding two squared values is: \(calcualte(a: 2, b: 2,&#13;
  funcA: addTwoValues, funcB: square))") // prints "The result of adding&#13;
  two squared value is: 8"</pre><p>Using higher-order functions made them flexible and more generic but still not that generic. These functions work only with <code class="literal">Int</code> values. Using generics, we can make them work with any numerical type. Let's make our calculate function even more generic:</p><pre class="programlisting">func calcualte&lt;T&gt;(a: T,&#13;
                  b: T,&#13;
              funcA: (T, T) -&gt; T,&#13;
              funcB: (T) -&gt; T) -&gt; T {&#13;
&#13;
    return funcA(funcB(a), funcB(b))&#13;
}&#13;
</pre><p>The <code class="literal">calculate</code> function accepts two values of the same type (<code class="literal">T</code>) and two functions. The <code class="literal">funcA</code> function accepts two values of the <code class="literal">T</code> type and returns a value of the <code class="literal">T</code> type. The <code class="literal">funcB</code> function accepts one value of the <code class="literal">T</code> type and returns a value of the same <code class="literal">T</code> type.</p><p>We can use the <code class="literal">calculate</code> function with any type now. For instance, we can pass any numeric number and the function will calculate it for that specific type.</p><p>There are two things to notice here. First of all, the same techniques can be applied to methods, and secondly, we cannot define <code class="literal">typealiases</code> with generic types directly in pre-Swift 3.0. Swift 3.0 introduces generic <code class="literal">typealiases</code> such as the following:</p><pre class="programlisting">typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;&#13;
typealias DictionaryOfStrings&lt;T: Hashable&gt; = Dictionary&lt;T, String&gt;&#13;
typealias IntFunction&lt;T&gt; = (T) -&gt; Int&#13;
typealias Vec3&lt;T&gt; = (T, T, T)&#13;
typealias BackwardTriple&lt;T1, T2, T3&gt; = (T3, T2, T1)&#13;
</pre></div></div>
<div class="section" title="Type constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Type constraints</h1></div></div></div><p>It is great that our function works with any type, but what if our API user tries to use the <code class="literal">calculate</code> function on types that cannot be used in arithmetic calculations?</p><p>To mitigate this problem, we can use type constraints. Using type constraints, we will be able to enforce the usage of a certain type. Type constraints specify that a type parameter must inherit from a specific class or conform to a particular protocol or protocol composition. Collections are examples of type constraints that we are already familiar with in the Swift programming language. Collections are generics in Swift, so we can have arrays of <code class="literal">Int</code>, <code class="literal">Double</code>, <code class="literal">String</code>, and so on.</p><p>Unlike Objective-C, where we could have different types in a collection, in Swift we need to have the same type that complies to the type constraint. For instance, the keys of a <code class="literal">dictionary</code> must conform to the <code class="literal">Hashable</code> protocol.</p><p>We can specify type constraints with either of the following two syntaxes:</p><p>
<code class="literal">&lt;T: Class&gt;</code> or <code class="literal">&lt;T: Protocol&gt;</code>
</p><p>Let's go back to our <code class="literal">calculate</code> example and define a numerical type constraint. There are different protocols such as <code class="literal">Hashable</code> and <code class="literal">Equatable</code>. However, none of these protocols are going to solve our problem. The easiest solution would be defining our protocol and extending the types that we want to use by conforming to our protocol. This is a generic approach that can be used to solve similar problems:</p><pre class="programlisting">protocol NumericType {&#13;
    func +(lhs: Self, rhs: Self) -&gt; Self&#13;
    func -(lhs: Self, rhs: Self) -&gt; Self&#13;
    func *(lhs: Self, rhs: Self) -&gt; Self&#13;
    func /(lhs: Self, rhs: Self) -&gt; Self&#13;
    func %(lhs: Self, rhs: Self) -&gt; Self&#13;
}&#13;
</pre><p>We define a protocol for numeric types with related basic math operators. We will require the types that we want to use to conform to our protocol. So we extend them as follows:</p><pre class="programlisting">extension Double : NumericType { }&#13;
extension Float  : NumericType { }&#13;
extension Int    : NumericType { }&#13;
extension Int8   : NumericType { }&#13;
extension Int16  : NumericType { }&#13;
extension Int32  : NumericType { }&#13;
extension Int64  : NumericType { }&#13;
extension UInt   : NumericType { }&#13;
extension UInt8  : NumericType { }&#13;
extension UInt16 : NumericType { }&#13;
extension UInt32 : NumericType { }&#13;
extension UInt64 : NumericType { }&#13;
</pre><p>Finally, we need to define the type constraint in our function as follows:</p><pre class="programlisting">func calculate&lt;T: NumericType&gt;(a: T,&#13;
                               b: T,&#13;
                           funcA: (T, T) -&gt; T,&#13;
                           funcB: (T) -&gt; T) -&gt; T {&#13;
&#13;
    return funcA(funcB(a), funcB(b))&#13;
}&#13;
&#13;
print("The result of adding two squared values is: \(calcualte(a: 2, b: 2,&#13;
  funcA: addTwoValues, funcB: square))") // prints "The result of adding&#13;
  two squared value is: 8"&#13;
</pre><p>As a result, we have a function that accepts only numerical types.</p><p>Let's test it with a non-numeric type to ensure its correctness:</p><pre class="programlisting">func format(a: String) -&gt; String {&#13;
    return "formatted \(a)"&#13;
}&#13;
&#13;
func appendStrings(a: String, b: String) -&gt; String {&#13;
    return a + b&#13;
}&#13;
&#13;
print("The result is: \(calculate("2", b: "2", funcA:&#13;
  appendStrings, funcB: format))")&#13;
</pre><p>This code example does not compile because of our type constraint, which can be seen in the following screenshot:</p><p>
</p><div class="mediaobject"><img alt="Type constraints" src="graphics/B05092_05_01_new.jpg"/></div><p>
</p><div class="section" title="Where clauses"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Where clauses</h2></div></div></div><p>The <code class="literal">where</code> clauses can be used to define more complex type constraints, for instance, to conform to more than one protocol with some constraints.</p><p>We can specify additional requirements on type parameters and their associated types by including a <code class="literal">where</code> clause after the generic parameter list. A <code class="literal">where</code> clause consists of the <code class="literal">where</code> keyword, followed by a comma-separated list of one or more requirements.</p><p>For instance, we can express the constraints that a generic type <code class="literal">T</code> inherits from a <code class="literal">C</code> class and conforms to a <code class="literal">V</code> protocol as <code class="literal">&lt;T where T: C, T: V&gt;</code>.</p><p>We can constrain the associated types of type parameters to conform to protocols. Let's consider the following generic parameter clause:</p><pre class="programlisting">&lt;Seq: SequenceType where Seq.Generator.Element: Equatable&gt;</pre><p>Here, it specifies that <code class="literal">Seq</code> conforms to the <code class="literal">SequenceType</code> protocol and the associated <code class="literal">Seq.Generator.Element</code> type conforms to the <code class="literal">Equatable</code> protocol. This constraint ensures that each element of the sequence is <code class="literal">Equatable</code>.</p><p>We can also specify that two types should be identical using the <code class="literal">==</code> operator. Let's consider the following generic parameter clause:</p><pre class="programlisting">&lt;Seq1: SequenceType, Seq2: SequenceType where &#13;
  Seq1.Generator.Element == Seq2.Generator.Element&gt;</pre><p>Here, it expresses the constraints that <code class="literal">Seq1</code> and <code class="literal">Seq2</code> conform to the <code class="literal">SequenceType</code> protocol and the elements of both sequences must be of the same type.</p><p>Any type argument substituted for a type parameter must meet all the constraints and requirements placed on the type parameter.</p><p>We can overload a generic function or initializer by providing different constraints, requirements, or both on the type parameters in the generic parameter clause. When we call an overloaded generic function or initializer, the compiler uses these constraints to resolve which overloaded function or initializer to invoke.</p></div></div>
<div class="section" title="Generic data structures"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Generic data structures</h1></div></div></div><p>In addition to generic functions, Swift empowers us to define our own generic types and data structures. In 
<a class="link" href="ch04.html" title="Chapter 4. Enumerations and Pattern Matching">Chapter 4</a>
, <span class="emphasis"><em>Enumerations and Pattern Matching</em></span>, we developed a simple tree with enumeration. Let's make it generic so that it can take different types as its leaf and node:</p><pre class="programlisting">enum GenericTree &lt;T&gt; {&#13;
    case empty&#13;
    case leaf(T)&#13;
    indirect case node(GenericTree, GenericTree)&#13;
}&#13;
&#13;
let ourGenericTree = GenericTree.node(GenericTree.leaf("First"),&#13;
  GenericTree.node(GenericTree.leaf("Second"), GenericTree.leaf("Third")))&#13;
print(ourGenericTree)</pre><p>With generics, our tree, which could accept only <code class="literal">Int</code> as a leaf, became a generic tree that can accept any type.</p><p>Using generics, it is possible to develop simple and generic types or data structures such as graphs, linked lists, stacks, and queues.</p><p>Let's examine a queue data structure example by making a <code class="literal">struct</code> generic. Queue is a well-known data structure in computer science that provides a mean to store items in the <span class="strong"><strong>First In First Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) order. A generic queue will be able to store any type in the FIFO order. The following example is not a complete implementation of a queue but it gives an idea about how generics can help develop generic data structures. Also, it is not a functional data structure as it has mutable variables and functions. In Chapter 8, <span class="emphasis"><em>Functional Data Structures</em></span>, we will explore the functional data structure in detail.</p><pre class="programlisting">struct Queue&lt;Element&gt; {&#13;
    private var elements = [Element]()&#13;
    mutating func enQueue(newElement: Element) {&#13;
        elements.append(newElement)&#13;
    }&#13;
&#13;
    mutating func deQueue() -&gt; Element? {&#13;
        guard !elements.isEmpty else {&#13;
            return nil&#13;
       }&#13;
       return elements.remove(at: 0)&#13;
    }&#13;
}&#13;
</pre></div>
<div class="section" title="Associated type protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Associated type protocols</h1></div></div></div><p>So far we were able to make functions, methods, and types generic. Can we make protocols generic too? The answer is no, we cannot, but protocols support a similar feature named associated types. Associated types give placeholder names or aliases to types that are used as part of the protocol. The actual type to use for an associated type is not specified until the protocol is adopted. Associated types are specified with the <code class="literal">associatedtype</code> keyword. Let's examine an example:</p><pre class="programlisting">protocol Container {&#13;
    associatedtype ItemType&#13;
    mutating func append(item: ItemType)&#13;
}&#13;
</pre><p>This protocol defines an <code class="literal">append</code> function that takes any item of the <code class="literal">ItemType</code> type. This protocol does not specify how the items in the container should be stored or what type they should be. The protocol only specifies an <code class="literal">append</code> function that any type must provide in order to be considered a <code class="literal">Container</code>.</p><p>Any type that conforms to the <code class="literal">Container</code> protocol should be able to specify the type of values that it stores. Specifically, it must ensure that only items of the right type are added to the container.</p><p>To define these requirements, the <code class="literal">Container</code> protocol requires a placeholder to refer to the type of elements that a container will contain, without knowing what that type is for a specific container. The <code class="literal">Container</code> protocol needs to specify that any value passed to the <code class="literal">append</code> method must have the same type as the container's element type.</p><p>To achieve this, the <code class="literal">Container</code> protocol declares an associated type called <code class="literal">ItemType</code>, written as <code class="literal">associatedtype ItemType</code>.</p><p>The protocol does not define what <code class="literal">ItemType</code> is an <code class="literal">associatedtype</code> for, and this information is left for any conforming type to provide. Nonetheless, <code class="literal">ItemType</code>
<code class="literal">associatedtype</code> provides you with a way to refer to the type of the items in a <code class="literal">Container</code> and define a type to use with <code class="literal">append</code>.</p><p>The following example shows how we will conform to a protocol with an associated type:</p><pre class="programlisting">struct IntContainer: Container {&#13;
    typealias ItemType = Int&#13;
    mutating func append(item: ItemType) {&#13;
        // append item to the container&#13;
    }&#13;
}&#13;
</pre><p>Here, we define a new <code class="literal">struct</code> that conforms to the <code class="literal">Container</code> protocol and takes <code class="literal">Int</code> as <code class="literal">ItemType</code>.</p></div>
<div class="section" title="Extending generic types"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Extending generic types</h1></div></div></div><p>In Swift, it is possible to extend a generic type. For instance, we can extend our <code class="literal">Queue</code> example <code class="literal">struct</code> and add new behaviors to it:</p><pre class="programlisting">extension Queue {&#13;
    func peek() -&gt; Element? {&#13;
        return elements.first&#13;
    }&#13;
}&#13;
</pre><p>As seen in this example, we were able to use the generic <code class="literal">Element</code> type in the extension.</p></div>
<div class="section" title="Subclassing generic classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Subclassing generic classes</h1></div></div></div><p>In Swift, it is possible to subclass a generic class. Suppose that we have a generic <code class="literal">Container</code> class. There are two different ways to subclass it. In our first example, <code class="literal">GenericContainer</code> subclasses the <code class="literal">Container</code> class and stays as a generic class. In our second example, <code class="literal">SpecificContainer</code> subclasses <code class="literal">Container</code> and becomes a <code class="literal">Container</code> of <code class="literal">Int</code>, therefore, it is not generic anymore:</p><pre class="programlisting">class Container&lt;Item&gt; {&#13;
}&#13;
&#13;
// GenericContainer stays generic&#13;
class GenericContainer&lt;Item&gt;: Container&lt;Item&gt; {&#13;
}&#13;
&#13;
// SpecificContainer becomes a container of Int type&#13;
class SpecificContainer: Container&lt;Int&gt; {&#13;
}&#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we understood how to define and use generics. We also understood what type of problems generics solve. Then we explored type constraints, generic data structures, and associated type protocols with examples. Generics are great tools that, when accustomed to, make our code more flexible, useful, and robust, so we will use them a lot in the rest of our book.</p><p>In the following chapter, we will be introduced to some category theory concepts such as functors, applicative functors, and monads. We will also explore higher-order functions such as map, filter, and reduce.</p></div></body></html>