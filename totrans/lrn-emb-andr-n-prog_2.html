<html><head></head><body>
		    <div class="readerChapterContent">
		      <div>
  <h1 class="Title-1"><span>Chapter 2. Obtaining the Source Code – Structure and Philosophy</span></h1>

  <p><span>In the previous chapter, we had an overview about the system layer-based architecture and we had our first hands-on experience, testing a real-world device using CTS tools suite.</span></p>

  <p><span>In this chapter, the user will learn about the philosophy behind the Android and Google development model. We will show how the source code is organized, which are the main branches, and what the workflow is. We will create a step-by-step journey to retrieve the </span><span class="strong"><strong><span>Android Open Source Project</span></strong></span><span> (</span><span class="strong"><strong><span>AOSP</span></strong></span><span>) source code and prepare the environment by installing all the required tools.</span></p>

  <p><span>The user will learn how to contribute to the Android Open Source Project, how to use tools such as </span><code class="literal"><span>git</span></code><span>, the version-control system, and, </span><code class="literal"><span>repo</span></code><span>, the repository manager.</span></p>

  <p><span>To complete the chapter, we will dig into the AOSP folder structure, analyzing the most important components that create the most popular mobile operating systems of the world.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>The Android philosophy</span></h2>

  <p><span>Android is an open source platform created to be compatible with a huge number of different devices, from a hardware point of view to a purpose point of view. The main goal is to provide a freely available software platform for both large enterprise companies and small independent makers or even single developers. Android aims to provide an easy way to create innovative solutions and bring them to market with no effort.</span></p>

  <p><span>Everything started in 2005, when Google acquired Android Inc., a small company that was developing an operating system for mobile devices. A couple of years later, the Open Handset Alliance was born. In 2007, 84 companies, including mobile operators, handset manufacturers, and semiconductor and software companies, publicly announced their brand new, upcoming mobile operating system.</span></p>

  <p><span>For one more whole year the project was kept a secret. Google worked hard to bring the project to version 1.0 and in 2008 Android was shown to the world. In the following seven years, four major versions of the system have been released. The following table tells the chronological history of all the Android versions. Every single version was released as open source software to the world. Every version, but </span><code class="literal"><span>Honeycomb</span></code><span>, that was an ugly PR slip for Google, which spent a lot of energy to bring it down and replace it with </span><code class="literal"><span>Ice Cream Sandwich</span></code><span> as soon as possible:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_18.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_18" style="max-width:521px;max-height:849px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>The license</span></h3>

  <p><span>Creating an open source platform brings in a few concerns about which license gives the perfect balance between protection and freedom. The goal is to give manufacturers enough freedom to adapt the system to their own hardware without being scared of dark licenses, trying to steal their intellectual property. To reach this goal, Google picked one of the most famous open source licenses available at the time and applied it to most parts of the operative system.</span></p>

  <p><span>The license that Google uses to protect the Android Open Source Project (AOSP) is the Apache Software License, Version 2.0, also known as Apache 2.0, and it covers almost every line of code published to AOSP. The Apache 2 license doesn't apply to one big system component—the kernel. Linux Kernel is protected by GNU Public License, V2, and it comes with a </span><span class="emphasis"><em><span>system exception</span></em></span><span> to be able to be shipped with Android.</span></p>

  <p><span>Being open source and being easily adaptable to popular hardware, it launched Android to the top of the mobile market at rocket speed, reaching one billion active devices all over the world with over one million apps available on the Google Play Store. One billion active devices is the result of a winning strategy—providing manufacturers with a software solution for their hardware, easy to integrate and customize, coming free of charge and community supported, in a market that was dominated by Apple.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Open source, closed doors</span></h3>

  <p><span>A closer look at the project shows how Android is slightly different from other open source projects: Android is developed by Google behind closed doors. Lots of people in the community don't agree about considering Android as </span><span class="emphasis"><em><span>open</span></em></span><span> as Linux is. In fact, the two approaches are completely different. Yes, both of them have an open source license, but Linux is a community-developed project, Android, instead, is completely developed by Google.</span></p>

  <p><span>Every technical discussion, every decision, every roadmap step is decided by Google. When the development life cycle completes, Google releases a new version of the operative system, updates the public source code repository and everybody is able to download the latest version of the OS.</span></p>

  <p><span>Of course, there are e-mailing lists for discussion and support and there are a few ways to contribute to the project, but everything is decided by the Android development team.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The Android development model</span></h3>

  <p><span>To assure the stability of the Android current release, Google keeps the source code in </span><span class="emphasis"><em><span>code lines</span></em></span><span>. This approach provides a proper mechanism to keep separated the current stable version, available on all latest devices, from the currently under development, unstable version. As you may easily notice, Google is using a different naming convention for Android compared to the usual nomenclature of open source projects—</span><code class="literal"><span>code line</span></code><span> is used instead of </span><code class="literal"><span>branch</span></code><span>, because a single </span><code class="literal"><span>code line</span></code><span> can be based on multiple git </span><code class="literal"><span>branches</span></code><span>.</span></p>

  <p><span>The following diagram shows how the source code history evolves over time, through different branches and releases:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_19.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_19" style="max-width:584px;max-height:527px"/></div>

  <p><span>The previous diagram shows the main </span><code class="literal"><span>public branch</span></code><span>, Upstream, on the left. This branch is the main public development branch where all the critical bug fixes are released constantly, and where all the main experimentation with new devices and new technology is performed. Every developer or manufacturer can obtain this set of source code and start to create their own Android device.</span></p>

  <p><span>On the right side of the diagram, we can see Google's private branch. This branch contains the Android </span><code class="literal"><span>next version</span></code><span>. Generally, all the development is done by Google itself, with the support of a hardware partner that provides a reference device. Typically, this device is a high-end, top-class device that Google appoints as Google's next reference device, also known as Nexus. Every new Nexus has been chosen keeping in mind Google Android's development roadmap—every technical hardware specification supports or discourages particular software development, to create the perfect symbiosis between the device and the operating system.</span></p>

  <p><span>When the internal development reaches the desired stable point, the new version is released, every branch is updated accordingly and a new public/private development cycle begins, once again.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Source code tags and builds</span></h3>

  <p><span>To effectively refer to a specific Android version, every public release, since Android 1.5, comes with a fancy pop codename, a version number, and a more developer-oriented API level.</span></p>

  <p><span>The following table shows how the correspondence between codename/version/API level is not always a one-to-one relationship. Most of the time, the code name has a longer life cycle than the version number:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_20.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_20" style="max-width:971px;max-height:1310px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Nexus</span></h3>

  <p><span>The Nexus family contains all those Android devices that Google designs, produces, and sells, with the help of its hardware manufacture partners.</span></p>

  <p><span>One of the peculiarities of the Nexus family is the bare Android system it equips the device—there is no customization of any sort, neither from the manufacturer nor from the telephone carrier. The system is based on pure Android source code, providing the user with the purest Android experience. As an advanced note, the device bootloader can be easily and legally unlocked, to allow every sort of modification any expert user could desire. Security-wise, the Nexus devices are the first ones that receive security fixes and system updates—stay updated, stay safe!</span></p>

  <p><span>The Nexus family is continuously growing in numbers and quality and it now contains smartphones, tablets, and even digital players. The upcoming tables show an overview on all the currently available models.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Phones</span></h4>

  <p><span>Here is a list of all stock Nexus phones:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_21.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_21" style="max-width:521px;max-height:417px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>Tablets</span></h4>

  <p><span>Here is a list of all stock Nexus tablets:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_22.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_22" style="max-width:520px;max-height:304px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>Digital media players</span></h4>

  <p><span>Here is a list of all stock Nexus digital media players:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_23.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_23" style="max-width:523px;max-height:188px"/></div>

  <p><span>Every single device in these tables has its own Android build, specifically tailored for its hardware and purpose. The following table is an example of builds code names and versions that Google provides for all the expert Android users who want to manually replace the operative system and want to retrieve the official build by Google:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_24.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_24" style="max-width:521px;max-height:742px"/></div>

  <p><span>Every build is identified by a </span><code class="literal"><span>build-code</span></code><span>, for instance, LMY470. The first letter is the initial letter of the code name, for instance, </span><span class="emphasis"><em><span>L</span></em></span><span>ollipop; the second letter identifies the branch used to produce this build; the following two letters identify the release date, based on quarters notation—A is Q1 2009, F is Q2 2010, and so on. The two numbers following the quarter letter specify the release day. The last letter identifies the build number. This notation is not critically precise. Google often reuses the same build code for more than one build. We need to consider it as a rough estimation of the release date.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Source code tools</span></h3>

  <p><span>Android is a huge project, with an astonishing amount of source code. Google itself manages the source code and stores it on its servers which are publicly accessible to the developers and advanced users.</span></p>

  <p><span>Considering the complexity of the project, we will need only two tools to retrieve the source code:</span></p>

  <ul>
    <li><span>git</span></li>

    <li><span>repo</span></li>
  </ul>

  <p><span>Let's have a quick overview on these powerful tools that will accompany us during our journey.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Git</span></h4>

  <p><span>Git is currently the most popular source code version control system, openly available in the world. It's an impressive tool created by Linus Torvalds (yes, the same Linus Torvalds who created the Linux kernel contained in Android).</span></p>

  <p><span>In 2005, Torvalds was struggling to find a proper way to manage the amount of code and contributions from the developers who were working on its Linux kernel. No tool available at that time was enough and, in a few days, he created the first working version of his new distributed revision control system that was able to manage a huge project with speed and flexibility.</span></p>

  <p><span>Git provides effective and easy-to-achieve solutions for modular systems and Google takes full advantage of this opportunity. Every contribution to the Android code base is provided using git features—commits, branches, and patches.</span></p>

  <p><span>The system is kept as modular as possible to allow developers and OEM to extract and replace components that need to be customized. Knowing this, it's easy to guess how many git repositories Android contains—dozens of interconnected repositories of different sizes and structures.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Repo</span></h4>

  <p><span>To overcome the difficulty of managing a plethora of different repositories, Google created </span><code class="literal"><span>git-repo</span></code><span>, a tool written in Python that acts like a coordinator upon git and allows automation of some common parts of the workflow.</span></p>

  <p><span>Repo comes in handy in a lot of scenarios. Most of all, all those network operations that involve the source code: retrieving, updating, and pushing the code to the remote servers. Repo is a pivot tool and we will learn a lot about it in the next sections.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Gerrit</span></h3>

  <p><span>Worth mentioning, Gerrit is the code review tool used to evaluate and approve every contribution made to AOSP. It provides a graphical user interface to monitor the evolution of the code base and represent the central point where all the contributions end before being accepted and merged into the main code base, or rejected if the review resolves in a </span><span class="emphasis"><em><span>no, th</span></em></span></p></div>
<div><p><span class="emphasis"/> <span class="emphasis"><em><span>anks</span></em></span><span>.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Setting up the environment</span></h2>

  <p><span>The Android build system is officially supported by Ubuntu Linux. Google assures that the system setup, the environment setup, and all the requirements are easily reproducible on this particular Linux distribution. The truth is, nowadays, every Linux distribution can be prepared to perform a proper Android build with little effort.</span></p>

  <p><span>To be closest to the guidelines and because we think that Ubuntu is the easiest system to set up for the job, in this book we are going to use Ubuntu Linux 15.04 to perform all our building procedures.</span></p>

  <p><span>If you are working on OS X or Windows and you prefer to stick to these operating systems, we are going to show you how to achieve our goal even using a virtual machine.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Free space</span></h3>

  <p><span>The amount of free space on the hard drive needed by the build system is massive. The Android source code by itself can reach 100 gigabytes of occupied space. When we move to more advanced scenarios, such as building using a caching system, such as </span><code class="literal"><span>ccache</span></code><span>, to speed up multiple system builds, we can easily reach 200 gigabytes of occupied space. It's very important to be sure that this kind of free space is available on your machine, because filling up the hard disk during the building process could bring the system into an unstable state.</span></p>

  <p><span>Another note is about your connection speed—considering the amount of data needed to get ready to build, be sure to have a fast Internet connection, or an appropriate amount of patience.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Installing the required tools</span></h2>

  <p><span>Even if officially the supported Linux distribution is Ubuntu, the following procedures and commands are equally correct on every Debian-based distribution, if it is actually installed on your computer or is running as a virtual machine.</span></p>

  <p><span>To be able to acquire the source code, retrieving it from Google </span><span class="emphasis"><em><span>git repository</span></em></span><span>, we need to install git. Let's open a Terminal and run:</span></p>
  <pre><span class="strong"><strong>~$ sudo apt-get install git</strong></span>
</pre>

  <p><span>Apt will ask for our super user password and will take care of installing git in the system. Once we have git, we need its trusted companion tool—repo. Repo does not need a real installation. It's a Python script, so we just need to download it and place it in a handy folder.</span></p>

  <p><span>Let's create a </span><code class="literal"><span>bin</span></code><span> folder in our home folder and add it to the system path:</span></p>
  <pre><span class="strong"><strong>~$ mkdir ~/bin</strong></span>
<span class="strong"><strong>~$ export PATH=~/bin:$PATH</strong></span>
</pre>

  <p><span>Now that we have a folder, we can download </span><code class="literal"><span>repo</span></code><span> using </span><code class="literal"><span>curl</span></code><span>:</span></p>
  <pre><span class="strong"><strong>~$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</strong></span>
<span class="strong"><strong>~$ chmod a+x ~/bin/repo</strong></span>
</pre>

  <h4 class="Title-3 sigil_not_in_toc"><span>Note</span></h4>

  <p><span>If </span><code class="literal"><span>curl</span></code><span> is not available in your system, you can install it using </span><code class="literal"><span>apt-get</span></code><span> as shown in the following command:</span></p>
  <pre><span class="strong"><strong>~$ sudo apt-get install curl</strong></span>
</pre>

  <p><span>The following is the output:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_25.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_25" style="max-width:800px;max-height:177px"/></div>

  <p><span>The previous screenshot shows the download and our </span><code class="literal"><span>chmod</span></code><span> command, to make </span><code class="literal"><span>repo</span></code><span> properly executable. The </span><code class="literal"><span>repo</span></code><span> tool comes with a collection of help commands accessible like this:</span></p>
  <pre><span class="strong"><strong>$ repo help</strong></span>
</pre>

  <p><span>This command lists all the available commands, as shown in the next screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_26.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_26" style="max-width:1000px;max-height:877px"/></div>

  <p><span>For further help, every command, for instance </span><code class="literal"><span>info</span></code><span>, has its own help screen accessible like this:</span></p>
  <pre><span class="strong"><strong>$ repo help command</strong></span>
</pre>

  <p><span>The following screenshot shows the help screen for the </span><code class="literal"><span>info</span></code><span> command:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_27.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_27" style="max-width:810px;max-height:470px"/></div>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Getting ready</span></h2>

  <p><span>As we already know, Google is the official manager of the entire hardware infrastructure supporting Android—everything is hosted and maintained by Google. The source code repository also provides a web UI to graphically navigate the source code. This source code browser is available at </span><a class="ulink" href="https://android.googlesource.com/"><span>https://android.googlesource.com/</span></a><span>.</span></p>

  <p><span>The following screenshot shows an example of what the page looks like:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_28.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_28" style="max-width:889px;max-height:696px"/></div>

  <p><span>Every single item of the list shown in the previous screenshot is a </span><code class="literal"><span>git</span></code><span> repository. This can give you a perfect idea of the importance of Google's </span><code class="literal"><span>repo</span></code><span> tool—manually managing this many repositories would be pure madness! Using </span><code class="literal"><span>repo</span></code><span>, retrieving, downloading, and creating the proper folder structure is a few-lines' task. Let's do it!</span></p>

  <p><span>First things first—create a working folder. Open a Terminal and create a folder like this:</span></p>
  <pre><span class="strong"><strong>~$ mkdir WORKING_DIRECTORY</strong></span>
<span class="strong"><strong>~$ cd WORKING_DIRECTORY</strong></span>
</pre>

  <p><span>Once in the folder, run:</span></p>
  <pre><span class="strong"><strong>~/WORKING_DIRECTORY$ repo init -u https://android.googlesource.com/platform/manifest</strong></span>
</pre>

  <p><span>The URL specifies the project manifest file. The manifest specifies which repositories are necessary for the download and what the folder structure is that must be expected to run.</span></p>

  <p><span>During this phase, </span><code class="literal"><span>repo</span></code><span> will ask for your full name and e-mail. This sort of registration is needed to enable the system to receive your contributions. Gerrit will use this information to communicate with you with notifications and news. Obviously, your name will be associated to every contribution, fix, or feature you will submit in the future. Making sure that the provided e-mail address is a valid Google account is a wise choice.</span></p>

  <p><span>A successful initialization ends with:</span></p>
  <pre><span class="strong"><strong>repo has been initialized</strong></span>
</pre>

  <p><span>Congrats! We now have an initialized repo in the current folder and a configuration folder, named </span><code class="literal"><span>.repo</span></code><span>, containing, for instance, the downloaded manifest file.</span></p>

  <p><span>Run </span><code class="literal"><span>ls -la</span></code><span> in your Terminal to spot the </span><code class="literal"><span>.repo</span></code><span> folder.</span></p>

  <p><span>Currently, our folder contains the </span><code class="literal"><span>master</span></code><span> branch of the whole Android project. It has to be considered a development branch, so we have no guarantee that the system will work on a device or even build on our system. We can use this branch to submit some contribution, but this is a task for another step of our journey. Our current goal is to try to build a working system, so the smart move is to switch to a branch or a TAG that officially supports a specific device.</span></p>

  <p><span>To switch to a specific branch, we will use </span><code class="literal"><span>repo</span></code><span>, which will take care of configuring every single repository involved, to bring us to a stable and guaranteed environment:</span></p>
  <pre><span class="strong"><strong>:~/WORKING_DIRECTORY$ repo init -u https://android.googlesource.com/platform/manifest -b android-5.1.1_r3</strong></span>
</pre>

  <p><span>The previously shown table contains every possible branch we could switch to.</span></p>

  <p><span>To retrieve the whole list of available branches, we are going to use a trick—cloning one specific repository that provides this very information: </span><code class="literal"><span>manifest.git</span></code><span>. Let's open a Terminal and clone it:</span></p>
  <pre><span class="strong"><strong>$ git clone http://https://android.googlesource.com/platform/manifest.git manifest</strong></span>
</pre>

  <p><span>Enter the folder we have just created and get the list:</span></p>
  <pre><span class="strong"><strong>$ cd manifest</strong></span>
<span class="strong"><strong>$ git branch -a</strong></span>
</pre>

  <p><span>The following screenshot shows part of the huge list of available branches:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_29.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_29" style="max-width:810px;max-height:750px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Downloading the code</span></h3>

  <p><span>Everything is in place: folders are ready, </span><code class="literal"><span>repo</span></code><span> is properly configured, we have tons of free hard disk space and a fast Internet connection. Let's sync!</span></p>

  <p><span>Open a Terminal and run:</span></p>
  <pre><span class="strong"><strong>$ repo sync</strong></span>
</pre>

  <p><span>Make yourself a tasty coffee as this will take some time! The </span><code class="literal"><span>repo</span></code><span> tool is going to download every single file of every single repository specified in the manifest file, for more than 50 gigabytes.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Hands on the code</span></h3>

  <p><span>Knowing that we will adapt Android to our hardware, it's important to have a clear understanding about the workflow to create and submit contributions. To achieve this goal, we will use both </span><code class="literal"><span>repo</span></code><span> and </span><code class="literal"><span>git</span></code><span>.</span></p>

  <p><span>The contribution workflow is based on five steps:</span></p>

  <ol>
    <li><span>We create a new topic branch:

      </span><pre><span class="strong"><strong>$ repo branch</strong></span>
</pre>
    </li>

    <li><span>We develop all the edits, fixes, and features we want. We add these contributions to the next commit:

      </span><pre><span class="strong"><strong>$ git add our_files</strong></span>
</pre>
    </li>

    <li><span>We save our staged file to the git repo:

      </span><pre><span class="strong"><strong>$ git commit -m "Add awesome new feature"</strong></span>
</pre>
    </li>

    <li><span>We submit our new commits to the code review server:

      </span><pre><span class="strong"><strong>$ repo uploads</strong></span>
</pre>
    </li>
  </ol>

  <p><span>Our code has been submitted and it's waiting to be reviewed—fingers crossed!</span></p>

  <p><span>If you don't want to download the whole code base and you know already which specific module you are going to customize, you can sync just this module:</span></p>
  <pre><span class="strong"><strong>$ repo sync art</strong></span>
</pre>

  <p><span>When our module has been synced, we need to create a new branch to keep our environment organized, with a clear structure and an easy way to compare our edits with the original content. To create our new </span><code class="literal"><span>topic branch</span></code><span>, we need to enter the module folder and run a </span><code class="literal"><span>repo</span></code><span> command:</span></p>
  <pre><span class="strong"><strong>$ cd art/</strong></span>
<span class="strong"><strong>$ repo start my_branch .</strong></span>
</pre>

  <p><span>If everything is in place, we run this command:</span></p>
  <pre><span class="strong"><strong>$ repo status .</strong></span>
</pre>

  <p><span>This command will be a bit comforting:</span></p>
  <pre><span class="strong"><strong>:$[…]/art$ repo status .</strong></span>
<span class="strong"><strong>project art/                    branch my_branch</strong></span>
</pre>

  <p><span>During our work, we can create as many branches as we need and we can list them as follows:</span></p>
  <pre><span class="strong"><strong>$ git branch</strong></span>
</pre>

  <p><span>The following screenshot shows the list of all the branches in the current module:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_30.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_30" style="max-width:810px;max-height:250px"/></div>

  <p><span>The current branch is the one with the star symbol (asterisk). Now that we know which are the available branches, we can switch from branch to branch using:</span></p>
  <pre><span class="strong"><strong>$ git checkout branch_name</strong></span>
</pre>

  <p><span>For every fix or feature we add, a new Git commit will land in our branch:</span></p>
  <pre><span class="strong"><strong>$ git add art_new_feature</strong></span>
<span class="strong"><strong>$ git commit -m "Add new awesome feature to ART"</strong></span>
</pre>

  <p><span>Once all our edits are complete, we need to get ready to submit our contribution to the Gerrit system and to the developers in charge of reviewing every code proposal.</span></p>

  <p><span>Before being able to submit our patches, we need to generate a new password to access the source code repository. Google provides a quick service to generate a password at the URL </span><a class="ulink" href="https://android-review.googlesource.com/new-password"><span>https://android-review.googlesource.com/new-password</span></a><span>.</span></p>

  <p><span>Choose your Google account that you want to connect to the Android source code repository and you will land at the git cookie configuration page. Google has everything already set up for you. Just copy and paste the configuration in one of your Terminals and you are ready to go.</span></p>

  <p><span>To submit our branch, we update the module to be sure it is aligned with </span><code class="literal"><span>upstream</span></code><span> and then we update:</span></p>
  <pre><span class="strong"><strong>$ repo sync</strong></span>
<span class="strong"><strong>$ repo upload</strong></span>
</pre>

  <p><span>Once we ask for uploading, </span><code class="literal"><span>repo</span></code><span> will ask for confirmation, showing all the contributions we are submitting, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_31.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_31" style="max-width:810px;max-height:230px"/></div>

  <p><span>After the confirmation, </span><code class="literal"><span>repo</span></code><span> will establish a secure connection with the repository server and your contribution will be stored online. You are now an Android developer or at least you are getting there!</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>A look inside AOSP</span></h2>

  <p><span>At this point, we have our copy of AOSP so we can start looking inside to see what the project consists of.</span></p>

  <p><span>Before delving inside, we must warn you that, when generating a new build image from scratch, you won't find any of the Google applications that you can find on most of the Android devices. That is because the Google applications are not licensed under Apache 2.0 license, so they are not provided with the public project. We are talking about applications such as Play Store, Gmail, YouTube, Maps, and all other official Google apps.</span></p>

  <p><span>These applications are provided only to the compatible devices, that is, the devices that pass the </span><code class="literal"><span>Compatibility Test Suite</span></code><span> we met in the first chapter.</span></p>

  <p><span>Being able to distribute an Android device with all Google's app on-board is no easy trip. After confirming that the device is compatible using CTS, it is also necessary to obtain a particular </span><span class="strong"><strong><span>Google Mobile Services</span></strong></span><span> (</span><span class="strong"><strong><span>GMS</span></strong></span><span>) license by contacting Google directly.</span></p>

  <p><span>Obviously, you can find those applications in their binary form on the Internet and add it like that to your build. It's not the official way to achieve the goal and we support a cleaner conduct to distribute our awesome device, but is worth mentioning that there are blurry shortcuts.</span></p>

  <p><span>Going back to our source code, let's take a look inside our </span><code class="literal"><span>WORKING_DIRECTORY</span></code><span> and see where we can find the basic Android components that AOSP is composed of.</span></p>

  <p><span>The next screenshot shows a clear overview of all the folders contained in the root directory:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_32.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_32" style="max-width:1000px;max-height:978px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>The ART directory</span></h3>

  <p><span>One of the most important folders is surely </span><code class="literal"><span>art/</span></code><span>. It contains the source code for the new </span><code class="literal"><span>Runtime Environment</span></code><span>, designed and devolved by Google.</span></p>

  <p><span>ART is an acronym of Android RunTime and it has been introduced in the Android 4.4 Kitkat as an alternative to the Dalvik Virtual Machine. It has completely replaced Dalvik in Android 5.0 Lollipop. The old Dalvik VM was based on a </span><span class="strong"><strong><span>Just-In-Time</span></strong></span><span> (</span><span class="strong"><strong><span>JIT</span></strong></span><span>) compiler technology, that is, it interprets and compiles an application source code into machine code in real time. This implementation has its advantages, but also disadvantages since runtime compilation certainly impacts system performance.</span></p>

  <p><span>ART is based on an AOT (Ahead-of-time) technology, which compiles all the application code at the time of application installation, that is, before the execution. That obviously requires more time to install the application, but that time is usually imperceptible seeing the hardware performance of the latest Android devices.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The bionic directory</span></h3>

  <p><span>Bionic is the C-runtime for Android. Unlike most Linux distributions, Android doesn't use the GNU C library (</span><code class="literal"><span>glibc</span></code><span>). The main differences between the GNU C library and </span><code class="literal"><span>bionic</span></code><span> is the license— </span><code class="literal"><span>glibc</span></code><span> is distributed under the GPL license while bionic has the BSD license. A more permissive license is crucial in a world so commercially oriented.</span></p>

  <p><span>Other very important features are the lightness and the size. Bionic is much smaller than glibc, which makes it more usable for embedded systems such as cell phones. Also, it has been made having in mind low-performance processors, so it performs better.</span></p>

  <p><span>A big part of the bionic source code comes from the OpenBSD project, but there are also some parts, such as </span><code class="literal"><span>pthread</span></code><span> and the dynamic linker, that have been written from scratch, to be sure to meet the performance, lightness, and flexibility requirements.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The build directory</span></h3>

  <p><span>This directory contains the whole Android build system. It contains all the </span><code class="literal"><span>makefile</span></code><span> core templates.</span></p>

  <p><span>Besides that, it contains </span><code class="literal"><span>envsetup.sh</span></code><span>, a script that allows the developer to work with Android sources without struggling with environment management. We will explain it in more detail later in the book, but in short, launching this script gives you various utilities that enable you to perform various operations on the source code, for example, compile specific modules or perform searches on specific files such as on all </span><code class="literal"><span>.java</span></code><span> files, and so on.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The external directory</span></h3>

  <p><span>All the packages regarding open source projects used by Android can be found in this directory. It contains various libraries as well as very important utilities such as </span><code class="literal"><span>zlib</span></code><span>, </span><code class="literal"><span>SQLite</span></code><span>, and </span><code class="literal"><span>webkit</span></code><span>.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The device directory</span></h3>

  <p><span>Here you can find all the configurations and definitions for specific devices. The following screenshot gives an overview of the content. As you can see, it's full of folders with names of well-known manufacturers:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_33.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_33" style="max-width:646px;max-height:322px"/></div>

  <p><span>There are all the definitions for the official Google devices, that is for all the Nexus devices, but there are also other directories such as:</span></p>

  <ul>
    <li><code class="literal"><span>common</span></code><span>: This directory contains certain information about the GPS and a script that allows you to extract the binary parts regarding a specific device so that they can be included in the image build.</span></li>

    <li><code class="literal"><span>generic</span></code><span>: This directory contains the configuration for the generic device called "goldfish" and is used to build the emulator image.</span></li>

    <li><code class="literal"><span>google</span></code><span>: This directory contains the code for the </span><span class="strong"><strong><span>Accessory Development Kit</span></strong></span><span> (</span><span class="strong"><strong><span>ADK</span></strong></span><span>). It also contains a DEMOKIT Android app that allows you to control the ADK board. ADK is a reference implementation for hardware manufacturers and hobbyists that can be used as a starting point for making Android accessories;</span></li>

    <li><code class="literal"><span>sample</span></code><span>: This directory contains a complete example of how to write your own shared library for Android, without modifying the Android framework. It also shows how to write JNI code to be included in the library, and a client application that uses such a library.</span></li>
  </ul>

  <h3 class="Title-2 sigil_not_in_toc"><span>The frameworks directory</span></h3>

  <p><span>This folder is very important because it contains the source code for the Android framework. It is here that you can find all the main components of Android such as Activity, Services, and so on. Here you can also find the mapping used between the native code in C/C++ and the code in Java.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The out directory</span></h3>

  <p><span>As intuitive as it can sound, when the build is done, the result of the compilations is in this directory. Here we will find images that are ready to be flashed on our device or emulator, under named subdirectories, such as </span><code class="literal"><span>out/product/generic/</span></code><span> for the emulator image. In one of its subfolders, in the </span><code class="literal"><span>out/host/linux-x86/</span></code><span>, you can also find all the tools that are needed from the host side, such as </span><code class="literal"><span>fastboot</span></code><span>, </span><code class="literal"><span>zipalign</span></code><span>, </span><code class="literal"><span>dexdump</span></code><span>, and so on.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The packages directory</span></h3>

  <p><span>As the folder name says, here you can find all the standard Android application packages, for example, </span><code class="literal"><span>Camera</span></code><span>, </span><code class="literal"><span>Calculator</span></code><span>, </span><code class="literal"><span>Dialer</span></code><span>, </span><code class="literal"><span>Launcher</span></code><span>, </span><code class="literal"><span>Settings</span></code><span>, and so on. Once again, these are not Google apps such as </span><code class="literal"><span>YouTube</span></code><span> or </span><code class="literal"><span>Maps</span></code><span>, but just the system apps that are common to every Android installation.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The system directory</span></h3>

  <p><span>The </span><code class="literal"><span>system/</span></code><span> directory contains the source code of the Android </span><code class="literal"><span>system core</span></code><span>, that is a minimal Linux system that takes care of the initialization of the device before the ART virtual machine starts any Java-based service.</span></p>

  <p><span>Inside this folder, you can find the source code for the </span><code class="literal"><span>init</span></code><span> process and the relative </span><code class="literal"><span>init.rc</span></code><span> default script that initializes and dynamically configures the platform, as well as applications such as </span><code class="literal"><span>Toolbox</span></code><span> (the Android alternative to </span><code class="literal"><span>BusyBox</span></code><span>) and the source codes for the </span><code class="literal"><span>adb</span></code><span> and </span><code class="literal"><span>fastboot</span></code><span> utilities that we will explain in more detail in the coming chapters.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>The rest of the directory structure</span></h3>

  <p><span>Here are the remaining folders that are part of the AOSP:</span></p>

  <ul>
    <li><code class="literal"><span>abi</span></code><span>: This is the source file for </span><code class="literal"><span>libgabi++</span></code><span>.</span></li>

    <li><code class="literal"><span>bootable</span></code><span>: This includes the boot and startup related code. Some of it is legacy, the fastboot protocol info could be interesting since it is implemented by boot loaders in a number of devices such as the Nexus ones.</span></li>

    <li><code class="literal"><span>cts</span></code><span>: This directory contains the code for the compatibility test suite.</span></li>

    <li><code class="literal"><span>dalvik</span></code><span>: This directory contains the code for the Dalvik virtual machine.</span></li>

    <li><code class="literal"><span>development</span></code><span>: This directory contains development tools—the source code of the SDK and the NDK.</span></li>

    <li><code class="literal"><span>docs</span></code><span>: This directory contains the documentation relative to the Android Open Source Project. It contains a subfolder called </span><code class="literal"><span>source.android.com</span></code><span>, which contains all the required files to generate the static HTML. You can see the result of the build at </span><a class="ulink" href="http://source.android.com/"><span>http://source.android.com/</span></a><span>.</span></li>

    <li><code class="literal"><span>Note</span></code><span>: This directory is the online version that often doesn't coincide with the one present in the AOSP.</span></li>

    <li><code class="literal"><span>hardware</span></code><span>: This folder contains HAL (Hardware Abstraction Layer), libraries that enable interfacing with the device hardware.</span></li>

    <li><code class="literal"><span>libcore</span></code><span>: This directory contains Apache Harmony.</span></li>

    <li><code class="literal"><span>ndk</span></code><span>: This directory contains the script to generate the Native Development Kit, that allows the use of the native code written in C/C++ from Android applications.</span></li>

    <li><code class="literal"><span>pdk</span></code><span>: This is the Platform Development Kit, a set of utilities that Google sends to various OEMs so that they can update their own frameworks before important system updates.</span></li>

    <li><code class="literal"><span>prebuilts</span></code><span>: This directory contains precompiled files, including various toolchain versions.</span></li>

    <li><code class="literal"><span>sdk</span></code><span>: This is the Software Development Kit.</span></li>

    <li><code class="literal"><span>tools</span></code><span>: These are some external IDE tools.</span></li>
  </ul>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Summary</span></h2>

  <p><span>In this chapter, we have learned lots of very important things that represent the basis of Android.</span></p>

  <p><span>We started with the Android philosophy regarding the licenses and the development model touching on different versions of Android that followed. We have learned to install and use the tools necessary to contribute to the AOSP project, and also how to download a copy of the AOSP source code, selecting the right TAG to get the wanted version of Android.</span></p>

  <p><span>In the next chapter, we will make the first build, generating an image for the emulator, but first we will explain how the Android build system works and what tools we need to install.</span></p>
</div>
		    </div>
		  </body></html>