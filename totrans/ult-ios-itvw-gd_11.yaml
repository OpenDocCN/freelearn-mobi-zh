- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI and Declarative Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was highly intensive. We discussed the most critical framework
    in iOS development besides **Foundation**.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is more than just discussing a framework – we will discuss an idea,
    a **programming paradigm**.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t approach a job interview today in iOS without a basic knowledge of
    declarative programming, a topic that was no more than “nice to have” a few years
    ago.
  prefs: []
  type: TYPE_NORMAL
- en: If you have gaps in your knowledge or limited experience, read this chapter
    thoroughly to fill that knowledge gap before you start your interview.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers these exciting topics in declarative programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a new era in the development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding declarative programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning states and observable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating SwiftUI views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expertise with the SwiftUI life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expertise with Combine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with a brief background about declarative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Entering a new era of development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI and Combine are not only interesting frameworks but also symbolize a
    new direction that Apple is leading us toward. This direction is not disconnected
    from the current industry standards, as we can observe from the presence of **React**,
    **Flutter**, and RxJava in the everyday work of many developers.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why I chose to dedicate a whole chapter to two frameworks that are
    still not widely used is that these two frameworks mark how iOS projects will
    look in the following decade.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t gained any experience with SwiftUI and Combine until now, the
    minimum you should do is understand the basic terms and concepts, which are part
    of the current chapter goal.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s go over the most critical concept – declarative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding declarative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declarative programming is a whole new programming paradigm that provides us
    with more readable and robust code. Declarative programming is not a new concept
    at all – in fact, we can find the roots of declarative programming 30–40 years
    ago. But only in the last decade has declarative programming gained popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to get into more detail about declarative programming by answering
    some questions we may encounter during an interview.
  prefs: []
  type: TYPE_NORMAL
- en: “What’s the difference between declarative programming and the “classic” programming
    paradigm, also known as imperative programming?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: If the workplace we interview for uses Combine or SwiftUI in its projects, we
    will probably have to answer some variant of this question. The reason is that
    the difference in how we approach code is so big that we cannot avoid restructuring
    our thoughts to answer that.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: In declarative programming, we *focus on the outcome and results of our code*.
    We observe changes and define precisely what the results would be on other objects
    and how data will be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: In imperative programming, we *focus on the steps that lead to* *our results*.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the difference doesn’t look clear. What does “focus on the
    results and not the steps” mean?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to explain that in code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a screen with a button (`UIButton`) and a text field (`UITextField`),
    and we want to enable or disable the button based on the text field input. Let’s
    see how we do that in imperative programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code should be straightforward, as we wrote this pattern hundreds of times
    while working with imperative programming. Connecting a delegate to a test field
    is common in iOS development. But look how unclear it is – when we set up the
    text field, we define *what function will be called* when the user changes the
    text, not what will happen. It means we focus on the steps and implementation,
    not the final result.
  prefs: []
  type: TYPE_NORMAL
- en: In the text field delegate function, we indeed update the `isEnabled` property
    of the button, but that piece of code is called in another function in another
    place, perhaps even in another file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a declarative approach to the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see a much clearer solution to enable a button
    based on a text field input. We observe the text field “editing changed” event,
    map the `isEmpty` property to another Boolean, and assign it to the button’s `isEnabled`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: This means we declare what happens when a particular value is changed without
    any control flows or delegates.
  prefs: []
  type: TYPE_NORMAL
- en: The two coding paradigms contrast significantly when dealing with more complex
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: “How does declarative programming help handle state management in iOS apps?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a strong relationship between declarative programming and state management.
    Before we answer that question, it is essential to understand what is considered
    a state and think about how you ever used a state in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a state is a condition of our app, screen, or view.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a state can be a Boolean variable that represents whether the user
    is logged in to your app. Another example of a state is whether a button should
    be visible.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that a state is something we all used in our apps before, and in
    declarative programming, the state is a primary topic.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Look at my last example – “whether a button should be visible.” It seems like
    a great idea to have a state for button visibility. The problem is that every
    time we change the state value, we must also ensure that the button is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to use a `didSet` property observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though a `didSet` property observer is a simple way to bind the state
    to button visibility, it’s not the ideal solution for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: A variable can only have one property observer,
    meaning we cannot separate different concerns or responsibilities. For instance,
    we cannot have one **didSet** block for analytics and another **didSet** block
    for UI updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not testable**: This relates to the previous point. Because the **didSet**
    block contains multiple actions, including possible UI changes, testing it can
    be challenging because it can have additional possible side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Can’t observe multiple variables**: It’s nice to observe one property, but
    what if we want to observe changes in numerous properties and perform one action
    based on that change? **didSet** is not suitable for that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, here’s the Combine example version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Combine version is a much more elegant way of handling a state. We bind
    the state to button enablement just like we did with the `didSet` example. But
    this time, we also earn more benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can observe the **buttonVisible** variable in *multiple places* for different
    purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use multiple instances of **buttonVisible** *along with* *more variables*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can perform *async operations* more efficiently and add sophisticated operators
    to the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative programming is suitable for handling states because it lets us explain
    precisely what to do each time the state changes, and that’s ideal for state management.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of states – let’s dive in and go over states in SwiftUI, as they play
    a significant role in screen updates and layout.
  prefs: []
  type: TYPE_NORMAL
- en: Learning states and observable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “States” is a primary topic in SwiftUI and declarative programming. Unlike imperative
    programming, where we can directly update UI elements on the screen, declarative
    programming *works in the opposite way* – we update the state, and the UI is updated
    according to our changes.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, using states is the only way to create dynamic views in SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI uses something called a property wrapper to mark certain variables as
    states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**@State**: To manage simple UI state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Binding**: To allow two directional updates between the view and its children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@ObservedObject**: To share data between views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@EnvironmentObject**: To share data between views across an app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When asked about SwiftUI, these different property wrappers play a significant
    role in understanding how SwiftUI works and building a full-featured app with
    SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read more about managing user interface state in SwiftUI, you
    can visit [https://developer.apple.com/documentation/swiftui/managing-user-interface-state](https://developer.apple.com/documentation/swiftui/managing-user-interface-state).
    For an overview of property wrappers, check out the link at [https://www.swift.org/blog/property-wrappers/](https://www.swift.org/blog/property-wrappers/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at two critical questions about that topic.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain the differences and use cases for the @State and @Binding property
    wrappers in SwiftUI?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: These two property wrappers are fundamental to understanding how SwiftUI works.
    Going back to the *Understanding declarative programming* section, `@State` and
    `@Binding` are pure implementations of the concept of declarative programming.
  prefs: []
  type: TYPE_NORMAL
- en: '`@State` and `@Binding` are essential wrappers to create complex and reusable
    views.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: '`@State` is a property wrapper used to manage local states within a view. It’s
    used for simple values managed by a single view, such as toggles or form data.
    When the value of a `@State` property changes, **SwiftUI** will automatically
    update the view to reflect the new state. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `toggleIsOn` variable is wrapped in `@State`, allowing the SwiftUI to observe
    and update `MyView` if needed. Within the view, there is `Toggle` that is linked
    to the `toggleIsOn` state. As the state value changes, a corresponding text is
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Binding` is a property wrapper that provides a two-way connection between
    the child’s and parent’s views. It’s used to pass the state down the view hierarchy,
    allowing child views to modify values stored in a parent view. When the value
    of a `@Binding` property changes, both the child and parent views will be updated
    to reflect the new state. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `MyParentView` manages the `toggleIsOn` state and passes it
    down to `MyChildView` using a `@Binding` property. `MyChildView` can then modify
    the state by updating the `toggleIsOn` property. Both views are automatically
    updated to reflect the new state when this happens.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `@State` and `@Binding` have a strong relationship. `@State`
    is `@Binding` of its child view. If we compare this to imperative programming
    with UIKit, the `@Binding` feature is similar to the delegate pattern we know
    and love but much more powerful, simple, and mainly declarative.
  prefs: []
  type: TYPE_NORMAL
- en: “What is the purpose of @ObservedObject in SwiftUI, and in what situations would
    you use it instead of @State or @Binding?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what `@State` and `@Bining` roles are in SwiftUI, we must understand
    how `@ObservedObject` fits into our app architecture and how it differs from other
    view property wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The `@ObservedObject` property wrapper in `@ObservedObject` will also automatically
    be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Can the observed object be a singleton? Definitely. More importantly, it should
    be the same instance we inject into the different views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at *Figure 8**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The role of an observed object in our app architecture](img/Figure_8.1_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The role of an observed object in our app architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.1* shows the different dependencies when using an observed object.
    It is an excellent practice to add more layers to our app that manage stuff such
    as persistent data and networking, and keep the observed object to share the data
    between the views.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a SwiftUI code example of a contacts list with the observed object.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the contacts list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the contacts list uses an observed object named `viewModel`
    that can be injected into the view or used as a `@ObservedObject` is that SwiftUI
    doesn’t recreate it whenever it needs to refresh the view, so it can safely store
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see what the `ContactViewModel` class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important things to note in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conforming to the** **ObservableObject** **protocol**: If we want the class
    to be an observed object, we need it to conform to the **ObservableObject** protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using** **@Published** **for the contacts list**: The contacts list variable
    has a **@Published** property wrapper, which lets the view observe changes in
    the contacts list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataLayer as a dependency**: To adhere to the separation of concerns principle,
    we separate the actual fetching and storing from the sharing class. The only responsibility
    of the **ContactViewModel** class is to share data between views. The **ContactDataLayer**
    class does the persistent operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, `ObservedObject` is a mechanism that facilitates data sharing
    among views. It is easy to grasp and incorporate and can help divide a project’s
    structure into distinct layers.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating SwiftUI views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigation in mobile apps was always a critical issue. UIKit supported navigation
    from day one, and SwiftUI launched with essential support from `NavigationView`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation in SwiftUI is quite different than UIKit. While in UIKit, we had
    to create a new view controller and push it to a stack using `UINavigationController`,
    in SwiftUI, it works slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed declarative programming earlier in this chapter? This
    is how navigation works in SwiftUI. Instead of creating and pushing a new view,
    we use the state to present sheets, modals, and links to navigate to a new view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to present a modal view using state modification in SwiftUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a state variable called `isModalPresented`. When a
    user taps the `Present Modal` button, we set `isModalPresented` to `true`, which
    triggers the view modifier `ModalView`.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting a modal using a state may feel weird for developers who worked years
    with imperative programming, but this pattern fits naturally into declarative
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to some interesting questions about SwiftUI navigation.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you pass data between views using the SwiftUI navigation system?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Passing data between views is critical to implementing an effective navigation
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: And this is not a trivial question – other patterns enable us to navigate to
    a new view without passing data. We can use the observed object pattern, which
    we reviewed in the previous section, or we can use some global state manager to
    understand what data to present.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is considered a best practice to pass data to a new screen for better
    separation and modularity.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that there are no tricks here that we don’t already know from
    other patterns in UIKit.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to pass data between views is to *inject the data when initiating
    the* *new view*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a screen with a list of countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create `CountryDetailView` with the `country` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `CountryDetailView` struct has a property named `country`. In Swift, the
    compiler automatically generates a member-wise initializer for their properties.
    We use that to pass the `country` object when initializing `CountryDetailView`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it is straightforward to pass data between views just by using
    dependency injection. We can also evaluate that pattern and pass a state on one
    side and a binding on the next view to create a two-directional update between
    the two views, such as a delegate pattern in UIKit.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how to use @Environment(\.presentationMode) to dismiss a presented
    view in SwiftUI navigation?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Using `NavigationLink` to move to a new place is easy, but how do we dismiss
    or navigate back?
  prefs: []
  type: TYPE_NORMAL
- en: This question tests our understanding of navigation and a property wrapper called
    `@Environment`, which can expose environment variables that provide more capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Environment(\.presentationMode`) is a property wrapper that provides access
    to a view’s presentation mode, allowing us to dismiss a presented view in SwiftUI
    navigation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use `@Environment(\.presentationMode)` to dismiss
    a presented view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have `DetailView` currently presented on the screen. We
    use the `@Environment(\.presentationMode)` property wrapper to access the view’s
    presentation mode.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user taps the `presentationMode` to dismiss the function, which takes
    us back to the previous screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if the view is not currently presented, we’ll get a runtime error
    trying to do that. Therefore, if we are not sure whether the view is presented
    before we dismiss it, we can check using the same presentation mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, the **Dismiss** button appears only if the view is presented,
    and since it’s declarative, it will be hidden when it’s not.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation is a crucial component of any mobile app, and in a way, it becomes
    even more straightforward with SwiftUI. The preceding two questions should be
    enough for us to prepare for this part of the interview.
  prefs: []
  type: TYPE_NORMAL
- en: Expertise with the SwiftUI life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can’t build UI screens without fully understanding the UI life cycle. States
    and modifiers such as `onChange` and `onAppear` are integral to the SwiftUI life
    cycle and essential to building a functional application.
  prefs: []
  type: TYPE_NORMAL
- en: We already went on some of the things related to the SwiftUI life cycle in the
    previous sections – for example, observed objects and states are part of the SwiftUI
    life cycle. Now, we must understand how they work when a view needs to reload,
    change, or move to a new screen.
  prefs: []
  type: TYPE_NORMAL
- en: “How does SwiftUI handle state changes during the view life cycle?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI’s approach to state management differs from traditional UIKit or AppKit
    approaches, and it’s crucial to understand how SwiftUI handles state changes and
    updates to avoid unexpected behavior in our app.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI generates the view hierarchy based on the current state. SwiftUI generates
    a new view hierarchy whenever the state changes and compares it to the current
    displayed hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: This means that all the variables are regenerated each time, except for the
    property wrappers such as `@State` and `@Binding`. The comparison to the current
    view tells SwiftUI what views it needs to update to reflect the new state. SwiftUI
    applies the changes to the user interface by adding, removing, or updating current
    views.
  prefs: []
  type: TYPE_NORMAL
- en: This process is very efficient because SwiftUI only updates the parts of the
    user interface that need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps the button, it changes the `labelText` state. In this case,
    SwiftUI generates a new view with a new value for the label (`Text`) and compares
    it to the current view hierarchy. Since only `Text` was changed and the button
    stayed the same, SwiftUI will only update `Text` and won’t render the whole screen
    to keep it much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you use the onChange modifier in SwiftUI, and what state changes does
    it respond to?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question is important because it assesses our understanding of responding
    to state changes in SwiftUI. Responding to state changes is a fundamental aspect
    of building user interfaces in SwiftUI, and an `onChange` modifier is a key tool
    to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `onChange` modifier to respond to changes in a specific state variable.
    When applied to a view, the `onChange` modifier will execute a closure when the
    specified state variable changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this syntax, `stateVariable` is the name of the state we want to observe,
    and `newValue` is the new value of that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some use cases we can think of for the preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating a view’s layout in response to changes in a user’s input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the button color when it is tapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the layout in response to an environmental change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to changes in a data model and presenting a banner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to a new screen when networking loading has finished
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of the last use case – navigating to a new screen when network
    loading has finished and the model updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the code observes the `viewModel` detail property, and once
    it is populated, it navigates to a new view.
  prefs: []
  type: TYPE_NORMAL
- en: Expertise in Combine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already discussed declarative programming throughout this chapter, so now,
    let’s focus on the Combine framework for a second.
  prefs: []
  type: TYPE_NORMAL
- en: Apple introduced Combine in WWDC 2019 as part of the iOS 13 version. Combine
    is Apple’s response to other popular reactive frameworks, such as React and **RxSwift**.
  prefs: []
  type: TYPE_NORMAL
- en: The Combine framework helps developers build reactive applications with robust
    async operations and data updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main components in Combine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publishers**: A publisher is an object that emits a stream of values over
    time. Publishers can be thought of as a source of data, which can come from various
    sources, such as user input, network requests, or timers. Publishers can emit
    values of different types, such as integers, strings, or custom data types, and
    can emit an unlimited number of values or a finite number of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operators**: Operators are functions that can be used to transform, filter,
    or combine streams of values emitted by publishers. Operators can take one or
    more publishers as input and return a new publisher that emits transformed values.
    Some examples of operators are **map**, **filter**, **flatMap**, and **zip**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: A subscriber is an object that receives and processes values
    emitted by a publisher. Subscribers can be considered consumers of data, which
    can handle the values emitted by a publisher in various ways, such as printing
    to a console, updating a user interface, or storing in a database. A subscriber
    can receive values of different types, requesting a certain number of values or
    receiving an unlimited number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining publishers, operators, and subscribers, we can create powerful
    data streams between the different parts of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of Combine usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will demonstrate the different components in Combine, as
    previously described:'
  prefs: []
  type: TYPE_NORMAL
- en: We have two different publishers (**numbersPublisher** and **lettersPublisher**)
    that send different values over time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We *combine* these two publishers using the **combineLatest** operator, which
    returns a publisher with the two most updated values each time one of the publishers
    is updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then *map the values* to one string using the **map** operator, followed
    by a filter operator that returns only strings with more than 10 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **sink** method helps to *subscribe to the Combine stream* and print the
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This complex yet interesting Combine stream demonstrates all the different Combine
    components effectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read more about Combine basics and principles, you can visit
    [https://developer.apple.com/documentation/combine#](https://developer.apple.com/documentation/combine#).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to some questions about Combine.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you provide an example of how you would use Combine in an iOS app?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: The complex Combine example I just showed you is nice but not very practical,
    and it’s there only to explain Combine framework principles.
  prefs: []
  type: TYPE_NORMAL
- en: The real challenge is understanding where to implement Combine in our app architecture
    in a real-world use case.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine has many real-world use cases. Let’s name some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing *network requests* and handling data or errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating UI elements with *data bindings* or state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating *user input* and showing feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing *MVVM* or other architectural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with timers, notifications, *key-value observing*, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are requested to provide an example of where we would use Combine in
    our app, here’s one where we bind data to UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we observe the number of notifications and update
    the notifications button with the relevant image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In our code example, we can see an excellent binding between data and a specific
    UI element. This example can also be used for other examples – title updates,
    color changes, button visibility, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Binding data as a UI element is also an excellent technique in the *MVVM design
    pattern*, where we can bind a state between the view model and the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see a more complex example of how to use Combine – to fetch data
    from a network request and update a table view while using the MVVM design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchArticles()` function does most of the job while requesting data, mapping
    it, decoding it to the `articles` array, moving it to the main thread, and assigning
    the data to the `articles` `published` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the view controller, we bind the `articles` array to the table view by observing
    changes and reloading the data each time we get an update.
  prefs: []
  type: TYPE_NORMAL
- en: The last example shows how to use Combine to chain different operators to perform
    a network request, parsing, moving to the main thread, and handling errors in
    a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: I think these two examples represent many widespread use cases with Combine.
    We should learn them thoroughly, which will help us answer this question efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you debug a Combine stream?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: We already know that debugging is critical for developers, not only iOS developers.
  prefs: []
  type: TYPE_NORMAL
- en: Most of our experience with debugging as iOS developers revolves around imperative
    programming and standard code flows. On the other hand, Combine brings something
    different to the table, with new challenges in the debugging area.
  prefs: []
  type: TYPE_NORMAL
- en: In this question, the interviewer wants to hear how we handle Combine issues
    we may encounter in our job.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: We can debug Combine streams using Xcode built-in debugging tools, such as setting
    breakpoints, inspecting variables, and stepping through code execution.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Combine framework offers additional tools to help us debug. Let’s
    list two of them.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the console with print() and handleEvents()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `print` operator is a debugging tool that allows us to print the events
    that flow through a Combine pipeline. We can use it to visualize the data transformations
    and identify unexpected behavior or errors. The `print` operator can be placed
    at any point in the pipeline and will print all events that occur downstream of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates how to use the `print` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use the `print` operator to label the debug output with
    `"Debug:"`. This will help us distinguish the debug logs from any other output
    in the console. When we run this code, we will see the following output in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `handleEvents` operator is similar to the `print` operator, but instead
    of printing the events, it allows us to trigger side effects at specific points
    in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We can use it to perform actions such as logging, updating UI elements, or triggering
    notifications. The `handleEvents` operator can be placed at any point in the pipeline,
    and it will trigger the side effects for all events that occur downstream of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates how to use the `handleEvents` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the `handleEvents` operator, we can print each event separately and have
    complete control of our printing operations.
  prefs: []
  type: TYPE_NORMAL
- en: Including breakpoints in our stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Combine framework provides additional operators to generate breakpoints
    in our streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and primary operator is `breakpoint()`, which can help us pause a
    program at specific events, similar to `handleEvents()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we pause the program on completion or when the output is bigger
    than eight by returning `true` in the corresponding places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second breakpoint operator is `breakpointOnError()`, which pauses the program
    when any of the upstream publishers throws an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This example is simple – the `tryMap` operator throws an error. Therefore, the
    program will pause, thanks to the `breakpointOnError()` command.
  prefs: []
  type: TYPE_NORMAL
- en: Both `breakpoint()` and `breakpointOnError()` are great ways to pause a program
    when we need to perform deep Combine issue investigations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over critical topics in declarative programming, SwiftUI,
    and Combine. We discussed the SwiftUI life cycle, debugging Combine, real-world
    examples, navigation, and states. By now, we should be fully covered for our interview
    when asked about SwiftUI and Combine.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is a bit different. We will discuss a critical layer in our
    architecture – the data layer and, specifically, the persistent data layer.
  prefs: []
  type: TYPE_NORMAL
