# 第10章. 利用过去 – 理解和翻译Objective-C

尽管苹果的平台已经存在很多年，但Swift仍然是一种非常新的语言。甚至在第一代iPhone发布之前，苹果首选的主要语言就是Objective-C。这意味着世界上有大量使用Objective-C在苹果平台上开发的应用资源。有许多令人惊叹的教程、代码库、文章等等，这些都是在Objective-C中编写的，对于Swift开发者来说仍然非常有价值。

为了利用这些资源，您至少需要具备Objective-C的基本理解，这样您才能将教程和文章中学到的概念翻译成Swift，并利用经过时间考验的Objective-C库。

在本章中，我们将通过以下主题来了解Objective-C的基础知识，并关注其与Swift的比较：

+   Swift与Objective-C的关系

+   Objective-C的背景

+   常量和变量

+   容器

+   控制流

+   函数

+   类型

+   项目

+   从Swift调用Objective-C代码

# Swift与Objective-C的关系

正如我们之前讨论的，Objective-C曾是开发苹果平台应用的主要语言。这意味着Objective-C对Swift产生了很大影响；其中最大的影响是Swift被设计成与Objective-C互操作。Swift代码可以调用Objective-C代码，同样，Objective-C代码也可以调用Swift代码。

Swift的设计初衷，并且仍在设计中，是为了成为编程语言的下一步，而不必丢弃我们所有的Objective-C代码。苹果对这种语言的目标是使Swift更加现代、交互式、安全、快速和强大。如果我们没有与Swift进行比较的基准，这些话将毫无意义。由于Swift主要设计用于苹果平台，这个基准在很大程度上是Objective-C。

# Objective-C的背景

在我们能够讨论Objective-C的细节之前，我们需要承认其历史。Objective-C基于一种被称为“C”的语言。C编程语言是第一种高度可移植的语言之一。可移植意味着相同的C代码可以被编译成在任何处理器上运行，只要有人为该平台编写一个编译器。在此之前，大多数代码都是用汇编语言编写的；这总是需要针对每个将要运行的处理器进行编写。

C通常被称为过程式编程语言。它基于一系列相互调用的函数的概念。它提供了非常基本的创建自定义类型的支持，但没有内置的对象概念。Objective-C被开发为C的面向对象扩展。正如Swift与Objective-C向后兼容一样，Objective-C也与C向后兼容。实际上，它只是在C的基础上添加了一些新的语法和内置库，以实现面向对象的功能。

真正重要的是苹果开发了他们当前的 API：Cocoa 和 Cocoa Touch，用于 Objective-C。这是 Objective-C 仍然对我们作为 Swift 开发者来说非常相关的一个最大原因。尽管我们主要编写 Swift 代码，但我们仍然会定期与用 Objective-C 编写的 Cocoa 和 Cocoa Touch 库进行交互。

# 常量和变量

现在，我们准备深入探讨 Objective-C 语言的基础知识。Objective-C 中的常量和变量与 Swift 非常相似，但它们的声明和工作方式略有不同。让我们来看看在 Swift 和 Objective-C 中如何声明一个变量：

[PRE0]

第一行应该看起来很熟悉，因为它是 Swift 语法。Objective-C 版本实际上并没有太大的区别。重要的区别在于变量的类型是在名称之前而不是之后声明的。还应注意，Objective-C 没有类型推断的概念。每次声明变量时，都必须给它指定一个特定的类型。你还会看到在名称后面有一个分号。这是因为 Objective-C 中的每一行代码都必须以分号结束。最后，你应该注意到我们没有显式地将 `number` 声明为变量。这是因为除非明确指定，否则 Objective-C 中假设所有信息都是变量。为了将 `number` 定义为常量，我们将在其类型之前添加 `const` 关键字：

[PRE1]

Objective-C 有值类型和引用类型，就像 Swift 一样。然而，在 Objective-C 中，它们之间的区别更具有概念性。

## 值类型

我们上面声明的数字在这两种语言中都是值类型。如果将它们传递给另一个函数，它们会被复制，并且不能有多个变量引用相同的实例。

实际上，在 Objective-C 中确定变量是值类型还是引用类型更容易，因为我们将会看到，几乎所有的引用类型都是用星号 (`*`) 声明的。如果有星号，你可以安全地假设它是一个引用类型。

## 引用类型

Objective-C 实际上允许你通过添加一个星号来将任何类型转换为引用类型：

[PRE2]

这声明了一个指向数字变量的引用，更常见的是称为 **指针**。在指针声明中，星号应该始终位于类型之后和名称之前。

在 Objective-C 中，引用类型实际上与 Swift 中的可选概念松散地混合在一起。所有引用类型都是可选的，因为指针可以始终指向 nil：

[PRE3]

指针也可以始终检查 nil：

[PRE4]

要访问引用的值，你必须取消引用它：

[PRE5]

你可以通过在指针前添加一个星号来取消引用它。

这就是 Swift 中指针与可选类型相似的地方。区别在于在 Objective-C 中无法声明非可选的引用类型。每个引用类型在技术上都可以是 nil，即使你设计它永远不会是 nil。这通常会增加很多不必要的 nil 检查，意味着你编写的每个接受引用类型的函数都应该处理 nil 的情况。

最后，这两种语言中引用类型的另一个区别是，Objective-C 在指针引用的类型上不是很严格。例如，如果我们在 `int` 指针指向相同的东西上创建一个新的双引用，Objective-C 不会抱怨：

[PRE6]

现在，我们有两个变量：`number` 和 `another`；它们指向相同的值，但假设它们是不同类型的。其中之一显然是错误的，但如果你尝试，Objective-C 会愉快地尝试将相同的值用作 `double` 和 `int`。这正是 Swift 通过设计使其不可能的一个错误。

到目前为止，我们查看的所有 Objective-C 代码实际上都是严格的 C 语言。我们没有使用 Objective-C 添加到 C 中的任何功能。Objective-C 添加到 C 中的主要事情是其类系统。

让我们看看我们的第一个实际的 Objective-C 类型 `NSString` 与 Swift 的 `String` 类型进行比较：

[PRE7]

就像在 Swift 中一样，你可以使用双引号创建一个字符串实例；然而，在 Objective-C 中，你必须在其前面放置一个 `@` 符号。

在 Objective-C 类系统中有一个重要的事情要记住，那就是无法创建一个值类型的类的实例。所有实例都必须通过引用类型来引用。我们不能创建一个普通的 `NSString`。它必须始终是一个 `NSString*` 指针。

# 容器

Objective-C 与 Swift 具有完全相同的核心容器，有两个例外：它们的命名略有不同，并且由于 Objective-C 中所有类型都必须是引用类型的基本要求，Objective-C 中的所有容器都是引用类型。

## 数组

在 Objective-C 中，数组被称为 `NSArray`。让我们看看 Swift 和 Objective-C 中数组的初始化是如何并排进行的：

[PRE8]

我们定义了一个名为 `array` 的变量，它是对 `NSArray` 类型的引用。然后我们将其分配给一个新的 `NSArray` 实例。Objective-C 中的方括号表示法允许我们在类型或实例上调用方法。每个单独的调用总是包含在单个方括号集中。在这种情况下，我们首先在 `NSArray` 类上调用 `alloc` 方法。这返回一个新分配的变量，其类型为 `NSArray`。

与 Swift 不同，Objective-C 需要两步过程来初始化一个新的实例。首先，必须分配内存，然后必须初始化。分配意味着我们为该对象预留内存，初始化意味着我们将它设置为默认值。这就是我们在第二行所做的事情。第二行要求实例初始化自己。我们将数组重新赋值为对 `init` 调用的结果，因为 `init` 可能返回 nil。请注意，我们没有解引用 `array` 变量来对其调用方法。我们实际上是在指针上直接调用方法。

现在，使用两行来初始化一个新的实例有点浪费，所以通常会将调用链式连接起来：

[PRE9]

这会在 `NSArray` 上调用 `alloc`，然后立即在 `alloc` 的结果上调用 `init`。然后，`array` 变量被分配给 `init` 调用的结果。请注意，`alloc` 可能返回 nil，在这种情况下，我们将对 nil 调用 `init`。在 Objective-C 中这是可以的；如果你在 nil 上调用方法，它将简单地总是返回 nil。这与 Swift 中的可选链式调用类似。

除了调用 `alloc` 和 `init` 之外，还有一个简单的替代方法，那就是使用 `new`：

[PRE10]

这个类方法同时分配和初始化实例。当你没有向 `init` 传递任何参数时，这很棒，但当你向其中传递参数时，你仍然需要单独调用 `alloc`。我们将在稍后看到这个例子。

你可能已经注意到，我们没有指定这个数组应该包含什么类型。这是因为实际上这是不可能的。在 Objective-C 中，只要不是 C 类型，所有数组都可以包含任何类型的混合。这意味着 `NSArray` 不能包含 `int`（而是使用 `NSNumber` 类），但它可以包含任何混合的 `NSStrings`、`NSArrays` 或其他 Objective-C 类型。编译器不会为你进行任何形式的类型检查，这意味着我们可以编写期望数组中包含错误类型的代码。这是 Swift 使之不可能的另一种错误分类。

那么，我们如何向我们的数组中添加对象呢？实际上，`NSArray` 类不允许我们向其中添加或删除对象。换句话说，`NSArray` 是不可变的。相反，有一个名为 `NSMutableArray` 的数组版本，允许我们添加和删除对象。然后我们可以使用 `addObject:` 方法：

[PRE11]

Objective-C 和 Swift 中的方法命名方式相同，冒号用于表示每个参数。在 Objective-C 中，冒号也用于调用方法，以表示以下代码是传递给方法的值。

纯粹的`NSArray`的存在是为了与Swift中的常量数组实现相同的基本目的。实际上，我们将看到所有Objective-C容器都被分为可变和不可变版本。可变容器可以被传递到方法中，并像不可变版本一样处理，通过不允许不想要的代码修改数组来增加一些安全性。

现在，要访问`NSArray`中的值，我们有两种选择。完整的方式是使用`objectAtIndex:`方法：

[PRE12]

我们也可以使用方括号，类似于Swift：

[PRE13]

注意，我们只是假设从数组返回的类型是`NSString`。我们同样可以假设它是另一种类型，比如`NSArray`：

[PRE14]

如我们所知，这将是不正确的，并且几乎肯定会在代码的后期引发错误，但编译器不会抱怨。

最后，要从可变数组中删除对象，我们可以使用`removeObjectAtIndex:`方法：

[PRE15]

你需要了解的另一个重要特性是，Objective-C也有数组字面量，因此你不必动态构建它们：

[PRE16]

数组字面量以`@`符号开头，就像字符串一样，但随后它由方括号内的对象列表定义，就像Swift一样。

数组可以做很多事情，但你应该能够在看到每个方法时理解它所做的是什么，因为大多数方法命名得很好。这些方法在每种语言中通常都有相同的名称，或者你可以在网上查找，苹果公司有广泛的文档。本章的目的是让你对Objective-C代码有一个足够高的层次理解。

## 字典

按照与数组相同的模式，Objective-C中的字典被称为`NSDictionary`和`NSMutableDictionary`。字典的初始化方式与所示完全相同：

[PRE17]

要设置一个值，我们使用`setObject:forKey:`方法：

[PRE18]

就像数组一样，我们无法在不可变字典上设置新对象。此外，这是我们第一个需要多个参数的方法的例子。正如你所看到的，每个参数都包含在方括号内，但由空格和该参数的标签分隔。在这种模式中，Objective-C方法可以有多个参数。

现在要访问一个值，我们可以使用`objectForKey:`方法或再次使用方括号：

[PRE19]

再次强调，我们假设返回的结果是一个字符串，因为我们知道我们刚刚放入字典中的内容。这种假设并不总是安全的，我们还需要始终意识到，如果该键不存在对象，此方法将返回nil。

最后，要删除对象，我们可以使用`removeObjectForKey:`方法：

[PRE20]

这一切相对简单明了，尤其是在阅读代码时。这种冗长性一直是Objective-C编写可理解代码的伟大特性，并且这一特性也被明确地继承到了Swift中。

字典也有字面量，但与 `NSArrays` 和 Swift 数组字面量不同，Objective-C 中的字典字面量使用花括号声明。否则，它看起来与 Swift 非常相似：

[PRE21]

再次强调，我们必须以 `@` 符号开始我们的字面量。我们还可以看到，只要我们在每个数字前加上 `@` 符号，我们就可以在我们的容器中使用数字作为对象。这不像创建一个 `int` 类型，而是创建一个 `NSNumber` 实例。你不需要了解太多关于 `NSNumber` 类的信息，除了它是一个表示许多不同形式的数字的对象类。

# 控制流

Objective-C 与 Swift 有许多相同的控制流范式。我们将快速浏览每个，但在我们这样做之前，让我们看看 Objective-C 中 `print` 的等价物：

[PRE22]

我们不是使用 `print`，而是使用一个名为 `NSLog` 的函数。Objective-C 没有字符串插值，所以 `NSLog` 是一个比 `print` 稍微复杂一些的解决方案。`NSLog` 的第一个参数是一个描述要打印格式的字符串。这包括每个我们想要记录的信息的占位符，它指示应该期望的类型。每个占位符都以百分号符号开始。在这种情况下，我们使用 at 符号来指示我们将在字符串中替换的内容。初始格式之后的每个参数都将按照传入的顺序替换占位符。这里，这意味着它最终会记录 **Hello Sarah**，就像 Swift 代码一样。

现在，我们已经准备好查看 Objective-C 中不同的控制流方法了。

## 条件语句

在 Swift 和 Objective-C 中，条件语句看起来几乎完全相同，只是在 Objective-C 中需要括号：

[PRE23]

你也可以在 Swift 中包含那些括号，但它们是可选的。在这里，你还可以看到 Objective-C 仍然有点语法来调用某些方法的概念。在这种情况下，我们使用了 `invitees.count` 而不是 `[invitees count]`。这只有在访问实例的属性或调用不带参数且返回某些内容的方法时才是可选的，就像它是一个计算属性一样。

## 开关

Objective-C 中的 `switch` 与 Swift 中的 `switch` 相比，功能要弱得多。实际上，`switch` 是严格 C 的一个特性，并且 Objective-C 并没有对其进行任何增强。`switch` 不能像一系列条件语句那样使用；它只能用于进行相等比较：

[PRE24]

再次强调，在 Objective-C 中需要括号，而在 Swift 中则是可选的。与 Objective-C 中的 `switch` 相比，最重要的区别是默认情况下，一个 case 会流入下一个，除非你明确使用 `break` 关键字来退出 `switch`。这与 Swift 相反，Swift 中只有在使用 `fallthrough` 关键字时才会流入下一个 case。在实践中，这意味着绝大多数 Objective-C 的 `switch` case 都需要以 `break` 结尾。

Objective-C 的 switch 语句功能不足以让我们为一系列值创建情况，当然也不能像 Swift 那样测试一系列任意条件。

## 循环

就像条件语句一样，Objective-C 中的循环与 Swift 非常相似。while 循环完全相同，只是需要括号：

[PRE25]

for-in 循环略有不同，在这个循环中，你必须指定你正在遍历的变量的类型，如下所示：

[PRE26]

你可能也注意到了，当我们遍历 Objective-C 中的 `NSDictionary` 时，你只能得到键。这是因为 Objective-C 中不存在元组。相反，你必须使用键作为遍历的依据来从原始字典中访问值。

Objective-C 缺失的另一个特性是范围。为了遍历一系列数字，Objective-C 程序员必须使用一种不同的循环，称为 `for` 循环：

[PRE27]

这个循环由三部分组成：一个初始值，一个运行条件，以及每次循环后要执行的操作。这个版本与 Swift 版本一样，循环遍历数字 1 到 10。显然，仍然可以将 Swift 代码翻译成 Objective-C；只是它并不那么简洁。

即使有这个限制，你仍然可以看出，Objective-C 和 Swift 的循环几乎相同，只是需要括号。

# 函数

到目前为止，我们已经调用了一些 Objective-C 函数，但还没有定义它们。让我们看看我们在 [第 2 章](ch02.html "第 2 章。构建块 – 变量、集合和流程控制")，*构建块 – 变量、集合和流程控制*中定义的函数的 Objective-C 版本。

我们最基本的函数定义没有接受任何参数，也没有返回任何内容。Objective-C 版本看起来类似于以下代码：

[PRE28]

Objective-C 函数总是以函数返回的类型开头，而不是 `func` 关键字。在这种情况下，我们实际上并没有返回任何内容，所以我们使用 `void` 关键字来表示。

接受参数并返回值的函数在这两种语言之间有更大的差异：

[PRE29]

再次强调，Objective-C 版本在函数开始处就定义了返回类型。同样，与变量一样，函数的参数必须在名称之前而不是之后定义其类型。然而，其余部分相当相似：参数包含在括号内，并用逗号分隔；函数的代码包含在大括号内，我们使用 `return` 关键字来指示我们想要返回的内容。

这种特定的实现实际上提出了处理Objective-C中数组的一个有趣的要求。就像我们希望在Swift中避免可变数组一样，我们通常也希望在Objective-C中避免它们。在这种情况下，我们仍然不想修改传入的数组，我们只想将新邀请者添加到复制的版本末尾。在Swift中，因为数组是值类型，复制是自动进行的，我们可以使用加法运算符来添加新邀请者。在Objective-C中，我们需要显式地复制数组。更重要的是，我们需要这个复制是可变的，这样我们才能向其中添加新邀请者。

所有这些加在一起，Swift函数和Objective-C方法之间最大的区别是返回值的定义位于参数的开始或结束位置。两种语言都以相同的方式处理内存。当在Objective-C中传递指针时，指针本身被复制，但两个版本都将引用同一个实例。当值类型在Swift中传递给函数时，值被简单地复制，之后两个版本之间没有任何关系。

# 类型

Objective-C中的类型系统比Swift稍微复杂一些。这是因为Objective-C中的结构和枚举来自C语言。只有类和类别来自Objective-C的扩展。

## 结构

在Swift中，结构与类非常相似，但在Objective-C中，它们差别很大。Objective-C中的结构本质上只是给一组单独的类型命名的一种方式。它们不能包含方法。甚至更为严格的是，结构不能包含Objective-C类型。这让我们只剩下基本的可能性：

[PRE30]

Objective-C中的结构以关键字`typedef`开始，它是类型定义的简称。然后是`struct`关键字，以及包含在花括号内的结构的不同组成部分。最后，在花括号之后是结构的名称。

高级C程序员会更多地使用结构。有一些方法可以模拟继承的一些功能，以及进行其他更高级的操作，但这超出了本书的范围，并且在大多数现代编程项目中并不相关。在Apple的API中，有一些类型是结构，比如CGRect，所以你应该知道如何与之交互，但在查看Objective-C资源时，你很可能不需要处理自定义结构定义。

## 枚举

枚举在Objective-C中也非常受限。它们实际上只是一个简单的机制，用于表示一系列相关的可能值。这允许我们仍然表示可能的基本颜色：

[PRE31]

就像结构一样，Objective-C枚举以关键字`typedef`开始，然后是`enum`，定义的末尾是名称。每个情况都包含在花括号内，并用逗号分隔。

注意，枚举的每个情况都以枚举的名称开头。这是一个非常常见的约定，使得代码补全变得容易，并显示枚举的所有可能值。这是因为Objective-C中，你不能通过枚举本身的名称来指定特定的枚举值。相反，每个情况都是其自己的关键字。这就是为什么当我们把`color`变量赋值为蓝色时，我们只使用情况名称本身。

Objective-C中的枚举不能有方法、关联值或表示任何其他值，除了整数。实际上，在Objective-C枚举中，每个情况都有一个数值。如果你没有指定任何值，它们从`0`开始，每个情况增加`1`。如果你想的话，你可以手动指定一个或多个情况的值：

[PRE32]

在手动指定的情况之后，每个情况将继续增加一个。这意味着在前面代码中`PrimaryColorRed`仍然是`0`，但`PrimaryColorBlue`是`11`。

## 类

与Objective-C的结构体和枚举不同，类与它们的Swift对应物非常相似。Objective-C类可以包含方法属性，使用继承，并且可以初始化。然而，它们看起来相当不同。最值得注意的是，Objective-C中的类分为两部分：其接口和其实现。接口旨在成为类的公共接口，而实现包括该接口的实现以及任何其他私有方法。

### 基本类

让我们再次看看[第3章](ch03.html "第3章。一次一个部分 – 类型、作用域和项目")中的联系人类，*一次一个部分 – 类型、作用域和项目*，以及它在Objective-C中的样子：

[PRE33]

已经有很多行Objective-C代码了。首先，我们有接口声明。它从`@interface`关键字开始，以`@end`关键字结束。方括号内是一个属性列表。这些属性本质上与结构体的属性相同，只是你可以在属性中包含Objective-C对象。这些属性通常不会这样写，因为使用属性会自动创建它们，就像我们稍后将要看到的那样。

你还会注意到，我们的类是从名为`NSObject`的类继承的，正如`: NSObject`所示。这是因为Objective-C中的每个类都必须继承自`NSObject`，这使得`NSObject`成为最基本的类形式。然而，不要被“基本”这个词所迷惑；`NSObject`提供了很多功能。我们在这里不会深入探讨，但你至少应该知道这一点。

类的另一个部分是实现。它以 `@implementation` 关键字开始，后面跟着我们要实现的类名，然后以 `@end` 关键字结束。在这里，我们没有实际上为我们联系人类添加任何额外的功能。然而，你可能注意到我们的类缺少 Swift 版本中存在的东西。

### 初始化器

Objective-C 不允许为任何属性或属性指定默认值。这意味着我们必须实现一个设置默认值的初始化器：

[PRE34]

在 Objective-C 中，初始化器与一个方法完全相同，只是按照惯例它们以 `init` 为名开头。这实际上只是一种惯例，但很重要，因为它会在内存管理和与 Swift 代码交互时引起后续问题。

开头带有减号的符号表示这是一个方法。接下来，在括号内指定返回类型，然后是方法名：在这种情况下是 `init`。方法体包含在类似于函数的大括号内。

所有初始化器的返回类型都将是 `id`，这是惯例。这使我们能够轻松地覆盖子类的初始化器。

几乎所有初始化器都将遵循这种相同的模式。就像在 Swift 中一样，`self` 引用被调用的实例。第一行通过调用父类的初始化器 `[super init]` 将 `self` 引用赋值给结果。然后我们允许初始化器失败并返回 nil 的可能性，通过在 `if (self)` 语句中测试它是否为 nil。如果 `self` 为 nil，则 `if` 语句将失败。如果不是 nil，我们分配默认值。最后，我们返回 `self`，以便调用代码可以维持对新初始化对象的引用。然而，这只是一个惯例，Objective-C 没有任何保护措施来确保属性被正确初始化。

### 属性

Objective-C 版本的联系人类仍然不完全像 Swift 版本，因为 `firstName` 和 `lastName` 属性无法从类外部访问。为了使它们可访问，我们需要将它们定义为公共属性，并可以将它们从显式属性中删除：

[PRE35]

注意，属性是在大括号之外但仍在 `@interface` 内定义的。实际上，如果你没有要定义的内容，你可以完全省略大括号。属性会自动生成同名的属性，但名称前有一个下划线：

[PRE36]

或者，你可以直接使用 `self` 来设置值：

[PRE37]

每种方法都有其细微差别，但仅就一般阅读目的而言，使用哪一种并不重要。

同样，正如你可以在 Swift 中定义弱引用一样，你可以在 Objective-C 中这样做：

[PRE38]

如果你愿意，你可以用 `strong` 替换 `weak`，但就像 Swift 一样，所有属性默认都是强引用。Objective-C 中的弱引用如果引用的对象被释放，将自动设置为 nil。你还可以使用 `unsafe_unretained` 关键字，它在 Swift 中相当于 `unowned`。然而，这很少被单独使用，因为在 Objective-C 中，`unsafe_unretained` 不会将值重置为 nil；相反，如果对象被释放，它将引用一个无效的对象，如果使用它，可能会导致混淆的崩溃。

除了 `weak` 或 `strong` 之外，你还可以指定属性是 `readonly` 或 `readwrite`：

[PRE39]

每个属性属性应该写在括号内，用逗号分隔。正如 `readonly` 名称所暗示的，这使得属性可读但不能写入。每个属性默认都是读写，所以通常不需要包含它。

注意，你可能会在括号中看到关键字 `nonatomic`。这是一个更高级的话题，超出了本书的范围。

### 方法

我们已经看到了一个初始化器形式的示例方法，但让我们看看一些带有参数的方法：

[PRE40]

每个参数都通过一个冒号后的公共标签定义，括号内是其类型，以及一个内部名称。然后，每个参数通过空格或换行符分隔。

你还可以看到一种格式化长方法调用的示例，即创建 `newString` 实例。类似于 Swift，任何空格都可以转换为换行符。这允许我们将单行转换为多行，只要我们不在部分行后放置分号。

就像 Swift 一样，Objective-C 也具有类方法的概念。类方法用加号而不是减号表示：

[PRE41]

因此，现在你可以直接在类上调用该方法：

[PRE42]

### 继承

就像我们迄今为止的所有类都继承自 `NSObject` 一样，任何类都可以像 Swift 一样继承自任何其他类，并且所有相同的规则都适用。方法和属性从其超类继承，你可以在子类中覆盖方法。然而，编译器对规则的强制程度较低。编译器不会强迫你指定你的方法意图覆盖另一个方法。编译器不会对初始化器和它们调用的对象施加任何规则。然而，所有这些约定都存在，因为这些约定是 Swift 要求的灵感来源。

## 类别

Objective-C 中的类别就像 Swift 扩展一样。它们允许你向现有类添加新方法。它们看起来与普通类非常相似：

[PRE43]

我们知道这是一个类别而不是普通类，因为我们已经在类名后面添加了一个括号内的名称。一个类上的每个类别都必须有一个唯一的名称。在这种情况下，我们将其称为 `Helpers`，并添加了一个返回联系人的全名的方法。

在这里，我们第一次在接口内部声明了一个方法。这也适用于类。方法定义看起来与实现完全相同，只是它以分号结束，而不是花括号内的代码。这将允许我们从当前文件外部调用该方法，正如我们将在即将到来的项目部分中更详细地看到的那样。

类别也可以添加属性，但你必须定义自己的获取器和设置器方法，因为就像Swift扩展不能添加存储属性一样，Objective-C类别也不能添加属性：

[PRE44]

这些类型的属性与计算属性非常相似。如果你需要允许从属性中读取，你必须实现一个具有完全相同名称的方法，该方法不接受任何参数并返回相同的类型。如果你想能够写入属性，你必须实现一个以`set`开头的方法，后面跟着以大写字母开头的相同属性名称，该方法接受属性类型作为参数并返回无值。这允许外部类以属性属性的方式与属性交互，尽管实际上它只是一组方法。同样，这可以在类或类别中实现。

## 协议

就像Swift一样，Objective-C也有协议的概念。它们的定义看起来类似于以下这样：

[PRE45]

在这里，我们使用`@protocol`关键字而不是`@interface`，并且它仍然以`@end`关键字结束。我们可以定义任何我们想要的属性或方法。然后我们可以说一个类实现了这个协议，类似于以下这样：

[PRE46]

一个类实现的协议列表应该列在它继承的类之后，用尖括号括起来，并用逗号分隔。在这种情况下，我们只实现了一个协议，所以不需要任何逗号。此代码还声明了一个`contents`属性，因此我们可以像下面这样实现协议：

[PRE47]

注意，我们在实现中并没有做任何特殊的事情来实现协议；我们只需要确保实现了正确的方法和计算属性。

你还应该注意的另一件事是，Objective-C中的协议并不像类那样使用。你不能仅仅定义一个变量为协议；相反，你必须给它一个类型，并要求它实现该协议。最常见的是使用`id`类型：

[PRE48]

任何变量声明都可能要求它不仅继承自特定类型，还实现某些协议。

## 块

最后，块是Objective-C中Swift闭包的替代品。实际上，它们是Objective-C的后期添加，因此它们的语法有些复杂：

[PRE49]

让我们分解一下。我们像任何其他变量一样开始，变量名和类型在等号之前。名称以第一个括号内的胡萝卜符号（`^`）开头。在这种情况下，我们将其称为 `doubleClosure`。闭包的实际类型包围着它。它开始的类型是闭包返回的类型，在这个例子中是 `int`。第二组括号列出了闭包接受的参数类型。总的来说，这意味着我们正在定义一个名为 `doubleClosure` 的闭包，它接受 `int` 并返回 `int`。

然后，我们转向实现闭包的业务。所有闭包实现都以胡萝卜符号开头，后面跟着括号内的任何参数，以及包含实际实现的括号。一旦定义了闭包，就可以像调用任何其他函数一样调用它。然而，你应该始终意识到闭包可能是 nil，调用它会导致程序崩溃。

还可以定义一个接受闭包作为参数的函数或方法。首先是一个函数：

[PRE50]

注意，类型 `id` 表示任何 Objective-C 对象，尽管它没有星号，但它是一个引用类型。上面的用法看起来与独立的代码块用法完全一样。然而，在方法中的语法看起来有些不同：

[PRE51]

这是因为一个方法的参数名称由括号分隔。这导致参数的名称从与胡萝卜符号一起移动到括号之后。最终，我们可以说，在阅读 Objective-C 代码并将其翻译为 Swift 时，只要认识到胡萝卜符号表示一个代码块，那么语法的细微差别并不太重要。许多 Objective-C 程序员会定期查阅代码块语法的细节。

在 Objective-C 中，与代码块相关的所有内存问题都存在。默认情况下，所有参数都是强引用捕获，而弱引用捕获的语法要复杂得多。你必须在代码块外部创建弱变量，并使用它们来捕获：

[PRE52]

在这里，我们使用关键字 `__weak`（有两个下划线）来表示 `weakBall` 变量应该只对 `ball` 有弱引用。然后我们可以在代码块内安全地引用 `weakBall` 变量，而不会创建循环引用。

# 项目

现在我们对 Objective-C 有了一个相当好的理解，让我们讨论一下项目中的 Objective-C 代码看起来是什么样子。与 Swift 代码不同，Objective-C 使用两种不同类型的文件编写。其中一种类型称为头文件，以扩展名 `h` 结尾。另一种类型称为实现文件，以扩展名 `m` 结尾。

在我们真正讨论两者之间的区别之前，我们首先必须讨论代码暴露。在Swift中，你写的所有代码都可以访问项目中的其他所有代码。在Objective-C中并非如此。在Objective-C中，你必须明确表示你想要访问另一个文件中的代码。

## 头文件

头文件是其他文件可以包含的文件类型。这意味着头文件应该只包含类型的接口。事实上，这就是为什么类接口和实现之间存在分离。任何文件都可以导入头文件，这实际上是将一个文件的代码插入到导入它的文件中：

[PRE53]

这允许我们将每个类单独放入自己的文件中，就像我们在Swift中喜欢做的那样。危险在于我们必须只将可以安全导入到头文件中的代码放入。如果你试图在头文件中放置实现，你将得到每次导入头文件时的重复实现。

在前面的例子中，我们实际上是将一个头文件导入到了另一个文件中。这意味着如果现在有另一个文件包含了这个头文件，它实际上会导入这两个头文件。

你还会注意到导入文件有两种不同的方式。我们使用尖括号导入基础文件，而使用引号导入我们的汽车头文件。尖括号用于从框架中导入头文件，而引号用于在同一个框架或应用程序中导入头文件。

很多的时间，一个头文件包含另一个头文件实际上并不是必要的，因为它只需要知道类的存在。如果它不需要知道类的任何实际细节，它可以使用`@class`关键字简单地指示类存在：

[PRE54]

现在，编译器不会抱怨它不知道`Car`是什么。然而，你很可能仍然需要在实现文件中导入汽车头文件，因为你很可能会与该类的一些部分进行交互。

## 实现文件

如你所猜到的，实现文件通常是用于你的类型的实现。这些文件不会被导入到其他文件中；它们只是履行接口文件定义的承诺。这意味着头文件和实现文件通常成对存在。如果你正在定义方向盘类，你很可能会创建一个`SteeringWheel.h`头文件和一个`SteeringWheel.m`实现文件。任何需要与方向盘类的细节进行交互的其他代码将导入头文件，在编译时，编译器将所有实现提供给运行程序。

实现文件也是一个很好的地方来隐藏私有代码，因为它们不能被其他代码导入。由于代码在其他任何地方都不可见，因此不太可能被交互。这意味着有时如果类的使用仅限于该文件，人们会向实现文件添加类接口。将所谓的匿名类别添加到实现文件中也是非常常见的：

[PRE55]

这被认为是匿名的，因为该类别实际上并没有被赋予一个名称。这意味着无法直接将实现与该类别配对。相反，实现应该在类的正常实现中定义。这为在实现文件顶部定义任何私有属性和方法提供了一个很好的方法。从技术上讲，你不需要定义任何私有方法，因为只要它们在同一个文件中实现，就可以进行交互。然而，通常在文件顶部有一个简洁的属性和方法列表会很好。

这又提出了另一个观点，即只有打算从外部文件使用的方法才应该在头文件中声明。你应该始终将头文件视为你类的公共接口，并且它应该尽可能简单。它总是从外部文件的角度来写。这是Objective-C实现访问控制的方式。它并没有正式地构建到语言中，但编译器会在你尝试与未导入的代码交互时发出警告。实际上，仍然可以与这些私有接口交互，特别是如果你在其他地方复制了接口声明，但被认为是一个最佳实践，不要这样做，并且苹果实际上会在审查期间拒绝你的应用程序，如果你尝试与它们的API的私有部分交互。

## 组织

除了明显的区别之外，Objective-C项目将有两种不同类型的文件。它们的组织方式与Swift文件完全相同。仍然被认为是一个好习惯，创建文件夹来将相关的文件分组在一起。大多数时候，你都会想将头文件和实现文件配对，因为人们会经常在这两种类型的文件之间切换。然而，人们也可以使用键盘快捷键*Control*/*Command*向上箭头或*Control*/*Command*向下箭头来快速在头文件和它的实现文件之间切换。

# 从Swift调用Objective-C代码

对于我们的目的来说，理解Objective-C的最后也是可能最重要的一个组成部分是能够从Swift调用Objective-C代码。在大多数情况下，这实际上是非常直接的。我们不会花时间讨论从Objective-C调用Swift代码，因为这本书假设你只编写Swift代码。

## 桥接头文件

能够从 Swift 调用 Objective-C 代码的最重要部分是如何让代码对 Swift 可见。正如我们所知，Objective-C 代码需要导入才能被其他代码看到。这一点在 Swift 中仍然适用，但 Swift 没有导入单个文件的机制。相反，当你将第一个 Objective-C 代码添加到 Swift 项目中时，Xcode 会询问你是否想要添加一个称为 **桥接头** 的文件：

![桥接头](img/B05103_10_01.jpg)

你应该选择 **是**，然后 Xcode 将自动创建一个以项目结尾名为 `Bridging-Header.h` 的头文件。这就是你需要导入任何想要暴露给 Swift 的 Objective-C 头文件的文件。它将只是一个包含导入列表的文件。你仍然不需要导入任何实现文件。

# 使用函数

在将头文件暴露给 Swift 之后，调用函数非常简单。你可以直接调用函数，就像它们没有参数名称一样：

[PRE56]

Xcode 甚至会为你自动完成代码。从你的 Swift 文件的角度来看，你无法知道该函数是在 Objective-C 中实现还是在 Swift 中实现。

## 使用类型

你可以使用类型的方式使用函数。一旦在桥接头文件中导入了适当的头文件，你就可以像使用 Swift 类型一样使用该类型：

[PRE57]

再次强调，从 Swift 的角度来看，我们编写使用 Objective-C 类的代码的方式与我们如果该类是在 Objective-C 中实现的方式之间绝对没有区别。我们甚至能够使用相同的参数名称调用 `addToInviteeList:includeLastName:` 方法。这使得更加清楚，Swift 是在设计时考虑了向后兼容性的。

唯一真正的限制是，所有在 Objective-C 中定义的类都将继承自 `NSObject`，并且 Objective-C 枚举不会完美地转换为 Swift 枚举。相反，它们仍然以单个常量的形式暴露出来：

[PRE58]

## 容器

你可能也注意到，`NSString` 和 `NSArray` 类型似乎在前面的代码中透明地转换为 `String` 和 `Array` 类。这是 Swift 和 Objective-C 之间桥接的另一个奇妙特性。这些类型，以及字典，几乎完美地转换。唯一的区别是，由于 Objective-C 在定义容器时确实需要一个元素类型，因此它们在 Swift 中被转换为包含 `AnyObject` 类型的对象。如果你想将它们视为更具体的类型，你必须进行类型转换：

[PRE59]

当此方法转换为 Swift 时，其实际返回值是 `[AnyObject]!`。因此，如果你确定该方法永远不会返回 nil 并且总是返回一个 `Strings` 数组，那么进行我们上面所做的那种强制转换是安全的。否则，你仍然应该检查 nil 并进行可选转换 (`as?`)。

## 注释

你会注意到，当 Objective-C 类型被转换为 Swift 时，这就像是一个模式。任何引用类型默认都会被转换为隐式解包的可选类型，这是由于 Objective-C 引用类型的特性。编译器无法自动知道返回的值是否可能为 nil，因此它不知道是否应该将其转换为常规可选类型或非可选类型。然而，Objective-C 开发者可以添加注释来让编译器知道一个值是否可能为 nil。

### 可空性

Objective-C 开发者首先可以为特定变量是否可以为 null 添加注释：

[PRE60]

`__nonnull` 关键字表示它不能为 nil，因此它将在 Swift 中被转换为非可选类型，而 `__nullable` 关键字表示它可以被 nil，因此在 Swift 中它将被转换为常规可选类型。

### 容器元素类型

Objective-C 开发者也可以注释他们的容器类型，以说明它们包含的类型。为此，使用与 Swift 一样的尖括号：

[PRE61]

现在，这个方法将真正像 Swift 方法一样工作，它将接受一个可选的字符串数组并返回一个非可选的字符串数组；将不需要进行类型转换：

[PRE62]

如果你控制着你要导入的 Objective-C 代码，那么你可能想要添加它。否则，你可能能够请求代码的开发者添加注释，以便让你的 Swift 编码更加容易和整洁。

# 摘要

虽然 Swift 目前是苹果开发社区中的热门新语言，但没有迹象表明 Objective-C 将被完全取代。苹果的所有 API 仍然是用 Objective-C 编写的，如果苹果想要重写它们，这将是一项巨大的工作。苹果肯定设计了 Swift 以能够与 Objective-C 并存，所以现在我们必须假设 Objective-C 将会持续存在。这使得理解和能够与 Objective-C 交互变得非常有价值，即使作为 Swift 开发者也是如此。

在本章中，我们从主要使用Swift开发者的角度概述了最相关的Objective-C特性和语法。我们了解到Swift基本上是演变语言长河的一部分。它受到了苹果希望使其与Objective-C向后兼容的强烈影响，而Objective-C实际上是C语言的一个演变，C语言又是汇编语言的一个演变，等等。Objective-C仍然是一种强大的语言，能够表达与Swift许多相同的概念。Objective-C有类似常量和变量的概念，但更侧重于变量。它也有相同的基本容器，但两种语言中的控制流略有不同。Swift有更强大的switch和ranges，但底层概念仍然非常相似。函数在这两种语言中几乎是相同的，但Objective-C的类型系统在某种程度上更为有限，因为它只能表达类，而Swift有强大的类、结构和枚举的概念。结构和枚举在Objective-C中仍然存在，但它们实际上直接来自C语言，并且可以做更少的事情。最后，我们看到了在项目中组织Objective-C的方式非常相似，并且从Swift调用Objective-C代码实际上相当直接。

在苹果开发者社区中，关于Objective-C在未来将有多大的相关性存在一些争议。有些人已经全职投入到Swift开发中，而有些人则在等待Swift更加成熟后再投入精力真正学习它。然而，关于Objective-C知识在一段时间内仍将保持相关性的事实，争议并不多，尤其是考虑到存在的大量资源和所有现有的苹果API都是用Objective-C编写的。我们将在下一章中利用这些API：[第11章](ch11.html "第11章. 一个全新的世界 – 开发一个应用"), *一个全新的世界 – 开发一个应用*，届时我们将最终深入到一些真正的应用开发中。
