- en: Chapter 7. The Importance of Being Lazy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 懒惰的重要性
- en: 'Another way of improving an application''s performance is by deferring the
    execution of code until the result is needed. This sounds very logical; the less
    the code we run, the less the time it will take. This design pattern is usually
    called **lazy**. There are many things that can be lazy, and there are many different
    ways in which we can defer code execution. We are going to cover the following
    topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 提高应用程序性能的另一种方法是推迟代码的执行，直到需要结果。这听起来非常合理；我们运行的代码越少，所需的时间就越少。这种设计模式通常被称为**懒惰**。有很多事情可以是懒惰的，也有很多不同的方法可以推迟代码执行。在本章中，我们将涵盖以下主题：
- en: The lazy mindset
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰的心态
- en: Lazy loading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载
- en: Lazy collections and evaluation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰集合和评估
- en: The lazy mindset
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰的心态
- en: First, it is very important to understand the lazy pattern, how it works, how
    it could benefit an application's performance, and when to use it. It's also very
    important not to abuse it, because that would make code more complex and hard
    to read. Plus, it would be hard to follow the execution flow. Also, abusing it
    would decrease the overall application's performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，理解懒惰模式的工作原理、它如何提高应用程序的性能以及何时使用它非常重要。同样重要的是不要滥用它，因为这会使代码更加复杂且难以阅读。此外，跟踪执行流程也会变得困难。滥用它还会降低应用程序的整体性能。
- en: The general idea of a lazy pattern is to defer the evaluation of an instruction
    until someone asks for the result of that instruction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰模式的一般思想是在有人请求该指令的结果之前，推迟对该指令的评估。
- en: In general, code is executed instruction by instruction, starting at the top
    of a file or a function. Nowadays, our applications are more complex and consist
    of many files, windows, libraries, components, and layers, but they still execute
    code in the same way. Because our system gets bigger and bigger, it's important
    to make them lazy so that we don't have to perform all the work when we start
    the application. Let's learn a few techniques for making code lazy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码是按指令顺序执行的，从文件的顶部或函数的开始处开始。如今，我们的应用程序更加复杂，由许多文件、窗口、库、组件和层组成，但它们仍然以相同的方式执行代码。由于我们的系统越来越大，使它们变得懒惰非常重要，这样我们就不必在启动应用程序时执行所有工作。让我们学习一些使代码变得懒惰的技术。
- en: Separation
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离
- en: 'It''s very important to separate code into components with a **single responsibility**
    pattern. A component should do only one thing and do it well. Let''s take a look
    at this simple example to understand how this could improve performance:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是将代码分离成具有**单一职责**模式的组件。组件应该只做一件事，并且要做好。让我们看看这个简单的例子，以了解这如何提高性能：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The problem with this code that the `analyze` function does two things. Because
    of that, the memory usage peak is twice as big. When we are done analyzing names,
    the memory used for it is not released immediately, but is kept until we return
    from the function. If we tried to analyze all of the population of England, it
    would require quite a lot of memory. By splitting them into separate functions,
    we can improve memory usage:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于`analyze`函数做了两件事。正因为如此，内存使用峰值是原来的两倍。当我们完成对名称的分析后，用于它的内存不会立即释放，而是保留到我们从函数返回。如果我们试图分析英格兰的全部人口，这将需要相当多的内存。通过将它们分成单独的函数，我们可以改善内存使用：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should apply a code separation technique very often to different components
    as an example. Make simple models and use only the data that you need for the
    current view. Splitting code into smaller components is useful, but you shouldn't
    split it into too small components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该经常将代码分离技术应用于不同的组件，例如。创建简单的模型，并仅使用当前视图所需的数据。将代码拆分为更小的组件是有用的，但你不应将其拆分得过于细小。
- en: Do work on demand
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需工作
- en: 'The main idea of lazy code is to do work only on demand. In this way, you can
    delay a code execution or remove it completely if no one asks for the result.
    When you are planning an application''s architecture, try to think about these
    questions: when would this resource or data be used in the application? Does it
    have to be instantiated now or can it wait? How often would this data be used?
    If often, then maybe you should cache it; if not, maybe you should load it lazily.
    Is the data heavy? Do you need to clean it afterward? Asking all of these questions
    helps you build a better application architecture with the *do work on demand*
    approach.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载代码的主要思想是仅在需要时才执行工作。这样，你可以在没有人请求结果的情况下延迟代码执行或完全删除它。当你规划应用程序的架构时，试着考虑这些问题：这个资源或数据在应用程序中何时会被使用？它现在必须实例化吗？还是可以等待？这份数据会被使用多频繁？如果经常使用，那么你可能应该缓存它；如果不经常使用，那么你可能应该懒加载它。数据是否很重？你需要在之后清理它吗？提出所有这些问题有助于你使用*按需工作*的方法构建更好的应用程序架构。
- en: Approximate results
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 近似结果
- en: Another idea is mixing lazy loading and asynchronous execution. If you want
    to perform an asynchronous task, because it takes a long time, but you would also
    like to get a result immediately, you can return an approximate result immediately
    and continue the execution. For example, the core data asynchronous fetching implements
    this pattern. It returns you an approximate number of items that will be fetched.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法是将懒加载和异步执行结合起来。如果你想执行一个异步任务，因为它需要很长时间，但你又想立即得到结果，你可以立即返回一个近似结果并继续执行。例如，核心数据异步获取实现了这个模式。它返回你将要获取的项目的大致数量。
- en: Lazy loading
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: The lazy loading pattern allows you to delay the creation of an object until
    you try to use it. This pattern can be implemented in any programming language.
    In Objective-C, we have used the property's getters and checked whether it was
    initialized. Swift adds support for lazy loading into the language, and this makes
    it even easier to apply this pattern. There are many things that can be lazy loaded,
    and we will cover them in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载模式允许你在尝试使用对象之前延迟创建对象。这种模式可以在任何编程语言中实现。在 Objective-C 中，我们使用了属性的获取器并检查它是否已初始化。Swift
    为语言添加了对懒加载的支持，这使得应用此模式变得更加容易。有许多东西可以被懒加载，我们将在本章中介绍它们。
- en: Global constants and variables
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局常量和变量
- en: 'Global variables and constants are always loaded lazily in Swift. This means
    that every global variable is initialized only when you access it for the first
    time. As a test, let''s create a new `Person.swift` file and add this code to
    it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，全局变量和常量始终是懒加载的。这意味着每个全局变量仅在第一次访问它时才被初始化。作为一个测试，让我们创建一个新的 `Person.swift`
    文件并将此代码添加到其中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This file contains two global constants: `Jon` and `Sam`. We have also added
    a log statement to the `Person` structure''s `init` method so that we can see
    when the person is created. Now let''s try to access one of the global constants
    and see the console output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含两个全局常量：`Jon` 和 `Sam`。我们还向 `Person` 结构体的 `init` 方法中添加了一个日志语句，这样我们就可以看到何时创建了这个人物。现在让我们尝试访问其中一个全局常量并查看控制台输出：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, only the `Jon` global constant is created, and it's created
    when we try to access its age property. Yes, global constants and variables have
    powerful features in Swift, but you should almost never use global constants!
    There is a better way to do that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有 `Jon` 全局常量被创建，并且是在我们尝试访问其年龄属性时创建的。是的，Swift 中的全局常量和变量具有强大的功能，但你几乎永远不应该使用全局常量！有更好的方法来做这件事。
- en: Global variables are even more vulnerable because anyone can change them in
    the entire application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量甚至更脆弱，因为任何人都可以在整个应用程序中更改它们。
- en: Type properties
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型属性
- en: Both structures and classes can have a `type` property. The `type` property
    belongs to the type itself and not to an instance of that type. Only one copy
    of a type property will be created no matter how many instances of that type you
    create. They behave like global variables and constants, but they have a namespace
    scope of that type. Also, type properties can be declared as private and be hidden
    from rest of the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体和类都可以有一个 `type` 属性。`type` 属性属于类型本身，而不是该类型的实例。无论你创建多少个该类型的实例，`type` 属性的副本都只有一个。它们的行为类似于全局变量和常量，但它们具有该类型的命名空间作用域。此外，类型属性可以声明为私有，并从应用程序的其余部分隐藏。
- en: 'We can very easily improve our code by moving our global constants into the
    `Person` struct definition:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将全局常量移动到 `Person` 结构定义中来非常容易地改进我们的代码：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To access a `type` property, we need to prefix it with a type name that it
    is declared in; to access the `Jon` type constant, we would need to write `Person.Jon`.
    Classes have the same syntax and functionality for type properties as structures:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`type`属性，我们需要在其前加上它声明的类型名称；要访问`Jon`类型常量，我们需要写`Person.Jon`。类与结构体在类型属性方面具有相同的语法和功能：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lazy properties
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载属性
- en: 'There is also a way to lazy load an instance property. Let''s extend our `Person`
    type and add a `HealthData` structure to it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还有懒加载实例属性的方法。让我们扩展我们的`Person`类型并为其添加一个`HealthData`结构体：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, every time we create a new person, it creates a `healthData` instance.
    In our example, `HealthData` could be a heavy object that connects to a database,
    fetches health data, and does a lot of work. And we don't need a `HealthData`
    structure to be created at the same time as `Person`; instead, we would like to
    create a `HealthData` structure only when we use it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们创建一个新的个人，它都会创建一个`healthData`实例。在我们的例子中，`HealthData`可能是一个连接到数据库、获取健康数据并执行大量工作的重对象。我们不需要在创建`Person`的同时创建`HealthData`结构体；相反，我们希望在需要时才创建`HealthData`结构体。
- en: 'To make a property behave lazy, all you need to do is add the `lazy` attribute
    to its declaration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个属性表现得是懒加载的，你只需要在其声明中添加`lazy`属性：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `lazy` instance property must be declared as a variable and not a constant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy`实例属性必须声明为变量而不是常量。'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is very important not to abuse lazy instance properties. Accessing a lazy
    property adds a small performance overhead, for checking whether it was initialized
    or not.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要不要滥用懒加载实例属性。访问懒加载属性会增加一点性能开销，用于检查它是否已初始化。
- en: That's why it is very important to analyze which parts of the system need to
    be created at the same time, because they are used at the same time, and which
    maybe not be used at all; so, we make them lazy to delay their creation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，分析系统哪些部分需要同时创建非常重要，因为它们会同时使用，而有些可能根本不会使用；因此，我们将它们设置为懒加载以延迟它们的创建。
- en: 'When you access a lazy property, it actually mutates a value, so the instance
    has to be declared as a variable. If you use a class with a lazy stored property,
    it can be declared as a constant. This is because it''s a constant reference and
    the changes are applied to the value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问懒加载属性时，它实际上会修改一个值，因此实例必须声明为变量。如果你使用具有懒加载存储属性的课程，它可以声明为常量。这是因为它是一个常量引用，更改应用于值：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An important thing to note about lazy properties is that they get initialized
    only once. If you create a lazy optional property that you would like set to `nil`
    later and initialize again, you will need to do it manually. Let''s say `healthData`
    is a very heavy instance and we want to clear it when it''s not needed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于懒加载属性的一个重要注意事项是，它们只初始化一次。如果你创建了一个懒加载的可选属性，稍后你想将其设置为`nil`并再次初始化，你需要手动完成。比如说`healthData`是一个非常重的实例，我们希望在不需要时清除它：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we said, the lazy stored property is initialized only once. So, the next
    time we access it, after we have cleared it, there is no extra initialization
    code running. If we really need this sort of lazy loading cache, then we will
    need to implement it ourselves. It''s not hard. We would need a stored property
    and a computed property like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，懒加载的存储属性只初始化一次。所以，下次我们访问它，在我们清除它之后，就没有额外的初始化代码在运行。如果我们真的需要这种懒加载缓存，那么我们需要自己实现它。这并不难。我们需要一个存储属性和一个计算属性，如下所示：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to create a mutating getter here, because the `var` properties can''t
    be declared as `mutating`. Now, if we run our previous example once more, we will
    see that `HealthData` is created every time after cleaning it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里必须创建一个可变获取器，因为`var`属性不能声明为`mutating`。现在，如果我们再次运行之前的示例，我们会看到每次清理后都会创建`HealthData`：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Computed properties
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: The other way of delaying a property initialization is by using a computed property.
    As the name says, a computed property is computed every time you access it. It's
    important to remember that such a property will be computed every time, because
    this could have a negative impact on performance or if you perform any side effect
    on it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟属性初始化的另一种方式是使用计算属性。正如其名所示，计算属性每次访问时都会被计算。重要的是要记住，这样的属性每次都会被计算，因为这可能会对性能产生负面影响，或者如果你对其执行任何副作用。
- en: 'The best use case of a computed property is when you want to provide a read-only
    property that uses internal data for its computation. A good example would be
    the full name of a person:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性的最好用途是当你想要提供一个只读属性，该属性使用内部数据进行计算时。一个很好的例子就是一个人的全名：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's really important to pay attention while performing any side effect or mutation
    operation on the computed properties. The mutating operation would require specifying
    explicitly for structures, but it would also be legal to do this for a class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何副作用或突变操作时，对计算属性进行操作时，我们必须非常注意。突变操作需要为结构显式指定，但对于类来说，这样做也是合法的。
- en: Lazy collections and evaluation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载集合和评估
- en: Another very interesting place where we could perform work lazily is collections
    and sequences. We store many elements in them, and sometimes, performing an operation
    such as `filter` or `map` would take a lot of time and may be unnecessary.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以懒加载执行操作的地方是集合和序列。我们在其中存储了许多元素，有时执行如`filter`或`map`这样的操作会花费很多时间，可能也是不必要的。
- en: 'Before we dig into the details, let''s first check out a small example to see
    why working lazily with a collection is so useful. We have a collection. We want
    to perform an operation such as mapping on it, and get one or a few elements from
    the result. Here is how we would implement it using an array:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们先看看一个小例子，看看为什么懒加载集合是如此有用。我们有一个集合。我们想要对其执行如映射这样的操作，并从结果中获取一个或几个元素。以下是使用数组实现它的方法：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we call the `map` method on the `numbers` array, it applies it to every
    element in the array and returns the new mapped array. As a result, we get a new
    `doubledNumbers` array. Our map `{ $0 * 2 }` closure is called as many times as
    there are elements in the array; in our case, it is 1,000,000 times. But we need
    only the last element from that array. Instead of mapping every element, we would
    like to map only the last one. For this situation, it is better to use a lazy
    collection:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`numbers`数组上调用`map`方法时，它会将操作应用于数组中的每个元素，并返回新的映射数组。因此，我们得到了一个新的`doubledNumbers`数组。我们的`map`闭包`{
    $0 * 2 }`会根据数组中的元素数量被调用，在我们的例子中是1,000,000次。但我们需要的是数组中的最后一个元素。而不是映射每个元素，我们只想映射最后一个。在这种情况下，使用懒加载集合会更好：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The only difference here is that we added a `lazy` method call to create `LazyCollection`
    from an array:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是我们添加了一个`lazy`方法调用来从数组创建`LazyCollection`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we call a map method on the lazy collection, it does not perform a mapping
    of every element immediately, but delays it and returns another `LazyCollection`—`LazyMapCollection`.
    The next time when we ask `doubledNumbers` for the last number, it performs a
    mapping to the last number and returns it to us. As a result, we call our map
    only once, which is exactly what we needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在懒加载集合上调用`map`方法时，它不会立即对每个元素进行映射，而是延迟执行并返回另一个`LazyCollection`——`LazyMapCollection`。下次当我们要求`doubledNumbers`获取最后一个数字时，它会对最后一个数字进行映射并返回给我们。因此，我们只调用了一次我们的`map`，这正是我们所需要的。
- en: All `LazyCollections` and `LazySequences` work by the same principle; they do
    work on demand when you pull an element from it. When you call any method that
    is supposed to perform an operation on a sequence, such as `map` or `filter`,
    it is not performed immediately. Instead, the `LazySequence` saves the operation
    that needs to be performed and returns a new `LazySequence`. The `LazySequence`
    performs that operation only when you pull data out of it, like when you ask for
    the last element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`LazyCollections`和`LazySequences`都按照相同的原理工作；它们在需要时才执行操作，当你从其中拉取一个元素时。当你调用任何应该对序列执行操作的函数，如`map`或`filter`时，它不会立即执行。相反，`LazySequence`保存需要执行的操作并返回一个新的`LazySequence`。只有当你从其中拉取数据时，`LazySequence`才会执行那个操作，比如当你请求最后一个元素时。
- en: Sequences and collections
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列和集合
- en: For a better understanding of laziness, it's useful to learn the difference
    between sequences and collections. We can apply lazy operations to both of them,
    but collections allow us to do more, and we will see why.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解懒加载，了解序列和集合之间的区别是有用的。我们可以将懒加载操作应用于它们，但集合允许我们做更多的事情，我们将会看到原因。
- en: Sequences
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列
- en: 'A sequence is represented as a traversable set of elements. The main operation
    we would do on a sequence is iterating over its elements by starting from the
    first element and moving forward. For us to do this, the sequence uses a `GeneratorType`
    protocol. The `GeneratorType` protocol has a `next` method, which returns the
    next element, or nil if there is no element. This is the only method that is available
    on `GeneratorType`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 序列表示为可遍历的元素集合。我们对序列的主要操作是从第一个元素开始向前迭代其元素。为了做到这一点，序列使用了一个 `GeneratorType` 协议。`GeneratorType`
    协议有一个 `next` 方法，它返回下一个元素，如果没有元素则返回 nil。这是 `GeneratorType` 上唯一可用的方法：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `SequenceType` and `GeneratorType` protocols are very simple. Each of them
    requires only one method to implement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequenceType` 和 `GeneratorType` 协议非常简单。每个协议都只需要实现一个方法：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the simplest and most fundamental operation that is available for a
    SequenceType instance, an iteration over its elements:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 SequenceType 实例可以执行的最简单和最基本操作，即对其元素的迭代：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want your own types to be used in a `for…in` loop, you need to implement
    a `SequenceType` protocol for your type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的自定义类型能在 `for…in` 循环中使用，你需要为你的类型实现一个 `SequenceType` 协议。
- en: 'The other way in which we can iterate over the sequence is by manually getting
    the next element from the generator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迭代序列的另一种方式是手动从生成器获取下一个元素：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Swift standard library uses protocol extensions to provide extra functionality
    for the `SequenceType`. In Swift 2.0, `SequenceType` has become very powerful,
    with many methods, such as `map` and `filter`, `sort`, `equal`, and many others.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 标准库使用协议扩展来为 `SequenceType` 提供额外的功能。在 Swift 2.0 中，`SequenceType` 变得非常强大，拥有许多方法，如
    `map` 和 `filter`、`sort`、`equal` 以及许多其他方法。
- en: Collections
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: A collection, on the other hand, represents a group of items in which every
    item can be accessed by its index. The simplest example of a collection is an
    array. A collection type also implements a `SequenceType` protocol, because of
    which you can use a collection in every place where a sequence is expected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集合表示一组项目，其中每个项目都可以通过其索引访问。集合的最简单例子是一个数组。集合类型也实现了 `SequenceType` 协议，因此你可以在需要序列的任何地方使用集合。
- en: '`CollectionType` requires implementing three more methods in addition to the
    `SequenceType` protocol:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `SequenceType` 协议外，`CollectionType` 还需要实现三个额外的方法：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`CollectionType` gives us random access to elements with a subscript method.
    Because the collection knows the first and last indexes, it can also calculate
    the size and iterate over its elements in both directions, from the beginning
    and from the end. This gives us much more power.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionType` 通过下标方法为我们提供了对元素的随机访问。因为集合知道第一个和最后一个索引，它还可以计算大小，并从开始和结束两个方向迭代其元素。这给了我们更多的能力。'
- en: Implementing our own sequence and collection
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现我们自己的序列和集合
- en: 'As the wrap-up of getting to know sequences and collections, let''s implement
    our own sequence and collection types. We can also add a `print` statement to
    it so that we can see in the console when it''s actually doing work. This is very
    useful for inspecting the behavior of lazy collections. Let''s start with the
    sequence:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为了解序列和集合的总结，让我们实现我们自己的序列和集合类型。我们还可以添加一个 `print` 语句，这样我们就可以在控制台看到它实际执行工作的情况。这对于检查惰性集合的行为非常有用。让我们从序列开始：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is our simple sequence of infinite numbers. Our generator just returns
    the next integer. Now let''s create a custom collection. It will be a bit more
    complicated than a sequence:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们简单的无限数列。我们的生成器只是返回下一个整数。现在让我们创建一个自定义集合。它将比序列复杂一些：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For this example, we made an immutable collection of 10 integer elements. Its
    implementation is still quite simple. Because our collection is closed and it
    has the `endIndex` property, the generator needs to check the bounds, and it returns
    `nil` when there are no more elements in the sequence.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们创建了一个包含 10 个整数元素的不可变集合。它的实现仍然相当简单。因为我们的集合是封闭的，并且它有 `endIndex` 属性，生成器需要检查边界，当序列中没有更多元素时，它返回
    `nil`。
- en: You can play around with those new types and use them with functions from the
    Swift standard library, which takes sequence or collection types as an argument.
    Now let's move on to the most interesting part; let's use these types with a lazy
    function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用这些新类型，并将它们与 Swift 标准库中的函数一起使用，这些函数接受序列或集合类型作为参数。现在让我们继续到最有趣的部分；让我们使用这些类型与一个惰性函数一起使用。
- en: Using lazy
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用惰性
- en: 'Turning a collection or a sequence into a lazy version is very simple. Both
    sequences and collections have a `lazy` property, which returns a lazy version
    of that collection or sequence:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将集合或序列转换为懒版本非常简单。序列和集合都有一个 `lazy` 属性，它返回该集合或序列的懒加载版本：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the lazy sequence
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用懒序列
- en: 'Let''s now play with our infinite numbers sequence and the `LazySequence` map
    and filter methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用我们的无限数字序列和 `LazySequence` 的映射和过滤方法来玩玩：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code here is pretty straightforward. We create a lazy sequence and apply
    a `map` and `filter` transformation to it. After that, we pull the first 10 results
    from it. Because the collection is lazy, it starts performing mapping and filtering
    only when we start pulling elements from it into the loop body, by calling the
    `next` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码相当简单。我们创建一个懒序列，并对其应用 `map` 和 `filter` 转换。然后，我们从其中提取前 10 个结果。因为集合是懒加载的，所以它只在开始从循环体中提取元素时开始执行映射和过滤，通过调用
    `next` 方法。
- en: 'Because `LazySequence` is a `SequenceType` protocol, you can use it with any
    function that takes a `SequenceType` protocol or call any method that is available
    in that `SequenceType`. That operation won''t be lazy and will return a result.
    If we try to use them with our infinity numbers, it could lead to an infinite
    loop. This is because our sequence is infinite:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `LazySequence` 是一个 `SequenceType` 协议，所以你可以用它与任何接受 `SequenceType` 协议的函数一起使用，或者调用在该
    `SequenceType` 中可用的任何方法。这种操作不会是懒加载的，并且会返回一个结果。如果我们尝试用我们的无限数字使用它们，可能会导致无限循环。这是因为我们的序列是无限的：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using a lazy collection
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用懒集合
- en: Working with lazy collections is very similar to working with lazy sequences.
    A `LazyCollection` implements a `CollectionType`, which means that we can use
    all the methods from `CollectionType` with a `LazyCollection`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与懒序列一起工作非常类似于与懒集合一起工作。`LazyCollection` 实现了一个 `CollectionType`，这意味着我们可以使用 `CollectionType`
    中的所有方法与 `LazyCollection` 一起使用。
- en: 'First, let''s create a lazy collection and some additional helper functions
    to map and filter a collection that we will use:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个懒集合和一些额外的辅助函数来映射和过滤我们将要使用的集合：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `map`, `reverse`, and `filter` methods of a lazy collection have small
    differences. They return different lazy collection types: `LazyMapCollection`,
    `LazyFilterCollection`, and `ReverseRandomAccessCollection`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 懒集合的 `map`、`reverse` 和 `filter` 方法有一些小的区别。它们返回不同的懒集合类型：`LazyMapCollection`、`LazyFilterCollection`
    和 `ReverseRandomAccessCollection`：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both the `LazyMapCollection` and `LazyFilterCollection` types implement a `LazyCollectionType`,
    and they have similar methods. Because of this, some lazy collections could have
    a different set of available methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyMapCollection` 和 `LazyFilterCollection` 类型都实现了 `LazyCollectionType`，并且它们有类似的方法。正因为如此，一些懒集合可能有一组不同的可用方法。'
- en: 'One more interesting behavior of these lazy collections is the difference in
    the way some methods work. As an example, let''s take a look at the `count` and
    `isEmpty` methods. First, let''s try to use them with `LazyMapCollection`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些懒集合的一个有趣的行为差异是某些方法工作方式的不同。作为一个例子，让我们看看 `count` 和 `isEmpty` 方法。首先，让我们尝试用 `LazyMapCollection`
    使用它们：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Calling `count` and `isEmpty` does not force a lazy collection to perform any
    mapping operation. Because mapping doesn't change the number of elements of a
    source collection, it can use the underlying collections data—`startIndex` and
    `endIndex`—to compute a result for those methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `count` 和 `isEmpty` 不会强制懒集合执行任何映射操作。因为映射不会改变源集合的元素数量，它可以使用底层集合数据——`startIndex`
    和 `endIndex`——来计算这些方法的结果。
- en: 'However, calling `count` and `isEmpty` on a `LazyFilterCollection` does require
    the lazy collection to perform a filtering operation. For the `isEmpty` method,
    it stops as soon as it finds an element; but for the `count` method, it needs
    to apply the filtering operation to every element. In such cases, calling a `count`
    method would behave the same way as calling it on a regular collection:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 `LazyFilterCollection` 上调用 `count` 和 `isEmpty` 确实需要懒集合执行一个过滤操作。对于 `isEmpty`
    方法，它一旦找到元素就会停止；但对于 `count` 方法，它需要将过滤操作应用于每个元素。在这种情况下，调用 `count` 方法的行为与在常规集合上调用它相同：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'One more difference between the `map` and `reverse` methods that is worth mentioning
    is in the subscript methods and indexes that they use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`map` 和 `reverse` 方法之间还有一个区别，那就是它们使用的下标方法和索引：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`LazyMapCollection` allows us to use the original index that we used for the
    collection; in our case, this is an `Int` type. The `reverse` method returns a
    `ReverseRandomAccessCollection` with indexes of the `ReverseRandomAccessIndex`
    type. To use a subscript method on it, we need to use a `startIndex` or `endIndex`
    and an `advance` method to move the index to the needed position.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyMapCollection`允许我们使用用于集合的原始索引；在我们的例子中，这是一个`Int`类型。`reverse`方法返回一个具有`ReverseRandomAccessIndex`类型索引的`ReverseRandomAccessCollection`。要使用其上的索引方法，我们需要使用`startIndex`或`endIndex`以及`advance`方法来移动索引到所需的位置。'
- en: This was a general overview of lazy collections and sequences. However, there
    is one more very important characteristic of lazy types that we need to cover.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对懒集合和序列的一般概述。然而，懒类型还有一个非常重要的特性需要我们介绍。
- en: A lazy collection or sequence performs an operation, for example, a mapping
    of elements, when we start pulling elements from it. The difference here is that
    a regular array applies a mapping only once for every element and returns the
    result immediately.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 懒集合或序列在开始从其中拉取元素时执行操作，例如，元素的映射。这里的区别是，常规数组对每个元素只应用一次映射并立即返回结果。
- en: 'A lazy collection applies a mapping every time we pull elements from it. If
    you are going to use a result of a mapping very often, then it may be better to
    use a regular array or add some kind of caching or memorization functionality.
    Let''s see with the help of an example why it could be dangerous:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 懒集合每次从其中拉取元素时都会应用映射。如果您打算经常使用映射的结果，那么使用常规数组或添加某种缓存或记忆功能可能更好。让我们通过一个例子来看看为什么这可能是危险的：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example shows two important issues with using a lazy collection and a state
    in the map function. When we use a mapped lazy collection, we expect that the
    result will be the same for all loop iterations because we haven't changed anything.
    In reality, however, it will be different because the `map` function is called
    twice and the state we used in the map function will have been changed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了使用懒集合和在映射函数中的状态时存在的两个重要问题。当我们使用映射的懒集合时，我们期望结果在所有循环迭代中都是相同的，因为我们没有做任何改变。然而，实际上，它将是不同的，因为`map`函数被调用了两次，我们在映射函数中使用的状态已经改变。
- en: 'We could partially solve this problem by removing the state from the map function.
    Now the lazy mapped collection produces the same result, but even this doesn''t
    change the fact that a map function will be executed in both loops. If we put
    an expensive operation inside the map function, it will make our app twice as
    slow:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从映射函数中移除状态来部分解决这个问题。现在，懒映射集合会产生相同的结果，但这并不能改变映射函数将在两个循环中执行的事实。如果我们把一个昂贵的操作放在映射函数内部，它会使我们的应用速度减半：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Closing the topic of lazy collections, I would say that a lazy collection is
    very powerful, but you should used it as carefully as any other tool that helps
    improve performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束懒集合的话题时，我想说，懒集合非常强大，但您应该像使用任何其他有助于提高性能的工具一样谨慎地使用它。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered two more tools that can improve an application''s
    performance: lazy loading and lazy execution techniques. First, we explained why
    it''s important to make code behave lazily, when to do so, and in which way it
    can be implemented. Next, we showed you the lazy loading feature built into the
    Swift language and how to use it with global variables, type properties, and lazy
    stored properties.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两个可以提高应用程序性能的工具：懒加载和懒执行技术。首先，我们解释了为什么让代码表现出懒性很重要，何时应该这样做，以及如何实现。接下来，我们展示了Swift语言内置的懒加载功能以及如何使用它与全局变量、类型属性和懒存储属性一起使用。
- en: In the rest of the chapter, we covered how to make a collection behave lazily.
    We used many functions with a lazy collection and showed the differences between
    a collection and a sequence.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分，我们介绍了如何使集合表现出懒性。我们使用了许多与懒集合相关的函数，并展示了集合与序列之间的区别。
- en: In the next and final chapter, *Discovering All of the Underlying Swift Power*,
    we will take a look at some more advanced tools that will help you analyze the
    power of Swift, and go through a quick recap of what you learned throughout the
    book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，*发现所有底层的Swift力量*，我们将探讨一些更高级的工具，这些工具将帮助您分析Swift的力量，并对您在本书中学到的内容进行快速回顾。
