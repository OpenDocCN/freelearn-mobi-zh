- en: Chapter 7. The Importance of Being Lazy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of improving an application''s performance is by deferring the
    execution of code until the result is needed. This sounds very logical; the less
    the code we run, the less the time it will take. This design pattern is usually
    called **lazy**. There are many things that can be lazy, and there are many different
    ways in which we can defer code execution. We are going to cover the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The lazy mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy collections and evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lazy mindset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, it is very important to understand the lazy pattern, how it works, how
    it could benefit an application's performance, and when to use it. It's also very
    important not to abuse it, because that would make code more complex and hard
    to read. Plus, it would be hard to follow the execution flow. Also, abusing it
    would decrease the overall application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea of a lazy pattern is to defer the evaluation of an instruction
    until someone asks for the result of that instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In general, code is executed instruction by instruction, starting at the top
    of a file or a function. Nowadays, our applications are more complex and consist
    of many files, windows, libraries, components, and layers, but they still execute
    code in the same way. Because our system gets bigger and bigger, it's important
    to make them lazy so that we don't have to perform all the work when we start
    the application. Let's learn a few techniques for making code lazy.
  prefs: []
  type: TYPE_NORMAL
- en: Separation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s very important to separate code into components with a **single responsibility**
    pattern. A component should do only one thing and do it well. Let''s take a look
    at this simple example to understand how this could improve performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this code that the `analyze` function does two things. Because
    of that, the memory usage peak is twice as big. When we are done analyzing names,
    the memory used for it is not released immediately, but is kept until we return
    from the function. If we tried to analyze all of the population of England, it
    would require quite a lot of memory. By splitting them into separate functions,
    we can improve memory usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should apply a code separation technique very often to different components
    as an example. Make simple models and use only the data that you need for the
    current view. Splitting code into smaller components is useful, but you shouldn't
    split it into too small components.
  prefs: []
  type: TYPE_NORMAL
- en: Do work on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main idea of lazy code is to do work only on demand. In this way, you can
    delay a code execution or remove it completely if no one asks for the result.
    When you are planning an application''s architecture, try to think about these
    questions: when would this resource or data be used in the application? Does it
    have to be instantiated now or can it wait? How often would this data be used?
    If often, then maybe you should cache it; if not, maybe you should load it lazily.
    Is the data heavy? Do you need to clean it afterward? Asking all of these questions
    helps you build a better application architecture with the *do work on demand*
    approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Approximate results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another idea is mixing lazy loading and asynchronous execution. If you want
    to perform an asynchronous task, because it takes a long time, but you would also
    like to get a result immediately, you can return an approximate result immediately
    and continue the execution. For example, the core data asynchronous fetching implements
    this pattern. It returns you an approximate number of items that will be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lazy loading pattern allows you to delay the creation of an object until
    you try to use it. This pattern can be implemented in any programming language.
    In Objective-C, we have used the property's getters and checked whether it was
    initialized. Swift adds support for lazy loading into the language, and this makes
    it even easier to apply this pattern. There are many things that can be lazy loaded,
    and we will cover them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Global constants and variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Global variables and constants are always loaded lazily in Swift. This means
    that every global variable is initialized only when you access it for the first
    time. As a test, let''s create a new `Person.swift` file and add this code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This file contains two global constants: `Jon` and `Sam`. We have also added
    a log statement to the `Person` structure''s `init` method so that we can see
    when the person is created. Now let''s try to access one of the global constants
    and see the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, only the `Jon` global constant is created, and it's created
    when we try to access its age property. Yes, global constants and variables have
    powerful features in Swift, but you should almost never use global constants!
    There is a better way to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables are even more vulnerable because anyone can change them in
    the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Type properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both structures and classes can have a `type` property. The `type` property
    belongs to the type itself and not to an instance of that type. Only one copy
    of a type property will be created no matter how many instances of that type you
    create. They behave like global variables and constants, but they have a namespace
    scope of that type. Also, type properties can be declared as private and be hidden
    from rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can very easily improve our code by moving our global constants into the
    `Person` struct definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a `type` property, we need to prefix it with a type name that it
    is declared in; to access the `Jon` type constant, we would need to write `Person.Jon`.
    Classes have the same syntax and functionality for type properties as structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Lazy properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is also a way to lazy load an instance property. Let''s extend our `Person`
    type and add a `HealthData` structure to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time we create a new person, it creates a `healthData` instance.
    In our example, `HealthData` could be a heavy object that connects to a database,
    fetches health data, and does a lot of work. And we don't need a `HealthData`
    structure to be created at the same time as `Person`; instead, we would like to
    create a `HealthData` structure only when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a property behave lazy, all you need to do is add the `lazy` attribute
    to its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy` instance property must be declared as a variable and not a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important not to abuse lazy instance properties. Accessing a lazy
    property adds a small performance overhead, for checking whether it was initialized
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: That's why it is very important to analyze which parts of the system need to
    be created at the same time, because they are used at the same time, and which
    maybe not be used at all; so, we make them lazy to delay their creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you access a lazy property, it actually mutates a value, so the instance
    has to be declared as a variable. If you use a class with a lazy stored property,
    it can be declared as a constant. This is because it''s a constant reference and
    the changes are applied to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An important thing to note about lazy properties is that they get initialized
    only once. If you create a lazy optional property that you would like set to `nil`
    later and initialize again, you will need to do it manually. Let''s say `healthData`
    is a very heavy instance and we want to clear it when it''s not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we said, the lazy stored property is initialized only once. So, the next
    time we access it, after we have cleared it, there is no extra initialization
    code running. If we really need this sort of lazy loading cache, then we will
    need to implement it ourselves. It''s not hard. We would need a stored property
    and a computed property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to create a mutating getter here, because the `var` properties can''t
    be declared as `mutating`. Now, if we run our previous example once more, we will
    see that `HealthData` is created every time after cleaning it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Computed properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other way of delaying a property initialization is by using a computed property.
    As the name says, a computed property is computed every time you access it. It's
    important to remember that such a property will be computed every time, because
    this could have a negative impact on performance or if you perform any side effect
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best use case of a computed property is when you want to provide a read-only
    property that uses internal data for its computation. A good example would be
    the full name of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's really important to pay attention while performing any side effect or mutation
    operation on the computed properties. The mutating operation would require specifying
    explicitly for structures, but it would also be legal to do this for a class.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy collections and evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very interesting place where we could perform work lazily is collections
    and sequences. We store many elements in them, and sometimes, performing an operation
    such as `filter` or `map` would take a lot of time and may be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dig into the details, let''s first check out a small example to see
    why working lazily with a collection is so useful. We have a collection. We want
    to perform an operation such as mapping on it, and get one or a few elements from
    the result. Here is how we would implement it using an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the `map` method on the `numbers` array, it applies it to every
    element in the array and returns the new mapped array. As a result, we get a new
    `doubledNumbers` array. Our map `{ $0 * 2 }` closure is called as many times as
    there are elements in the array; in our case, it is 1,000,000 times. But we need
    only the last element from that array. Instead of mapping every element, we would
    like to map only the last one. For this situation, it is better to use a lazy
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here is that we added a `lazy` method call to create `LazyCollection`
    from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we call a map method on the lazy collection, it does not perform a mapping
    of every element immediately, but delays it and returns another `LazyCollection`—`LazyMapCollection`.
    The next time when we ask `doubledNumbers` for the last number, it performs a
    mapping to the last number and returns it to us. As a result, we call our map
    only once, which is exactly what we needed.
  prefs: []
  type: TYPE_NORMAL
- en: All `LazyCollections` and `LazySequences` work by the same principle; they do
    work on demand when you pull an element from it. When you call any method that
    is supposed to perform an operation on a sequence, such as `map` or `filter`,
    it is not performed immediately. Instead, the `LazySequence` saves the operation
    that needs to be performed and returns a new `LazySequence`. The `LazySequence`
    performs that operation only when you pull data out of it, like when you ask for
    the last element.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences and collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a better understanding of laziness, it's useful to learn the difference
    between sequences and collections. We can apply lazy operations to both of them,
    but collections allow us to do more, and we will see why.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A sequence is represented as a traversable set of elements. The main operation
    we would do on a sequence is iterating over its elements by starting from the
    first element and moving forward. For us to do this, the sequence uses a `GeneratorType`
    protocol. The `GeneratorType` protocol has a `next` method, which returns the
    next element, or nil if there is no element. This is the only method that is available
    on `GeneratorType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SequenceType` and `GeneratorType` protocols are very simple. Each of them
    requires only one method to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the simplest and most fundamental operation that is available for a
    SequenceType instance, an iteration over its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your own types to be used in a `for…in` loop, you need to implement
    a `SequenceType` protocol for your type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way in which we can iterate over the sequence is by manually getting
    the next element from the generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Swift standard library uses protocol extensions to provide extra functionality
    for the `SequenceType`. In Swift 2.0, `SequenceType` has become very powerful,
    with many methods, such as `map` and `filter`, `sort`, `equal`, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A collection, on the other hand, represents a group of items in which every
    item can be accessed by its index. The simplest example of a collection is an
    array. A collection type also implements a `SequenceType` protocol, because of
    which you can use a collection in every place where a sequence is expected.
  prefs: []
  type: TYPE_NORMAL
- en: '`CollectionType` requires implementing three more methods in addition to the
    `SequenceType` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`CollectionType` gives us random access to elements with a subscript method.
    Because the collection knows the first and last indexes, it can also calculate
    the size and iterate over its elements in both directions, from the beginning
    and from the end. This gives us much more power.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our own sequence and collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the wrap-up of getting to know sequences and collections, let''s implement
    our own sequence and collection types. We can also add a `print` statement to
    it so that we can see in the console when it''s actually doing work. This is very
    useful for inspecting the behavior of lazy collections. Let''s start with the
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our simple sequence of infinite numbers. Our generator just returns
    the next integer. Now let''s create a custom collection. It will be a bit more
    complicated than a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we made an immutable collection of 10 integer elements. Its
    implementation is still quite simple. Because our collection is closed and it
    has the `endIndex` property, the generator needs to check the bounds, and it returns
    `nil` when there are no more elements in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: You can play around with those new types and use them with functions from the
    Swift standard library, which takes sequence or collection types as an argument.
    Now let's move on to the most interesting part; let's use these types with a lazy
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Using lazy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Turning a collection or a sequence into a lazy version is very simple. Both
    sequences and collections have a `lazy` property, which returns a lazy version
    of that collection or sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using the lazy sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now play with our infinite numbers sequence and the `LazySequence` map
    and filter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code here is pretty straightforward. We create a lazy sequence and apply
    a `map` and `filter` transformation to it. After that, we pull the first 10 results
    from it. Because the collection is lazy, it starts performing mapping and filtering
    only when we start pulling elements from it into the loop body, by calling the
    `next` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `LazySequence` is a `SequenceType` protocol, you can use it with any
    function that takes a `SequenceType` protocol or call any method that is available
    in that `SequenceType`. That operation won''t be lazy and will return a result.
    If we try to use them with our infinity numbers, it could lead to an infinite
    loop. This is because our sequence is infinite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using a lazy collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Working with lazy collections is very similar to working with lazy sequences.
    A `LazyCollection` implements a `CollectionType`, which means that we can use
    all the methods from `CollectionType` with a `LazyCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a lazy collection and some additional helper functions
    to map and filter a collection that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map`, `reverse`, and `filter` methods of a lazy collection have small
    differences. They return different lazy collection types: `LazyMapCollection`,
    `LazyFilterCollection`, and `ReverseRandomAccessCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Both the `LazyMapCollection` and `LazyFilterCollection` types implement a `LazyCollectionType`,
    and they have similar methods. Because of this, some lazy collections could have
    a different set of available methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more interesting behavior of these lazy collections is the difference in
    the way some methods work. As an example, let''s take a look at the `count` and
    `isEmpty` methods. First, let''s try to use them with `LazyMapCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Calling `count` and `isEmpty` does not force a lazy collection to perform any
    mapping operation. Because mapping doesn't change the number of elements of a
    source collection, it can use the underlying collections data—`startIndex` and
    `endIndex`—to compute a result for those methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, calling `count` and `isEmpty` on a `LazyFilterCollection` does require
    the lazy collection to perform a filtering operation. For the `isEmpty` method,
    it stops as soon as it finds an element; but for the `count` method, it needs
    to apply the filtering operation to every element. In such cases, calling a `count`
    method would behave the same way as calling it on a regular collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'One more difference between the `map` and `reverse` methods that is worth mentioning
    is in the subscript methods and indexes that they use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`LazyMapCollection` allows us to use the original index that we used for the
    collection; in our case, this is an `Int` type. The `reverse` method returns a
    `ReverseRandomAccessCollection` with indexes of the `ReverseRandomAccessIndex`
    type. To use a subscript method on it, we need to use a `startIndex` or `endIndex`
    and an `advance` method to move the index to the needed position.'
  prefs: []
  type: TYPE_NORMAL
- en: This was a general overview of lazy collections and sequences. However, there
    is one more very important characteristic of lazy types that we need to cover.
  prefs: []
  type: TYPE_NORMAL
- en: A lazy collection or sequence performs an operation, for example, a mapping
    of elements, when we start pulling elements from it. The difference here is that
    a regular array applies a mapping only once for every element and returns the
    result immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lazy collection applies a mapping every time we pull elements from it. If
    you are going to use a result of a mapping very often, then it may be better to
    use a regular array or add some kind of caching or memorization functionality.
    Let''s see with the help of an example why it could be dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example shows two important issues with using a lazy collection and a state
    in the map function. When we use a mapped lazy collection, we expect that the
    result will be the same for all loop iterations because we haven't changed anything.
    In reality, however, it will be different because the `map` function is called
    twice and the state we used in the map function will have been changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could partially solve this problem by removing the state from the map function.
    Now the lazy mapped collection produces the same result, but even this doesn''t
    change the fact that a map function will be executed in both loops. If we put
    an expensive operation inside the map function, it will make our app twice as
    slow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Closing the topic of lazy collections, I would say that a lazy collection is
    very powerful, but you should used it as carefully as any other tool that helps
    improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered two more tools that can improve an application''s
    performance: lazy loading and lazy execution techniques. First, we explained why
    it''s important to make code behave lazily, when to do so, and in which way it
    can be implemented. Next, we showed you the lazy loading feature built into the
    Swift language and how to use it with global variables, type properties, and lazy
    stored properties.'
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the chapter, we covered how to make a collection behave lazily.
    We used many functions with a lazy collection and showed the differences between
    a collection and a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, *Discovering All of the Underlying Swift Power*,
    we will take a look at some more advanced tools that will help you analyze the
    power of Swift, and go through a quick recap of what you learned throughout the
    book.
  prefs: []
  type: TYPE_NORMAL
