- en: Chapter 9. Importance of Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented and functional programming, immutable objects are objects
    whose state cannot be changed or altered after they are initiated. Therefore,
    a mutable object stays the same until the end of its life cycle, when it is deinitialized.
    In contrast, a mutable object can be altered countless times by other objects
    after it is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects improve readability and runtime efficiency and using them
    simplifies our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the concept of immutability by discussing the following
    topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cases for mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example with approach comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side-effects and unintended consequences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An immutable object is an object whose state cannot be modified after it is
    initiated. This quality of immutable objects is essential in multithreaded applications
    because it allows a thread to act on the data represented by immutable objects
    without worrying about changes from other threads.
  prefs: []
  type: TYPE_NORMAL
- en: An object is considered immutable if the object itself, and in fact all of its
    properties, are immutable. In some cases, an object is considered immutable even
    if some of its internal properties change but the object's state appears to be
    immutable from an external point of view. For instance, an object that uses the
    memoization technique to cache the results of resource-greedy calculations can
    be considered as an immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable objects have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: They are simple to construct, test, and use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are simple to understand and reason about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are inherently thread-safe and have no synchronization issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not require a copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They always have failure atomicity so if an immutable object throws an exception,
    it will not be stuck in an undesirable/indeterminate state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They offer higher security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the imperative programming style, values held in application variables whose
    contents never change are known as constants to differentiate them from variables
    that could be altered during execution. Examples might include a view's height
    and width or the value of Π to several decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike programming languages such as Objective-C in which some types are mutable
    and some are not, Swift provides a way to create an immutable or mutable version
    of the same type. In Swift, we use the `let` and `var` keywords to create and
    store values:'
  prefs: []
  type: TYPE_NORMAL
- en: The `var` keyword is used to create a variable that can be altered later, in
    other words, to create mutable variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `let` keyword is used to create a constant that cannot be altered later,
    in other words, immutable variables or constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, in Swift, we do not need to have any type such as `NSMutableArray`
    opposed to `NSArray` or `NSMutableDictionary` opposed to `NSDictionary` to differentiate
    between mutability and immutability. We can simply define `Dictionary` with `var`
    or `let` to make it mutable or immutable.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Swift compiler always suggests and warns us about variables
    that are not changed and will be converted to constants later.
  prefs: []
  type: TYPE_NORMAL
- en: Weak versus strong immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, certain properties of an object can be immutable while the others
    may be mutable. These types of objects are called weakly immutable. Weak immutability
    means that we cannot change the immutable parts of the object state even though
    other parts of the object may be mutable. If all properties are immutable, then
    the object is immutable. If the whole object cannot be mutated after its creation,
    the object is called strongly immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types versus value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered this topic in a previous chapter, but it is important to emphasize
    that in most **object-oriented programming** (**OOP**) languages, instances can
    be shared and objects can be passed around with their references. This is true
    for Swift classes and closures as well. In those cases, it is important to understand
    that the state of an object can be altered when objects are shared via references.
    In other words, in case any user of a reference to a mutable object changes the
    object, all other users of that object will be affected by the change.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that immutability helps safety and performance, but in real-world
    application development, immutability can provide us with more benefits, which
    will be explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immutable objects are useful in multithreaded applications because multiple
    threads can act on the data of immutable objects without worrying about changes
    to the data by other threads.
  prefs: []
  type: TYPE_NORMAL
- en: As immutable objects are closed to change, it is safe to assume that they will
    stay unchanged while we access the object from different threads. This assumption
    simplifies most of the multithreading problems that are complex to solve and maintain.
    For instance, we do not need to think about the synchronization/locking mechanism
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have a mutable object that includes a mutable array of a type,
    for example, a `Product` class that has four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen from the preceding example, all properties are defined as mutable.
    Now let''s create an array of `Product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that we need the `products` array to be shared between different threads.
    Different threads may change the array in different ways. Some may change the
    price while others may change the quantity. Some may add or remove items from
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: The first issue to solve is keeping track of changes and knowing who changes
    the array and when. This is already complex, so let's simplify the issue and only
    add an item to the array. Also, let's assume that we are only interested in the
    latest change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to track the latest change, let''s create another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductTracker` class has an array of `products` and a `lastModified`
    variable to track the latest change. In addition, it has three methods: one to
    add a new product to the array, another to retrieve the last modification date,
    and the last one to retrieve the product list.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to make our `ProductTracker` class thread-safe and allow
    multiple objects to access our `ProductTracker` object. We cannot allow multiple
    threads execute `addNewProduct` while multiple others list products. First of
    all, we will need a locking mechanism to lock the class during the modifications,
    second, we need to protect `lastModified` against modification without locking,
    and finally, an unlocking mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Apple provides multiple multithreading mechanisms such as `NSThread`, Grand
    Central Dispatch (GCD), and operation queues to overcome these types of issues
    but still multithreading remains complex.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referential transparency generally means that we can always replace a function
    with its return value without an effect on the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency is a guarantee of code reusability. Also, it denies
    the mutable state of data. In the case of a mutable state, two calls of the same
    function can potentially produce two different results, which is very difficult
    to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Low coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coupling is the measure of code dependency. We always want to reduce coupling
    and make our code components independent of each other as much as possible. Low
    coupling allows us to change the component without affecting other code components.
    The low-coupled code is easier to read because each component has its own, relatively
    small area of responsibility, though we need to understand only this code without
    spending time on figuring out how the entire system works.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability helps achieving low coupling. Immutable data can be safely passed
    through different code blocks without worrying about it being transformed and
    causing effects on other parts of the code. Pure functions transform the data
    and return the result without affecting the input data. So, if the function contains
    errors, we can easily find it. Also, using value types and immutable data structures
    means that we can significantly reduce object referencing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the data transformation idea. We have immutable array numbers,
    and we need the sum of all the even numbers that it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numbers` array is not changed and can be passed to any other function
    without any side-effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using in-place transformation of the immutable data will help us reduce coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding temporal coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that we have a code statement that is dependent on another code statement,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we set two different HTTP requests. Suppose
    that we do not need our first request anymore and we delete the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will not complain but as we deleted `request.httpMethod = "GET"`, our
    second request is not going to work. This situation is called temporal coupling.
    If we had immutable definitions with `let`, we would avoid temporal coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding identity mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may need objects to be identical if their internal states are the same. When
    modifying the state of an object, we are not expecting it to change its identity.
    Immutable objects avoid this completely.
  prefs: []
  type: TYPE_NORMAL
- en: Failure atomicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class can be left in a broken state if it throws a runtime exception. Immutability
    prevents this problem. An object will never be left in a broken state because
    its state is modified only during its initialization. The initialization will
    either fail, rejecting object initialization, or succeed, making a valid solid
    object, which never changes its encapsulated state.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immutability makes it easier to parallelize code execution as there are no conflicts
    among objects and instances.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling and error management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we use immutable types only, the internal state of our application will be
    consistent even if we have exceptions because our immutable objects do not maintain
    different states.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: References to immutable objects can be cached as they are not going to change;
    therefore, the same immutable object will be retrieved quickly the next time we
    try to access it. An example technique is memoization, which we have explained
    in [Chapter 2](ch02.html "Chapter 2. Functions and Closures"), *Functions and
    Closures*.
  prefs: []
  type: TYPE_NORMAL
- en: State comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state of an application is the state of all its objects at a given time.
    State changes rapidly over time and an application needs to change state in order
    to continue running.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects, however, have fixed state over time. Once created, the state
    of an immutable object does not change although the state of the application as
    a whole might change. This makes it easy to keep track of what is happening and
    simplify state comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler optimizes `let` statements better for items whose values will not
    change during their lifetime. For example, Apple writes, *"It is good practice
    to create immutable collections in all cases where the collection does not need
    to change. Doing so enables the Swift compiler to optimize the performance of
    the collections you create."* (Do prefer using `let` over `var` where appropriate.)
  prefs: []
  type: TYPE_NORMAL
- en: Cases for mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we require to change an immutable object, we will need to create a
    new, modified copy of it. This might not be costly and tedious for small and simple
    objects but will be in cases where we have large or complex objects with lots
    of properties and operations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, changing an existing object is simpler and much more intuitive than creating
    a new, modified copy of it for objects with a distinct identity, for instance,
    a profile of a user. We may want to maintain a single object of a user's profile
    and modify it when necessary. This might not be a great example as it is hard
    to see the performance penalty for this case but the speed of execution can be
    a very important differentiator for some types of applications such as games.
    As an example, representing our game characters with mutable objects may make
    our game run faster than an alternative implementation where we will need to create
    a new, modified copy of the game character whenever we need to change it.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our real-world perception is inevitably based on the concept of
    mutable objects. We deal with all objects around us in our real life. These objects
    are identical most of the time and we change some of their characteristics if
    required.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we paint a wall in our home instead of replacing the whole wall.
    We perceive the wall as the same object with a modified property, in this case,
    color. The wall's identity is maintained while its state changes when we paint
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, whenever we model a real-world domain to represent real-world objects
    in our applications, it is inevitably easier to perceive and implement the domain
    model using mutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We understand that there are cases where immutability makes our life harder.
    We barely touched the surface of these problems in a previous section. We will
    examine issues in more detail in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's redevelop our `Product` example with a **functional programming** (**FP**)
    style and compare the outcome to its OOP counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our `Product` example in this chapter immutable and examine the
    outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have `struct` instead of class and all properties are immutable. Also,
    we do not need an `init` method as `struct` provides it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to modify our `ProductTracker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `FunctionalProductTracker` is simplified: it is `struct` with an immutable
    array of `products` and our `addNewProduct` does not modify the state of our object
    but provides a new array of `products` each time. In fact, we can remove the `addNewProduct`
    method from this `struct` and handle it in a client object.'
  prefs: []
  type: TYPE_NORMAL
- en: Side-effects and unintended consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our mutable example''s design can produce unpredictable side-effects. If multiple
    clients hold a reference to the `ProductTracker` instance, there are two ways
    for the products to change from underneath any of these clients:'
  prefs: []
  type: TYPE_NORMAL
- en: We could simply reassign a value to the `products` directly. This is fixable
    by making it `private` for client calls but it is not fixable for in-class modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could call `addNewProduct()` from any client and modify the `products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either way, there are going to be side-effects and unintended consequences because
    of the mutation.
  prefs: []
  type: TYPE_NORMAL
- en: In our immutable example, it is impossible to cause those unintended consequences
    because our `FunctionalProductTracker` is a value type and all the properties
    are immutable. The `products` cannot be changed directly (it is a constant), and
    `addNewProduct()` returns a whole new instance, so all clients will be dealing
    with the instance that they expect to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our mutable example's `addNewProduct()` method has no return values. While it
    is possible to write a unit test for it, it is not obvious how we should implement
    asserting because the method causes a side-effect in our existing instance that
    we need to know about.
  prefs: []
  type: TYPE_NORMAL
- en: Our immutable example's `addNewProduct()` method returns a new `Array` of `Product`.
    We simply inspect the value of `products` and assert. We still have both the old
    and new instances, so we have everything we need to ensure that our code works
    as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Although we do not cover unit-testing in this book, it is highly recommended
    that you explore QuickCheck-based libraries such as Quick ([https://github.com/Quick/Quick](https://github.com/Quick/Quick))
    and SwiftCheck ([https://github.com/typelift/SwiftCheck](https://github.com/typelift/SwiftCheck))
    as they employ FP techniques to ease the unit testing process of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Copy constructors and lenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After examining our immutable example implementation, we are not able to say
    that it covers all the functionalities of the imperative approach. For instance,
    it does not provide us with a way to change the `producer` of a `product`. After
    all, we cannot change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we need to change any property of the `product`, we need to go through
    the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This solution is verbose and does not look nice. Let's examine how we can improve
    this process.
  prefs: []
  type: TYPE_NORMAL
- en: Copy constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first solution is to provide a new `init` method that copies the current
    instance. This approach is called copy constructor. Let''s add our new `init`
    method and leverage it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the default `init` as well because by adding a new `init` method to
    our `struct`, we lost the benefit of automatic `init` generation. We also need
    to change our `addNewProduct` to accommodate these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we need to modify our object partially, we will be able to do so easily
    using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Lens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we covered copy constructors. Here, we will examine
    a functional structure called lens. Simply put, lenses are *functional getters
    and setters* that are implemented for a whole object and its parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getters: We can *look through* the lens at an immutable object to get its parts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setters: We can use the lens to change a part of an immutable object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement a `Lens`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use it to change our `FunctionalProduct` object to get and set the `producer`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the producer for `mexicanBananas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Through our lens, we can change it as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine another example. Suppose that we have a `Producer` object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to change the `address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we had `mexicanBananas2` and needed to have a Chinese banana producer,
    then we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This syntax does not look very simple, and it seems that we did not gain much
    after all. In the next section, we will simplify it.
  prefs: []
  type: TYPE_NORMAL
- en: Lens composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lens composition will help to simplify our lens; let''s examine how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is going to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using lenses and composition, we were able to get and set a product's producer
    address.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by exploring the concept of immutability. We looked
    into its importance and benefits with examples. Then we looked at cases for mutability
    and went through an example to compare mutability and immutability effects on
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored the means to get and set immutable objects in a functional
    way, such as copy constructors and lenses.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will be introduced to OOP, **protocol-oriented
    programming** (**POP**), and **Functional Reactive Programming** (**FRP**). Then,
    we will explore the concept of mixing OOP and FP paradigms, in other words, object
    functional programming.
  prefs: []
  type: TYPE_NORMAL
