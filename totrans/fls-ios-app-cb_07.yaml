- en: Chapter 7. Working with Text and the Virtual Keyboard
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用文本和虚拟键盘
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using device fonts within text fields
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本字段中使用设备字体
- en: Using embedded fonts within text fields
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本字段中使用嵌入式字体
- en: Providing text entry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供文本输入
- en: Capturing text input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获文本输入
- en: Configurable panning with virtual keyboard activation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的平移与虚拟键盘激活
- en: Updating dynamic text fields
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新动态文本字段
- en: Using native iOS text controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生iOS文本控件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With the omission of physical buttons the iPhone has changed forever how many
    of us will enter text. Gone are the fixed keypad configurations of previous phones;
    replaced instead by a touch-screen keyboard that adapts its keys and layout for
    different applications. In addition, iOS comes with a comprehensive library of
    fonts and impressive text rendering capabilities, allowing user input to be shown
    in crisp detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有物理按钮，iPhone永远改变了我们输入文本的方式。之前的手机上的固定键盘配置已经消失；取而代之的是适应不同应用的触摸屏键盘。此外，iOS附带了一个全面的字体库和令人印象深刻的文本渲染能力，允许用户输入以清晰的细节显示。
- en: In this chapter, you will explore Flash's support for the native iOS virtual
    keyboard and learn how to work with text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探索Flash对原生iOS虚拟键盘的支持，并学习如何处理文本。
- en: Using device fonts within text fields
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文本字段中使用设备字体
- en: A comprehensive list of fonts is installed on iOS devices and is available for
    use directly within your AIR for iOS app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备上安装了全面的字体列表，可以直接在您的AIR for iOS应用中使用。
- en: This recipe will take you through the steps required to create a text field
    that uses a device font.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将指导您完成创建使用设备字体的文本字段的步骤。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter7\recipe1\recipe.fla`
    into Flash Professional. The FLA's stage is empty but its AIR for iOS settings
    have already been applied, saving you the time and effort when you build and deploy
    it to a device.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，在Flash Professional中打开`chapter7\recipe1\recipe.fla`。FLA的舞台是空的，但其AIR
    for iOS设置已经应用，这为您在构建和部署到设备时节省了时间和精力。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to take advantage of a device font:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以利用设备字体：
- en: Using the **Text Tool (T)** , draw a text field on the stage.![How to do it...](img/1383_07_01.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文本工具（T）**在舞台上绘制一个文本字段。![如何做到...](img/1383_07_01.jpg)
- en: Enter **Flash iOS Apps Cookbook** into the text field.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本字段中输入**Flash iOS Apps Cookbook**。
- en: From the **Properties** panel, ensure that **Classic Text** and **Dynamic Text**
    are selected from the two top-most drop-down boxes.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**属性**面板中，确保从最上面的两个下拉框中选择**经典文本**和**动态文本**。
- en: Position the text field at (21,52). Set its width and height to 278 and 240
    respectively.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本字段定位在(21,52)。将其宽度和高度分别设置为278和240。
- en: Expand the **CHARACTER** section within the Properties panel. Set the **Family**
    drop-down to **Trebuchet MS**, the **Size** to **60.0** pt, and change the font
    color to black. Also, select **Use device fonts** for the **Anti-alias** field
    and ensure that the **Selectable** icon directly underneath is not selected. All
    these settings are shown in the preceding screenshot.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性面板中展开**字符**部分。将**家族**下拉框设置为**Trebuchet MS**，将**大小**设置为**60.0** pt，并将字体颜色更改为黑色。此外，选择**使用设备字体**作为**抗锯齿**字段，并确保直接下方的**可选中**图标未被选中。所有这些设置都在前面的屏幕截图中显示。
- en: Finally, expand the **PARAGRAPH** section. Select **Align center** for the **Format**
    field and **Multiline** from the **Behavior** field's drop-down box.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，展开**段落**部分。将**格式**字段选择为**居中对齐**，并将**行为**字段的下拉框选择为**多行**。
- en: Save your FLA.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的FLA。
- en: Publish the FLA and install the IPA on your device.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并在您的设备上安装IPA。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Although Flash can embed fonts directly within your SWF, iOS provides its own,
    which can be used instead. These are known as **device fonts** and using them
    carries a number of advantages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flash可以直接在您的SWF中嵌入字体，但iOS提供了自己的字体，可以替代使用。这些被称为**设备字体**，使用它们具有许多优点：
- en: The final size of your app will be reduced as there will be no need for Flash
    to include any of the font's glyphs directly within your SWF
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应用的最终大小将会减小，因为不再需要Flash将字体符号直接包含在您的SWF中。
- en: It will guarantee that the font renders identically to other iOS apps that use
    it
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将确保字体渲染与其他使用它的iOS应用完全相同
- en: Device fonts render to the screen faster than fonts embedded by Flash
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备字体比Flash嵌入的字体在屏幕上渲染得更快
- en: 'Device fonts have a few drawbacks too, which might dictate whether or not you
    can use them in your project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设备字体也有一些缺点，这可能会决定您是否可以在项目中使用它们：
- en: Alpha transparency can't be applied directly to your text
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法直接将透明度应用于您的文本
- en: Embedded fonts will not render if the text field has been rotated
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本字段已旋转，则嵌入的字体将无法渲染
- en: If you select a font that is available on the device, then ensure that **Use
    device fonts** is selected from the **Anti-alias** field. The fonts must also
    be installed on your development computer or you won't be able to select them
    from Flash Professional.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择设备上可用的字体，请确保从**抗锯齿**字段中选择**使用设备字体**。字体还必须安装到您的开发计算机上，否则您将无法从Flash Professional中选择它们。
- en: Flash can't stop you from selecting a font that is not actually installed on
    your device—there is no way for it to tell. If a font you selected isn't available,
    then all text fields that require its use will default to **_sans**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Flash无法阻止您选择未实际安装到设备上的字体——它无法判断。如果您选择的字体不可用，则所有需要使用该字体的文本字段将默认为**_无衬线**。
- en: 'Device fonts can be used with all three classic text types: static, dynamic,
    and input text.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设备字体可以与所有三种经典文本类型一起使用：静态、动态和输入文本。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Choosing the correct fonts for your application is important. First you need
    to know which fonts are actually available.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序选择正确的字体很重要。首先，您需要知道哪些字体实际上是可用的。
- en: Device fonts on iOS
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS上的设备字体
- en: Not being able to tell from Flash Professional's IDE which fonts are actually
    embedded on your device can be problematic. Fortunately, there are several apps
    that list the fonts installed on a device and let you preview them at various
    point sizes. Most will also let you enter and preview your own text.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无法从Flash Professional的IDE中判断哪些字体实际上已嵌入到您的设备中可能会带来问题。幸运的是，有几个应用程序可以列出设备上安装的字体，并允许您以各种点大小预览它们。大多数应用程序还允许您输入并预览自己的文本。
- en: Two apps worth taking a look at are **Fast Fonts** and **Fonts**. Both are free
    and can be downloaded from iTunes or the App Store.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的两个应用程序是**Fast Fonts**和**Fonts**。两者都是免费的，可以从iTunes或App Store下载。
- en: Be careful, the number of installed fonts varies across devices and versions
    of iOS. For example, on iOS 4.3, 40 font families are installed on iPhone whereas
    iPad has 57\. Check the availability of a font across all devices you wish to
    target before using it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，安装的字体数量在不同设备和iOS版本之间有所不同。例如，在iOS 4.3中，iPhone上安装了40种字体家族，而iPad则有57种。在使用之前，请检查您希望针对的所有设备上字体的可用性。
- en: 'The following are a few device fonts that are commonly used:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常用设备字体：
- en: 'Serif: Times New Roman, Georgia, and _serif'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宋体：Times New Roman, Georgia, 和 _宋体
- en: 'Sans-serif: Helvetica, Arial, Verdana, Trebuchet, Tahoma, and _sans'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无衬线：Helvetica, Arial, Verdana, Trebuchet, Tahoma, 和 _无衬线
- en: 'Fixed-width: Courier, Courier New, and _typewriter'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等宽：Courier, Courier New, 和 _打字机
- en: For a complete list of the fonts supported on the most recent version of iOS,
    take a look at the iOS Fonts website at [http://iosfonts.com.](http://iosfonts.com.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取iOS最新版本上支持的所有字体的完整列表，请查看[iOS Fonts网站](http://iosfonts.com.)。
- en: Enumerating the available device fonts
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列举可用的设备字体
- en: 'It is possible to determine the fonts that are installed on a device. The following
    is a simple code example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以确定设备上安装的字体。以下是一个简单的代码示例：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By passing `true` to the static `Font.enumerateFonts()` method, you can retrieve
    an array of `Font` instances that represent the device's embedded fonts. Simply
    query an instance's `fontName, fontStyle`, and `fontType` properties to find out
    more about the font it represents.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`true`传递给静态`Font.enumerateFonts()`方法，您可以检索一个表示设备嵌入字体的`Font`实例数组。只需查询实例的`fontName,
    fontStyle`, 和 `fontType`属性，就可以了解更多关于该字体代表的信息。
- en: Also, you will need to import `flash.text.Font` before using the `Font` class.
    To find out more about each property, perform a search for the `Font` class within
    Adobe Community Help.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您在使用`Font`类之前需要导入`flash.text.Font`。要了解更多关于每个属性的信息，请在Adobe Community Help中搜索`Font`类。
- en: Pixel density
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素密度
- en: The pixel density of your iOS device is likely to be higher than that of a typical
    monitor. Font sizes that look adequate when working within Flash Professional
    could potentially be too small when viewed on an actual device. This is particularly
    true when targeting the iPhone 4/4S's Retina display. An app such as Fast Fonts
    will help you select a suitable size directly from your device. Try not to use
    a point size lower than 14.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您的iOS设备的像素密度可能比典型监视器要高。在Flash Professional中工作时看起来合适的字体大小，在实际设备上可能太小。这尤其适用于针对iPhone
    4/4S的Retina显示屏。Fast Fonts等应用程序可以帮助您直接从您的设备中选择合适的大小。尽量不使用小于14磅的点大小。
- en: TLF text
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLF文本
- en: Flash Professional CS5 introduced a new text engine called **Text Layout Framework
    (TLF).** While TLF provides superior text layout features compared to the previous
    classic text engine, it is not recommended that you use it when targeting iOS
    due to the framework's heavy performance constraints. TLF text will not be covered
    in this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Flash Professional CS5引入了一个名为**文本布局框架（TLF）**的新文本引擎。虽然TLF与之前的经典文本引擎相比提供了更优越的文本布局功能，但由于框架的性能限制较重，不建议在针对iOS时使用它。本书不会涉及TLF文本。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using embedded fonts within text fields*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在文本字段中使用嵌入的字体*'
- en: Using embedded fonts within text fields
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文本字段中使用嵌入的字体
- en: It is likely that you will eventually want to make use of a font that isn't
    installed on your device. When this is the case, you can embed the font allowing
    it to be rendered correctly within your app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您最终可能需要使用未安装在您的设备上的字体。在这种情况下，您可以嵌入字体，使其在您的应用中正确渲染。
- en: Let us see how this is done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Launch Flash Professional and open `chapter7\recipe2\recipe.fla` from the book's
    accompanying code bundle. The FLA's stage is empty but its AIR for iOS settings
    have already been applied letting you easily publish once you are ready.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Flash Professional，并从书籍配套代码包中打开`chapter7\recipe2\recipe.fla`。FLA的舞台是空的，但其AIR
    for iOS设置已经应用，一旦您准备好，您可以轻松发布。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The Impact font isn't installed on iOS devices. Let us create a text field that
    makes use of it by embedding the font directly within your app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备上未安装Impact字体。让我们创建一个文本字段，通过直接在您的应用中嵌入字体来使用它。
- en: Select the **Text Tool (T)** and draw a text field on the stage.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文本工具（T）**并在舞台上绘制一个文本字段。
- en: Enter **Flash iOS Apps Cookbook** into the text field.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本字段中输入**Flash iOS Apps Cookbook**。
- en: From the **Properties** panel, select **Classic Text** and **Dynamic Text**
    from the two top-most drop-down boxes.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**面板中，从最上面的两个下拉框中选择**经典文本**和**动态文本**。
- en: Position the text field at (21,52). Set its width and height to 278 and 240
    respectively.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本字段定位在(21,52)。将其宽度和高度分别设置为278和240。
- en: Expand the **CHARACTER** section within the Properties panel. Set the **Family**
    field to **Impact**, the **Size** to **60.0** pt, and change the font color to
    black. Also, ensure that the **Selectable** icon is not selected.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性面板中展开**字符**部分。将**家族**字段设置为**Impact**，将**大小**设置为**60.0** pt，并将字体颜色更改为黑色。同时，确保未选中**可选取**图标。
- en: Staying within the **CHARACTER** section, set the **Anti-alias** field to **Anti-alias
    for readability**. A **Font Embedding Warning** dialog box may appear stating
    that you need to select the fonts and characters to embed. If it does, then click
    on its **Embed** button to open the **Font Embedding** panel. If it doesn't, then
    simply click on the **Embed** button next to the **Style** field to open the panel
    as shown in the following screenshot:![How to do it...](img/1383_07_02.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**字符**部分中保持，将**抗锯齿**字段设置为**可读性抗锯齿**。可能会出现一个**字体嵌入警告**对话框，指出您需要选择要嵌入的字体和字符。如果是这样，请点击其**嵌入**按钮打开**字体嵌入**面板。如果不是，请简单地点击**样式**字段旁边的**嵌入**按钮打开面板，如图所示：![如何做到这一点...](img/1383_07_02.jpg)
- en: From the **Font Embedding** panel, check the **Uppercase [A..Z]** and **Lowercase
    [a..z]** checkboxes within the **Character ranges** list. Click on the **OK**
    button to close the panel.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**字体嵌入**面板中，在**字符范围**列表中检查**大写[A..Z]**和**小写[a..z]**复选框。点击**确定**按钮关闭面板。
- en: Now expand the **PARAGRAPH** section within the **Properties** panel. Select
    **Align center** for the **Format** field and **Multiline** from the **Behavior**
    field's drop-down box.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在**属性**面板中展开**段落**部分。将**格式**字段选择为**居中对齐**，并将**行为**字段的下拉框选择为**多行**。
- en: Save your FLA.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的FLA文件。
- en: Publish the FLA and install the IPA on your device.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并在您的设备上安装IPA。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Any font installed on your computer can be embedded within your SWF. This will
    allow the font to be rendered correctly within your app, even if it is not available
    directly from your device.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您计算机上安装的任何字体都可以嵌入到您的SWF中。这将允许字体在您的应用程序中正确渲染，即使它无法直接从您的设备获取。
- en: You can manage the fonts you would like to embed from the Font Embedding panel,
    which is launched by clicking on the **Embed** button on the Properties panel.
    From here you can also set the range of characters that you wish to include for
    a particular font. It is important you select only the characters that are required
    as your app's file size will increase with the number of character glyphs you
    add. Additionally, you can export fonts for ActionScript usage from this panel
    too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从字体嵌入面板管理您想要嵌入的字体，该面板通过在属性面板上单击**嵌入**按钮启动。从这里，您还可以设置您希望包含的特定字体的字符范围。您只选择所需的字符非常重要，因为随着您添加的字形符号数量的增加，您的应用程序文件大小会增加。此外，您还可以从该面板导出用于ActionScript的字体。
- en: Embedded fonts can be used with all classic text field types. However, when
    using a static text field, you have no control over the range of characters that
    get embedded into your SWF. Instead, Flash simply includes the characters that
    appear within the field.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入的字体可以与所有经典文本字段类型一起使用。然而，当使用静态文本字段时，您无法控制嵌入到您的SWF中的字符范围。相反，Flash只是包括字段中出现的字符。
- en: When using embedded fonts, make sure the text field's **Anti-alias** option
    is set to anything other than **Use device fonts**. Setting it to **Use device
    fonts** won't actually embed the font and will instead assume that the font comes
    installed with the device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用嵌入的字体时，请确保文本字段的**抗锯齿**选项设置为除**使用设备字体**之外的内容。将其设置为**使用设备字体**实际上不会嵌入字体，而是假设该字体已安装在与设备一起。
- en: Only embed a font if it isn't available on the device and there isn't a suitable
    alternative device font that you can use. Embedded fonts increase the size of
    your app and in most cases don't render as quickly as device fonts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当字体在设备上不可用且没有合适的替代设备字体可以使用时，才嵌入字体。嵌入的字体会增加应用程序的大小，并且在大多数情况下不如设备字体渲染得快。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You should carefully manage the fonts you embed and try to keep your app's file
    size as small as possible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该仔细管理嵌入的字体，并尽量保持您的应用程序文件大小尽可能小。
- en: Size considerations
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小考虑
- en: Embedding a font is useful when that font isn't available directly from the
    device. However, embedded fonts can impact the final size of your app.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当该字体无法直接从设备获取时，嵌入字体是有用的。然而，嵌入的字体可能会影响您应用程序的最终大小。
- en: You can generate a size report from Flash, which provides a breakdown of all
    the assets within your SWF and how much of the SWF's file size they consume. This
    report will also include size information for each of your embedded fonts. Simply
    move to the **Publish Settings** panel and check the **Generate Size Report**
    checkbox. Flash CS5 users should click on the **Flash** tab within the **Publish
    Settings** panel first.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Flash生成大小报告，该报告提供了您SWF中所有资产的分析以及它们消耗的SWF文件大小。此报告还将包括每个嵌入字体的尺寸信息。只需转到**发布设置**面板并勾选**生成大小报告**复选框。Flash
    CS5用户应首先在**发布设置**面板中的**Flash**选项卡上单击。
- en: When you publish the FLA, a size report will be generated and displayed in the
    **Output** panel. Within the report is a section where you can see a list of the
    embedded fonts and their character sets. The number of bytes used by each font
    is also shown.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发布FLA时，将生成一个大小报告，并在**输出**面板中显示。在报告中有一个部分，您可以查看嵌入的字体及其字符集的列表。每个字体使用的字节数也会显示出来。
- en: 'The following is the result taken from the size report for this recipe''s FLA:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从该食谱的FLA的大小报告中获取的结果：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, approximately 7 KB is required to hold this font's character
    set.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大约需要7 KB来存储这个字体的字符集。
- en: Move back to the Font Embedding panel and include all the font's glyphs by checking
    the first checkbox within the **Character ranges** list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回字体嵌入面板，通过检查**字符范围**列表中的第一个复选框来包含所有字体的字形。
- en: Re-publish the FLA and take a look at the new size report. The font now consumes
    almost 47 KB!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发布FLA并查看新的大小报告。现在字体几乎消耗了47 KB！
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important that you include only fonts that are required and that you keep
    each font's character set to the absolute minimum. Your app's final file size
    can quickly escalate due to poor management of embedded fonts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using device fonts within text fields*'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing text entry
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All iOS devices forego a physical keyboard in favor of a virtual touch-screen
    equivalent. AIR provides virtual keyboard support, allowing a user to enter text
    within an input text field.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point for this recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter7\recipe3\recipe.fla`
    into Flash Professional.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Three static text fields are already sitting on the stage and will act as labels.
    We will add three input text fields to the stage, associating one with each of
    the labels.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the three input text fields:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layer on the timeline by selecting **Insert** | **Timeline** |
    **Layer**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Text Tool (T)** from the Tools panel.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the newly created layer, draw a text field adjacent to the **Forename** text
    field as shown in the following screenshot:![How to do it...](img/1383_07_03.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Properties** panel, select **Classic Text** and **Input Text** from
    the two top-most drop-down boxes.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the Properties panel's **CHARACTER** section. Set the **Family** drop-down
    to **Trebuchet MS**, the **Size** to **20.0** pt, and the text color to black.
    Also, set the **Anti-alias** field to **Use device fonts** and select the **Show
    border around text** icon.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the text field at (114,33) and set its size to 193x28.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **PARAGRAPH** section. Set the **Format** by selecting the **Align
    right** icon, and select **Single line** from the **Behavior** drop-down box.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second input text field similar to the first. Position this one next
    to the **Surname** label at (114,83) and set its **Format** field to **Align center**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally draw a third input text field directly below the **Details** label.
    Position it at (11,174) and set its size to 298x154\. Within the **PARAGRAPH**
    section, select the **Align left** icon for the **Format** field and select **Multiline**
    from the **Behavior** drop-down box.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and install the IPA on your device.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app and enter text into each of the fields.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual keyboard will automatically appear when a user touches any input
    text field. Many of the same features provided by native iOS applications are
    also available directly from your input text fields, including predictive text
    and a button to clear the field. Apps running on iOS 4 or above will also benefit
    from copy and paste support.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The first two fields are single-line and, if text has been entered, will provide
    a clear button on the far-right. However, if the text field is too narrow, the
    button won't be shown.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: When you have finished entering text into a single-line text field, you can
    dismiss the virtual keyboard by tapping the **Done** key or by tapping outside
    the text field.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成在单行文本字段中输入文本后，您可以通过点击**完成**键或点击文本字段外部的任何地方来关闭虚拟键盘。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you built your app using Flash Professional CS5, then you will notice that
    the alignment settings for the **Forename** and **Surname** fields are ignored
    when entering text. When using the AIR 2.0 SDK, input text fields in iOS only
    support left alignment. It is, therefore, recommended that you don't select alternative
    alignments when working with CS5.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Flash Professional CS5构建了您的应用，那么您会注意到，当输入文本时，**名**和**姓**字段的对齐设置被忽略。当使用AIR
    2.0 SDK时，iOS中的输入文本字段仅支持左对齐。因此，当与CS5一起工作时，建议您不要选择其他对齐方式。
- en: When editing the **Details** field, which is multiline, the virtual keyboard
    doesn't provide a **Done** key. Instead a **return** key is found in its place,
    allowing the user to jump to the next line. To dismiss the virtual keyboard when
    editing a multiline input text field, the user must tap anywhere outside the field.
    Unfortunately this is not standard practice for iOS apps and may confuse users.
    Also, make sure you include an area outside the text field that the user can tap.
    If the field is too large, then it may be impossible for the user to dismiss the
    keyboard.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当编辑多行的**详细信息**字段时，虚拟键盘不提供**完成**键。取而代之的是，在其位置上有一个**回车**键，允许用户跳到下一行。要关闭编辑多行输入文本字段时的虚拟键盘，用户必须点击字段外的任何地方。不幸的是，这并不是iOS应用的常规做法，可能会让用户感到困惑。另外，请确保包含一个用户可以点击的区域。如果字段太大，那么用户可能无法关闭键盘。
- en: The position of input text fields is important. If the field you wish to edit
    sits within the area used by the virtual keyboard, then AIR will adjust the position
    of the stage at runtime. You can see this by attempting to edit the **Details**
    input text field. The stage will be panned, ensuring that the field isn't obscured.
    Both the **Forename** and **Surname** input fields, however, are pushed out of
    view to make room for **Details**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本字段的位置很重要。如果您要编辑的字段位于虚拟键盘使用的区域，那么AIR将在运行时调整舞台的位置。您可以通过尝试编辑**详细信息**输入文本字段来看到这一点。舞台将被平移，以确保字段不被遮挡。然而，**名**和**姓**输入字段却被推出了视图，为**详细信息**腾出空间。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When designing your application, take into consideration the area used by the
    keyboard and the effects of editing a text field that sits within this area.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计您的应用程序时，请考虑键盘所占用的区域以及在此区域内编辑文本字段的影响。
- en: You should also ensure that the height of your multiline text fields does not
    exceed the height remaining after the virtual keyboard has been raised as text
    field scrolling is not directly provided.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该确保您的多行文本字段的高度不超过虚拟键盘升起后剩余的高度，因为文本字段滚动不是直接提供的。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To improve performance and render quality, use device fonts over embedded fonts
    within your input text fields.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能和渲染质量，请在您的输入文本字段中使用设备字体而不是嵌入的字体。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Activation of the virtual keyboard and its many text editing features comes
    free of charge. But what if you want a little more control?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟键盘及其许多文本编辑功能的激活是免费的。但如果你想要更多的控制呢？
- en: Keyboard types
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键盘类型
- en: Whereas those developing native apps using the iOS SDK can configure the type
    of keyboard that appears, AIR does not currently provide such control when working
    with input text fields. You are limited to two very similar layouts—one for single-line
    input fields and another for multiline.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用iOS SDK开发原生应用的开发者可以配置显示的键盘类型不同，当与输入文本字段一起工作时，AIR目前不提供此类控制。您只能限制为两种非常相似的布局——一个用于单行输入字段，另一个用于多行。
- en: If the virtual keyboard does not meet your requirements, then consider using
    the native iOS text controls provided by AIR 3.0\. Doing so will provide you with
    access to additional keyboard configurations. Refer to the *Using native iOS text
    controls* recipe at the end of this chapter for more detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟键盘不符合您的要求，那么请考虑使用AIR 3.0提供的原生iOS文本控件。这样做将为您提供访问更多键盘配置的权限。有关更多详细信息，请参阅本章末尾的*使用原生iOS文本控件*配方。
- en: Launching the virtual keyboard programmatically
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以编程方式启动虚拟键盘
- en: The virtual keyboard is launched automatically when a user taps on an input
    text field. However, there may be times when you need to launch the keyboard programmatically
    using ActionScript.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击输入文本字段时，虚拟键盘会自动启动。但是，有时您可能需要使用 ActionScript 代码来程序化地启动键盘。
- en: In AIR 2.6 and above, you can force the virtual keyboard to appear by setting
    a text field's `needsSoftKeyboard` property to `true` and then calling its `requestSoftKeyboard()`
    method. The following code is an example that launches the virtual keyboard by
    setting focus on a text field with an instance name of `forename`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AIR 2.6 及以上版本中，您可以通过将文本字段的 `needsSoftKeyboard` 属性设置为 `true` 并调用其 `requestSoftKeyboard()`
    方法来强制虚拟键盘出现。以下是一个示例代码，通过将焦点设置到实例名为 `forename` 的文本字段上来启动虚拟键盘。
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `requestSoftKeyboard()` method returns a Boolean value indicating whether
    or not the virtual keyboard was successfully raised.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestSoftKeyboard()` 方法返回一个布尔值，指示虚拟键盘是否成功弹出。'
- en: If you are using Flash Professional CS5 and AIR 2.0, then you can force the
    virtual keyboard to appear by using the `Stage` class' `focus` property. The following
    code is an example using a text field with an instance name of `forename:`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Flash Professional CS5 和 AIR 2.0，则可以通过使用 `Stage` 类的 `focus` 属性来强制虚拟键盘出现。以下是一个使用实例名为
    `forename:` 的文本字段的示例代码：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember you can retrieve a reference to the stage from any `DisplayObject`
    including your document class. The `DisplayObject` class provides a `stage` property
    that you can access.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您可以从任何 `DisplayObject`（包括您的文档类）中检索到舞台的引用。`DisplayObject` 类提供了一个 `stage` 属性，您可以访问它。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Capturing text input*'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捕获文本输入*'
- en: '*Configurable panning with virtual keyboard activation*'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可配置的滚动与虚拟键盘激活*'
- en: '*Using native iOS text controls*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用原生 iOS 文本控件*'
- en: Capturing text input
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获文本输入
- en: You can obtain text stored within any non-static text field. This is particularly
    useful for input text fields where an app may want to immediately respond to the
    user's input or collect the information for use later.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以获取任何非静态文本字段中存储的文本。这对于输入文本字段尤其有用，因为应用程序可能希望立即响应用户的输入或收集信息以供以后使用。
- en: This recipe will show you how to capture user input.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何捕获用户输入。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter7\recipe4\recipe.fla`
    into Flash Professional.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍的配套代码包中，将 `chapter7\recipe4\recipe.fla` 打开到 Flash Professional 中。
- en: An input text field named `submit` is sitting on the stage. Beneath it is a
    dynamic text field named `echo`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `submit` 的输入文本字段位于舞台上。在其下方是一个名为 `echo` 的动态文本字段。
- en: We will write some ActionScript to grab any text that the user enters into the
    `submit` field and display it within the `echo` field.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些 ActionScript 代码来捕获用户在 `submit` 字段中输入的任何文本，并在 `echo` 字段中显示它。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a document class named `Main`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Main` 的文档类。
- en: 'Within the class, listen for `FocusEvent.FOCUS_OUT` being dispatched from the
    `submit` input field. You will also need to add an import statement for the `FocusEvent`
    class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中监听 `submit` 输入字段发出的 `FocusEvent.FOCUS_OUT` 事件。您还需要添加对 `FocusEvent` 类的导入语句：
- en: '[PRE4]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add a handler for the `FOCUS_OUT` event:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个处理 `FOCUS_OUT` 事件的处理器：
- en: '[PRE5]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the class and when prompted name the file `Main.as`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类，并在提示时将文件命名为 `Main.as`。
- en: Finally save and compile the FLA. Test the app on your device.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后保存并编译 FLA 文件。在您的设备上测试应用程序。
- en: Any text you enter into the input text field will be echoed to the dynamic text
    field below it. This will happen whenever you tap outside the input field.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您在输入文本字段中输入的任何文本都会被回显到下面的动态文本字段中。这将在您点击输入字段外部时发生。
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Both dynamic and input fields provide a `text` property that can be used to
    get or set their current text. However, before we can obtain the `submit` field''s
    text, we need to know when the user has actually finished typing. We can tell
    this by listening for the `FOCUS_OUT` event, which is dispatched by an input text
    field in response to the following user actions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 动态字段和输入字段都提供了一个 `text` 属性，可以用来获取或设置它们的当前文本。然而，在我们能够获取 `submit` 字段的文本之前，我们需要知道用户是否已经完成输入。我们可以通过监听
    `FOCUS_OUT` 事件来判断，该事件是由输入文本字段在用户执行以下操作时触发的：
- en: The user touches the screen anywhere outside the text field's bounds
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在文本字段边界之外的屏幕上触摸
- en: The user taps the virtual keyboard's **Done** key
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击虚拟键盘的 **完成** 键
- en: 'Within this recipe''s code, the `focusLost()` handler responds to the `submit`
    field''s `FOCUS_OUT` event. It sets the text within the `echo` field to that of
    the `submit` field. The following is the handler''s code again:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的代码中，`focusLost()`处理程序响应`submit`字段的`FOCUS_OUT`事件。它将`echo`字段中的文本设置为`submit`字段的文本。以下又是处理程序的代码：
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `submit` field is actually accessed through the `FocusEvent` parameter''s
    `target` property. We can do this because the `FOCUS_OUT` event was dispatched
    from the `submit` field making it the event''s target. Alternatively, we could
    have ignored the actual `FocusEvent` parameter and accessed the `submit` field
    directly by using the following code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`字段实际上是通过`FocusEvent`参数的`target`属性访问的。我们可以这样做，因为`FOCUS_OUT`事件是从`submit`字段发出的，使其成为事件的目标。或者，我们也可以忽略实际的`FocusEvent`参数，直接使用以下代码片段直接访问`submit`字段：'
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the recipe has shown, the mechanics of retrieving and setting text within
    fields is trivial. When capturing a user's text input, however, you first need
    to make sure the user has finished typing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如食谱所示，在字段中检索和设置文本的机制是微不足道的。然而，在捕获用户的文本输入时，您首先需要确保用户已经完成输入。
- en: For more information perform a search for `flash.text.TextField` and `flash.events.FocusEvent`
    within Adobe Community Help.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请在Adobe社区帮助中搜索`flash.text.TextField`和`flash.events.FocusEvent`。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Before we move on, the following is some additional information.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，以下是一些额外的信息。
- en: Listening for focus
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听焦点
- en: As well as `FocusEvent.FOCUS_OUT`, you can also listen for the `FOCUS_IN` event,
    which lets you know when a user has tapped on an input text field. This is ideal
    if you need to carry out any preparation before the user starts entering text.
    For example, you may want to clear a field's current text before the user starts
    typing. Let us go ahead and implement this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`FocusEvent.FOCUS_OUT`，您还可以监听`FOCUS_IN`事件，这会告诉您用户何时触摸输入文本字段。如果您需要在用户开始输入文本之前执行任何准备工作，这很理想。例如，您可能想在用户开始键入之前清除字段中的当前文本。让我们继续实现这一点。
- en: 'Within your document class'' constructor, listen for the `FOCUS_IN` event:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的文档类的构造函数中，监听`FOCUS_IN`事件：
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now add a handler for the event, which simply clears the text field:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一个事件处理程序，它简单地清除文本字段：
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the class and test the latest version of the app on your device.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 保存类并测试您设备上最新版本的app。
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Providing text entry*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供文本输入*'
- en: Configurable panning with virtual keyboard activation
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置虚拟键盘激活时的平移
- en: The virtual keyboard appears automatically when a user touches an input text
    field. If the text field sits within the region used by the keyboard, then the
    stage will automatically pan to prevent the text field from being obscured. However,
    it is possible to switch off this default behavior and modify the layout yourself
    in response to the keyboard being activated.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户触摸输入文本字段时，虚拟键盘会自动出现。如果文本字段位于键盘使用的区域中，则舞台将自动平移以防止文本字段被遮挡。然而，可以关闭此默认行为并自行修改布局以响应键盘的激活。
- en: The steps covered here are applicable only to those using Flash Professional
    CS5.5 and AIR 2.6 or above.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的步骤仅适用于使用Flash Professional CS5.5和AIR 2.6或更高版本的用户。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个FLA作为起点。
- en: From the book's accompanying code bundle, open `chapter7\recipe5\recipe.fla`
    into Flash Professional.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将`chapter7\recipe5\recipe.fla`打开到Flash Professional中。
- en: Centered on the stage is an input text field named `field`. We will write some
    ActionScript to reposition this text field when the virtual keyboard is activated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 舞台中心是一个名为`field`的输入文本字段。我们将编写一些ActionScript来在虚拟键盘激活时重新定位此文本字段。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First, you will need to switch off automatic panning from the application descriptor
    file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要从应用程序描述文件中关闭自动平移。
- en: Select **File** | **Open** from Flash Professional CS5.5\. From the file browser,
    select `recipe-app.xml`, which can be found within the same folder as your FLA.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Flash Professional CS5.5中选择**文件** | **打开**。从文件浏览器中，选择与FLA相同的文件夹中的`recipe-app.xml`。
- en: 'Add the following line to the descriptor file''s XML:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到描述文件的XML中：
- en: '[PRE10]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Now, create a document class for your FLA and name it `Main`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为您的FLA创建一个文档类，并将其命名为`Main`。
- en: 'Add the following import statements:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入语句：
- en: '[PRE11]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Within the constructor, listen for the virtual keyboard being activated and
    deactivated:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，监听虚拟键盘的激活和关闭：
- en: '[PRE12]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a handler for the `SOFT_KEYBOARD_ACTIVATE` event. It will be called when
    the virtual keyboard has been activated and will position the input text field
    outside of the keyboard''s bounds:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SOFT_KEYBOARD_ACTIVATE`事件添加一个处理程序。当虚拟键盘被激活时，它将被调用，并将输入文本字段定位在键盘边界之外：
- en: '[PRE13]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `activate()` handler calculates the number of pixels the text field needs
    to be moved by vertically in order to be positioned outside the keyboard''s bounding
    area. This value is stored within a member variable named `offset`. Declare the
    `offset` member variable within your class:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`activate()`处理程序计算文本字段需要垂直移动多少像素才能定位在键盘边界区域外。这个值存储在一个名为`offset`的成员变量中。在你的类中声明`offset`成员变量：'
- en: '[PRE14]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need to place the text field back in its original position when
    the keyboard is removed. The handler for the `SOFT_KEYBOARD_DEACTIVATE` event
    will use the `offset` member variable to take care of this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当键盘移除时，我们需要将文本字段放回其原始位置。`SOFT_KEYBOARD_DEACTIVATE`事件的处理程序将使用`offset`成员变量来处理这个问题：
- en: '[PRE15]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the class and when prompted, name the file `Main.as`. Also save your FLA.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存该类，并在提示时将文件命名为`Main.as`。也要保存您的FLA文件。
- en: Publish the app and test it on your device.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布应用程序并在您的设备上测试它。
- en: When you select the input text field, the virtual keyboard will be shown and
    the field will be repositioned directly above it. Tapping outside the field will
    place it back in its original position after the keyboard has left the screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择输入文本字段时，虚拟键盘将会显示，并且字段将被重新定位在它上方。在字段外轻触会将它放回键盘离开屏幕后的原始位置。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Normally the stage is automatically panned if the virtual keyboard obscures
    the input text field that has focus. However, we disabled this default behavior
    by setting the `softKeyboardBehavior` element in the application descriptor file
    to `none:`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果虚拟键盘遮挡了具有焦点的输入文本字段，舞台会自动平移。然而，我们通过将应用程序描述文件中的`softKeyboardBehavior`元素设置为`none:`来禁用了这种默认行为：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term **Soft Keyboard** refers to a software keyboard, which is AIR's generic
    term for the virtual keyboard used by iOS.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**软键盘**这个术语指的是软件键盘，它是AIR对iOS使用的虚拟键盘的通用术语。'
- en: With automatic panning switched off, we can simply change the application's
    layout whenever the user taps on an input text field, and change it back when
    the user has finished typing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭自动平移后，我们可以在用户轻触输入文本字段时更改应用程序的布局，并在用户完成输入后将其改回。
- en: 'In order to do this, we listened for the following two events being dispatched
    from the stage:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们监听了以下两个从舞台发出的事件：
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE`'
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE`'
- en: The `SOFT_KEYBOARD_ACTIVATE` event is fired when the virtual keyboard appears
    on screen. It is in response to this event that we reposition the input text field.
    When the user taps outside an input text field or presses the **Done** key, the
    virtual keyboard is dismissed and `SOFT_KEYBOARD_DEACTIVATE` is dispatched. When
    we capture this event, we place the input text field back in its original position.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当虚拟键盘出现在屏幕上时，会触发`SOFT_KEYBOARD_ACTIVATE`事件。正是响应这个事件，我们重新定位输入文本字段。当用户在输入文本字段外轻触或按下**完成**键时，虚拟键盘会被关闭，并发出`SOFT_KEYBOARD_DEACTIVATE`事件。当我们捕获这个事件时，我们将输入文本字段放回其原始位置。
- en: Although it is perfectly acceptable to hard-code the positions of the text field
    for these two events, our example code goes a little further and dynamically shifts
    the text field away from the area occupied by the keyboard, before shifting it
    back once the keyboard is dismissed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为这两个事件硬编码文本字段的定位是完全可以接受的，但我们的示例代码更进一步，在键盘关闭后动态地将文本字段移出键盘占据的区域，然后再将其移回。
- en: 'It does this by first checking to see if the input text field is within the
    keyboard''s bounding region. If so it positions the text field above the keyboard
    by calculating how far it needs to be offset by. The following is the code again:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先检查输入文本字段是否在键盘的边界区域内。如果是的话，它会通过计算需要偏移多少来将文本字段定位在键盘上方。以下又是代码：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The virtual keyboard's bounding region is retrieved from `Stage.softKeyboardRect`
    and represents the area of the stage that is covered by the virtual keyboard.
    Be careful when using this property as it will return a size of zero when the
    keyboard is not visible. Also notice that the offset is stored within our `offset`
    member variable and will be set to zero if the text field doesn't fall within
    the keyboard's bounds.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟键盘的边界区域是从 `Stage.softKeyboardRect` 获取的，它表示被虚拟键盘覆盖的舞台区域。使用此属性时要小心，因为它在键盘不可见时将返回零的大小。此外，请注意，偏移量存储在我们的
    `offset` 成员变量中，如果文本字段不在键盘的边界内，它将被设置为零。
- en: 'Finally, when the virtual keyboard is dismissed, we use the value of the `offset`
    member variable to shift the text field back:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当虚拟键盘关闭时，我们使用 `offset` 成员变量的值将文本字段移回：
- en: '[PRE18]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For more information, perform a search for `flash.events.SoftKeyboardEvent`
    and `Stage.softKeyboardRect` within Adobe Community Help.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请在 Adobe Community Help 中搜索 `flash.events.SoftKeyboardEvent` 和 `Stage.softKeyboardRect`。
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may find the following information of interest.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对以下信息感兴趣。
- en: Related object
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关对象
- en: The `SoftKeyboardEvent` class provides the `relatedObject` property, which holds
    the `InteractiveObject` that previously had focus. This is useful when listening
    for `SoftKeyboardEvent.DEACTIVATE` as you will be able to determine which input
    text field the user was last editing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoftKeyboardEvent` 类提供了 `relatedObject` 属性，它包含之前有焦点的 `InteractiveObject`。当你监听
    `SoftKeyboardEvent.DEACTIVATE` 时，这很有用，因为你将能够确定用户最后编辑的是哪个输入文本字段。'
- en: Updating dynamic text fields
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新动态文本字段
- en: Rendering text is expensive and can reduce the overall performance of your app.
    This is particularly noticeable on older devices such as the first and second-generation
    iPhone and iPod touch where every CPU cycle counts. Minimize the amount of text
    you update and the frequency with which these updates take place.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染文本很昂贵，可能会降低应用程序的整体性能。这在第一代和第二代 iPhone 和 iPod touch 等较老设备上尤为明显，因为每个 CPU 周期都很重要。尽量减少更新的文本数量和更新频率。
- en: Let us look at ways to do this.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided at `chapter7\recipe6\recipe.fla` within the book's
    accompanying code bundle.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍的配套代码包中，提供了一个 FLA 文件，位于 `chapter7\recipe6\recipe.fla`。
- en: You will find two text fields sitting on the stage. The first is static and
    contains the text **Elapsed Time:**. The second is dynamic, contains a zero and
    has an instance name of `timerField`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在舞台上找到两个文本字段。第一个是静态的，包含文本 **已过时间:**。第二个是动态的，包含一个零，并且有一个实例名称 `timerField`。
- en: We will write some ActionScript to continuously update the `timerField` with
    the number of seconds that have elapsed since the app was launched.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些 ActionScript 代码，以持续更新 `timerField`，显示自应用程序启动以来已过的秒数。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let us go ahead and do this by performing the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤进行操作：
- en: Create a document class and named it `Main`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为 `Main`。
- en: 'We will require two member variables. One to store the time the app was launched
    and another to store the number of seconds that have elapsed. Let us also initialize
    both variables within the class'' constructor:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要两个成员变量。一个用于存储应用程序启动时的时间，另一个用于存储已过秒数。让我们也在类的构造函数中初始化这两个变量：
- en: '[PRE19]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will use a loop to calculate the number of seconds that have elapsed and
    update the `timerField` with that value. The loop will be called on every frame
    redraw.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用循环来计算已过的秒数，并使用该值更新 `timerField`。该循环将在每一帧重绘时被调用。
- en: 'First, add a listener for `Event.ENTER_FRAME` and also add an import statement
    for the `Event` class:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，添加一个监听器 `Event.ENTER_FRAME`，并添加一个对 `Event` 类的导入语句：
- en: '[PRE20]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, add the event handler that will act as the update loop:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加将作为更新循环的事件处理程序：
- en: '[PRE21]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save the class and when prompted, name the file `Main.as`. Save the FLA.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类，并在提示时将文件命名为 `Main.as`。保存 FLA 文件。
- en: Compile the app and deploy it to your device.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译应用程序并将其部署到您的设备上。
- en: When you test the app, you should see the dynamic text field continuously update
    with the number of seconds that have elapsed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你测试应用程序时，你应该看到动态文本字段持续更新为已过秒数。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Although the `update()` handler is called on every `ENTER_FRAME`, we only set
    the elapsed time within the text field when it has actually changed. A common
    mistake is to repeatedly write an identical string to a text field, which is unnecessary
    and will degrade performance. We guard against this with the following `if` statement:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在每次`ENTER_FRAME`事件上都会调用`update()`处理程序，但我们只在实际改变时在文本字段中设置经过的时间。一个常见的错误是反复将相同的字符串写入文本字段，这是不必要的，并且会降低性能。我们通过以下`if`语句来防止这种情况：
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Basically the text field only gets updated if the number of seconds that have
    elapsed differs from the value used in the previous call to the loop. For this
    recipe, it means the text field only gets updated once every second rather than
    24 times per second (the FLA's frame rate). This is a significant saving.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，只有当经过的秒数与上一次循环调用中使用的值不同时，文本字段才会更新。对于此配方来说，这意味着文本字段每秒只更新一次，而不是每秒24次（FLA的帧率）。这是一个重大的节省。
- en: 'As well as reducing the frequency with which a text field is updated, we can
    also improve performance by only setting the characters that need to change. The
    two text fields within this recipe could easily have been represented by a single
    field. If we had taken this approach, then the code to update the field would
    have looked like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少文本字段更新的频率外，我们还可以通过仅设置需要更改的字符来提高性能。此配方中的两个文本字段可以很容易地用一个字段表示。如果我们采取这种方法，那么更新字段所需的代码将看起来像这样：
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Of course this is wasteful, as the string **Elapsed Time:** would be written
    to the text field every time. Displaying and updating just the time within its
    own separate text field helped further improve the performance of this recipe's
    app.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是浪费的，因为**经过时间**字符串会每次都写入文本字段。仅在其自己的单独文本字段中显示和更新时间有助于进一步提高此配方应用的性能。
- en: Although these suggestions may seem obvious, they are often overlooked by developers
    used to targeting the Flash and AIR desktop runtimes. Every saving counts when
    developing for iOS and this is equally true for text, which can have a large performance
    impact, even for small amounts of text.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些建议可能看起来很明显，但习惯于针对Flash和AIR桌面运行时的开发者往往会忽略它们。在为iOS开发时，每一项节省都很重要，这对于文本同样适用，即使是少量文本也可能对性能产生重大影响。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following may help you obtain further performance gains.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下可能有助于你获得更多的性能提升。
- en: Device fonts
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备字体
- en: This recipe used embedded fonts. However, an additional saving can be made by
    using the fonts that come installed directly on iOS devices. This will not only
    reduce the size of your SWF but will also increase performance as device fonts
    render to the screen faster than embedded fonts. Also, before embedding a font,
    check to see if it is available on the device.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用了嵌入式字体。然而，通过使用直接安装在iOS设备上的字体，可以进一步节省空间。这不仅会减小你的SWF文件大小，还会提高性能，因为设备字体渲染到屏幕上的速度比嵌入式字体快。此外，在嵌入字体之前，检查该字体是否在设备上可用。
- en: Appending text
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追加文本
- en: 'Appending a string to the end of a text field is another common task that can
    be expensive. It is often done using the concatenation assignment operator (+=)
    and is shown in the following simple example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串追加到文本字段末尾是另一个常见的任务，可能会很昂贵。这通常使用连接赋值运算符（+=）来完成，以下是一个简单的示例：
- en: '[PRE24]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `TextField` class, however, provides `appendText()` which performs this
    operation many times faster:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`TextField`类提供了`appendText()`方法，它执行此操作的速度要快得多：
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you are appending text, then use this method instead of the concatenation
    assignment operator.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在追加文本，那么请使用这种方法而不是连接赋值运算符。
- en: Replacing text fields with bitmaps
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用位图替换文本字段
- en: Where performance is critical, use bitmaps to represent text.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能至关重要的地方，使用位图来表示文本。
- en: As an example, consider a game where the user's score is constantly being updated.
    Using a dynamic text field can hurt performance. Instead, write some ActionScript
    to display and arrange bitmap representations of each number. Although it will
    require more effort to code, using bitmaps will typically outperform fonts, which
    are constructed from complex vector shapes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个用户得分不断更新的游戏。使用动态文本字段可能会损害性能。相反，编写一些ActionScript来显示和排列每个数字的位图表示。虽然这需要更多的编码工作，但通常使用位图会比使用由复杂矢量形状构成的字体表现更好。
- en: Cache as Bitmap
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存为位图
- en: A text field can be cached as a bitmap, preventing it from being re-rendered
    under certain circumstances, and providing a performance boost. Caching of text
    fields cannot be applied from the Flash IDE and instead must be done using ActionScript.
    Use the `cacheAsBitmap` and `cacheAsBitmapMatrix` properties, which are available
    to the `TextField` class. Bitmap caching cannot be directly applied to a static
    text field.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段可以被缓存为位图，防止它在某些情况下被重新渲染，并提供性能提升。文本字段的缓存不能从Flash IDE中应用，而必须使用ActionScript来完成。使用`cacheAsBitmap`和`cacheAsBitmapMatrix`属性，这些属性对`TextField`类可用。位图缓存不能直接应用于静态文本字段。
- en: For more information, refer to the *Using Cache As Bitmap* and *Using Cache
    As Bitmap Matrix* recipes from [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration").
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[第6章](ch06.html "第6章。图形和硬件加速")中的*使用位图缓存*和*使用位图缓存矩阵*配方。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using an update loop, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用更新循环，[第3章](ch03.html "第3章。编写你的第一个应用程序")*'
- en: '*Using device fonts within text fields*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在文本字段中使用设备字体*'
- en: '*Using embedded fonts within text fields*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在文本字段中使用嵌入式字体*'
- en: Using native iOS text controls
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生iOS文本控件
- en: AIR 3.0 introduced the `StageText` class, which provides access to iOS's native
    text-input controls and the ability to customize the virtual keyboard.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: AIR 3.0引入了`StageText`类，它提供了对iOS原生文本输入控件和自定义虚拟键盘的能力。
- en: Let us see how to create a native text input field and specify the type of virtual
    keyboard that is launched when performing text entry.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个原生文本输入字段并指定在执行文本输入时启动的虚拟键盘类型。
- en: The steps covered here are applicable only to those using AIR 3.0 and above.
    If you are using Flash Professional CS5, then you will be unable to attempt this
    recipe as it only supports AIR 2.0.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的步骤仅适用于使用AIR 3.0及以上版本的用户。如果你使用Flash Professional CS5，那么你将无法尝试这个配方，因为它仅支持AIR
    2.0。
- en: Getting ready
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point. From the book's accompanying code
    bundle, open `chapter7\recipe7\recipe.fla` into Flash Professional CS5.5.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个FLA作为起点。从本书的配套代码包中，将`chapter7\recipe7\recipe.fla`打开到Flash Professional
    CS5.5中。
- en: Sitting on the stage is a background bitmap image. We will write some ActionScript
    to overlay a native text input field, which when tapped will launch a virtual
    keyboard configured for entering a person's name.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段上有一个背景位图图像。我们将编写一些ActionScript来叠加一个原生文本输入字段，当点击时将启动一个配置为输入人名的虚拟键盘。
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will make heavy use of the classes found in the `flash.text` package by
    performing the following steps:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤大量使用`flash.text`包中找到的类：
- en: Create a document class and name it `Main`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并将其命名为`Main`。
- en: 'Add the following import statements to the class:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入语句添加到类中：
- en: '[PRE26]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare a `StageText` member variable:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`StageText`成员变量：
- en: '[PRE27]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now within the constructor, create and initialize a native text input field.
    As part of initialization, we will ensure that it contains text prompting the
    user to enter their name:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在构造函数中创建并初始化一个原生文本输入字段。作为初始化的一部分，我们将确保它包含提示用户输入他们名字的文本：
- en: '[PRE28]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In addition, listen for the text field receiving focus when the user touches
    it by adding the highlighted code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，通过添加以下高亮代码来监听用户触摸时文本字段获得焦点的事件：
- en: '[PRE29]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When it receives focus, we will remove the field''s default text, allowing
    the user to enter their name without first having to delete characters. The following
    code snippet is the event handler for this:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它获得焦点时，我们将移除字段的默认文本，使用户能够直接输入他们的名字，而无需先删除字符。以下代码片段是该事件处理程序：
- en: '[PRE30]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save the class and when prompted name the file `Main.as`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类，并在提示时将文件命名为`Main.as`。
- en: Move back to your FLA and save it. Now publish the app and test it on your device.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的FLA并保存它。现在发布应用程序并在你的设备上测试它。
- en: '![How to do it...](img/1383_07_04.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/1383_07_04.jpg)'
- en: Tap the **enter name** text field and use the virtual keyboard to input text.
    Press the **Done** key to commit your changes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**输入名字**文本字段并使用虚拟键盘输入文本。按**完成**键提交更改。
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `StageText` class allows native iOS text input fields to be added to an
    application. Unlike Flash's Classic and TLF text field types, `StageText` provides
    the same user interaction behaviors found on iOS such as magnification, text selection,
    auto-capitalization, auto-correction, and virtual keyboard customization.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageText` 类允许将原生 iOS 文本输入字段添加到应用程序中。与 Flash 的 Classic 和 TLF 文本字段类型不同，`StageText`
    提供了在 iOS 上找到的相同用户交互行为，例如放大、文本选择、自动大写、自动更正和虚拟键盘自定义。'
- en: 'However, while Classic and TLF text fields can be added using the IDE''s Tools
    panel, each `StageText` instance must be added, positioned, and sized programmatically.
    This is shown in the following code snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管可以使用 IDE 的工具面板添加 Classic 和 TLF 文本字段，但每个 `StageText` 实例都必须通过编程方式添加、定位和调整大小。以下代码片段展示了这一点：
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this code snippet, the `stage` property is used to add a text field`—StageText`
    objects can't be added to the display list and instead must be attached directly
    to the stage. The text field's position and size are specified by passing a `Rectangle`
    object to its `viewPort` property. Additionally, all `StageText` instances will
    appear above content in the display list and their depths cannot be ordered. It
    is, therefore, advisable that you avoid overlapping native text fields.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，使用 `stage` 属性添加文本字段——`StageText` 对象不能添加到显示列表中，而必须直接附加到舞台。通过传递一个 `Rectangle`
    对象到其 `viewPort` 属性来指定文本字段的位置和大小。此外，所有 `StageText` 实例都将出现在显示列表中的内容上方，并且它们的深度无法排序。因此，建议您避免重叠原生文本字段。
- en: The `fontFamily` property is used to dictate the device font to use—embedded
    Flash fonts can't be used. When specifying a device font, ensure that it is available
    on all iOS devices you wish to target.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontFamily` 属性用于指定要使用的设备字体——不能使用嵌入的 Flash 字体。在指定设备字体时，请确保它在您希望针对的所有 iOS 设备上可用。'
- en: The current text shown within the native text field can be set using the `text`
    property, and if the field permits user input, then the number of characters can
    be restricted with `maxChars.`
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `text` 属性设置原生文本字段中显示的当前文本，如果字段允许用户输入，则可以使用 `maxChars` 限制字符数。
- en: 'Finally, the type of keyboard that is to be used when entering text is set
    using the `softKeyboardType` property. The keyboard can be further configured
    by using `returnKeyLabel` to specify the label used for its return key:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `softKeyboardType` 属性设置输入文本时要使用的键盘类型。可以通过使用 `returnKeyLabel` 来进一步配置键盘，以指定其返回键的标签：
- en: '[PRE32]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Constants provided by the `SoftKeyboardType` class are used to specify the keyboard
    type, while the `ReturnKeyLabel` class represents the various different labels
    that can be used for the return key. This code specifies a keyboard configured
    for name entry with its return label set to **Done**.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoftKeyboardType` 类提供的常量用于指定键盘类型，而 `ReturnKeyLabel` 类表示可用于返回键的各种不同标签。此代码指定了一个配置为姓名输入的键盘，其返回标签设置为**完成**。'
- en: If the field's `editable` property is set to `true` (it is by default), then
    a virtual keyboard will appear when the user touches it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段的 `editable` 属性设置为 `true`（默认情况下是如此），则当用户触摸它时将显示虚拟键盘。
- en: For more information, perform a search for `flash.text.StageText` within Adobe
    Community Help.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请在 Adobe Community Help 中搜索 `flash.text.StageText`。
- en: There's more...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Before we leave this chapter, here is some additional detail regarding native
    text input fields and the virtual keyboard.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这一章之前，这里有一些关于原生文本输入字段和虚拟键盘的附加细节。
- en: Virtual keyboard types
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟键盘类型
- en: 'The supported virtual keyboard types are specified as public constants within
    the `flash.text.SoftKeyboardType` class and are listed as follows for your convenience:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的虚拟键盘类型在 `flash.text.SoftKeyboardType` 类中指定为公共常量，以下列出以供您方便参考：
- en: '`CONTACT:` Designed for entering a person''s name or phone number'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTACT:` 适用于输入人名或电话号码'
- en: '`DEFAULT:` The default keyboard configuration'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT:` 默认键盘配置'
- en: '`EMAIL:` This configuration is suited to the entry of email addresses'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL:` 此配置适用于电子邮件地址的输入'
- en: '`NUMBER:` A numeric keypad'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NUMBER:` 数字键盘'
- en: '`PUNCTUATION:` Designed for text entry that includes punctuation'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUNCTUATION:` 适用于包含标点的文本输入'
- en: '`URL:` Optimized for URL entry'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL:` 优化用于 URL 输入'
- en: Return key label types
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回键标签类型
- en: 'The `flash.text.ReturnKeyLabel` class provides the following constants, which
    can be used to set the virtual keyboard''s return key: `DEFAULT, DONE, GO, NEXT`,
    and `SEARCH`.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.text.ReturnKeyLabel` 类提供了以下常量，可用于设置虚拟键盘的返回键：`DEFAULT, DONE, GO, NEXT`
    和 `SEARCH`。'
- en: Enumerating device fonts
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举设备字体
- en: It is possible to enumerate a device's available fonts by passing `true` to
    the `flash.text.Font.enumarateFonts()` static method. This will let you know,
    which strings you can select from when setting a native text input field's `fontFamily`
    property.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `true` 传递给 `flash.text.Font.enumarateFonts()` 静态方法，您可以枚举设备的可用字体。这将让您知道，在设置原生文本输入字段的
    `fontFamily` 属性时，您可以从哪些字符串中进行选择。
- en: Events
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'The following events may be dispatched when interacting with a `StageText`
    instance:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `StageText` 实例交互时，可能会触发以下事件：
- en: '`FocusEvent.FOCUS_IN:` The native text input field has received focus'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FocusEvent.FOCUS_IN:` 原生文本输入字段已获得焦点'
- en: '`FocusEvent:FOCUS_OUT:` The native text input field has lost focus'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FocusEvent:FOCUS_OUT:` 原生文本输入字段已失去焦点'
- en: '`KeyboardEvent.KEY_DOWN:` A virtual key has been pressed'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyboardEvent.KEY_DOWN:` 一个虚拟键已被按下'
- en: '`KeyboardEvent.KEY_UP:` A virtual key as been released'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyboardEvent.KEY_UP:` 一个虚拟键已被释放'
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATING:` The virtual keyboard is being
    activated and is currently moving into view'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATING:` 虚拟键盘正在被激活，并且目前正在进入视图'
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE:` The virtual keyboard has been activated
    and can now be interacted with `SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE:` 虚拟键盘已被激活，现在可以与 `SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE`
    进行交互'
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE:` The virtual keyboard has been
    deactivated'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE:` 虚拟键盘已被停用'
- en: Auto-correction and auto-capitalization
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动更正和自动大写
- en: You can enable iOS's auto-correction and auto-capitalization features by setting
    your `StageText` object's `autoCorrect` and `autoCapitalize` properties to `true`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将您的 `StageText` 对象的 `autoCorrect` 和 `autoCapitalize` 属性设置为 `true` 来启用 iOS
    的自动更正和自动大写功能。
- en: See also
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using device fonts within text fields*'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在文本字段中使用设备字体*'
- en: '*Configurable panning with virtual keyboard activation*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置虚拟键盘激活时的可滚动*'
