- en: Chapter 7. Working with Text and the Virtual Keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using device fonts within text fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using embedded fonts within text fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing text entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing text input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable panning with virtual keyboard activation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating dynamic text fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using native iOS text controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the omission of physical buttons the iPhone has changed forever how many
    of us will enter text. Gone are the fixed keypad configurations of previous phones;
    replaced instead by a touch-screen keyboard that adapts its keys and layout for
    different applications. In addition, iOS comes with a comprehensive library of
    fonts and impressive text rendering capabilities, allowing user input to be shown
    in crisp detail.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will explore Flash's support for the native iOS virtual
    keyboard and learn how to work with text.
  prefs: []
  type: TYPE_NORMAL
- en: Using device fonts within text fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A comprehensive list of fonts is installed on iOS devices and is available for
    use directly within your AIR for iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will take you through the steps required to create a text field
    that uses a device font.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter7\recipe1\recipe.fla`
    into Flash Professional. The FLA's stage is empty but its AIR for iOS settings
    have already been applied, saving you the time and effort when you build and deploy
    it to a device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to take advantage of a device font:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Text Tool (T)** , draw a text field on the stage.![How to do it...](img/1383_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **Flash iOS Apps Cookbook** into the text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Properties** panel, ensure that **Classic Text** and **Dynamic Text**
    are selected from the two top-most drop-down boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the text field at (21,52). Set its width and height to 278 and 240
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **CHARACTER** section within the Properties panel. Set the **Family**
    drop-down to **Trebuchet MS**, the **Size** to **60.0** pt, and change the font
    color to black. Also, select **Use device fonts** for the **Anti-alias** field
    and ensure that the **Selectable** icon directly underneath is not selected. All
    these settings are shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, expand the **PARAGRAPH** section. Select **Align center** for the **Format**
    field and **Multiline** from the **Behavior** field's drop-down box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and install the IPA on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although Flash can embed fonts directly within your SWF, iOS provides its own,
    which can be used instead. These are known as **device fonts** and using them
    carries a number of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The final size of your app will be reduced as there will be no need for Flash
    to include any of the font's glyphs directly within your SWF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will guarantee that the font renders identically to other iOS apps that use
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device fonts render to the screen faster than fonts embedded by Flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Device fonts have a few drawbacks too, which might dictate whether or not you
    can use them in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha transparency can't be applied directly to your text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded fonts will not render if the text field has been rotated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you select a font that is available on the device, then ensure that **Use
    device fonts** is selected from the **Anti-alias** field. The fonts must also
    be installed on your development computer or you won't be able to select them
    from Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Flash can't stop you from selecting a font that is not actually installed on
    your device—there is no way for it to tell. If a font you selected isn't available,
    then all text fields that require its use will default to **_sans**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Device fonts can be used with all three classic text types: static, dynamic,
    and input text.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing the correct fonts for your application is important. First you need
    to know which fonts are actually available.
  prefs: []
  type: TYPE_NORMAL
- en: Device fonts on iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not being able to tell from Flash Professional's IDE which fonts are actually
    embedded on your device can be problematic. Fortunately, there are several apps
    that list the fonts installed on a device and let you preview them at various
    point sizes. Most will also let you enter and preview your own text.
  prefs: []
  type: TYPE_NORMAL
- en: Two apps worth taking a look at are **Fast Fonts** and **Fonts**. Both are free
    and can be downloaded from iTunes or the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful, the number of installed fonts varies across devices and versions
    of iOS. For example, on iOS 4.3, 40 font families are installed on iPhone whereas
    iPad has 57\. Check the availability of a font across all devices you wish to
    target before using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few device fonts that are commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serif: Times New Roman, Georgia, and _serif'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sans-serif: Helvetica, Arial, Verdana, Trebuchet, Tahoma, and _sans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed-width: Courier, Courier New, and _typewriter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of the fonts supported on the most recent version of iOS,
    take a look at the iOS Fonts website at [http://iosfonts.com.](http://iosfonts.com.)
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating the available device fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to determine the fonts that are installed on a device. The following
    is a simple code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By passing `true` to the static `Font.enumerateFonts()` method, you can retrieve
    an array of `Font` instances that represent the device's embedded fonts. Simply
    query an instance's `fontName, fontStyle`, and `fontType` properties to find out
    more about the font it represents.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will need to import `flash.text.Font` before using the `Font` class.
    To find out more about each property, perform a search for the `Font` class within
    Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel density
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pixel density of your iOS device is likely to be higher than that of a typical
    monitor. Font sizes that look adequate when working within Flash Professional
    could potentially be too small when viewed on an actual device. This is particularly
    true when targeting the iPhone 4/4S's Retina display. An app such as Fast Fonts
    will help you select a suitable size directly from your device. Try not to use
    a point size lower than 14.
  prefs: []
  type: TYPE_NORMAL
- en: TLF text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flash Professional CS5 introduced a new text engine called **Text Layout Framework
    (TLF).** While TLF provides superior text layout features compared to the previous
    classic text engine, it is not recommended that you use it when targeting iOS
    due to the framework's heavy performance constraints. TLF text will not be covered
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using embedded fonts within text fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using embedded fonts within text fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is likely that you will eventually want to make use of a font that isn't
    installed on your device. When this is the case, you can embed the font allowing
    it to be rendered correctly within your app.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch Flash Professional and open `chapter7\recipe2\recipe.fla` from the book's
    accompanying code bundle. The FLA's stage is empty but its AIR for iOS settings
    have already been applied letting you easily publish once you are ready.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Impact font isn't installed on iOS devices. Let us create a text field that
    makes use of it by embedding the font directly within your app.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Text Tool (T)** and draw a text field on the stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **Flash iOS Apps Cookbook** into the text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Properties** panel, select **Classic Text** and **Dynamic Text**
    from the two top-most drop-down boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the text field at (21,52). Set its width and height to 278 and 240
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **CHARACTER** section within the Properties panel. Set the **Family**
    field to **Impact**, the **Size** to **60.0** pt, and change the font color to
    black. Also, ensure that the **Selectable** icon is not selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Staying within the **CHARACTER** section, set the **Anti-alias** field to **Anti-alias
    for readability**. A **Font Embedding Warning** dialog box may appear stating
    that you need to select the fonts and characters to embed. If it does, then click
    on its **Embed** button to open the **Font Embedding** panel. If it doesn't, then
    simply click on the **Embed** button next to the **Style** field to open the panel
    as shown in the following screenshot:![How to do it...](img/1383_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Font Embedding** panel, check the **Uppercase [A..Z]** and **Lowercase
    [a..z]** checkboxes within the **Character ranges** list. Click on the **OK**
    button to close the panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now expand the **PARAGRAPH** section within the **Properties** panel. Select
    **Align center** for the **Format** field and **Multiline** from the **Behavior**
    field's drop-down box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and install the IPA on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any font installed on your computer can be embedded within your SWF. This will
    allow the font to be rendered correctly within your app, even if it is not available
    directly from your device.
  prefs: []
  type: TYPE_NORMAL
- en: You can manage the fonts you would like to embed from the Font Embedding panel,
    which is launched by clicking on the **Embed** button on the Properties panel.
    From here you can also set the range of characters that you wish to include for
    a particular font. It is important you select only the characters that are required
    as your app's file size will increase with the number of character glyphs you
    add. Additionally, you can export fonts for ActionScript usage from this panel
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded fonts can be used with all classic text field types. However, when
    using a static text field, you have no control over the range of characters that
    get embedded into your SWF. Instead, Flash simply includes the characters that
    appear within the field.
  prefs: []
  type: TYPE_NORMAL
- en: When using embedded fonts, make sure the text field's **Anti-alias** option
    is set to anything other than **Use device fonts**. Setting it to **Use device
    fonts** won't actually embed the font and will instead assume that the font comes
    installed with the device.
  prefs: []
  type: TYPE_NORMAL
- en: Only embed a font if it isn't available on the device and there isn't a suitable
    alternative device font that you can use. Embedded fonts increase the size of
    your app and in most cases don't render as quickly as device fonts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should carefully manage the fonts you embed and try to keep your app's file
    size as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Size considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedding a font is useful when that font isn't available directly from the
    device. However, embedded fonts can impact the final size of your app.
  prefs: []
  type: TYPE_NORMAL
- en: You can generate a size report from Flash, which provides a breakdown of all
    the assets within your SWF and how much of the SWF's file size they consume. This
    report will also include size information for each of your embedded fonts. Simply
    move to the **Publish Settings** panel and check the **Generate Size Report**
    checkbox. Flash CS5 users should click on the **Flash** tab within the **Publish
    Settings** panel first.
  prefs: []
  type: TYPE_NORMAL
- en: When you publish the FLA, a size report will be generated and displayed in the
    **Output** panel. Within the report is a section where you can see a list of the
    embedded fonts and their character sets. The number of bytes used by each font
    is also shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the result taken from the size report for this recipe''s FLA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, approximately 7 KB is required to hold this font's character
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Move back to the Font Embedding panel and include all the font's glyphs by checking
    the first checkbox within the **Character ranges** list.
  prefs: []
  type: TYPE_NORMAL
- en: Re-publish the FLA and take a look at the new size report. The font now consumes
    almost 47 KB!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important that you include only fonts that are required and that you keep
    each font's character set to the absolute minimum. Your app's final file size
    can quickly escalate due to poor management of embedded fonts.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using device fonts within text fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing text entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All iOS devices forego a physical keyboard in favor of a virtual touch-screen
    equivalent. AIR provides virtual keyboard support, allowing a user to enter text
    within an input text field.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter7\recipe3\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Three static text fields are already sitting on the stage and will act as labels.
    We will add three input text fields to the stage, associating one with each of
    the labels.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the three input text fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layer on the timeline by selecting **Insert** | **Timeline** |
    **Layer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Text Tool (T)** from the Tools panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the newly created layer, draw a text field adjacent to the **Forename** text
    field as shown in the following screenshot:![How to do it...](img/1383_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Properties** panel, select **Classic Text** and **Input Text** from
    the two top-most drop-down boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the Properties panel's **CHARACTER** section. Set the **Family** drop-down
    to **Trebuchet MS**, the **Size** to **20.0** pt, and the text color to black.
    Also, set the **Anti-alias** field to **Use device fonts** and select the **Show
    border around text** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the text field at (114,33) and set its size to 193x28.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **PARAGRAPH** section. Set the **Format** by selecting the **Align
    right** icon, and select **Single line** from the **Behavior** drop-down box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second input text field similar to the first. Position this one next
    to the **Surname** label at (114,83) and set its **Format** field to **Align center**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally draw a third input text field directly below the **Details** label.
    Position it at (11,174) and set its size to 298x154\. Within the **PARAGRAPH**
    section, select the **Align left** icon for the **Format** field and select **Multiline**
    from the **Behavior** drop-down box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and install the IPA on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app and enter text into each of the fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual keyboard will automatically appear when a user touches any input
    text field. Many of the same features provided by native iOS applications are
    also available directly from your input text fields, including predictive text
    and a button to clear the field. Apps running on iOS 4 or above will also benefit
    from copy and paste support.
  prefs: []
  type: TYPE_NORMAL
- en: The first two fields are single-line and, if text has been entered, will provide
    a clear button on the far-right. However, if the text field is too narrow, the
    button won't be shown.
  prefs: []
  type: TYPE_NORMAL
- en: When you have finished entering text into a single-line text field, you can
    dismiss the virtual keyboard by tapping the **Done** key or by tapping outside
    the text field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you built your app using Flash Professional CS5, then you will notice that
    the alignment settings for the **Forename** and **Surname** fields are ignored
    when entering text. When using the AIR 2.0 SDK, input text fields in iOS only
    support left alignment. It is, therefore, recommended that you don't select alternative
    alignments when working with CS5.
  prefs: []
  type: TYPE_NORMAL
- en: When editing the **Details** field, which is multiline, the virtual keyboard
    doesn't provide a **Done** key. Instead a **return** key is found in its place,
    allowing the user to jump to the next line. To dismiss the virtual keyboard when
    editing a multiline input text field, the user must tap anywhere outside the field.
    Unfortunately this is not standard practice for iOS apps and may confuse users.
    Also, make sure you include an area outside the text field that the user can tap.
    If the field is too large, then it may be impossible for the user to dismiss the
    keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The position of input text fields is important. If the field you wish to edit
    sits within the area used by the virtual keyboard, then AIR will adjust the position
    of the stage at runtime. You can see this by attempting to edit the **Details**
    input text field. The stage will be panned, ensuring that the field isn't obscured.
    Both the **Forename** and **Surname** input fields, however, are pushed out of
    view to make room for **Details**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When designing your application, take into consideration the area used by the
    keyboard and the effects of editing a text field that sits within this area.
  prefs: []
  type: TYPE_NORMAL
- en: You should also ensure that the height of your multiline text fields does not
    exceed the height remaining after the virtual keyboard has been raised as text
    field scrolling is not directly provided.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve performance and render quality, use device fonts over embedded fonts
    within your input text fields.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Activation of the virtual keyboard and its many text editing features comes
    free of charge. But what if you want a little more control?
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whereas those developing native apps using the iOS SDK can configure the type
    of keyboard that appears, AIR does not currently provide such control when working
    with input text fields. You are limited to two very similar layouts—one for single-line
    input fields and another for multiline.
  prefs: []
  type: TYPE_NORMAL
- en: If the virtual keyboard does not meet your requirements, then consider using
    the native iOS text controls provided by AIR 3.0\. Doing so will provide you with
    access to additional keyboard configurations. Refer to the *Using native iOS text
    controls* recipe at the end of this chapter for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the virtual keyboard programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The virtual keyboard is launched automatically when a user taps on an input
    text field. However, there may be times when you need to launch the keyboard programmatically
    using ActionScript.
  prefs: []
  type: TYPE_NORMAL
- en: In AIR 2.6 and above, you can force the virtual keyboard to appear by setting
    a text field's `needsSoftKeyboard` property to `true` and then calling its `requestSoftKeyboard()`
    method. The following code is an example that launches the virtual keyboard by
    setting focus on a text field with an instance name of `forename`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `requestSoftKeyboard()` method returns a Boolean value indicating whether
    or not the virtual keyboard was successfully raised.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Flash Professional CS5 and AIR 2.0, then you can force the
    virtual keyboard to appear by using the `Stage` class' `focus` property. The following
    code is an example using a text field with an instance name of `forename:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember you can retrieve a reference to the stage from any `DisplayObject`
    including your document class. The `DisplayObject` class provides a `stage` property
    that you can access.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Capturing text input*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configurable panning with virtual keyboard activation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using native iOS text controls*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing text input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can obtain text stored within any non-static text field. This is particularly
    useful for input text fields where an app may want to immediately respond to the
    user's input or collect the information for use later.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to capture user input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter7\recipe4\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: An input text field named `submit` is sitting on the stage. Beneath it is a
    dynamic text field named `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: We will write some ActionScript to grab any text that the user enters into the
    `submit` field and display it within the `echo` field.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class named `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the class, listen for `FocusEvent.FOCUS_OUT` being dispatched from the
    `submit` input field. You will also need to add an import statement for the `FocusEvent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a handler for the `FOCUS_OUT` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class and when prompted name the file `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally save and compile the FLA. Test the app on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any text you enter into the input text field will be echoed to the dynamic text
    field below it. This will happen whenever you tap outside the input field.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both dynamic and input fields provide a `text` property that can be used to
    get or set their current text. However, before we can obtain the `submit` field''s
    text, we need to know when the user has actually finished typing. We can tell
    this by listening for the `FOCUS_OUT` event, which is dispatched by an input text
    field in response to the following user actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The user touches the screen anywhere outside the text field's bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user taps the virtual keyboard's **Done** key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within this recipe''s code, the `focusLost()` handler responds to the `submit`
    field''s `FOCUS_OUT` event. It sets the text within the `echo` field to that of
    the `submit` field. The following is the handler''s code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `submit` field is actually accessed through the `FocusEvent` parameter''s
    `target` property. We can do this because the `FOCUS_OUT` event was dispatched
    from the `submit` field making it the event''s target. Alternatively, we could
    have ignored the actual `FocusEvent` parameter and accessed the `submit` field
    directly by using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As the recipe has shown, the mechanics of retrieving and setting text within
    fields is trivial. When capturing a user's text input, however, you first need
    to make sure the user has finished typing.
  prefs: []
  type: TYPE_NORMAL
- en: For more information perform a search for `flash.text.TextField` and `flash.events.FocusEvent`
    within Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on, the following is some additional information.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for focus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as `FocusEvent.FOCUS_OUT`, you can also listen for the `FOCUS_IN` event,
    which lets you know when a user has tapped on an input text field. This is ideal
    if you need to carry out any preparation before the user starts entering text.
    For example, you may want to clear a field's current text before the user starts
    typing. Let us go ahead and implement this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within your document class'' constructor, listen for the `FOCUS_IN` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a handler for the event, which simply clears the text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Save the class and test the latest version of the app on your device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Providing text entry*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable panning with virtual keyboard activation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The virtual keyboard appears automatically when a user touches an input text
    field. If the text field sits within the region used by the keyboard, then the
    stage will automatically pan to prevent the text field from being obscured. However,
    it is possible to switch off this default behavior and modify the layout yourself
    in response to the keyboard being activated.
  prefs: []
  type: TYPE_NORMAL
- en: The steps covered here are applicable only to those using Flash Professional
    CS5.5 and AIR 2.6 or above.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter7\recipe5\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Centered on the stage is an input text field named `field`. We will write some
    ActionScript to reposition this text field when the virtual keyboard is activated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you will need to switch off automatic panning from the application descriptor
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **Open** from Flash Professional CS5.5\. From the file browser,
    select `recipe-app.xml`, which can be found within the same folder as your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line to the descriptor file''s XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a document class for your FLA and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the constructor, listen for the virtual keyboard being activated and
    deactivated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a handler for the `SOFT_KEYBOARD_ACTIVATE` event. It will be called when
    the virtual keyboard has been activated and will position the input text field
    outside of the keyboard''s bounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `activate()` handler calculates the number of pixels the text field needs
    to be moved by vertically in order to be positioned outside the keyboard''s bounding
    area. This value is stored within a member variable named `offset`. Declare the
    `offset` member variable within your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to place the text field back in its original position when
    the keyboard is removed. The handler for the `SOFT_KEYBOARD_DEACTIVATE` event
    will use the `offset` member variable to take care of this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class and when prompted, name the file `Main.as`. Also save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the app and test it on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you select the input text field, the virtual keyboard will be shown and
    the field will be repositioned directly above it. Tapping outside the field will
    place it back in its original position after the keyboard has left the screen.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally the stage is automatically panned if the virtual keyboard obscures
    the input text field that has focus. However, we disabled this default behavior
    by setting the `softKeyboardBehavior` element in the application descriptor file
    to `none:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term **Soft Keyboard** refers to a software keyboard, which is AIR's generic
    term for the virtual keyboard used by iOS.
  prefs: []
  type: TYPE_NORMAL
- en: With automatic panning switched off, we can simply change the application's
    layout whenever the user taps on an input text field, and change it back when
    the user has finished typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we listened for the following two events being dispatched
    from the stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SOFT_KEYBOARD_ACTIVATE` event is fired when the virtual keyboard appears
    on screen. It is in response to this event that we reposition the input text field.
    When the user taps outside an input text field or presses the **Done** key, the
    virtual keyboard is dismissed and `SOFT_KEYBOARD_DEACTIVATE` is dispatched. When
    we capture this event, we place the input text field back in its original position.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is perfectly acceptable to hard-code the positions of the text field
    for these two events, our example code goes a little further and dynamically shifts
    the text field away from the area occupied by the keyboard, before shifting it
    back once the keyboard is dismissed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It does this by first checking to see if the input text field is within the
    keyboard''s bounding region. If so it positions the text field above the keyboard
    by calculating how far it needs to be offset by. The following is the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The virtual keyboard's bounding region is retrieved from `Stage.softKeyboardRect`
    and represents the area of the stage that is covered by the virtual keyboard.
    Be careful when using this property as it will return a size of zero when the
    keyboard is not visible. Also notice that the offset is stored within our `offset`
    member variable and will be set to zero if the text field doesn't fall within
    the keyboard's bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when the virtual keyboard is dismissed, we use the value of the `offset`
    member variable to shift the text field back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For more information, perform a search for `flash.events.SoftKeyboardEvent`
    and `Stage.softKeyboardRect` within Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may find the following information of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Related object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SoftKeyboardEvent` class provides the `relatedObject` property, which holds
    the `InteractiveObject` that previously had focus. This is useful when listening
    for `SoftKeyboardEvent.DEACTIVATE` as you will be able to determine which input
    text field the user was last editing.
  prefs: []
  type: TYPE_NORMAL
- en: Updating dynamic text fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering text is expensive and can reduce the overall performance of your app.
    This is particularly noticeable on older devices such as the first and second-generation
    iPhone and iPod touch where every CPU cycle counts. Minimize the amount of text
    you update and the frequency with which these updates take place.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided at `chapter7\recipe6\recipe.fla` within the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: You will find two text fields sitting on the stage. The first is static and
    contains the text **Elapsed Time:**. The second is dynamic, contains a zero and
    has an instance name of `timerField`.
  prefs: []
  type: TYPE_NORMAL
- en: We will write some ActionScript to continuously update the `timerField` with
    the number of seconds that have elapsed since the app was launched.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us go ahead and do this by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and named it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will require two member variables. One to store the time the app was launched
    and another to store the number of seconds that have elapsed. Let us also initialize
    both variables within the class'' constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use a loop to calculate the number of seconds that have elapsed and
    update the `timerField` with that value. The loop will be called on every frame
    redraw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add a listener for `Event.ENTER_FRAME` and also add an import statement
    for the `Event` class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the event handler that will act as the update loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class and when prompted, name the file `Main.as`. Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the app and deploy it to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you test the app, you should see the dynamic text field continuously update
    with the number of seconds that have elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the `update()` handler is called on every `ENTER_FRAME`, we only set
    the elapsed time within the text field when it has actually changed. A common
    mistake is to repeatedly write an identical string to a text field, which is unnecessary
    and will degrade performance. We guard against this with the following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Basically the text field only gets updated if the number of seconds that have
    elapsed differs from the value used in the previous call to the loop. For this
    recipe, it means the text field only gets updated once every second rather than
    24 times per second (the FLA's frame rate). This is a significant saving.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as reducing the frequency with which a text field is updated, we can
    also improve performance by only setting the characters that need to change. The
    two text fields within this recipe could easily have been represented by a single
    field. If we had taken this approach, then the code to update the field would
    have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Of course this is wasteful, as the string **Elapsed Time:** would be written
    to the text field every time. Displaying and updating just the time within its
    own separate text field helped further improve the performance of this recipe's
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Although these suggestions may seem obvious, they are often overlooked by developers
    used to targeting the Flash and AIR desktop runtimes. Every saving counts when
    developing for iOS and this is equally true for text, which can have a large performance
    impact, even for small amounts of text.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following may help you obtain further performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: Device fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe used embedded fonts. However, an additional saving can be made by
    using the fonts that come installed directly on iOS devices. This will not only
    reduce the size of your SWF but will also increase performance as device fonts
    render to the screen faster than embedded fonts. Also, before embedding a font,
    check to see if it is available on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Appending text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Appending a string to the end of a text field is another common task that can
    be expensive. It is often done using the concatenation assignment operator (+=)
    and is shown in the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TextField` class, however, provides `appendText()` which performs this
    operation many times faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you are appending text, then use this method instead of the concatenation
    assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing text fields with bitmaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where performance is critical, use bitmaps to represent text.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a game where the user's score is constantly being updated.
    Using a dynamic text field can hurt performance. Instead, write some ActionScript
    to display and arrange bitmap representations of each number. Although it will
    require more effort to code, using bitmaps will typically outperform fonts, which
    are constructed from complex vector shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Cache as Bitmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A text field can be cached as a bitmap, preventing it from being re-rendered
    under certain circumstances, and providing a performance boost. Caching of text
    fields cannot be applied from the Flash IDE and instead must be done using ActionScript.
    Use the `cacheAsBitmap` and `cacheAsBitmapMatrix` properties, which are available
    to the `TextField` class. Bitmap caching cannot be directly applied to a static
    text field.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, refer to the *Using Cache As Bitmap* and *Using Cache
    As Bitmap Matrix* recipes from [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using an update loop, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using device fonts within text fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using embedded fonts within text fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using native iOS text controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AIR 3.0 introduced the `StageText` class, which provides access to iOS's native
    text-input controls and the ability to customize the virtual keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how to create a native text input field and specify the type of virtual
    keyboard that is launched when performing text entry.
  prefs: []
  type: TYPE_NORMAL
- en: The steps covered here are applicable only to those using AIR 3.0 and above.
    If you are using Flash Professional CS5, then you will be unable to attempt this
    recipe as it only supports AIR 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point. From the book's accompanying code
    bundle, open `chapter7\recipe7\recipe.fla` into Flash Professional CS5.5.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting on the stage is a background bitmap image. We will write some ActionScript
    to overlay a native text input field, which when tapped will launch a virtual
    keyboard configured for entering a person's name.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will make heavy use of the classes found in the `flash.text` package by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import statements to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `StageText` member variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now within the constructor, create and initialize a native text input field.
    As part of initialization, we will ensure that it contains text prompting the
    user to enter their name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, listen for the text field receiving focus when the user touches
    it by adding the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When it receives focus, we will remove the field''s default text, allowing
    the user to enter their name without first having to delete characters. The following
    code snippet is the event handler for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class and when prompted name the file `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move back to your FLA and save it. Now publish the app and test it on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1383_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tap the **enter name** text field and use the virtual keyboard to input text.
    Press the **Done** key to commit your changes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StageText` class allows native iOS text input fields to be added to an
    application. Unlike Flash's Classic and TLF text field types, `StageText` provides
    the same user interaction behaviors found on iOS such as magnification, text selection,
    auto-capitalization, auto-correction, and virtual keyboard customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, while Classic and TLF text fields can be added using the IDE''s Tools
    panel, each `StageText` instance must be added, positioned, and sized programmatically.
    This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the `stage` property is used to add a text field`—StageText`
    objects can't be added to the display list and instead must be attached directly
    to the stage. The text field's position and size are specified by passing a `Rectangle`
    object to its `viewPort` property. Additionally, all `StageText` instances will
    appear above content in the display list and their depths cannot be ordered. It
    is, therefore, advisable that you avoid overlapping native text fields.
  prefs: []
  type: TYPE_NORMAL
- en: The `fontFamily` property is used to dictate the device font to use—embedded
    Flash fonts can't be used. When specifying a device font, ensure that it is available
    on all iOS devices you wish to target.
  prefs: []
  type: TYPE_NORMAL
- en: The current text shown within the native text field can be set using the `text`
    property, and if the field permits user input, then the number of characters can
    be restricted with `maxChars.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the type of keyboard that is to be used when entering text is set
    using the `softKeyboardType` property. The keyboard can be further configured
    by using `returnKeyLabel` to specify the label used for its return key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Constants provided by the `SoftKeyboardType` class are used to specify the keyboard
    type, while the `ReturnKeyLabel` class represents the various different labels
    that can be used for the return key. This code specifies a keyboard configured
    for name entry with its return label set to **Done**.
  prefs: []
  type: TYPE_NORMAL
- en: If the field's `editable` property is set to `true` (it is by default), then
    a virtual keyboard will appear when the user touches it.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, perform a search for `flash.text.StageText` within Adobe
    Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we leave this chapter, here is some additional detail regarding native
    text input fields and the virtual keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual keyboard types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The supported virtual keyboard types are specified as public constants within
    the `flash.text.SoftKeyboardType` class and are listed as follows for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTACT:` Designed for entering a person''s name or phone number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT:` The default keyboard configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL:` This configuration is suited to the entry of email addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NUMBER:` A numeric keypad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUNCTUATION:` Designed for text entry that includes punctuation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL:` Optimized for URL entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return key label types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flash.text.ReturnKeyLabel` class provides the following constants, which
    can be used to set the virtual keyboard''s return key: `DEFAULT, DONE, GO, NEXT`,
    and `SEARCH`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating device fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to enumerate a device's available fonts by passing `true` to
    the `flash.text.Font.enumarateFonts()` static method. This will let you know,
    which strings you can select from when setting a native text input field's `fontFamily`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following events may be dispatched when interacting with a `StageText`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FocusEvent.FOCUS_IN:` The native text input field has received focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FocusEvent:FOCUS_OUT:` The native text input field has lost focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyboardEvent.KEY_DOWN:` A virtual key has been pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyboardEvent.KEY_UP:` A virtual key as been released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATING:` The virtual keyboard is being
    activated and is currently moving into view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE:` The virtual keyboard has been activated
    and can now be interacted with `SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE:` The virtual keyboard has been
    deactivated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-correction and auto-capitalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can enable iOS's auto-correction and auto-capitalization features by setting
    your `StageText` object's `autoCorrect` and `autoCapitalize` properties to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using device fonts within text fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configurable panning with virtual keyboard activation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
