- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines and Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces you to background operations and data manipulations
    with Coroutines and Flow. You’ll also learn how to manipulate and display the
    data using `LiveData` transformations and Kotlin Flow operators.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use Coroutines and Flow to manage
    network calls in the background. You will also be able to manipulate data with
    `LiveData` transformations and Flow operators.
  prefs: []
  type: TYPE_NORMAL
- en: You learned the basics of Android app development and implemented features such
    as RecyclerViews, notifications, fetching data from web services, and services.
    You also gained skills in the best practices for testing and persisting data.
    In the previous chapter, you learned about dependency injection. Now, you will
    learn about background operations and data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Some Android applications work on their own. However, most apps would need a
    backend server to retrieve or process data. These operations may take a while,
    depending on the internet connection, device settings, and server specifications.
    If long-running operations are run in the main **user interface** (**UI**) thread,
    the application will be blocked until the tasks are completed. The application
    might become unresponsive and prompt the user to close and stop using it.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, tasks that can take an indefinite amount of time must be run
    asynchronously. An asynchronous task means it can run in parallel to another task
    or in the background. For example, while fetching data from a data source asynchronously,
    your UI can still be displayed and user interaction can occur.
  prefs: []
  type: TYPE_NORMAL
- en: You can use libraries such as Coroutines and Flow for asynchronous operations.
    We’ll discuss both in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Coroutines on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming `LiveData`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Flow on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/puLUO](https://packt.link/puLUO)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with Coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Using Coroutines on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines were added in Kotlin 1.3 to manage background tasks such as making
    network calls and accessing files or databases. Kotlin coroutines are Google’s
    official recommendation for asynchronous programming on Android. Their Jetpack
    libraries, such as LifeCycle, WorkManager, and Room, now include support for coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: With coroutines, you can write your code in a sequential way. The long-running
    task can be made into a suspending function, which, when called, can pause the
    thread without blocking it. When the suspending function is done, the current
    thread will resume execution. This will make your code easier to read and debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark a function as a suspending function, you can add the `suspend` keyword
    to it; for example, if you have a function that calls the `getMovies` function,
    which fetches `movies` from your endpoint and then displays it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make the `getMovies()` function a suspending function by adding the
    `suspend` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the calling function will invoke `getMovies` and pause. After `getMovies`
    returns a list of movies, it will resume its task and display the movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suspending functions can only be called in other suspending functions or from
    a coroutine. Coroutines have a context, which includes the coroutine dispatcher.
    Dispatchers specify what thread the coroutine will use. There are three dispatchers
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.Main`: Used to run on Android’s main thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.IO`: Used for network, file, or database operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.Default`: Used for CPU-intensive work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change the context for your coroutine, you can use the `withContext` function
    for the code that you want to use a different thread with. For example, in your
    suspending function, `getMovies`, which gets movies from your endpoint, you can
    use `Dispatchers.IO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will cover how to create coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a coroutine with the `async` and `launch` keywords. The `launch`
    keyword creates a coroutine and doesn’t return anything. On the other hand, the
    `async` keyword returns a value that you can get later with the `await` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async` and `launch` keywords must be created from `CoroutineScope`, which
    defines the lifecycle of the coroutine. For example, the coroutine scope for the
    main thread is `MainScope`. You can then create coroutines with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create your own `CoroutineScope` instead of using `MainScope`
    by creating one with `CoroutineScope` and passing in the context for the coroutine.
    For example, to create `CoroutineScope` for use on a network call, you can define
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The coroutine can be canceled when the function is no longer needed, such as
    when you close the activity. You can do that by calling the `cancel` function
    from `CoroutineScope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A ViewModel also has a default `CoroutineScope` for creating coroutines: `viewModelScope`.
    Jetpack’s LifeCycle also has the `lifecycleScope` that you can use. `viewModelScope`
    is canceled when the ViewModel has been destroyed; `lifecycleScope` is also canceled
    when the lifecycle is destroyed. Thus, you no longer need to cancel them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to add coroutines to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding coroutines to your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add coroutines to your project by adding the following code to your
    `app/build.gradle` file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`kotlinx-coroutines-core` is the main library for coroutines, while `kotlinx-coroutines-android`
    adds support for the main Android thread.'
  prefs: []
  type: TYPE_NORMAL
- en: You can add coroutines in Android when making a network call or fetching data
    from a local database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function
    as a suspending function with `suspend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create a coroutine to call the suspending `getMovies` function
    and display the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use LiveData for the response of your coroutines. `LiveData` is
    a Jetpack class that can hold observable data. You can add `LiveData` to your
    Android project by adding the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try to use coroutines in an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.01 – using coroutines in an Android app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this chapter, you will work with an application that displays popular movies
    using The Movie Database API. Go to [https://developers.themoviedb.org](https://developers.themoviedb.org)
    and register for an API key. In this exercise, you will be using coroutines to
    fetch a list of popular movies:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Popular Movies` project in Android Studio in the `Chapter14` directory
    from this book's code repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file and add the `INTERNET` permission inside
    the manifest tag but outside the application tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app/build.gradle` file and add the dependencies for the Kotlin Coroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These will allow you to use coroutines in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add the dependencies for the ViewModel and `LiveData` extension libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `MovieService` interface and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will mark `getPopularMovies` as a suspending function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MovieRepository` and add `apiKey` (with the value from the Movie Database
    API):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `MovieRepository` file, add the movies and error `LiveData` for the
    list of movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the suspending `fetchMovies` function to retrieve the list from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `MovieApplication` and add a property for `movieRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onCreate` function of the `MovieApplication` class and initialize
    `movie``Repository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the contents of `MovieViewModel` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fetchPopularMovies` function has a coroutine, using `viewModelScope`, that
    will fetch the movies from `movieRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainActivity` class. At the end of the `onCreate` function, create
    `movie` **Repository** and `movieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add an observer to `popularMovies` and `error` `LiveData` from
    `movie``ViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will update the activity’s RecyclerView with the movies fetched. The list
    of movies is filtered using Kotlin’s `filter` function to only include movies
    released this year. They are then sorted by popularity using Kotlin’s `sortedByDescending`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You will see that the app will display a list of popular
    movie titles from the current year, sorted by popularity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The app displaying popular movies released this year, sorted
    by popularity](img/B19411_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The app displaying popular movies released this year, sorted by
    popularity
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on a movie, and you will see its details, such as its release date and
    an overview:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – The movie details screen](img/B19411_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – The movie details screen
  prefs: []
  type: TYPE_NORMAL
- en: You have used coroutines and `LiveData` to retrieve and display a list of popular
    movies from a remote data source without blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Before passing `LiveData` into the UI for display, you can also transform the
    data first. You will learn about that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming LiveData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the `LiveData` you pass from the ViewModel to the UI layer needs
    to be processed first before displaying. For example, you can only select a part
    of the data or do some processing on it first. In the previous exercise, you filtered
    the data to only select popular movies from the current year.
  prefs: []
  type: TYPE_NORMAL
- en: To modify `LiveData`, you can use the `Transformations` class. It has two functions,
    `Transformations.map` and `Transformations.switchMap`, that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: '`Transformations.map` modifies the value of `LiveData` into another value.
    This can be used for tasks such as filtering, sorting, or formatting the data.
    For example, you can transform `movieLiveData` into string `LiveData` from the
    movie’s title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When `movieLiveData` changes value, `movieTitleLiveData` will also change based
    on the movie’s title.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `Transformations.switchMap`, you can transform the value of a `LiveData`
    into another `LiveData`. This is used when you want to do a specific task involving
    a database or network operation with the original `LiveData`. For example, if
    you have a `LiveData` representing a movie `id` object, you can transform that
    into movie `LiveData` by applying the `getMovieDetails` function, which returns
    `LiveData` of movie details from the `id` object (such as from another network
    or database call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let’s use `LiveData` transformations on the list of movies fetched using coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.02 – LiveData transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will transform the `LiveData` list of movies before passing
    them to the observers in the `MainActivity` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Popular Movies` project you worked on in the previous exercise in
    Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainActivity` file. In the `movieViewModel.popularMovies` observer
    in the `onCreate` function, remove the filter and the `sortedByDescending` function
    calls. The code should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will now display all movies in the list without them being sorted by popularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You should see all movies (even those from the past year),
    not sorted by popularity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – The app with unsorted popular movies](img/B19411_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – The app with unsorted popular movies
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MovieViewModel` class and update `popularMovies` with `LiveData`
    transformations to filter and sort the movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will select the movies released this year and sort them by title before
    passing them to the UI observer in `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. You will see that the app shows a list of popular movies
    from the current year, sorted by popularity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – The app with the movies released last month sorted by popularity](img/B19411_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – The app with the movies released last month sorted by popularity
  prefs: []
  type: TYPE_NORMAL
- en: You have used `LiveData` transformations to modify the list of movies to select
    only the ones released in the previous month. They were also sorted by popularity
    before passing them to the observers in the UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about Kotlin Flows.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flow on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will look into using Flows for asynchronous programming
    in Android. Flow, an asynchronous stream library built on top of Kotlin Coroutines,
    is ideal for live data updates in your application. Android Jetpack libraries
    include Room, WorkManager, and Jetpack Compose, and third-party libraries support
    Flow.
  prefs: []
  type: TYPE_NORMAL
- en: A Flow of data is represented by the `kotlinx.coroutines.flow.Flow` interface.
    Flows emit multiple values of the same type one at a time. For example, `Flow<String>`
    is a Flow that emits string values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A flow starts to emit values when you call the suspending `collect` function
    from a coroutine or another suspending function. In the following example, the
    `collect` function was called from the coroutine created using the `launch` builder
    of `lifecycleScope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `collect{}` function was called on `viewModel.fetchMovies()`. This
    will start the Flow’s emission of movies; each movie title is then logged.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the `CoroutineContext` where the Flow runs, you can use the `flowOn()`
    function to change the Dispatcher. The previous example can be updated with a
    different Dispatcher, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the Dispatcher for the Flow will be changed to `Dispatchers.IO`.
    Calling `flowOn` will only change the functions before it, not the functions and
    operators after.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about collecting Flows on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting Flows on Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android, Flows are usually collected in the Activity or Fragment for display
    in the UI. Moving the app in the background will not stop the data collection.
    The app must not do so and continue updating the screen to avoid memory leaks
    and prevent wasting resources.
  prefs: []
  type: TYPE_NORMAL
- en: You can safely collect flows in the UI Iayer by manually handling lifecycle
    changes or by using `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`,
    available in the `lifecycle-runtime-ktx` library, starting with version 2.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it in your project, add the following to your `app/build.gradle` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This adds the `lifecycle-runtime-ktx` library to your project, so you can use
    both `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Lifecycle.repeatOnLifecycle(state, block)` will suspend the parent coroutine
    until the lifecycle is destroyed and executes the suspending `block` code when
    the Lifecycle is at least in the `state` provided. The flow will stop when the
    Lifecycle moves out of the state and restart when the lifecycle moves back to
    the state. `Lifecycle.repeatOnLifecycle` must be called on Activity’s `onCreate`
    or on Fragment’s `onViewCreated`.'
  prefs: []
  type: TYPE_NORMAL
- en: When using `Lifecycle.State.STARTED` for `state`, the `repeatOnLifecycle` will
    start Flow collection when the Lifecycle is started and stop when the Lifecycle
    is stopped (`onStop()` is called).
  prefs: []
  type: TYPE_NORMAL
- en: If you use `Lifecycle.State.RESUMED`, the start will be when the Lifecycle is
    resumed, and the stop will be when `onPause` is called or when the Lifecycle is
    paused.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how you can use `Lifecycle.repeatOnLifecycle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this class, `repeatOnLifecycle` with `Lifecycle.State.STARTED` starts collecting
    the Flow of movies when the lifecycle is started and stops when the lifecycle
    is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: '`Flow.flowWithLifecycle` is another way to safely collect Flows in Android.
    It emits values from the Flow and operators preceding the call (the upstream Flow)
    when the lifecycle is at least in the state you set or the default, `Lifecycle.State.STARTED`.
    Internally, it uses `Lifecycle.repeatOnLifecycle`. The following example shows
    how you can use `Flow.flowWithLifecycle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `flowWithLifecycle` with `Lifecycle.State.STARTED` to collect
    the Flow of movies when the lifecycle is started and stop when the lifecycle is
    stopped.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to create Flows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Flows with Flow Builders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create Flows using the Flow Builders from the Kotlin Flow API. The
    following are the Flow Builders you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flow{}`: This creates a new Flow from a suspendable lambda block. You can
    send values using the `emit` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flowOf()`: This creates a Flow from the specified value or the `vararg` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asFlow()`: This is an extension function used to convert a type (sequence,
    array, range, or collection) into a Flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to use the Flow Builders in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `fetchMovies` created a Flow using `flow{}` and emitted each
    movie from the list. The `fetchTop3Titles` function uses `flowOf` to create a
    Flow with the titles of the first three movies. Finally, `fetchMovieIds` converted
    the list of IDs into a Flow of movie IDs using the `asFlow` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about the Kotlin Flow operators you can
    use with Flows.
  prefs: []
  type: TYPE_NORMAL
- en: Using operators with Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are built-in Flow operators you can use with Flows. You can collect Flows
    with terminal operators and transform Flows with intermediate operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminal operators, such as the `collect` function used in the previous examples,
    are used to collect Flows. The following are the other terminal operators you
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first` and `firstOrNull`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last` and `lastOrNull`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single` and `singleOrNull`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toCollection`, `toList`, and `toSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operators work similarly to the Kotlin `Collection` function with the
    same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Intermediate operators to modify a Flow and return a new one. They
    can also be chained. The following Intermediate operators work the same as the
    Kotlin collection functions with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter`, `filterNot`, `filterNotNull`, and `filterIsInstance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map` and `mapNotNull`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runningReduce` and `runningFold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withIndex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there is a `transform` operator you can use to apply your own
    operation. For example, this class has a Flow that uses the `transform` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `transform` operator was used in the Flow of movies to only emit the
    ones whose `voteAverage` is higher than `0.6` (60%).
  prefs: []
  type: TYPE_NORMAL
- en: There are also size-limiting Kotlin Flow operators such as `drop`, `dropWhile`,
    `take`, and `takeWhile`, which function similarly to the Kotlin collection functions
    of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add Kotlin Flow into an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.03 – using Flow in an Android application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will update the Popular Movies app to use Kotlin Flow
    in fetching the list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Popular Movies project from the previous exercise in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `MovieRepository` class and remove the `movies` and `error` `LiveData`.
    Then, replace the `fetchMovies` function with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This changes the `fetchMovies` function to use Kotlin Flow. The Flow will emit
    the list of movies from `movieService.getPopularMovies`, and it will flow on the
    `Dispatchers.IO` dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MovieViewModel` class. In the class declaration, add a dispatcher
    parameter with a default value of `Dispatchers.IO`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be the dispatcher that will be used later for the Flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `popularMovies` `LiveData` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will use these for the value of the list of movies from `MovieRepository`.
    `StateFlow` is an observable Flow that emits state updates to the collectors,
    while `MutableStateFlow` is a `StateFlow` that you can change the value. In Android,
    `StateFlow` can be an alternative to `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `error` `LiveData` and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will use these for handling when the Flow encounters an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the content of the `fetchPopularMovies` function with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will collect the list of movies from `movieRepository` and set it to `MutableStateFlow`
    in `_popularMovies` (and `StateFlow` in `popularMovies`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app/build.gradle` file and add the following in the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows you to use `lifecycleScope` for collecting the Flows in `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `MainActivity` file and remove the lines of code for observing `popularMovies`
    and `error` from `MovieViewModel`. Add the following to collect the Flow from
    `MovieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application. The app will display the list of movies, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – The app displaying popular movies](img/B19411_14_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – The app displaying popular movies
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you added Kotlin Flow to an Android project. `MovieRepository`
    returns the list of movies as a Flow, which was collected in `MovieViewModel`.
    `MovieViewModel` uses `StateFlow`, which was then collected in `MainActivity`
    for displaying in RecyclerView.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 14.01 – creating a TV Guide app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of people watch television. Most of the time, though, they are not sure
    what TV shows are currently airing. Suppose you wanted to develop an app that
    can display a list of these shows from the Movie Database API’s `tv/on_the_air`
    endpoint using Kotlin Flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will have two screens: the main screen and the details screen. On the
    main screen, you will display a list of the TV shows that are on the air. The
    TV shows will be sorted by name. Clicking on a TV show will open the details screen,
    which displays more information about the selected TV show.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are for the completion of the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and name it `TV Guide`. Set its package
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `INTERNET` permission in the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the dependencies for Retrofit, Coroutines, Moshi, Lifecycle, and other libraries
    in your `app/build.gradle` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `layout_margin` dimension value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `view_tv_show_item.xml` layout file with `ImageView` for the poster
    and `TextView` for the name of the TV show.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `activity_main.xml` file, remove the `Hello World` TextView and add a
    RecyclerView to the list of TV shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShow` model class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another class named `TVResponse` for the response you get from the API
    endpoint for the TV shows on air.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new activity named `DetailsActivity` with `activity_details.xml` as
    the layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `AndroidManifest.xml` file and add the `parentActivityName` attribute
    in the `DetailsActivity` declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `activity_details.xml`, add the views for the details of the TV show.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `DetailsActivity` and add the code to display the details of the TV show
    selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShowAdapter` adapter class for the list of TV shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TelevisionService` class for adding the `Retrofit` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShowRepository` class with a constructor for `tvService`, and properties
    for `apiKey` and `tvShows`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to retrieve the list of TV shows from the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVShowViewModel` class with a constructor for `TVShowRepository`.
    Add the `tvShows` and `error` StateFlow and a `fetchTVShows` function that collects
    the Flow from the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an application class named `TVApplication` with a property for `TVShowRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `TVApplication` as the value for the application in the `AndroidManifest.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainActivity` and add the code to update the RecyclerView when the Flow
    from `ViewModel` updates its value. Add a function that will open the details
    screen when clicking on a TV show from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your application. The app will display a list of TV shows. Clicking on
    a TV show will open the details activity, which displays the show details. The
    main screen and details screen will be similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – The main screen and details screen of the TV Guide app](img/B19411_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – The main screen and details screen of the TV Guide app
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on doing background operations with Coroutines and Flow.
    Background operations are used for long-running tasks such as accessing data from
    the local database or a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: You started with the basics of using Kotlin coroutines, Google’s recommended
    solution for asynchronous programming. You learned that you can make a background
    task into a suspending function with the `suspend` keyword. Coroutines can be
    started with the `async` or `launch` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to create suspending functions and how to start coroutines.
    You also used dispatchers to change the thread where a coroutine runs. Then, you
    used coroutines for performing network calls and modified the data retrieved with
    the `map` and `switchMap` `LiveData` transformation functions.
  prefs: []
  type: TYPE_NORMAL
- en: You then moved on to using Kotlin Flow in an Android app to load the data in
    the background. To safely collect flows in the UI layer, prevent memory leaks,
    and avoid wasting resources, you can use `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about using Flow Builders to create Flows. The `flow` builder function
    creates a new Flow from a suspending lambda block and then you can send values
    with `emit()`. The `flowOf` function creates a Flow that emits the value or the
    `vararg` values. You can use the `asFlow()` extension function to convert collections
    and functional types into a Flow.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you explored Flow operators and learned how to use them with Kotlin
    Flows. Terminal operators are used to start the collection of the Flow. With Intermediate
    operators, you can transform a Flow into another Flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about architecture patterns. You will learn
    about patterns such as **Model-View-ViewModel** (**MVVM**) and how you can improve
    the architecture of your app.
  prefs: []
  type: TYPE_NORMAL
