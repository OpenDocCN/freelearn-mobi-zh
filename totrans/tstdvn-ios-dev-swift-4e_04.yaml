- en: '*Chapter 3*: Test-Driven Development in Xcode'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：Xcode中的测试驱动开发'
- en: For **test-driven development** (**TDD**), we need a way to write and execute
    unit tests. We could write the tests into the main target of our Xcode project
    but that would be impractical. We would have to separate the test code from the
    production code somehow, and we would have to write some scripts that execute
    the text code and gather feedback about the results of the tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**测试驱动开发**（**TDD**），我们需要一种编写和执行单元测试的方法。我们可以将测试写入Xcode项目的目标中，但这不太实际。我们必须以某种方式将测试代码与生产代码分开，并且我们需要编写一些脚本，这些脚本将执行测试代码并收集关于测试结果的反馈。
- en: Fortunately, this has already been done. It all started in 1998, when the Swiss
    company Sen:te developed OCUnit, a testing framework for Objective-C (hence the
    OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had
    written for Smalltalk in 1994.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这一切都已经完成了。这一切始于1998年，当时瑞士公司Sen:te开发了OCUnit，这是一个Objective-C（因此有OC前缀）的测试框架。OCUnit是SUnit的移植，SUnit是Kent
    Beck在1994年为Smalltalk编写的测试框架。
- en: 'With Xcode 2.1, Apple added OCUnit to Xcode. One reason for this step was that
    they used it to develop Core Data at the same time that they developed Tiger,
    the OS with which Core Data was shipped. Bill Bumgarner, an Apple engineer, wrote
    this later in a blog post:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode 2.1中，苹果公司将OCUnit添加到Xcode中。这一步骤的一个原因是他们在开发Tiger操作系统的同时开发了Core Data，Core
    Data就是与Tiger一起发布的。苹果工程师Bill Bumgarner在后来的博客文章中写道：
- en: '"Core Data 1.0 is not perfect, but it is a rock solid product that I''m damned
    proud of. The quality and performance achieved could not have been done without
    the use of unit testing. Furthermore, we were able to perform highly disruptive
    operations to the codebase very late in the development cycle. The end result
    was a vast increase in performance, a much cleaner codebase, and rock solid release."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “Core Data 1.0并不完美，但它是一个坚如磐石的产品，我为之感到无比自豪。所达到的质量和性能没有使用单元测试是无法实现的。此外，我们能够在开发周期的后期对代码库进行高度破坏性的操作。最终结果是性能大幅提升，代码库更加整洁，发布更加稳定。”
- en: Apple realized how valuable unit tests can be when developing complex systems
    in a changing environment. They wanted third-party developers to benefit from
    unit tests as well. OCUnit could be (and has been) added to Xcode by hand before
    version 2.1\. But by including it in the **Integrated Development Environment**
    (**IDE**), the investment in time that was needed to start unit testing was reduced
    a lot, and as a result, more people started to write tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果意识到，在变化的环境中开发复杂系统时，单元测试是多么有价值。他们希望第三方开发者也能从单元测试中受益。在版本2.1之前，OCUnit可以通过手动方式添加到Xcode中。但通过将其包含在**集成开发环境**（**IDE**）中，开始单元测试所需的时间投资大大减少，因此，更多的人开始编写测试。
- en: In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing
    of iPhone apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年，OCUnit被集成到iPhone SDK 2.2中，以允许对iPhone应用程序进行单元测试。
- en: Finally, in 2013, unit testing became a first-class citizen in Xcode 5 with
    the introduction of XCTest. With XCTest, Apple added specific user interface elements
    to Xcode that helped with testing, which allowed running specific tests, finding
    failing tests quickly, and getting an overview of all the tests. We will go over
    the testing user interface in Xcode later in this chapter. But, first, we will
    take a look at TDD using Xcode in action. This chapter sets the foundation we
    need to start building our first app using TDD.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在2013年，随着XCTest的引入，单元测试在Xcode 5中成为了一等公民。通过XCTest，苹果在Xcode中添加了特定的用户界面元素，这些元素有助于测试，允许运行特定的测试，快速找到失败的测试，并查看所有测试的概览。我们将在本章后面讨论Xcode中的测试用户界面。但首先，我们将看看使用Xcode进行TDD的实际操作。本章为我们开始使用TDD构建第一个应用程序奠定了基础。
- en: 'These are the main sections we will cover in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本章中涵盖的主要部分：
- en: An example of TDD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的一个示例
- en: Finding information about tests in Xcode
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Xcode中查找有关测试的信息
- en: Running tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Setting up and tearing down
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和拆除
- en: Debugging tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试测试
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code in this chapter is uploaded (in complete form) here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码都已上传（完整形式）在此：
- en: '[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter03](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter03)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter03](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter03)'
- en: An example of TDD
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的一个示例
- en: For this TDD example, we are going to use the same project we created in [*Chapter
    1*](B18127_01_ePub.xhtml#_idTextAnchor018), *Your First Unit Tests*. Open the
    FirstDemo project in Xcode, and run the tests by hitting *⌘**U*. The test we wrote
    to explore the custom assert function is failing. We don't need this test anymore.
    Delete it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个TDD示例，我们将使用我们在[*第1章*](B18127_01_ePub.xhtml#_idTextAnchor018)，*你的第一个单元测试*中创建的相同项目。在Xcode中打开FirstDemo项目，通过按*⌘**U*运行测试。我们编写的用于探索自定义断言功能的测试失败了。我们不再需要这个测试。删除它。
- en: Let's say we are building an app for a blogging platform. When writing a new
    post, the user puts in a headline for the post. All the words in the headline
    should start with an uppercase letter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为博客平台构建一个应用程序。当编写新帖子时，用户会为帖子输入一个标题。标题中的所有单词都应该以大写字母开头。
- en: 'To start the TDD workflow, we need a failing test. The following questions
    need to be considered when writing the test:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始TDD工作流程，我们需要一个失败的测试。在编写测试时需要考虑以下问题：
- en: '**Precondition**: What is the state of the system before we invoke the method?'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前提条件**：在我们调用方法之前，系统的状态是什么？'
- en: '**Invocation**: How should the signature of the method look? What are the input
    parameters (if any) of the method?'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用**：方法签名应该如何？方法（如果有）的输入参数是什么？'
- en: '**Assertion**: What is the expected result of the method invocation?'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：方法调用的预期结果是什么？'
- en: 'For our blogging app example, here are some possible answers to these questions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的博客应用示例，以下是一些可能的答案：
- en: '**Precondition**: None.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前提条件**：无。'
- en: '`makeHeadline`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeHeadline`。'
- en: '**Assertion**: The resulting string should be the same, but all the words should
    start with an uppercase letter.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：结果字符串应该相同，但所有单词都应该以大写字母开头。'
- en: This is enough to get us started. Enter the red step.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够我们开始了。进入红色步骤。
- en: Capitalize headline – red
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题首字母大写 – 红色
- en: 'The following steps bring us to the first red state of our TDD journey:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将我们带到TDD旅程的第一个红色状态：
- en: 'Open `FirstDemoTests.swift`, and add the following code to the `FirstDemoTests`
    class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FirstDemoTests.swift`，并将以下代码添加到`FirstDemoTests`类中：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This isn't a complete test method yet because we aren't really testing anything.
    But we have to stop writing the test at this point because the compiler complains
    that it `Blogger` but we haven't added it yet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是完整的测试方法，因为我们实际上并没有测试任何东西。但我们必须在这个地方停止编写测试，因为编译器抱怨我们没有添加`Blogger`。
- en: Following the TDD workflow, we need to add code until the compiler stops printing
    errors. Remember that **code does not compile** within a test means "the test
    is failing." And a failing test means we need to write code until the test does
    not fail anymore.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照TDD工作流程，我们需要添加代码，直到编译器停止打印错误。记住，在测试中**代码无法编译**意味着“测试失败。”一个失败的测试意味着我们需要编写代码，直到测试不再失败。
- en: 'Add a Swift file `Blogger.swift` to the main target with the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Swift文件`Blogger.swift`添加到主目标中，并包含以下代码：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Xcode replaces the error in the test with a warning that we do not use the `blogger`
    variable. That's true. So let's use it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode将测试中的错误替换为警告，指出我们没有使用`blogger`变量。这是真的。所以让我们使用它。
- en: 'Change the test code such that it looks like this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改测试代码，使其看起来像这样：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The test is still not complete. But again we have to stop because the compiler
    is complaining, this time with the message **Value of type 'Blogger' has no member
    'makeHeadline'**. So even with these few lines of code, you can already see how
    the test is "driving" the development. Step by step, we add code to the test and
    to the production code to implement the feature we are trying to build.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试仍然没有完成。但又一次，我们不得不停下来，因为编译器在抱怨，这次的信息是**类型'Blogger'没有成员'makeHeadline'**。所以，即使只有这几行代码，你也能看到测试是如何“驱动”开发的。一步一步地，我们向测试和生产代码中添加代码来实现我们试图构建的功能。
- en: 'As the test is failing (not compiling) right now, we need to switch back to
    the `Blogger` struct and add some more code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于测试目前失败（无法编译），我们需要切换回`Blogger`结构体并添加一些更多的代码：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, this changes the error in the test code to a warning that we are not
    using the headline variable. This is true. But we aren't finished with the test
    yet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这改变了测试代码中的错误，变成了警告，指出我们没有使用标题变量。这是真的。但我们还没有完成测试。
- en: 'We will use the variable next. Add the following assertion to the test method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用变量`next`。向测试方法添加以下断言：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This makes the test compile. Run the tests with the keyboard shortcut *⌘**U*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试可以编译。使用键盘快捷键*⌘**U*运行测试。
- en: The test we just added compiles and fails. We can move on to the green phases
    in the TDD workflow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的测试编译并失败。我们可以继续到TDD工作流程中的绿色阶段。
- en: Capitalize headline – green
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写标题 – 绿色
- en: The test fails because the string that is returned from `makeHeadline(from:)`
    is just an empty string. But the method should return the capitalized version
    of the input string `The Accessibility inspector`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败是因为从`makeHeadline(from:)`返回的字符串只是一个空字符串。但该方法应该返回输入字符串`The Accessibility
    inspector`的大写版本。
- en: 'Following the TDD workflow, we need to go back to the implementation and add
    the simplest code that makes the test pass. In `Blogger.swift`, change the code
    of `makeHeadline(from:)` such that it reads like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照TDD工作流程，我们需要回到实现部分并添加最简单的代码，使测试通过。在`Blogger.swift`中，修改`makeHeadline(from:)`的代码，使其看起来像这样：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is stupid and wrong, but it is the simplest code that makes the test
    pass. Run the tests (*⌘* *U*) to make sure that this is actually the case.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很愚蠢且错误，但它是最简单的使测试通过的代码。运行测试（*⌘* *U*）以确保这是实际情况。
- en: Even though the code we just wrote is useless for the feature we are trying
    to implement, it still has value for us, the developers. It tells us that we need
    another test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚编写的代码对我们尝试实现的功能没有用处，但它对我们这些开发者来说仍然有价值。它告诉我们我们需要另一个测试。
- en: Capitalize headline – refactor
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写标题 – 重构
- en: Before writing more tests, we need to refactor the existing ones. In the production
    code, there is nothing to refactor. This code couldn't be simpler or more elegant.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写更多测试之前，我们需要重构现有的测试。在生产代码中，没有什么可以重构的。这段代码既简单又优雅。
- en: 'But the test can be improved. Right now, the relevant information for the test
    is kind of unstructured. It''s not a big problem but maybe we can improve the
    readability of the test by following these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但测试可以改进。目前，测试的相关信息有点无结构。这不是大问题，但也许我们可以通过以下步骤提高测试的可读性：
- en: 'Replace the `test_makeHeadline_shouldCapitalisePassedInString()` test method
    with the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`test_makeHeadline_shouldCapitalisePassedInString()`测试方法替换为以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By using variables in the test, we make it easier to understand. The names of
    the variables inform the reader of the test about the purpose of these values.
    One value is the input, one is the result, and one is the expected value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在测试中使用变量，我们使其更容易理解。变量的名称向测试的读者说明了这些值的用途。一个值是输入，一个是结果，另一个是预期值。
- en: Run the tests. All the tests should still pass. But how do we know whether the
    tests still test the same thing as they did earlier? In most cases, the changes
    we'll make while refactoring the tests don't need to be tested themselves. But,
    sometimes (such as in this case), it is good to make sure that the test still
    works. This means that we need a failing test again.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。所有测试都应该仍然通过。但我们如何知道测试是否仍然测试与之前相同的内容？在大多数情况下，我们在重构测试时所做的更改不需要再次测试。但是，有时（例如在这种情况下），确保测试仍然有效是很好的。这意味着我们需要另一个失败的测试。
- en: 'Go to `makeHeadline(from:)` and change the returned string like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`makeHeadline(from:)`并更改返回的字符串如下：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have removed the last word from the return string. Run the tests again to
    make sure that the test now fails.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从返回的字符串中移除了最后一个单词。再次运行测试以确保测试现在失败。
- en: Now change the returned string back to `The Accessibility Inspector` to make
    the test pass again. Confirm that all tests pass again by running the tests.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将返回的字符串改回`The Accessibility Inspector`以再次使测试通过。通过运行测试来确认所有测试再次通过。
- en: By making the test fail on purpose and fixing it in the next step, we have proven
    that the test can fail. This is important because writing a test that always passes
    can easily happen. For example, if you forget to add an `assert` function or the
    `assert` function is never reached because of some conditionals in the test, the
    test is always reported as green.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过故意使测试失败并在下一步修复它，我们已经证明测试可以失败。这很重要，因为编写总是通过测试的测试很容易发生。例如，如果你忘记添加`assert`函数，或者由于测试中的某些条件，`assert`函数从未被触及，测试总是报告为绿色。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Always confirm that the test can fail!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总是确认测试可以失败！
- en: We already know that the implementation is not correct. The `makeHeadline(from:)`
    method always returns the same string and ignores the string that gets passed
    into the method. But all tests we have passed. When all tests pass, but we know
    that we are not finished with the feature yet, this means we need another test.
    In TDD, we always start with a failing test.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道实现是不正确的。`makeHeadline(from:)` 方法总是返回相同的字符串，并忽略了传递给方法中的字符串。但我们所有的测试都通过了。当所有测试都通过，但我们知道我们还没有完成这个功能，这意味着我们需要另一个测试。在
    TDD 中，我们总是从一个失败的测试开始。
- en: Capitalize headline 2 – red
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写标题 2 – 红色
- en: 'The production code we have written to make the previous test pass only works
    for one specific headline. But the feature we want to implement has to work for
    all possible headlines. Add the following test to `FirstDemoTests.swift`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的用于使之前的测试通过的生产代码仅适用于一个特定的标题。但我们想要实现的功能必须适用于所有可能的标题。将以下测试添加到 `FirstDemoTests.swift`
    中：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the tests. This new test obviously fails. Now, take a break. Go for a walk
    or prepare some beverages. Seriously, go away from the computer for half an hour
    or so.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。这个新测试显然失败了。现在，休息一下。去散步或者准备一些饮料。说真的，离开电脑半小时左右。
- en: Let's make the tests green.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使测试通过。
- en: Capitalize headline 2 – green
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写标题 2 – 绿色
- en: 'Open `Blogger.swift`, and replace the implementation of `makeHeadline(from:)`
    with the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Blogger.swift`，将 `makeHeadline(from:)` 的实现替换为以下代码：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's OK to be shocked by this implementation. With this code, I'm trying to
    make the point that, in the green step of TDD, any code is good as long as it
    makes the test pass. We'll improve this code in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现感到震惊是可以的。通过这段代码，我试图说明，在 TDD 的绿色步骤中，只要代码能让测试通过，任何代码都是好的。我们将在下一节中改进这段代码。
- en: 'Let''s go through this implementation step by step:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地通过这个实现：
- en: Split the string into words.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串拆分为单词。
- en: Iterate over the words, and remove the first character and change it to uppercase.
    Add the changed character to the beginning of the word. Add this word with a trailing
    space to the headline string.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历单词，删除第一个字符并将其转换为大写。将更改后的字符添加到单词的开头。将带有尾随空格的此单词添加到标题字符串中。
- en: Remove the last space and return the string.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除最后一个空格并返回字符串。
- en: Run the tests. All the tests pass. The next thing to perform in the TDD workflow
    is refactoring.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。所有测试都通过了。在 TDD 的工作流程中，接下来要执行的是重构。
- en: Tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not skip refactoring. This step is as important as the red and the green
    step. You are not done until there is nothing to refactor anymore.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不要跳过重构。这一步与红色和绿色步骤一样重要。直到没有可以重构的内容，你才算完成。
- en: Capitalize headline 2 – refactor
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写标题 2 – 重构
- en: 'Let''s start our refactoring with the tests:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试开始重构：
- en: The two `makeHeadline` tests both start with creating an instance of `Blogger`.
    This is a repetition of code and a good candidate for refactoring.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个 `makeHeadline` 测试都以创建 `Blogger` 的实例开始。这是代码重复，是重构的好候选。
- en: 'Add the following property at the beginning of the `FirstDemoTests` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FirstDemoTests` 类的开头添加以下属性：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Remember that the `setUp()` method is called before each test is executed.
    So, it is the perfect place to initialize the `blogger` property:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，`setUp()` 方法在每次测试执行之前被调用。因此，它是初始化 `blogger` 属性的完美位置：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each test should clean up after it has run. So, add the following code to `tearDownWithError()`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个测试运行后都应该清理。因此，将以下代码添加到 `tearDownWithError()` 中：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we can remove the `let blogger = Blogger()` line from the headline tests.
    Run the tests to make sure that they still compile and run.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从标题测试中删除 `let blogger = Blogger()` 行。运行测试以确保它们仍然可以编译和运行。
- en: 'Now we need to refactor the implementation code. The implementation we have
    right now looks like it was translated from Objective-C to Swift (if you haven''t
    used Objective-C yet, you have to trust me on this). But Swift is different and
    has many concepts that make it possible to write less code that is easier to read.
    Let''s make the implementation swifter. Replace `makeHeadline(from:)` with the
    following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要重构实现代码。我们目前拥有的实现看起来像是从 Objective-C 转换到 Swift（如果你还没有使用过 Objective-C，你必须相信我）。但是
    Swift 是不同的，并且有许多概念使得可以编写更少的代码，这些代码更容易阅读。让我们使实现更加敏捷。将 `makeHeadline(from:)` 替换为以下代码：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How cool is that? Swift even comes with a method on the `String` class to do
    exactly that. Run the tests again to make sure we didn't break anything with the
    refactoring. All the tests should still pass.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？Swift 甚至在 `String` 类中提供了一个方法来做这件事。再次运行测试以确保我们没有在重构中破坏任何东西。所有测试都应该仍然通过。
- en: A recap
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: In this section, we have added a feature to our project using the TDD workflow.
    We started with a failing test. We made the test pass. And, finally, we refactored
    the code to be clean. The steps you have seen here seem so simple and insignificant
    that you may think that you could skip some of the tests and still be good. But
    then it's not TDD anymore. The beauty of TDD is that the steps are so easy that
    you do not have to think about them. You just have to remember what the next step
    is.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 TDD 工作流程向我们的项目添加了一个功能。我们从失败的测试开始。我们使测试通过。最后，我们对代码进行了重构以使其更简洁。您在这里看到的步骤似乎非常简单且微不足道，以至于您可能认为可以跳过一些测试而仍然做得很好。但那样就不再是
    TDD 了。TDD 的美妙之处在于步骤非常简单，以至于您不必去思考。您只需记住下一步是什么。
- en: 'Because the steps and the rules are so easy, you don''t have to waste your
    brainpower thinking about what the steps actually mean. The only thing you have
    to remember is red, green, and refactor. As a result, you can concentrate on the
    difficult part: *writing tests*, *making them pass*, and *improving code*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为步骤和规则如此简单，您不必浪费脑力去思考这些步骤的实际含义。您唯一需要记住的是红色、绿色和重构。因此，您可以专注于困难的部分：*编写测试*、*使测试通过*和*改进代码*。
- en: Now that we know how to write tests, let's see where we can find information
    about our tests in Xcode.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何编写测试，让我们看看在 Xcode 中我们可以在哪里找到有关我们的测试的信息。
- en: Finding information about tests in Xcode
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Xcode 中查找测试信息
- en: With Xcode 5 and the introduction of XCTest, unit testing became tightly integrated
    into Xcode. Apple added many UI elements to navigate to tests, run specific tests,
    and find information about failing tests. Over the years, they improved the integration
    further. One key element here is the **test navigator**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 5 和 XCTest 的引入之后，单元测试被紧密集成到 Xcode 中。Apple 添加了许多 UI 元素来导航到测试、运行特定测试和查找有关失败的测试的信息。多年来，他们进一步改进了集成。这里的一个关键元素是**测试导航器**。
- en: Test navigator
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试导航器
- en: 'To open the test navigator, click the diamond with the minus sign in the navigator
    panel or use the shortcut *⌘* *6*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开测试导航器，点击导航面板中的带减号的菱形按钮或使用快捷键 *⌘* *6*：
- en: '![Figure 3.1 – The test navigator in Xcode'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – Xcode 中的测试导航器'
- en: '](img/Figure_3.01_B18127.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B18127.jpg)'
- en: Figure 3.1 – The test navigator in Xcode
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Xcode 中的测试导航器
- en: The test navigator shows all tests in the open project or workspace. In the
    preceding screenshot, you can see the test navigator for our demo project. In
    the project, there are two test targets, one for the unit tests and one for the
    UI tests. For complex apps, it can be useful to have more than one unit tests
    target, but this is beyond the scope of this book. The number of tests is shown
    right behind the name of the test target. In our case, there are three tests in
    the unit tests target.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试导航器显示了打开的项目或工作区中的所有测试。在上面的屏幕截图中，您可以看到我们的演示项目的测试导航器。在该项目中，有两个测试目标，一个用于单元测试，一个用于
    UI 测试。对于复杂的应用程序，拥有多个单元测试目标可能很有用，但这超出了本书的范围。测试的数量显示在测试目标的名称后面。在我们的例子中，单元测试目标中有三个测试。
- en: 'At the bottom of the navigator is a filter control with which you can filter
    the shown tests. As soon as you start typing, the shown tests are filtered using
    fuzzy matching. There''s a button in the control showing a diamond with a cross:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航器的底部有一个过滤器控件，您可以使用它来过滤显示的测试。一旦您开始输入，显示的测试就会使用模糊匹配进行过滤。控件中有一个显示带交叉的菱形的按钮：
- en: '![Figure 3.2 – The button in the test navigator to only show the failing tests'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 测试导航器中仅显示失败测试的按钮'
- en: '](img/Figure_3.02_B18127.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B18127.jpg)'
- en: Figure 3.2 – The button in the test navigator to only show the failing tests
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 测试导航器中仅显示失败测试的按钮
- en: If this button is selected, only the failing tests are shown in the list. With
    the button on the right, you can filter all skipped tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择此按钮，列表中仅显示失败的测试。通过右侧的按钮，您可以过滤所有跳过的测试。
- en: Test overview
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试概览
- en: 'Xcode also has a test overview where all the results of the tests are collected
    in one place. To open it, select **Report navigator** in the navigator panel,
    and select the last test in the list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还有一个测试概览，其中所有测试的结果都收集在一个地方。要打开它，在导航面板中选择**报告导航器**，然后选择列表中的最后一个测试：
- en: '![Figure 3.3 – Access the overview of the tests in the report navigator'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 在报告导航器中访问测试概览'
- en: '](img/Figure_3.03_B18127.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B18127.jpg)'
- en: Figure 3.3 – Access the overview of the tests in the report navigator
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 在报告导航器中访问测试概览
- en: 'You can also select other tests in the list if you want to compare test runs
    with each other. In the editor on the right-hand side, an overview of all the
    tests from the selected test run is shown:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要比较不同的测试运行，你还可以在列表中选择其他测试。在右侧的编辑器中，显示了所选测试运行中所有测试的概览：
- en: '![Figure 3.4 – Overview of the tests of the last test run'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 上次测试运行中的测试概览'
- en: '](img/Figure_3.04_B18127.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B18127.jpg)'
- en: Figure 3.4 – Overview of the tests of the last test run
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 上次测试运行中的测试概览
- en: When you hover over one of the tests with the mouse pointer, a circle with an
    arrow to the right appears. If you click on the arrow, Xcode opens the test in
    the editor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用鼠标指针悬停在某个测试上时，会出现一个带有向右箭头的圆圈。如果你点击箭头，Xcode 将在编辑器中打开测试。
- en: 'In the report navigator, there is also the **Log** item. It shows all the tests
    in a tree-like structure. Here is an example of what this looks like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告导航器中，还有一个**日志**项。它以树状结构显示所有测试。以下是一个示例：
- en: '![Figure 3.5 – Log of the test reports'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 测试报告日志'
- en: '](img/Figure_3.05_B18127.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B18127.jpg)'
- en: Figure 3.5 – Log of the test reports
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 测试报告日志
- en: The logs show the test cases (in this example, one test case) and the tests
    within the test cases (in this example, two failing and one passing test). In
    addition to this, you can also seethe time each test case and even each test needs
    to execute.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示了测试用例（在这个例子中，一个测试用例）以及测试用例内的测试（在这个例子中，两个失败的和一个通过的测试）。此外，你还可以看到每个测试用例甚至每个测试需要执行的时间。
- en: In TDD, it is important for the tests to execute quickly. You want to be able
    to execute the whole test suite in less than a second. Otherwise, the whole workflow
    is dominated by test execution and testing can distract your focus and concentration.
    You should never be tempted to switch to another application (such as Safari)
    because the tests will take half a minute.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 中，测试执行得快是很重要的。你希望能够在不到一秒的时间内执行整个测试套件。否则，整个工作流程将受测试执行的影响，测试可能会分散你的注意力和专注力。你不应该被诱惑切换到另一个应用程序（如
    Safari），因为测试可能需要半分钟。
- en: If you notice that the test suite takes too long to be practical, open the logs
    and search for the tests that slow down testing and try to make the tests faster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到测试套件运行时间过长，不切实际，请打开日志并搜索那些减慢测试速度的测试，并尝试使测试更快。
- en: Now that we have seen where we can find information about our tests, in the
    next section we will explore the different ways to run tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在哪里可以找到关于我们的测试的信息，在下一节中，我们将探讨运行测试的不同方法。
- en: Running tests
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Xcode provides many different ways to execute tests. You have already seen
    two ways to execute all the tests in the test suite: go to the **Project** | **Test**
    menu item or use the *⌘**U* keyboard shortcut.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了许多不同的执行测试的方法。你已经看到了执行测试套件中所有测试的两种方法：转到**项目** | **测试**菜单项或使用 *⌘**U*
    键盘快捷键。
- en: Running one specific test
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一个特定的测试
- en: In TDD, you normally want to run all the tests as often as possible. Running
    the tests gives you confidence that the code does what you intended when you wrote
    the tests. In addition to this, you want immediate feedback (that is, a failing
    test) whenever new code breaks a seemingly unrelated feature. Immediate feedback
    means that your memory of the changes that broke the feature is fresh, and the
    fix is made quickly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 中，你通常希望尽可能频繁地运行所有测试。运行测试可以让你有信心，代码在编写测试时确实做了你想要的事情。此外，你希望在新的代码破坏看似无关的功能时立即获得反馈（即，失败的测试）。立即反馈意味着你对破坏功能的更改的记忆是新鲜的，修复也是迅速进行的。
- en: 'Nevertheless, sometimes, you need to run one specific test, but don''t let
    it become a habit. To run one specific test, you can click on the diamond visible
    next to the test method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要运行一个特定的测试，但不要让它成为一种习惯。要运行一个特定的测试，你可以点击在测试方法旁边可见的菱形：
- en: '![Figure 3.6 – Run one specific test by clicking the diamond next to the test
    method in the gutter'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 通过点击侧边栏中测试方法的菱形来运行一个特定的测试'
- en: '](img/Figure_3.06_B18127.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B18127.jpg)'
- en: Figure 3.6 – Run one specific test by clicking the diamond next to the test
    method in the gutter
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 通过点击侧边栏中测试方法的菱形来运行一个特定的测试
- en: When you click on it, the production code is compiled and launched in the simulator
    or on the device, and the test is executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击它时，生产代码将在模拟器或设备上编译并启动，并执行测试。
- en: 'There is another way to execute exactly one specific test. When you open the
    test navigator and hover over one test, a circle with a play icon is shown next
    to the test method name:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种执行特定测试的方法是。当您打开测试导航器并将鼠标悬停在某个测试上时，测试方法名旁边会显示一个带有播放图标的圆形：
- en: '![Figure 3.7 – Click the diamond next to the test in the test navigator to
    run this test'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.7 – 点击测试导航器中测试旁边的菱形以运行此测试]'
- en: '](img/Figure_3.07_B18127.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.07_B18127.jpg]'
- en: Figure 3.7 – Click the diamond next to the test in the test navigator to run
    this test
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.7 – 点击测试导航器中测试旁边的菱形以运行此测试]'
- en: Again, if you click on this test, it is run exclusively.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果您点击此测试，它将单独运行。
- en: The test framework identifies tests by the prefix of the method name. If you
    want to run all tests but one, remove the `test` prefix from the beginning of
    this test's method name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架通过方法名的前缀来识别测试。如果您想运行所有测试但排除一个，请从该测试方法名的开头移除 `test` 前缀。
- en: Running all tests in a test case
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试用例中运行所有测试
- en: In the same way as running one specific test, you can run all the tests of a
    specific test case. Click on the diamond next to the definition of the test case,
    or click on the play button that appears when you hover over the test case name
    in the test navigator.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行特定测试相同，您也可以运行特定测试用例的所有测试。点击测试用例定义旁边的菱形，或者当您在测试导航器中将鼠标悬停在测试用例名称上时出现的播放按钮。
- en: Running a group of tests
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一组测试
- en: 'You can choose to run a group of tests by editing the build scheme. To edit
    the build scheme, click on the scheme in the toolbar in Xcode, and then click
    on **Edit Scheme...**:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编辑构建方案来选择运行一组测试。要编辑构建方案，请点击 Xcode 工具栏中的方案，然后点击 **编辑方案...**：
- en: '![Figure 3.8 – Open the scheme editor'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.08 – 打开方案编辑器]'
- en: '](img/Figure_3.08_B18127.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.08_B18127.jpg]'
- en: Figure 3.8 – Open the scheme editor
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 打开方案编辑器
- en: 'Then, select **Test**, and expand the test suite by clicking on the small triangle.
    On the right-hand side, there is a column called **Tests**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择 **测试**，通过点击小三角形来展开测试套件。在右侧，有一个名为 **测试** 的列：
- en: '![Figure 3.9 – Test setting in the scheme editor'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.09 – 方案编辑器中的测试设置]'
- en: '](img/Figure_3.09_B18127.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.09_B18127.jpg]'
- en: Figure 3.9 – Test setting in the scheme editor
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.09 – 方案编辑器中的测试设置]'
- en: The selected scheme only runs the tests that are checked. By default, all the
    tests are checked, but you can uncheck some tests if you need to. But don't forget
    to check all the tests again when you are finished.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的方案仅运行已勾选的测试。默认情况下，所有测试都是勾选的，但您可以根据需要取消勾选某些测试。但别忘了在完成时再次勾选所有测试。
- en: As an alternative, you can add a build scheme for a group of tests that you
    want to run regularly without running all tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您可以添加一个构建方案，用于运行一组您想要定期运行而无需运行所有测试的测试。
- en: But as mentioned earlier, you should run the complete test suite as often as
    possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但如前所述，您应该尽可能经常运行完整的测试套件。
- en: The following section shows how to add code that is run before and after each
    test invocation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何在每次测试调用前后添加代码。
- en: Setting up and tearing down
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和清理
- en: We have already seen the `setUpWithError()` and `tearDownWithError()` instance
    methods earlier in this chapter. The code in the `setUpWithError()` instance method
    is run before each test invocation. In our example, we used `setUpWithError()`
    to initialize the `Blogger` that we wanted to test. As it was run before each
    test invocation, each test used its own instance of `Blogger`. The changes we
    made to this particular instance in one test didn't affect the other test. The
    tests are executed independently of each other.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经看到了 `setUpWithError()` 和 `tearDownWithError()` 实例方法。`setUpWithError()`
    实例方法中的代码在每个测试调用之前运行。在我们的示例中，我们使用 `setUpWithError()` 来初始化我们想要测试的 `Blogger`。由于它在每个测试调用之前运行，每个测试都使用其自己的
    `Blogger` 实例。我们对这个特定实例所做的更改不会影响其他测试。测试是相互独立执行的。
- en: The `tearDownWithError()` instance method is run after each test invocation.
    Use `tearDownWithError()` to perform the necessary cleanup. In the example, we
    set the `blogger` to `nil` in the `tearDownWithError()` method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`tearDownWithError()` 实例方法在每个测试调用之后运行。使用 `tearDownWithError()` 来执行必要的清理工作。在示例中，我们在
    `tearDownWithError()` 方法中将 `blogger` 设置为 `nil`。'
- en: In addition to the instance methods, there are also the `setUp()` and `tearDown()`
    class methods. These are run before and after all the tests of a test case, respectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例方法之外，还有`setUp()`和`tearDown()`类方法。这些方法分别在测试用例的所有测试之前和之后运行。
- en: Debugging tests
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试测试
- en: Sometimes, but not often, you may need to debug your tests. As with normal code,
    you can set breakpoints in test code. The debugger then stops the execution of
    the code at that breakpoint. You can also set breakpoints in the code that will
    be tested to check whether you have missed something or whether the code you'd
    like to test is actually executed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，但并不经常，你可能需要调试你的测试。与正常代码一样，你可以在测试代码中设置断点。然后，调试器会在该断点处停止代码执行。你还可以在将被测试的代码中设置断点，以检查你是否遗漏了某些内容，或者你想要测试的代码是否实际上被执行了。
- en: 'To get a feeling of how this works, let''s add an error to a test in the preceding
    example and debug it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何工作的，让我们在先前的示例中向测试添加一个错误并对其进行调试：
- en: 'Open `FirstDemoTests.swift` and replace the test method `test_makeHeadline_shouldCapitalisePassedInString_2()`
    with this code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `FirstDemoTests.swift` 并将测试方法 `test_makeHeadline_shouldCapitalisePassedInString_2()`
    替换为以下代码：
- en: '[PRE14]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Have you seen the error that we have introduced? The value of the string expected
    has a typo. The last character in `Contextual` is an uppercase "i" and not a lowercase
    "l". Run the tests. The test fails and Xcode tells you what the problem is.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我们引入的错误了吗？期望字符串的值中有一个拼写错误。`Contextual`中的最后一个字符是大写“i”，而不是小写“l”。运行测试。测试失败，Xcode
    会告诉你问题所在。
- en: 'But for the sake of this exercise, let''s set a breakpoint in the line with
    the `XCTAssertEqual()` function. Click on the area on the left-hand side of the
    line where you want to set a breakpoint. You have to click on the area next to
    the red diamond. As a result, your editor will look similar to the following:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但为了这个练习，让我们在`XCTAssertEqual()`函数所在的行设置一个断点。单击你想要设置断点的行的左侧区域。你必须单击红色菱形旁边的区域。结果，你的编辑器将看起来类似于以下：
- en: '![Figure 3.10 – Add a breakpoint in the line with the assertion'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 在断言所在的行添加断点'
- en: '](img/Figure_3.10_B18127.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B18127.jpg)'
- en: Figure 3.10 – Add a breakpoint in the line with the assertion
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 在断言所在的行添加断点
- en: 'Run the tests again. The execution of the tests stops at the breakpoint. Open
    the debug console if it is not already open (go to `(lldb)` and a blinking cursor.
    Put in `po expected` and hit *Return*. `po` is the "print object" command. As
    the name suggests, it prints a representation of the object:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。测试执行在断点处停止。如果调试控制台尚未打开，请打开它（转到`(lldb)`并出现闪烁的光标。输入`po expected`并按*Enter*。`po`是“打印对象”命令。正如其名所示，它会打印对象的表示：
- en: '[PRE15]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now print the value of the result:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打印结果值：
- en: '[PRE16]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, with the help of the debugger, you can find out what is happening.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助调试器，你可以找出发生了什么。
- en: As we have seen, the debugger is attached to the running app when we run the
    tests. This means breakpoints in production code are also hit when we run the
    tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当我们运行测试时，调试器会附加到正在运行的应用程序上。这意味着当运行测试时，生产代码中的断点也会被触发。
- en: Tip
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about the debugger, search for `lldb` in the Apple documentation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于调试器的信息，请在 Apple 文档中搜索`lldb`。
- en: For now, keep the typo in the `expected` string constant as it is, but remove
    the breakpoint by dragging it with the mouse from the area to the left of the
    editor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请将`expected`字符串常量中的拼写错误保留原样，但通过用鼠标将其从编辑器左侧的区域拖动来删除断点。
- en: A breakpoint that breaks on test failure
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试失败时中断的断点
- en: Xcode has a built-in breakpoint that breaks on test failures. When this breakpoint
    is set, the execution of the tests is stopped, and a debug session is started
    whenever a test fails.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 内置了一个断点，当测试失败时触发。当设置此断点时，测试执行将停止，并且每当测试失败时，都会启动一个调试会话。
- en: Usually, this is not what you want because in TDD, failing tests are normal
    and you don't need a debugger to find out what's going on. You explicitly wrote
    the test to fail at the beginning of the TDD workflow cycle.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这并不是你想要的，因为在 TDD 中，失败的测试是正常的，你不需要调试器来找出发生了什么。你明确地在 TDD 工作流程周期的开始处编写了测试以失败。
- en: 'But in case you need to debug one or more failing tests, it''s good to know
    how this breakpoint is activated. Open the breakpoint navigator:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你需要调试一个或多个失败的测试，了解如何激活此断点是有好处的。打开断点导航器：
- en: '![Figure 3.11 – The breakpoint navigator'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 断点导航器'
- en: '](img/Figure_3.11_B18127.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B18127.jpg)'
- en: Figure 3.11 – The breakpoint navigator
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 断点导航器
- en: 'At the bottom of the navigator view is a button with a plus sign (+). Click
    on it, and select **Test Failure Breakpoint**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航视图的底部有一个带有加号（+）的按钮。点击它，然后选择**测试失败断点**：
- en: '![Figure 3.12 – Select Test Failure Breakpoint'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – 选择测试失败断点'
- en: '](img/Figure_3.12_B18127.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B18127.jpg)'
- en: Figure 3.12 – Select Test Failure Breakpoint
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 选择测试失败断点
- en: As the name suggests, this breakpoint stops the execution of the tests whenever
    a test fails. We still have a failing test in our example. Run the tests to see
    the breakpoint in action.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，此断点在测试失败时停止测试的执行。在我们的例子中，我们仍然有一个失败的测试。运行测试以查看断点的作用。
- en: The debugger stops at the line with the assertion because the tests fail. Like
    in the preceding example, you get a debug session so that you can put in `LLDB`
    commands to find out why the test failed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器在断言所在的行停止，因为测试失败。就像前面的例子一样，你可以得到一个调试会话，以便你可以输入 `LLDB` 命令来找出测试失败的原因。
- en: Remove the breakpoint again because it's not very practical while performing
    TDD. In TDD, we have failing tests all the time. A test failure breakpoint would
    disturb the TDD flow too much.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次移除断点，因为在执行 TDD 时它不太实用。在 TDD 中，我们总是有失败的测试。测试失败断点会过多地干扰 TDD 流程。
- en: The test again feature
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试再次功能
- en: Now, let's fix the error in the tests and learn how to run the previous test
    again. Open `FirstDemoTests.swift` and run only the failing test by clicking on
    the diamond symbol next to the test method. The test still fails. Fix it by changing
    the last character in `ContextuaI` to "l" in the `expected` string constant. Then,
    go to **Product** | **Perform Action** | **Test "test_makeHeadline_shouldCapitalisePassedInString_2()"
    Again**, or use the shortcut *⌃⌥⌘**G* to run just the previous test again. The
    shortcut is especially useful when you are working on one specific feature and
    you need to test whether the implementation is sufficient already.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复测试中的错误，并学习如何再次运行前面的测试。打开 `FirstDemoTests.swift` 并通过点击测试方法旁边的菱形符号来仅运行失败的测试。测试仍然失败。通过将
    `ContextuaI` 中的最后一个字符在 `expected` 字符串常量中更改为 "l" 来修复它。然后，转到**产品** | **执行操作** |
    **再次测试 "test_makeHeadline_shouldCapitalisePassedInString_2()"**，或使用快捷键 *⌃⌥⌘**G*
    再次运行前面的测试。快捷键在处理特定功能时特别有用，当你需要测试实现是否足够时。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how unit testing and TDD works in Xcode. We saw
    real tests testing real code. Using the different test-related features of Xcode,
    we learned to write, run, and fix tests and to find test-relevant information.
    All this is important for the rest of the book. We need to know how to use Xcode
    when doing TDD.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 Xcode 中单元测试和 TDD 的工作方式。我们看到了真实的测试在测试真实的代码。通过使用 Xcode 的不同测试相关功能，我们学习了如何编写、运行和修复测试，以及如何找到与测试相关的信息。所有这些对于本书的其余部分都很重要。我们需要知道如何在执行
    TDD 时使用 Xcode。
- en: In the next chapter, we will figure out the app we are going to build using
    test-driven development.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过测试驱动开发来确定我们将要构建的应用程序。
- en: Exercises
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write a test for a method that reverses a string. Write the code that makes
    the test pass.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试方法，该方法反转一个字符串。编写使测试通过的代码。
- en: Write a test for a method that takes a headline and creates a filename from
    it. In the filename, make sure that spaces are replaced by `_` and it only contains
    lowercase characters.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试方法，该方法接受一个标题并从中创建一个文件名。在文件名中，确保空格被替换为 `_`，并且它只包含小写字母。
