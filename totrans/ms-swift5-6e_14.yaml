- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, most major programming languages have functionalities similar to those
    of closures in Swift. Some of these implementations are really hard to use (Objective-C
    blocks), while others are easy (Java lambdas and C# delegates). I have found that
    the functionality that closures provide is especially useful when developing frameworks.
    I have also used them extensively when communicating with remote services over
    a network connection. While blocks in Objective-C are incredibly useful, the syntax
    used to declare a block is absolutely horrible. Luckily, when Apple was developing
    the Swift language, they made the syntax of closures much easier to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are closures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a closure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a closure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some examples of useful closures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid strong reference cycles within closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures are self-contained blocks of code that can be passed around and used
    throughout our application. We can think of the `Int` type as a type that contains
    an integer, and the `String` type as a type that contains a string. In this context,
    a closure can be thought of as a type that contains a block of code. This means
    that we can assign closures to a variable, pass them as arguments to functions,
    and return them from a function.
  prefs: []
  type: TYPE_NORMAL
- en: Closures can capture and store references to any variable or constant from the
    context in which they were defined. This is known as closing over the variables
    or constants and, for the most part, Swift will handle the memory management for
    us. The only exception is in creating a strong reference cycle, and we will look
    at how to resolve this in the *Creating strong reference cycles with closures*
    section of *Chapter 18*, *Memory Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures in Swift are similar to blocks in Objective-C; however, closures in
    Swift are a lot easier to use and understand. Let''s look at the syntax used to
    define a closure in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The syntax used to create a closure looks very similar to the syntax we use
    to create functions, and in Swift, global and nested functions are closures. The
    biggest difference in the format between closures and functions is the `in` keyword.
    The `in` keyword is used in place of curly brackets to separate the definition
    of the closure's parameter and return types from the body of the closure.
  prefs: []
  type: TYPE_NORMAL
- en: There are many uses for closures, and we will go over a number of them later
    in this chapter, but first, we need to understand the basics of closures. Let's
    start by looking at some very basic closures so that we can get a better understanding
    of what they are, how to define them, and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Simple closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin by creating a very simple closure that does not accept any arguments
    and does not return any value. All it does is print `Hello World` to the console.
    Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a closure and assign it to the `clos1` constant.
    Since there are no parameters defined between the parentheses, this closure will
    not accept any parameters. Also, the return type is defined as `Void`; therefore,
    this closure will not return any value. The body of the closure contains one line,
    which prints `Hello World` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to use closures; in this example, all we want to do is
    execute it. We can execute the closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After executing the closure, we will see that `Hello World` is printed to the
    console. At this point, closures may not seem that useful, but as we get further
    along in this chapter, we will see how useful and powerful they can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another simple example. This closure will accept one `String`
    parameter named `name` but will not return a value. Within the body of the closure,
    we will print out a greeting to the name passed into the closure through the `name`
    parameter. Here is the code for this second closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The big difference between the `clos2` closure and the `clos1` closure is that
    we define a single `String` parameter between the parentheses. As we can see,
    we define parameters for closures just like we define parameters for functions.
    We can execute this closure in the same way in which we executed the `clos1` closure.
    The following code shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example, when executed, will print the `Hello Jon` message to the console.
    Let's look at another way we can use the `clos2` closure. One thing to note in
    this example is that the named parameters in a closure do not require the parameter
    name to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our original definition of closures stated that Closures are self-contained
    blocks of code that can be passed around and used throughout our application.
    This tells us that we can pass our closures from the context that they were created
    into other parts of our code. Let''s look at how to pass our `clos2` closure into
    a function. We will define a function that accepts our `clos2` closure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the function just like we would any other function; however, in the
    parameter list, we define a parameter named `handler`, and the type defined for
    the `handler` parameter is `(String) -> Void`. If we look closely, we can see
    that the `(String) -> Void` definition of the `handler` parameter matches the
    parameter and return types that we defined for the `clos2` closure. This means
    that we can pass the `clos2` closure into the function. Let''s look at how to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `testClosure()` function just like any other function, and the
    closure that is being passed in looks like any other variable. Since the `clos2`
    closure is executed in the `testClosure()` function, we will see the message `Hello
    Dasher` printed to the console when this code is executed. As we will see a little
    later in this chapter, the ability to pass closures to functions is what makes
    closures so exciting and powerful. As the final piece to the closure puzzle, let''s
    look at how to return a value from a closure. The following example shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `clos3` closure looks very similar to how we defined
    the `clos2` closure. The difference is that we changed the `Void` return type
    to a `String` type. Then, in the body of the closure, instead of printing the
    message to the console, we used the return statement to return the message. We
    can now execute the `clos3` closure just like the previous two closures or pass
    the closure to a function like we did with the `clos2` closure. The following
    example shows how to execute the `clos3` closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this line of code is executed, the message variable will contain the `Hello
    Buddy` string. The previous three examples of closures demonstrate the format
    and how to define a typical closure. Those who are familiar with Objective-C can
    see that the format of closures in Swift is a lot cleaner and easier to use. The
    syntax for creating closures that we have shown so far in this chapter is pretty
    short; however, we can shorten it even more. In this next section, we will look
    at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand syntax for closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at a couple of ways to shorten the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Using the shorthand syntax for closures is really a matter of personal preference.
    A lot of developers like to make their code as small and compact as possible,
    and they take great pride in doing so. However, at times this can make the code
    hard to read and understand for other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first shorthand syntax for closures that we are going to look at is one
    of the most popular, which is the syntax we saw when we were using algorithms
    with arrays in *Chapter 5*, Using Swift Collections. This format is mainly used
    when we want to send a really small (usually one line) closure to a function,
    like we did with the algorithms for arrays. Before we look at this shorthand syntax,
    we need to write a function that will accept a closure as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts two parameters; the first parameter is an integer named
    `num`, and the second parameter is a closure named `handler`, which does not have
    any parameters and does not return any value. Within the function, we create a
    `for` loop that will use the `num` integer to define how many times it loops.
    Within the `for` loop, we call the `handler` closure that was passed into the
    function. Now let''s create a closure and pass it to `testFunction()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very easy to read and understand; however, it does take five lines
    of code. Now let''s look at how to shorten it by writing the closure inline within
    the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we created the closure inline within the function call, using
    the same syntax that we used with the algorithms for arrays. The closure is placed
    in between two curly brackets (`{}`), which means the code to create the closure
    is `{print("Hello from Shorthand closure")}`. When this code is executed, it will
    print out the `Hello from Shorthand closure` message five times on the screen.
    The ideal way to call the `testFunction()` with a closure, for both compactness
    and readability, would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the closure as the final parameter allows us to leave off the label
    when calling the function. This example gives us both compact and readable code.
    Let''s look at how to use parameters with this shorthand syntax. We will begin
    by creating a new function that will accept a closure with a single parameter.
    We will name this function `testFunction2`. The following example shows what the
    new `testFunction2` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In `testFunction2`, we define the closure like this: `(_ : String)->Void`.
    This definition means that the closure accepts one parameter and does not return
    any value. Now let''s look at how to use the same shorthand syntax to call this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between this closure definition and the previous one is `$0`.
    The `$0` parameter is shorthand for the first parameter passed into the function.
    If we execute this code, it prints out the `Hello from Me` message five times.
    Using the dollar sign (`$`) followed by a number with inline closures allows us
    to define the closure without having to create a parameter list in the definition.
    The number after the dollar sign defines the position of the parameter in the
    parameter list. Let''s examine this format a bit more, because we are not limited
    to only using the dollar sign (`$`) and number shorthand format with inline closures.
    This shorthand syntax can also be used to shorten the closure definition by allowing
    us to leave the parameter names off. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the closure has two string parameters defined; however, we
    do not give them names. The parameters are defined like this: (`String`, `String`).
    We can then access the parameters within the body of the closure using `$0` and
    `$1`. Also, note that the closure definition is after the colon (`:`), using the
    same syntax that we use to define a variable type rather than inside the curly
    brackets. When we use anonymous arguments, this is how we would define the closure.
    It will not be valid to define the closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will receive an error letting us know that this format
    is not valid. Next, let''s look at how we would use the `clos5` closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Hello` is the first string in the parameter list, it is accessed with
    `$0`, and as `Kara` is the second string in the parameter list, it is accessed
    with `$1`. When we execute this code, we will see the `Hello Kara` message printed
    to the console. This next example is used when the closure doesn''t return any
    value. Rather than defining the return type as `Void`, we can use parentheses,
    as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define the closure as `() -> ()`. This tells Swift that
    the closure does not accept any parameters and also does not return a value. We
    will execute this closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As a personal preference, I am not very fond of this shorthand syntax. I think
    the code is much easier to read when the `Void` keyword is used rather than the
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more shorthand closure example to demonstrate before we begin showing
    some really useful examples of closures. In this last example, we will demonstrate
    how we can return a value from the closure without the need to include the `return`
    keyword. If the entire closure body consists of only a single statement, we can
    omit the `return` keyword, and the results of the statement will be returned.
    Let''s look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the closure accepts two parameters of the `Int` type and will
    return an instance of the `Int` type. The only statement within the body of the
    closure adds the first parameter to the second parameter. However, if you notice,
    we do not include the `return` keyword before the additional statement. Swift
    will see that this is a single-statement closure and will automatically return
    the results, just as if we put the `return` keyword before the additional statement.
    We do need to make sure the result type of our statement matches the return type
    of the closure.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples shown in the previous two sections were designed to show
    how to define and use closures. On their own, these examples do not really show
    off the power of closures and they do not show how incredibly useful closures
    are. The remainder of this chapter will demonstrate the power and usefulness of
    closures in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Using closures with Swift arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Using Swift Collections*, we looked at several built-in algorithms
    that we can use with Swift's arrays. In that chapter, we briefly looked at how
    to add simple rules to each of these algorithms with very basic closures. Now
    that we have a better understanding of closures, let's look at how we can expand
    on these algorithms using more advanced closures.
  prefs: []
  type: TYPE_NORMAL
- en: Using closures with Swift's array algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will primarily be using the `map` algorithm for consistency
    purposes; however, we can use the basic ideas demonstrated with any of the algorithms.
    We will start by defining an array to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This array contains a list of names and the array is named `guests`. This array
    will be used for the majority of the examples in this section. Now that we have
    our `guests` array, let''s add a closure that will print a greeting to each of
    the names in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `map` algorithm applies the closure to each item of the array, this
    example will print out a greeting for each name within the array. After the first
    section in this chapter, we should have a pretty good understanding of how this
    closure works. Using the shorthand syntax that we saw in the previous section,
    we could reduce the preceding example down to the following single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of the few times, in my opinion, where the shorthand syntax may
    be easier to read than the standard syntax. Now, let''s say that rather than printing
    the greeting to the console, we wanted to return a new array that contained the
    greetings. For this, we would return a `String` type from our closure, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is executed, the `messages` array will contain a greeting to
    each of the names in the `guests` array, while the array will remain unchanged.
    We could access the greetings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples in this section showed how to add a closure to the `map`
    algorithm inline. This is good if we only had one closure that we wanted to use
    with the `map` algorithm, but what if we had more than one closure that we wanted
    to use, or if we wanted to use the closure multiple times or reuse it with different
    arrays? For this, we could assign the closure to a constant or variable and then
    pass in the closure, using its constant or variable name, as needed. Let's look
    at how to do this. We will begin by defining two closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the closures will print a greeting for each element in the array, and
    the other closure will print a goodbye message for each element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have two closures, we can use them with the `map` algorithm as
    needed. The following code shows how to use these closures interchangeably with
    the `guests` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `greetGuest` closure with the `guests` array, the greeting
    message is printed to the console, and when we use the `sayGoodbye` closure with
    the `guests` array, the goodbye message is printed to the console. If we had another
    array named `guests2`, we could use the same closures for that array, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the examples in this section so far have either printed a message to
    the console or returned a new array from the closure. We are not limited to such
    basic functionality in our closures. For example, we can filter the array within
    the closure, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we print out a different message depending on whether the name
    starts with the letter `K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier in the chapter, closures have the ability to capture and
    store references to any variable or constant from the context in which they were
    defined. Let''s look at an example of this. Let''s say that we have a function
    that contains the highest temperature for the last seven days at a given location
    and this function accepts a closure as a parameter. This function will execute
    the closure on the array of temperatures. The function can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts a closure, defined as `(Int)-> Void`. We then use the
    `map` algorithm to execute this closure for each item of the `tempArray` array.
    The key to using a closure correctly in this situation is to understand that the
    `temperatures` function does not know, or care, about what goes on inside the
    `calculate` closure. Also, be aware that the closure is also unable to update
    or change the items within the function's context, which means that the closure
    cannot change any other variable within the temperature's function; however, it
    can update variables in the context that it was created in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the function that we will create the closure in. We will name
    this function `testFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we begin by defining two variables, named `total` and `count`,
    where both variables are of the `Int` type. We then create a closure named `addTemps`
    that will be used to add all the temperatures from the `temperatures` function
    together. The `addTemps` closure will also count how many temperatures there are
    in the array. To do this, the `addTemps` closure calculates the sum of each item
    in the array and keeps the total in the `total` variable that was defined at the
    beginning of the function. The `addTemps` closure also keeps track of the number
    of items in the array by incrementing the `count` variable for each item. Notice
    that neither the `total` nor `count` variables are defined within the closure;
    however, we are able to use them within the closure because they were defined
    in the same context as the closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the `temperatures` function and pass it the `addTemps` closure.
    Finally, we print the `Total`, `Count`, and `Average` temperature to the console.
    When `testFunction` is executed, we will see the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, the `addTemps` closure is able to update and
    use items that are defined within the context that it was created in, even when
    the closure is used in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at using closures with the array `map` algorithm, let's
    look at using closures by themselves. We will also look at the ways we can clean
    up our code to make it easier to read and use.
  prefs: []
  type: TYPE_NORMAL
- en: Non-contiguous elements from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Using Swift Collections*, we showed how to retrieve non-contiguous
    sub-elements from an array using the `subrange` method with a closure. Now that
    we know a little more about closures, let's take a look at this again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we used in *Chapter 5*, *Using Swift Collections*, retrieved the even
    numbers from an array of integers. Let''s look at this code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we used `isMultiple(of: )` from the `Int` type to retrieve
    all elements that are even numbers. Since the `subranges(where: )` method takes
    a closure, we can use other logic as well. For example, if we wanted to retrieve
    all elements that were equal to or less than 6, we could use the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are familiar with closures, we can see some of the possibilities
    of the `subrange(where: )` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Uninitialized arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift 5.2 with SE-0245 introduced a new initializer for arrays that does not
    pre-fill the values with a default value. This initializer enables us to provide
    a closure to fill in the values however we like. Let''s take a look at how to
    do this by creating an array that will contain the value of 20 dice rolls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We begin by setting a constant that contains the capacity for the array. We
    do this because we need to provide that value in several spots within the initializer
    and by using the constant, if we need to change this capacity at a later time,
    then it only needs to be changed in one spot.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code initializes the array. The closure provides an unsafe mutable
    buffer pointer, which we named `buffer` in the previous code, that can be used
    to write the values for the array too. We use a `for` loop to populate the array
    with random integer values from 1 to 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some general rules when you are using this initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to use the full capacity that you ask for; however, you cannot
    use more. In our example, we ask for a capacity of 20 elements, which means we
    can use less than 20, but we cannot use more than 20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not initialize an element, then it will probably be filled with random
    data (very bad idea). In our example, where we request a capacity of 20 elements,
    if we only populated the first 10 elements then the second 10 elements would contain
    random garbage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `initializedCount` is not set then it will default to `0` and all of the
    data will be lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a very handy initializer to use but it is also very easy to make a
    mistake with it. We could also rewrite the `diceRolls` initializer using the `map`
    array algorithm, as the following code shows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this would be less efficient because initializing the array as shown
    in the first example is internally optimized for better performance. If you are
    not worried about the best performance, then the map algorithm is much easier
    to read and understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let's look at how we can use closures to change functionality at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Changing functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures also give us the ability to change the functionality of types on the
    fly. In *Chapter 11*, *Generics*, we saw that generics give us the ability to
    write functions that are valid for multiple types. With closures, we are able
    to write functions and types whose functionality can change, based on the closure
    that is passed in. In this section, we will show you how to write a function whose
    functionality can be changed with a closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by defining a type that will be used to demonstrate how to swap
    out a functionality. We will name this type `TestType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We begin this type by defining a `typealias` for our closure, which is named
    `GetNumClosure`. Any closure that is defined as a `GetNumClosure` closure will
    take two integers and return a single integer. Within this closure, we assume
    that it does something with the integers that we pass in to get the value to return,
    but it really doesn't have to do anything with the integers. To be honest, this
    class doesn't really care what the closure does as long as it conforms to the
    `GetNumClosure` type. Next, we define three integers, named `numOne`, `numTwo`,
    and `results`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define a method named `getNum()`. This method accepts a closure that
    conforms to the `GetNumClosure` type as its only parameter. Within the `getNum()`
    method, we execute the closure by passing in the `numOne` and `numTwo` variables,
    and the integer that is returned is put into the `results` class variable. Now
    let''s look at several closures that conform to the `GetNumClosure` type that
    we can use with the `getNum()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we define five closures that conform to the `GetNumClosure` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max`: This returns the maximum value of the two integers that are passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in min`: This returns the minimum value of the two integers that are passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in multiply`: This multiplies both the values that are passed in and returns
    the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`second`: This returns the second parameter that was passed in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`answer`: This returns the answer to life, the universe, and everything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `answer` closure, we have an extra line that looks like it does not
    have a purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We do this deliberately because the following code is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This type gives us the error Contextual type for closure argument list expects
    two arguments, which cannot be implicitly ignored. As we can see by the error,
    Swift will not let us ignore the expected parameters within the body of the closure.
    In the second closure, Swift assumes that there are two parameters because `$1`
    specifies the second parameter. We can now pass each one of these closures to
    the `getNum()` method to change the functionality of the function to suit our
    needs. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is run, we will receive the following results for each of the
    closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The last example we are going to show you is one that is used a lot in frameworks,
    especially ones that have a functionality that is designed to be run asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a closure based on results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final example, we will pass two closures to a method, and then, depending
    on some logic, one or possibly both of the closures will be executed. Generally,
    one of the closures is called if the method was successfully executed and the
    other closure is called if the method failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a type that will contain a method that will accept
    two closures and then execute one of the closures based on the defined logic.
    We will name this type `TestType`. Here is the code for the `TestType` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We begin this type by creating a `typealias` that defines the closure that we
    will use for both the successful and failure closures. We will name this `typealiasResultsClosure`.
    This example also illustrates why you should use a `typealias` rather than retyping
    the closure definition. It saves us a lot of typing and prevents us from making
    mistakes. In this example, if we do not use a `typealias`, we would need to retype
    the closure definition four times, and if we need to change the closure definition,
    we would need to change it in four spots. With the type alias, we only need to
    type the closure definition once and then use the alias throughout the remaining
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a method named `isGreater`, which takes two integers as the
    first two parameters, and two closures as the next two parameters. The first closure
    is named `successHandler`, and the second closure is named `failureHandler`. Within
    this method, we check whether the first integer parameter is greater than the
    second. If the first integer is greater, the `successHandler` closure is executed;
    otherwise, the `failureHandler` closure is executed. Now, let''s create two closures
    outside of the `TestType` structure. The code for these two closures is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that both closures are defined as the `TestClass.ResultsClosure` type.
    In each closure, we simply print a message to the console to let us know which
    closure was executed. Normally, we would put some functionality in the closure.
    We will then call the method with both the closures, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the method call, we are sending both the success closure and the
    failure closure. In this example, we will see the `Success: 8 is greater than
    6` message. If we reversed the numbers, we would see the `Failure: 6 is not greater
    than 8` message. This use case is really good when we call asynchronous methods,
    such as loading data from a web service. If the web service call was successful,
    the success closure is called; otherwise, the failure closure is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One big advantage of using closures like this is that the UI does not freeze
    while we wait for the asynchronous call to complete. This also involves a concurrency
    piece, which we will be covering in *Chapter 16*, *Concurrency and Parallelism
    in Swift*. As an example, imagine we tried to retrieve data from a web service
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our UI would freeze while we waited for the response, or we would have to make
    the call in a separate thread so that the UI would not hang. With closures, we
    pass the closures to the networking framework and rely on the framework to execute
    the appropriate closure when it is done. This relies on the framework to implement
    concurrency correctly, to make the calls asynchronously, but a decent framework
    should handle that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that we can define a closure just like we can define
    an integer or string type. We can assign closures to a variable, pass them as
    an argument to functions, and return them from functions. Closures capture strong
    references to any constants or variables from the context in which the closure
    was defined. We do have to be careful with this functionality, to make sure that
    we do not create a strong reference cycle, which would lead to memory leaks in
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Swift closures are very similar to blocks in Objective-C, but they have a much
    cleaner and more eloquent syntax. This makes them a lot easier to use and understand.
    Having a good understanding of closures is vital to mastering the Swift programming
    language and will make it easier to develop great applications that are easy to
    maintain. They are also essential for creating first-class frameworks that are
    easy both to use and to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The use cases that we looked at in this chapter are by no means the only useful
    use cases for closures. I can promise you that the more you use closures in Swift,
    the more uses you will find for them. Closures are definitely one of the most
    powerful and useful features of the Swift language, and Apple did a great job
    by implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can use the advanced bitwise operators
    provided by Swift and how we can create our own custom operators.
  prefs: []
  type: TYPE_NORMAL
