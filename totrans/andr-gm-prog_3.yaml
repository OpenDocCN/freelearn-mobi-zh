- en: Part 3. Module 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分. 第3模块
- en: '***Mastering Android Game Development***'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***精通Android游戏开发***'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Master game development with the Android SDK to develop highly interactive
    and amazing games*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*使用Android SDK精通游戏开发，开发高度互动和令人惊叹的游戏*'
- en: Chapter 1. Setting Up the Project
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 设置项目
- en: In this chapter, we will describe the situations in which it makes sense to
    use the Android SDK for a game and those where it is best to use an external engine,
    explaining the pros and cons of each case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述使用Android SDK进行游戏开发是有意义的场景，以及最好使用外部引擎的场景，解释每种情况的优势和劣势。
- en: We will create a simple project that we will be improving throughout the book,
    until it becomes a complete game. The particular game we are going to build is
    a Space Shooter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的项目，我们将在整本书中对其进行改进，直到它成为一个完整游戏。我们将要构建的游戏是一个太空射击游戏。
- en: A few top-level decisions will be made and explained, such as which orientation
    to use and how are we going to use activities and fragments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将做出一些高级决策并解释，例如使用哪种方向以及我们将如何使用活动和片段。
- en: We will describe the top-level architecture of a game engine, study how it is
    different from a typical app's, explaining why there is an `UpdateThread` and
    how it interacts with the user input and why it is separated from the `DrawThread`;
    we will include those elements in our project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述游戏引擎的高级架构，研究它与典型应用程序的不同之处，解释为什么存在`UpdateThread`以及它是如何与用户输入交互的，以及为什么它被从`DrawThread`中分离出来；我们将在我们的项目中包含这些元素。
- en: Once the game engine is completed, we will expand the project to show a pause
    dialog, handle the Android back key properly, be consistent with the `Activity`
    lifecycle, and make it fullscreen.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏引擎完成，我们将扩展项目以显示暂停对话框，正确处理Android返回键，保持与`Activity`生命周期的连贯性，并使其全屏。
- en: Finally, we will summarize some best practices in writing code for games.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将总结一些编写游戏代码的最佳实践。
- en: 'Topics that will be covered in this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The right tool for the right game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合游戏的正确工具
- en: Setting up the project with Android Studio
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android Studio设置项目
- en: Game architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏架构
- en: Alert dialogs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告对话框
- en: Handling the back key
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理返回键
- en: Dealing with the fullscreen mode
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理全屏模式
- en: Good practices for game developers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开发者最佳实践
- en: The right tool for the right game
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合游戏的正确工具
- en: Before we begin entering the details about making games with the Android SDK,
    let's first take a step back and consider why are we doing this and what the other
    alternatives are for making a game that runs on Android.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始详细讨论使用Android SDK制作游戏之前，让我们先退一步，考虑我们为什么要这样做，以及制作在Android上运行的游戏的其他替代方案是什么。
- en: People tend to reinvent the wheel quite often and developers use to do it ever
    more, especially in the case of video games. While creating a complete engine
    from scratch is a great learning experience, it also takes a lot of time. So,
    if you want to just make a game, it may be more cost-efficient for you to use
    one of the existing engines instead.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 人们往往经常重新发明轮子，开发者更是如此，尤其是在视频游戏领域。虽然从头开始创建一个完整的引擎是一个很好的学习经历，但它也花费了很多时间。所以，如果你只是想制作一个游戏，使用现有的引擎可能对你来说更经济高效。
- en: We are in a golden age of tools for creating video games. Not only are there
    lots of them, but most of them are free as well. This makes choosing the right
    one a little bit more complicated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正处于视频游戏制作工具的黄金时代。不仅有大量的工具，而且其中大多数都是免费的。这使得选择正确的工具变得更加复杂。
- en: Let's take a look at several questions to help us decide which tool to use to
    suit the needs of a specific game. Since you are already reading this book, I
    consider that multiplatform is not high on your list of priorities and that reusing
    your existing Java and Android knowledge is a plus.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个问题，以帮助我们决定使用哪种工具来满足特定游戏的需求。由于你已经在阅读这本书，我认为多平台不是你优先考虑的事项，而且重用你现有的Java和Android知识是一个加分项。
- en: '![The right tool for the right game](img/B04757_01_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![适合游戏的正确工具](img/B04757_01_01.jpg)'
- en: Do you want to use 3D?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你想使用3D吗？
- en: If the answer is yes; I would definitely recommend you to use an already existing
    engine. There are some well-known tasks you'll need to implement to build even
    the simplest 3D engine such as loading models, loading and applying textures,
    handling transformations, and dealing with cameras. On top of this, you'd need
    to be writing OpenGL. All this is a lot of work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是肯定的；我肯定会推荐你使用一个已经存在的引擎。你需要实现一些已知任务来构建甚至最简单的3D引擎，例如加载模型、加载和应用纹理、处理变换以及处理相机。除此之外，你还需要编写OpenGL。所有这些都需要大量的工作。
- en: Writing an OpenGL engine is the very definition of reinventing the wheel. It
    is fine if what you want is to learn the internals of a 3D engine, but if you
    go this road you'll spend a few months before you can even start with the game.
    If you want to go straight into making the game, you'd better start with an existing
    3D engine.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编写OpenGL引擎是重新发明轮子的非常定义。如果你想要学习3D引擎的内部结构，这是很好的学习经历，但如果你选择这条路，你将花费几个月的时间才能开始游戏。如果你想直接制作游戏，你最好从一个现有的3D引擎开始。
- en: 'The second question on this road is: do you prefer to work with code or are
    you more comfortable with a complete editor? For code, you can use jPCT-AE and
    libGDX, while, on the editor side, the most common alternative is Unity.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条路上，第二个问题是：你更喜欢与代码一起工作，还是更习惯于使用完整的编辑器？对于代码，你可以使用jPCT-AE和libGDX，而在编辑器方面，最常见的选择是Unity。
- en: Do you want to use physics?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你想使用物理吗？
- en: An affirmative answer to this question should point you straight to an existing
    engine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的肯定回答应该直接指向一个现有的引擎。
- en: Physics simulation is a very well-known area where there is a lot of documentation,
    and you should be able to implement your own physics engine. Again, this is a
    great learning experience, but if you want to go straight into making the game
    it is much more convenient to use an existing engine that supports physics. The
    most used physics engine around is Box2D, which is written in C++ and it has been
    ported to Android using the NDK.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 物理模拟是一个众所周知且有很多文档的领域，你应该能够实现自己的物理引擎。再次强调，这是一个很好的学习经历，但如果你想直接制作游戏，使用支持物理的现有引擎会方便得多。最常用的物理引擎是Box2D，它用C++编写，并已通过NDK移植到Android。
- en: While we are going to talk about collision detection later in the book, physics
    is out beyond the scope of this book. Anything more complex than two spheres colliding
    can become quite complex to handle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本书的后面部分讨论碰撞检测，但物理超出了本书的范围。任何比两个球体碰撞更复杂的情况都可能变得难以处理。
- en: Once again, it depends whether you prefer to work with code or if you want a
    complete editor. To work with code, AndEngine should be your weapon of choice.
    In the case of an editor, Corona and Unity are among the most popular choices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，这取决于你是否更喜欢与代码一起工作，或者你是否需要一个完整的编辑器。如果你想与代码一起工作，AndEngine应该是你的首选武器。在编辑器的方面，Corona和Unity是最受欢迎的选择之一。
- en: Do you want to use Java?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你想使用Java吗？
- en: Most of the feature-rich environments we are mentioning have their own environment,
    including a specific IDE. It takes effort to learn them and some of them use a
    different language (for example Unity has its own environment and uses JavaScript
    or C#).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所提到的功能丰富的环境都有自己的环境，包括一个特定的IDE。学习它们需要付出努力，其中一些使用不同的语言（例如Unity有自己的环境，并使用JavaScript或C#）。
- en: On the other hand, the frameworks are simpler. You just have to include them
    and you'll still be writing an Android game. This is an interesting middle ground,
    where you still can reuse your Android and Java knowledge and make use of features
    such as physics or 3D models. In this section, we can mention AndEngine for 2D
    and physics and jPCT-AE for 3D as good options.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，框架更简单。你只需要包含它们，你仍然可以编写Android游戏。这是一个有趣的中间地带，你仍然可以重用你的Android和Java知识，并利用诸如物理或3D模型等功能。在本节中，我们可以提到AndEngine作为2D和物理以及jPCT-AE作为3D的好选择。
- en: Pros of building games with the Android SDK
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Android SDK构建游戏的优点
- en: 'There are several advantages to building games using the Android SDK:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android SDK构建游戏有几个优点：
- en: It is faster to build a prototype
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建原型更快
- en: You have full control over the engine
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对引擎有完全的控制权
- en: It has a smaller learning curve (you already know Android, Java, and Android
    Studio)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的学习曲线较小（你已经知道Android、Java和Android Studio）
- en: Most of your knowledge can be applied to apps
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的大部分知识可以应用于应用
- en: You can use Google Play services and other libraries natively
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Google Play服务和其他库进行原生操作
- en: Cons of building games with the Android SDK
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Android SDK构建游戏的缺点
- en: 'Of course, not everything is awesome. There are some serious disadvantages,
    most of them already mentioned, such as:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非一切都很完美。有一些严重的缺点，其中大部分已经提到，例如：
- en: The code is not portable to other platforms (namely iOS).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不可移植到其他平台（特别是 iOS）。
- en: Performance can be an issue. If the game gets to a certain complexity, you may
    need to use OpenGL.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能可能是一个问题。如果游戏达到一定的复杂度，你可能需要使用 OpenGL。
- en: It lacks a physics engine; you'd need to write it yourself.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它缺少物理引擎；你需要自己编写。
- en: The support for OpenGL is just primitives; you need to build everything (or
    use a library).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL 的支持仅仅是基本原语；你需要构建一切（或使用一个库）。
- en: I want the Android SDK!
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我想要 Android SDK！
- en: Are you still here? Congratulations, you have chosen the right book!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在这里吗？恭喜你，你选择了正确的书籍！
- en: If you want to explore other options, there are books available for Unity, AndEngine,
    and libGDX, and published by Packt.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索其他选项，有关于 Unity、AndEngine 和 libGDX 的书籍可供选择，由 Packt 出版。
- en: Now that we are all on the same page, let's get down to business.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们都在同一页面上，让我们开始吧。
- en: The project – YASS (Yet Another Space Shooter)
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – YASS（另一个太空射击游戏）
- en: Along the book, we will be building a game as a demo of the concepts we will
    be studying in each chapter. The game is going to be a classic Space Shooter arcade
    game. We'll call it YASS—Yet Another Space Shooter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将构建一个游戏作为每个章节我们将要学习概念的演示。这个游戏将是一个经典的太空射击街机游戏。我们将称之为 YASS – 另一个太空射击游戏。
- en: This means some decisions will be taken for this particular type of game, but
    other options will also be commented since the book is meant for generic video
    game development.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于这种特定类型的游戏，将做出一些决定，但也会讨论其他选项，因为这本书旨在介绍通用的视频游戏开发。
- en: Activities and Fragments
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动和片段
- en: We are going to create a project with a single `Activity` and we will add fragments
    when necessary.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个只有一个 `Activity` 的项目，并在必要时添加片段。
- en: In the versions prior to Android 5.0 Lollipop, the transitions between activities
    could be modified, but only in a very limited way. The user can even disable them
    in a setting. All in all, this will make your game look clunky while transitioning
    from one `Activity` to another. You will need to save the state of the `Activity`
    in case it gets destroyed. Since each `Activity` is a separate instance, you will
    need to take care of communication among them, if required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 5.0 Lollipop 之前的版本中，活动之间的转换可以被修改，但只能以非常有限的方式。用户甚至可以在设置中禁用它们。总的来说，这将在从一个
    `Activity` 切换到另一个 `Activity` 时使你的游戏看起来很笨拙。如果你需要保存 `Activity` 的状态，以防它被销毁。由于每个 `Activity`
    都是一个独立的实例，如果你需要，你需要注意它们之间的通信。
- en: On the other hand, when you work with fragments, you never exit the `Activity`
    and you have complete control over the transition animations. In addition to these,
    you still have the code and layout of each section separated, so modularity and
    encapsulation are not compromised.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你与片段一起工作时，你永远不会退出 `Activity`，并且你对过渡动画有完全的控制权。除此之外，你仍然有每个部分的代码和布局分离，因此模块化和封装没有受到影响。
- en: Finally, when it comes to handling third-party libraries such as In-App Billing
    or Google Play services, you have to take care if initialization and configuration
    only once, since those are linked at the `Activity` level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当涉及到处理第三方库，如 In-App Billing 或 Google Play 服务时，你必须确保初始化和配置只进行一次，因为这些是在 `Activity`
    级别链接的。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For games, it is more efficient to use only one Activity with multiple Fragments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏，使用一个 `Activity` 和多个片段会更有效率。
- en: One good practice is to have a base `Fragment` for our game (`YassBaseFragment`)
    from which all the other fragments will inherit. One good use of this fragment
    is to have a method to replace `getActivity` that returns our specific `Activity`,
    but there are other cases in which having a common base fragment is handy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是有一个基础 `Fragment` 用于我们的游戏（`YassBaseFragment`），所有其他片段都将从这个片段继承。这个片段的一个很好的用途是有一个替换
    `getActivity` 的方法，它返回我们的特定 `Activity`，但还有其他情况下，有一个公共基础片段会很有用。
- en: Project setup
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设置
- en: We are going to use Android Studio as the IDE. We are going to create the project
    with `minSDK` 15 (Ice Cream Sandwich—ICS). As a good practice, we don't want to
    move the minimum SDK, unless we are using some features that were not available
    before. By keeping the `minSDK` low, you make your game available to as many devices
    as possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 作为 IDE。我们将创建一个 `minSDK` 为 15（冰淇淋三明治 – ICS）的项目。作为一个好的做法，我们不想移动最低
    SDK，除非我们正在使用一些之前不可用的功能。通过保持 `minSDK` 低，你使你的游戏尽可能多的设备可用。
- en: The two main features we are going to use from ICS are `Fragments`, `ValueAnimators`,
    and `ViewPropertyAnimators`. All of these were already available in Honeycomb,
    but 3.x is considered little more than a test for ICS; it was not mature and has
    been replaced by ICS in almost all devices.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从ICS使用两个主要功能：`Fragments`、`ValueAnimators`和`ViewPropertyAnimators`。所有这些在Honeycomb中都已经可用，但3.x被认为只是对ICS的一个测试；它并不成熟，并且几乎在所有设备上都被ICS所取代。
- en: In the unlikely case that you want to support older versions such as Gingerbread,
    you can make use of the compatibility library and NineOldAndroids to add backwards-compatibility
    for the features we are using.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在不太可能的情况下，如果你想支持旧版本，如Gingerbread，你可以使用兼容库和NineOldAndroids来为使用的功能添加向后兼容性。
- en: Creating the stub project
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建存根项目
- en: Let's go on and navigate to **File** > **New Project**. We are going to use
    `YASS` as the **Application name** and `example.com` as the **Company Domain**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并导航到**文件** > **新建项目**。我们将使用`YASS`作为**应用程序名称**，`example.com`作为**公司域名**。
- en: '![Creating the stub project](img/B04757_01_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![创建存根项目](img/B04757_01_02.jpg)'
- en: We include support for Android TV, since we want to be able to run our game
    on the big screen. This will create an extra module that we can compile for, but
    we are not going to touch this until the last chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括对Android TV的支持，因为我们希望能够在大屏幕上运行我们的游戏。这将创建一个额外的模块，我们可以为其编译，但我们不会在最后一章之前接触它。
- en: As explained before, we will use **Minimum SDK** version 15 for phones and 21
    for Android TV, since this is when it was made available.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将为手机使用**最小SDK版本**15，为Android TV使用21，因为这是它们可用的时候。
- en: For the **Package name** of the application, we are going to use `com.example.yass`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序的**包名**，我们将使用`com.example.yass`。
- en: '![Creating the stub project](img/B04757_01_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建存根项目](img/B04757_01_03.jpg)'
- en: 'We are not going to use any of the default wizards, since all of them include
    the action bar/toolbar that is great for apps, but of no use for games. So, we''ll
    go with the empty project options:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用任何默认向导，因为它们都包括对应用程序来说很棒但对我们游戏无用的动作栏/工具栏。因此，我们将选择空项目选项：
- en: '![Creating the stub project](img/B04757_01_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![创建存根项目](img/B04757_01_04.jpg)'
- en: 'Similarly, we are not going to create any Activity for TV:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们不会为电视创建任何Activity：
- en: '![Creating the stub project](img/B04757_01_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![创建存根项目](img/B04757_01_05.jpg)'
- en: Once the project is created, we will create a single `Activity` with one `Fragment`.
    This is done via the menu option **New** > **Activity** > **Blank Activity with
    Fragment**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，我们将创建一个包含一个`Fragment`的单个`Activity`。这是通过菜单选项**新建** > **Activity** >
    **带有Fragment的空白Activity**完成的。
- en: '![Creating the stub project](img/B04757_01_06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![创建存根项目](img/B04757_01_06.jpg)'
- en: 'We are going to customize the `Activity` by filling the dialog as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自定义`Activity`，如下填写对话框：
- en: '**Activity Name**: `YassActivity`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Activity名称**: `YassActivity`'
- en: '**Layout Name**: `activity_yass` (will be the default as soon as we change
    the Activity name)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局名称**: `activity_yass`（一旦我们更改Activity名称，它将成为默认值）'
- en: '**Fragment Layout Name**: `fragment_yass` (will be the default as soon as we
    change the Activity name)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fragment布局名称**: `fragment_yass`（一旦我们更改Activity名称，它将成为默认值）'
- en: '**Title**: `YassActivity`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**: `YassActivity`'
- en: 'This will create the following files:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下文件：
- en: '`YassActivity.java` with the code for `YassActivity` and `PlaceholderFragment`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YassActivity.java`包含`YassActivity`和`PlaceholderFragment`的代码'
- en: '`activity_main.xml`: A `FrameLayout` with `@+id/container`, which will be used
    to load the fragments into'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activity_main.xml`：一个带有`@+id/container`的`FrameLayout`，它将被用来加载片段'
- en: '`fragment_main.xml`: A placeholder layout with the text `Hello World!`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragment_main.xml`：一个带有文本`Hello World!`的占位符布局'
- en: 'Since we did not tell Android Studio that this activity is going to be our
    launch activity, we need to edit the `AndroidManifest.xml` to configure it as
    such, by adding the proper intent filter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有告诉Android Studio这个活动将成为我们的启动活动，我们需要编辑`AndroidManifest.xml`来配置它，通过添加适当的intent过滤器：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Cleaning up
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理工作
- en: We are not going to use menus at all, so there are a few methods and files we
    will not need and we can delete them. You can leave all those methods there if
    you want, but it is better to have a clean environment, free of unused code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完全不使用菜单，因此有一些方法和文件我们将不需要，我们可以删除它们。如果你想保留所有这些方法，也可以，但保持一个干净的环境，没有未使用的代码会更好。
- en: So, we can remove the `menu` folder under `resources` and the files in it, which
    are meant to be the menu for the `YassActivity`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以删除`resources`下的`menu`文件夹及其中的文件，这些文件原本是`YassActivity`的菜单。
- en: 'The methods that handle menu-creation and menu-item-selection are also useless,
    so we can remove the following methods from `YassActivity`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 处理菜单创建和菜单项选择的方法也是无用的，因此我们可以从 `YassActivity` 中移除以下方法：
- en: '`onCreateOptionsMenu`: Invoked when the menu is created'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateOptionsMenu`：当菜单创建时被调用'
- en: '`OnOptionsItemSelected`: Invoked when an option from the menu is selected'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnOptionsItemSelected`：当从菜单中选择一个选项时被调用'
- en: Choosing an orientation
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择方向
- en: Deciding the orientation of a game is a very important point. Given the diversity
    of Android phones, the resolution and aspect ratio are a couple of things we have
    to deal with.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 决定游戏的方向是一个非常关键的问题。鉴于 Android 手机的多样性，分辨率和宽高比是我们必须处理的一些事情。
- en: 'Gaming is traditionally done in landscape orientation: computers have monitors
    in landscape mode, and so do TV screens when you play with your gaming console.
    Almost all handheld consoles are designed with landscape orientation as well.
    Even more, most tablets consider landscape to be the default orientation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏传统上是在横屏方向进行的：电脑显示器是横屏模式，当你用游戏机玩游戏时，电视屏幕也是横屏模式。几乎所有便携式游戏机也都是设计成横屏方向的。更重要的是，大多数平板电脑也将横屏视为默认方向。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Landscape is the traditional orientation for gaming.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 横屏是游戏的传统方向。
- en: YASS is going to be a landscape game. The key reason why we are doing it is
    to be able to port the game to Android consoles later on, both on Android TV and
    OUYA. This does not mean that the portrait mode is not a valid orientation for
    games, but it is a less familiar one for players.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: YASS 将是一款横屏游戏。我们这样做的主要原因是将来能够将游戏移植到 Android 控制台，包括 Android TV 和 OUYA。这并不意味着竖屏模式不是游戏的有效方向，但对于玩家来说，它是一个不太熟悉的方向。
- en: 'We are going to use `sensorLandscape` instead of just `landscape`, so the device
    can rotate 180 degrees to adjust to whatever side is down. We have to update the
    `AndroidManifest.xml` to look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `sensorLandscape` 而不是仅仅 `landscape`，这样设备就可以旋转 180 度以适应任何朝下的侧面。我们必须更新 `AndroidManifest.xml`
    以使其看起来像这样：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you probably know, when an `Activity` changes orientation on Android, it
    is destroyed and recreated and so are all the fragments inside it. This means
    that, unless you explicitly save and restore information, the fragments will not
    remember the previous state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当 Android 中的 `Activity` 改变方向时，它会被销毁并重新创建，以及其中所有的片段。这意味着，除非你明确保存和恢复信息，否则片段将不会记住之前的状态。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sensorLandscape` and `sensorPortrait` modes do not destroy activities on
    rotation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensorLandscape` 和 `sensorPortrait` 模式在旋转时不会销毁活动。'
- en: 'Some good news here: while using `sensorLandscape`, the rotation does not kill
    the Activity, so no extra work is required. This happens because the layout is
    exactly the same and nothing needs to be recreated.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些好消息：在使用 `sensorLandscape` 时，旋转不会杀死 Activity，因此不需要额外的工作。这是因为布局完全相同，不需要重新创建任何内容。
- en: If you plan to make a game that can rotate, you must pay extra attention to
    saving and restoring the status of the game when the orientation changes. This
    in itself is another good reason to keep the game locked to a particular orientation,
    be it landscape or portrait.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划制作一个可以旋转的游戏，你必须特别注意在方向改变时保存和恢复游戏状态。这本身就是将游戏锁定在特定方向（无论是横屏还是竖屏）的另一个很好的理由。
- en: Dealing with aspect ratios
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理宽高比
- en: Android devices come in a lot of different aspect ratios, form 4:3 to 16:9 at
    least. This is not counting the number of pixels.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备拥有许多不同的宽高比，至少从 4:3 到 16:9。这还不包括像素的数量。
- en: While designing a game for multiple aspect ratios, there are basically two ways
    of doing it. For each of them, we design for the most extreme aspect ratio. We
    will be using the extra space for "smart letterboxes," which means that we can
    have more game view.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在为多个宽高比设计游戏时，基本上有两种方法。对于每一种方法，我们都为最极端的宽高比进行设计。我们将使用额外的空间来制作“智能信箱”，这意味着我们可以有更多的游戏视图。
- en: '![Dealing with aspect ratios](img/B04757_01_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![处理宽高比](img/B04757_01_07.jpg)'
- en: Several ways of designing for different aspect ratios
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 设计不同宽高比的不同方法
- en: The most common option is to make the camera centered and fix the smallest size
    (the height for the landscape orientation). This allows for more view space on
    the sides, while making sure that the smallest screen will have enough display
    space. This is the equivalent of viewing 4:3 images on a 16:9 screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的选项是将相机置于中心并固定最小尺寸（横屏方向的高度）。这允许在两侧有更多的视图空间，同时确保最小的屏幕将有足够的显示空间。这在 16:9 屏幕上查看
    4:3 图像是等效的。
- en: You can also fix the bigger size if the game design makes sense. This will add
    extra space on the top and bottom if the screen is square. This is the equivalent
    of viewing 16:9 images on a 4:3 screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏设计合理，你也可以固定更大的尺寸。如果屏幕是正方形，这将增加顶部和底部的额外空间。这相当于在4:3屏幕上查看16:9的图像。
- en: 'There is an alternative approach: simply having "more camera space." We can,
    as well, make the game view a certain size and use the extra space for other controls
    such as scores, levels, and so on.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是简单地拥有“更多的相机空间”。我们还可以使游戏视图达到一定大小，并使用额外的空间来放置其他控件，如得分、等级等。
- en: If you take this approach to the extreme, you can design the game area completely
    square and put the extra information in "smart letterboxes" for both landscape
    and portrait. One very good example of this approach is done by Candy Crush Saga.
    This is the best approach for versatility, but it is also the one that requires
    the most work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这种方法推向极致，你可以设计一个完全平方的游戏区域，并将额外信息放在“智能信封”中，适用于横屏和竖屏。一个很好的例子是Candy Crush Saga。这是最灵活的方法，但也是需要最多工作量的方法。
- en: For our game, we are going to use a "more camera space" approach with fixed
    size letterboxes to display scores and lives.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们将采用“更接近相机空间”的方法，使用固定大小的信封来显示得分和生命值。
- en: For the difference in resolution and pixel density, we will be designing for
    a low density screen. We will read the resolution of the device programmatically
    and apply a conversion factor. Some in-depth details of this approach are given
    in the chapters dedicated to low-level drawing, menus, and dialogs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分辨率和像素密度的差异，我们将为低密度屏幕进行设计。我们将以编程方式读取设备的分辨率并应用一个转换因子。关于这种方法的一些深入细节可以在专门介绍低级绘图、菜单和对话框的章节中找到。
- en: Game architecture
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏架构
- en: Games have a different architecture and control flow than apps. Both seem to
    respond to user input instantly, but while an app does this by setting listeners
    and reacting to events with method calls (most commonly the `onClick` method calls
    the `OnClickListener`), this approach is not valid for a real-time game (although
    it is valid for non-real-time games).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的架构和控制流程与应用程序不同。两者似乎都能即时响应用户输入，但应用程序是通过设置监听器并使用方法调用（最常见的是`onClick`方法调用`OnClickListener`）来做到这一点的，而对于实时游戏来说，这种方法是不适用的（尽管对于非实时游戏是适用的）。
- en: Once a game is running, it must evaluate and update everything as fast as possible.
    This is the reason why it cannot be interrupted by user events. Those events or
    states should be recorded instead and then read by the game objects during its
    update.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏开始运行，它必须尽可能快地评估和更新一切。这也是为什么它不能被用户事件中断的原因。这些事件或状态应该被记录下来，然后在游戏对象的更新过程中读取。
- en: The game engine should be created inside the fragment that runs the game, because
    we only need the game engine running while we are playing. This has the advantage
    that we can use our existing Android knowledge to create and handle the rest of
    the screens of the game.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎应该创建在运行游戏的片段中，因为我们只需要在玩游戏时运行游戏引擎。这有一个优点，那就是我们可以利用我们现有的Android知识来创建和处理游戏的其他屏幕。
- en: '![Game architecture](img/B04757_01_08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![游戏架构](img/B04757_01_08.jpg)'
- en: Simplified architecture of a game engine
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎的简化架构
- en: The basic **Game Engine** architecture is composed of an **Update Thread**,
    a **Draw Thread**, and a series of **Game Objects** that belong to the **Game
    Engine**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的游戏引擎架构由一个**更新线程**、一个**绘图线程**和一系列属于**游戏引擎**的**游戏对象**组成。
- en: The **Game Engine** is the component through which the rest of the program interacts
    with the game. Its mission is also to encapsulate the existence of the update
    and draw threads as well as to handle the game objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏引擎**是程序其他部分与游戏交互的组件。它的任务也是封装更新和绘图线程的存在，以及处理游戏对象。'
- en: A game is composed of **Game** **Objects** that are both updated and drawn.
    These objects are held inside the **Game Engine**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个游戏由既更新又绘制的**游戏对象**组成。这些对象被保存在**游戏引擎**内部。
- en: The **Update Thread** is responsible for updating the state of the game objects
    as fast as it can. It will run through all the game objects calling an update
    method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新线程**负责尽可能快地更新游戏对象的状态。它将遍历所有游戏对象，调用更新方法。'
- en: The UI has to also be constantly updating and be independent of the update thread.
    It will draw all the game objects by calling a draw method on them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: UI 也必须不断更新，并且独立于更新线程。它将通过在它们上调用绘图方法来绘制所有游戏对象。
- en: Let's analyze each component in detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析每个组件。
- en: GameEngine and GameObjects
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameEngine 和 GameObjects
- en: The `GameEngine` contains the three elements already mentioned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEngine` 包含了前面提到的三个元素。'
- en: '`GameObject` is an abstract class that all game objects in our game must extend
    from. This interface connects them with the `Update` and `Draw` threads.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject` 是一个抽象类，我们游戏中的所有游戏对象都必须从这个类扩展。这个接口将它们与 `Update` 和 `Draw` 线程连接起来。'
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`startGame` is used for the initialization of the object before a game can
    start.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startGame` 用于在游戏开始之前初始化对象。'
- en: '`onUpdate` is called by the game engine as fast as possible, providing the
    number of milliseconds that have passed since the previous call and a reference
    to the `GameEngine` itself for future uses such as accessing user input.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate` 被游戏引擎尽可能快地调用，提供自上次调用以来经过的毫秒数以及 `GameEngine` 本身的引用，供将来使用，例如访问用户输入。'
- en: '`onDraw` makes the component render itself. We are not using any parameters
    just yet, but later we will pass a `Canvas` to draw on.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDraw` 使组件能够渲染自身。我们目前还没有使用任何参数，但稍后我们将传递一个 `Canvas` 来绘制。'
- en: '`onRemovedFromGameUiThread` contains code that must be run on the `UIThread`
    when the object is removed from the game.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRemovedFromGameUiThread` 包含了当对象从游戏中移除时必须在 `UIThread` 上运行的代码。'
- en: '`onAddedToGameUiThread` contains code that must be run on the `UIThread` when
    the object is added to the game.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAddedToGameUiThread` 包含了当对象被添加到游戏时必须在 `UIThread` 上运行的代码。'
- en: The two `Runnable` objects are used to call `onRemovedFromGameUiThread` and
    `onAddedToGameUiThread` inside the `UIThread`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `Runnable` 对象用于在 `UIThread` 内部调用 `onRemovedFromGameUiThread` 和 `onAddedToGameUiThread`。
- en: The `GameEngine` will provide us with easy methods to start, stop, pause, and
    resume the game, so we don't have to worry about the threads or the game objects
    from the outside.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEngine` 将为我们提供启动、停止、暂停和恢复游戏的方法，这样我们就不必担心外部的线程或游戏对象。'
- en: 'The game engine is composed of three items: the list of game objects, the `UpdateThread`,
    and the `DrawThread`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎由三个项目组成：游戏对象列表、`UpdateThread` 和 `DrawThread`。
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's take a look at the different methods of the engine to handle a game.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看引擎处理游戏的不同方法。
- en: Starting a game
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始游戏
- en: 'The code to start a game from the `GameEngine` is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `GameEngine` 开始游戏的代码如下：
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First of all, we have to make sure that no game is running, so we call `stopGame`
    at the beginning to stop a game if there is one in progress.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确保没有游戏正在运行，因此我们在开始时调用 `stopGame` 来停止正在进行的游戏。
- en: Secondly, we reset all the game objects that are linked to the engine. It is
    important to do this before we start the threads, so everything starts from the
    initial position.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们重置与引擎链接的所有游戏对象。在启动线程之前做这件事很重要，这样一切都可以从初始位置开始。
- en: Finally, we create and start the `UpdateThread` and the `DrawThread`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建并启动 `UpdateThread` 和 `DrawThread`。
- en: Stopping a game
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止游戏
- en: 'Stopping a game is even simpler. We just have to stop the `Update` and `Draw`
    threads if they exist:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 停止游戏甚至更简单。我们只需停止存在的 `Update` 和 `Draw` 线程：
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We also have methods for `pauseGame` and `resumeGame` that are functionally
    equivalent to this one. In these methods, the logic of the action belongs to each
    thread. We are not including the code of these methods here, because they are
    redundant.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 `pauseGame` 和 `resumeGame` 方法，它们的功能与此类似。我们在这里不包括这些方法的代码，因为它们是冗余的。
- en: Managing game objects
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理游戏对象
- en: The engine has to manage the addition and removal of game objects. We cannot
    just handle the list directly, since it will be used intensively during `onUpdate`
    and `onDraw`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎必须管理游戏对象的添加和删除。我们不能直接处理列表，因为它将在 `onUpdate` 和 `onDraw` 期间被大量使用。
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the lists `mObjectsToAdd` and `mObjectsToRemove` to keep track of the
    objects that must be added or removed. We will do both as the last step of the
    `onUpdate` method with the exception of when the game engine is not running, in
    which case it is safe to add and remove them directly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表 `mObjectsToAdd` 和 `mObjectsToRemove` 来跟踪必须添加或删除的对象。我们将这两者都作为 `onUpdate`
    方法的最后一步执行，除非游戏引擎正在运行，在这种情况下，可以直接添加和删除它们。
- en: We are also running the corresponding `Runnable` object from the `GameObject`
    on the `UIThread`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `UIThread` 上从 `GameObject` 运行相应的 `Runnable` 对象。
- en: To update the game objects from the engine, we just call `onUpdate` on all of
    them. Once the update loop has finished, we take care of the objects that must
    be removed or added to `mGameObjects`. This part is done using a `synchronized`
    section that is also important for the `onDraw` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要从引擎更新游戏对象，我们只需在它们所有上调用`onUpdate`。一旦更新循环完成，我们就处理必须从`mGameObjects`中移除或添加的对象。这部分是通过使用`synchronized`代码块来完成的，这对于`onDraw`方法也很重要。
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We do the same for drawing, except that the drawing must be done on the `UIThread`.
    So, we create a `Runnable` object that we pass to the `runOnUIThread` method of
    the activity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘图，我们做的是同样的事情，只不过绘图必须在`UIThread`上完成。因此，我们创建一个`Runnable`对象，并将其传递给活动的`runOnUIThread`方法。
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we synchronize the run method using `mGameObjects`. We do it so we
    are sure that the list is not modified while we iterate it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`mGameObjects`来同步运行方法。我们这样做是为了确保在迭代列表时列表不会被修改。
- en: It is also important that only the last part of the `onUpdate` is synchronized.
    If no objects are added or removed, the threads are independent. If we synchronize
    the complete `onUpdate` method, we will be losing all the advantages of having
    the `Update` and `Draw` threads separated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，只有`onUpdate`的最后一部分需要同步。如果没有对象被添加或移除，线程是独立的。如果我们同步整个`onUpdate`方法，我们将失去将`Update`和`Draw`线程分开的所有优势。
- en: UpdateThread
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UpdateThread
- en: '`UpdateThread` is a thread that continuously runs updates on the game engine.
    For each call to `onUpdate`, it provides the number of milliseconds since the
    previous execution.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateThread`是一个持续在游戏引擎上运行更新的线程。对于每次对`onUpdate`的调用，它提供自上次执行以来的毫秒数。'
- en: 'The basic `run` method of the update thread is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更新线程的基本`run`方法如下：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The thread stays in a loop for as long as the game is running. On each iteration,
    it will get the current time, calculate the elapsed milliseconds since the previous
    run, and call `onUpdate` on the `GameEngine` object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 线程会持续循环，直到游戏运行结束。在每次迭代中，它将获取当前时间，计算自上次运行以来的已过毫秒数，并在`GameEngine`对象上调用`onUpdate`。
- en: While this first version works and is very simple to follow, it can only start
    and stop a game. We want to be able to pause and resume it as well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个第一个版本可行且非常简单易懂，但它只能启动和停止游戏。我们希望能够暂停和恢复它。
- en: 'To pause and resume the game, we need a variable that we read inside the loop
    to check when to pause the execution. We''ll need to keep track of the elapsed
    milliseconds and discount the time spent paused. A simple way to do it is like
    this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂停和恢复游戏，我们需要一个变量，我们在循环内部读取它以检查何时暂停执行。我们需要记录已过毫秒数并扣除暂停所花费的时间。一个简单的方法如下：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code for the `pauseGame` and `resumeGame` methods is just setting the variable
    `mPauseGame` to true or false.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`pauseGame`和`resumeGame`方法的代码只是将变量`mPauseGame`设置为true或false。'
- en: If the game is paused, we enter a while loop in which we will remain until the
    game is resumed. To avoid having an empty loop that runs continuously, we can
    put the thread to sleep for a short amount of time (20 milliseconds). Note that
    `Thread.sleep` can trigger an `InterruptedException`. If that happens we can just
    continue since it is going to be run in 20 milliseconds again. Besides, we are
    going to improve it right now.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏处于暂停状态，我们将进入一个while循环，直到游戏恢复才会退出。为了避免有一个持续运行的空循环，我们可以让线程短暂休眠（20毫秒）。注意，`Thread.sleep`可能会触发`InterruptedException`。如果发生这种情况，我们只需继续，因为它将在20毫秒后再次运行。此外，我们马上就要改进它了。
- en: This approach works, but there is still a lot of idle processing being done.
    For threads, there are mechanisms to pause and resume in a much more efficient
    way. We are going to improve this using `wait`/`notify`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但仍然有大量的空闲处理在进行。对于线程来说，有更高效的暂停和恢复机制。我们将使用`wait`/`notify`来改进这一点。
- en: 'The code can be updated to be like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以更新为如下所示：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `pauseGame` method is the same as before, but we need to update `resumeGame`
    to be at the place from where the lock is notified and released:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`pauseGame`方法与之前相同，但我们需要更新`resumeGame`，使其位于通知和释放锁的位置：'
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the use of `wait`/`notify`, we ensure that the thread will not do any work
    while it is idle and we also know that it will be woken up as soon as we notify
    it. It is important to first set `mPauseGame` to `false` and then awake the thread,
    otherwise the main loop could stop again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wait`/`notify`，我们确保线程在空闲时不会做任何工作，并且我们知道一旦我们通知它，它就会被唤醒。重要的是首先将`mPauseGame`设置为`false`，然后唤醒线程，否则主循环可能会再次停止。
- en: 'Finally, to start and stop the game, we just need to change the values of the
    variables:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要开始和停止游戏，我们只需要改变变量的值：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The game never starts in a paused state. To stop a game, we just need to set
    the `mGameIsRunning` value to `false` and the loop inside the `run` method will
    end.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏永远不会以暂停状态开始。要停止游戏，我们只需将`mGameIsRunning`值设置为`false`，`run`方法中的循环就会结束。
- en: It is important to call `resumeGame` as a part of the `stopGame` method. If
    we call stop while the game is paused, the thread will be waiting, so nothing
    will happen unless we resume the game. If the game is not paused, nothing is done
    inside `resumeGame`, so it does not matter if we called it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stopGame`方法中调用`resumeGame`是很重要的。如果我们暂停游戏时调用停止，线程将等待，除非我们恢复游戏，否则不会发生任何事情。如果游戏没有暂停，`resumeGame`内部没有执行任何操作，所以调用它没有关系。
- en: DrawThread
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DrawThread
- en: There are several ways to implement `DrawThread`. It could be done in a similar
    way to the update thread, but we are going to use a much simpler approach that
    does not use a `Thread`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实现DrawThread的方法有几种。它可以以类似更新线程的方式完成，但我们将使用一种不使用`Thread`的更简单的方法。
- en: 'We are going to use the `Timer` and `TimerTask` classes to send the `onDraw`
    callback to the game engine with a high-enough frequency to render at 30 frames
    per second:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Timer`和`TimerTask`类以足够高的频率将`onDraw`回调发送到游戏引擎，以实现每秒30帧的渲染：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have this method called every 33 milliseconds. In simple implementations,
    this method will just call `invalidate` in the `GameView`, which will cause a
    call to the `onDraw` method of the `View`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每33毫秒调用这个方法。在简单实现中，这个方法将只调用`GameView`中的`invalidate`，这将导致调用`View`的`onDraw`方法。
- en: This implementation relies on one feature of the Android UI. To redisplay views,
    Android has a contingency system that is built in to avoid recurrent invalidates.
    If an invalidation is requested while the view is being drawn, it will be queued.
    If more than one invalidations are queued, they will be discarded as they won't
    have any effect.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现依赖于Android UI的一个特性。为了重新显示视图，Android内置了一个应急系统，以避免重复的无效化。如果在视图正在绘制时请求无效化，它将被排队。如果有多个无效化请求排队，它们将被丢弃，因为它们不会产生任何效果。
- en: With this, if the view takes longer than `TIME_BETWEEN_DRAWS` to be drawn, the
    system will fall back to fewer frames per second automatically.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果视图绘制时间超过`TIME_BETWEEN_DRAWS`，系统将自动回退到每秒更少的帧数。
- en: Later in the book, we will revisit this thread for more complex implementations
    but, for now, let's keep it simple.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将重新访问这个线程以进行更复杂的实现，但现在让我们保持简单。
- en: 'Stopping, pausing, and resuming the `DrawThread` is also simple:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 停止、暂停和恢复`DrawThread`也很简单：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To stop the game, we only need to `cancel` and `purge` the timer. The `cancel`
    method will cancel the timer and all scheduled tasks, while `purge` will remove
    all the canceled tasks from the queue.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止游戏，我们只需要`cancel`和`purge`计时器。`cancel`方法将取消计时器和所有计划中的任务，而`purge`将从队列中删除所有已取消的任务。
- en: Since we do not need to keep track of any state, we can just make the `pauseGame`
    and `resumeGame` equivalents to `stopGame` and start.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要跟踪任何状态，我们只需将`pauseGame`和`resumeGame`与`stopGame`和启动等效。
- en: Note that, if we want to have a smooth game at 30fps, the drawing of all the
    items on the screen must be performed in less than 33 milliseconds. This implies
    that the code of these methods usually needs to be optimized.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想在30fps下有一个平滑的游戏，屏幕上所有项目的绘制必须在不到33毫秒内完成。这意味着这些方法的代码通常需要优化。
- en: User input
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户输入
- en: As we mentioned, user input is to be processed by some input controller and
    then read by the objects that need it, when they need it. We will go into the
    details of such an input controller in the next chapter. For now, we just want
    to check whether the game engine works as expected and handles the start, stop,
    pause, and resume calls properly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，用户输入将由某个输入控制器处理，然后由需要它们的对象在需要时读取。我们将在下一章详细介绍此类输入控制器。现在，我们只想检查游戏引擎是否按预期工作，并且正确处理启动、停止、暂停和恢复调用。
- en: Pause, resume, and start are different from the other user inputs, because they
    affect the state of the engine and threads themselves instead of modifying the
    state of the game objects. For this reason, we are going to use standard event-oriented
    programming to trigger these functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停、恢复和启动与其他用户输入不同，因为它们影响引擎和线程本身的状态，而不是修改游戏对象的状态。因此，我们将使用标准的事件驱动编程来触发这些函数。
- en: Putting everything together
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合起来
- en: Let's pick up our stub project, add all the classes we need to have a working
    game engine, and then modify the code so it allows us to start, stop, pause, and
    resume the game engine and display the number of milliseconds since the game was
    started.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿起我们的原型项目，添加所有必要的类以拥有一个可工作的游戏引擎，然后修改代码以便我们可以启动、停止、暂停和继续游戏引擎，并显示自游戏开始以来的毫秒数。
- en: We will put our current implementation of `GameEngine`, `UpdateThread`, `DrawThread`,
    and `GameObject` inside the `com.example.yass.engine` package.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把当前的`GameEngine`、`UpdateThread`、`DrawThread`和`GameObject`实现放入`com.example.yass.engine`包中。
- en: Next, we will create another package named `com.example.yass.counter`, which
    we will use for the code of this example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个名为`com.example.yass.counter`的包，我们将使用该包中的代码来编写此示例。
- en: Inside `YassActivity`, we have an inner class named `PlaceholderFragment`. We
    are going to rename it to `GameFragment`, refactor it to a separate file, and
    put it under the `com.example.yass.counter` package.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`YassActivity`内部，我们有一个名为`PlaceholderFragment`的内部类。我们将将其重命名为`GameFragment`，将其重构为单独的文件，并将其放入`com.example.yass.counter`包下。
- en: 'We are going to add a `TextView` that will show the number of milliseconds
    and two buttons: one to start and stop the game engine and another one to pause
    and resume it.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`TextView`来显示毫秒数，以及两个按钮：一个用于启动和停止游戏引擎，另一个用于暂停和继续它。
- en: 'We are going to add them to the layout of `fragment_yass_main.xml`, which will
    look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它们添加到`fragment_yass_main.xml`布局中，它将看起来像这样：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the game fragment, we need to add the following code inside `onViewCreated`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏片段，我们需要在`onViewCreated`内部添加以下代码：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the view is created, we create the game engine and add a new `ScoreGameObject`
    to it. Then we set the current fragment as the listener for the two buttons we
    have added.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了视图，我们就创建游戏引擎并添加一个新的`ScoreGameObject`到其中。然后我们将当前片段设置为两个已添加按钮的监听器。
- en: 'The code for `onClick` is very simple; just decide which method to call for
    each button:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick`的代码非常简单；只需为每个按钮决定调用哪个方法：'
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Deciding whether the game should be paused or resumed is as simple as this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 决定游戏是否应该暂停或继续就像这样简单：
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also handle a name change on the button to make sure the UI is consistent.
    In the code, we are making use of the `isPaused` method from `GameEngine`. This
    method just returns the status of the `UpdateThread` object as long as it is not
    null:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还处理了按钮的名称更改，以确保UI的一致性。在代码中，我们使用了`GameEngine`中的`isPaused`方法。只要该对象不为空，该方法就只返回`UpdateThread`对象的状态：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, to play/pause the game and keep the state of the buttons, we will
    add this method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了播放/暂停游戏并保持按钮的状态，我们将添加此方法：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once again, we need a method in the `GameEngine` to know whether it is running
    or not. As we did for the previous one, we just mirror the status of `UpdateThread`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们需要在`GameEngine`中有一个方法来知道它是否正在运行。就像我们之前做的那样，我们只是镜像`UpdateThread`的状态：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the basic connections are done, we can move to the really interesting
    bit: the game object we are creating. This object illustrates the use of each
    method from the `GameObject` class that we have been talking about:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成基本连接，我们就可以进入真正有趣的部分：我们正在创建的游戏对象。这个对象展示了我们一直在讨论的`GameObject`类中每个方法的用法：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `onUpdate` method just keeps adding milliseconds to the total. The total
    is reset when a new game starts and `onDraw` sets the value of the total number
    of milliseconds in the text view.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`onUpdate`方法只是不断地将毫秒数添加到总数中。当新游戏开始时，总数会被重置，而`onDraw`则设置文本视图中总毫秒数的值。'
- en: As expected, `onUpdate` is called a lot more often than `onDraw`. On the other
    hand, `onDraw` is executed on the `UIThread`, which is something we cannot afford
    to do with `onUpdate`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`onUpdate`被调用的次数比`onDraw`多得多。另一方面，`onDraw`是在`UIThread`上执行的，这是我们无法承担`onUpdate`所做的事情。
- en: We can now compile and run the example and check that the timer starts and stops
    when we start and stop the game engine. We can also check that pause and resume
    work as expected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编译并运行示例，检查计时器是否在启动和停止游戏引擎时开始和停止。我们还可以检查暂停和继续是否按预期工作。
- en: Moving forward with the example
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续示例
- en: Now we are going to change the example a bit. We are going to make a pause dialog
    from which we can resume or stop the game. This dialog will be shown if the user
    taps on the pause button and if he or she hits the back key.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将稍微改变一下示例。我们将创建一个暂停对话框，我们可以从中继续或停止游戏。如果用户点击暂停按钮，或者按返回键，将显示此对话框。
- en: Finally, we are going to add one fragment from which the player can start the
    game and we will separate the game fragment from the menu.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个片段，玩家可以从该片段开始游戏，并将游戏片段与菜单分开。
- en: 'So, we''ll be creating `MainMenuFragment.java` and `fragment_main_menu.xml`.
    The content of the layout will be extremely simple:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建 `MainMenuFragment.java` 和 `fragment_main_menu.xml`。布局的内容将非常简单：
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This includes the app title on the screen and a button to start playing:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括屏幕上的应用标题和开始播放的按钮：
- en: '![Moving forward with the example](img/B04757_01_09.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![使用示例继续前进](img/B04757_01_09.jpg)'
- en: 'Inside this fragment, we add a listener to the start button and we make it
    call the `startGame` method. The code of the `startGame` method is very simple
    as well:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段内部，我们添加了一个监听器到启动按钮，并使其调用 `startGame` 方法。`startGame` 方法的代码同样很简单：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using the fragment manager to transition from the current fragment to
    `GameFragment`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用片段管理器从当前片段过渡到 `GameFragment`。
- en: The `beginTransition` method creates the transition itself and we can configure
    it with chained methods.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`beginTransition` 方法创建过渡本身，并且我们可以通过链式方法来配置它。'
- en: We are replacing the fragment inside the view with the `R.id.container` id with
    a `GameFragment`. This will remove the old fragment. If we use `add`, both fragments
    will be shown instead.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用 `R.id.container` id 替换视图内的片段。这将移除旧片段。如果我们使用 `add`，则两个片段都会显示。
- en: Then, we add the fragment to the back stack with no tag, since we don't need
    any. This is very important, because it allows the system to handle the back key
    properly. Everything that is on the back stack of the fragment manager will pop
    up when the back key is pressed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个没有标签的片段到返回栈，因为我们不需要任何标签。这非常重要，因为它允许系统正确处理返回键。当按下返回键时，片段管理器的返回栈上的所有内容都将弹出。
- en: If we do not add the fragment to the back stack, the default behavior when we
    tap on the back key will be to close the app. With the fragment on the back stack,
    we can just rely on the system to handle fragment navigation properly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将片段添加到返回栈，当我们在返回键上点击时，默认行为将是关闭应用。当片段在返回栈上时，我们可以依赖系统正确处理片段导航。
- en: Finally, we commit the transition so the fragment is replaced.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提交过渡，这样片段就会被替换。
- en: Inside the game fragment we have already, we will remove the start/stop dialog
    and modify the pause button to show a dialog from where we can resume or exit
    the current game.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已有的游戏片段内部，我们将移除启动/停止对话框，并修改暂停按钮以显示一个对话框，从该对话框我们可以恢复或退出当前游戏。
- en: 'We want the game to start immediately, so the `onViewCreated` method of the
    `GameFragment` will now look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望游戏立即开始，因此 `GameFragment` 的 `onViewCreated` 方法现在看起来像这样：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will also modify the `onClick` method, removing the old code to start or
    stop, so it looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将修改 `onClick` 方法，移除启动或停止的旧代码，使其看起来像这样：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This simpler version only cares about pausing the game and showing a dialog
    when the pause button is clicked.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更简单的版本只关心暂停游戏，并在点击暂停按钮时显示对话框。
- en: 'For now, we are going to create a default dialog using the `AlertDialog` framework:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用 `AlertDialog` 框架创建一个默认对话框：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The positive button will resume the game, so it calls `resumeGame` in the game
    engine.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正面按钮将恢复游戏，因此它调用游戏引擎中的 `resumeGame`。
- en: The negative button will exit the game, so it calls `stopGame` in the `GameEngine`
    and then `navigateBack` in the parent `Activity`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 负面按钮将退出游戏，因此它调用 `GameEngine` 中的 `stopGame`，然后调用父 `Activity` 中的 `navigateBack`。
- en: 'The `navigateBack` method is nothing more than handling a back key pressed
    in the activity:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigateBack` 方法不过是处理活动中的返回键按下：'
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we put the fragment in the navigation stack, the `MainMenuFragment` will
    be loaded again and the `GameFragment` will be destroyed. The following is how
    the `Pause` dialog looks:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将片段放入导航栈，`MainMenuFragment` 将再次加载，而 `GameFragment` 将被销毁。以下是如何显示 `Pause`
    对话框：
- en: '![Moving forward with the example](img/B04757_01_10.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![使用示例继续前进](img/B04757_01_10.jpg)'
- en: Handling the back key
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理返回键
- en: One of the things we want to do is to handle the back key properly. This is
    something that upsets Android users when it does not work as expected inside games,
    so we'll be paying some special attention to it. There are two places where it
    does not work as expected right now.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的事情之一是正确处理返回键。这是当它不按预期在游戏中工作时让 Android 用户感到沮丧的事情，因此我们将特别关注这一点。目前有两个地方它没有按预期工作。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Handling the back key properly is very important on Android.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上正确处理返回键非常重要。
- en: If we dismiss the **Pause** dialog using the back key, the game will not resume.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用返回键取消**暂停**对话框，游戏将不会恢复。
- en: While in the game fragment, the back key should pause the game. At the moment,
    the back key goes back to the `GameFragment`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏片段中，返回键应该暂停游戏。目前，返回键会返回到`GameFragment`。
- en: For the first problem, we need to add an `OnCancelListener` to the dialog. This
    is different from `OnDismissListener`, which is called every time the dialog is
    dismissed. The `cancel` method is only called when the dialog is canceled.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个问题，我们需要在对话框中添加一个`OnCancelListener`。这与每次对话框被关闭时都会被调用的`OnDismissListener`不同。`cancel`方法仅在对话框被取消时调用。
- en: Also, `OnDismissListener` was introduced in API level 17\. Since we don't need
    it, we will not worry about raising the `minSDK` of the game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`OnDismissListener`是在API级别17中引入的。由于我们不需要它，所以我们不会担心提高游戏的`minSDK`。
- en: 'We update the creation of the **Pause** dialog with the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码更新**暂停**对话框的创建：
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The remaining item is to pause the game when the back key is pressed during
    the game. This is something that needs to be handled in the fragment. As it happens,
    `onBakPressed` is a method available only for activities. We need to code a way
    to expand this to the current fragment.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是当游戏过程中按下返回键时暂停游戏。这是需要在片段中处理的事情。实际上，`onBackPressed`是仅对活动可用的方法。我们需要编写代码来扩展它到当前的片段。
- en: 'We are going to make use of our `YassBaseFragment`, the base class for all
    the fragments in our game, to add the support to `onBackPressed`. We will create
    one `onBackPressed` method here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们的`YassBaseFragment`，这是我们游戏中所有片段的基类，以添加对`onBackPressed`的支持。我们在这里创建一个`onBackPressed`方法：
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `Activity`, we update `onBackClicked` to allow the fragments to override
    it if needed:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Activity`中，我们更新`onBackClicked`以允许片段在需要时覆盖它：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the fragment does not handle the back key press, it will return false. Then,
    we just call the super method to allow the default behavior.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果片段没有处理返回键的按下，它将返回`false`。然后，我们只需调用超类方法以允许默认行为。
- en: '`TAG_FRAGMENT` is very important; it allows us to get the fragment we are adding
    and it is set when we add the fragment to `FragmentTransition`. Let''s review
    the `onCreate` method of `MainActivity`, which was created by the wizard, and
    add the `TAG_FRAGMENT` to the initial `FragmentTransition`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`TAG_FRAGMENT`非常重要；它允许我们获取我们添加的片段，并且在我们将片段添加到`FragmentTransition`时设置。让我们回顾一下由向导创建的`MainActivity`的`onCreate`方法，并将`TAG_FRAGMENT`添加到初始的`FragmentTransition`：'
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is also very important that all the fragments of the application must extend
    from `YassBaseFragment`, otherwise this method will throw a `ClassCastException`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，应用程序的所有片段都必须扩展自`YassBaseFragment`，否则此方法将抛出`ClassCastException`。
- en: 'With all the pieces in place, we now override the `onBackPressed` method inside
    `GameFragment` to show the **Pause** dialog:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有部件就绪后，我们现在在`GameFragment`内部覆盖`onBackPressed`方法以显示**暂停**对话框：
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this, the **Pause** dialog is shown when we click back while in the `GameFragment`.
    Note that we will only show the pause dialog if the `GameEngine` is running. When
    it is not running, we return `false`. The default behavior of Android will trigger
    and the **Pause** dialog, which must be showing, will be canceled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，当我们在`GameFragment`中点击返回时，会显示**暂停**对话框。请注意，我们只有在`GameEngine`正在运行时才会显示暂停对话框。当它没有运行时，我们将返回`false`。Android的默认行为将被触发，并且必须显示的**暂停**对话框将被取消。
- en: Honoring the lifecycle
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尊重生命周期
- en: 'Our game should also be consistent with the Activity lifecycle; especially,
    it should pause whenever the `Activity` pauses. This is very important for mainly
    two reasons:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏也应该与活动生命周期保持一致；特别是，当活动暂停时，它应该暂停。这主要有两个原因：
- en: If the game is put in the background, the user wants it to be paused when it
    returns
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果游戏被置于后台，当它返回时，用户希望它被暂停
- en: As long as the game is running, the update thread will be updating as fast as
    it can, so it will make the phone feel slower
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要游戏在运行，更新线程将尽可能快地更新，因此会使手机感觉更慢
- en: With the current implementation, none of this will happen. You can try pressing
    the home button, you will see that the device does not feel responsive. Also,
    if you put the game again in the foreground using the recent activities button,
    you will see that the timer is still counting.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前实现，这些都不会发生。你可以尝试按一下主页按钮，你会看到设备没有响应。此外，如果你再次使用最近活动按钮将游戏置于前台，你会看到计时器仍在计数。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not respecting the fragment lifecycle will result in performance problems and
    unhappy players.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不尊重片段生命周期会导致性能问题和玩家不满。
- en: 'Solving this is very simple, we just need to be consistent with the fragment
    lifecycle, by adding this code to the `GameFragment`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题非常简单，我们只需要保持片段生命周期的连贯性，通过在`GameFragment`中添加以下代码：
- en: '[PRE35]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this, whenever the fragment is paused, we pause the game and show the dialog,
    so the player can resume again. Also, whenever the fragment is destroyed, we stop
    the game engine.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，每当片段暂停时，我们暂停游戏并显示对话框，以便玩家可以再次继续。另外，每当片段被销毁时，我们停止游戏引擎。
- en: It is important to check whether the game engine is running or not before we
    pause it, since `onPause` is also called when we exit the game. So, if we forget
    to do this, exiting via the pause dialog will make the app crash.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停之前检查游戏引擎是否正在运行非常重要，因为`onPause`在退出游戏时也会被调用。所以，如果我们忘记这样做，通过暂停对话框退出将导致应用崩溃。
- en: Using as much screen as we can
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能使用屏幕空间
- en: 'We are building a game. We want to have all the screen space of the device
    and no distractions. There are two items that take this from us:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发一个游戏。我们希望拥有设备的所有屏幕空间，没有干扰。有两个项目从我们这里拿走了这些：
- en: '**The Status bar**: The bar on the top of the screen where the time, battery,
    WiFi, mobile signal, and notifications are displayed.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态栏**：屏幕顶部的栏，显示时间、电池、WiFi、移动信号和通知。'
- en: '**The Navigation bar**: This is the bar where the `back`, `home`, and `recent`
    buttons are placed. It may be located in different places according to the orientation
    of the device.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航栏**：这是放置“返回”、“主页”和“最近”按钮的栏。它可能根据设备的方向位于不同的位置。'
- en: '![Using as much screen as we can](img/B04757_01_11.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![尽可能使用屏幕空间](img/B04757_01_11.jpg)'
- en: The Status and Navigation bars take up a significant amount of space on the
    screen
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 状态栏和导航栏在屏幕上占据相当大的空间
- en: The **Navigation bar** was introduced on Ice Cream Sandwich as a replacement
    for physical buttons. But, even today, some manufacturers decide to use physical
    buttons instead, so it may or may not be there.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航栏**是在冰淇淋三明治上引入的，作为物理按钮的替代品。但即使今天，一些制造商仍然决定使用物理按钮，所以它可能存在也可能不存在。'
- en: The first thing we can do is to tell the system that we want to be fullscreen.
    There is a flag with the `SYSTEM_UI_FLAG_FULLSCREEN` name, which seems to be what
    we are looking for.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先可以告诉系统我们想要全屏。有一个名为`SYSTEM_UI_FLAG_FULLSCREEN`的标志，这似乎是我们正在寻找的。
- en: The problem is that this flag was introduced in the early versions of Android
    when there was no **Navigation bar**. Back then, it really meant fullscreen but,
    from Ice Cream Sandwich onwards, it just means "remove the **Status bar**".
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，这个标志是在Android早期版本中引入的，当时没有**导航栏**。当时，它确实意味着全屏，但从冰淇淋三明治开始，它仅仅意味着“移除**状态栏**”。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `SYSTEM_UI_FLAG_FULLSCREEN` mode is not really fullscreen.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSTEM_UI_FLAG_FULLSCREEN`模式并不是真正的全屏。'
- en: '![Using as much screen as we can](img/B04757_01_12.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![尽可能使用屏幕空间](img/B04757_01_12.jpg)'
- en: Fullscreen only makes the Status bar go away.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 全屏仅使状态栏消失。
- en: Along with the **Navigation** **bar**, some ways to handle fullscreen were added.
    The approach was revisited in KitKat. So, let's look at our options.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**导航栏**外，还添加了一些处理全屏的方法。这种方法在KitKat中得到了回顾。所以，让我们看看我们的选项。
- en: Before Android 4.4 – almost fullscreen
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android 4.4之前 – 几乎全屏
- en: 'On Android 4.0, together with the **Navigation bar**, two new flags were added
    to handle the **Navigation bar** in addition to the existing fullscreen flag:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 4.0中，除了**导航栏**外，还添加了两个新标志来处理**导航栏**，这些标志是现有全屏标志的补充：
- en: '`SYSTEM_UI_FLAG_HIDE_NAVIGATION`: This tells the system to hide the **Navigation
    bar**'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYSTEM_UI_FLAG_HIDE_NAVIGATION`：这告诉系统隐藏**导航栏**'
- en: '`SYSTEM_UI_FLAG_LOW_PROFILE`: This puts the device in "low profile" mode, dimming
    the icons on the **Navigation bar** and replacing them with just dots'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYSTEM_UI_FLAG_LOW_PROFILE`：这会将设备置于“低配置”模式，将**导航栏**上的图标变暗，并用点替换它们'
- en: While it is true that the "hide navigation" flag hides the Navigation bar completely,
    the bar will reappear as soon as you touch anywhere on the screen, since this
    mode is designed to be used for noninteractive activities such as video playback.
    So, `SYSTEM_UI_FLAG_HIDE_NAVIGATION` is not much use to us.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确实“隐藏导航”标志可以完全隐藏导航栏，但由于这种模式旨在用于非交互式活动，如视频播放，因此一旦你触摸屏幕上的任何地方，导航栏就会重新出现。因此，`SYSTEM_UI_FLAG_HIDE_NAVIGATION`对我们来说并没有太大用处。
- en: Using low profile to dim the navigation bar is a much more logical solution.
    Although we are not getting any extra screen space, the fact that the icons on
    the bar are reduced to small dots allows players to focus a lot more on the content.
    These icons will show when necessary (essentially, when the user taps on the bar)
    and dim again as soon as they are not needed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用低轮廓来降低导航栏亮度是一个更合理的解决方案。尽管我们没有获得额外的屏幕空间，但将导航栏上的图标缩小为小点，使得玩家可以更多地专注于内容。这些图标在必要时（基本上，当用户点击导航栏时）会显示出来，并在不需要时立即变暗。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hiding the navigation bar will only work fine for noninteractive apps. The Navigation
    bar will appear again as soon as you touch the screen.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏导航栏仅适用于非交互式应用。一旦你触摸屏幕，导航栏就会再次出现。
- en: All in all, we have to be happy with just dimming the Navigation bar and getting
    rid of the Status bar.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们只能对仅降低导航栏亮度并去除状态栏感到满意。
- en: '![Before Android 4.4 – almost fullscreen](img/B04757_01_13.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![Android 4.4之前 – 几乎全屏](img/B04757_01_13.jpg)'
- en: The low profile mode dims the Navigation bar so it is less obtrusive
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 低轮廓模式会降低导航栏的亮度，使其不那么显眼。
- en: 'This is the code we need to add to the `MainActivity` to remove the Status
    bar and put the device in a low profile mode:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要添加到`MainActivity`中以去除状态栏并将设备置于低轮廓模式的代码：
- en: '[PRE36]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are overriding the `onWindowFocusChanged` method in the main `Activity`.
    This is the recommended place to handle the flags, since it is called whenever
    the window focus changes. When the app regains focus, we don't know in which status
    the bars are. So, it is a good practice to ensure that things are the way we want
    them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主`Activity`中重写了`onWindowFocusChanged`方法。这是处理标志的推荐位置，因为每当窗口焦点改变时都会调用它。当应用恢复焦点时，我们不知道状态栏处于何种状态。因此，确保一切如我们所愿是一个好的做法。
- en: There are two more flags we haven't mentioned yet. They were introduced in API
    level 16 and are designed to take care of how the layout reacts to the appearance
    and disappearance of elements.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个我们尚未提到的标志。它们是在API级别16中引入的，旨在处理布局对元素出现和消失的反应。
- en: The `SYSTEM_UI_FLAG_LAYOUT_STABLE` flag means that the layout will be consistent,
    independent of the elements being shown or hidden.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSTEM_UI_FLAG_LAYOUT_STABLE` 标志意味着布局将是连贯的，独立于显示或隐藏的元素。'
- en: The `SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN` flag tells the system that our stable
    layout will be the one in the fullscreen mode—without the navigation bar.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN` 标志告诉系统我们的稳定布局将是全屏模式下的布局——没有导航栏。'
- en: This means that if/when the status bar is shown, the layout will not change,
    which is good, otherwise it will look like it is a glitch. It also means that
    we need to be careful with margins, so nothing important gets covered by the Status
    bar.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果/当状态栏显示时，布局不会改变，这是好的，否则它看起来就像是一个错误。这也意味着我们需要注意边距，确保没有重要内容被状态栏覆盖。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Stable layout only exists from the Jelly Bean version onwards (API level 16
    +).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定布局仅从Jelly Bean版本开始存在（API级别16+）。
- en: For Ice Cream Sandwich, `SYSTEM_UI_FLAG_LAYOUT_STABLE` does not work. But there
    are very few devices with this version and the Status bar is shown on very few
    occasions, so it is acceptable.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ice Cream Sandwich，`SYSTEM_UI_FLAG_LAYOUT_STABLE` 不起作用。但拥有这个版本的设备非常少，状态栏也很少显示，所以这是可以接受的。
- en: The real fullscreen mode was introduced in KitKat.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的全屏模式是在KitKat中引入的。
- en: Android 4.4 and beyond – immersive mode
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 4.4及更高版本 – 沉浸模式
- en: 'On KiKat, a new mode was introduced: the **immersive mode**.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在KiKat中，引入了一种新的模式：**沉浸模式**。
- en: Immersive mode hides the Status and Navigation bars completely. It is designed,
    as the name indicates, for fully-immersive experiences, which means games mostly.
    Even when the Navigation bar appears again, it is semitransparent instead of black
    and overlaid on top of the game.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸模式会完全隐藏状态栏和导航栏。正如其名所示，它旨在提供完全沉浸式的体验，这意味着主要是游戏。即使导航栏再次出现，它也是半透明的，而不是黑色，并叠加在游戏之上。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sticky immersive mode has been designed almost specifically for games.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 粘性沉浸模式几乎是为游戏专门设计的。
- en: 'Immersive mode can be used in two ways: **normal** and **sticky**. Both of
    them are fullscreen and the user is shown a tip the first time the app is put
    in this mode with an explanation of how to get out of it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸模式可以使用两种方式：**正常**和**粘性**。它们都是全屏模式，并且当应用第一次进入此模式时，用户会看到一个提示，解释如何退出此模式：
- en: '![Android 4.4 and beyond – immersive mode](img/B04757_01_14.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![Android 4.4 及以上版本 – 沉浸模式](img/B04757_01_14.jpg)'
- en: The immersive nonsticky mode will keep the Status and Navigation bars visible
    once they are shown, while the immersive sticky mode will hide them after a couple
    of seconds have passed, returning to the real fullscreen. The recommended mode
    for games is to use sticky immersion.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸式非粘性模式会在状态栏和导航栏显示后保持可见，而沉浸式粘性模式会在几秒钟后隐藏它们，返回真实的全屏模式。对于游戏来说，推荐使用粘性沉浸模式。
- en: 'The code to put the app in the fullscreen sticky immersion mode is as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用置于全屏粘性沉浸模式的代码如下：
- en: '[PRE37]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, as in the previous one, we are requesting the use of a stable
    layout, and we are making it as if it is fullscreen. This time, we include a flag
    to make the stable layout the one with no Navigation bar (`SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION`).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，就像之前的情况一样，我们要求使用稳定的布局，并使其看起来像全屏。这次，我们包括一个标志，使稳定的布局成为没有导航栏的布局（`SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION`）。
- en: 'We also add the flags to hide the Status bar (fullscreen) and the Navigation
    bar (hide navigation). Finally, we ask for the immersive sticky mode. The result
    is a real fullscreen game:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了隐藏状态栏（全屏）和导航栏（隐藏导航）的标志。最后，我们请求沉浸式粘性模式。结果是真正的全屏游戏：
- en: '![Android 4.4 and beyond – immersive mode](img/B04757_01_15.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![Android 4.4 及以上版本 – 沉浸模式](img/B04757_01_15.jpg)'
- en: Immersive mode gives us all the screen space on the device
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸模式为我们提供了设备上的所有屏幕空间
- en: 'With this configuration, even when the user does a gesture to show the Status
    and Navigation bars, they are shown in a semitransparent way overlaid on top of
    our UI:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，即使用户做出手势显示状态栏和导航栏，它们也会以半透明的方式叠加在我们的UI之上：
- en: '![Android 4.4 and beyond – immersive mode](img/B04757_01_16.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Android 4.4 及以上版本 – 沉浸模式](img/B04757_01_16.jpg)'
- en: When the bars are shown while in sticky immersion mode, they are overlaid and
    semi transparent
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当在粘性沉浸模式下显示栏时，它们会叠加并半透明
- en: Unfortunately, the sticky mode requires us to add the `SYSTEM_UI_FLAG_HIDE_NAVIGATION`
    flag to put the Navigation bar in the sticky mode. This has a very bad side-effect
    in the previous versions of Android, making the Navigation bar appear and disappear
    continuously as soon as you touch the screen, since this flag without the immersive
    mode means something different.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，粘性模式需要我们添加`SYSTEM_UI_FLAG_HIDE_NAVIGATION`标志来将导航栏置于粘性模式。在Android的早期版本中，这有一个非常糟糕的副作用，即触摸屏幕后导航栏会连续出现和消失，因为此标志在没有沉浸模式的情况下意味着不同的东西。
- en: In addition to this, the `SYSTEM_UI_FLAG_LOW_PROFILE` flag does not have any
    effect on the versions in which the immersive mode is available. This makes sense,
    since it is considered a replacement and an improvement on it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`SYSTEM_UI_FLAG_LOW_PROFILE`标志在沉浸模式可用的版本中没有任何效果。这是有意义的，因为它被认为是沉浸模式的替代品和改进。
- en: Putting fullscreen together
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将全屏结合在一起
- en: 'Since we have two different modes for requesting fullscreen, one prior to KitKat
    (low profile) and one from KitKat (immersive mode), and the flags for hiding the
    Navigation bar do not play together nicely, we need to make a different configuration
    based on which version of Android the device is running on:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两种不同的全屏请求模式，KitKat之前（低配置）和KitKat之后（沉浸模式），以及隐藏导航栏的标志不兼容，我们需要根据设备运行的Android版本进行不同的配置：
- en: '[PRE38]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this code, we give the expected game experience to each one of the Android
    versions; a low profile with a dimmed Navigation bar on the versions older than
    KitKat and the full-immersive mode on the newer devices.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们为每个Android版本提供了预期的游戏体验；在KitKat之前的版本上，导航栏变暗以降低配置，而在较新的设备上则使用全沉浸模式。
- en: Good practices for game developers
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏开发者的良好实践
- en: In general, you should avoid premature optimization. This means, do not optimize
    your code unless you have a performance problem.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该避免过早优化。这意味着，除非你遇到性能问题，否则不要对你的代码进行优化。
- en: Nevertheless, in games, we have two methods (`onUpdate` and `onDraw`) for which
    the execution time is critical. So, we will be providing a few tips that should
    be enough to get performance under a reasonable threshold.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在游戏中，我们有两种方法（`onUpdate`和`onDraw`）的执行时间至关重要。因此，我们将提供一些应该足以使性能保持在合理阈值之下的技巧。
- en: For the rest of the cases, your code will be probably good. If you find a performance
    problem, you should measure it carefully to find where the bottleneck is and only
    then optimize it. Most of the time, the problem is not where we think it is. Premature
    optimization can lead to a less readable code without significant improvement.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他情况，你的代码可能没问题。如果你发现性能问题，你应该仔细测量以找到瓶颈所在，然后才进行优化。大多数情况下，问题并不在我们认为的地方。过早的优化可能导致代码可读性降低，而改进并不显著。
- en: Object pools
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池
- en: The creation and destruction of objects is an expensive operation that should
    be limited. This is one area where a real-time game is a lot more sensitive than
    an app.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的创建和销毁是一项昂贵的操作，应该限制其使用。在这方面，实时游戏比应用程序更为敏感。
- en: Every time you create an object, the garbage collector has a chance to be run.
    In the old versions of Android, it meant that everything stopped for 200ms. While
    it is no longer this bad, it may still be noticeable.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建对象时，垃圾收集器都有机会运行。在Android的旧版本中，这意味着一切都会停止200毫秒。虽然现在情况不再这么糟糕，但可能仍然会注意到。
- en: Note
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We should avoid object creation as much as we can.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能避免对象创建。
- en: We want to avoid any expensive operation to be performed inside the `onUpdate`
    method—which must run as fast as it can—so we are going to take the creation and
    destruction of objects out of it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免在必须尽可能快运行的`onUpdate`方法中执行任何昂贵的操作，因此我们将对象创建和销毁的操作从其中移除。
- en: The solution for this is a well-known software pattern called **object pool**.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是众所周知的软件模式，称为**对象池**。
- en: Before we start the game, we will precreate the objects we are going to need
    and put them in a pool. The pool can be something as simple as a stack or list.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始游戏之前，我们将预先创建我们将需要的对象并将它们放入池中。池可以是像栈或列表这样简单的东西。
- en: Instead of creating an object, we will pick one from the pool and initialize
    it. If the pool is empty, it means that we underestimated the number of objects.
    So as a lesser evil, a new instance of the object must be created.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个对象，我们将从池中挑选一个并初始化它。如果池为空，这意味着我们低估了对象的数量。所以作为一个较小的恶，必须创建对象的新实例。
- en: Instead of destroying an object, we will put it back into the pool.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是销毁一个对象，我们将将其放回池中。
- en: The fact that we have to return objects to the pool forces us to figure out
    when an object is no longer needed instead of just relying on the garbage collector
    to do that for us. While it requires a bit of effort, this mental exercise will
    improve the game performance and structure. If you have ever worked with C++,
    this should be easy-peasy for you.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将对象返回到池中的事实迫使我们思考何时一个对象不再需要，而不是仅仅依赖垃圾收集器为我们完成这项工作。虽然这需要一点努力，但这种思维练习将提高游戏性能和结构。如果你曾经使用过C++，这对你来说应该很容易。
- en: We will use object pools for all the game objects in the code; this means enemies
    and bullets basically.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中使用对象池来处理所有游戏对象；这意味着敌人和子弹基本上。
- en: Avoiding enhanced loop syntax in lists
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在列表中使用增强型循环语法
- en: Related to the object creation, we should avoid the use of an enhanced loop
    syntax in the lists. While the for-each syntax is easier to read, it creates an
    iterator on-the-fly, which makes the execution slower and gives the garbage collector
    a chance to be run.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象创建相关，我们应该避免在列表中使用增强型循环语法。虽然for-each语法更容易阅读，但它会在运行时创建一个迭代器，这会使执行变慢，并给垃圾收集器运行的机会。
- en: 'In the case of the `onUpdate` method of `GameEngine`, we could have written
    it using the for-each syntax like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameEngine`的`onUpdate`方法的情况下，我们可以使用类似这样的for-each语法来编写它：
- en: '[PRE39]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But this is significantly slower than using the standard for loop syntax. This
    is why it looks like this instead:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但这比使用标准的for循环语法要慢得多。这就是为什么它看起来是这样的：
- en: '[PRE40]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the particular case of arrays, the enhanced syntax is as fast as the traditional
    one on the devices with the **JIT** (**just-in-time**) compiler—which should be
    the case for all devices nowadays—so there is no drawback in always using the
    default loop syntax instead of the enhanced one.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组的特定情况下，增强的语法在具有**JIT**（即时）编译器的设备上与传统语法一样快——现在所有设备都应该如此——因此，始终使用默认循环语法而不是增强语法没有缺点。
- en: It is also important to use a variable for the size instead of requesting it
    for every iteration, which leads us to the next tip.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是，使用变量来存储大小，而不是在每次迭代时请求它，这引出了下一个技巧。
- en: Precreating objects
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预先创建对象
- en: Related to the inefficiency of creating objects inside the `onUpdate` loop,
    we should always precreate the objects we are going to use.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 与在`onUpdate`循环中创建对象的低效性相关，我们应该始终预先创建我们将要使用的对象。
- en: A good example of this practice is the `Runnable` objects that are created inside
    the `GameObject` to run `onRemovedFromGameUiThread` and `onAddedToGameUiThread`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的一个好例子是创建在`GameObject`内部的`Runnable`对象，以运行`onRemovedFromGameUiThread`和`onAddedToGameUiThread`。
- en: We could create them on-demand inside the game engine as a part of `addGameObject`
    and `removeGameObject`, but it will be much less efficient.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏引擎中按需创建它们，作为`addGameObject`和`removeGameObject`的一部分，但这将效率低得多。
- en: Accessing variables directly
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接访问变量
- en: As often as we can, we will use a direct variable access instead of using getters
    and setters. This is a good practice in general, since accessors are expensive
    and the compiler does not inline them.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在尽可能多的场合，我们将使用直接变量访问而不是使用getter和setter。这通常是一个好习惯，因为访问器很昂贵，编译器不会内联它们。
- en: In the case of games, it makes sense to extend this practice to variables of
    other classes. As we mentioned several times before, the execution time of `onUpdate`
    and `onDraw` is critical; a difference of just milliseconds counts. This is why,
    when variables from the game objects are accessed by other game objects, we make
    them public and work with them directly.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的情况下，将这种做法扩展到其他类的变量是有意义的。正如我们之前多次提到的，`onUpdate`和`onDraw`的执行时间至关重要；仅仅毫秒级的差异就很重要。这就是为什么当游戏对象中的变量被其他游戏对象访问时，我们会将它们设置为公共的，并直接与它们一起工作。
- en: This is a bit counter-intuitive for Java developers, since we are used to encapsulating
    everything through getters and setters. In this case, efficiency is more important
    than encapsulation.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于Java开发者来说可能有点反直觉，因为我们习惯于通过getter和setter来封装一切。在这种情况下，效率比封装更重要。
- en: Being careful with floating points
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心处理浮点数
- en: In the case of doing calculations, integer operations are about twice as fast
    as float operations.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行计算的情况下，整数操作的速度大约是浮点操作的两倍。
- en: When integers are not enough, there is no real difference in speed between float
    and double. The only difference is in space, where doubles are twice as large.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当整数不够用时，浮点数和双精度数之间的速度没有真正的差异。唯一的区别在于空间，双精度数是两倍大。
- en: Also, even for integers, some processors have hardware multiply, but lack hardware
    divide. In such cases, integer division and modulus operations are performed in
    the software. All in all, this is a case where premature optimization can harm
    you.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使对于整数，一些处理器有硬件乘法，但没有硬件除法。在这种情况下，整数除法和取模操作是在软件中执行的。总的来说，这是一个过早优化可能对你有害的例子。
- en: Performance myths – avoid interfaces
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能神话——避免使用接口
- en: On the older versions of Android, before the JIT compiler was introduced, accessing
    methods via an interface instead of the exact type was slightly more efficient.
    In these versions, it made sense to declare a variable of `ArrayList` instead
    of the generic List interface to access the class directly.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入JIT编译器之前的Android旧版本中，通过接口访问方法而不是精确类型稍微高效一些。在这些版本中，声明`ArrayList`变量而不是泛型List接口来直接访问类是有意义的。
- en: 'In the modern versions of Android, however, there is no difference between
    accessing a variable via an interface and doing it directly. So, for the sake
    of generality, we will be using the generic interface instead of the class, as
    seen inside the `GameEngine`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现代版本的Android中，通过接口访问变量和直接访问之间没有区别。因此，为了通用性，我们将使用通用接口而不是类，就像在`GameEngine`中看到的那样：
- en: '[PRE41]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After a quick introduction to the question of which tools are best to make which
    types of games, we have described the pros and cons of using the bare Android
    SDK for making games.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍了哪种工具最适合制作哪种类型的游戏之后，我们描述了使用裸Android SDK制作游戏的优缺点。
- en: We have set up a project and defined the main activity and its orientation.
    We have created a basic game engine, included it in the project, and checked whether
    it works as expected.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个项目，并定义了主要活动和其方向。我们创建了一个基本的游戏引擎，将其包含在项目中，并检查它是否按预期工作。
- en: Later, we have extended the project with a second fragment and a pause dialog,
    managed the lifecycle of the game properly, and defined a way to get a proper
    fullscreen for different Android versions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们通过添加第二个片段和暂停对话框扩展了项目，正确管理了游戏的生命周期，并为不同的Android版本定义了全屏的方式。
- en: Finally, we have covered a few tips on optimizing the code inside the critical
    sections of the game.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了一些关于优化游戏关键部分代码的技巧。
- en: We are ready to start handling the user input.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好开始处理用户输入了。
- en: Chapter 2. Managing User Input
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 管理用户输入
- en: In this chapter, we will learn how to handle user input in a generic way and
    later expand it to be either a virtual joystick, sensors, or an external controller.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何以通用方式处理用户输入，并稍后将其扩展为虚拟摇杆、传感器或外部控制器。
- en: To get a visual feedback of the input, we will be placing a spaceship on the
    screen and moving it around. We will also make it fire some bullets. This will
    also help you understand the interaction between the game objects and the game
    engine.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得输入的视觉反馈，我们将在屏幕上放置一艘宇宙飞船并移动它。我们还将让它发射一些子弹。这也有助于您理解游戏对象与游戏引擎之间的交互。
- en: We will extend the generic `InputController` class to make the simplest keypad
    controller possible to understand how the class fits in the existing architecture
    and how the input is processed and read inside the game objects.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展通用的`InputController`类，以使最简单的键盘控制器尽可能易于理解，了解该类如何适应现有架构以及如何在游戏对象内部处理和读取输入。
- en: Once we get the basic keypad working, we will implement a virtual joystick,
    which is a much better way of handling user input.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使基本的键盘工作，我们将实现一个虚拟摇杆，这是一种处理用户输入的更好方式。
- en: Managing physical controllers is also important for the game we are writing,
    so we will see how to detect them and handle different options.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 管理物理控制器对我们正在编写的游戏也很重要，因此我们将了解如何检测它们并处理不同的选项。
- en: Finally, we will talk a bit about using sensors as controls. They are not a
    good fit for this type of game, but we will cover the basics and provide some
    links if you want to explore further.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要讨论使用传感器作为控制方式。它们不适合这种类型的游戏，但我们将介绍基础知识，并提供一些链接，如果您想进一步探索。
- en: The InputController base class
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`InputController`基类'
- en: It does not matter how we want to control the game; it can always be abstracted
    as a two-axis joystick and a button to fire. For other games this could be different,
    but you should always be able to extract basic actions from the user and create
    an `InputController` that handles them. The `InputController` we are building
    is useful for any game that uses directional control.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们想要如何控制游戏，它都可以抽象为一个二维摇杆和一个射击按钮。对于其他游戏，这可能是不同的，但您应该始终能够从用户那里提取基本动作并创建一个处理它们的`InputController`。我们正在构建的`InputController`对任何使用方向控制的游戏都很有用。
- en: Note
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Input controllers are quite specific to each type of game.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 输入控制器对每种类型的游戏都很具体。
- en: We are going to consider a normalized horizontal and vertical axis as an input
    (going from -1 to 1). In the case of a controller that does not have a range,
    we will just set it to the maximum. This will allow us to handle user input with
    precision when the type of input allows us to, as is the case with virtual and
    real joysticks as well as with sensors.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个归一化的水平和垂直轴作为输入（从-1到1）。对于没有范围的控制器，我们将将其设置为最大值。这将允许我们在允许输入类型的情况下，以精确的方式处理用户输入，正如虚拟和真实摇杆以及传感器的情况一样。
- en: '![The InputController base class](img/B04757_02_01.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![`InputController`基类](img/B04757_02_01.jpg)'
- en: The coordinate system of a phone screen
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 手机屏幕的坐标系
- en: Just as a reminder, the coordinates on a computer screen have [0,0] in the top-left
    corner and go positive towards to the right and down. The bottom-right corner
    has coordinates **[width, height]**. This is different from the standard coordinate
    system we are used to, but it is very important that you remember it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 就像提醒一样，计算机屏幕上的坐标在左上角为[0,0]，向右和向下为正值。右下角的坐标为**[width, height]**。这与我们习惯的标准坐标系不同，但您记住这一点非常重要。
- en: This is why moving left is -1 and moving to the top is -1 as well.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么向左移动是-1，向上移动也是-1的原因。
- en: 'The base class for all the input controllers in our game is going to be as
    follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中所有输入控制器的基类将如下所示：
- en: '[PRE42]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that this is a class with public variables. It is done this way to avoid
    reading the values via a method. We mentioned that in the previous chapter as
    a performance improvement.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个具有公共变量的类。这样做是为了避免通过方法读取值。我们已经在上一章中提到过，这是一种性能提升的方法。
- en: Each implementation of this class will be responsible for having these variables
    populated with the updated values. The game objects can read them during `onUpdate`.
    By doing this, we separate the action of using the values from the game objects
    from the reading of the user input.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的每个实现都将负责使用更新后的值填充这些变量。游戏对象可以在 `onUpdate` 期间读取它们。通过这种方式，我们将游戏对象使用值的动作与读取用户输入的动作分开。
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`InputController` isolates the reading of the input from its usage via the
    game objects.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputController` 将输入的读取与其通过游戏对象的使用隔离开。'
- en: '`InputController` is a part of the `GameEngine`. We just add a variable of
    this type to the engine and create a method to set it:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputController` 是 `GameEngine` 的一部分。我们只是向引擎添加了这个类型的变量并创建了一个设置它的方法：'
- en: '[PRE43]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The methods `onStart`, `onStop`, `onPause`, and `onResume` are called from the
    `GameEngine`, when the game is started, stopped, paused, or resumed. Some input
    controllers will need to do special actions in such situations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStart`、`onStop`、`onPause` 和 `onResume` 方法是在游戏启动、停止、暂停或恢复时由 `GameEngine`
    调用的。在这种情况下，一些输入控制器可能需要执行特殊操作。'
- en: 'Finally, we add the input controller to the `GameEngine` during the initialization
    of the engine inside the `GameFragment`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `GameFragment` 中初始化引擎时将输入控制器添加到 `GameEngine` 中：
- en: '[PRE44]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For now, we are adding an input controller that does nothing. We are also adding
    a `Player` game object, which we are going to work on before going into the different
    input controllers in more detail.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们添加了一个不执行任何操作的输入控制器。我们还添加了一个 `Player` 游戏对象，在详细研究不同的输入控制器之前，我们将先处理这个游戏对象。
- en: Note that we are no longer using the `ScoreGameObject` from the previous example
    and it should not be added to the game engine.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再使用之前示例中的 `ScoreGameObject`，并且不应将其添加到游戏引擎中。
- en: The Player object
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家对象
- en: The first version of the `Player` game object we are going to build will just
    initialize its coordinates in the middle of the screen. Then, it will update them
    based on the information in the input controller and, finally, it will display
    the value as [x, y] in the `TextView` we have on the layout.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的 `Player` 游戏对象的第一版将只是初始化其在屏幕中间的坐标。然后，它将根据输入控制器中的信息更新它们，最后，它将在布局上的 `TextView`
    中以 [x, y] 的形式显示值。
- en: After this, we will make it display a spaceship located at the coordinates.
    But for now, we will focus on how `onUpdate` is implemented.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将使其显示位于坐标处的宇宙飞船。但到目前为止，我们将专注于 `onUpdate` 的实现。
- en: 'The code for `onUpdate` and `onDraw` of the first version of the `Player` class
    is as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 类第一版 `onUpdate` 和 `onDraw` 的代码如下：'
- en: '[PRE45]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, in each run of `onUpdate`, we will increase the `x` and `y` position using
    the corresponding factor (which we read from the input controller), a speed factor,
    and the elapsed milliseconds. This is nothing more than the classic formula *distance
    = speed * time*.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在每次 `onUpdate` 运行中，我们将使用相应的因子（我们从输入控制器中读取）、速度因子和已过毫秒数来增加 `x` 和 `y` 位置。这不过是经典的公式
    *距离 = 速度 * 时间*。
- en: The rest of the code ensures that the *x* and *y* positions stay inside the
    boundaries of the screen.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分确保 *x* 和 *y* 位置保持在屏幕边界内。
- en: The `onDraw` method is equivalent to the one of `ScoreGameObject`, but it just
    sets text in `TextView`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw` 方法与 `ScoreGameObject` 的方法等效，但它只是在 `TextView` 中设置文本。'
- en: 'Now there are a few values in this code that we have not initialized. They
    are as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这段代码中有几个值我们没有初始化。它们如下所示：
- en: '`mSpeedFactor`: The speed converted into pixels per millisecond.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSpeedFactor`：将速度转换为每毫秒像素。'
- en: '`mMaxX`: The maximum value for `x`. It will be the width of the view minus
    the paddings.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mMaxX`：`x` 的最大值。它将是视图的宽度减去填充。'
- en: '`mMaxY`: The maximum value for `y`. It is the height of the view minus the
    padding.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mMaxY`：`y` 的最大值。它是视图的高度减去填充。'
- en: '`mTextView`: The view in which we set the current coordinates.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTextView`：我们设置当前坐标的视图。'
- en: 'All these elements are initialized on the constructor of the `Player` object
    that receives the parent view as a parameter:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些元素都在接收父视图作为参数的 `Player` 对象的构造函数中初始化：
- en: '[PRE46]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We calculate the pixel factor of our screen, taking a height of 400 units as
    a reference. This is an arbitrary number and you can use whatever makes sense
    to you. It will help if you think of working with a 400 px tall screen and then
    let the code convert it to the real amount of pixels.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算屏幕的像素因子，以400个单位的高度为参考。这是一个任意数字，你可以使用对你有意义的任何数字。如果你想象在一个400像素高的屏幕上工作，然后让代码将其转换为实际的像素数，这将有所帮助。
- en: This is a concept that is similar to dips, but also different. While dips are
    meant to have the same physical size among all devices, the units make our game
    scale. So, all the items of the game will take the same amount of screen space
    regardless of the resolution or size of the device.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与dips类似但不同的概念。虽然dips旨在在所有设备上具有相同的物理尺寸，但单位使我们的游戏可缩放。因此，无论分辨率或设备大小如何，游戏中的所有项目都将占据相同数量的屏幕空间。
- en: Note
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We will define the game space in "units" so all the devices have the same screen
    height.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以“单位”定义游戏空间，这样所有设备都有相同的屏幕高度。
- en: We want our ship to move at a speed of 100 units per second, so moving across
    the screen from its bottom to the top takes 4 seconds. Since we need the speed
    in pixels per millisecond, we need to multiply the desired speed with the pixel
    factor (pixels/unit) and divide it by 1,000 (milliseconds/second).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的船以每秒100个单位的速度移动，所以从底部到顶部穿过屏幕需要4秒。由于我们需要以像素每毫秒的速度，我们需要将期望的速度乘以像素因子（像素/单位）并除以1,000（毫秒/秒）。
- en: The next step is to read the width and height of the parent view and use them
    as the maximum width and height after subtracting the padding.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是读取父视图的宽度和高度，并在减去填充后使用它们作为最大宽度和高度。
- en: Finally, we get a hook into the `TextView` that we are going to use to display
    the coordinates.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们获取到我们将用于显示坐标的`TextView`的钩子。
- en: Once we have finished the initialization, we still have the `startGame` method.
    In this one, we will position our player in the middle of the screen.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成初始化，我们仍然有`startGame`方法。在这个方法中，我们将玩家定位在屏幕中间。
- en: '[PRE47]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you try and run the example now, you will see that the position stays at
    [0,0], indicating that something is going wrong.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试运行示例，你会看到位置保持在[0,0]，这表明出了问题。
- en: The problem is that we are reading the width and height of a view straight after
    it is created (inside the `onViewCreated` method of the `GameFragment`). At this
    moment, the view has not yet been measured.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们在视图创建后立即（在`GameFragment`的`onViewCreated`方法中）读取其宽度和高度。在这个时候，视图尚未被测量。
- en: Note
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: You cannot obtain the width and/or height of a view during the constructor,
    as it has not been measured yet.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在构造函数期间获取视图的宽度和/或高度，因为此时它尚未被测量。
- en: 'The solution for this is to delay the initialization of the `GameEngine` until
    the view has been measured. The best way to do this is to use `ViewTreeObserver`.
    Let''s go to the `onViewCreated` of the `GameFragment` and update it:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是在视图被测量后延迟初始化`GameEngine`。最好的方法是使用`ViewTreeObserver`。让我们转到`GameFragment`的`onViewCreated`并更新它：
- en: '[PRE48]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We get the `ViewTreeObserver` of the view that has just been created for the
    layout and add a new `OnGlobalLayoutListener` to it. We create the listener as
    an anonymous inner class.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取用于布局的刚刚创建的视图的`ViewTreeObserver`，并向其添加一个新的`OnGlobalLayoutListener`。我们将监听器创建为一个匿名内部类。
- en: This listener will be called every time a global layout is performed. To avoid
    being called multiple times and, therefore, initializing multiple engines, we
    need to remove the listener as soon as it is called.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行全局布局时，此监听器都会被调用。为了避免多次调用并因此初始化多个引擎，我们需要在监听器被调用后立即移除它。
- en: Unfortunately, there was a typo in the name of the method used to remove the
    listener in Android versions prior to Jelly Bean, so we have to use one method
    name for versions before Jelly Bean and another one for later versions.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Jelly Bean之前的Android版本中，用于移除监听器的函数名中有一个拼写错误，因此我们必须为Jelly Bean之前的版本使用一个方法名，而为后续版本使用另一个方法名。
- en: The rest of the code inside the method is the engine initialization, which was
    previously done directly inside `onViewCreated`. We just moved it inside `onGlobalLayout`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 方法内部剩余的代码是引擎初始化，这之前是在`onViewCreated`中直接完成的。我们只是将它移动到了`onGlobalLayout`中。
- en: Note that, while the views have not been measured yet, they have been created
    and they exist. So, there is no need to move the code that sets the `OnClickListener`
    for the pause button to the layout observer.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然这些观点尚未被测量，但它们已经被创建并且存在。因此，没有必要将设置暂停按钮`OnClickListener`的代码移动到布局观察者中。
- en: If we go on and run this version, we will see that the coordinates show the
    value of the center of the screen in pixels.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续运行这个版本，我们会看到坐标显示的是屏幕中心的像素值。
- en: '![The Player object](img/B04757_02_02.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![玩家对象](img/B04757_02_02.jpg)'
- en: Displaying a spaceship
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示宇宙飞船
- en: All this is not fun if we don't at least show a spaceship, so we can see that
    something is really happening.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们至少不展示一艘宇宙飞船，所有这些都不好玩，这样我们才能看到确实有事情发生。
- en: We are going to take the graphics for the game from the OpenGameArt website
    ([http://opengameart.org](http://opengameart.org)), which contains multiple free—as
    in freedom—graphics for games, most of them under a Creative Commons license,
    which means you have to credit the author.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从OpenGameArt网站（[http://opengameart.org](http://opengameart.org)）获取游戏图形，该网站包含多个免费（自由）的游戏图形，其中大部分受Creative
    Commons许可协议保护，这意味着你必须给作者致谢。
- en: Note
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The OpenGameArt.org website is a great resource for game graphics.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGameArt.org网站是游戏图形的一个极好资源。
- en: The spaceships we are going to show were created by Eikesteer and we will use
    them throughout the game.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要展示的宇宙飞船是由Eikesteer制作的，我们将在整个游戏中使用它们。
- en: '![Displaying a spaceship](img/B04757_02_03.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![显示宇宙飞船](img/B04757_02_03.jpg)'
- en: The spaceship set made by Eikesteer that we picked from Open Game Art
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Open Game Art中挑选的Eikesteer制作的宇宙飞船套装
- en: From the set, we will use the third from the right. We can extract it to a new
    image using a simple editor such as GIMP and place it under the `drawable-nodpi`
    directory.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 从套装中，我们将使用从右数第三个。我们可以使用像GIMP这样的简单编辑器将其提取为新的图像，并将其放置在`drawable-nodpi`目录下。
- en: Note that we are going to scale everything to be consistent with our 400 units
    of screen height, so it does not make sense to put the image in a drawable directory
    that has a density qualifier. This is why we are going to use `drawable-nodpi`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将把所有内容缩放到与我们的400个屏幕高度单位一致，因此将图像放入具有密度限定符的drawable目录中是没有意义的。这就是为什么我们将使用`drawable-nodpi`。
- en: The `drawable-nodpi` directory is meant to be independent from any density,
    while `drawable` is meant for images that do not have a qualifier. This means
    that the behavior is different when we try to read the intrinsic size of a drawable
    image. The intrinsic size will return the real size when placed under `nodpi`
    and will depend on the device when read from `drawable`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawable-nodpi`目录旨在与任何密度无关，而`drawable`则用于没有限定符的图像。这意味着当我们尝试读取可绘制图像的内建尺寸时，行为会有所不同。当放置在`nodpi`下时，内建尺寸将返回实际尺寸，而从`drawable`读取时将取决于设备。'
- en: Note
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will place our game object images in the `drawable-nodpi` folder.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把游戏对象图像放在`drawable-nodpi`文件夹中。
- en: 'The next step is to create an `ImageView` to display our spaceship. We are
    going to do this inside the constructor of the `Player` object:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个`ImageView`来显示我们的宇宙飞船。我们将在`Player`对象的构造函数中完成这项工作：
- en: '[PRE49]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first part of the constructor remains unchanged. We then add the code to
    create the `ImageView` and load the `Drawable` into it.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的前一部分保持不变。然后我们添加创建`ImageView`并将`Drawable`加载到其中的代码。
- en: First, we create an `ImageView` using the `Context` of the parent view and we
    store it as a class variable.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用父视图的`Context`创建一个`ImageView`，并将其存储为类变量。
- en: Then, we load the `Drawable` of the ship from the resources and assign it to
    the `shipDrawable` local variable.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从资源中加载飞船的`Drawable`并将其分配给局部变量`shipDrawable`。
- en: We proceed to create a `LayoutParams` object for the `ImageView` and set it.
    Since we already have the drawable, we can specify the exact dimensions for it.
    For this, we read the intrinsic width and height of the `shipDrawable` and multiply
    it by the pixel factor.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续为`ImageView`创建一个`LayoutParams`对象并设置它。由于我们已经有了一个drawable，我们可以指定它的确切尺寸。为此，我们读取`shipDrawable`的内建宽度和高度，并将其乘以像素因子。
- en: This means that the `ImageView` of the spaceship will be scaled to the equivalent
    of a 400-unit screen in pixels. Another way to say this is that the spaceship
    is the exact same size as it would be if displayed on a 400-pixel-tall screen.
    The drawable is then set to the `ImageView`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着宇宙飞船的`ImageView`将被缩放到相当于400像素高的屏幕。另一种说法是，宇宙飞船的大小与在400像素高的屏幕上显示时的大小完全相同。然后，将drawable设置为`ImageView`。
- en: We also have to update the maximum value of *x* and *y* by subtracting the size
    of the ship. With this, it gets placed in the center and it does not go outside
    the borders.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须通过减去飞船的大小来更新*x*和*y*的最大值。这样，它就被放置在中心，不会超出边界。
- en: Finally, the `ImageView` is added to the parent view, which is expected to be
    a `FrameLayout`. This new requirement comes from the need to be able to position
    the image anywhere.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`ImageView`添加到父视图中，这预期是一个`FrameLayout`。这个新要求来自于能够将图像放置在任何位置的需求。
- en: This is something we need to update or we will get a `ClassCastException`. We
    are updating the `fragment_game.xml` layout to have a top layout of the `FrameLayout`
    type.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要更新或我们将得到`ClassCastException`的情况。我们正在更新`fragment_game.xml`布局，使其顶部布局为`FrameLayout`类型。
- en: 'Now that we are touching the layout, we will also align the pause button to
    the top right, which is where the pause button for most games is:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在接触布局，我们还将暂停按钮对齐到右上角，这是大多数游戏暂停按钮的位置：
- en: '[PRE50]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, we need to update the `onDraw` method to make it display the spaceship
    in the right position. For this, we just translate the `ImageView` to the expected
    position on the screen using `translateX` and `translateY`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新`onDraw`方法，使其能够显示太空船在正确的位置。为此，我们只需使用`translateX`和`translateY`将`ImageView`平移到屏幕上的预期位置。
- en: 'This is far from optimal, but we will work on the drawing in the next chapter.
    For now, it serves the purpose of displaying the image at the right position:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这远非最佳，但我们在下一章中会处理绘图。现在，它足以在正确的位置显示图像：
- en: '[PRE51]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we launch our game, we can see the spaceship in the middle of the screen:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动游戏，我们可以在屏幕中间看到太空船：
- en: '![Displaying a spaceship](img/B04757_02_04.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![显示太空船](img/B04757_02_04.jpg)'
- en: Now that we have a spaceship, it is time to add some bullets to the mix.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了太空船，是时候添加一些子弹了。
- en: Firing bullets
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发射子弹
- en: The spaceship will fire bullets that will move upward until they are outside
    the screen.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 太空船将发射子弹，这些子弹将向上移动，直到它们超出屏幕。
- en: 'As we mentioned in the `Good practices for game developers` section of the
    previous chapter, we will use an object pool for the bullets that we will create
    inside the `Player` class:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章的“游戏开发者良好实践”部分中提到的，我们将使用对象池来管理我们在`Player`类内部创建的子弹：
- en: '[PRE52]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It initializes the number of bullets we want to have on the screen at a certain
    point. If you ask for a bullet when the pool has items it will just remove one
    and return it, but if the list is empty, it will return null. You can make this
    number a limitation to impact the gameplay or you can do the math and make the
    pool large enough.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 它初始化我们在屏幕上想要显示的子弹数量。如果你在池中有项目时请求子弹，它将移除一个并返回，但如果列表为空，它将返回null。你可以将这个数字作为一个限制来影响游戏玩法，或者你可以进行数学计算，使池足够大。
- en: In our case, we cannot fire more than 6 bullets, given the speed of the bullets
    and the time between shots.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于子弹的速度和射击之间的时间，我们无法发射超过6发子弹。
- en: Back to the pool, to release a bullet we will simply put it back into the list.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 回到池，要释放子弹，我们只需将其放回列表中。
- en: 'Now, during the `onUpdate` of the player, we check if we should fire a bullet:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在玩家的`onUpdate`中，我们检查是否应该发射子弹：
- en: '[PRE53]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We check whether the input controller has the fire button pressed and whether
    the cool down time has passed. If we want and can fire a bullet we take one from
    the pool.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查输入控制器是否按下了射击按钮，以及冷却时间是否已过。如果我们想并且可以射击，我们就从池中取一个子弹。
- en: If there is no bullet available (the object b is null), we do nothing else and
    return.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的子弹（对象b为null），我们不做其他任何事情并返回。
- en: Once we get a `Bullet` from the pool, we initialize it using the current position
    and place it in the middle of the spaceship. Then, we add it to the engine. To
    conclude, we reset the time since the last fire.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从池中获取一个`Bullet`，我们使用当前位置对其进行初始化，并将其放置在太空船的中间。然后，我们将其添加到引擎中。最后，我们重置上次射击的时间。
- en: If we cannot or do not want to fire, we just add the elapsed milliseconds to
    the time since the last bullet was fired.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能或不想射击，我们只需将经过的毫秒数添加到上次射击的时间。
- en: '![Firing bullets](img/B04757_02_05.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![发射子弹](img/B04757_02_05.jpg)'
- en: In the preceding image, we can see the relative position of the bullet with
    the spaceship and why passing the *x* coordinate as the center of the spaceship
    gives the right information to the bullet. But we still need to add some offsets
    to it.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到子弹与太空船的相对位置以及为什么将*x*坐标作为太空船的中心可以给子弹提供正确的信息。但我们仍然需要添加一些偏移量。
- en: From this moment on, all the logic regarding the movement of the bullet is done
    inside the `Bullet` object.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 从此刻起，所有关于子弹移动的逻辑都在`Bullet`对象内部完成。
- en: The Bullet game object
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子弹游戏对象
- en: 'The `Bullet` extends `GameObject` as well. And, as the spaceship does, it also
    creates an `ImageView` and loads the drawable into it as part of the constructor:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`对象也扩展了`GameObject`。同样，就像太空船一样，它也在构造函数中创建了一个`ImageView`并将可绘制的内容加载到其中：'
- en: '[PRE54]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The only difference between this constructor and the one for the `Player` object
    is that we set the visibility of `ImageView` to `GONE`, since the bullets are
    not supposed to be displayed unless they are being fired. The `Bullet` also has
    an `mPositionX` and `mPositionY` used for drawing.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Player`对象的构造函数相比，唯一的区别是我们将`ImageView`的可见性设置为`GONE`，因为除非正在发射，否则子弹不应该显示。子弹也有一个用于绘制的`mPositionX`和`mPositionY`。
- en: These similarities come from the fact that both the game objects are what we
    call **sprites**. Sprite is a `GameObject` that has an image associated with it
    and gets rendered on the screen.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相似之处源于这两个游戏对象都是我们所说的**精灵**。精灵是与它关联的图像的`GameObject`，并在屏幕上渲染。
- en: Note
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sprite is a game object (generally a 2D image) that is displayed in a game and
    manipulated as a single entity.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是游戏中显示并作为一个单一实体操作的（通常是一个2D图像）游戏对象。
- en: In the next chapter, we will extract the common concepts of sprite and put them
    in a base class.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提取精灵的公共概念并将它们放入一个基类中。
- en: In the constructor, we also set the speed of the bullet to 300 units per second.
    This is 3 times faster than the spaceship. You can play with the values of speed
    and time between bullets, but remember to test that they do not overlap during
    continuous fire while the spaceship moves upward.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们还设置了子弹的速度为每秒300个单位。这是太空船速度的3倍。你可以调整速度和子弹之间的时间间隔，但请记住测试在太空船向上移动时连续发射时它们不会重叠。
- en: If you modify the bullet speed, you may also need to check the size of the pool.
    The worst case is to continuously fire with the spaceship placed at the bottom
    of the screen.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了子弹速度，你可能还需要检查池的大小。最坏的情况是，当太空船位于屏幕底部时，持续发射。
- en: 'The next interesting point is initialization. This is done using the `init`
    method that receives the position of the spaceship:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣点是初始化。这是通过接收太空船位置的`init`方法来完成的：
- en: '[PRE55]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is worth mentioning that we want to position the bullet a bit ahead of the
    spaceship and properly centered. Since the member variables `mPositionX` and `mPositionY`
    are pointing to the top-left corner of the image, we have to apply an offset to
    the initial parameters based on the size of the bullet.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们希望将子弹放置在太空船前方一点，并且正确居中。由于成员变量`mPositionX`和`mPositionY`指向图像的左上角，我们必须根据子弹的大小对初始参数应用偏移。
- en: We are positioning the bullet only half way outside the spaceship on the vertical
    axis (*mImageHeight/2*) to improve the feeling of it being shot from the spaceship.
    We are also displaying it centered on the horizontal axis, which is why we also
    subtract *mImageWidth/2*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在垂直轴上（*mImageHeight/2*）将子弹定位在太空船外部的一半，以增强它从太空船发射的感觉。我们还在水平轴上居中显示它，这就是为什么我们还要减去*mImageWidth/2*。
- en: The image in the previous section will also help you visualize this offset.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中的图像也将帮助你可视化这个偏移量。
- en: 'Because the `Bullets` are added and removed from the `GameEngine`, we need
    to change the visibility of the view when they are added and removed. This needs
    to be done on the `UIThread`. For this purpose, we use the callbacks we created
    in the previous chapter:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 因为子弹是在`GameEngine`中添加和移除的，所以当它们被添加和移除时，我们需要改变视图的可见性。这需要在`UIThread`上完成。为此，我们使用上一章中创建的回调函数：
- en: '[PRE56]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All changes to the view must be done on the `UIThread`, otherwise an exception
    will be thrown.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对视图的更改都必须在`UIThread`上完成，否则将抛出异常。
- en: 'Since these bullets are also sprites, the `onDraw` method is almost identical
    to the one of the player. We do it again by animating the view and translating
    it:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些子弹也是精灵，所以`onDraw`方法几乎与玩家的方法相同。我们再次通过动画视图和转换来实现这一点：
- en: '[PRE57]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'On the other hand, the `onUpdate` method is a bit different and it is interesting
    to look at it in detail:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`onUpdate`方法略有不同，详细研究它很有趣：
- en: '[PRE58]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Similar to what we did with the player, we use the *distance = speed * time*
    formula. But, in this case, there is no influence from the `InputController` at
    all. The bullet has a fixed vertical speed.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对玩家所做的一样，我们使用`距离 = 速度 * 时间`公式。但在这个情况下，`InputController`没有任何影响。子弹有一个固定的垂直速度。
- en: We also check whether the bullet is out of the screen. Since we draw the items
    in the top-left corner, we need it to be completely gone. This is why we compare
    with `mImageHeight`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查子弹是否飞出了屏幕。由于我们在屏幕的左上角绘制项目，我们需要确保它完全消失。这就是为什么我们与`mImageHeight`进行比较。
- en: If the bullet is out, we remove it from the `GameEngine` and we return it to
    the pool by calling `releaseBullet`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子弹飞出，我们就从`GameEngine`中移除它，并通过调用`releaseBullet`将其返回到池中。
- en: This game object removal is done inside the `onUpdate` loop of the `GameEngine`.
    If we modify the list at this moment, we will get an `ArrayIndexOutOfBoundsException`
    while executing `onUpdate` in the `GameEngine`. This is why the `removeGameObject`
    method puts the objects in a separate list to be removed after `onUpdate` is called.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏对象移除是在`GameEngine`的`onUpdate`循环中完成的。如果我们此时修改列表，在执行`GameEngine`中的`onUpdate`时将会得到`ArrayIndexOutOfBoundsException`异常。这就是为什么`removeGameObject`方法将对象放入一个单独的列表中，在调用`onUpdate`之后进行移除。
- en: Now, all this is useless unless we can move the spaceship and fire the bullets.
    Let's build the most basic `InputController`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除非我们可以移动宇宙飞船并射击子弹，否则所有这一切都是无用的。让我们构建最基本的`InputController`。
- en: The most basic virtual keypad
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最基本的虚拟键盘
- en: 'The simplest we can go is to build a simple keypad in the shape of a cross
    on the left-hand side of the screen and a fire button on its right-hand side.
    For this layout, we are going to create a new file under the `layout` folder and
    call it `view_keypad.xml`:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是在屏幕左侧构建一个十字形状的简单键盘，并在其右侧放置一个射击按钮。对于这个布局，我们将在`layout`文件夹下创建一个新文件，命名为`view_keypad.xml`：
- en: '[PRE59]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have a relative layout that covers the screen's full width. It has a `layout_gravity`
    set to `bottom`, so we are assured that it will be properly aligned.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相对布局，覆盖了屏幕的全宽。它有一个`layout_gravity`设置为`bottom`，所以我们确信它会被正确对齐。
- en: We have our four-button pad arranged in a `RelativeLayout`. The left button
    is aligned to the left of the layout and the up button is aligned to the top of
    the layout. Then, the top and bottom buttons are set to the right of the left
    button. The right one is set below and to the right of the up button. Finally,
    the left one is set below the up button and the down button is just below the
    left. Sounds a bit too complicated, but the image is much clearer.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将四个按钮的垫子排列在一个`RelativeLayout`中。左按钮与布局的左侧对齐，上按钮与布局的顶部对齐。然后，将上下按钮设置为左按钮的右侧。右按钮设置为上按钮的下方和右侧。最后，左按钮设置为上按钮的下方，下按钮正好位于左按钮下方。听起来有点复杂，但图片会更清晰。
- en: '![The most basic virtual keypad](img/B04757_02_06.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![最基本的虚拟键盘](img/B04757_02_06.jpg)'
- en: On the other side of the screen, aligned to the right of the parent and to the
    top of the left button, we have a fire button.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的另一侧，与父元素对齐，位于左按钮的上方，我们有一个射击按钮。
- en: You may have noticed that all the buttons are using a special dimension named
    `keypad_size`. This is a very important point, not only to make them all look
    the same, but for usability in general. We are setting it to 42 dp, which is the
    recommended minimum size for a touch target.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有按钮都使用一个名为`keypad_size`的特殊维度。这是一个非常重要的点，不仅是为了使它们看起来都一样，而且对于一般的使用性也很重要。我们将它设置为42
    dp，这是触摸目标的推荐最小尺寸。
- en: Note
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The smallest size a touchable item should have is 42 dp.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 可触摸项目的最小尺寸应为42 dp。
- en: Feel free to play with the size of the buttons and observe by yourself that
    a smaller size button is very hard to touch. In fact, for a game, we should always
    use large-sized touch targets, sometimes larger than the area that provides visual
    feedback. The bigger you can make the touch area for a control, the better it
    is. In this example, the touch area of the fire button could be as large as the
    right half of the screen.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 随意调整按钮的大小，并亲自观察，你会发现尺寸较小的按钮很难触摸。实际上，对于游戏，我们应该始终使用大尺寸的触摸目标，有时甚至比提供视觉反馈的区域还要大。控制器的触摸区域越大，越好。在这个例子中，射击按钮的触摸区域可以大到屏幕的右半部分。
- en: We are going to include this layout inside the game fragment, so we can see
    how it overlays. Since we already updated the top layout to be a `FrameLayout`,
    we just need to use an `include` tag.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个游戏片段中包含这个布局，这样我们就可以看到它是如何叠加的。由于我们已经将顶部布局更新为`FrameLayout`，我们只需要使用一个`include`标签。
- en: '[PRE60]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we just go on and run it, we can see how it looks all together.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续运行它，我们可以看到整体的效果。
- en: '![The most basic virtual keypad](img/B04757_02_07a.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![最基本的虚拟键盘](img/B04757_02_07a.jpg)'
- en: 'Now let''s write the code for the `BasicInputController` to handle the buttons.
    Starting with the constructor, the code is as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写`BasicInputController`的代码来处理按钮。从构造函数开始，代码如下：
- en: '[PRE61]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We are setting the game controller as the touch listener for all the buttons:
    up, down, left, right, and fire. It is important to note that we have to use `OnTouchListener`
    and not `OnClickListener`.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将游戏控制器设置为所有按钮（上、下、左、右和射击）的触摸监听器：这是很重要的，我们必须使用`OnTouchListener`而不是`OnClickListener`。
- en: The `onClick` callback is only triggered when the button is pressed and then
    released. In our case, we need to know when the button is pressed and when it
    is released. We need to move the spaceship while the button is being pressed.
    This is why we need the more detailed callback that `OnTouchListener` provides.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick`回调仅在按钮被按下然后释放时触发。在我们的情况下，我们需要知道按钮何时被按下以及何时被释放。在按钮被按下的同时，我们需要移动太空船。这就是为什么我们需要`OnTouchListener`提供的更详细的回调。'
- en: 'The implementation of the method from `OnTouchListener` in the `BasicInputController`
    is as follows:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicInputController`中`OnTouchListener`方法的具体实现如下：'
- en: '[PRE62]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is important to note that we are calling `getActionMasked` instead of `getAction`.
    In the case of multiple touch pointers, `getAction` includes pointer information
    while that information is removed when requested as a masked action. This is why
    the recommended way to handle multitouch is to to use `getActionMasked` and `getActionPointer`.
    Otherwise, you need to use the `OR` operation to check for the action instead
    of the equal or it won't work when the pointers above the first one are being
    read.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们调用的是`getActionMasked`而不是`getAction`。在多个触摸指针的情况下，`getAction`包括指针信息，而当请求作为掩码动作时，该信息被移除。这就是为什么推荐处理多点触控的方式是使用`getActionMasked`和`getActionPointer`。否则，你需要使用`OR`操作来检查动作，而不是使用等于，否则在读取上面的指针时不会工作。
- en: Note
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `getActionMasked` and `getPointerIndex` is the recommended way to deal
    with multitouch.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getActionMasked`和`getPointerIndex`是处理多点触控的推荐方式。
- en: We have two cases. When the action is `MotionEvent.ACTION_DOWN`, it means that
    the user has pressed a button, so we check for the ID of the view that was touched
    and act accordingly.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种情况。当动作是`MotionEvent.ACTION_DOWN`时，这意味着用户已经按下了按钮，因此我们检查被触摸的视图的ID并相应地操作。
- en: If the view is up or down, we subtract or add 1 to the vertical factor. Similarly,
    we subtract or add 1 to the horizontal factor if the touched button was left or
    right.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果视图是向上或向下，我们向垂直因子加或减1。同样，如果触摸的按钮是左或右，我们向水平因子加或减1。
- en: The second part, where we handle the `MotionEvent.ACTION_UP` action, reverses
    the addition or subtraction to the corresponding factor.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分，处理`MotionEvent.ACTION_UP`动作，将加法或减法反转到相应的因子。
- en: We are adding and subtracting instead of setting the value to 1 or -1 for multitouch.
    For example, if you first tap on right and then on left, the spaceship should
    stop, since you are pressing on both buttons at the same time. Once you release
    one of them, the movement is restored.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是在进行加法和减法，而不是将值设置为1或-1，以处理多点触控。例如，如果你首先点击右键，然后点击左键，太空船应该停止，因为你同时按下了两个按钮。一旦你释放其中一个，运动就会恢复。
- en: For the fire button, we set `mIsFiring` to `true` when it is down and to `false`
    when it is up. Simple.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对于射击按钮，当它按下时，我们将`mIsFiring`设置为`true`，当它抬起时设置为`false`。很简单。
- en: Finally, we return `false`. This is important, because it tells the system that
    the event was not consumed by our listener and, therefore, the chain of listeners
    can continue. This chain of listeners includes the button's own click listener,
    which is responsible for changing the background image to one consistent with
    the button's state. If we return true, updating the background will not happen.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回`false`。这很重要，因为它告诉系统事件没有被我们的监听器消耗，因此监听器的链可以继续。这个监听器链包括按钮自己的点击监听器，它负责将背景图像更改为与按钮状态一致的一个。如果我们返回`true`，则不会更新背景。
- en: Note
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`OnTouch` implementation returns whether the event was consumed by this listener
    or not.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTouch`实现返回事件是否被此监听器消耗。'
- en: As simple as this—we can run the game now. We will see that the spaceship moves
    around the screen and also fires some bullets. At last, YASS starts to look like
    a game.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单——我们现在可以运行游戏了。我们会看到太空船在屏幕上移动，并且还发射了一些子弹。最后，YASS开始看起来像一款游戏。
- en: Limitations and problems
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性和问题
- en: There are several limitations and problems with such a simple keypad. Apart
    from the fact that the buttons are quite small and hard to handle, the rest of
    the issues come from when users move the touch pointer.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这样简单的键盘存在一些局限性和问题。除了按钮相当小且难以操作之外，其余问题都源于用户移动触摸指针时的情况。
- en: If the user moves outside the button, Android versions before API level 17 will
    trigger an event of the `MotionEvent.ACTION_DOWN` type, but from this API level
    onwards they will not. If you want to handle this situation properly, you need
    to check on every move or action and validate whether it gets out of the rectangle
    for the original view to do a manual cancel. But this is not the only problem
    with move. If you tap on one button and move towards the opposite one, a new tap
    on the other button will not be detected, since it is an `ACTION_MOVE` and not
    an `ACTION_DOWN`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户将指针移出按钮，Android版本低于API级别17将触发`MotionEvent.ACTION_DOWN`类型的事件，但从这个API级别开始则不会。如果您想正确处理这种情况，您需要在每次移动或操作时进行检查，并验证它是否移出了原始视图的矩形，以便进行手动取消。但这并不是移动的唯一问题。如果您在一个按钮上点击并移动到相反的按钮，新的点击将不会被检测到，因为它是一个`ACTION_MOVE`而不是`ACTION_DOWN`。
- en: The solution for this is to check the position of each pointer in each event,
    see whether it is inside the rectangle of a button, and act accordingly.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是检查每个事件中每个指针的位置，看它是否在按钮的矩形内，并相应地采取行动。
- en: There is also the problem of not being able to handle diagonal movements.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题是无法处理对角线移动。
- en: We could try and solve these problems for this keypad. But since it is not a
    very elegant input controller anyway, we will just move forward and make an `InputController`
    that is a proper virtual joystick instead.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试解决这个键盘的问题。但由于它本身并不是一个非常优雅的输入控制器，我们将继续前进，创建一个合适的虚拟摇杆`InputController`。
- en: Creating a virtual joystick
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建虚拟摇杆
- en: We are going to improve the user input and we are going to do it by creating
    a virtual joystick.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改进用户输入，我们将通过创建虚拟摇杆来实现这一点。
- en: A **virtual joystick** measures the distance from the touch position to its
    center and uses this information to set the values on the two axes. It behaves
    as a traditional analog joystick.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟摇杆**测量触摸位置到其中心的距离，并使用这些信息在两个轴上设置值。它表现得像传统的模拟摇杆。'
- en: Since it is virtual, we are not constrained to have it at a specific position
    on the screen, so we can place it anywhere the player touches it.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是虚拟的，我们不受限于将其放置在屏幕上的特定位置，因此我们可以将其放置在玩家触摸的任何地方。
- en: We cannot, however, take the entire screen for the virtual joystick. There needs
    to be a fire button too.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法将整个屏幕都用于虚拟摇杆。还需要一个射击按钮。
- en: We have experienced the frustration of small touch targets, so we are going
    to make the fire button as big as we can. This means that we are going to use
    half the screen for the virtual joystick and half the screen for the fire button.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经体验过小触摸目标带来的挫败感，所以我们将尽可能使射击按钮变大。这意味着我们将使用屏幕的一半空间用于虚拟摇杆，另一半空间用于射击按钮。
- en: 'The layout that we are going to use will have two views that fill the screen,
    each of them covering half of the width. We will name this layout `view_vjoystick.xml`:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的布局将有两个视图填满屏幕，每个视图覆盖一半的宽度。我们将把这个布局命名为`view_vjoystick.xml`：
- en: '[PRE63]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The interesting bit of this layout is the usage of Android:`layout_weight` to
    equally divide the screen into two halves. You can modify the weight value to
    make one view larger than the other if you want a larger space for the virtual
    joystick or the fire button.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局有趣的地方在于使用了Android的`layout_weight`来将屏幕等分为两部分。如果您想为虚拟摇杆或射击按钮留出更大的空间，可以修改权重值。
- en: We will create a class to handle this user `InputController`. We will call it
    `VirtualJoystickInputController` and it will, obviously, extend `InputController`.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类来处理这个用户的`InputController`。我们将称之为`VirtualJoystickInputController`，并且它显然将扩展`InputController`。
- en: 'To handle the events of this `InputController`, we are going to use two internal
    classes. One for each view we want to listen to the events to:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个`InputController`的事件，我们将使用两个内部类。每个我们想要监听事件的视图一个：
- en: '[PRE64]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `mMaxDistance` variable defines how far from the touch we consider the user
    to have reached the maximum. The value is, again, in screen units. You can imagine
    the maximum distance as the radius of the virtual gamepad. The smaller this distance
    is, the more sensitive the joystick is.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`mMaxDistance`变量定义了我们认为用户已经达到最大距离的触摸距离。这个值再次是以屏幕单位来衡量的。你可以想象最大距离是虚拟游戏手柄的半径。这个距离越小，摇杆就越敏感。'
- en: A small maximum distance will allow quick reactions, while a large one will
    allow better precision. Feel free to experiment with its size to make it work
    as you'd like.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的最大距离将允许快速反应，而较大的距离将允许更好的精度。请随意尝试调整其大小，使其按你的意愿工作。
- en: '![Creating a virtual joystick](img/B04757_02_07.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![创建虚拟摇杆](img/B04757_02_07.jpg)'
- en: 'The fire button is easier to handle than the virtual joystick. We use the same
    logic as in the previous example. Set `mIsFiring` to `true` when the event is
    a down action and set it to `false` when the event is an up action:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 火箭按钮比虚拟摇杆更容易操作。我们使用与上一个示例相同的逻辑。当事件是按下动作时，将`mIsFiring`设置为`true`，当事件是抬起动作时，将其设置为`false`：
- en: '[PRE65]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The listener for the virtual joystick is more interesting. We record the position
    of the touch when a down action is performed, we also reset the values when the
    touch goes up. But, as long as it moves, we update the values of `mHorizontalFactor`
    and `mVerticalFactor` based on the distance to the original touch:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟摇杆的监听器更有趣。我们在按下动作执行时记录触摸的位置，当触摸抬起时，我们也重置这些值。但是，只要它移动，我们就根据原始触摸的距离更新`mHorizontalFactor`和`mVerticalFactor`的值：
- en: '[PRE66]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Please note that we want to keep `mHorizontalFactor` and `mVerticalFactor` between
    -1 and 1; thus, whenever the distance is larger than `mMaxDistance`, we do not
    consider it.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们希望将`mHorizontalFactor`和`mVerticalFactor`保持在-1和1之间；因此，当距离大于`mMaxDistance`时，我们不予以考虑。
- en: 'Finally, time to connect this new controller to the `GameEngine`. It is quite
    simple. We just have to update the layout for `fragment_game.xml`, including `view_vjoystick.xml`
    instead of `view_keypad.xml`, and then update the initialization of the `GameEngine`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候将这个新的控制器连接到`GameEngine`了。这相当简单。我们只需更新`fragment_game.xml`的布局，包括将`view_vjoystick.xml`替换为`view_keypad.xml`，然后更新`GameEngine`的初始化：
- en: '[PRE67]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As a reminder, the initialization of the `GameEngine` is done inside `onViewCreated`
    of the `GameFragment`. We only need to create an instance of the proper `InputController`:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`GameEngine`的初始化是在`GameFragment`的`onViewCreated`中完成的。我们只需要创建适当的`InputController`实例：
- en: '[PRE68]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Time to run the game and try this controller.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行游戏并尝试这个控制器了。
- en: General considerations and improvements
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般考虑和改进
- en: This input method is a huge improvement over the basic keypad we did before.
    The touch area is as big as the screen and the player does not need to look at
    this area of the screen to tap on small buttons. It will work anywhere.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前做的基本键盘相比，这种输入方法是一个巨大的改进。触摸区域与屏幕大小相当，玩家不需要看这个屏幕区域来点击小按钮。它可以在任何地方工作。
- en: This system handles diagonal as well as horizontal and vertical movements and
    also anything in between.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统可以处理斜向以及水平和垂直移动，以及介于两者之间的任何移动。
- en: The player does not need to remove his/her finger from the screen to change
    the directions.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家不需要从屏幕上移除手指来改变方向。
- en: There is a lack of visual feedback, which can be solved by drawing the virtual
    gamepad as two circles when the player is using it. A big circle will show the
    range of the virtual joystick, while a smaller one will show the current touch
    pointer. On the other hand, you may not want to, since the lack of visual clutter
    makes the screen cleaner.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏视觉反馈，可以通过在玩家使用时将虚拟游戏手柄绘制为两个圆圈来解决。一个大的圆圈将显示虚拟摇杆的范围，而一个较小的圆圈将显示当前的触摸指针。另一方面，你可能不想这样做，因为视觉杂乱的缺乏使得屏幕更干净。
- en: Physical controllers
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理控制器
- en: 'Time to move into a type of controller that hardcore gamers love: physical
    ones.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试一种硬核玩家喜欢的控制器类型了：物理控制器。
- en: There are a few devices that have a controller included as a part of their hardware.
    Some notable examples are XPeria Play—one of the pioneer phones that had a sliding
    gamepad—and Nvidia Shield, the latest in this category.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些设备将控制器作为其硬件的一部分包含在内。一些值得注意的例子是XPeria Play——这是一款具有滑动游戏手柄的先驱手机——以及Nvidia Shield，这是这一类中的最新产品。
- en: 'XPeria Play was one of the first devices with an integrated gamepad:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: XPeria Play是第一个集成了游戏手柄的设备：
- en: '![Physical controllers](img/B04757_02_08.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
  zh: '![物理控制器](img/B04757_02_08.jpg)'
- en: 'Nvidia Shield is one of the most powerful Android devices with a gamepad:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Nvidia Shield是最强大的Android游戏设备之一，带有游戏手柄：
- en: '![Physical controllers](img/B04757_02_09.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![物理控制器](img/B04757_02_09.jpg)'
- en: On the other hand, there are many brands that build game controllers for smartphones
    and they have been fairly popular among traditional gamers. All of them are Bluetooth
    controllers that can be connected to your phone or tablet. Some of them are designed
    to make your phone fit into it like Gametel (another pioneer) and most of the
    MOGA models.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有许多品牌为智能手机制作游戏控制器，它们在传统玩家中相当受欢迎。所有这些控制器都是蓝牙控制器，可以连接到您的手机或平板电脑。其中一些设计得可以让您的手机适应它，例如Gametel（另一家先驱）和大多数MOGA型号。
- en: '![Physical controllers](img/B04757_02_10.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![物理控制器](img/B04757_02_10.jpg)'
- en: MOGA controller with an adjustable strip to hold your phone
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 配有可调节带子以固定手机的MOGA控制器
- en: There are also a few Android-powered devices that use controllers as the main
    input source. Here, we are talking about microconsoles such as the OUYA or other
    TV-like devices such as the Amazon FireTV or Android TV.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些使用控制器作为主要输入源的Android设备。这里，我们谈论的是像OUYA或其他类似电视的设备，如Amazon FireTV或Android TV。
- en: '![Physical controllers](img/B04757_02_11.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![物理控制器](img/B04757_02_11.jpg)'
- en: The OUYA was the first of the Android microconsoles
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: OUYA是第一个Android微型游戏机
- en: These devices work in a very similar way to HID devices, either in the form
    of keyboards or as directional controls based on an axis (analog joysticks). All
    we have to do to handle them is to set the correct listeners.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备的工作方式与HID设备非常相似，无论是以键盘的形式还是基于轴的方向控制（模拟摇杆）。我们处理它们所需要做的只是设置正确的监听器。
- en: 'Some controllers do have their own proprietary library. We won''t cover this,
    since they are very specific and they provide detailed documentation on how to
    integrate them. This is the case with the MOGA Pocket (more advanced MOGA controllers
    support two modes: proprietary and HID).'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 一些控制器确实有自己的专有库。我们不会涉及这一点，因为它们非常具体，并且提供了如何集成它们的详细文档。MOGA Pocket（更高级的MOGA控制器支持两种模式：专有和HID）就是这种情况。
- en: Note
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most controllers work as HID, which is standard.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数控制器都以HID的形式工作，这是标准的。
- en: We can set listeners for the controller at the `Activity` level or `View` level.
    In any case, we will need to extend the class. There is no way to add a listener
    for these methods, they must be overridden. Since we are already extending the
    `Activity` class, we'll do it this way.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Activity`级别或`View`级别为控制器设置监听器。在任何情况下，我们都需要扩展这个类。无法为这些方法添加监听器，它们必须被重写。由于我们已经在扩展`Activity`类，我们将这样做。
- en: Note
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We listen to `KeyEvent` and `MotionEvent` inside the Activity.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Activity`内部监听`KeyEvent`和`MotionEvent`。
- en: 'There are two types of events we need to listen for. They are as follows:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要监听两种类型的事件。如下所示：
- en: '`KeyEvent`: For all the button presses and, in some gamepads, also the directional
    cross'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyEvent`：对于所有按钮按下，在一些游戏手柄中，还包括方向十字键'
- en: '`MotionEvent`: Events related to the movement along an axis: joysticks'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionEvent`：与轴上的运动相关的事件：摇杆'
- en: We want to have the input controller separated from the `Activity`, so we will
    make a special listener that combines the two events we need and then make the
    `Activity` delegate on it.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将输入控制器与`Activity`分离，因此我们将创建一个特殊的监听器，它结合了我们需要的两个事件，然后在该监听器上创建`Activity`的代理。
- en: 'The interface we need is very simple, we will call it `GamepadControllerListener`:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的接口非常简单，我们将称之为`GamepadControllerListener`：
- en: '[PRE69]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inside the `Activity`, we create a method to set a listener of `GamepadControllerListener`
    type. Since we only require one listener at a time, the method is set instead
    of add. To remove the listener, we just need to set it to null:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Activity`内部，我们创建了一个设置`GamepadControllerListener`类型监听器的方法。由于我们一次只需要一个监听器，所以方法被设置为而不是添加。要移除监听器，我们只需将其设置为null：
- en: '[PRE70]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, we have to override `dispatchGenericMotionEvent` and `dispatchKeyEvent`
    inside our `Activity`:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在我们的`Activity`内部重写`dispatchGenericMotionEvent`和`dispatchKeyEvent`：
- en: '[PRE71]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that this method uses the convention of returning true if the event was
    consumed and false if it was not. In our case, we will return true only if the
    event was consumed by the listener. In other cases, we will return the result
    to delegate the event to the base class.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法使用的是返回`true`表示事件已被消耗，返回`false`表示事件未被消耗的约定。在我们的情况下，我们只有在事件被监听器消耗时才返回`true`。在其他情况下，我们将返回结果以委托事件到基类。
- en: It is very important to call the corresponding method in the super class, as
    there is a lot of processing done inside the `Activity` class that we do not want
    to discard accidentally.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在超类中调用相应的方法非常重要，因为在`Activity`类内部进行了大量的处理，我们不希望意外地丢弃这些处理。
- en: 'With these components in place, we can proceed to create our `GamepadInputController`,
    which will extend `InputController` and implement `GamepadControllerListener`:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组件就绪后，我们可以继续创建我们的`GamepadInputController`，它将扩展`InputController`并实现`GamepadControllerListener`：
- en: '[PRE72]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Hooking into the key and motion events of the `Activity` is something we want
    to limit as much as possible. This is why we override the `onStop` and `onStart`
    methods of the `InputController` to only set the listener while a game is running.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能限制对`Activity`的关键事件和运动事件的钩子。这就是为什么我们重写`InputController`的`onStop`和`onStart`方法，只在游戏运行时设置监听器。
- en: 'There are several possible controller layouts. In general, they usually have
    a cross control and/or an analog joystick. Some have several analog joysticks
    and, of course, buttons. All in all there are some important details about the
    events and how different gamepads may be configured:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的控制器布局。一般来说，它们通常有一个十字控制键和/或模拟控制杆。一些设备有几个模拟控制杆，当然还有按钮。总的来说，关于事件和不同游戏手柄如何配置有一些重要的细节：
- en: '![Physical controllers](img/B04757_02_12.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![物理控制器](img/B04757_02_12.jpg)'
- en: The cross control can be made of buttons or it can be another analog joystick.
    If it has buttons, it will be handled as a `KeyEvent` with the same constants
    as a D-Pad. If it is an analog joystick, it will use `AXIS_HAT_X` and `AXIS_HAT_Y`.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十字控制键可以由按钮组成，也可以是另一个模拟控制杆。如果它有按钮，它将作为具有与D-Pad相同常量的`KeyEvent`处理。如果它是一个模拟控制杆，它将使用`AXIS_HAT_X`和`AXIS_HAT_Y`。
- en: Analog joysticks are handled via `MotionEvent` and we can read them using the
    `getAxisValue` method of the `MotionEvent`. The default joystick will use `AXIS_X`
    and `AXIS_Y`.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟控制杆通过`MotionEvent`处理，我们可以使用`MotionEvent`的`getAxisValue`方法来读取它们。默认控制杆将使用`AXIS_X`和`AXIS_Y`。
- en: We are not going to map the second analog joystick for this game, but it is
    mapped on the `AXIS_Z` and `AXIS_RZ`.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会为这个游戏映射第二个模拟控制杆，但它被映射在`AXIS_Z`和`AXIS_RZ`上。
- en: The buttons are mapped as a `KeyEvent` with the name of each button.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮被映射为具有每个按钮名称的`KeyEvent`。
- en: Handling MotionEvents
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`MotionEvent`
- en: When we receive a `MotionEvent`, we need to first validate that the event is
    from a source we should read.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接收到`MotionEvent`时，我们首先需要验证事件是否来自我们应该读取的源。
- en: 'The source is part of the event and it is a composition of flags. The ones
    we are interested in are:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 源是事件的一部分，它是一系列标志的组合。我们感兴趣的是：
- en: '`SOURCE_GAMEPAD`: It indicates that the device has gamepad buttons such as
    **A**, **B**, **X**, or **Y**.'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCE_GAMEPAD`：表示设备具有如**A**、**B**、**X**或**Y**之类的游戏手柄按钮。'
- en: '`SOURCE_DPAD`: It indicates that the device has a D-Pad.'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCE_DPAD`：表示设备有一个D-Pad。'
- en: '`SOURCE_JOYSTICK`: It indicates that the device has analog control sticks.'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCE_JOYSTICK`：表示设备具有模拟控制杆。'
- en: The only motion events we should process are the ones in which the source has
    the joystick flag set. Both gamepad and D-Pad sources will be sent as a `KeyEvent`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该处理的唯一运动事件是那些设置了控制杆标志的事件。游戏手柄和D-Pad源都将作为`KeyEvent`发送。
- en: 'The handling of receiving a `MotionEvent` is as follows:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 接收`MotionEvent`的处理方式如下：
- en: '[PRE73]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: First, we check the source. If it is not from a joystick, we just return `false`,
    since we won't be consuming this event.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查源。如果不是来自控制杆，我们就直接返回`false`，因为我们不会消耗这个事件。
- en: Then we read the axis values for `MotionEvent.AXIS_X` and `MotionEvent.AXIS_Y`
    and assign them to our variables. This is meant to read the default joystick.
    But we are not done. It is possible that the controller has a cross that works
    as an analog joystick.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们读取`MotionEvent.AXIS_X`和`MotionEvent.AXIS_Y`的轴值，并将它们分配给我们的变量。这是为了读取默认控制杆。但我们还没有完成。控制器可能有一个用作模拟控制杆的十字控制键。
- en: To decide whether we read the secondary joystick, we check if there was input
    on the default one. If not, we assign the value from the secondary one to our
    variables.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定我们是否读取辅助摇杆，我们检查默认摇杆是否有输入。如果没有，我们将辅助摇杆的值分配给我们的变量。
- en: It is important to note that most analog joysticks are not perfectly aligned
    at 0, so comparing the value of `mHorizontalFactor` and `mVerticalFactor` with
    0 is not a valid way to detect if the joystick was moved.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，大多数模拟摇杆在 0 点并不完全对齐，因此比较 `mHorizontalFactor` 和 `mVerticalFactor` 的值与
    0 并不是检测摇杆是否移动的有效方法。
- en: Note
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Analog joysticks are not perfectly centered at 0.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟摇杆在 0 点并不完全居中。
- en: What we need to do is to read the flat value of the motion range of the device.
    It is much simpler than it sounds, since all this information is a part of the
    `MotionEvent`.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是读取设备的运动范围平坦值。这比听起来简单得多，因为所有这些信息都是 `MotionEvent` 的一部分。
- en: Then, if there was no input from the default axis, we assign the value of `AXIS_HAT_X`
    and `AXIS_HAT_Y` to our variables. We also check whether the input of the axis
    is above its flat value and set it to 0 if it is not. We need to do this or the
    spaceship will move very slowly without any input at all.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果没有来自默认轴的输入，我们将 `AXIS_HAT_X` 和 `AXIS_HAT_Y` 的值分配给我们的变量。我们还检查轴的输入是否高于其平坦值，如果不是，则将其设置为
    0。我们必须这样做，否则太空船在没有任何输入的情况下会移动得非常慢。
- en: Finally, we return `true` to indicate that we have consumed the event.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回 `true` 以指示我们已经消费了该事件。
- en: Handling KeyEvents
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理键事件
- en: 'The implementation of `dispatchKeyEvent` is very similar to the one we did
    for the basic controller with buttons on the screen:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatchKeyEvent` 的实现与我们在屏幕按钮基本控制器上所做的非常相似：'
- en: '[PRE74]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The only significant difference is that we are comparing key codes to the constants
    for the D-Pad instead of view ID. But apart from this, the logic is exactly the
    same.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的重大区别是我们将键码与 D-Pad 的常量进行比较，而不是与视图 ID 进行比较。但除此之外，逻辑完全相同。
- en: We also have to take care of mapping the button **B** to act as the back key.
    While this is already done on the latest versions of Android, it was not always
    the case, so we need to handle it. For this, we use the `onBackPressed` callback
    we already created in `YassActivity`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须注意将按钮 **B** 映射为返回键。虽然这已经在 Android 的最新版本中完成，但并非总是如此，因此我们需要处理它。为此，我们使用在 `YassActivity`
    中已创建的 `onBackPressed` 回调。
- en: Also, on Android 4.2 (API level 17) and before it, the system treated `BUTTON_A`
    as the Android back key by default. This is why we should always use `BUTTON_A`
    as the primary game action.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 Android 4.2（API 级别 17）及其之前，系统默认将 `BUTTON_A` 视为 Android 返回键。这就是为什么我们应该始终使用
    `BUTTON_A` 作为主要游戏动作的原因。
- en: Detecting gamepads
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测游戏手柄
- en: It is a good practice to check whether a controller is connected when we launch
    the game. This allows us to display a help screen on how to play with a controller
    before the user starts playing. We should also check whether the controller is
    disconnected while the game is already running to pause it.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动游戏时检查控制器是否连接是一种良好的做法。这允许我们在用户开始玩游戏之前显示如何使用控制器的帮助屏幕。我们还应该在游戏运行时检查控制器是否断开连接，以便暂停游戏。
- en: While checking for controllers can be done via the `InputDevice` class, checking
    for changes in the controllers was only introduced in API level 16 (we are using
    minSDK=15).
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过 `InputDevice` 类检查控制器，但检查控制器变化的功能仅在 API 级别 16 中引入（我们使用 minSDK=15）。
- en: Note
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Detecting changes in the controllers being connected or disconnected was only
    introduced in Jelly Bean.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 检测控制器连接或断开连接的功能仅在 Jelly Bean 中引入。
- en: We are not going to provide a backward-compatible solution to detect the connection
    and disconnection of controllers. If you need to do it, there are detailed steps
    in the official documentation at [http://developer.android.com/training/game-controllers/compatibility.html](http://developer.android.com/training/game-controllers/compatibility.html);
    these basically use a polling mechanism over input devices and check for changes
    in the list.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会提供向后兼容的解决方案来检测控制器的连接和断开。如果您需要这样做，官方文档中有详细的步骤，请参阅[http://developer.android.com/training/game-controllers/compatibility.html](http://developer.android.com/training/game-controllers/compatibility.html)；这些步骤基本上是在输入设备上使用轮询机制并检查列表中的变化。
- en: 'We are going to check for gamepads during the `onResume` of the `MainMenuFragment`.
    The first time a controller is detected, we will show an `AlertDialog` that shows
    how to use the gamepad:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`MainMenuFragment`的`onResume`期间检查游戏手柄。当检测到控制器第一次时，我们将显示一个`AlertDialog`，显示如何使用游戏手柄：
- en: '[PRE75]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We are using default shared preferences to store whether we have displayed the
    dialog already or not. Once it is displayed we set the value to false, so it is
    not shown again.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用默认的共享首选项来存储是否已经显示了对话框。一旦显示，我们将值设置为false，因此不再显示。
- en: 'The method to check if there is a controller connected is as follows:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否有控制器连接的方法如下：
- en: '[PRE76]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We iterate over the input devices and, if the source of any of them is a gamepad
    or a joystick, we return true.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历输入设备，如果其中任何一个的来源是游戏手柄或操纵杆，我们就返回true。
- en: If no device is found with these sources, we return false.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到具有这些来源的设备，我们返回false。
- en: Note that each `InputDevice` also has a name. This can be useful to identify
    specific gamepads in case you want to show different help screens such as for
    Nvidia Shield.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个`InputDevice`都有一个名称。这有助于在需要显示不同帮助屏幕的情况下识别特定的游戏手柄，例如Nvidia Shield。
- en: To check whether a controller gets disconnected during gameplay, we need to
    register an `InputDeviceListener` on the `InputManager` and process the events.
    We will make `GameFragment` implement `InputDeviceListener`.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查控制器在游戏过程中是否断开连接，我们需要在`InputManager`上注册一个`InputDeviceListener`并处理事件。我们将使`GameFragment`实现`InputDeviceListener`。
- en: We do the registration right after creating the `GameEngine` and the unregistration
    after stopping the game in `onDestroy`. You need to either add some annotations
    to prevent int from giving an error for the method not being available on the
    minimum SDK or wrap it into an `if` block that checks the version, as we did before.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建`GameEngine`后立即进行注册，并在`onDestroy`中停止游戏后进行注销。你需要添加一些注释以防止int在方法不可用的情况下给出错误，或者将其包裹在一个检查版本的`if`块中，就像我们之前做的那样。
- en: 'Then, it is as simple as pausing the game when a device is disconnected:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当设备断开连接时暂停游戏就很简单了：
- en: '[PRE77]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that this pauses the game when *any* device gets disconnected. It is unlikely
    that a device that is not a controller gets disconnected, but we could make sure
    it is a controller just by checking the source, as we did for `isGameControllerConnected`.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当任何设备断开连接时，这将暂停游戏。一个非控制器的设备断开连接的可能性不大，但我们可以通过检查来源来确保它是一个控制器，就像我们在`isGameControllerConnected`中做的那样。
- en: Sensors and InputControllers
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传感器和输入控制器
- en: Sensors are a common way to control games on smartphones. They work fine when
    the only controls in the game are left and right (like a car racing game). If
    you plan to also move up and down, you need to ask the player to do a calibration
    at the beginning of the game to make it usable. Note that, when you are using
    only one axis, such calibration is not necessary.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器是智能手机上控制游戏的常见方式。当游戏中的唯一控制是左右（如赛车游戏）时，它们工作得很好。如果你计划同时上下移动，你需要在游戏开始时让玩家进行校准以使其可用。请注意，当你只使用一个轴时，这种校准是不必要的。
- en: In addition to this, the up and down movement tends to interfere with the `sensorLandscape`
    orientation. So, the use of sensors is not a very good idea for YASS.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，上下移动往往会干扰`sensorLandscape`方向。因此，对于YASS，使用传感器不是一个很好的主意。
- en: Note
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sensors are good controls only in certain cases.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器在某些情况下是很好的控制方式。
- en: You also have to consider that, while sensors are a replacement for directions,
    you still need to place the action buttons on the screen—in our case, the fire
    button.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须考虑，虽然传感器可以替代方向，但你仍然需要在屏幕上放置动作按钮——在我们的例子中，是射击按钮。
- en: We are not going to use sensors for YASS but, if you want to make a game that
    uses them, we will cover the basics.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在YASS中使用传感器，但如果你想制作一个使用它们的游戏，我们将介绍基础知识。
- en: 'You need to register a listener for the accelerometer and another one for the
    magnetic field. You should only listen to the sensors while the game is running,
    so we will override the life cycle methods to register and unregister sensors
    accordingly:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为加速度计注册一个监听器，并为磁场注册另一个监听器。你应该只在游戏运行时监听传感器，因此我们将重写生命周期方法以相应地注册和注销传感器：
- en: '[PRE78]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that we are using `SensorManager.SENSOR_DELAY_FASTEST`, which means that
    the sensors will give feedback as fast and as often as they can. This is very
    important for real-time games.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是`SensorManager.SENSOR_DELAY_FASTEST`，这意味着传感器会尽可能快和尽可能频繁地提供反馈。这对于实时游戏非常重要。
- en: 'We are setting objects as listeners. Each listener will just copy the values
    of the sensor into a local array that we will process later on. For example, in
    the case of an accelerometer, we will do:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对象设置为监听器。每个监听器将只复制传感器的值到一个我们将稍后处理的本地数组中。例如，在加速度计的情况下，我们将这样做：
- en: '[PRE79]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To obtain the final value, we have to do some calculations. So, we will add
    a `onPreUpdate` method that will be called by the `GameEngine` just before calling
    `onUpdate`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最终值，我们必须进行一些计算。因此，我们将添加一个 `onPreUpdate` 方法，该方法将在 `GameEngine` 调用 `onUpdate`
    之前被调用。
- en: 'It is important to note that there are some special cases. They are as follows:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，有一些特殊情况。它们如下：
- en: There are devices that lack a magnetic field sensor. In such cases, we can use
    a simplified version using the value of the accelerometer. Nvidia Shield and specific
    versions of Nook are some of these devices.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些设备缺少磁场传感器。在这种情况下，我们可以使用一个简化版本，使用加速度计的值。Nvidia Shield 和某些版本的 Nook 就是这些设备之一。
- en: In all cases, the sensors are related to the default orientation of the device,
    which can be either landscape or portrait. We have to take this into consideration
    while processing the values.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有情况下，传感器都与设备的默认方向相关，可以是横屏或竖屏。在处理值时，我们必须考虑这一点。
- en: 'All in all, the conversion for the horizontal axis can be done like this:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，水平轴的转换可以这样做：
- en: '[PRE80]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `getHorizontalAxis` code does the following steps:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`getHorizontalAxis` 代码执行以下步骤：'
- en: Calculates the rotation matrix using the last data from the accelerometer and
    the magnetic sensor.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计和磁传感器的最后数据计算旋转矩阵。
- en: If it returns true, all goes well. Based on the rotation of the device, we decide
    whether we need to remap the coordinate system or not and then return the orientation
    that is converted into degrees.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它返回 true，一切正常。根据设备的旋转，我们决定是否需要重新映射坐标系，然后返回转换为度的方向。
- en: If it could not be calculated (lack of a magnetic field sensor), the method
    returns false. We have to rely on an approximation using the accelerometer values.
    Based on the rotation of the device, we should use one or another axis.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法计算（缺少磁场传感器），该方法返回 false。我们必须依赖于使用加速度计值的一个近似。根据设备的旋转，我们应该使用一个或另一个轴。
- en: The rotation of the device can be read in the constructor of the `InputController`
    with a single line of code.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的旋转可以在 `InputController` 的构造函数中通过一行代码读取。
- en: '[PRE81]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, the `onPreUpdate` method:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onPreUpdate` 方法：
- en: '[PRE82]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The is method just converts the reading (in degrees) into values in the range
    [-1,1] by using the maximum angle at which we consider it to be fully tilted.
    I recommend you to play with this constant and start with 30 degrees.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 方法只是将读取值（以度为单位）转换为 [-1,1] 范围内的值，使用我们认为是完全倾斜的最大角度。我建议你玩一下这个常数，从 30 度开始。'
- en: For more information on handling sensors, you can check the official documentation
    [http://developer.android.com/guide/topics/sensors/sensors_overview.html](http://developer.android.com/guide/topics/sensors/sensors_overview.html).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 关于处理传感器的更多信息，你可以查看官方文档 [http://developer.android.com/guide/topics/sensors/sensors_overview.html](http://developer.android.com/guide/topics/sensors/sensors_overview.html)。
- en: Selecting control modes
  id: totrans-721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择控制模式
- en: It is common for games to ask the user to select the control mode they prefer,
    but it is also a good practice to avoid friction as much as possible by not asking
    what is not necessary.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常会让用户选择他们偏好的控制模式，但避免询问不必要的选项，尽可能减少摩擦也是一个好的实践。
- en: YASS is only using a virtual joystick and the gamepad controls. There is no
    need to ask the user which one he or she wants. Both input modes are compatible,
    especially because the virtual joystick does not display anything on the screen
    when it is not used. The only thing we need to do is to modify the `GameEngine`
    to support more than one `InputController`.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: YASS 只使用虚拟摇杆和游戏手柄控制。没有必要询问用户他们想要哪一个。两种输入模式都是兼容的，尤其是虚拟摇杆在不使用时不会在屏幕上显示任何内容。我们唯一需要做的是修改
    `GameEngine` 以支持一个以上的 `InputController`。
- en: Note
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will support both input modes simultaneously.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将同时支持两种输入模式。
- en: The way to support both input modes at the same time is to create a `CompositeInputController`
    that uses the composition pattern to have both a `VirtualJoystickInputController`
    and a `GamepadInputController`, and combines the input from both.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 同时支持两种输入模式的方法是创建一个 `CompositeInputController`，它使用组合模式来同时拥有 `VirtualJoystickInputController`
    和 `GamepadInputController`，并组合两者的输入。
- en: To synchronize the readings from the two input controllers, we are going to
    use a method on the `InputController` called `onPreUpdate`, which will be called
    just before `onUpdate`. We will use it to populate the values of `mHorizontalFactor`,
    `mVerticalFactor`, and `mIsFiring` with the ones read from the other controllers.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同步两个输入控制器读取的数据，我们打算在`InputController`上使用一个名为`onPreUpdate`的方法，这个方法将在`onUpdate`之前被调用。我们将使用它来填充`mHorizontalFactor`、`mVerticalFactor`和`mIsFiring`的值，这些值是从其他控制器读取的。
- en: '[PRE83]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We now have a game that can be controlled with a virtual joystick and a gamepad.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以用虚拟摇杆和游戏手柄控制的游戏。
- en: Summary
  id: totrans-730
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned how to deal with input from users in several ways and how to
    make it transparent for the `GameEngine`.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何以多种方式处理用户的输入，以及如何使它对`GameEngine`透明。
- en: To get a proper visual feedback from the controller, we created a `Player` game
    object that updates its position based on the values from the `InputController`.
    We also learned how to add and remove game objects to and from the `GameEngine`
    while playing.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从控制器获得适当的视觉反馈，我们创建了一个`Player`游戏对象，它根据`InputController`的值更新其位置。我们还学会了如何在游戏过程中添加和移除游戏对象到`GameEngine`。
- en: We created a very basic keypad that later evolved into a virtual joystick. We
    also learned how to handle external controllers.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常基本的键盘，后来演变成了虚拟摇杆。我们还学会了如何处理外部控制器。
- en: At this point, our game has a spaceship that moves along the screen and fires
    bullets. It can be controlled using a virtual joystick or a gamepad, independently.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的游戏有一个在屏幕上移动并发射子弹的宇宙飞船。它可以独立地使用虚拟摇杆或游戏手柄进行控制。
- en: 'The current implementation does lag occasionally and we have barely started
    drawing objects on the screen. It is time to fix this. Next stop: improve the
    rendering by drawing directly on the view instead of relying on positioning views
    on the screen.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现偶尔会有延迟，而我们刚刚开始在屏幕上绘制对象。是时候修复这个问题了。下一个目标：通过直接在视图中绘制来改进渲染，而不是依赖于在屏幕上定位视图。
- en: Chapter 3. Into the Draw Thread
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 进入绘制线程
- en: 'In this chapter, we are going to improve the rendering of sprites for our game.
    For this, we are going to use a custom `GameView` that will perform low-level
    drawing. We will make two different implementations: one that extends from `View`
    and another one that extends from `SurfaceView`. We will let `DrawThread` be a
    real thread, to work better with this `GameView`.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进游戏中精灵的渲染。为此，我们将使用一个自定义的`GameView`，它将执行低级绘制。我们将实现两种不同的实现：一种扩展自`View`，另一种扩展自`SurfaceView`。我们将让`DrawThread`成为一个真正的线程，以更好地与这个`GameView`协同工作。
- en: We will refactor the project, creating a `Sprite` class that will be used for
    all the items that are drawn in the game. We will draw bitmaps on a `Canvas` and
    learn about the transformation matrix used to do this.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构项目，创建一个`Sprite`类，该类将用于游戏中所有绘制的项目。我们将在`Canvas`上绘制位图，并了解用于此目的的变换矩阵。
- en: To continue improving the game, we will add enemies. They will be a wave of
    asteroids moving towards our spaceship. For this, we will learn the concept of
    `GameController` and the different ways of doing it, from static to procedural
    level generation.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续改进游戏，我们将添加敌人。它们将是一波向我们的宇宙飞船移动的小行星。为此，我们将学习`GameController`的概念以及实现它的不同方法，从静态到程序化关卡生成。
- en: As part of the rendering techniques, we will learn about occlusion culling and
    parallax backgrounds, which we will use to make the game look nicer.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渲染技术的一部分，我们将了解遮挡剔除和视差背景，我们将使用这些技术来使游戏看起来更美观。
- en: Finally, we will add support for layers in the engine.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为引擎添加对层的支持。
- en: Using GameView
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GameView
- en: Until now, we have been using standard views and translating them to render
    the different elements of the game. While this is an easy way to draw elements
    on the screen, it is far from being efficient. We are relying on the system layout
    to do the drawing.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用标准视图并将它们转换为渲染游戏的不同元素。虽然这是一种在屏幕上绘制元素的方法，但它远非高效。我们依赖于系统布局来进行绘制。
- en: While this technique is fine for a turn-based game or any non-real-time game
    in general, it cannot render enough frames per second for a real-time game.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种技术在回合制游戏或任何非实时游戏中都很好，但它无法以足够的帧率渲染实时游戏。
- en: Note
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Working with standard Views is fine for non-real-time games.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非实时游戏，使用标准视图是可行的。
- en: We are going to create a custom `View` that we are going to call `GameView`.
    This view will be responsible for drawing the sprites.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义的`View`，我们将称之为`GameView`。这个视图将负责绘制精灵。
- en: We already noted the duplication of code and mentioned the concept of sprite
    in the previous chapter. We will now move forward and create a `Sprite` class
    that will take care of drawing an image at specific coordinates inside the `GameView`.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中提到了代码重复的概念，并介绍了精灵（sprite）的概念。现在我们将继续前进，创建一个`Sprite`类，该类将负责在`GameView`内部特定坐标处绘制图像。
- en: 'There are two ways of drawing at low level on Android. They are:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，有几种低级绘图方式。它们是：
- en: Extending `View` and overriding `onDraw`
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`View`并重写`onDraw`
- en: Extending `SurfaceView` and using `SurfaceHolder`
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`SurfaceView`并使用`SurfaceHolder`
- en: In both cases, we will get a `Canvas` and draw our `GameObjects` on it. The
    main difference is that the `onDraw` method of the `View` is executed on the `UIThread`,
    while `SurfaceView` and `SurfaceHolder` are designed to perform the draw on a
    separate thread.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都会得到一个`Canvas`，并在其上绘制我们的`GameObjects`。主要区别在于`View`的`onDraw`方法是在`UIThread`上执行的，而`SurfaceView`和`SurfaceHolder`被设计为在单独的线程上执行绘制。
- en: Note
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Low-level drawing on Android is always done using a canvas.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，低级绘图始终使用`Canvas`完成。
- en: According to the official documentation, it is more efficient to use `SurfaceView`.
    But, since Android 4.0, view rendering is hardware-accelerated (while `SurfaceView`
    is not). In the case of modern phones with high-resolution screens and faster
    processors, this may not always be the case.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，使用`SurfaceView`更高效。但是，从Android 4.0开始，视图渲染是硬件加速的（而`SurfaceView`不是）。在具有高分辨率屏幕和快速处理器的现代手机上，这并不总是如此。
- en: Note
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`SurfaceView` is not hardware-accelerated and may perform worse than normal
    `View`.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceView`不是硬件加速的，可能比普通`View`表现更差。'
- en: 'Anyway, you should know both and be able to swap them easily, even if it is
    just for testing purposes. We will create an interface named `GameView`, which
    will be implemented by the two classes, so they can be changed easily. The classes
    we will make are:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你应该了解它们，并且能够轻松地互换，即使只是为了测试目的。我们将创建一个名为`GameView`的接口，这两个类将实现它，以便它们可以轻松更改。我们将制作的类是：
- en: '`StandardGameView`: This will extend from `View`'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StandardGameView`：这将扩展自`View`'
- en: '`SurfaceGameView`: This will extend from `SurfaceView`'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SurfaceGameView`：这将扩展自`SurfaceView`'
- en: The GameView interface
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GameView`接口'
- en: 'The `GameView` interface will have all the methods that are needed by the `GameEngine`
    to handle the `View`:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameView`接口将包含`GameEngine`处理`View`所需的所有方法：'
- en: '[PRE84]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'There are basically two methods we need, one to trigger the drawing and one
    to pass the list of game objects to the `GameView`, so they can be drawn there:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上需要两种方法，一种用于触发绘制，另一种将游戏对象列表传递给`GameView`，以便它们可以在那里绘制：
- en: '`draw`: This will trigger a draw on the `GameView`'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`：这将触发`GameView`的绘制'
- en: '`setGameObjects`: This will set the list of `GameObjects` for the `View`'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGameObjects`：这将设置`View`的`GameObjects`列表'
- en: The rest of the methods are implemented in the `View`. We need to declare them,
    because we are using them on the `GameEngine`.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法都在`View`中实现。我们需要声明它们，因为我们正在`GameEngine`中使用它们。
- en: Let's explore each implementation in detail.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探索每种实现方式。
- en: StandardGameView
  id: totrans-769
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StandardGameView
- en: 'The `StandardGameView` class extends `View`. We just provide the basic constructors
    for `View`, override the `onDraw` method, and then implement the methods from
    `GameView`:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardGameView`类扩展自`View`。我们只为`View`提供了基本的构造函数，重写了`onDraw`方法，然后实现了`GameView`中的方法：'
- en: '[PRE85]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Basically, `setGameObjects` stores a reference to the game objects. The adding
    and removing of `GameObjects` are done in the `GameEngine`. When we draw the view,
    we iterate over the list of game objects, calling `onDraw` on all of them and
    passing the `Canvas` object on which we are drawing.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`setGameObjects`存储游戏对象的引用。游戏对象的添加和删除在`GameEngine`中完成。当我们绘制视图时，我们遍历游戏对象列表，对它们中的每一个调用`onDraw`，并传递我们正在绘制的`Canvas`对象。
- en: Note that the method is synchronized using the `mGameObjects` variable. This
    is important because, as we mentioned in [Chapter 1](ch21.html "Chapter 1. Setting
    Up the Project"), *Setting Up the Project*, the contents of the list can change
    during `onUpdate` and we do not want this to happen while we are iterating over
    the list.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该方法使用`mGameObjects`变量进行同步。这很重要，因为我们提到在[第1章](ch21.html "第1章. 设置项目")中，*设置项目*，列表的内容可以在`onUpdate`期间改变，我们不希望在我们遍历列表时发生这种情况。
- en: The other important point is that the list of `GameObjects` is a reference to
    the one inside the `GameEngine` and not a copy, so whenever the list gets modified,
    the latest values are accessible from both places. This is also why synchronization
    is required.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的点是，`GameObjects` 的列表是 `GameEngine` 中列表的引用，而不是副本，所以每当列表被修改时，最新的值都可以从两个地方访问。这也是为什么需要同步的原因。
- en: Note
  id: totrans-775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The list of GameObjects is shared between the GameEngine and the GameView.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: GameObjects 的列表在 GameEngine 和 GameView 之间共享。
- en: Performance-wise, it would not make sense to copy all the elements in the list
    to a new one in each execution of `onDraw`.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，在每次 `onDraw` 执行中都将列表中的所有元素复制到新列表中是没有意义的。
- en: To trigger a draw, we just need to call `postInvalidate`. Remember that invalidating
    a view has to be done on the `UIThread`. This is why we need to call `postInvalidate`.
    This method will post a `Runnable` to be run on the `UIThread` that will then
    invalidate the `View`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发绘制，我们只需调用 `postInvalidate`。记住，使视图无效必须在 `UIThread` 上完成。这就是为什么我们需要调用 `postInvalidate`
    的原因。此方法将发布一个将在 `UIThread` 上运行的 `Runnable`，然后使 `View` 无效。
- en: As we mentioned in the earlier chapters, once the view gets invalidated, Android
    makes sure that the `onDraw` method of the `View` is called and then the UI is
    updated. This is the connection between invalidating the view and the `onDraw`
    method, where we draw the game objects.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，一旦视图被使无效，Android 确保调用 `View` 的 `onDraw` 方法，然后更新 UI。这是使视图无效和 `onDraw`
    方法之间的联系，我们在其中绘制游戏对象。
- en: 'The `onDraw` method is obviously time-critical. We should avoid all unnecessary
    operations. In particular, lint shows a warning if you create an object inside
    `onDraw`. This is, to reiterate, a best practice for game developers: to always
    create the objects in advance.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw` 方法显然是时间敏感的。我们应该避免所有不必要的操作。特别是，如果你在 `onDraw` 中创建对象，lint 会显示警告。这再次重申，是游戏开发者的最佳实践：始终提前创建对象。'
- en: Note
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never do object creation inside `onDraw`.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在 `onDraw` 中创建对象。
- en: Also, it is worth remembering that Android has a fallback mechanism to avoid
    overload on the drawing. If a view has been invalidated but not yet redrawn, the
    call to invalidate will be ignored (the view is already going to be redrawn).
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得记住的是，Android 有一个回退机制来避免绘图过载。如果一个视图已被使无效但尚未重绘，对无效的调用将被忽略（视图已经将要重绘）。
- en: SurfaceGameView
  id: totrans-784
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SurfaceGameView
- en: To implement a `GameView` that extends `SurfaceView`, we need to define a `Callback`
    for `SurfaceHolder`—the class used to access the `SurfaceView`—and then, whenever
    we want to draw, we lock the canvas, draw on it, and unlock it again so it can
    be rendered by `SurfaceView`.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个扩展 `SurfaceView` 的 `GameView`，我们需要为 `SurfaceHolder` 定义一个 `Callback`——用于访问
    `SurfaceView` 的类——然后，每当我们要绘制时，我们锁定画布，在其上绘制，然后再解锁它，以便它可以由 `SurfaceView` 渲染。
- en: 'Let''s see the code of `SurfaceGameView`:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `SurfaceGameView` 的代码：
- en: '[PRE86]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: First, we have three constructors with different arguments that are intrinsic
    to `SurfaceView`. Note that they all include a call to set a `Callback` to the
    `SurfaceHolder`, which is also implemented by `SurfaceGameView`. This callback
    will inform us of when `SurfaceView` is ready or when things have changed.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有三个具有不同参数的构造函数，这些参数是 `SurfaceView` 内在的。注意，它们都包括调用将 `Callback` 设置到 `SurfaceHolder`，这也由
    `SurfaceGameView` 实现。此回调将通知我们 `SurfaceView` 是否已准备好或何时发生变化。
- en: The next methods are the implementation of the `Callback` interface. Those are
    the methods that are called when the `SurfaceView` is created, modified, or destroyed.
    We store the status of the view to know whether it is ready or not, so that it
    can be used to draw. A `View` is ready any time after it is created until it is
    destroyed.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `Callback` 接口的实现。这些是在 `SurfaceView` 创建、修改或销毁时被调用的方法。我们存储视图的状态，以便知道它是否已准备好，这样就可以用于绘制。一个
    `View` 在创建后直到销毁的任何时间都是可用的。
- en: Then, we move into implementing the methods from `GameView`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入实现 `GameView` 的方法。
- en: To set the `GameObjects`, we do exactly as we did for `StandardGameView`, also
    with the same implications when it comes to handling a reference.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `GameObjects`，我们与 `StandardGameView` 完全一样，同样在处理引用时也有相同的含义。
- en: The `draw` method is where things are a bit different. We have to check whether
    the view is ready. If so, we lock the `Canvas` so we can draw on it.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法是事情有点不同。我们必须检查视图是否已准备好。如果是这样，我们锁定 `Canvas` 以便我们可以在其上绘制。'
- en: Once we have the canvas, we need to clean it before we draw each frame. The
    canvas will have the previous image on it. (If we do not clean it, we will get
    rendering artifacts as shown in the following screenshot.) This cleaning is done
    by filling the canvas with a solid color using `drawRGB`.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了画布，我们在绘制每一帧之前需要清理它。画布上将有之前的图像。（如果我们不清理它，我们将在下面的屏幕截图中看到渲染伪影。）这种清理是通过使用`drawRGB`用纯色填充画布来完成的。
- en: '![SurfaceGameView](img/B04757_03_01.jpg)'
  id: totrans-794
  prefs: []
  type: TYPE_IMG
  zh: '![SurfaceGameView](img/B04757_03_01.jpg)'
- en: Once we have cleaned the canvas, we take the same drawing as for `StandardGameView`
    and just iterate over the game objects.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们清理了画布，我们就使用与`StandardGameView`相同的绘图，然后遍历游戏对象。
- en: Finally, we unlock the canvas and post it. This is the point when we pass the
    `Canvas` back to the `SurfaceView` and post it to the `UIThread`. Note that all
    of the drawing has been done outside the `UIThread`. Only once the `Canvas` is
    fully rendered will it be passed back for drawing.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解锁画布并发布它。这是我们将`Canvas`返回给`SurfaceView`并发布到`UIThread`的时刻。请注意，所有绘图都是在`UIThread`外完成的。只有当`Canvas`完全渲染后，它才会被返回以进行绘图。
- en: Note
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`SurfaceView` performs the drawing on the `Canvas` outside the `UIThread`.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceView`在`UIThread`外部的`Canvas`上执行绘图。'
- en: As mentioned before, `SurfaceView` is supposed to give better performance. But,
    since it is only software accelerated, in modern phones a standard `View`—with
    hardware acceleration—may be more efficient in some cases. A particular situation
    when `SurfaceView` performance is impacted is if we put other views on top of
    it (like the pause button), since a full alpha-blended composite will be performed
    each time the surface changes.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`SurfaceView`应该提供更好的性能。但是，由于它只是软件加速，在现代手机上，在某些情况下，带有硬件加速的标准`View`可能更有效率。`SurfaceView`性能受到影响的一个特定情况是，如果我们将其上的其他视图（如暂停按钮）放在它上面，因为每次表面变化时都会执行完整的alpha混合合成。
- en: Updating GameEngine
  id: totrans-800
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新GameEngine
- en: The use of `GameView` has some implications from the `GameEngine` point of view.
    It means that it has to initialize the `GameView` and then trigger draws using
    the generic interface.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 从`GameEngine`的角度来看，使用`GameView`有一些影响。这意味着它必须初始化`GameView`，然后使用通用接口触发绘图。
- en: 'The `GameView` will be a parameter of the constructor of `GameEngine`. It will
    be initialized, passing a reference to the list of game objects. The updated constructor
    of `GameEngine` is like this:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameView`将成为`GameEngine`构造函数的参数。它将被初始化，传递一个游戏对象列表的引用。更新后的`GameEngine`构造函数如下：'
- en: '[PRE87]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'From now on, we will also calculate the `pixelFactor` inside the `GameEngine`.
    We will store it in a public variable so it can be read by the game objects. This
    has several advantages, such as:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们也将计算`pixelFactor`，在`GameEngine`内部。我们将将其存储在一个公共变量中，以便游戏对象可以读取。这有几个优点，例如：
- en: If we decide to change the number of units of the screen, this is done in a
    single place
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们决定更改屏幕的单位数，这将在一个地方完成
- en: Removing code duplications is always good for maintenance
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除代码重复总是有利于维护
- en: 'On the other hand, the `onDraw` method of the `GameEngine` becomes extremely
    simple:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`GameEngine`的`onDraw`方法变得极其简单：
- en: '[PRE88]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Updating the game layout
  id: totrans-809
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏布局
- en: Of course, we have to modify the `fragment_game.xml` layout to include the `GameView`.
    We will take this chance to do some other modifications to it, such as removing
    the `TextView` and changing the padding of the layout to be the margins on the
    pause button instead. This makes sure that the `GameView` is fullscreen while
    keeping the button margins as they were.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须修改`fragment_game.xml`布局以包含`GameView`。我们将借此机会对其进行一些其他修改，例如删除`TextView`并更改布局的填充为暂停按钮的边距。这确保了`GameView`全屏，同时保持按钮边距不变。
- en: It is important to remember that in a `FrameLayout`, the order in the XML specifies
    the order in which the items are drawn (the z-index). We will put the `GameView`
    at the beginning of the layout to have the pause button drawn on top of it.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在`FrameLayout`中，XML中的顺序指定了项目绘制的顺序（z-index）。我们将把`GameView`放在布局的开头，以确保暂停按钮绘制在其上方。
- en: 'The new version of `fragment_game.xml` is as follows:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`fragment_game.xml`的新版本如下：'
- en: '[PRE89]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that this is the place where we decide which variant of the `GameView`
    we are going to use. The rest of the code will access the methods via the `GameView`
    interface, so nothing else needs to be changed. We are going to use the `SurfaceGameView`
    from now on, but feel free to experiment with `StandardGameView` as well.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是决定我们将要使用 `GameView` 变体的地方。其余的代码将通过 `GameView` 接口访问方法，因此不需要做任何其他更改。从现在起，我们将使用
    `SurfaceGameView`，但也可以自由地尝试 `StandardGameView`。
- en: Note
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The layout is where we set which variant of `GameView` we are going to use.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是设置我们将要使用的 `GameView` 变体的地方。
- en: 'Finally, inside `GameFragment`, we update the creation of the `GameEngine`
    by adding the `GameView` parameter:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `GameFragment` 中，我们通过添加 `GameView` 参数来更新 `GameEngine` 的创建：
- en: '[PRE90]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now we have a `GameEngine` that relies on a `GameView` to do the rendering.
    We still need to update the `GameObject` class to make use of it.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个依赖于 `GameView` 进行渲染的 `GameEngine`。我们仍然需要更新 `GameObject` 类以利用它。
- en: Before we get to the `GameObject` class, let's take a moment to improve `DrawThread`
    as well.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达 `GameObject` 类之前，让我们花点时间改进 `DrawThread`。
- en: Improving DrawThread
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进 DrawThread
- en: 'To trigger the draw we have been using a `Timer` and `TimerTask` scheduled
    so we could get 30 frames per second. While this works, it gives better performance
    to do it like the `UpdateThread`: run as many calls to `onDraw` as we can.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发绘制，我们使用了一个 `Timer` 和 `TimerTask` 来安排，以便每秒获得 30 帧。虽然这可行，但像 `UpdateThread`
    一样运行尽可能多的 `onDraw` 调用会提供更好的性能。
- en: This approach works great for `SurfaceView` since the drawing is done on the
    same thread. But it may give some message overflow problems while using `StandardGameView`,
    which just calls `postInvalidate`. To prevent the overflow, we will ensure that
    the time between the calls to `onDraw` is never shorter than 20 milliseconds,
    which is enough for 50 frames per second.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于 `SurfaceView` 来说效果很好，因为绘制是在同一线程上完成的。但是，当使用 `StandardGameView` 时，可能会出现一些消息溢出问题，因为它只是调用
    `postInvalidate`。为了防止溢出，我们将确保 `onDraw` 调用之间的时间永远不会短于 20 毫秒，这对于 50 帧每秒来说已经足够了。
- en: 'The code for the new `DrawThread` is exactly the same as for `UpdateThread`,
    except for the part in the run method that takes care of the overflow. It looks
    like this:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 新 `DrawThread` 的代码与 `UpdateThread` 的代码完全相同，只是在运行方法中处理溢出的部分不同。它看起来像这样：
- en: '[PRE91]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the case of running two calls too close, we put the thread to sleep from
    the remaining time to a minimum of 20 milliseconds.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行两个调用过于接近，我们将线程置于剩余时间的睡眠状态，直到至少 20 毫秒。
- en: If an `InterruptedException` happens, we don't really have much to handle. So,
    we can just move on and call `onDraw` in the `GameEngine`.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生 `InterruptedException`，我们实际上没有太多要处理的。因此，我们可以继续前进并调用 `GameEngine` 中的 `onDraw`。
- en: Sprites
  id: totrans-828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sprites
- en: We have already mentioned the concept of a sprite being an entity that is drawn
    and handled at a specific position on a screen. Essentially, everything we see
    in a game are sprites. There are exceptions, such as game controllers (which do
    not draw anything) and backgrounds (which are drawn in a different way), but we
    will talk about them later in the chapter.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了精灵是一个在屏幕特定位置绘制和处理的项目。本质上，我们在游戏中看到的一切都是精灵。有一些例外，例如游戏控制器（不绘制任何内容）和背景（以不同的方式绘制），但我们将稍后在章节中讨论它们。
- en: 'So, this is the code for the `Sprite` class that extends `GameObject`:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是扩展 `GameObject` 类的 `Sprite` 类的代码：
- en: '[PRE92]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`Sprite` is an abstract class and there is no implementation of `onUpdate`
    at all. Sprites care about displaying an item on the screen, not about how this
    item moves.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sprite` 是一个抽象类，并且完全没有实现 `onUpdate`。Sprite 关注的是在屏幕上显示一个项目，而不是这个项目如何移动。'
- en: 'The class has a series of member variables. Let''s go through them:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一系列成员变量。让我们逐一介绍：
- en: '`mPositionX`, `mPositionY`: The position of the `Sprite` on the screen. The
    same concept we used for the `Player` and the `Bullet` objects. This position
    is in the top-left corner of the image.'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mPositionX`, `mPositionY`: 屏幕上 `Sprite` 的位置。与 `Player` 和 `Bullet` 对象使用的相同概念。此位置位于图像的左上角。'
- en: '`mPixelFactor`: The same concept as before. The factor to convert screen units
    into pixels.'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mPixelFactor`: 与之前相同的概念。将屏幕单位转换为像素的系数。'
- en: '`mBitmap`: The bitmap we are going to draw.'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBitmap`: 我们将要绘制的位图。'
- en: '`mImageWidth`, `mImageHeight`: The size of the bitmap as drawn on the screen.
    It is set here for convenience. We could always calculate it using the bitmap
    and the pixel factor, but it is faster to just store it for future use by the
    subclasses.'
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mImageWidth`，`mImageHeight`：屏幕上绘制的位图的大小。这里设置是为了方便。我们总是可以使用位图和像素因子来计算它，但直接存储以供子类将来使用更快。'
- en: '`mMatrix`: This object is a transformation matrix. It is used for scaling,
    moving, and rotating the bitmap before rendering it on the canvas. For optimization
    purposes, it is reused among the `onDraw` executions instead of being created
    for each run.'
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mMatrix`：此对象是一个变换矩阵。它用于在画布上渲染位图之前进行缩放、移动和旋转。为了优化目的，它被重用于`onDraw`执行之间，而不是为每次运行创建。'
- en: The next piece of code is the constructor. We are passing a reference to the
    `GameEngine` and a drawable resource. In the previous chapter, we were passing
    the parent `View`, so we could add the newly created `ImageView` to it. This is
    no longer necessary. We just need the `Context` and the pixel factor, which we
    can get from the `GameEngine`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是构造函数。我们传递`GameEngine`的引用和一个可绘制资源。在前一章中，我们传递了父`View`，这样我们就可以将其添加到新创建的`ImageView`中。这不再是必要的。我们只需要`Context`和像素因子，这些都可以从`GameEngine`中获取。
- en: 'The code in the constructor is very similar to the ones we have seen before.
    It does several things:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的代码与我们之前看到的非常相似。它做了几件事情：
- en: Loads the `Drawable` from resources via the `Context`
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Context`从资源中加载`Drawable`。
- en: Gets the intrinsic size of the drawable and multiplies it by the pixel factor
    to store the width and height that the sprite will use in pixels for this particular
    device
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取可绘制对象的固有尺寸，并将其乘以像素因子以存储精灵将用于此特定设备的像素宽度和高度。
- en: Gets the `Bitmap` from the `Drawable` and stores it in a class variable to use
    it during `onDraw`
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Drawable`获取`Bitmap`并将其存储在类变量中，以便在`onDraw`中使用。
- en: Finally, we have the `onDraw` method that receives a `Canvas`. This method is
    now called from the `GameView`. The `Canvas` is obtained in a different way from
    a `StandardGameView` and `SurfaceGameView`, but the logic of drawing on it is
    the same in both cases.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`onDraw`方法，它接收一个`Canvas`。现在这个方法是从`GameView`中调用的。`Canvas`的获取方式与`StandardGameView`和`SurfaceGameView`不同，但在两种情况下绘制逻辑是相同的。
- en: A canvas works as a drawing interface for the actual surface upon which your
    graphics will be drawn. It provides us with a set of primitives to draw, including
    bitmaps, text, lines, rectangles, ovals, and so on. When using a canvas, the drawing
    is actually performed upon an underlying bitmap, which is then placed in the window.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas作为实际绘图表面的绘图接口。它为我们提供了一套绘图原语，包括位图、文本、线条、矩形、椭圆等。当使用Canvas时，绘图实际上是在一个底层的位图上进行的，然后该位图被放置在窗口中。
- en: Note
  id: totrans-846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Canvas acts as a drawing interface that provides us with primitives.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas充当一个绘图接口，为我们提供基本绘图元素。
- en: 'To draw the sprite, we use the `drawBitmap` method from the `Canvas` class.
    This method receives a transformation matrix as a parameter. Let''s see what we
    can do with the `Matrix`:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制精灵，我们使用`Canvas`类的`drawBitmap`方法。此方法接收一个变换矩阵作为参数。让我们看看我们可以用`Matrix`做什么：
- en: '`reset`: We reset the transformation matrix from the values of the previous
    run. This is required to reuse the `Matrix` object from the previous run.'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`：我们将变换矩阵重置为上次运行的值。这是为了重用上次运行的`Matrix`对象。'
- en: '`postScale`: We add a scale transformation at the end of the transformation
    list. The scale is the same as the `mPixelFactor`.'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postScale`：我们在变换列表的末尾添加一个缩放变换。缩放与`mPixelFactor`相同。'
- en: '`postTranslate`: This adds a translation transformation at the end of the transformation
    list. This means that this transformation will be performed after the scale. We
    translate the item to the location (`mPositionX`, `mPositionY`).'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postTranslate`: 这将在变换列表的末尾添加一个翻译变换。这意味着这个变换将在缩放之后执行。我们将项目翻译到位置（`mPositionX`，`mPositionY`）。'
- en: For now, this is all we will do with the transformation matrix. Later in the
    chapter, we will add rotation.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就是我们将对变换矩阵所做的一切。在章节的后面，我们将添加旋转。
- en: Note
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of actions in a transformation matrix is very important. The results
    are impacted by the order of the transformations.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 变换矩阵中动作的顺序非常重要。结果会受到变换顺序的影响。
- en: The transformation matrix is a very powerful tool to transform bitmaps. The
    key point while creating the matrix is to keep in mind that the order is very
    important. It does not matter when we only use translation and scale. But with
    rotation, the results are impacted by the order of the transformations.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 变换矩阵是转换位图的一个非常强大的工具。在创建矩阵时，关键是要记住顺序非常重要。当我们只使用平移和缩放时，顺序并不重要。但是，当使用旋转时，结果会受到变换顺序的影响。
- en: Updating the spaceship and bullets
  id: totrans-856
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新飞船和子弹
- en: Now that we have a `Sprite` base class, we have to update the existing `Player`
    and `Bullet` classes to extend from it.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `Sprite` 基类，我们必须更新现有的 `Player` 和 `Bullet` 类，以便从它扩展。
- en: Most of the member variables from the `Player` object are now a part of the
    `Sprite`. We can also remove the old implementation of `onDraw` and rely on the
    one from the `Sprite`.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 对象的大部分成员变量现在都是 `Sprite` 的一部分。我们也可以移除旧的 `onDraw` 实现，并依赖于 `Sprite` 中的实现。'
- en: 'Finally, we have new simpler constructors that just receive the `GameEngine`.
    The one for the `Player` class is:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有新的更简单的构造函数，它们只接收 `GameEngine`。`Player` 类的构造函数如下：
- en: '[PRE93]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The one for the `Bullet` object is:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet` 对象的构造函数如下：'
- en: '[PRE94]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: All in all, we have pushed a lot of code to the `Sprite` class, which will make
    the inclusion of new game elements easier.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们已经将大量代码推送到 `Sprite` 类，这将使新游戏元素的添加更加容易。
- en: Before this, let's also add a frame-per-second counter to the `GameView` and
    see how it is performing to be able to compare `StandardGameView` and `SurfaceGameView`.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们还要在 `GameView` 中添加每秒帧数计数器，以便能够比较 `StandardGameView` 和 `SurfaceGameView`
    的性能。
- en: Adding a frames-per-second (fps) counter
  id: totrans-865
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加每秒帧数（fps）计数器
- en: We have updated the `DrawThread` to run at an arbitrary number of frames per
    second, adapting to the time required to render instead of a fixed 30 fps, and
    we are using sprites. Now is the perfect time to add a frames-per-second counter.
    It is a very easy tool and is also handy to check performance.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了 `DrawThread` 以在任意帧数每秒运行，适应渲染所需的时间，而不是固定的 30 fps，并且我们正在使用精灵。现在是添加每秒帧数计数器的完美时机。这是一个非常简单的工具，并且也便于检查性能。
- en: 'We could have used a `TextView`, but there are some good reasons to draw it
    on the `Canvas` directly instead:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用 `TextView`，但有一些很好的理由直接在 `Canvas` 上绘制它：
- en: The performance of `SurfaceView` suffers when we overlay other views on top
    of it
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在 `SurfaceView` 上叠加其他视图时，其性能会受到影响
- en: It is an interesting example of other methods of drawing on the `Canvas`
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是在 `Canvas` 上绘制其他方法的有趣示例
- en: We can remove and add it without touching the layout
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加和移除它，而不需要触及布局
- en: 'We will make a class named `FPSCounter` that extends from `GameObject` and
    looks like this:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `FPSCounter` 的类，它从 `GameObject` 扩展，如下所示：
- en: '[PRE95]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The logic is quite simple; we count the number of calls to `onDraw` and during
    `onUpdate`. Whenever we have been running for more than 1000 milliseconds, we
    do the calculation, store the result, and reset both variables.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑相当简单；我们计算 `onDraw` 和 `onUpdate` 的调用次数。每当运行时间超过 1000 毫秒时，我们进行计算，存储结果，并重置这两个变量。
- en: The `onDraw` method draws a black square and then renders the text on it centered.
    We set the size of the square to 50 by 25 units and the text size to half the
    height of the square, so there is a margin. For this, we also need to use a `Paint`
    object.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw` 方法绘制一个黑色正方形，然后在其中居中渲染文本。我们将正方形的大小设置为 50x25 单位，文本大小为正方形高度的一半，因此留有边距。为此，我们还需要使用一个
    `Paint` 对象。'
- en: The `Paint` class has methods to set colors, alignments, stroke width and type,
    and so on. Since we are mostly drawing bitmaps, we won't go into more detail on
    this.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`Paint` 类有设置颜色、对齐方式、笔触宽度和类型等方法。由于我们主要绘制位图，我们不会对此进行更详细的说明。'
- en: Note that the `Paint` object is created once and reused, as we did with the
    `Matrix` on the `Sprite`, with (yet again) the premise that we should not do any
    object allocations inside `onDraw`.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Paint` 对象是创建一次并重复使用的，就像我们在 `Sprite` 上的 `Matrix` 一样，前提是我们不应该在 `onDraw` 中进行任何对象分配。
- en: Spawning enemies – the GameController
  id: totrans-877
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成敌人 – `GameController`
- en: 'Now we are ready to spawn some enemies. For this, we are going to introduce
    a new concept: the `GameController`.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备生成一些敌人。为此，我们将引入一个新概念：`GameController`。
- en: A `GameController` is a special type of `GameObject` that has no visual representation
    (it is not a sprite) and its mission is to control the evolution of the game using
    the calls to `onUpdate`.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameController`是一种没有视觉表示（它不是一个精灵）的特殊类型的`GameObject`，其任务是使用`onUpdate`调用控制游戏的演变。'
- en: One of the most typical tasks of a `GameController` is managing the environment.
    This includes spawning enemies with the right parameters when necessary.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameController`最典型的任务之一是管理环境。这包括在必要时使用正确的参数生成敌人。'
- en: 'Game controllers fall into two main groups:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器分为两大类：
- en: Procedural/random
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序/随机
- en: Deterministic/static
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性/静态
- en: Procedural/random
  id: totrans-884
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序/随机
- en: This is a type of `GameController` that generates levels or enemies based on
    a set of parameters (or a function) that include some sort of random input.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基于一组参数（或函数）生成级别或敌人的`GameController`，这些参数（或函数）包含某种随机输入。
- en: The main advantage of procedural generation is that you do not have to create
    all the levels in detail, you just provide the parameters and an algorithm. It
    is complicated to tune it properly, but, once it is right, it potentially presents
    you with a different setup each time you play it. This improves replayability.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成的最大优点是，你不必详细创建所有级别，你只需提供参数和算法即可。正确调整它可能很复杂，但一旦调整正确，它可能会在每次玩游戏时提供不同的设置。这提高了可玩性。
- en: Some games that use procedural game controllers are Chalk Ball (survival mode),
    Fruit Ninja, and Eufloria. The most classic example of procedural-level generation
    are Rogue-like games, where each level of the dungeon is generated when you enter
    it.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用程序游戏控制器的是Chalk Ball（生存模式）、水果忍者、Eufloria。程序级别生成的最经典例子是类似Rogue的游戏，其中地牢的每一层在你进入时都会生成。
- en: '![Procedural/random](img/B04757_03_02.jpg)'
  id: totrans-888
  prefs: []
  type: TYPE_IMG
  zh: '![程序/随机](img/B04757_03_02.jpg)'
- en: Nethack, one of the first games to use procedural-level generation.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: Nethack，是第一个使用程序级别生成的游戏之一。
- en: Deterministic/static
  id: totrans-890
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性/静态
- en: Deterministic-level generation is used when the levels are fixed and they are
    always the same.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性级别的生成用于当级别固定且始终相同的情况下。
- en: This implies a lot of attention to detail, which allows for fine-tuning difficulty
    in the levels. Obviously, it also takes a lot of time.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着需要关注很多细节，这允许在级别中微调难度。显然，这也需要花费很多时间。
- en: 'Most game puzzles and tower defense games are examples of this: Angry Birds,
    Cut the Rope, Anomaly, SpaceCat, among many others.'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏谜题和塔防游戏都是这种类型的例子：愤怒的小鸟、剪绳子、异形、太空猫，等等。
- en: As a rule of thumb, while using a deterministic `GameController` you want to
    have the definition of the levels stored in some files that can be modified without
    touching the code. This allows you to tune a level or add new sets of levels independently
    of the code. You can even create an external editor to manage the levels.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，当使用确定性`GameController`时，你希望将级别的定义存储在可以修改而不需要触及代码的文件中。这允许你独立于代码调整级别或添加新的级别集合。你甚至可以创建一个外部编辑器来管理级别。
- en: The format of these files is completely up to you. I, personally, recommend
    the use of a structured language such as XML or JSON.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件格式完全取决于你。我个人推荐使用结构化语言，如XML或JSON。
- en: '![Deterministic/static](img/B04757_03_03.jpg)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![确定性/静态](img/B04757_03_03.jpg)'
- en: A level of SpaceCat as seen in the level editor
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: SpaceCat级别编辑器中看到的级别
- en: Hybrid approach
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合方法
- en: Game-level design is not black or white. There are many ways to define a `GameController`
    that is somewhere in between a procedural and a deterministic controller.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏级别设计不是非黑即白。有许多方法可以定义一个位于程序和确定性控制器之间的`GameController`。
- en: For example, Candy Crush Saga has a hybrid-level generation when the layout
    of the level is settled, but the candies that drop are different each time you
    play.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，糖果传奇在级别布局确定时采用混合级别生成，但每次玩游戏时掉落的糖果都不同。
- en: This gets the best of both worlds. It allows you to fine-tune the design of
    a level while it is still different each time you play it. It also takes a lot
    of time, because you have to tune both the static design and the algorithm.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 这兼顾了两者的优点。它允许你在每次玩游戏时都能调整级别的设计，同时保持其每次的不同。这也需要花费很多时间，因为你必须调整静态设计和算法。
- en: Our approach
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的方案
- en: It does not make sense to have a deterministic `GameController` for YASS, so
    we will go for the procedural generation.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 对于YASS来说，拥有一个确定性的`GameController`没有意义，因此我们将采用程序生成。
- en: We are going to make asteroids fall from the top of the screen with an angle
    that varies in the range of [-30,30] degrees. We will restrict their position
    on the *x* axis to be in the 50 percent central area of the screen.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使小行星从屏幕顶部落下，角度在 [-30,30] 度的范围内变化。我们将限制它们在 *x* 轴上的位置在屏幕的 50 百分之中央区域。
- en: The speed is going to be constant and they will spawn at a given interval, also
    a constant.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 速度将是恒定的，并且它们将以给定的间隔生成，这也是一个常数。
- en: 'The code of the `GameController` for handling the generation of `Asteroids`
    is as follows:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 处理生成 `Asteroids` 的 `GameController` 代码如下：
- en: '[PRE96]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We count the time the game has been running, then we calculate the time for
    the next enemy to spawn. This is the number of enemies we already created multiplied
    by the time between enemies.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算游戏运行的时间，然后计算下一个敌人生成的计时。这是已经创建的敌人数量乘以敌人之间的时间。
- en: If the current time of the game is greater than the time when the next enemy
    has to appear, then we spawn one and add it to the `GameEngine`.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏当前时间大于下一个敌人必须出现的时间，那么我们就生成一个并添加到 `GameEngine` 中。
- en: To do so, we get an `Asteroid` from the pool of objects, just as we did with
    the bullets. We initialize it and add it to the `GameEngine`. Then, we add one
    to the number of enemies spawned.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们从对象池中获取一个 `Asteroid`，就像我们处理子弹一样。我们初始化它并将其添加到 `GameEngine` 中。然后，我们将生成的敌人数量加一。
- en: The code spawns a new enemy, separating them by the number of milliseconds stated
    by `TIME_BETWEEN_ENEMIES`. We have set this at 500 milliseconds.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过 `TIME_BETWEEN_ENEMIES` 指定的毫秒数来分隔生成新的敌人。我们将其设置为 500 毫秒。
- en: The object pool we are using for the asteroids is essentially the same as the
    one for the bullets. I won't bore you with the same details again.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于小行星的对象池与用于子弹的几乎相同。我不会再次重复相同的细节。
- en: 'The rest of the procedural generation is inside the `init` method of the `Asteroid`,
    which looks like this:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的生成过程都在 `Asteroid` 的 `init` 方法中，如下所示：
- en: '[PRE97]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `cos` and `sin` methods require the parameter to be radians, so we use `Random.getDouble`
    to get a double between [0,1], multiply it by PI/3, and then subtract PI/6\. With
    this, we get a random value between [-PI/6,PI/6].
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '`cos` 和 `sin` 方法需要将参数转换为弧度，所以我们使用 `Random.getDouble` 获取一个在 [0,1] 范围内的双精度值，将其乘以
    PI/3，然后减去 PI/6。这样，我们得到一个在 [-PI/6,PI/6] 范围内的随机值。'
- en: We use a random angle to get the components of speed on `X` and `Y` using `sin`
    and `cos`.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用随机角度来获取 `X` 和 `Y` 上的速度分量，使用 `sin` 和 `cos`。
- en: For the starting position we use the same technique. We get a random integer
    in the range [0,width/2] and then we add width/4, so the final value is in the
    range [width/4,width*3/4].
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 对于起始位置，我们使用相同的技术。我们获取一个在 [0,width/2] 范围内的随机整数，然后加上 width/4，所以最终值在 [width/4,width*3/4]
    范围内。
- en: '![Our approach](img/B04757_03_04.jpg)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![我们的方法](img/B04757_03_04.jpg)'
- en: The asteroids
  id: totrans-919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于小行星
- en: Finally, we need our `Asteroid` class, which is going to be a `Sprite`. As we
    did for the other graphics, we downloaded our art from the OpenGameArt website.
    This time we get a few asteroids with different shapes and colors.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要我们的 `Asteroid` 类，它将是一个 `Sprite`。就像我们处理其他图形一样，我们从 OpenGameArt 网站下载了我们的艺术作品。这次我们得到了几个形状和颜色不同的小行星。
- en: The asteroid's implementation is reminiscent of the one for the bullets, except
    that this time the object is removed from the `GameEngine` when it gets out of
    the screen from the bottom and it has speed components on both axes.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星的实现与子弹的实现相似，但这次对象在从底部离开屏幕时从 `GameEngine` 中移除，并且它在两个轴上都有速度分量。
- en: 'The code for the `Asteroid` is as follows:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asteroid` 的代码如下：'
- en: '[PRE98]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Thanks to the `Sprite` base class, this implementation is very easy. We just
    need to set the speed in the construction and then update the position on both
    axes using the speed and `elapsedMillis`.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `Sprite` 基类，这种实现非常简单。我们只需要在构造函数中设置速度，然后使用速度和 `elapsedMillis` 更新两个轴上的位置。
- en: Lastly, we check whether the object is out of bounds and, if so, we remove it
    from the engine and return it to the pool.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查对象是否超出边界，如果是，则将其从引擎中移除并返回到池中。
- en: We can now compile and run and can see asteroids coming towards our spaceship.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编译并运行，可以看到小行星正朝我们的宇宙飞船飞来。
- en: '![The asteroids](img/B04757_03_05.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![小行星](img/B04757_03_05.jpg)'
- en: More on the transformation matrix
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于变换矩阵的内容
- en: 'You may have noticed that the asteroids looked quite static. This is because
    the image is always the same. We can improve this with a nice simple trick: by
    adding rotation to them.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到小行星看起来相当静止。这是因为图像始终如一。我们可以通过一个简单巧妙的方法来改进这一点：给它们添加旋转。
- en: 'The first thing we need to do is to update the `Sprite` class to make it handle
    rotation as a part of the configuration of the transformation matrix:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是更新`Sprite`类，使其能够处理旋转作为变换矩阵配置的一部分：
- en: '[PRE99]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The order of the transformations is extremely important. The transformations
    are applied in order and a rotation does transform the reference axes. So, if
    we rotate 45 degrees and then translate 40 units to the right, since the initial
    rotation changes the reference for the coordinates, the end position will be down
    and left. On the other hand, if we first translate and then rotate, the coordinate
    system only gets affected at the end.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 变换的顺序非常重要。变换是按顺序应用的，旋转确实会变换参考轴。因此，如果我们先旋转45度，然后向右平移40个单位，由于初始旋转改变了坐标的参考，最终位置将会向下和向左。另一方面，如果我们先平移再旋转，坐标系只有在最后才会受到影响。
- en: '![More on the transformation matrix](img/B04757_03_06.jpg)'
  id: totrans-933
  prefs: []
  type: TYPE_IMG
  zh: '![关于变换矩阵的更多内容](img/B04757_03_06.jpg)'
- en: This can be counter-intuitive at first, but it is a very powerful tool to describe
    nonlinear movements. We will see more about transformations in [Chapter 8](ch28.html
    "Chapter 8. The Animation Framework"), *The Animation Framework*.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能不太直观，但它是一个非常强大的工具来描述非线性运动。我们将在[第8章](ch28.html "第8章。动画框架")*动画框架*中看到更多关于变换的内容。
- en: For the sprites, we first do a translation and then a rotation, using the center
    of the sprite at the final position as the pivot for it.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 对于精灵，我们首先进行平移，然后旋转，以精灵在最终位置的中心作为旋转的支点。
- en: Note
  id: totrans-936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A rotation also affects the reference coordinate system of the object.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转也会影响对象的参考坐标系。
- en: Once the `Sprite` knows how to handle rotation, we just need to initialize the
    rotation of the asteroid to a value that makes sense and is different for each
    asteroid.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Sprite`知道如何处理旋转，我们只需要将小行星的旋转初始化为一个有意义的值，并且对于每个小行星都是不同的。
- en: 'First, we initialize the rotation to a random angle, so each asteroid has a
    different value. We add this line to the `init` method of the `Asteroid`:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将旋转初始化为一个随机角度，因此每个小行星都有一个不同的值。我们将此行添加到`Asteroid`的`init`方法中：
- en: '[PRE100]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then we set the rotation speed proportional to the angle of the linear speed,
    so each asteroid has a rotation speed based on the inclination of the trajectory.
    This also goes inside the `init` method:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将旋转速度与线性速度的角度成比例，因此每个小行星都有一个基于轨迹倾角的旋转速度。这也包含在`init`方法中：
- en: '[PRE101]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We make the asteroid perform a rotation equivalent to the inclination angle
    for times each second.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让小行星每秒进行一次与倾角相等的旋转。
- en: 'Once the values have been initialized, we need to update them during the `onUpdate`
    call. We will add the following code to `onUpdate`:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了值，我们还需要在`onUpdate`调用期间更新它们。我们将向`onUpdate`添加以下代码：
- en: '[PRE102]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We update the rotation and ensure that it is under the values that are valid
    [0-360].
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新旋转并确保它处于有效值范围内[0-360]。
- en: Note
  id: totrans-947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The rotation of a transformation matrix is provided in degrees.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 变换矩阵的旋转是以度数提供的。
- en: Note that the transformation matrix uses the angles in degrees and not in radians,
    while the mathematical operators we used for the speed expect it in radians. Always
    double-check in which units the angles are expected.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变换矩阵使用的是角度的度数而不是弧度，而我们使用的数学运算符期望的是弧度。始终要检查角度期望的单位。
- en: If you run the game now, you will notice how such a simple tweak makes it look
    much nicer.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会注意到这样一个简单的调整如何让游戏看起来更加美观。
- en: Occlusion culling
  id: totrans-951
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 次要遮挡剔除
- en: Occlusion culling is a technique that is broadly used in games, especially 3D
    ones. Since drawing is very expensive and has to be done many times, every optimization
    counts. The obvious optimization is to not draw the parts that are not going to
    be seen (for example hidden by something else). If we can draw each pixel on the
    screen only once, we are saving a lot of processing time.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 次要遮挡剔除是一种在游戏中广泛使用的技术，尤其是在3D游戏中。由于绘制非常昂贵并且需要多次进行，因此每个优化都很重要。明显的优化是不绘制那些不会看到的部分（例如被其他东西遮挡）。如果我们只能将屏幕上的每个像素绘制一次，我们就能节省大量的处理时间。
- en: The fact of drawing each pixel more than once is called overdraw. Having a high
    overdraw is one of the factors that impact performance the most.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制每个像素多次的事实被称为过度绘制。过度绘制高是影响性能的最主要因素之一。
- en: In the case of 3D, drawing is especially expensive, and occlusion culling is
    something that most engines do automatically to a certain extent.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D的情况下，绘制尤其昂贵，暗影剔除是大多数引擎在某种程度上自动执行的功能。
- en: Note
  id: totrans-955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Occlusion culling optimizes the drawing time by not drawing what is not shown.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 暗影剔除通过不绘制未显示的内容来优化绘制时间。
- en: In our case, we may be drawing some pixels twice, but since we are only doing
    2D, the cost of drawing is not that high and it is something we don't need to
    do.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可能会绘制一些像素两次，但由于我们只做2D，绘制的成本并不高，而且这不是我们必须做的。
- en: 'There is one special case, however: drawing sprites that are outside the `GameView`.'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个特殊情况：绘制位于`GameView`之外的精灵。
- en: Until now, we have been spawning the sprites as we needed them and removing
    them once they are out of the `GameView`. We could instead put them into place
    in the initialization of the level and just rely on the calls to `onUpdate` to
    make them appear on the screen. This is quite common for elements that are a part
    of the scenery or static enemies. In the case of a rogue-like game, we would be
    generating each dungeon level in the beginning and then spawning all the sprites
    and putting them into place.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是根据需要生成精灵，一旦它们离开`GameView`就删除它们。我们可以在关卡初始化时将它们放置到位，并仅依靠对`onUpdate`的调用使它们出现在屏幕上。这对于场景或静态敌人等元素来说是很常见的。在类似Rogue的游戏中，我们会在开始时生成每个地牢关卡，然后生成所有精灵并将它们放置到位。
- en: 'Obviously, drawing things that are out of the player''s view is a waste. So,
    we will make sure that the `Sprite` class performs this simple occlusion culling-like
    optimization:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，绘制玩家视野之外的物体是浪费。因此，我们将确保`Sprite`类执行这种类似于暗影剔除的简单优化：
- en: '[PRE103]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We just have to check if the positions on the *x* and *y* axes and see if the
    sprite is inside the drawing area. Remember that we use the points at the top-left
    corner of the image. This is why we have to check against the width and height
    in negative.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要检查*x*和*y*轴上的位置，看看精灵是否在绘制区域内。记住，我们使用图像的左上角点。这就是为什么我们必须检查负宽度和高度。
- en: This will not make any difference in our game, but it may be crucial for other
    types of games, especially those with static content.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的游戏中不会有任何区别，但它可能对其他类型的游戏至关重要，尤其是那些具有静态内容的游戏。
- en: Parallax backgrounds
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直背景
- en: Another typical feature of 2D games that is deeply related to the `DrawThread`
    is parallax backgrounds.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏中的另一个典型特征，与`DrawThread`密切相关的是垂直背景。
- en: The idea of a parallax background is to have an image that moves slower than
    the elements in the foreground, giving the impression of depth.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直背景的想法是有一个比前景元素移动速度慢的图像，从而产生深度感。
- en: Note
  id: totrans-967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Parallax backgrounds are used to create an illusion of depth in 2D games.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直背景用于在2D游戏中创建深度错觉。
- en: To make this effect better, we can use multiple background images at different
    speeds. This is commonly used in 2D scrollers. For example with trees in the near
    plane and mountains and clouds at the very back.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种效果更好，我们可以使用不同速度的多个背景图像。这在2D滚动游戏中很常见。例如，近处的树木和远处的山脉和云彩。
- en: For YASS, we will use a star field that moves down slowly as a background.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 对于YASS，我们将使用一个缓慢向下移动的星场作为背景。
- en: We are going to use the same convention of units as we used for the sprites.
    The image we use for the background should be designed to be tiled, vertically
    in our case. This means that the end of the image fits with its beginning, so
    they are placed one after another and have continuity.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与精灵相同的单位约定。我们用于背景的图像应该设计成可以平铺的，在我们的情况下是垂直平铺。这意味着图像的末端与起始部分相匹配，因此它们一个接一个地放置并保持连续性。
- en: It should also be designed in a way that it is larger than the biggest screen.
    We can consider the tallest screens the ones with an 16:9 aspect ratio. So for
    a height of 400 pixels, this image should be at least 720 pixels wide (400 * 16
    / 9 = 711.11).
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 它还应该设计得比最大的屏幕大。我们可以考虑最高屏幕是那些具有16:9宽高比的屏幕。因此，对于400像素的高度，这张图片至少应该是720像素宽（400 *
    16 / 9 = 711.11）。
- en: A background is quite different from a sprite, mainly because of the size of
    the image and the fact that we may need to draw two of them to cover the screen
    is some cases.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 背景与精灵相当不同，主要是因为图像的大小以及在某些情况下我们可能需要绘制两个图像来覆盖屏幕。
- en: 'We will create a new `ParallaxBackground` class for this:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为此创建一个新的`ParallaxBackground`类：
- en: '[PRE104]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The constructor is similar to the one `Sprite`. We load a bitmap, calculate
    the speed, and store the height and width of both the screen and image at its
    display size.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与`Sprite`类似。我们加载位图，计算速度，并存储屏幕和图像在显示大小下的宽度和高度。
- en: 'We have a new concept: the target width. This is used for optimization in case
    the image is larger than the screen, so we do not draw what is not going to be
    seen.'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的概念：目标宽度。当图像大于屏幕时，我们使用它进行优化，这样我们就不绘制那些将不会被看到的内容。
- en: 'To begin with, we will do a simple implementation using the same transformation
    matrix concept that we used on the sprites:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用与精灵上使用的相同变换矩阵概念进行简单的实现：
- en: '[PRE105]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We are drawing the image at the *y* coordinate. When this coordinate is greater
    than 0, there will be space on the top of the view that needs to be filled with
    another image. This is what the first part of the code does; it draws the image
    one more time, but translates all the height of the image, so they tile.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`y`坐标处绘制图像。当这个坐标大于0时，视图顶部将会有空间需要用另一个图像填充。这就是代码的第一部分所做的工作；它再次绘制图像，但将整个图像的高度进行平移，以便它们可以拼接。
- en: In any case, we have to draw the background at `mPositionY`, which is what the
    second block does. Note that, when the position is smaller than 0, we only need
    to draw one image. The logic of the class ensures that the value of `Y` is never
    smaller than `mImageHeight` – `mScreenHeight`.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们都必须在`mPositionY`处绘制背景，这正是第二个块所做的。注意，当位置小于0时，我们只需要绘制一个图像。类的逻辑确保`Y`的值永远不会小于`mImageHeight`减去`mScreenHeight`。
- en: Once the `Y` position gets out of the screen, the second part of the drawing
    is no longer needed, so we subtract the image's height. With this, the image keeps
    the same position and scrolls smoothly, because the second part of the draw is
    now equivalent to the first one, which is not entered.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Y`位置超出屏幕，绘制过程的第二部分就不再需要，所以我们减去图像的高度。这样，图像保持相同的位置并平滑滚动，因为绘制过程的第二部分现在等同于第一部分，后者没有进入。
- en: '![Parallax backgrounds](img/B04757_03_07.jpg)'
  id: totrans-983
  prefs: []
  type: TYPE_IMG
  zh: '![Parallax backgrounds](img/B04757_03_07.jpg)'
- en: The different states of the background drawable.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 背景可绘制状态的不同。
- en: While this code works, it is quite inefficient, because it does a lot of drawing
    that is not visible.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可以工作，但它相当低效，因为它做了很多不可见的绘制。
- en: We can implement the drawing on `ParallaxBackground` using another variant of
    `drawBitmap` that receives the rectangle of the image we want to draw and the
    rectangle on the screen when it should be drawn.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`drawBitmap`的另一个变体在`ParallaxBackground`上实现绘制，该变体接收我们要绘制的图像的矩形以及屏幕上绘制时应显示的矩形。
- en: 'The math for this case looks a bit complicated. Let''s first look at the code:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例的数学计算看起来有些复杂。让我们先看看代码：
- en: '[PRE106]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The handling is conceptually the same as for the previous algorithm, but now
    you have to keep in mind that the source rectangle has the original scale of the
    image, while the destination rectangle has the scale of the `GameView`. Other
    than this, the cases and how they work are the same.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 处理方式在概念上与之前的算法相同，但现在你必须记住，源矩形具有图像的原始比例，而目标矩形具有`GameView`的比例。除此之外，情况和它们的工作方式都是相同的。
- en: While this drawing is more efficient under the draw-what-is-needed criteria,
    it is not so efficient in some cases.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种绘制在“只绘制所需内容”的标准下更高效，但在某些情况下并不高效。
- en: When we use `drawBitmap` with two rectangles, a new bitmap is created and used.
    This bitmap is then discarded and another one is created for the next call to
    `onDraw`. With the other implementation, the bitmaps are not touched, so they
    can remain loaded in the memory, saving some processing time.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用两个矩形`drawBitmap`时，会创建一个新的位图并使用它。然后丢弃这个位图，并为下一次调用`onDraw`创建另一个位图。在另一种实现中，位图不会被修改，因此它们可以保留在内存中，从而节省一些处理时间。
- en: All in all, the performance depends on the size of the bitmaps, if you are using
    a `SurfaceView` or a normal `View`, and how good is the hardware of the device.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，性能取决于位图的大小，如果你使用`SurfaceView`或普通`View`，以及设备的硬件性能如何。
- en: Note
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Though efficient, this way of drawing may not be faster. Bitmap manipulation
    and allocating memory are also time-consuming.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法效率高，但绘制方式可能并不更快。位图操作和内存分配也是耗时的工作。
- en: To add a background to the `GameEngine`, we have to remember that the drawing
    order in the `GameView` is the order in which the `GameObjects` were added to
    the `GameEngine`, so we must ensure that we add the background in the beginning,
    before the rest of the game objects.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`GameEngine`添加背景，我们必须记住`GameView`中的绘制顺序是`GameObjects`被添加到`GameEngine`中的顺序，因此我们必须确保我们在其他游戏对象之前将背景添加到开始处。
- en: 'The initialization of `GameEngine` inside `GameFragment` should look like this
    now:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameFragment`内部的`GameEngine`初始化现在应该如下所示：'
- en: '[PRE107]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Our game is starting to look really good.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏开始看起来真的很棒。
- en: '![Parallax backgrounds](img/B04757_03_08.jpg)'
  id: totrans-999
  prefs: []
  type: TYPE_IMG
  zh: '![视差背景](img/B04757_03_08.jpg)'
- en: Multiple backgrounds
  id: totrans-1000
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重背景
- en: It is fairly easy to add another `ParallaxBackground` to the game with an additional
    set of stars at a different speed, so the two of them together give a better feeling
    of depth. This is as simple as adding another `ParallaxBackground` object with
    a different speed and a drawable that has transparency.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中添加另一个具有不同速度的`ParallaxBackground`以及一组额外的星星相当简单，这样两者结合就能更好地体现深度感。这就像添加一个具有不同速度和具有透明度的可绘制`ParallaxBackground`对象一样简单。
- en: If we do it, we are going to see a dramatic decrease in performance.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们将看到性能的显著下降。
- en: This performance problem is caused by the number of pixel overdraws. With the
    second background, every point on the screen gets drawn at least twice (once for
    each background), and some of them thrice, when there is a sprite involved. Transparent
    pixels do count as overdraw.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这种性能问题是由于像素过度绘制数量造成的。使用第二个背景时，屏幕上的每个点至少被绘制两次（每个背景一次），当涉及精灵时，有些点甚至被绘制三次。透明像素也计入过度绘制。
- en: Note
  id: totrans-1004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using two overlapping parallax backgrounds forces each pixel to be drawn at
    least twice per frame.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个重叠的视差背景迫使每个像素在每一帧至少绘制两次。
- en: All in all, there are many parameters involved in the performance. In most cases,
    `SurfaceGameView`, together with efficient background drawing, will give the best
    results. But as soon as we overlay another `View` on top of `GameView`, the performance
    plummets. `StandardGameView` performance decays slower in this case.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，性能涉及许多参数。在大多数情况下，`SurfaceGameView`以及高效的背景绘制将给出最佳结果。但是，一旦我们在`GameView`上叠加另一个`View`，性能就会急剧下降。在这种情况下，`StandardGameView`的性能下降较慢。
- en: There is not much of a difference in performance between the two implementations
    of `GameView` or background rendering methods when we use only one background.
    But again, it depends on the size of the bitmap used for the background. I recommend
    you to experiment and see the differences yourself.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只使用一个背景时，`GameView`的两个实现或背景渲染方法在性能上没有太大差异。但同样，这取决于用于背景的位图的大小。我建议你亲自实验并查看差异。
- en: While the effect of two parallax backgrounds is nice and our `GameView` can
    handle it with a decent refresh rate, we are going to use only one background
    in YASS. With this amount of overdraw, we are getting into the performance limit
    of what can be done with the standard Android SDK without using OpenGL.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个视差背景的效果很好，并且我们的`GameView`可以以合理的刷新率处理它，但我们将在YASS中只使用一个背景。在这种情况下，我们会有这么多的过度绘制，我们将达到使用标准Android
    SDK（不使用OpenGL）所能做到的性能极限。
- en: If you want more complex backgrounds, you may want to move into using an OpenGL
    engine such as AndEngine, which uses the same concepts we have been using here.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更复杂的背景，你可能需要转向使用OpenGL引擎，如AndEngine，它使用与我们这里相同的概念。
- en: Layers
  id: totrans-1010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层
- en: Until now, the drawing sequence for the GameObjects is the order in which they
    are added to the GameEngine. This is inconvenient to say the least. We should
    improve it.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`GameObject`的绘制顺序是它们被添加到`GameEngine`中的顺序。这至少是不方便的。我们应该改进它。
- en: As most other drawing systems do, our engine should use layers.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 如同大多数其他绘图系统一样，我们的引擎应该使用层。
- en: Whenever we add a `GameObject` to the `GameEngine`, we will pass an integer
    to indicate the layer we want it to be added to. We will consider 0 to be the
    layer to add the background to. Think of layers as a z-index for the game objects.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向`GameEngine`添加一个`GameObject`时，我们将传递一个整数来指示我们希望将其添加到的层。我们将0视为添加背景的层。将层想象成游戏对象的z-index。
- en: 'We are going to use four layers. From the foreground to the background, we
    will display:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四个层。从前景到背景，我们将显示：
- en: 'The `Player` object: The spaceship'
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`对象：飞船'
- en: Asteroids
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小行星
- en: Bullets
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹
- en: The background
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景
- en: '![Layers](img/B04757_03_09.jpg)'
  id: totrans-1019
  prefs: []
  type: TYPE_IMG
  zh: '![层](img/B04757_03_09.jpg)'
- en: To add layer support, we need to modify the `GameEngine`, `StandardGameView`,
    and `SurfaceGameView` classes. For convenience, we will also update `GameObject`
    to know its layer.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加层支持，我们需要修改`GameEngine`、`StandardGameView`和`SurfaceGameView`类。为了方便，我们还将更新`GameObject`以了解其层。
- en: On the top level, we will handle the layers as a list of lists of game objects.
    This is the data structure that we will store in the `GameEngine` and pass to
    the implementations of `GameView`. We will keep the old `mGameObject` list as
    a simple way to iterate over all the `GameObjects`.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层，我们将处理层作为游戏对象列表的列表。这是我们将在`GameEngine`中存储并传递给`GameView`实现的数据结构。我们将保留旧的`mGameObject`列表作为遍历所有`GameObjects`的简单方式。
- en: 'We initialize the layers inside the constructor of `GameEngine`. We will add
    a parameter to the constructor showing the number of layers we expect to have,
    so they can be precreated:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`GameEngine`的构造函数中初始化层。我们将向构造函数添加一个参数，显示我们期望拥有的层数，以便它们可以预先创建：
- en: '[PRE108]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The major changes are inside `onUpdate`:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 主要更改发生在`onUpdate`内部：
- en: '[PRE109]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The first part is the same as before. It iterates along all the `GameObjects`,
    calling `onUpdate`.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分与之前相同。它遍历所有的`GameObjects`，调用`onUpdate`。
- en: For the removal of objects, it is important that the `GameObject` knows its
    layer. Because of this, removing the object from the list of layers is just one
    more line of code.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象的移除，重要的是`GameObject`知道它的层。正因为如此，从层的列表中移除对象只是多一行代码。
- en: Knowing the layer is also important when it comes to adding the `GameObjects`,
    especially when such addition is delayed to the end of `onUpdate`.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`GameObjects`时，了解层也很重要，尤其是当这种添加被延迟到`onUpdate`的末尾时。
- en: 'There is one new method called `addToLayerNow`. It is used also when the objects
    are added before the game starts. We can see how it is used in the `addGameObject`
    method of the `GameEngine`:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新方法叫做`addToLayerNow`。当对象在游戏开始前被添加时也会使用它。我们可以在`GameEngine`的`addGameObject`方法中看到它是如何使用的：
- en: '[PRE110]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note that the first thing we do when we add a new `GameObject` is to set the
    layer it is to be added to.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们添加一个新的`GameObject`时，我们首先做的事情是设置它要添加到的层。
- en: 'The `addToLayerNow` method takes care of the situation when we want to add
    a `GameObject` to a layer we have not defined. This should not happen if we defined
    the correct number of layers to be precreated. But it is a good safety measure
    to have in place, especially when you are not sure how many layers you will use:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToLayerNow`方法处理当我们想要将一个`GameObject`添加到尚未定义的层的情况。如果我们正确定义了预创建的层数，这种情况不应该发生。但这是一个很好的安全措施，尤其是在你不确定将使用多少层时：'
- en: '[PRE111]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The fact that `GameObject` knows the layer it has to be added to allows us to
    add it to the right layer in a single line of code. Note that we also add the
    `GameObject` to the list of all game objects.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GameObject`知道它需要添加到的层，这使得我们可以在一行代码中将它添加到正确的层。请注意，我们还将`GameObject`添加到所有游戏对象的列表中。
- en: 'Finally, the code that draws the game objects into the canvas has to be changed
    in both implementations of `GameView`. This is the place where the order of the
    layers is used to provide the drawing order:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`GameView`的两个实现中，将游戏对象绘制到画布上的代码必须更改。这是使用层的顺序来提供绘制顺序的地方：
- en: '[PRE112]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note that, inside each layer, the order of drawing is still the order of addition.
    Since we can now isolate the same type of items to the same layer, this should
    not be something to worry about any longer.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每个层内部，绘制的顺序仍然是添加的顺序。由于我们现在可以将相同类型的项隔离到同一层，这不应该再是令人担忧的事情了。
- en: Also, note that the synchronization object is the same in the `GameViews` and
    in the `GameEngine`, now that synchronization is done using `mLayers`.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，由于同步现在使用`mLayers`，`GameViews`和`GameEngine`中的同步对象是相同的。
- en: Summary
  id: totrans-1039
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned how to draw at low level using a standard `View` and also a
    `SurfaceView`. We have created a `Sprite` class to reuse the code of the items
    that are displayed on the screen.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用标准的`View`和`SurfaceView`进行低级绘制，我们还创建了一个`Sprite`类来重用屏幕上显示的项的代码。
- en: The `DrawThread` has been updated to a more efficient one and we also added
    a frames-per-second counter to check the efficiency of each configuration.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawThread`已经被更新为一个更高效的版本，我们还添加了一个每秒帧数计数器来检查每个配置的效率。'
- en: Along the way, we learned about game controllers and the different ways to create
    levels. We also decided to spawn asteroids YASS using procedural generation, and
    put this into effect.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅途中，我们学习了游戏控制器和创建不同级别的不同方法。我们还决定使用程序生成来生成YASS彗星，并将其付诸实践。
- en: We also added support for parallax backgrounds and layers to the engine.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向引擎添加了对透视背景和层的支持。
- en: 'All in all, YASS is starting to look good, but we are clearly missing something:
    the bullets do nothing when they hit an asteroid and neither does our spaceship.'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，YASS开始看起来不错，但我们显然缺少一些东西：子弹击中彗星时没有任何动作，我们的太空船也是如此。
- en: It is time to implement collision detection.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现碰撞检测了。
- en: Chapter 4. Collision Detection
  id: totrans-1046
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 碰撞检测
- en: In most games we need to detect when objects intersect with each other to trigger
    actions; this is called collision detection. We will use it to detect when a bullet
    hits an asteroid (to destroy it) and when the player is hit by an asteroid (to
    end the game). This detection can be done in a discrete or in a continuous way,
    and it can involve different types of shapes. We will use discrete detection with
    rectangular and circular shapes.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏中，我们需要检测对象何时相互交叉以触发动作；这被称为碰撞检测。我们将使用它来检测子弹击中彗星（以摧毁它）以及玩家被彗星击中（以结束游戏）。这种检测可以是离散的或连续的，并且可以涉及不同类型的形状。我们将使用矩形和圆形形状的离散检测。
- en: As mentioned in [Chapter 1](ch21.html "Chapter 1. Setting Up the Project"),
    *Setting Up the Project*, we are not going to do any Physics simulation. That
    is a completely separate topic and it is long enough to deserve its own book.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第一章](ch21.html "第一章 设置项目")中所述，*设置项目*，我们不会进行任何物理模拟。这是一个完全独立的话题，它足够长，足以成为一本书的主题。
- en: We will also discuss optimization techniques and implement one method called
    spatial partitioning that splits the area into smaller ones based on object density.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论优化技术，并实现一种称为空间划分的方法，该方法根据对象密度将区域划分为更小的部分。
- en: As a side note, all the concepts in this chapter can be easily extrapolated
    to collisions in 3D.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，本章中的所有概念都可以很容易地推广到3D碰撞。
- en: Detecting collisions
  id: totrans-1051
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'There are two main approaches to checking collisions:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 检查碰撞有两种主要方法：
- en: Discrete, or a posteriori
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散的，或后验
- en: Continuous, or a priori
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续的，或先验
- en: For the discrete approach, we advance the state of the game items and then check
    if any of them are intersecting. It is a discrete simulation because we only do
    the evaluation at the end of each step. It is called a posteriori because it is
    done after the objects have moved. It is reactive. Most of the time we lack the
    exact point of contact; we only know that at the end of the simulation step the
    objects are colliding.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 对于离散方法，我们推进游戏项目的状态，然后检查其中是否有任何项目相交。因为它只在每个步骤的末尾进行评估，所以它是一个离散模拟。因为它是在对象移动之后进行的，所以它被称为后验。它是反应性的。大多数时候我们缺乏确切的接触点；我们只知道在模拟步骤结束时对象发生了碰撞。
- en: On the other hand, a continuous approach predicts the collision before applying
    the movement, based on the parameters of each object. It is calculated before
    the movement is performed. That's why it is called a priori. This method provides
    the exact point of contact and it is extremely useful when we require precision—such
    as for physics simulation.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，连续方法在应用运动之前预测碰撞，基于每个对象的参数。它在运动执行之前进行计算。这就是为什么它被称为先验。这种方法提供了确切的接触点，当我们需要精确度时——例如物理模拟——它非常有用。
- en: The discrete method is generally one dimension simpler than the continuous one.
    This makes it much easier to understand and implement. It trades speed for precision.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 离散方法通常比连续方法简单一个维度。这使得它更容易理解和实现。它以速度换取精度。
- en: Note
  id: totrans-1058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Discrete collision detection is faster but less precise.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 离散碰撞检测更快但精度较低。
- en: Since we are not going to use physics and we don't really care about the exact
    point of contact, we will use the discrete approach.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会使用物理引擎，并且我们并不真正关心确切的接触点，我们将使用离散方法。
- en: Who can collide?
  id: totrans-1061
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些对象可以发生碰撞？
- en: To be able to calculate `GameObject` collisions, we need to associate a shape
    (or body) to a `GameObject`. This association requires some information about
    the object on the screen, such as position on the *x* and *y* axes and also the
    width and height.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够计算`GameObject`的碰撞，我们需要将一个形状（或身体）与一个`GameObject`关联起来。这种关联需要一些关于屏幕上对象的信息，例如在*x*轴和*y*轴上的位置，以及宽度和高度。
- en: We are going to create a class named `ScreenGameObject` that extends from `GameObject`
    and will contain that information. In our game, `Sprite` is the only class that
    will extend from `ScreenGameObject`, but it may come in handy if you want to place
    non-visual items on the screen that trigger something when the player crosses
    them, which is a common technique in games.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `ScreenGameObject` 的类，它继承自 `GameObject` 并将包含相关信息。在我们的游戏中，`Sprite`
    是唯一一个将继承自 `ScreenGameObject` 的类，但如果你想在屏幕上放置非视觉项目，当玩家穿过它们时触发某些操作，这将是游戏中的常见技术。
- en: '![Who can collide?](img/B04757_04_01.jpg)'
  id: totrans-1064
  prefs: []
  type: TYPE_IMG
  zh: '![谁可以碰撞？](img/B04757_04_01.jpg)'
- en: GameObject classes hierarchy
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: GameObject 类层次结构
- en: To collide with other objects you need a position on the screen and a size.
    `ScreenGameObject` will provide that.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 要与其他对象发生碰撞，你需要屏幕上的位置和大小。`ScreenGameObject` 将提供这些信息。
- en: 'All the logic for calculation collisions will be placed inside the `ScreenGameObject`
    class. The stub of the class is like this:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 所有计算碰撞的逻辑都将放置在 `ScreenGameObject` 类内部。类的存根如下：
- en: '[PRE113]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We take this opportunity to refactor the variables `width`, `height`, `X`, and
    `Y` to have shorter, more generic names. We will continue working with this class
    throughout the chapter.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这个机会将变量 `width`、`height`、`X` 和 `Y` 重构为更短、更通用的名称。我们将继续在本章中工作与此类。
- en: The method `checkCollision` is where the action happens. That method will have
    a different implementation depending on the shapes we use to calculate the collisions.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkCollision` 方法是动作发生的地方。此方法将根据我们用于计算碰撞的形状具有不同的实现。'
- en: Finally, `onCollision` is used to trigger an action when a collision occurs.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onCollision` 用于在发生碰撞时触发一个动作。
- en: Updating GameEngine
  id: totrans-1072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 GameEngine
- en: To run discrete collision detection, we will use a method named `checkCollisions`
    during the execution of `onUpdate` on the `GameEngine`, so it will run every time
    the game objects are updated. We will place this method call after the update
    of the game objects and before the code that removes objects. Collisions are a
    typical reason why objects get removed.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行离散碰撞检测，我们将在 `GameEngine` 的 `onUpdate` 执行期间使用名为 `checkCollisions` 的方法，因此它将在游戏对象更新时运行。我们将在游戏对象更新之后和移除对象的代码之前放置这个方法调用。碰撞是对象被移除的典型原因。
- en: Since only `ScreenGameObjects` can have collisions, we will create a special
    list containing them.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有 `ScreenGameObjects` 可以有碰撞，我们将创建一个包含它们的特殊列表。
- en: '[PRE114]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: And we will keep it updated whenever an object is added to or removed from the
    `GameEngine`, as we did for the separate layers in the previous chapter.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们将在对象被添加到或从 `GameEngine` 中移除时保持其更新，就像我们在上一章中为单独的层所做的那样。
- en: The code to check for collisions and to notify the game objects involved is
    as follows.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 检查碰撞并通知涉及的游戏对象的代码如下。
- en: '[PRE115]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The code is as simple as a nested `for` loop that checks every `ScreenGameObject`
    against all the others. If a collision is detected, we will execute the method
    `onCollision` on both screen game objects involved in it, passing the object they
    have collided with as a parameter.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 代码就像一个嵌套的 `for` 循环，检查每个 `ScreenGameObject` 与其他所有对象的碰撞。如果检测到碰撞，我们将对涉及的两个屏幕游戏对象执行
    `onCollision` 方法，并将它们碰撞的对象作为参数传递。
- en: Keep in mind that this method has quadratic complexity, while all the other
    methods involved in `onUpdate` have linear complexity instead. Running collision
    detection is expensive.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此方法具有二次复杂度，而 `onUpdate` 中涉及的所有其他方法都具有线性复杂度。运行碰撞检测是昂贵的。
- en: Note
  id: totrans-1081
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Checking for collisions has quadratic complexity O(n²).
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 检查碰撞具有二次复杂度 O(n²)。
- en: Handling collisions
  id: totrans-1083
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: Regardless of the method we use to calculate the collisions, the actions we
    have to take for the player and the bullets are the same. Let's override the method
    `onCollision` for them.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用什么方法来计算碰撞，对于玩家和子弹，我们都要采取相同的行动。让我们为它们覆盖 `onCollision` 方法。
- en: In the case of the bullets, we have to check if the object it collides with
    is an asteroid and, if that's the case, we remove both objects from the `GameEngine`.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 在子弹的情况下，我们必须检查与之碰撞的对象是否是小行星，如果是，则从 `GameEngine` 中移除这两个对象。
- en: '[PRE116]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Note that we are calling a method `removeObject` on the objects themselves.
    This method takes care of removing the `GameObject` from the `GameEngine`, and
    also returning it to the object pool.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们是在对象本身上调用一个名为 `removeObject` 的方法。此方法负责将 `GameObject` 从 `GameEngine` 中移除，并将其返回到对象池。
- en: 'The code for the player is almost identical to the one for the bullet: we just
    remove both colliding objects in the case of an asteroid.'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的代码几乎与子弹的代码相同：在遇到小行星的情况下，我们只是移除两个碰撞对象。
- en: It is worth mentioning that because of the way we are spawning the bullets,
    they do collide with the `Player` object when added to the scene because we want
    it to look like they appear from the spaceship. We have to discard that collision.
    It is good practice to always check what the object is colliding against.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于我们生成子弹的方式，当它们被添加到场景中时，它们会与`Player`对象发生碰撞，因为我们想让它们看起来是从宇宙飞船中出现的。我们必须忽略这种碰撞。始终检查对象正在与什么发生碰撞是良好的实践。
- en: If we want to make a game with several lives, we should signal the `GameEngine`
    at that point to stop spawning waves, remove one life, spawn a new `Player` object,
    and then continue the game.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要制作一个有多个生命的游戏，我们应该在那个时刻向`GameEngine`发出信号以停止生成波次，移除一个生命，生成一个新的`Player`对象，然后继续游戏。
- en: Let's see how the collisions are actually calculated.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看碰撞实际上是如何计算的。
- en: Rectangular bodies
  id: totrans-1092
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形体
- en: The first way we are going to implement detection is through the intersection
    of rectangles, which is also the simplest method.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现检测的第一种方式是通过矩形的交集，这也是最简单的方法。
- en: We will use the bounding rectangle of the `ScreenGameObject` and check if it
    intersects with the bounding rectangle of the other `ScreenGameObject`.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ScreenGameObject`的边界矩形，并检查它是否与另一个`ScreenGameObject`的边界矩形相交。
- en: The bounding rectangle changes each time we update the position of the sprite
    and, since we may be required to check with many other objects, it is best if
    we recalculate it after `onUpdate`. We are going to make a new method called `onPostUpdate`
    and do that inside it.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们更新精灵的位置时，边界矩形都会改变，由于我们可能需要与其他许多对象进行检查，所以在`onUpdate`之后重新计算它最好。我们将创建一个新的方法`onPostUpdate`并在其中执行此操作。
- en: We have to add a new method to `ScreenGameObject`.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须向`ScreenGameObject`添加一个新的方法。
- en: '[PRE117]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: If you need to override `onPostUpdate` on other objects, remember to always
    call the super method, otherwise collisions will misbehave.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在其他对象上重写`onPostUpdate`，请记住始终调用超类方法，否则碰撞将表现异常。
- en: 'Then, when checking for collisions, we do a check for rectangular ones:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在检查碰撞时，我们进行矩形碰撞的检查：
- en: '[PRE118]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Finally, although calculating intersections of rectangles is a very easy operation,
    since the class `Rect` already provides us with a utility method to do it, we
    will use it.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管计算矩形的交集是一个非常简单的操作，因为`Rect`类已经为我们提供了一个执行此操作的工具方法，所以我们将使用它。
- en: '[PRE119]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Adding visual feedback
  id: totrans-1103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加视觉反馈
- en: 'Something that really helps when working with collisions is to get some visual
    feedback on what is happening. For that we are going to draw the bounding rectangle
    in yellow as a background for the sprites:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理碰撞时，真正有帮助的是获得一些关于正在发生什么的视觉反馈。为此，我们将以黄色为背景绘制边界矩形，作为精灵的背景：
- en: '[PRE120]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '![Adding visual feedback](img/B04757_04_02.jpg)'
  id: totrans-1106
  prefs: []
  type: TYPE_IMG
  zh: '![添加视觉反馈](img/B04757_04_02.jpg)'
- en: 'And it is time to try out our shiny collision detection method and see how
    it performs. Spoiler alert: not too good.'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试我们的闪亮的碰撞检测方法，看看它的表现如何。剧透：不太好。
- en: Pros and cons
  id: totrans-1108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优缺点
- en: 'This collision detection has some advantages:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种碰撞检测有一些优点：
- en: Easy to implement
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单
- en: Fast to evaluate
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估速度快
- en: 'But it also has some important flaws:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也有一些重要的缺陷：
- en: If the sprite has padding, the collision area is too big and unrealistic.
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果精灵有填充，碰撞区域太大，不真实。
- en: We are not rotating the rectangles when the Sprite rotates.
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当精灵旋转时，我们没有旋转矩形。
- en: Collisions are very strict. The system detects collisions where there are only
    transparent pixels. This is especially bad when the corners touch.
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测非常严格。系统检测到只有透明像素的地方发生碰撞。当角落接触时，这尤其糟糕。
- en: We can solve the first problem by clipping the sprites or by adding the possibility
    to set margins on the `ScreenGameObject`.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过裁剪精灵或为`ScreenGameObject`添加设置边距的可能性来解决第一个问题。
- en: The second problem can be solved with some simple math, but it complicates the
    code and the result isn't a better solution than a circular collision body. This
    is outside the scope of this book and is left as an exercise for the reader.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题可以通过一些简单的数学方法解决，但这会使代码复杂化，而且结果并不比圆形碰撞体更好。这超出了本书的范围，留给读者作为练习。
- en: '![Pros and cons](img/B04757_04_03.jpg)'
  id: totrans-1118
  prefs: []
  type: TYPE_IMG
  zh: '![优缺点](img/B04757_04_03.jpg)'
- en: Rectangular bodies require no padding on the images and can still create false
    positives
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形体在图像上不需要填充，但仍可能产生误报。
- en: Unfortunately, the last problem is something that is inherent to this approach
    and cannot be solved unless we use a bounding polygon or a combination of rectangles.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，最后一个问题是这种方法的固有缺陷，除非我们使用边界多边形或矩形的组合，否则无法解决。
- en: Circular bodies
  id: totrans-1121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆形身体
- en: 'The next type of body we can use to detect collisions is a circle. For that
    we are going to consider the diameter of the circle to be the largest of the dimensions
    of the sprite. We have to add a member variable to `ScreenGameObject` named `mRadius`
    and this code to the constructor of the sprite:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来检测碰撞的下一类身体是一个圆形。为此，我们将考虑圆的直径是精灵尺寸的最大值。我们必须在`ScreenGameObject`中添加一个名为`mRadius`的成员变量，并将此代码添加到精灵的构造函数中：
- en: '[PRE121]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Note that other elements that inherit from `ScreenGameObject` may want to initialize
    the radius in a different way.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从`ScreenGameObject`继承的其他元素可能希望以不同的方式初始化半径。
- en: 'The calculation of a circular collision is fairly simple: we just have to measure
    the distance between the centers of the two circles and check if it is smaller
    than the sum of the radius.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形碰撞的计算相当简单：我们只需要测量两个圆心之间的距离，并检查它是否小于半径之和。
- en: '![Circular bodies](img/B04757_04_04.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
  zh: '![圆形身体](img/B04757_04_04.jpg)'
- en: With circular bodies, the collision can occur outside the rectangle of the sprite
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于圆形身体，碰撞可以发生在精灵的矩形之外
- en: 'Because calculating square roots is a much more time consuming operation than
    a multiplication, we will use the square of the distance as defined by the Pythagorean
    theorem: *distance**²* *= Δx**²* *+ Δy**²*.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算平方根比乘法要耗费更多的时间，我们将使用由勾股定理定义的距离的平方：*距离**²* *= Δx**²* *+ Δy**²*。
- en: 'The code to check circular collisions is like this:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 检查圆形碰撞的代码如下：
- en: '[PRE122]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We calculate the distance on each axis, then get the `squareDistance` as the
    sum of the squares. The `collisionDistance` is the sum of the radius, and then
    we compare it with the square of the `collisionDistance`.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个轴上计算距离，然后得到`squareDistance`作为平方的总和。`collisionDistance`是半径的总和，然后我们将其与`collisionDistance`的平方进行比较。
- en: Adding visual feedback
  id: totrans-1132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加视觉反馈
- en: 'As we did for rectangle collision detection, we will add some visual feedback
    to the sprite to show the collision area while playing. In this case we just need
    to draw a circle:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对矩形碰撞检测所做的那样，我们将在游戏过程中为精灵添加一些视觉反馈来显示碰撞区域。在这种情况下，我们只需要画一个圆：
- en: '[PRE123]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: And, as simple as that, we can see the collision area of the sprites on the
    game.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样简单，我们就可以看到游戏中的精灵的碰撞区域。
- en: '![Adding visual feedback](img/B04757_04_05.jpg)'
  id: totrans-1136
  prefs: []
  type: TYPE_IMG
  zh: '![添加视觉反馈](img/B04757_04_05.jpg)'
- en: Circular bodies fit great the Asteroids, but are terrible for the Bullets
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形身体非常适合小行星，但对子弹来说却很糟糕
- en: Pros and cons
  id: totrans-1138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优缺点
- en: 'This approach is not perfect either, but it has some advantages:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也不是完美的，但它有一些优点：
- en: It works better than rectangles for most sprites
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比矩形更适合大多数精灵
- en: It is easy to implement
  id: totrans-1141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易实现
- en: It does not involve complex calculations
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不涉及复杂的计算
- en: But it also has some problems— the most notable one is that when the image is
    mostly rectangular, the area of the collision is too big. We can see that clearly
    in the case of the bullets.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也有一些问题——最明显的一个问题是，当图像主要是矩形时，碰撞区域太大。我们可以在子弹的例子中清楚地看到这一点。
- en: So, some sprites work better with rectangles, while others work better with
    circles. We could just have different body types for each `ScreenGameObject` and
    calculate collisions accordingly.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些精灵与矩形配合得更好，而另一些则与圆形配合得更好。我们可以为每个`ScreenGameObject`设置不同的身体类型，并相应地计算碰撞。
- en: Mixed collision detection
  id: totrans-1145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合碰撞检测
- en: We have seen that a single shape does not fit all cases, so we are going to
    update our game to allow us to define which body shape each `ScreenGameObject`
    uses for collisions. For this, we are going to create an enum of body types and
    have a variable to store that information in `ScreenGameObject`.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到单一形状并不适用于所有情况，因此我们将更新我们的游戏，以便我们可以定义每个`ScreenGameObject`用于碰撞的身体形状。为此，我们将创建一个身体类型的枚举，并在`ScreenGameObject`中有一个变量来存储该信息。
- en: 'The enum `BodyType` is as follows:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyType`枚举如下：'
- en: '[PRE124]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In the case of sprites, we will add a parameter to the constructor that specifies
    body type. Note that we have a special type called `None`. This is used for sprites
    that do not collide with others. While there are none of those in our game yet,
    other types of games can have them—for example, floor tiles on a dungeon crawler.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 在精灵的情况下，我们将在构造函数中添加一个参数，指定身体类型。请注意，我们有一个特殊类型称为`None`。这用于不与其他精灵碰撞的精灵。虽然在我们的游戏中还没有这样的精灵，但其他类型的游戏可以有它们——例如，地牢爬行者中的地板砖。
- en: Note
  id: totrans-1150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We may want to have some sprites that do not trigger collisions. This is done
    using `BodyType.None`.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望有一些不会触发碰撞的精灵。这是通过使用`BodyType.None`来实现的。
- en: We are going to use circular bodies for the asteroids and the player, and rectangular
    ones for the bullets.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为小行星和玩家使用圆形身体，为子弹使用矩形身体。
- en: Since we have a list of bodies that can collide, if a `ScreenGameObject` has
    a `BodyType` of `None` we will not add it to the list; therefore, we do not need
    to check its collisions. This piece of code goes inside the method `addToLayerNow`
    of `GameEngine`.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个可以碰撞的身体列表，如果`ScreenGameObject`具有`BodyType.None`，则我们不会将其添加到列表中；因此，我们不需要检查其碰撞。这段代码位于`GameEngine`的`addToLayerNow`方法中。
- en: '[PRE125]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Then we have to update the `checkCollision` method of the `ScreenGameObject`
    to check which types the bodies of the two objects are, and which method we have
    to apply:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须更新`ScreenGameObject`的`checkCollision`方法，以检查两个对象的身体类型，以及我们必须应用哪种方法：
- en: '[PRE126]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note that at this point in the execution, we know that the object is a `ScreenGameObject`
    and that it has a `BodyType` that is not `None`.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在执行到这一点时，我们知道该对象是一个`ScreenGameObject`，并且它有一个不是`None`的`BodyType`。
- en: 'If both objects involved have rectangular bodies, we use the rectangular collision
    detection method. If both have circular bodies, we use the circular collision
    detection method. In any other case one of them is circular and the other is rectangular,
    so we have a new method for this case: `checkMixedCollision`.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及的两个对象都具有矩形身体，我们使用矩形碰撞检测方法。如果两者都具有圆形身体，我们使用圆形碰撞检测方法。在任何其他情况下，一个是圆形，另一个是矩形，因此我们为此情况有一个新方法：`checkMixedCollision`。
- en: To calculate if a rectangle and a circle collide, we have to check if the point
    of the rectangle that is closest to the circle is inside it (the distance to the
    center of the circle is smaller than the radius).
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算矩形和圆是否碰撞，我们必须检查矩形最接近圆的点是否在圆内（到圆心的距离小于半径）。
- en: The point of the rectangle that is closest to the circle can be easily calculated
    if we isolate the problem on each coordinate.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将问题隔离到每个坐标，则矩形最接近圆的点可以很容易地计算出来。
- en: '![Mixed collision detection](img/B04757_04_06.jpg)'
  id: totrans-1161
  prefs: []
  type: TYPE_IMG
  zh: '![混合碰撞检测](img/B04757_04_06.jpg)'
- en: Possible relative positions of a circle and a rectangle and its closest point
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 圆和矩形及其最近点的可能相对位置
- en: 'We are going to discuss the vertical axis (this is easier to distinguish because
    the bullets are tall). The horizontal axis follows an equivalent logic:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论垂直轴（这更容易区分，因为子弹很高）。水平轴遵循类似的逻辑：
- en: We draw a horizontal line that goes through the center of the circle.
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们画一条穿过圆心的水平线。
- en: If that line intersects the rectangle, the point of intersection is the closest
    point. As we are considering only the vertical axis, that value is the *y* coordinate
    of the center of the circle.
  id: totrans-1165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果那条线与矩形相交，交点就是最近的点。因为我们只考虑垂直轴，所以这个值是圆心的*y*坐标。
- en: If the rectangle is below the line, the *y* coordinate of the closest point
    to the circle is the top position of the rectangle (the *y* coordinate).
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果矩形在直线以下，则圆最近的点的*y*坐标是矩形的顶部位置（*y*坐标）。
- en: If the rectangle is above the line, the *y* coordinate of the closest point
    to the circle is the bottom position of the rectangle (*y* + `height`).
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果矩形在直线以上，则圆最近的点的*y*坐标是矩形的底部位置（*y* + `height`）。
- en: Remember that in computer graphics the [0,0] point is at the top left of the
    screen and the *y* axis is positive downwards.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在计算机图形中，[0,0]点位于屏幕的左上角，*y*轴向下为正。
- en: 'Now that the algorithm is clear, let''s look at the code:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在算法已经清晰，让我们看看代码：
- en: '[PRE127]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We first identify which object has a circular body and which a rectangular one,
    and we set them to local variables.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确定哪个对象具有圆形身体，哪个具有矩形身体，并将它们设置为局部变量。
- en: Then we calculate the *x* and *y* coordinates of the closest point, following
    the logic we already described. This combination gives us nine possible relative
    positions, which you can see in the image.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据之前描述的逻辑计算最近点的 *x* 和 *y* 坐标。这种组合给我们提供了九种可能的相对位置，您可以在图中看到。
- en: Finally, we calculate the square distance from that point to the center of the
    circle and check if it is smaller than the square of the radius.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算该点到圆心的平方距离，并检查它是否小于半径的平方。
- en: Adding visual feedback
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加视觉反馈
- en: Adding visual feedback is again very simple. We just need to run the code to
    draw a rectangle or the one to draw a circle, according to the type of body the
    sprite has.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 添加视觉反馈再次非常简单。我们只需要运行代码来绘制矩形或圆形，具体取决于精灵体的类型。
- en: '[PRE128]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '![Adding visual feedback](img/B04757_04_07.jpg)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
  zh: '![添加视觉反馈](img/B04757_04_07.jpg)'
- en: Other options for shapes
  id: totrans-1178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他形状选项
- en: With this, we have covered the basic options for collision detection using simple
    shapes. To get a good feel for a game, you will need to pay special attention
    to the shape of each sprite and see which shape fits it best, maybe with modifications
    such as a smaller radius. For this I recommend you to keep the visual feedback
    on to check the approximation.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经涵盖了使用简单形状进行碰撞检测的基本选项。为了对游戏有一个良好的感觉，您需要特别注意每个精灵的形状，并看看哪种形状最适合它，也许需要一些修改，比如更小的半径。为此，我建议您保持视觉反馈开启以检查近似值。
- en: There is also the possibility of using polygons as shapes or multiple rectangles.
    These are reasonably easy ways to improve collision detection, and not too hard
    to implement. We leave it to the reader to explore the subject in more depth,
    as it requires fine-tuning.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种可能性是使用多边形作为形状或多个矩形。这些是提高碰撞检测的合理简单方法，并且实现起来也不太难。我们将探索这一主题的深入细节留给读者，因为它需要微调。
- en: In the case of the spaceship, the best shape would be a combination of 2 rectangles
    but, as we are happy with the circular body, we will leave it like that.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 在宇宙飞船的情况下，最好的形状可能是两个矩形的组合，但由于我们对圆形身体感到满意，我们将保持原样。
- en: '![Other options for shapes](img/B04757_04_08.jpg)'
  id: totrans-1182
  prefs: []
  type: TYPE_IMG
  zh: '![其他形状选项](img/B04757_04_08.jpg)'
- en: Different shape options for the spaceship
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 宇宙飞船的不同形状选项
- en: Optimization
  id: totrans-1184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Checking for collisions is an algorithm of quadratic complexity. If the number
    of objects to be checked grows, it may quickly become a bottleneck.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 检查碰撞是一个二次复杂度的算法。如果需要检查的对象数量增加，它可能很快就会成为瓶颈。
- en: One option is to keep a record of the previous state of the comparison between
    the objects, and then either return the old value if both objects have not changed
    since the last check or use the old state as a parameter to the calculation of
    the new one. This is particularly handy for 3D games, where collision detection
    requires much more complex algorithms.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是记录对象之间比较的先前状态，然后如果自上次检查以来两个对象都没有改变，就返回旧值，或者使用旧状态作为计算新状态的参数。这对于3D游戏特别有用，因为碰撞检测需要更复杂的算法。
- en: There is another optimization called spatial partitioning that exploits the
    proximity of the objects. This technique is based on the idea that objects can
    only collide with other elements that are close to them on the screen. Pretty
    obvious, right?
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种优化称为空间划分，它利用了对象的邻近性。这种技术基于这样的想法：对象只能与屏幕上靠近它们的其他元素发生碰撞。很明显，对吧？
- en: To implement spatial partitioning, we are going to use a data structure known
    as `QuadTree`.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现空间划分，我们将使用一种称为 `QuadTree` 的数据结构。
- en: Spatial partitioning and QuadTree
  id: totrans-1189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间划分和QuadTree
- en: A `QuadTree` is similar to a binary tree, except that each node that is not
    a leaf has four children instead of two.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuadTree` 与二叉树类似，除了每个不是叶子的节点有四个子节点而不是两个。'
- en: This is meant to represent the spatial partitioning of a space into four sectors,
    each sector represented by one of the children. Each child can have another four
    nodes, or just be a leaf. This design makes it possible to apply the partition
    recursively when it is needed.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示将空间划分为四个部分，每个部分由一个子节点表示。每个子节点可以有另外四个节点，或者只是一个叶子节点。这种设计使得在需要时可以递归地应用划分。
- en: '![Spatial partitioning and QuadTree](img/B04757_04_09.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![空间划分和QuadTree](img/B04757_04_09.jpg)'
- en: Example of recursive partitioning where the density is high.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 高密度情况下的递归划分示例。
- en: We only need to partition the space if the number of objects in it is too large.
    This means that some sections with a high density of objects may be partitioned
    several times while others aren't.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要分区空间，如果其中的对象数量太大。这意味着一些具有高密度对象的部分可能被分区多次，而其他部分则不是。
- en: When applying this concept to 3D games the data structure is called `OctTree`,
    because when we have three dimensions the space is divided into eight sections.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此概念应用于3D游戏时，数据结构称为`OctTree`，因为当我们有三个维度时，空间被分成八个部分。
- en: 'The algorithm to populate a `QuadTree` is quite straight forward:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`QuadTree`的算法相当直接：
- en: We check how many objects are in the space, and if the number is not too large
    (we use the constant `MAX_OBJECTS_TO_CHECK` for that), we will run the collision
    detection as before, checking each object with every other one
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查空间中有多少对象，如果数量不是太大（我们使用常量`MAX_OBJECTS_TO_CHECK`来表示这一点），我们将像以前一样运行碰撞检测，检查每个对象与另一个对象的碰撞
- en: Otherwise, divide the space into four quadrants or areas
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将空间分成四个象限或区域
- en: For each quadrant, check which objects are inside (an object may be in more
    than one quadrant)
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个象限，检查哪些对象在内部（一个对象可能位于多个象限中）
- en: For each quadrant, apply this same algorithm recursively
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个象限，递归应用此相同的算法
- en: Each `QuadTree` has a `Rect` member that designates its area and a list of objects
    to check.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`QuadTree`都有一个`Rect`成员，指定其区域和要检查的对象列表。
- en: Inside `GameEngine`, we will replace the list of objects to check for collision
    with the root node of a `QuadTree`. We will add objects to or remove them from
    this node as they are added to or removed from the `GameEngine` and delegate the
    `QuadTree` to check the collisions.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameEngine`内部，我们将用`QuadTree`的根节点替换检查碰撞的对象列表。当对象被添加到或从`GameEngine`中删除时，我们将向或从该节点添加或删除对象，并将`QuadTree`委托以检查碰撞。
- en: 'On the constructor of the `GameEngine`, we will set the area of the root node:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameEngine`的构造函数中，我们将设置根节点的区域：
- en: '[PRE129]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The code to check the collisions on the `GameEngine` gets simplified to a single
    line:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`GameEngine`上的碰撞的代码简化为单行：
- en: '[PRE130]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Then, inside `QuadTree`, the code for checking the collisions is as follows:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`QuadTree`内部，检查碰撞的代码如下：
- en: '[PRE131]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: There are two possibilities. If we have too many objects and more than four
    `QuadTree` objects in the pool, we split the space and check the collisions on
    the children. If this isn't so, we just run the collision detection method as
    we did before, iterating among all the objects on the list.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能性。如果我们有太多的对象，并且池中有超过四个`QuadTree`对象，我们将分割空间并在子节点上检查碰撞。如果不是这样，我们就像以前一样运行碰撞检测方法，遍历列表上的所有对象。
- en: 'The method `splitAndCheck` looks like this:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '`splitAndCheck`方法看起来是这样的：'
- en: '[PRE132]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We take four `QuadTree` objects from the pool and assign them to the elements
    on the array of children. It is important to do this at the beginning, given the
    recursive nature of the algorithm.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从池中取出四个`QuadTree`对象，并将它们分配给子数组中的元素。考虑到算法的递归性质，这一点非常重要。
- en: For each child we define the area, which means dividing the current area into
    four equal rectangles, checking which objects are inside the area, and then checking
    for collisions, which is the recursive function again. Once that is done, we clear
    the child and return it to the pool.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个子节点，我们定义区域，这意味着将当前区域分成四个相等的矩形，检查哪些对象在区域内，然后检查碰撞，这又是递归函数。一旦完成，我们清除子节点并将其返回到池中。
- en: On a final note—`getArea` just reuses a `Rect` object to set it to the values
    of the four quadrants.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点——`getArea`只是重用`Rect`对象来将其设置为四个象限的值。
- en: '[PRE133]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: To get an idea of the level of optimization of QuadTrees, let's imagine that
    we have 100 objects on the screen and that they are distributed in only two quadrants.
    This is one of those cases when this algorithm provides the best optimization.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解QuadTrees的优化水平，让我们想象屏幕上有100个对象，并且它们只分布在两个象限中。这就是这种算法提供最佳优化的一种情况。
- en: '![Spatial partitioning and QuadTree](img/B04757_04_10.jpg)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
  zh: '![空间划分和QuadTree](img/B04757_04_10.jpg)'
- en: If we don't use the `QuadTree` technique, the number of collisions that need
    to be evaluated is 50.000\. Iterating over the list twice gives n²/2 collision
    checks.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用`QuadTree`技术，需要评估的碰撞次数是50,000次。遍历列表两次给出n²/2次碰撞检查。
- en: When we split the space into four, the amount of collisions checked is 1.250
    on the first and fourth quadrants (50²/2) and none on the others. We have to add
    400 operations, which are needed to see in which section each object is located
    (100 objects in four quadrants).
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将空间划分为四个部分时，第一和第四象限的碰撞检查数量为1.250（50²/2），其他象限没有。我们需要添加400个操作，这些操作是查看每个对象位于哪个部分所必需的（四个象限中有100个对象）。
- en: For us, checking which quadrant an object is in is of similar complexity to
    checking a collision, but for collisions in 3D the collision check is much more
    expensive.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，检查一个对象位于哪个象限的复杂度与检查碰撞相似，但对于3D中的碰撞，碰撞检查的成本要高得多。
- en: Duplicated collisions
  id: totrans-1221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复碰撞
- en: 'There is a special case we should be aware of when using spatial partitioning:
    some collisions can be detected twice.'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用空间划分时，我们应该注意一个特殊情况：一些碰撞可能会被检测两次。
- en: When a collision occurs between two objects that are on the intersection of
    two quadrants, both objects are in both quadrants; when the algorithm checks for
    collisions, it is detected in each of them. In the worst case it would be detected
    four times, when the objects are placed on the intersection of the four quadrants.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对象位于两个象限的交点时，这两个对象都位于两个象限中；当算法检查碰撞时，在每个象限都会被检测到。在最坏的情况下，当对象位于四个象限的交点时，它会被检测四次。
- en: To solve this, we will keep a list of collisions that have been detected and
    only process a collision if it has not been detected before.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将保留一个已检测到的碰撞列表，并且只有当碰撞之前没有被检测到时才处理碰撞。
- en: 'The `Collision` class is very simple. It just contains two `ScreenGameObject`
    instances, an `equals` method, and a couple of static methods to handle its pool:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collision`类非常简单。它只包含两个`ScreenGameObject`实例、一个`equals`方法和一些用于处理其池的静态方法：'
- en: '[PRE134]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We add the list of detected collisions as a parameter to the `checkCollisions`
    method, and we make sure we clean it on `GameEngine` before checking it again.
    The updated `checkCollisions` on the `GameEngine` is like this:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检测到的碰撞列表作为参数添加到`checkCollisions`方法中，并确保在再次检查之前在`GameEngine`中清理它。`GameEngine`上的更新版`checkCollisions`如下所示：
- en: '[PRE135]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note that, because we are using a pool, we cannot just clear the list; we need
    to release each element individually.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我们使用了一个池，我们不能简单地清除列表；我们需要逐个释放每个元素。
- en: Finally, we verify that the collision has not been detected before, checking
    it on the `QuadTree`.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们验证碰撞之前没有被检测到，在`QuadTree`上检查它。
- en: '[PRE136]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that the list of collisions is required throughout the process, and it
    must be passed to the recursive method as part of the state of the calculation.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在整个过程中都需要碰撞列表，并且它必须作为计算状态的一部分传递给递归方法。
- en: Summary
  id: totrans-1233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now our game is really playable, we can detect when the bullets touch the asteroids
    and destroy them; additionally, we have to be careful because our ship can be
    destroyed by them as well.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏真的可以玩儿了，我们可以检测子弹是否接触到小行星并摧毁它们；此外，我们还得小心，因为我们的飞船也可能被它们摧毁。
- en: We have learned how to do simple collision detection with rectangular and circular
    bodies, adjusting the body for each particular sprite.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用矩形和圆形体进行简单的碰撞检测，并调整每个特定精灵的体。
- en: We also learned some optimization techniques for collision detection and implemented
    one that makes use of spatial partitioning.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了碰撞检测的一些优化技术，并实现了一个利用空间划分的技术。
- en: The next step in our roadmap is to add some juiciness to the game. Didn't you
    notice that the asteroids are missing some explosions? In the next chapter, we
    are going to talk about how to create particle systems for effects.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们路线图中的下一步是给游戏增加一些趣味性。你没有注意到小行星缺少一些爆炸效果吗？在下一章中，我们将讨论如何创建用于效果的粒子系统。
- en: Chapter 5. Particle Systems
  id: totrans-1238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 粒子系统
- en: Particle systems are a technique used widely in video games to simulate phenomena
    that are complicated to render with other methods. The typical usages for them
    include explosions, fireworks, smoke, fire, water, and so on. They are usually
    highly chaotic systems.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是一种在视频游戏中广泛使用的技巧，用于模拟其他方法难以渲染的现象。它们典型的应用包括爆炸、烟花、烟雾、火焰、水等等。它们通常是高度混沌的系统。
- en: Their foundation is to use a large number of small sprites called particles.
    Their behavior is parametrized, so each particle has a different set of pseudo-random
    values. This makes each usage of the particle system different while it still
    looks similar.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的基座是使用大量称为粒子的微小精灵。它们的行为是参数化的，因此每个粒子都有不同的一组伪随机值。这使得每次使用粒子系统都不同，同时看起来仍然相似。
- en: Most game engines include a way to implement particle systems. Our engine will
    have them too.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏引擎都包含实现粒子系统的方法。我们的引擎也将拥有这些功能。
- en: We will base our code on the free software project Leonids, which is a library
    to display particle systems in the standard Android UI. We will adapt it to be
    used by our engine.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于开源项目Leonids编写我们的代码，Leonids是一个用于在标准Android UI中显示粒子系统的库。我们将对其进行适配以供我们的引擎使用。
- en: After explaining the basics of particle systems, we will implement a couple
    of examples of one-shot particle systems to simulate explosions, and also some
    continuous emitters to simulate a trail for the asteroids and the smoke of the
    spaceship's engine.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了粒子系统的基本原理之后，我们将实现一些一次性粒子系统的示例，以模拟爆炸，以及一些连续发射器来模拟小行星的轨迹和宇宙飞船引擎的烟雾。
- en: General concepts
  id: totrans-1244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般概念
- en: We are going to make our particle system in a way that mimics the Leonids particle
    system library at [http://plattysoft.github.io/Leonids/](http://plattysoft.github.io/Leonids/).
    This project is a free software library I made to use particle systems in the
    standard Android UI.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照[http://plattysoft.github.io/Leonids/](http://plattysoft.github.io/Leonids/)上的Leonids粒子系统库的方式制作我们的粒子系统。这是一个我制作的免费软件库，用于在标准Android
    UI中使用粒子系统。
- en: '![General concepts](img/B04757_05_01.jpg)'
  id: totrans-1246
  prefs: []
  type: TYPE_IMG
  zh: '![一般概念](img/B04757_05_01.jpg)'
- en: A demo of the Leonids library is available on Google Play
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: Leonids库的演示可在Google Play上找到
- en: As a result of this, Leonids implements its own update and draw threads, as
    well as a simplified `GameView`. We already have all these, so we will adapt the
    code to suit our needs.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Leonids实现了自己的更新和绘制线程，以及简化的`GameView`。我们已经有所有这些，所以我们将适配代码以满足我们的需求。
- en: 'The concepts we are going to work with in this chapter are:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用的概念是：
- en: '**Particle**: Each of the sprites that are rendered'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子**：每个被渲染的精灵'
- en: '**Particle system**: The entity that takes care of spawning, updating, and
    keeping track of the particles'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子系统**：负责生成、更新和跟踪粒子的实体'
- en: '**Initializer**: A class that sets a value for a particle based on certain
    parameters (before being active)'
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化器**：一个基于某些参数（在激活之前）为粒子设置值的类'
- en: '**Modifier**: A class that updates a value for a particle based on the elapsed
    time (while being active)'
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符**：一个基于经过的时间（在激活期间）更新粒子值的类'
- en: In our game, we will use only a few initializers and modifiers. If you need
    to extend the functionality of the particle system, you can visit Leonids' GitHub
    page to get ideas from it.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将仅使用少数初始化器和修饰符。如果您需要扩展粒子系统的功能，您可以访问Leonids的GitHub页面以获取灵感。
- en: Let's get into the concepts.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这些概念。
- en: Particles
  id: totrans-1256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子
- en: 'Particles are a subclass of `Sprites`. Each particle is a small image with
    several particularities:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子是`Sprites`的子类。每个粒子都是一个小图像，具有几个特定的特性：
- en: Particles do not have a collision body
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子没有碰撞体
- en: Their movement is based on linear and angular speed
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的运动基于线性和角速度
- en: They have a limited time to live
  id: totrans-1260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有有限的生命周期
- en: While, in theory, you could have a particle system in which the particles can
    collide—and this is handy to simulate effects such as a waterfall— the truth is
    that, unless you also have physics, this will not work properly. For simplicity,
    we are going to define our particles to have a `BodyType` of `None`.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲，您可以在粒子系统中实现粒子可以碰撞的情况——这对于模拟瀑布等效果很有用——但事实是，除非您还有物理引擎，否则这不会正常工作。为了简单起见，我们将定义我们的粒子具有`BodyType`为`None`。
- en: A particle does have linear and angular speed and its `onUpdate` method is based
    on these variables. Each particle has these values initialized by the particle
    system.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子确实具有线性和角速度，其`onUpdate`方法基于这些变量。每个粒子都有这些值，由粒子系统初始化。
- en: 'There are a few properties of sprites that particles usually modify. They are
    alpha and scale. We are not using them on sprites yet, so we will modify the `onDraw`
    method of `Sprite` for it:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子通常修改精灵的一些属性。它们是透明度和缩放。我们目前还没有在精灵上使用它们，所以我们将修改`Sprite`的`onDraw`方法来实现这一点：
- en: '[PRE137]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: As it happens, we were using the scale as part of the transformation matrix
    to scale the sprite based on the pixel factor. Now, we also multiply this by the
    perceived scale and we are done.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们正在使用缩放作为变换矩阵的一部分来根据像素因子缩放精灵。现在，我们还乘以感知的缩放，这样就完成了。
- en: Note that we also need to multiply the width and height by the scale to put
    the center of the rotation at the center of the scaled sprite.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还需要将宽度和高度乘以缩放比例，以便将旋转中心放在缩放精灵的中心。
- en: Also, note that we do the scaling in the beginning. If we were to do the scaling
    after the translation, the movement would be scaled as well and this is not what
    we want. Again, the order of the transformations affects the result.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们在开始时进行缩放。如果我们要在平移之后进行缩放，那么移动也会被缩放，而这不是我们想要的。再次强调，变换的顺序会影响结果。
- en: While the scale is a part of the transformation matrix, the alpha is a parameter
    of `Paint`. Its value goes from 0 (transparent) to 255 (opaque). It is important
    that you remember to initialize it to 255 or all our sprites will be transparent.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`scale`是变换矩阵的一部分，但`alpha`是`Paint`的参数。它的值从0（透明）到255（不透明）。重要的是你要记得将其初始化为255，否则我们所有的精灵都将透明。
- en: Note
  id: totrans-1269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alpha values go from 0 (transparent) to 255 (opaque).
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度值从0（透明）到255（不透明）。
- en: With regard to the time to live, we just need to check the total amount of time
    the particle has been active during `onUpdate` to remove it from the `GameEngine`
    and return it to the particle system when it has expired.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 关于存活时间，我们只需要检查粒子在`onUpdate`期间活跃的总时间，以从`GameEngine`中移除它，并在它过期时将其返回到粒子系统。
- en: '`Particle` is then a class that extends `Sprite`, which has a method to `activate`
    it. It runs its updates based on the values of linear and angular speed:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle`是一个扩展了`Sprite`的类，它有一个`激活`的方法。它根据线性和角速度的值运行其更新：'
- en: '[PRE138]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: In the constructor, we pass a reference to the parent `ParticleSystem`, which
    we will use to return the particle to it when it is removed from the game engine.
    We also pass `BodyType.None` to the base class constructor so the particle is
    not involved in the collision detection.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们向父`ParticleSystem`传递一个引用，当我们从游戏引擎中移除粒子时，我们将使用它将粒子返回。我们还向基类构造函数传递`BodyType.None`，这样粒子就不会参与碰撞检测。
- en: 'When we activate the particle, we do several actions:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们激活粒子时，我们执行几个操作：
- en: Set a time to live
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置存活时间
- en: Initialize the position on the *x* and *y* axes, adjusting it with the width
    and height of the image
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*x*和*y*轴上初始化位置，并调整图像的宽度和高度
- en: Add it to the specific layer of the `GameEngine`
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其添加到`GameEngine`的特定层
- en: Store a reference to the list of modifiers to be used during `onUpdate`
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在`onUpdate`期间要使用的修饰符列表的引用
- en: Set the total milliseconds to 0 to indicate that this particle has just been
    activated
  id: totrans-1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将总毫秒数设置为0，以表示该粒子刚刚被激活
- en: It is worth noticing that we are keeping a reference to the list of modifiers.
    This list is shared among all the particles in the system and it is managed by
    the `ParticleSystem` class.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们保留了对修饰符列表的引用。这个列表在系统中的所有粒子之间共享，并由`ParticleSystem`类管理。
- en: During `onUpdate`, we add the elapsed milliseconds to the total time and check
    whether the `Particle` has passed its time to live. If this is the case, we remove
    it from the `GameEngine`. Otherwise, we update the position and rotation based
    on the speed (linear and angular) and then apply all the modifiers.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onUpdate`期间，我们将经过的毫秒数添加到总时间，并检查`Particle`是否已经过了其存活时间。如果是这样，我们就从`GameEngine`中移除它。否则，我们根据速度（线性和角速度）更新位置和旋转，然后应用所有修饰符。
- en: You may have realized that we are using linear and angular speed values but,
    so far, we have not set them. This is done by the `ParticleSystem` through the
    initializers. This is why these variables are public.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到我们正在使用线性和角速度值，但到目前为止，我们还没有设置它们。这是通过`ParticleSystem`的初始化器完成的。这就是为什么这些变量是公开的。
- en: Let's look at the system that handles the particles.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理粒子的系统。
- en: ParticleSystem
  id: totrans-1285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ParticleSystem
- en: The `ParticleSystem` itself is the one that controls the emission of particles.
    It is similar to the `GameController` class in some ways. `ParticleSystem` takes
    care of the initializing, activating, and spawning of particles.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`本身是控制粒子发射的部分。它在某些方面类似于`GameController`类。`ParticleSystem`负责初始化、激活和生成粒子。'
- en: One of the responsibilities of the `ParticleSystem` is to manage the pool of
    `Particle` objects. Given that particle systems have a large number of particles
    that expire and get reused, this is one of the cases when using an object pool
    is most important.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`的一个职责是管理`Particle`对象的池。鉴于粒子系统有大量过期并被重用的粒子，这是使用对象池最重要的案例之一。'
- en: Note
  id: totrans-1288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ParticleSystem` has a pool of `Particles`.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`有一个`Particles`的池。'
- en: 'The pool is populated in the constructor of the `ParticleSystem`:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 池在`ParticleSystem`的构造函数中被填充：
- en: '[PRE139]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The constructor receives the maximum number of particles that will be used simultaneously.
    This is what we will use for the size of the pool.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收将同时使用的最大粒子数。这是我们用于池大小的值。
- en: Another important point about our particle system is that all the particles
    have the same image. This is passed to the `ParticleSystem` in construction. If
    you want to have different images, you should use a `ParticleSystem` for each
    one of them as we will do in one of the examples.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的粒子系统，另一个重要点是所有粒子具有相同的图像。这个图像在构造时传递给`ParticleSystem`。如果你想要不同的图像，你应该为每个粒子使用一个`ParticleSystem`，就像我们在一个示例中所做的那样。
- en: Note
  id: totrans-1294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All particles of a `ParticleSystem` have the same image.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`中的所有粒子具有相同的图像。'
- en: In the constructor, we also create the lists of `ParticleInitializer` and `ParticleModifiers`.
    The initializers will be used while activating each particle. The modifiers list
    will be passed to each particle and it will be used inside the `onUpdate` method
    of `Particle` as we have already seen.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们还创建了`ParticleInitializer`和`ParticleModifiers`的列表。初始化器将在激活每个粒子时使用。修饰器列表将被传递给每个粒子，它将在`Particle`的`onUpdate`方法中使用，就像我们已经看到的那样。
- en: 'This is how the initializers are used during the activation of a particle:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在粒子激活期间初始化器是如何被使用的：
- en: '[PRE140]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: An important design concept in `ParticleSystem` is that it abstracts the initializers
    and modifiers via utility methods and each one of these utility methods return
    the `ParticleSystem` object, so the initialization can be chained, making the
    code shorter and easier to read.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`中的一个重要设计概念是它通过实用方法抽象了初始化器和修饰器，并且每个实用方法都返回`ParticleSystem`对象，这样初始化就可以链式调用，使代码更短，更容易阅读。'
- en: Let's look at `ParticleInitializers` and `ParticleModifiers` in detail.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看`ParticleInitializers`和`ParticleModifiers`。
- en: Initializers
  id: totrans-1301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化器
- en: '**Initializers** are used by the `ParticleSystem` to set values for the particles
    based on parameters. To do this, we define `ParticleInitializer` as a very simple
    interface:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化器**被`ParticleSystem`用来根据参数为粒子设置值。为此，我们将`ParticleInitializer`定义为一个非常简单的接口：'
- en: '[PRE141]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'As an example, we will look at the utility method of `ParticleSytem` to set
    the initial rotation of the particles:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将查看`ParticleSytem`的实用方法来设置粒子的初始旋转：
- en: '[PRE142]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: When we set the initial rotation range for a `Particle`, we add an initializer
    of the `RotationInitializer` type to the `ParticleSystem`. Then we return this,
    so the methods can be chained.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`Particle`设置初始旋转范围时，我们将`RotationInitializer`类型的初始化器添加到`ParticleSystem`中。然后我们返回这个对象，这样方法就可以链式调用了。
- en: 'Other methods that we can use to configure the initialization of particles
    are:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的其他配置粒子初始化的方法包括：
- en: '`setRotationSpeedRange(double minRotationSpeed, double maxRotationSpeed)`'
  id: totrans-1308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRotationSpeedRange(double minRotationSpeed, double maxRotationSpeed)`'
- en: '`setSpeedRange(double speedMin, double speedMax)`'
  id: totrans-1309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSpeedRange(double speedMin, double speedMax)`'
- en: '`setSpeedModuleAndAngleRange(double speedMin, double speedMax, int minAngle,
    int maxAngle)`'
  id: totrans-1310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSpeedModuleAndAngleRange(double speedMin, double speedMax, int minAngle,
    int maxAngle)`'
- en: '`setRotationSpeedRange(double minRotationSpeed, double maxRotationSpeed)`'
  id: totrans-1311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRotationSpeedRange(double minRotationSpeed, double maxRotationSpeed)`'
- en: 'We are not going to include the code of all the initializers we are going to
    use since all of them follow the same pattern:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会包含我们将要使用的所有初始化器的代码，因为它们都遵循相同的模式：
- en: Receive a set of parameters and define the range(s)
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一组参数并定义范围
- en: Generate a random value(s) from the range(s)
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从范围中生成随机值
- en: Set the value(s) to the proper variable(s) of `Particle` (this may involve more
    than one field)
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值设置到`Particle`的适当变量中（这可能涉及多个字段）
- en: Note
  id: totrans-1316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Initializers get a random value(s) from a range and set it to a variable(s)
    of `Particle`.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器从范围内获取随机值并将其设置到`Particle`的变量中。
- en: 'As an example on how `ParticleInitializer` is implemented, let''s look at the
    code of `RotationInitializer`:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`ParticleInitializer`实现的一个示例，让我们看看`RotationInitializer`的代码：
- en: '[PRE143]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Straightforward enough; the initializer stores the minimum and maximum values
    of the angle in member variables (`mMinAngle`, `mMaxAngle`). When it initializes
    a particle, it generates a random value in the range and sets it to the rotation
    variable of the particle.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 足够直接；初始化器将角度的最小值和最大值存储在成员变量中（`mMinAngle`，`mMaxAngle`）。当它初始化一个粒子时，它会在范围内生成一个随机值并将其设置为粒子的旋转变量。
- en: 'All initializers work the same way; some are a bit more complex than others.
    For example, `SpeedModuleAndRangeInitializer` uses trigonometry to convert the
    speed from angle and module to coordinates:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 所有初始化器都以相同的方式工作；有些比其他的一些更复杂。例如，`SpeedModuleAndRangeInitializer` 使用三角学将速度从角度和模块转换为坐标：
- en: '[PRE144]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: In this case, we have two ranges, one for the speed module and another for the
    angle. When we initialize a particle, we get a value for each one of them from
    their range, but then we need to use `sin` and `cos` to convert them into values
    that can be used for `Particle`, which are `mSpeedX` and `mSpeedY`.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个范围，一个用于速度模块，另一个用于角度。当我们初始化一个粒子时，我们从它们各自的范围内获取每个值，但随后我们需要使用 `sin`
    和 `cos` 将它们转换为可以用于 `Particle` 的值，即 `mSpeedX` 和 `mSpeedY`。
- en: In this case, we are initializing two variables of `Particle`. Note again that
    these fields of the `Particle` class are public, so we can modify them from this
    class easily.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在初始化 `Particle` 的两个变量。再次注意，`Particle` 类的这些字段是公开的，因此我们可以轻松地从此类中修改它们。
- en: Modifiers
  id: totrans-1325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修饰符
- en: '**Modifiers** are a concept similar to initializers, but they are applied when
    the particle is active.'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '**修饰符** 是一个类似于初始化器的概念，但它们是在粒子激活时应用的。'
- en: 'As for initializers, we define an interface that allows them to interact with
    the `Particle` class:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 至于初始化器，我们定义了一个接口，允许它们与 `Particle` 类交互：
- en: '[PRE145]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: For us, a modifier will have the same parameters for all the particles, while
    an initializer will generate a value for each particle. This is why the linear
    and angular speeds are *not* handled by modifiers and are variables of each particle
    that can—and most likely will—have different values for each one of them.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，修饰符将为所有粒子具有相同的参数，而初始化器将为每个粒子生成一个值。这就是为什么线性和角速度不是由修饰符处理的，而是每个粒子的变量，它们可以——并且很可能会——具有不同的值。
- en: 'The `ParticleModifier` instances are also managed via utility methods of `ParticleSystem`,
    such as the one to set a fade out:'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleModifier` 实例也通过 `ParticleSystem` 的实用方法进行管理，例如设置淡出：'
- en: '[PRE146]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This method creates an `AlphaModifier` to set a fade out (from an alpha of 255
    to 0) based on the particle's time to live in the system.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个 `AlphaModifier` 来设置淡出（从 alpha 值 255 到 0），基于粒子在系统中的存活时间。
- en: 'In general, we can create our own `ParticleModifier` instances and add them
    to the `ParticleSystem` by calling `addModifier`:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以创建自己的 `ParticleModifier` 实例，并通过调用 `addModifier` 将它们添加到 `ParticleSystem`
    中：
- en: '[PRE147]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'We are going to use only two modifiers: `AlphaModifier` for fade outs and `ScaleModifier`.'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用两个修饰符：`AlphaModifier` 用于淡出和 `ScaleModifier`。
- en: 'Let''s examine the code for `AlphaModifier`:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `AlphaModifier` 的代码：
- en: '[PRE148]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Note that we have an initial value and a final value; we will set the alpha
    to the initial value if the time is less than the starting one and set it to the
    final value when the time is greater than the end one.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个初始值和一个最终值；如果时间小于起始时间，我们将 alpha 设置为初始值；如果时间大于结束时间，我们将 alpha 设置为最终值。
- en: This allows us to do both, a fade in and a fade out, using the same class.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用相同的类同时进行淡入和淡出。
- en: For modifiers, it is important to emphasize that the `apply` method receives
    the total amount of milliseconds spent. This is required because the modifier
    does not know anything about the `Particle`. It does not have any state, so all
    the information must be passed as parameters to the `apply` method.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于修饰符，重要的是强调 `apply` 方法接收已花费的总毫秒数。这是必需的，因为修饰符对 `Particle` 一无所知。它没有任何状态，因此所有信息都必须作为参数传递给
    `apply` 方法。
- en: Note
  id: totrans-1341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modifiers are the same for all the particles and do not save any state.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符对所有粒子都是相同的，并且不保存任何状态。
- en: The modifier has a start and an end time. When the time is outside the interval,
    we set it to the initial or final value. When the time is between these boundaries,
    it returns the value as a linear interpolation of the increment between the initial
    and final values.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符有一个开始时间和结束时间。当时间在区间之外时，我们将它设置为初始或最终值。当时间在这两个边界之间时，它返回初始值和最终值之间增量的一次线性插值。
- en: It is quite easy to modify this code to use other types of interpolators. If
    you are curious about it, you can check the code of Leonids on GitHub, which supports
    interpolators.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改此代码以使用其他类型的插值器非常简单。如果你对此好奇，可以查看 GitHub 上 Leonids 的代码，它支持插值器。
- en: '`ScaleModifier` is almost identical to this one, except that the value is set
    to `mScale` instead of `mAlpha`.'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScaleModifier` 几乎与这个相同，只是值被设置为 `mScale` 而不是 `mAlpha`。'
- en: Composite GameObjects and GameEngine
  id: totrans-1346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合 GameObjects 和 GameEngine
- en: Until now, the `GameObjects` that we have been using are a single entity. From
    now on, we will also have `GameObjects` that include other `GameObjects`. In particular,
    the `ParticleSystems` used by each object will be owned by them.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用的 `GameObjects` 是一个单一实体。从现在开始，我们还将拥有包含其他 `GameObjects` 的 `GameObjects`。特别是，每个对象使用的
    `ParticleSystems` 将由它们拥有。
- en: This implies that the addition and removal of `GameObjects` to the `GameEngine`
    must be updated. The object will have two methods to add and remove itself from
    the `GameEngine` and we can override this method when we use a composite object
    to take care of them.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着必须更新将 `GameObjects` 添加到 `GameEngine` 的添加和删除操作。对象将有两个方法来自身添加和删除到 `GameEngine`，并且当我们使用组合对象时可以覆盖此方法来处理它们。
- en: Our change will be to stop using the `addGameObject` and `removeGameObject`
    methods from `GameEngine` and start using new equivalent methods such as `addToGameEngine`
    and `removeFromGameEngine` on the `GameObject` instead.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变化将是不再使用 `GameEngine` 的 `addGameObject` 和 `removeGameObject` 方法，而是开始使用新的等效方法，如
    `addToGameEngine` 和 `removeFromGameEngine` 在 `GameObject` 上。
- en: 'This implies that we should go over the code of the project and replace all
    their occurrences. This is especially important in the case of the `GameController`,
    where the asteroids are spawned, and the initialization of the `GameEngine` inside
    `GameFragment`, when we add the `Player` object:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该检查项目的代码，并替换所有出现的地方。这在 `GameController` 的情况下尤为重要，其中小行星被生成，以及 `GameFragment`
    内 `GameEngine` 的初始化，当我们添加 `Player` 对象时：
- en: '[PRE149]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Even though the use of the old methods would produce the same result on noncomposite
    objects, it is better to add all the `GameObjects` to the `GameEngine` in the
    same way to have consistent code.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用旧方法在非组合对象上会产生相同的结果，但最好以相同的方式将所有 `GameObjects` 添加到 `GameEngine` 中，以保持代码的一致性。
- en: 'The default implementations of `addToGameEngine` and `removeFromGameEngine`
    are actually extremely simple for a noncomposite `GameObject`:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToGameEngine` 和 `removeFromGameEngine` 的默认实现对于一个非组合 `GameObject` 来说实际上非常简单：'
- en: '[PRE150]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: When we override this methods on composite items, we must remember to call the
    super method to add and remove the object.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在组合项上覆盖此方法时，我们必须记得调用超类方法来添加和删除对象。
- en: Making good particle systems
  id: totrans-1356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作好的粒子系统
- en: As a side note, particle systems are very powerful, but it is not trivial to
    tweak and design them.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，粒子系统非常强大，但调整和设计它们并不简单。
- en: The implementation details of a particle system are straightforward, as we have
    seen. But making a particle system that looks realistic and good is something
    else entirely.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的实现细节非常简单，正如我们所看到的。但制作出看起来逼真且好的粒子系统则是另一回事。
- en: The key to fine-tuning them is to play with the parameters and see how they
    look, again, and again, and again until we are happy with the result.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 调整它们的关键是玩弄参数，再次再次再次查看它们的外观，直到我们对结果满意为止。
- en: To try and throw some light on the obscure art of tweaking particle systems,
    we are going to do a few examples. You can play with the particles and parameters
    on your own to see how much of a difference small changes make.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试阐明调整粒子系统的神秘艺术，我们将做一些例子。你可以自己玩弄粒子和参数，看看小变化能有多大影响。
- en: 'There are two ways of using particle systems: one-shot and continuous emitter.
    Let''s make some examples of both.'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用粒子系统的两种方式：一次性发射器和连续发射器。让我们举一些两种方法的例子。
- en: One shot
  id: totrans-1362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一击
- en: While using one shot, we make the `ParticleSystem` launch all the particles
    at once.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用一次性发射时，我们将 `ParticleSystem` 中的所有粒子一次性发射出去。
- en: In this case, we do not need to add or remove the `ParticleSystem` to or from
    the `GameEngine`, because the `onUpdate` method of the `ParticleSystem` does not
    need to be called (it is only used to emit new particles).
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要将 `ParticleSystem` 添加到或从 `GameEngine` 中删除，因为 `ParticleSystem` 的
    `onUpdate` 方法不需要被调用（它仅用于发射新粒子）。
- en: While using one shot, it is only logical to initialize the particle pool with
    the same number of particles that we plan to use for the shot.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单次发射时，用我们计划用于射击的相同数量的粒子初始化粒子池是合乎逻辑的。
- en: 'The `oneShot` method of the `ParticleSystem` class is as follows:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`类的`oneShot`方法如下：'
- en: '[PRE151]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We set the *x* and *y* coordinates from which we will emit and then set `isEmitting`
    to `false`. While updating `isEmitting` is only necessary when the `ParticleSystem`
    is added to the `GameEngine`, we do it just to be safe. In this case, setting
    `isEmitting` to false will make `onUpdate` simply do nothing.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了发射的*x*和*y*坐标，然后设置`isEmitting`为`false`。在更新`isEmitting`时，只有在将`ParticleSystem`添加到`GameEngine`时才是必要的，但我们只是为了安全起见这样做。在这种情况下，将`isEmitting`设置为`false`将使`onUpdate`简单地什么也不做。
- en: Once the parameters are set, we get the particles from the pool and `activate`
    them. Remember that we already saw the `activate` method while explaining the
    `ParticleSystem` class. As part of the activation, the particles are added to
    the `GameEngine`.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好参数，我们就从池中获取粒子并`激活`它们。记住，我们在解释`ParticleSystem`类时已经看到了`activate`方法。作为激活的一部分，粒子被添加到`GameEngine`中。
- en: We are going to use this type of particle system for the explosion of `Asteroids`
    and the `Player`.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种类型的粒子系统来处理`Asteroids`和`Player`的爆炸。
- en: Asteroid explosions
  id: totrans-1371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小行星爆炸
- en: For the explosion of asteroids, we are going to use a particle that has three
    small fragments of rock, so it will look like the asteroid has broken into multiple
    pieces. To enforce this effect, we will make the particles rotate and move in
    any direction, but not too far away.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小行星的爆炸，我们将使用一个有三个小岩石碎片的粒子，这样它看起来就像小行星已经分裂成多个部分。为了强化这种效果，我们将使粒子以任何方向旋转和移动，但不要离得太远。
- en: 'We create and configure the `ParticleSystem` as part of the `Asteroid` creation.
    This will ensure that each asteroid has its own independent pool of particles:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建和配置`ParticleSystem`时将其作为`Asteroid`创建的一部分。这将确保每个小行星都有自己的独立粒子池：
- en: '[PRE152]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The configuration of the particle system does the following:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的配置执行以下操作：
- en: The particles will live for 700 milliseconds.
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子将存活700毫秒。
- en: They will be spawned in all directions with a speed that will vary between 15
    and 40 units per second.
  id: totrans-1377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将以每秒15到40个单位的速度向所有方向发射。
- en: In the last 300 milliseconds, they will have an alpha modifier to fade out smoothly.
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后300毫秒内，它们将有一个alpha修改器，以平滑地淡出。
- en: The particles will have any initial rotation. Note that the particle is not
    symmetrical; this is very important to prevent the particle from looking static.
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子将具有任何初始旋转。请注意，粒子不是对称的；这一点非常重要，可以防止粒子看起来静止。
- en: Finally, each particle will have an angular rotation speed between -180 and
    180 degrees per second.
  id: totrans-1380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，每个粒子都将有一个每秒-180到180度的角速度。
- en: '`EXPLOSION_PARTICLES` is a constant for the `Asteroid`. We have set it at 15.'
  id: totrans-1381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLOSION_PARTICLES`是`Asteroid`的一个常量。我们将其设置为15。'
- en: The `explode` method does trigger `oneShot` from the center of the asteroid,
    which will put all the particles in motion.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '`explode`方法确实会从小行星的中心触发`oneShot`，这将使所有粒子开始运动。'
- en: 'The last connection point is to trigger the `explode` method. This happens
    when a bullet collides with an asteroid or when the player collides with an asteroid.
    This is how it is done inside the `Bullet` class:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的连接点是触发`explode`方法。这发生在子弹与小行星碰撞或玩家与小行星碰撞时。这是在`Bullet`类内部如何实现的：
- en: '[PRE153]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: This is it. Quite simple, right? Since the `ParticleSystem` is using a `oneShot`,
    it does not need to be added or removed to or from the `GameEngine`.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。很简单，对吧？由于`ParticleSystem`使用的是`oneShot`，因此不需要添加或从`GameEngine`中移除它。
- en: '![Asteroid explosions](img/B04757_05_02.jpg)'
  id: totrans-1386
  prefs: []
  type: TYPE_IMG
  zh: '![小行星爆炸](img/B04757_05_02.jpg)'
- en: Detail of the explosion particle and particle system.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸粒子和粒子系统的细节。
- en: Spaceship explosions
  id: totrans-1388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宇宙飞船爆炸
- en: For the `Player` explosion, we will use a different approach. We want it to
    look more dramatic. We will have a larger value for the speed than for the asteroid
    to give the impression of a much more aggressive explosion with an extended range.
    We will also use two different particles with different colors instead of one
    with several shards.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Player`的爆炸，我们将采用不同的方法。我们希望它看起来更加戏剧化。我们将使用比小行星更大的速度值，以产生更加强烈且范围更广的爆炸印象。我们还将使用两种不同颜色而不是一个带有多个碎片的一个粒子。
- en: 'Since each `ParticleSystem` is designed to hold only one type of `Particle`
    (one image), we will have two `ParticleSystem` instances in the `Player` class
    that will be initialized in the constructor:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个`ParticleSystem`都设计用来只持有一种类型的`Particle`（一个图像），因此`Player`类中将有两个`ParticleSystem`实例，它们将在构造函数中初始化：
- en: '[PRE154]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In this case, each particle is very small and symmetrical, so we don't need
    rotational speed. Since they are much faster than before, the time to live is
    also a bit shorter and the fade out is sharper.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个粒子都非常小且对称，所以我们不需要旋转速度。由于它们比以前快得多，所以存活时间也短一些，淡出也更尖锐。
- en: In this case, `EXPLOSION_PARTICLES` is set to 20, so there are 40 particles
    in total.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`EXPLOSION_PARTICLES`设置为20，所以总共有40个粒子。
- en: 'When the `Player` object explodes (as a part of `onCollision`), we trigger
    `oneShot` on both `ParticleSystem` instances:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Player`对象爆炸（作为`onCollision`的一部分）时，我们在两个`ParticleSystem`实例上触发`oneShot`：
- en: '[PRE155]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'As you can see, if you run it now, the explosion has a completely different
    feeling from the one for the asteroid:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您现在运行它，爆炸的感觉与用于小行星的完全不同：
- en: '![Spaceship explosions](img/B04757_05_03.jpg)'
  id: totrans-1397
  prefs: []
  type: TYPE_IMG
  zh: '![飞船爆炸](img/B04757_05_03.jpg)'
- en: Emitters
  id: totrans-1398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射器
- en: The other way to use particle systems is to configure them as emitters. This
    means that there is a ratio of particles per second that your system emits while
    it is active.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用粒子系统的另一种方法是将其配置为发射器。这意味着在系统活跃时，它每秒发射的粒子数有一个比率。
- en: Calculating the right pool size is quite easy. It is just a formula based on
    the particle's time to live and the number of particles per second you want. For
    example, using 20 particles per second with 500 milliseconds time to live, you
    only need a pool of 10 particles, since they are returned to the pool as they
    die.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 计算正确的池大小相当简单。它只是一个基于粒子存活时间和你想要的每秒粒子数量的公式。例如，使用每秒20个粒子，500毫秒的存活时间，你只需要一个包含10个粒子的池，因为它们在死亡时会被返回到池中。
- en: 'It is important to remember that a `ParticleSystem` working as an emitter needs
    to be added and removed from the `GameEngine`, since the `onUpdate` method is
    required to check for the spawning of more particles. The `onUpdate` method of
    the `ParticleSystem` looks like this:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，作为发射器的`ParticleSystem`需要被添加到`GameEngine`中，并从其中移除，因为需要`onUpdate`方法来检查更多粒子的生成。`ParticleSystem`的`onUpdate`方法如下所示：
- en: '[PRE156]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The code is quite simple. First we check weather the system is emitting or not.
    If the system is not emitting, we do not need to update anything, so we can simply
    return.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。首先我们检查系统是否在发射。如果系统没有在发射，我们不需要更新任何东西，所以我们可以简单地返回。
- en: If it is emitting, we check whether we have to activate a particle. For this,
    we compare the number of particles that we have activated with the number of particles
    that should have been activated (*particlesPerMillisecond*totalMilliseconds*).
    We also need to be sure that we can have a particle from the pool (it is not empty).
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它在发射，我们检查是否需要激活一个粒子。为此，我们比较我们已激活的粒子数量与应该激活的粒子数量（*particlesPerMillisecond*totalMilliseconds*）。我们还需要确保可以从池中获取一个粒子（它不是空的）。
- en: Once we know that we need to spawn a particle and we have some particles available,
    we proceed to the activation. The last line on the `activateParticle` method increases
    the counter of activated particles.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们需要生成一个粒子并且有一些粒子可用，我们就进行激活。`activateParticle`方法的最后一行增加了激活粒子的计数器。
- en: Note that the number of activated particles is the total number of particles
    that have been activated by the emitter and not the current number of active particles.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，激活的粒子数量是发射器激活的总粒子数量，而不是当前活跃粒子的数量。
- en: 'The emit method from `ParticleSystem` is as follows:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`的发射方法如下所示：'
- en: '[PRE157]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Easy enough; it resets the number of activated particles and the time counter.
    It also calculates the rate of particles per millisecond (the parameter is passed
    as particles per second) and then sets `mIsEmitting` to `true`, so the `onUpdate`
    method should work.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单；它重置了激活粒子的数量和时间计数器。它还计算每毫秒的粒子率（参数以每秒粒子数传递）并将`mIsEmitting`设置为`true`，这样`onUpdate`方法应该可以工作。
- en: 'Finally, to stop emitting we just need to set `mIsEmitting` to `false`:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要停止发射，我们只需将`mIsEmitting`设置为`false`：
- en: '[PRE158]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Let's look at some examples of emitters.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些发射器的例子。
- en: Asteroid trails
  id: totrans-1413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小行星尾迹
- en: 'Asteroids will look a lot cooler if they leave a trail behind them. Inside
    the constructor of the `Asteroid` class, we will create a `ParticleSystem` for
    the trail in the same place as the one for the explosion:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果陨石留下尾迹，它们看起来会酷得多。在`Asteroid`类的构造函数中，我们将在与小行星爆炸相同的地点创建尾迹的`ParticleSystem`：
- en: '[PRE159]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: For this trail, we are using a particle, that is two small pieces. To give a
    better feel of a trail, we add a `ScaleModifier` together with the fade out.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个尾迹，我们使用一个粒子，即两个小块。为了更好地体现尾迹的感觉，我们添加了一个`ScaleModifier`以及渐隐效果。
- en: 'We want an initialization that depends on the values of the asteroid. To do
    so, we will set all the initializers during the call to `init` of the asteroid:'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望初始化依赖于陨石的价值。为此，我们将在调用陨石的`init`方法期间设置所有初始化器：
- en: '[PRE160]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: First, we clean all the initializers and then set it to have any rotation. The
    rotation speed will be the same as the rotation speed of the asteroid. Then, the
    linear speed will be proportional and swapped from the asteroid components. This
    will make the trail move perpendicular to the asteroid.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们清理所有初始化器，然后将其设置为任何旋转。旋转速度将与小行星的旋转速度相同。然后，线性速度将与小行星组件成比例并交换。这将使尾迹垂直于小行星移动。
- en: 'The point of emission of the `ParticleSystem` needs to be updated on each run
    of `onUpdate` on the asteroid to keep emitting from the right position:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`的发射点需要在每次`onUpdate`运行时更新，以确保从正确的位置发射：'
- en: '[PRE161]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Since it is an emitter, it needs to be added to and removed from the `GameEngine`
    together with the `Asteroid`. For this, we have already defined the `addToGameEngine`
    and `removeFromGameEngine` methods. We will override them now:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个发射器，它需要与小行星一起添加到和从`GameEngine`中移除。为此，我们已定义了`addToGameEngine`和`removeFromGameEngine`方法。我们现在将覆盖它们：
- en: '[PRE162]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Note that we add it to the `GameEngine` one layer below the asteroids, so the
    particle system always goes behind them and not the other way around.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将它添加到`GameEngine`中，位于小行星之下的一层，因此粒子系统总是位于它们之后，而不是相反。
- en: 'With this, we have all the pieces in place and we can see how much nicer our
    asteroids look now:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经将所有部件就位，现在我们可以看到我们的陨石看起来有多漂亮：
- en: '![Asteroid trails](img/B04757_05_04.jpg)'
  id: totrans-1426
  prefs: []
  type: TYPE_IMG
  zh: '![陨石尾迹](img/B04757_05_04.jpg)'
- en: The spaceship's engine
  id: totrans-1427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宇宙飞船的引擎
- en: 'For the last effect, we will add some smoke to the spaceship. Because it is
    an emitter, it needs to honor the `GameObject` lifecycle by adding and removing
    it from the `GameEngine` together with the player object, as we did for the asteroid
    trail:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个效果，我们将在宇宙飞船上添加一些烟雾。因为它是一个发射器，它需要通过添加和移除它与`GameEngine`中的玩家对象一起遵守`GameObject`生命周期，就像我们为小行星尾迹所做的那样：
- en: '[PRE163]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Inside the `onUpdate` method, we have to synchronize the position of the player
    with the emitter of the `ParticleSystem`, as we did with the asteroid:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onUpdate`方法内部，我们必须同步玩家的位置与`ParticleSystem`的发射器，就像我们处理小行星那样：
- en: '[PRE164]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Note that we are setting the emitter at the bottom of the spaceship instead
    of the center. This makes the smoke appear in the right place.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将发射器设置在宇宙飞船的底部而不是中心。这使得烟雾出现在正确的位置。
- en: 'Finally, we will create the `ParticleSystem` in the constructor of the `Player`
    object at the same place we are already creating the other two for the explosions:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`Player`对象的构造函数中创建`ParticleSystem`，与我们已经为爆炸创建的其他两个对象在同一位置：
- en: '[PRE165]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: These configuration methods are all well-known to us by now.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置方法我们现在都很熟悉。
- en: We have the whole range of the initial rotation [0-360] and a rotation speed
    that goes from -30 to 30 degrees per second. We also have a much longer fade out
    for other systems to make it dissolve in a smooth way.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有整个初始旋转范围[0-360]，旋转速度从每秒-30度到30度。我们还为其他系统设置了更长的渐隐效果，以便使其平滑溶解。
- en: We also use `setSpeedModuleAndAngleRange`, which sets the speed in terms of
    the angle and module. We want the smoke to get out of the spaceship in the range
    of [60-120] degrees (that is, an arc of 60 degrees going to the bottom of the
    spaceship) and with a speed that does not vary much.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`setSpeedModuleAndAngleRange`，它根据角度和模块设置速度。我们希望烟雾在[60-120]度（即60度弧线延伸到宇宙飞船底部）的范围内排出，并且速度变化不大。
- en: 'You can run it now and see how it looks:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行它，看看效果如何：
- en: '![The spaceship''s engine](img/B04757_05_05.jpg)'
  id: totrans-1439
  prefs: []
  type: TYPE_IMG
  zh: '![宇宙飞船的引擎](img/B04757_05_05.jpg)'
- en: While looking at a static image, you can see each particle, but when they are
    in motion, it feels really good.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看静态图像时，你可以看到每个粒子，但当他们运动时，感觉真的很好。
- en: Optionally, you could start this particle system if there is some user input
    during `onUpdate` and stop it if not, which will give a more dynamic look and
    feel, since the smoke will appear only when the spaceship is moving.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以在`onUpdate`期间有用户输入时启动这个粒子系统，如果没有则停止它，这将使游戏看起来更加动态，因为烟雾只有在飞船移动时才会出现。
- en: Summary
  id: totrans-1442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have learned how particle systems work and how to integrate them into our
    game. We included `ParticleSystem` and the particles themselves into our `GameEngine`.
    We also learned about initializers and modifiers and how to create new ones to
    extend the system if we want to.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了粒子系统的工作原理以及如何将其集成到我们的游戏中。我们将`ParticleSystem`和粒子本身集成到`GameEngine`中。我们还学习了初始化器和修改器以及如何创建新的来扩展系统，如果我们想的话。
- en: Then we saw how to compose a `GameObject` that has other `GameObject` instances
    inside it. In particular, particle systems do normally belong to another `GameObject`.
    For this, the `ParticleSystem` hooks into the lifecycle of the `GameObject`. We
    updated the `GameEngine` to make it easier to add `GameObjects` that are compositions.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何组合一个包含其他`GameObject`实例的`GameObject`。特别是，粒子系统通常属于另一个`GameObject`。为此，`ParticleSystem`连接到`GameObject`的生命周期。我们更新了`GameEngine`，使其更容易添加组合的`GameObjects`。
- en: Finally, we examined two examples of one shots and two examples of emitters
    that covered a variety of different parameters.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查了两个一次性声音效果示例和两个发射器示例，涵盖了各种不同的参数。
- en: 'All in all, these four `ParticleSystem` instances make the game feel much more
    alive. Let''s move on to the last step of making the game feel alive: sound effects.'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这四个`ParticleSystem`实例使游戏感觉更加生动。让我们继续到最后一步，让游戏感觉生动：声音效果。
- en: Chapter 6. Sound FX and Music
  id: totrans-1447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 声音效果和音乐
- en: A game feels incomplete without sound. In this chapter we will explore the different
    options for playing sound effects and music in Android, we will build a `SoundManager`
    class to handle them, and we will see how it interacts with the `GameEngine`.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 没有声音的游戏感觉不完整。在本章中，我们将探讨在Android中播放声音效果和音乐的多种选项，我们将构建一个`SoundManager`类来处理它们，并看看它是如何与`GameEngine`交互的。
- en: For sound effects we will use `SoundPool`, which has been specifically designed
    for playing small sounds by preloading them in memory. To trigger the sound effects,
    we will introduce the concept of `GameEvent` and learn how they are propagated
    through the `GameEngine`.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 对于声音效果，我们将使用`SoundPool`，它专门设计用于通过预先加载到内存中来播放小声音。为了触发声音效果，我们将介绍`GameEvent`的概念，并学习它们是如何通过`GameEngine`传播的。
- en: In the case of background music, we will use `MediaPlayer` directly since long
    tracks do not work well with `SoundPool`, and `MediaPlayer` is the generic solution
    for playing all types of media files.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 在背景音乐的情况下，我们将直接使用`MediaPlayer`，因为长曲目与`SoundPool`配合不佳，而`MediaPlayer`是播放所有类型媒体文件的通用解决方案。
- en: Finally, we will add controls to enable and disable sound effects and music
    on the home screen and make `SoundManager` take care of them.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加控件以在主页上启用和禁用声音效果和音乐，并让`SoundManager`负责它们。
- en: SoundManager
  id: totrans-1452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SoundManager
- en: 'To manage sounds and music, we are going to have a class called `SoundManager`.
    This class will be instantiated only once along the `Application` code and it
    will be done at `onCreate` of `YassActivity`. There are several reasons to do
    this:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理声音和音乐，我们将有一个名为`SoundManager`的类。这个类将仅在`Application`代码中实例化一次，并且将在`YassActivity`的`onCreate`方法中完成。这样做有几个原因：
- en: Sound effects do take a little time to be loaded, so it is better to load them
    in advance
  id: totrans-1454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音效果确实需要一点时间来加载，因此最好提前加载它们
- en: We may want to use sounds and music in the menus
  id: totrans-1455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想在菜单中使用声音和音乐
- en: Loading sounds and music requires memory; it does not make sense to duplicate
    that
  id: totrans-1456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载声音和音乐需要内存；重复加载是没有意义的
- en: 'Let''s look at the modifications we need to make to `YassActivity`:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要对`YassActivity`进行的修改：
- en: '[PRE166]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: We have a field that contains the `SoundManager`, and we initialize it during
    the `onCreate` method. We also provide a getter method for it.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含`SoundManager`的字段，我们将在`onCreate`方法中初始化它。我们还提供了它的getter方法。
- en: 'There is another line that requires special mention:'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一行需要特别提及：
- en: '[PRE167]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This code sets the volume control stream of the application to be music. It
    tells the operating system that, when we press the physical volume keys while
    our application is running, we want it to modify the music volume instead of the
    default volume. There are seven stream types on Android, one for each sound type,
    from system and ring tone volumes to alarms and notifications.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将应用程序的音量控制流设置为音乐。它告诉操作系统，当我们的应用程序正在运行时按下物理音量键，我们希望它修改音乐音量而不是默认音量。在 Android
    上有七种流类型，每种声音类型一种，从系统音量和铃声音量到闹钟和通知。
- en: Note
  id: totrans-1463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To make the volume keys act over the music volume if pressed while the game
    is running, we should call `setVolumeControlStream(AudioManager.STREAM_MUSIC)`
    in the Activity.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在游戏运行时按下音量键，我们应该在 Activity 中调用 `setVolumeControlStream(AudioManager.STREAM_MUSIC)`
    来使音量键控制音乐音量。
- en: Since we will be playing sound, this small tweak is very important to allow
    the user to control the volume of sounds during the course of the game.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将播放声音，这个小的调整非常重要，以便用户可以在游戏过程中控制声音的音量。
- en: '`SoundManager` will take care of the sounds and music using different classes
    from the Android SDK. It will also provide different methods to access them. Sound
    effects and music are independent features in the `SoundManager` class, so we
    will look at each of them separately.'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundManager` 将使用 Android SDK 中的不同类来处理声音和音乐。它还将提供不同的方法来访问它们。音效和音乐是 `SoundManager`
    类中的独立功能，因此我们将分别查看每个功能。'
- en: Sound FX
  id: totrans-1467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音效FX
- en: Sound effects will be used for events in the game such as explosions, firing
    bullets, and so on, but also could be used in other cases such as menu clicks
    and dialogs appearing. In our game we will add sound effects to the explosions
    of the asteroids and the spaceship as well as for laser firing.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 音效将用于游戏中的事件，如爆炸、开火等，也可以用于其他情况，如菜单点击和对话框出现。在我们的游戏中，我们将为小行星和宇宙飞船的爆炸以及激光发射添加音效。
- en: We will begin discussing some ways to get sound effects for games. We cannot
    work if we don't have sound files, right?
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始讨论一些获取游戏音效的方法。如果我们没有音文件，我们无法工作，对吧？
- en: Once we have our sounds in place, we will update `GameEngine` to provide a way
    to signal events in the game, and we will let `SoundManager` know when one of
    those events happens.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们放置了声音，我们将更新 `GameEngine` 以提供一种在游戏中发出信号的方式，并且我们将让 `SoundManager` 知道当这些事件中的任何一个发生时。
- en: Finally we will explain how `SoundPool` works and how to include it in our `SoundManager`,
    associating a game event to a sound effect.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将解释 `SoundPool` 的工作原理以及如何将其包含在我们的 `SoundManager` 中，将游戏事件与音效关联起来。
- en: Hands on—let's get some sound files.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 亲身体验——让我们获取一些音文件。
- en: How to create sound FXs
  id: totrans-1473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何创建音效
- en: For indie developers, there are a few places where you can get sound effects.
    The already mentioned `OpenGameArt` not only has graphics but also sounds. One
    of the best places to find sound effects for games is the website [www.freesound.org](http://www.freesound.org)
    (formerly "The Free Sound Project").
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于独立开发者来说，有几个地方可以获取音效。之前提到的 `OpenGameArt` 不仅提供图形，还有声音。寻找游戏音效的最佳地方之一是网站 [www.freesound.org](http://www.freesound.org)（以前称为“免费声音项目”）。
- en: '![How to create sound FXs](img/B04757_06_01.jpg)'
  id: totrans-1475
  prefs: []
  type: TYPE_IMG
  zh: '![如何创建音效](img/B04757_06_01.jpg)'
- en: 'In its own words: Freesound aims to create a huge collaborative database of
    audio snippets, samples, recordings, bleeps, and so on released under Creative
    Commons licenses that allow their reuse. Freesound provides new and interesting
    ways to access these samples, allowing users to browse the sounds in new ways
    using keywords, a "sounds-like" type of browsing, and more.'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 用它自己的话来说：Freesound 致力于创建一个巨大的协作数据库，包含在 Creative Commons 许可下发布的音频片段、样本、录音、哔哔声等，允许其重用。Freesound
    提供了新的和有趣的方式来访问这些样本，允许用户使用关键词、一种“听起来像”的浏览方式以及更多方式来浏览声音。
- en: Note
  id: totrans-1477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Freesound.org is a great sound database under Creative Commons licenses.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: Freesound.org 是一个在 Creative Commons 许可下的优秀声音数据库。
- en: It may take you a while to browse to the sounds you need, but this is a really
    useful resource. We used it when making Chalk Ball and SpaceCat at The Pill Tree.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到所需的声音可能需要一些时间，但这确实是一个非常有用的资源。我们在制作 The Pill Tree 的 Chalk Ball 和 SpaceCat
    时使用了它。
- en: 'For games that require simple sounds in a retro style, there is another project
    that is interesting: Bfxr ([www.bfxr.net/](http://www.bfxr.net/))'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要复古风格简单声音的游戏，还有一个有趣的项目：Bfxr ([www.bfxr.net/](http://www.bfxr.net/))
- en: Note
  id: totrans-1481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bfxr is a simple and handy utility to create retro-style sound effects.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: Bfxr 是一个简单便捷的工具，用于创建复古风格的音效。
- en: Bfxr allows you to do a lot with sound waves, but you do not need to be an expert
    because it also has some buttons that will generate a new random sound based on
    certain parameters. These buttons are used for shoots, pickup, powerups, hits,
    and so on. Bfxr is inspired by as3sfxr, which is also simpler.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: Bfxr允许你对声音波进行很多操作，但你不需要是专家，因为它还有一些按钮，可以根据某些参数生成新的随机声音。这些按钮用于射击、拾取、加成、击中等等。Bfxr受到了as3sfxr的启发，它也更简单。
- en: '![How to create sound FXs](img/B04757_06_02.jpg)'
  id: totrans-1484
  prefs: []
  type: TYPE_IMG
  zh: '![如何创建声音效果](img/B04757_06_02.jpg)'
- en: The UI of the web version of bfxr
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: bfxr网页版的UI
- en: You have full rights to all sounds made with bfxr, therefore you are free to
    use them for any purposes, commercial or otherwise.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 你对使用bfxr制作的所有声音拥有完全的权利，因此你可以自由地用于任何目的，无论是商业的还是其他目的。
- en: For YASS we have used bfxr to generate a few explosions and laser sounds and
    then picked the ones we liked better. You can make your own and it will take you
    only a few minutes.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 对于YASS，我们使用了bfxr生成了一些爆炸声和激光声，然后挑选了我们更喜欢的一些。你可以自己制作，这只需要几分钟。
- en: Now that we have the sounds, we need a place to put them inside our project.
    We could store the sounds as raw resources (under `res/raw`) but it is more handy
    to have them inside the `assets` folder, where we can have a hierarchical structure
    and there is no restriction on the file naming.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了声音，我们需要一个地方将它们放入我们的项目中。我们可以将声音作为原始资源（在`res/raw`下）存储，但将它们放在`assets`文件夹中会更方便，在那里我们可以有一个分层结构，并且对文件命名没有限制。
- en: Note
  id: totrans-1489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We store the sound files under the `assets` folder.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声音文件存储在`assets`文件夹下。
- en: We have to create the `assets` folder under the `src/main` directory of the
    project. Inside the `assets` folder we will create another folder called `sfx`
    for all our sound files.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在项目的`src/main`目录下创建`assets`文件夹。在`assets`文件夹内，我们将创建一个名为`sfx`的文件夹来存放所有的声音文件。
- en: GameEvents
  id: totrans-1492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏事件
- en: 'As we mentioned, we are going to link sound effects to `GameEvents`, so first
    we need our `GameEngine` to have support for such `GameEvents`. For that we create
    an enum that contains the `GameEvents` we are interested in:'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，我们将把声音效果链接到`GameEvents`，所以首先我们需要我们的`GameEngine`支持这样的`GameEvents`。为此，我们创建了一个枚举，其中包含了我们感兴趣的`GameEvents`：
- en: '[PRE168]'
  id: totrans-1494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '`GameEvents` will be propagated across the `GameEngine` in a way similar to
    a `BroadcastReceiver` or an `EventBus`. We create a new method `onGameEvent` in
    `GameEngine`. This method will be called when a `GameEvent` happens.'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEvents`将以类似于`BroadcastReceiver`或`EventBus`的方式在`GameEngine`中传播。我们在`GameEngine`中创建了一个新的方法`onGameEvent`。当发生`GameEvent`时，将调用此方法。'
- en: '[PRE169]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: When a `GameEvent` arrives, we communicate it to the `SoundManager`. It will
    be easy to have all `GameObjects` subscribed to `GameEvents` by just adding a
    loop over the `GameObjects` inside this method.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 当`GameEvent`到达时，我们将它传达给`SoundManager`。只需在这个方法中添加一个遍历`GameObjects`的循环，就可以轻松地让所有`GameObjects`订阅`GameEvents`。
- en: 'The only thing left is to trigger the events when they happen. Let''s see the
    ones triggered from the `Player` object:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是在事件发生时触发它们。让我们看看从`Player`对象触发的那些事件：
- en: '[PRE170]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Because the `GameEvents` happen during `onUpdate`, we always have a reference
    to the `GameEngine` at hand, and sending the event is as simple as adding a method
    call in the right place. The `Player` object now communicates the events of `LaserFired`
    and `SpaceshipHit` to the `GameEngine`.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`GameEvents`发生在`onUpdate`中，所以我们总是手头有一个`GameEngine`的引用，发送事件就像在正确的位置添加一个方法调用一样简单。现在`Player`对象将`LaserFired`和`SpaceshipHit`事件的通信传递给`GameEngine`。
- en: Bullet does trigger a `GameEvent` as well.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹也会触发一个`GameEvent`。
- en: '[PRE171]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Now that the events are triggered and they reach the `SoundManager`, we have
    to actually play the specific sound when the event arrives. For that we need to
    build and configure the `SoundPool`.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事件被触发并且达到`SoundManager`时，我们必须在事件到达时实际播放特定的声音。为此，我们需要构建和配置`SoundPool`。
- en: Using SoundPool
  id: totrans-1504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SoundPool
- en: '`SoundPool` is a utility designed to play multiple short sound files with low
    latency playback. It does preloading of the files and it allows us to play several
    of them at the same time. The initial constructor for `SoundManager` will look
    like this:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundPool`是一个用于以低延迟播放多个短声音文件的实用工具。它预先加载文件，并允许我们同时播放多个文件。`SoundManager`的初始构造函数将看起来像这样：'
- en: '[PRE172]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: We are going to have a method that loads the sounds. At the moment this is used
    only once but later on, when we add a setting to enable or disable them, the sounds
    could be loaded and unloaded multiple times.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个加载声音的方法。目前这仅使用一次，但稍后，当我们添加一个启用或禁用它们的设置时，声音可以被多次加载和卸载。
- en: There is a specific method to handle the creation of the `SoundPool` because
    the default constructor has been deprecated on Lollipop and the new way of building
    it is quite verbose and not backwards-compatible; we need to branch the code based
    on the OS version.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lollipop上默认构造函数已被弃用，而构建它的新方法相当冗长且不向后兼容；我们需要根据操作系统版本分支代码。
- en: '[PRE173]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Both ways of building the `SoundPool` receive the same kind of parameters, but
    while the old one is just one constructor, the new one uses a builder and `AudioAttributes`.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这两种方式的`SoundPool`接收相同类型的参数，但旧的那个只有一个构造函数，而新的一个使用构建器和`AudioAttributes`。
- en: 'The parameters of the now deprecated constructor are:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已弃用的构造函数的参数是：
- en: '**Max streams**: Maximum number of simultaneous streams to be played.'
  id: totrans-1512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大流数**：同时播放的最大流数。'
- en: '**Stream type**: the audio stream type as described in `AudioManager`. Games
    should use `STREAM_MUSIC`.'
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流类型**：在`AudioManager`中描述的音频流类型。游戏应使用`STREAM_MUSIC`。'
- en: '**Src quality**: The sample-rate converter quality. It has no effect, so we
    just use 0.'
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Src质量**：采样率转换器的质量。它没有效果，所以我们只使用0。'
- en: The new way of building the `SoundPool` replaces the stream type with the usage
    and content type of `AudioAttributes`, but you could use the legacy system type
    instead of these parameters and set it to `AudioManager.STREAM_MUSIC` if you prefer.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 构建新方法的`SoundPool`用`AudioAttributes`的使用和内容类型替换了流类型，但您也可以使用旧系统类型代替这些参数，如果您愿意，可以将它设置为`AudioManager.STREAM_MUSIC`。
- en: The parameter of max streams has the exact same meaning as before. `SoundPool`
    tracks the number of active streams. If the maximum number of streams is exceeded,
    `SoundPool` will automatically stop a previously playing one, based first on priority
    and then by age within that priority.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 最大流数的参数与之前完全相同。`SoundPool`跟踪活动流的数量。如果超过最大流数，`SoundPool`将自动停止之前播放的一个，首先基于优先级，然后在同一优先级内按年龄排序。
- en: Note
  id: totrans-1517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`SoundPool` is designed to play small sound files with low latency playback.'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundPool`旨在播放小声音文件，具有低延迟播放。'
- en: Using `SoundPool` is quite easy. When we load a file into the `SoundPool`, it
    will return a sound ID, which we need to use to play the sound later.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SoundPool`相当简单。当我们把一个文件加载到`SoundPool`中时，它会返回一个声音ID，我们需要使用这个ID来稍后播放声音。
- en: To store those sound IDs we will have a map inside `SoundManager` that has a
    `GameEvent` as key and `Integer` as the type of the values.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储这些声音ID，我们将在`SoundManager`内部有一个映射，它以`GameEvent`作为键，以`Integer`作为值的类型。
- en: '[PRE174]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We now create a method that loads a file into the `SoundPool` and associates
    it to a `GameEvent`:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建一个方法，将文件加载到`SoundPool`中并将其与`GameEvent`关联：
- en: '[PRE175]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`SoundPool` has several methods for loading files regarding of where they are
    located. Since our sound files are in `assets`, we need to use the one that receives
    an `AssetFileDescriptor`.'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundPool`有几种加载文件的方法，无论它们位于何处。由于我们的声音文件在`assets`中，我们需要使用接收`AssetFileDescriptor`的那个方法。'
- en: The load method also receives the priority as a parameter. The official documentation
    says that this currently has no effect and we should use 1 for future compatibility,
    so we do.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 加载方法也接收优先级作为参数。官方文档表示，这目前没有效果，我们应该为了未来的兼容性使用1，所以我们这样做。
- en: Finally we store the sound ID into the map.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将声音ID存储到映射中。
- en: We can get an `IOException` if the file we are trying to open does not exist.
    It is interesting to print the stack trace if we miss some sounds while playing,
    to check for possible typos.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试打开的文件不存在，我们可能会得到一个`IOException`。如果我们播放时遗漏了一些声音，打印堆栈跟踪是有趣的，以检查可能的错误。
- en: 'It is time to look at `loadSounds`, which effectively combines all the code
    that we have seen until now:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看`loadSounds`了，它有效地结合了我们迄今为止所看到的所有代码：
- en: '[PRE176]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Simple enough—we create the `SoundPool` and the sounds map. Then we load three
    sound files and associate them to the `GameEvents`.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单——我们创建`SoundPool`和声音映射。然后我们加载三个声音文件并将它们与`GameEvents`关联。
- en: 'We also have a method to unload the sounds:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个卸载声音的方法：
- en: '[PRE177]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: To unload the sounds, we release the sound pool and clear the sound map.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载声音，我们释放声音池并清除声音映射。
- en: The official documentation tells us to release the `SoundPool` and set it to
    null; then create a new one when loading a new set of sounds instead of unloading
    each of the sound effects. That is why a new `SoundPool` is created at the beginning
    of `loadSounds` instead of in the constructor of `SoundManager`.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档建议我们释放 `SoundPool` 并将其设置为 null；在加载一组新的声音时，创建一个新的 `SoundPool` 而不是卸载每个声音效果。这就是为什么在
    `loadSounds` 的开始处创建一个新的 `SoundPool` 而不是在 `SoundManager` 的构造函数中。
- en: 'At last we are ready to play a sound when a `GameEvent` arrives:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当 `GameEvent` 到达时我们准备播放声音：
- en: '[PRE178]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: We get the sound ID from the map and, if it is not null, we play it. This check
    is important to make the game future-proof, when we evolve it to support more
    `GameEvents` and some of them do not have sound associated.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从映射中获取声音 ID，如果它不是 null，我们就播放它。这个检查对于使游戏面向未来很重要，当我们将其扩展以支持更多的 `GameEvents`
    并且其中一些没有关联声音时。
- en: 'The parameters for the play method of `SoundPool` are:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundPool` 的播放方法参数如下：'
- en: '**Left volume**: Self-explanatory. A float value between 0.0 and 1.0.'
  id: totrans-1539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左声道音量**：不言而喻。一个介于 0.0 和 1.0 之间的浮点值。'
- en: '**Right volume**: Also self-explanatory. A float value between 0.0 and 1.0.'
  id: totrans-1540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右声道音量**：同样不言而喻。一个介于 0.0 和 1.0 之间的浮点值。'
- en: '**Priority**: 0 means lowest priority; all our sounds will have the same priority.
    It is used to select the sound to stop when the maximum number of streams is reached.'
  id: totrans-1541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：0 表示最低优先级；我们所有的声音都将具有相同的优先级。它用于在达到最大流数时选择停止播放的声音。'
- en: '**Loop**: A loop value of -1 means loop forever, a value of 0 means don''t
    loop, and other values indicate the number of repeats. We don''t want to loop
    our sounds, so we pass 0.'
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**：-1 的循环值表示无限循环，0 的值表示不循环，其他值表示重复次数。我们不想循环我们的声音，所以我们传递 0。'
- en: '**Rate**: A value of 1.0 means play back at the original frequency. A value
    of 2.0 means play back twice as fast, and a value of 0.5 means playback at half
    speed. The range is from 0.5 to 2.0.'
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率**：1.0 的值表示以原始频率播放。2.0 的值表示以两倍速度播放，0.5 的值表示以半速播放。范围是 0.5 到 2.0。'
- en: You could improve the feeling of the sound by tweaking the left and right volume
    based on the position of the event on the screen but we are not going to get into
    that, so we just use 1.0 for both left and right volumes.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过根据事件在屏幕上的位置调整左右声道音量来改善声音的感觉，但我们不会深入探讨这一点，所以我们只使用 1.0 作为左右声道音量。
- en: The play method will return a stream ID that we could use to pause or resume
    this sound. Since we are using very short sounds that do not loop and are not
    interrupted, we do not need to store the stream ID at all.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 播放方法将返回一个流 ID，我们可以使用它来暂停或继续播放此声音。由于我们使用的是非常短的声音，它们不循环且不会被中断，所以我们根本不需要存储流 ID。
- en: Note that calling play may cause another sound to stop playing if the maximum
    number of active streams is exceeded.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果超过最大活动流数，调用 play 可能会导致另一个声音停止播放。
- en: With this architecture of `SoundManager`, it is very easy to add new sound effects
    by just associating them to a `GameEvent` and triggering the event from whatever
    `GameObject` produces it.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 `SoundManager` 架构，只需将它们关联到 `GameEvent` 并从产生它的任何 `GameObject` 触发事件，就可以很容易地添加新的声音效果。
- en: Playing music
  id: totrans-1548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐
- en: The other type of sound that a game contains is background music. These tracks
    are usually longer than the sound effects and are played in a loop. In some cases
    there may be more than one track, for example, if we want a music for the menu
    and another one for the level, or if we want several levels with different background
    music tracks. We will work with a single one, but it is very easy to extend it
    to multiple tracks.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中包含的另一种声音类型是背景音乐。这些曲目通常比声音效果长，并且循环播放。在某些情况下可能有多个曲目，例如，如果我们想要菜单和关卡的音乐，或者如果我们想要几个具有不同背景音乐曲目的关卡。我们将只处理一个，但很容易将其扩展到多个曲目。
- en: We are going to use `MediaPlayer` to play the background music in our game and
    we are going to abstract it via `SoundManager` as well, providing methods to pause
    and resume the music when the activity is paused and resumed.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `MediaPlayer` 在游戏中播放背景音乐，并且我们也将通过 `SoundManager` 抽象化它，提供在活动暂停和恢复时暂停和继续播放音乐的方法。
- en: Obtaining music
  id: totrans-1551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取音乐
- en: As with sound effects, we need some tracks to work with. When it comes to making
    games on a budget, one of the best places to look for music that can be used for
    free is Jamendo.com. There are lots of albums under Creative Commons license,
    some of them very reasonably priced when it comes to using them to make commercial
    products, and most of them only require attribution (also known as giving credit
    to the artist).
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 就像音效一样，我们需要一些音轨来工作。当涉及到在预算有限的条件下制作游戏时，寻找可以免费使用的音乐的最佳地方之一是Jamendo.com。那里有许多在Creative
    Commons许可下的专辑，其中一些在用于制作商业产品时价格非常合理，而且大多数只需要署名（也称为向艺术家致谢）。
- en: '![Obtaining music](img/B04757_06_03.jpg)'
  id: totrans-1553
  prefs: []
  type: TYPE_IMG
  zh: '![获取音乐](img/B04757_06_03.jpg)'
- en: Jamendo is a great resource for Creative Commons music
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: Jamendo是Creative Commons音乐的绝佳资源
- en: We are going to use a track from Riccardo Colombo, entitled "Something mental",
    which has a nice ambient sound. We will also place that sound under the `sfx`
    folder we created inside `assets`.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Riccardo Colombo的一首名为"Something mental"的音轨，它有一个很好的环境音效。我们还将将该音效放置在我们创建在`assets`内部的`sfx`文件夹中。
- en: On Android, MP3 files normally work fine, but OGG usually produces more consistent
    and reliable behavior among the different devices and hardware capabilities. You
    can convert any MP3 to OGG using an audio editor such as Audacity ([http://audacity.sourceforge.net/](http://audacity.sourceforge.net/)).
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，MP3文件通常工作得很好，但OGG在不同的设备和硬件能力之间通常会产生更一致和可靠的行为。您可以使用Audacity（[http://audacity.sourceforge.net/](http://audacity.sourceforge.net/)）等音频编辑器将任何MP3转换为OGG。
- en: MediaPlayer
  id: totrans-1557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MediaPlayer
- en: '`MediaPlayer` is quite straight forward to use, but it also has a complicated
    life cycle and it is very strict in its usage. It can give problems if not used
    exactly as intended.'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaPlayer`的使用非常直观，但它也有一个复杂的生命周期，并且对其使用非常严格。如果使用不当，可能会出现问题。'
- en: The life cycle consists of several states and methods. While in a state, only
    a few methods can be called. Because of this, the invocation of the method calls
    must be done in precise sequence to move from one state to the next. If you call
    a method that is not allowed in the current state of `MediaPlayer`, it will crash
    with a cryptic error. Also, there is no method to know the current state of the
    MediaPlayer.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期由几个状态和方法组成。在某个状态下，只有少数方法可以被调用。因此，必须按照精确的顺序调用方法调用，以从一个状态移动到下一个状态。如果您调用`MediaPlayer`当前状态不允许的方法，它将崩溃并显示一个神秘的错误。此外，没有方法可以知道MediaPlayer的当前状态。
- en: Note
  id: totrans-1560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you call a method that is not allowed in the current state of `MediaPlayer`,
    it will crash with a cryptic error.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`MediaPlayer`当前状态不允许的方法，它将崩溃并显示一个神秘的错误。
- en: '![MediaPlayer](img/B04757_06_04.jpg)'
  id: totrans-1562
  prefs: []
  type: TYPE_IMG
  zh: '![MediaPlayer](img/B04757_06_04.jpg)'
- en: But do not worry, we are going to use it in the simplest way possible.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 但不用担心，我们将以最简单的方式使用它。
- en: 'What we are going to do is take the following actions to load the track:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行以下操作来加载音轨：
- en: Create the `MediaPlayer` object, so it is in the **Idle** state.
  id: totrans-1565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MediaPlayer`对象，使其处于**空闲**状态。
- en: Set the data source, so it becomes **Initialized**.
  id: totrans-1566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据源，使其变为**初始化**状态。
- en: Call `prepare`. This moves `MediaPlayer` to the **Prepared** state.
  id: totrans-1567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`prepare`。这将`MediaPlayer`移动到**准备**状态。
- en: From **Prepared**, we will call `start`, so it moves to **Started**.
  id: totrans-1568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**准备**状态，我们将调用`start`，使其移动到**开始**状态。
- en: While playing we may `pause` the stream, moving to **Paused**. And from **Paused**
    we can call `start` again to go back to **Started**.
  id: totrans-1569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在播放过程中，我们可以`暂停`流，移动到**暂停**状态。然后从**暂停**状态我们可以再次调用`start`以回到**开始**状态。
- en: 'We will also have a method to unload the track so the music can be enabled
    and disabled at any moment. To unload the track we just have to:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个方法来卸载音轨，以便音乐可以在任何时候启用或禁用。要卸载音轨，我们只需：
- en: '**Call stop**. This will work from either **Started** or **Paused**. This call
    will make the music stop.'
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用停止**。这可以从**开始**或**暂停**状态执行。这个调用将使音乐停止。'
- en: '**Call release**. This will move to the **End** status from any other state.
    Note that there is no way to get out of the **End** state, so when we want to
    load the music again, we need to create a new `MediaPlayer` and start again from
    the beginning.'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用释放**。这将从任何其他状态移动到**结束**状态。请注意，没有方法可以退出**结束**状态，因此当我们想要再次加载音乐时，我们需要创建一个新的`MediaPlayer`并从头开始。'
- en: The situation we need to take care of the most is to avoid calling `pause` while
    in the **Prepared** or **Paused** states. That method is not allowed there, and
    will `MediaPlayer` in to a non-working state. However, if you follow the steps
    provided here, you will not have to worry about it.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最小心处理的情况是在**准备**或**暂停**状态下调用`pause`。该方法在那里是不允许的，并且会将`MediaPlayer`置于非工作状态。然而，如果你遵循这里提供的步骤，你就不必担心这个问题。
- en: 'Let''s look at the methods we have in `SoundManager` to handle background music:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`SoundManager`中处理背景音乐的方法：
- en: '[PRE179]'
  id: totrans-1575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The only points we haven''t covered yet are the calls to `setLooping` and `setVolume`.
    They are quite clear on their own: `setLooping` sets the media player into looping
    or not-looping mode based on the parameter; `setVolume` sets the left and right
    volumes for this instance of `MediaPlayer`. For the volume we are using a constant
    `DEFAULT_MUSIC_VOLUME` that we have set to a value of 0.6, so the music is played
    more softly than the sound effects.'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涉及的是对`setLooping`和`setVolume`的调用。它们本身相当清晰：`setLooping`根据参数设置媒体播放器为循环或非循环模式；`setVolume`设置`MediaPlayer`实例的左右音量。对于音量，我们使用一个常量`DEFAULT_MUSIC_VOLUME`，将其设置为0.6，因此音乐的播放音量比音效要小。
- en: 'We can get an `IOException` when loading the music for the same reason we might
    have one with the sound effects: if the file does not exist. As we did earlier,
    if that happens we just log it and continue.'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载音乐时，我们可能会遇到`IOException`，原因与音效相同：如果文件不存在。正如我们之前所做的那样，如果发生这种情况，我们只需记录下来并继续。
- en: Of course we also need to load the music when we initialize the `SoundManager`,
    calling `loadMusic` just after we call `loadSounds`.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要在初始化`SoundManager`时加载音乐，在调用`loadSounds`之后立即调用`loadMusic`。
- en: '[PRE180]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Music and Activity life cycle
  id: totrans-1580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音乐和Activity生命周期
- en: 'In this section we will handle pausing and resuming the music. For that, the
    only thing we need to do is link the `SoundManager` to the Activity life cycle.
    In the next section we will take care of unloading and loading the music on-demand
    when the user changes the preferences:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理暂停和恢复音乐。为此，我们只需要将`SoundManager`链接到Activity生命周期。在下一节中，我们将处理用户更改偏好时按需加载和卸载音乐：
- en: '[PRE181]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Remember that we create the `SoundManager` during `onCreate`. Now we add the
    method calls to pause the music when the activity calls `onPause` and resume it
    when the activity calls `onResume`.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在`onCreate`期间创建了`SoundManager`。现在我们添加方法调用，当活动调用`onPause`时暂停音乐，当活动调用`onResume`时恢复音乐。
- en: This allows us to pause the music when another app comes to the foreground (or
    when the game is put to the background) and then resume it when it returns to
    the foreground.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在其他应用进入前台（或游戏被置于后台）时暂停音乐，并在它返回前台时恢复播放。
- en: Do not allow the user to manually pause or resume the background music; this
    can put `MediaPlayer` into an inconsistent state. Instead of pausing the music,
    we will allow the user to disable music, which is a different process and one
    that we will cover in the next section.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 不要允许用户手动暂停或恢复背景音乐；这可能会使`MediaPlayer`处于不一致的状态。我们不会暂停音乐，而是允许用户禁用音乐，这是一个不同的过程，我们将在下一节中介绍。
- en: Enabling and disabling music and sound FX
  id: totrans-1586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用和禁用音乐和音效
- en: 'Now we have music and sound effects working, but we are missing a very important
    point: allowing the user to disable them. If you add sounds to a game, you need
    to provide a way to disable them. Many people like to play in silence.'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让音乐和音效正常工作，但我们遗漏了一个非常重要的点：允许用户禁用它们。如果你在游戏中添加了音效，你需要提供一个禁用它们的方法。很多人喜欢在静音状态下玩游戏。
- en: Note
  id: totrans-1588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always provide a way for the user to disable music and sound effects individually.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 总是为用户提供一种方法来单独禁用音乐和音效。
- en: To do this, we will add two buttons on the main screen (one for music and one
    for sounds) to enable and disable each one independently. These options should
    also be present on the **Pause** dialog, but we will get into that when we rework
    the dialogs in the next chapter.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在主屏幕上添加两个按钮（一个用于音乐，一个用于音效）来独立启用和禁用每个选项。这些选项也应该出现在**暂停**对话框中，但我们将留到下一章重新设计对话框时再讨论。
- en: On the one hand, we are going to update the layout and the code of `MainMenuFragment`;
    on the other hand, we will make `SoundManager` take care of this configuration.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们将更新`MainMenuFragment`的布局和代码；另一方面，我们将让`SoundManager`负责这项配置。
- en: To store the music and sound state we will use `SharedPreferences`, as it is
    the simplest and most convenient way to store key-value persistent data on Android.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储音乐和声音状态，我们将使用 `SharedPreferences`，因为它是存储 Android 上键值持久数据的简单且方便的方式。
- en: Updating MainMenuFragment
  id: totrans-1593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 `MainMenuFragment`
- en: Until now, a `FrameLayout` has been good enough for us. At this point we want
    to have the sound and music buttons on one side and together, so we need to replace
    it with a `RelativeLayout`.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`FrameLayout` 对我们来说已经足够好了。现在我们希望声音和音乐按钮在一边并且放在一起，所以我们需要将其替换为 `RelativeLayout`。
- en: 'The updated version of `fragment_main.xml` is as follows:'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '`fragment_main.xml` 的更新版本如下：'
- en: '[PRE182]'
  id: totrans-1596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: No specific comments are required. We just have `btn_sound` and `btn_music`
    added to the bottom right and with the correct margins, aligning the music button
    to the bottom of the sound one and placing it to the left of it.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要特定的注释。我们只是在右下角添加了 `btn_sound` 和 `btn_music`，并设置了正确的边距，将音乐按钮对齐到声音按钮的底部，并将其放置在其左侧。
- en: '![Updating MainMenuFragment](img/B04757_06_06.jpg)'
  id: totrans-1598
  prefs: []
  type: TYPE_IMG
  zh: '![更新 `MainMenuFragment`](img/B04757_06_06.jpg)'
- en: The code is a bit more interesting. We have to modify `MainMenuFragment` to
    handle the click on the new buttons as well as to place the correct text on them.
    For this we will modify `onViewCreated` and `onClick` and add a new method to
    place the correct text on each button.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有点更有趣。我们必须修改 `MainMenuFragment` 来处理新按钮的点击，以及放置正确的文本。为此，我们将修改 `onViewCreated`
    和 `onClick` 并添加一个新的方法来放置每个按钮的正确文本。
- en: 'First we have to add `MainMenuFragment` as a click listener to these buttons
    during `onViewCreated`:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在 `onViewCreated` 期间将这些按钮添加为 `MainMenuFragment` 的点击监听器：
- en: '[PRE183]'
  id: totrans-1601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Then we have to handle the click. For that we rely on methods we will create
    inside `SoundManager` to toggle the values. Once that is done, we update the text
    on the buttons.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须处理点击。为此，我们依赖于在 `SoundManager` 内部创建的方法来切换值。一旦完成，我们更新按钮上的文本。
- en: '[PRE184]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Finally, the method `updateSoundAndMusicButtons` simply reads the state of sound
    and music from the `SoundManager` and sets the correct string resource on each
    button.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`updateSoundAndMusicButtons` 方法简单地从 `SoundManager` 读取声音和音乐的状态，并在每个按钮上设置正确的字符串资源。
- en: '[PRE185]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'As we mentioned, all the heavy work is done inside `SoundManager`, especially
    in the methods we have not implemented yet: `toggleMusicStatus` and `toggleSoundStatus`.'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，所有繁重的工作都是在 `SoundManager` 内部完成的，尤其是在我们尚未实现的方法中：`toggleMusicStatus` 和
    `toggleSoundStatus`。
- en: Let's get into `SoundManager` then.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `SoundManager`。
- en: Updating SoundManager
  id: totrans-1608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 `SoundManager`
- en: Our `SoundManager` is responsible for reading, changing, and restoring the values
    of the sound and music preferences. To do that we read them from `SharedPreferences`
    on construction and provide a method to change the setting that also takes care
    of the loading and unloading of the sound files as needed.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `SoundManager` 负责读取、更改和恢复声音和音乐首选项的值。为此，我们在构造时从 `SharedPreferences` 读取它们，并提供一个方法来更改设置，该方法还负责根据需要加载和卸载声音文件。
- en: '[PRE186]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: With this initialization, we read the values from `SharedPreferences` and store
    them in the member variables `mSoundEnabled` and `mMusicEnabled`, which can be
    accessed at any time and don't need to be read from disk. Once the values are
    read, we load the sounds and music only if they are enabled.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个初始化，我们从 `SharedPreferences` 读取值并将它们存储在成员变量 `mSoundEnabled` 和 `mMusicEnabled`
    中，这些变量可以在任何时候访问，无需从磁盘读取。一旦读取了值，我们只在没有启用的情况下加载声音和音乐。
- en: We also provide the accessor methods `getSoundStatus` and `getMusicStatus`,
    which we were already using on `MainMenuFragment` to update the text on the buttons.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了访问器方法 `getSoundStatus` 和 `getMusicStatus`，这些方法我们已经在 `MainMenuFragment`
    中使用，用于更新按钮上的文本。
- en: 'To change the value of each of the variables we have to use a method that will
    take care of saving the status and also to load or unload the required files.
    Let''s see the method for the sounds:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改每个变量的值，我们必须使用一个方法来处理保存状态以及根据需要加载或卸载所需的文件。让我们看看声音的方法：
- en: '[PRE187]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: The method switches the value of the setting to the logical negation of what
    it was. Then it loads or unloads the sounds based on the new value. Finally it
    stores the updated value on `SharedPreferences` so the member variable and the
    stored one are in sync.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将设置的值切换为其逻辑否定。然后根据新值加载或卸载声音。最后，它将更新的值存储在 `SharedPreferences` 上，以确保成员变量和存储的值保持同步。
- en: In the case of music, the method has the exact same logic but loads and unloads
    the music based on the value of `mMusicEnabled` and the preferences key is the
    constant `MUSIC_PREF_KEY` instead.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 在音乐的情况下，方法具有完全相同的逻辑，但根据`mMusicEnabled`的值加载和卸载音乐，而偏好键是常量`MUSIC_PREF_KEY`。
- en: '[PRE188]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: To complete the functionality, we are yet to modify `playSoundForGameEvent`
    as well as `pauseBgMusic` and `resumeBgMusic` to only do something when the sounds
    or music are enabled. It is as simple as adding a check at the beginning of each
    one of the methods involved.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成功能，我们还需要修改`playSoundForGameEvent`以及`pauseBgMusic`和`resumeBgMusic`，以便仅在声音或音乐启用时执行某些操作。这就像在每个相关方法的开头添加一个检查一样简单。
- en: '[PRE189]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Note that this check is very important because we can easily get `NullPointerExceptions`
    when trying to access uninitialized components.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个检查非常重要，因为我们尝试访问未初始化的组件时很容易得到`NullPointerExceptions`。
- en: Disabling system sounds
  id: totrans-1621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用系统声音
- en: 'Android has default sounds for button clicks. If you want to use your own sounds
    for the click action, you also have to disable the system sounds. This is something
    that we will want almost every time. Luckily it is very easy to do. We just have
    to modify the application style we have already defined in `res/styles.xml` and
    tell it that we want to disable sound effects:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: Android默认为按钮点击提供声音。如果你想为点击动作使用自己的声音，你还需要禁用系统声音。这几乎是我们每次都会做的事情。幸运的是，这非常容易做到。我们只需修改已经在`res/styles.xml`中定义的应用程序样式，并告诉它我们想要禁用音效：
- en: '[PRE190]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Summary
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have created a `SoundManager` that loads and unloads sound effects and music
    tracks from the assets folder, using the classes Android has for it—`SoundPool`
    and `MediaPlayer`—and we have learned the best use for each of them.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`SoundManager`，它从资源文件夹中加载和卸载音效和音乐轨道，使用Android提供的类——`SoundPool`和`MediaPlayer`——并且我们学习了它们各自的最佳使用方法。
- en: To play sounds we have added a `GameEvent` messaging system to the `GameEngine`
    that can be used for other purposes; this is a common mechanism for synchronizing
    `GameObjects`.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 为了播放声音，我们在`GameEngine`中添加了一个`GameEvent`消息系统，它可以用于其他目的；这是同步`GameObjects`的常见机制。
- en: For music we have linked pausing and resuming the music with the Activity life
    cycle.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音乐，我们将暂停和恢复音乐与Activity生命周期相关联。
- en: We have also added the possibility of enabling and disabling sounds and music
    independently at any time and stored the states in a persistent storage.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还增加了在任何时候独立启用和禁用声音和音乐的可能性，并将状态存储在持久存储中。
- en: At this point the `GameEngine` is mostly complete. In the following chapters
    we are going to focus on the tools that Android provides to make the UI nicer
    and more compelling, improving the look and feel of the game overall.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`GameEngine`基本上已经完成。在接下来的章节中，我们将关注Android提供的工具，以使UI更美观、更有吸引力，从而改善游戏的整体外观和感觉。
- en: Chapter 7. Menus and Dialogs
  id: totrans-1630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：菜单和对话框
- en: Now that the game works, it is time to tweak the rest of the UI. When you make
    an app, the best practice is to use all the standard UI components. Games are
    different, they should have personality. For this we are going to see how to use
    custom fonts, buttons, and dialogs.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经可以运行了，是时候调整剩余的UI界面了。当你开发一个应用时，最佳实践是使用所有标准的UI组件。游戏则不同，它们应该有自己的个性。为此，我们将了解如何使用自定义字体、按钮和对话框。
- en: We will start by making all the fragments of the game use a custom font. Then
    we will tweak the main menu to make it look nicer by adding a background and customizing
    the buttons for sound and music; we will also customize the button that starts
    the game using special drawable types we can define in XML.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使游戏的所有片段都使用自定义字体。然后我们将调整主菜单，通过添加背景和自定义音效和音乐的按钮来使其看起来更美观；我们还将使用在XML中可以定义的特殊可绘制类型来自定义启动游戏的按钮。
- en: For `GameFragment`, we will make space to display the score and lives and will
    update the pause button as well. We will make the game take care of scoring and
    player deaths. For this we will also see how to use `GameEvents`, not just for
    playing sounds, but also for extending the functionality, and adding a few events.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GameFragment`，我们将留出空间显示分数和生命值，并更新暂停按钮。我们将让游戏负责计分和玩家死亡。为此，我们还将了解如何使用`GameEvents`，不仅用于播放声音，还用于扩展功能，并添加一些事件。
- en: We will also make `GameController` take more responsibility for the game situation
    by using a state machine. This technique can be applied to other cases such as
    new levels, etc.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过使用状态机让`GameController`承担更多游戏情况的责任。这项技术可以应用于其他情况，如新关卡等。
- en: Finally, since the Android framework for dialogs is quite limited, we'll see
    how we can create custom dialogs for quitting the game, pausing, and game over.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 Android 框架的对话框功能相当有限，我们将看看如何创建用于退出游戏、暂停和游戏结束的自定义对话框。
- en: Custom fonts
  id: totrans-1636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义字体
- en: For app developers, Google has always enforced the use of the system default
    font, especially since Robotto was introduced. That is the reason why there are
    no other fonts in the system. However, `TextView` can use custom fonts in True
    Type (`.ttf`) or Open Type (`.otf`) formats.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用开发者，Google 一直强制使用系统默认字体，特别是自从 Robotto 引入以来。这就是为什么系统中没有其他字体。然而，`TextView`
    可以使用 True Type (`.ttf`) 或 Open Type (`.otf`) 格式的自定义字体。
- en: When choosing a font, you have lots of choices. There are websites that list
    lots of fonts that are free to use. Because YASS is meant to be a retro-style
    shooter, I picked a pixel-art style font called Adore64.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 选择字体时，你有许多选择。有一些网站列出了许多免费使用的字体。因为 YASS 意在成为复古风格的射击游戏，我选择了一个像素艺术风格的字体，名为 Adore64。
- en: We will store the font files into a folder under `assets` that we will name
    `ttf`, in the same way as we did for sounds.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字体文件存储在 `assets` 下的一个文件夹中，命名为 `ttf`，就像我们为声音所做的那样。
- en: To load the font in a format that can be used by `TextView`, we have the `Typeface`
    class. The process of loading a font is expensive, so we will do it only once
    (inside `onCreate`) and we will keep the `Typeface` variable as a member of the
    `Activity`.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载 `TextView` 可以使用的格式，我们有 `Typeface` 类。加载字体的过程是昂贵的，所以我们只做一次（在 `onCreate` 中），并将
    `Typeface` 变量作为 `Activity` 的成员保留。
- en: Note
  id: totrans-1641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Loading a Typeface is expensive; we should keep it in memory (at the Activity
    level).
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 `Typeface` 是昂贵的；我们应该将其保存在内存中（在 Activity 级别）。
- en: 'The code we have to add to `YassActivity` for loading a font is very simple:'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到 `YassActivity` 中以加载字体的代码非常简单：
- en: '[PRE191]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Once the font is loaded, we just need to apply it to all the text views of
    the hierarchy. This can be done easily using recursion:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦字体加载，我们只需将其应用到层次结构中的所有文本视图。这可以通过递归轻松完成：
- en: '[PRE192]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The method receives a `View`. If it is an instance of `ViewGroup`, it means
    that it has (or can have) more views as children, so we iterate over all the children
    using this same method recursively.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收一个 `View`。如果它是 `ViewGroup` 的实例，这意味着它有（或可以有）更多视图作为子视图，所以我们使用相同的方法递归地遍历所有子视图。
- en: If the view is an instance of `TextView`, we just call the method `setTypeface`,
    which only exists on `TextView`, and we can move on.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 如果视图是 `TextView` 的实例，我们只需调用 `setTypeface` 方法，这个方法只存在于 `TextView` 中，然后我们可以继续。
- en: For any other type of views, we do nothing.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何其他类型的视图，我们不做任何事情。
- en: Note
  id: totrans-1650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Applying a typeface to all our views is easy to do using recursive algorithms.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归算法将字体应用到所有视图是很容易做到的。
- en: Note that `instanceof` checks if the object complies with the class given. This
    means that objects from classes that extend from it will return true. This is
    key for this algorithm to work, since all the `Layout` classes are children of
    `ViewGroup` and all views that hold text (that is `Button`) extend from `TextView`.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`instanceof` 检查对象是否遵守给定的类。这意味着从它扩展的类的对象将返回 true。这对于此算法正常工作至关重要，因为所有 `Layout`
    类都是 `ViewGroup` 的子类，所有包含文本的视图（即 `Button`）都扩展自 `TextView`。
- en: The missing link is, where do we invoke this method and with which parameters?
    We will do it using the method `onViewCreated` of `YassBaseFragment`.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的链接是，我们在哪里调用这个方法以及使用哪些参数？我们将使用 `YassBaseFragment` 的 `onViewCreated` 方法来完成。
- en: '[PRE193]'
  id: totrans-1654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Since all the fragments will extend from this one, they will all have the `Typeface`
    set automatically.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有片段都将扩展自这个，它们都将自动设置 `Typeface`。
- en: If we want to use more than one font in the game, the code starts to become
    complex and it is a better idea to use a library to take care of it. For this
    I recommend using Calligraphy ([https://github.com/chrisjenx/Calligraphy](https://github.com/chrisjenx/Calligraphy)),
    which hooks into the `ContextWrapper` to load the typeface when inflating the
    views instead of traversing the hierarchy later, and also supports XML attributes
    to set a specific font to a specific view.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在游戏中使用多个字体，代码开始变得复杂，使用库来处理它是个更好的主意。为此，我推荐使用 Calligraphy ([https://github.com/chrisjenx/Calligraphy](https://github.com/chrisjenx/Calligraphy))，它通过
    `ContextWrapper` 钩子来加载字体，而不是在之后遍历层次结构，并且还支持 XML 属性来设置特定视图的特定字体。
- en: Note
  id: totrans-1657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Calligraphy is a great library if you want to use multiple fonts in your Android
    project.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Android 项目中使用多种字体，书法艺术是一个很好的库。
- en: Working with backgrounds
  id: totrans-1659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与背景一起工作
- en: Something that makes the game look bad is the plain white background we have
    at the moment. While we could set a background for the activity, this is not the
    best solution because background images are set to scale to fit, and that cannot
    be changed. When using a background image it will expand to cover all the view.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 让游戏看起来不好的是当前我们使用的纯白色背景。虽然我们可以为活动设置背景，但这不是最好的解决方案，因为背景图片被设置为缩放以适应，并且无法更改。当使用背景图片时，它将扩展以覆盖所有视图。
- en: Note
  id: totrans-1661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The attribute `android:background` will stretch the image to make it fit in
    the view.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `android:background` 将拉伸图片以使其适合视图。
- en: We do not want our background image to be stretched in one dimension. We want
    it to scale uniformly on both axes.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望背景图片在一个维度上被拉伸。我们希望它在两个轴向上均匀缩放。
- en: This can be improved with the use of a 9-patch as the background image, but
    in our case we will just use an `ImageView` that covers all the layout with `scaleType`
    set to `centerCrop`. This parameter does scale the image uniformly (maintaining
    the image's aspect ratio) so that both dimensions of the image (width and height)
    will be equal to or larger than the corresponding dimension of the `View`.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 9-patch 作为背景图片可以改进这一点，但在这个例子中，我们将只使用一个覆盖整个布局的 `ImageView`，并将 `scaleType`
    设置为 `centerCrop`。此参数将图像均匀缩放（保持图像的宽高比），使得图像的两个维度（宽度和高度）都将等于或大于 `View` 的相应维度。
- en: 'We will add an `ImageView` at the beginning of `fragment_main_menu.xml` with
    the desired `scaleType`:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `fragment_main_menu.xml` 的开头添加一个 `ImageView`，并设置所需的 `scaleType`：
- en: '[PRE194]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: And just with the fonts and the background, the main menu looks much better
    already!
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过字体和背景，主菜单就已经看起来好多了！
- en: '![Working with backgrounds](img/B04757_07_01.jpg)'
  id: totrans-1668
  prefs: []
  type: TYPE_IMG
  zh: '![处理背景](img/B04757_07_01.jpg)'
- en: We could use a `GameView` instead of an `ImageView` to have a parallax background,
    I leave this as an exercise for readers interested in tweaking backgrounds even
    more.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `GameView` 而不是 `ImageView` 来实现视差背景，我将这个作为练习留给对调整背景更感兴趣的读者。
- en: The power of XML drawables
  id: totrans-1670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 可绘制元素的力量
- en: Until now we have used drawables that are images, but Android provides a very
    complete framework that allows us to use other types of resources. A drawable
    resource is a general concept for a graphic that can be drawn to the screen. There
    are several types of drawables that you can define in XML.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了图像类型的可绘制元素，但 Android 提供了一个非常完整的框架，允许我们使用其他类型的资源。可绘制资源是一个通用概念，用于可以在屏幕上绘制的图形。你可以在
    XML 中定义几种类型的可绘制元素。
- en: We are going to describe state lists and shape drawables, but there are a few
    more. In particular if you are not familiar with 9-patches, you should check them
    out as well.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述状态列表和形状可绘制元素，但还有更多。特别是如果你不熟悉 9-patch，你也应该查看它们。
- en: Note
  id: totrans-1673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn about all drawable resources in the official documentation: [http://developer.android.com/guide/topics/resources/drawable-resource.html](http://developer.android.com/guide/topics/resources/drawable-resource.html).'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中了解所有可绘制资源：[http://developer.android.com/guide/topics/resources/drawable-resource.html](http://developer.android.com/guide/topics/resources/drawable-resource.html)。
- en: State list drawables
  id: totrans-1675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态列表的可绘制元素
- en: '`StateListDrawable` is a drawable object defined in XML that uses several other
    drawables to represent the same graphic depending on the state of the object.
    The framework defines many states, but we will only use `pressed`, `focused`,
    and `default` (no state). There is also a state named `selected` that should not
    be confused with `focused`. In fact selected is hardly ever used.'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateListDrawable` 是在 XML 中定义的一个可绘制对象，它使用几个其他可绘制元素来表示同一图形，具体取决于对象的状态。框架定义了许多状态，但我们将只使用
    `pressed`、`focused` 和 `default`（无状态）。还有一个名为 `selected` 的状态，不应与 `focused` 混淆。实际上，`selected`
    很少使用。'
- en: The state list is described in an XML file that has `<selector>` as the root
    tag. Each graphic is represented by an `<item>` element which can use various
    attributes to describe the state in which it should be used as the graphic for
    the drawable.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 状态列表由一个根标签为 `<selector>` 的 XML 文件描述。每个图形由一个 `<item>` 元素表示，该元素可以使用各种属性来描述它应该作为可绘制图形使用的状态。
- en: When the state changes, the list is checked in sequential order and the first
    item that matches the current state is used. It is important to remember that
    this selection of state is not based on a best match but on a first match. The
    best practice for defining state lists is to put the most restrictive states at
    the beginning and to have a default state as the last item.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态改变时，列表将按顺序检查，并使用第一个匹配当前状态的项。重要的是要记住，这种状态选择不是基于最佳匹配，而是基于第一个匹配。定义状态列表的最佳实践是将最限制性的状态放在前面，并将默认状态作为最后一个项。
- en: Note
  id: totrans-1679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the states is very important. The first match on the list is the
    one that is used.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的顺序非常重要。列表中的第一个匹配项将被使用。
- en: 'We are going to use state list drawables for the music and sound buttons. We
    will then have four state list drawables—music on, music off, sound on & sound
    off—and for each of them we will have three states: pressed, focused, and normal.'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用状态列表可绘制来为音乐和声音按钮。然后我们将有四个状态列表可绘制——音乐开启、音乐关闭、声音开启 & 声音关闭——并且对于每一个，我们将有三种状态：按下、聚焦和正常。
- en: These views will not be buttons any longer but an `ImageView` instead. A bit
    of a code tweaking will be needed in order to make this change, basically inside
    `updateSoundAndMusicButtons`, which should use drawables now instead of texts.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图将不再是按钮，而是 `ImageView`。为了实现这个变化，需要对代码进行一些调整，基本上是在 `updateSoundAndMusicButtons`
    中，它现在应该使用可绘制而不是文本。
- en: Regarding the look and feel, we are going to make a circle of a color that represents
    the state, and then use the same icon for all of the states, just changing the
    color. We will also make the pressed state a bit smaller—to give the feeling of
    being pressed—by adding margins to the image.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 关于外观和感觉，我们将使用代表状态的颜色的圆形，然后为所有状态使用相同的图标，只需改变颜色。我们还将通过给图像添加边距，使按下状态稍微小一点，以产生被按下的感觉。
- en: We are using white for normal state, yellow for pressed, and blue for focused.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用白色表示正常状态，黄色表示按下状态，蓝色表示聚焦状态。
- en: '![State list drawables](img/B04757_07_02.jpg)'
  id: totrans-1685
  prefs: []
  type: TYPE_IMG
  zh: '![状态列表可绘制](img/B04757_07_02.jpg)'
- en: All the composed drawables for the states of sound and music
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于声音和音乐状态的可绘制组合。
- en: The state drawable files should be placed into the `res/drawable` directory
    because they are just a list of references and therefore they are independent
    of the density. On the other hand, we should provide density-specific versions
    of the drawables that are referenced as states.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可绘制文件应放置在 `res/drawable` 目录中，因为它们只是引用列表，因此它们与密度无关。另一方面，我们应该提供作为状态引用的可绘制文件的密度特定版本。
- en: Now, instead of providing 12 icons, since all of them use the same background
    we can configure this using 4 icons, 3 background states and 1 state drawable
    that will be the background for all of them. This will also allow us to reuse
    the background for other buttons.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于所有这些图标都使用相同的背景，我们可以使用 4 个图标、3 个背景状态和 1 个状态可绘制来配置它，这将作为所有这些的背景。这还将允许我们为其他按钮重用背景。
- en: 'This is the code of the state list drawable that we will use for the background:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于背景的状态列表可绘制代码：
- en: '[PRE195]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: As we already said, the order is very important. We want to show the pressed
    state when it is pressed; we do not care if it is focused or not, so that is the
    first case. Then we want to show if it is focused. Finally we have a default case
    with no parameters that covers "everything else".
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，顺序非常重要。我们希望在按下时显示按下状态；我们不在乎它是否聚焦，所以这是第一个情况。然后我们想显示它是否聚焦。最后，我们有一个默认情况，没有参数，覆盖“其他所有情况”。
- en: The backgrounds have been created using GIMP and the base icons are free ones
    that we found using an icon search website such as IconFinder ([https://www.iconfinder.com](https://www.iconfinder.com)).
    There are many icon search websites. Try several and see which one you like best.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 背景是通过 GIMP 创建的，基础图标是我们使用图标搜索网站（如 IconFinder [https://www.iconfinder.com](https://www.iconfinder.com)）找到的免费图标。有许多图标搜索网站。尝试几个，看看哪个最适合你。
- en: Note that the naming convention is to use a name for the state list and then
    the same name followed by pressed, selected, or normal for each state.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，命名约定是使用状态列表的名称，然后是每个状态的相同名称后跟 pressed、selected 或 normal。
- en: State lists colors
  id: totrans-1694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态列表颜色
- en: We can use selectors to define colors as well as images. This can be used on
    the text that goes into a button or the background of a view. It works the same
    way as for drawables, but uses the `color` keyword instead of `drawable`. The
    files that define colors must be placed under the `res/colors` directory.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用选择器来定义颜色以及图像。这可以用于按钮中的文本或视图的背景。它与可绘制元素的工作方式相同，但使用 `color` 关键字而不是 `drawable`。定义颜色的文件必须放置在
    `res/colors` 目录下。
- en: An example of a color state list that we will reference later is `btn_background.xml`.
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会参考的一个颜色状态列表示例是 `btn_background.xml`。
- en: '[PRE196]'
  id: totrans-1697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: And of course we need to define these colors as well. Note that these colors
    are not state lists, and therefore should be defined in a file under the `res/values`
    directory. We normally call this file `colors.xml` as a convention, but any name
    will work.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要定义这些颜色。请注意，这些颜色不是状态列表，因此应该在 `res/values` 目录下的文件中定义。我们通常按照惯例将此文件命名为 `colors.xml`，但任何名称都可以。
- en: '[PRE197]'
  id: totrans-1699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Note
  id: totrans-1700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: State list color XML files are placed under `res/color`, but normal colors are
    defined as values in files under `res/values` instead.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 状态列表颜色 XML 文件放置在 `res/color` 目录下，但正常颜色定义为 `res/values` 目录下的文件中的值。
- en: As good practice, you should always externalize all the variables of the layouts
    . This is valid for colors, dimensions, and strings.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，你应该始终将布局的所有变量外部化。这对于颜色、尺寸和字符串都是有效的。
- en: Shape drawables
  id: totrans-1703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状可绘制元素
- en: 'Shape drawables are exactly what the name suggests: a way to define a generic
    shape in XML. We are going to use them to make all the button backgrounds.'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 形状可绘制元素正如其名所示：在 XML 中定义通用形状的一种方式。我们将使用它们来制作所有的按钮背景。
- en: 'The syntax for shape drawables is defined as this:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 形状可绘制元素的语法定义如下：
- en: '[PRE198]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The top level tag of the shape drawable is `<shape>` and it has an attribute
    also named `shape` that defines its type. Possible values are:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 形状可绘制元素的最高级标签是 `<shape>`，它有一个也命名为 `shape` 的属性，用于定义其类型。可能的值包括：
- en: '`rectangle`: a rectangle that fills the containing view. This is the default
    shape if none is specified.'
  id: totrans-1708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rectangle`：填充包含视图的矩形。如果没有指定，这是默认形状。'
- en: '`oval`: an oval shape that fits the dimensions of the containing view.'
  id: totrans-1709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oval`：适合包含视图尺寸的椭圆形。'
- en: '`line`: a horizontal line that spans the width of the containing view. This
    shape requires the `<stroke>` element to define the width of the line.'
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line`：横跨包含视图宽度的水平线。此形状需要 `<stroke>` 元素来定义线的宽度。'
- en: '`ring`: a ring shape. This shape allows some other attributes to be properly
    defined such as `innerRadius/innerRadiusRatio`, `thickness/thicknessRatio`, and
    `useLevel`.'
  id: totrans-1711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ring`：环形形状。此形状允许正确定义一些其他属性，例如 `innerRadius/innerRadiusRatio`、`thickness/thicknessRatio`
    和 `useLevel`。'
- en: The content of the shape can be a solid color or a gradient. For this, we use
    the tags `<solid>` or `<gradient>`.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的内容可以是纯色或渐变。为此，我们使用 `<solid>` 或 `<gradient>` 标签。
- en: The tag `<solid>` has the argument `color`, which can be provided as a hexadecimal
    value or a color resource. This color resource can also be a state list.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: '`<solid>` 标签的参数是 `color`，可以是十六进制值或颜色资源。此颜色资源也可以是状态列表。'
- en: The tag `<gradient>` can be used instead of `<solid>` and its arguments are
    self-explanatory. We are not going to use them in our game.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `<gradient>` 标签代替 `<solid>` 标签，其参数是自解释的。我们不会在我们的游戏中使用它们。
- en: We can define the padding of the containing view elements using the `<padding>`
    tag. It has four different attributes—`left`, `top`, `right`, and `bottom`—that
    can be provided as a dimension value or dimension resource.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `<padding>` 标签来定义包含视图元素的填充。它有四个不同的属性——`left`、`top`、`right` 和 `bottom`——可以作为尺寸值或尺寸资源提供。
- en: The size of the shape is optional and can be defined using the tag `<size>`,
    which has `height` and `width` as attributes that can be a dimension value or
    resource.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的大小是可选的，可以使用 `<size>` 标签来定义，该标签具有 `height` 和 `width` 属性，可以是尺寸值或资源。
- en: Note
  id: totrans-1717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The shape scales to the size of the container `View` proportionate to the dimensions
    defined here, by default. When you use the shape in an `ImageView`, you can restrict
    scaling by setting `android:scaleType` to `"center"`.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 形状默认按比例缩放到容器 `View` 的大小，与这里定义的尺寸相对应。当你在 `ImageView` 中使用形状时，你可以通过设置 `android:scaleType`
    为 `"center"` 来限制缩放。
- en: 'The border or outline of the shape is defined with the tag `<stroke>`. It accepts
    the following attributes:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的边框或轮廓使用 `<stroke>` 标签定义。它接受以下属性：
- en: '**Width**: the thickness of the line, as a dimension value or dimension resource.'
  id: totrans-1720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽度**：线的厚度，可以是尺寸值或尺寸资源。'
- en: '**Color**: the color of the line, as a hexadecimal value or color resource.'
  id: totrans-1721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：线的颜色，作为十六进制值或颜色资源。'
- en: '**DashGap/DashWith**: the distance between line dashes and the size of each
    dash, both as dimension values and dimension resources. They need to be set together.'
  id: totrans-1722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DashGap/DashWith**：线段之间的距离和每个线段的尺寸，两者都作为尺寸值和尺寸资源。它们需要一起设置。'
- en: 'When using a rectangular shape, we can specify the corners to be rounded by
    using the `<corners>` tag; for that we can use just `radius` or we can specify
    a dimension for each of the corners: `topLeftRadius`, `topRightRadius`, `bottomLeftRadius`,
    and `bottomRightRadius`.'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用矩形形状时，我们可以通过使用`<corners>`标签来指定要圆滑的角落；为此，我们可以只使用`radius`，或者我们可以为每个角落指定一个维度：`topLeftRadius`、`topRightRadius`、`bottomLeftRadius`和`bottomRightRadius`。
- en: Note
  id: totrans-1724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The system requires every corner radius to be initialized with a value greater
    than 1 in the XML file. Otherwise no corners are rounded. To work around this
    you can override the corner radius value programmatically.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 系统要求在XML文件中将每个圆角半径初始化为大于1的值。否则，没有圆角会被圆滑。为了解决这个问题，你可以通过程序覆盖圆角半径值。
- en: Now that we have seen the syntax in detail, let's create the shapes we are going
    to use in our game.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经详细了解了语法，让我们创建我们将在游戏中使用的形状。
- en: We are going to create an oval shape for the round buttons, and use a color
    that is also a color state list to replace the current drawable state list that
    has multiple shapes because it makes the code much more compact and easy to update.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为圆形按钮创建一个椭圆形形状，并使用一个也是颜色状态列表的颜色来替换当前具有多个形状的可绘制状态列表，因为这会使代码更加紧凑且易于更新。
- en: '[PRE199]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: We define the shape as oval, then set it to have a solid color that is the state
    list color resource we defined in the previous section. Finally we define some
    paddings that come from dimensions resources.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将形状定义为椭圆形，然后将其设置为具有实心颜色，即我们在上一节中定义的状态列表颜色资源。最后，我们定义了一些来自尺寸资源的内边距。
- en: 'Next, we are going to define a shape for the square buttons (at the moment
    it is only used for the button to start the game):'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为方形按钮定义一个形状（目前它仅用于启动游戏的按钮）：
- en: '[PRE200]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: This shape is a rectangle with a border. The border is defined by the `stroke`
    tag.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 这个形状是一个带有边框的矩形。边框由`stroke`标签定义。
- en: All the dimensions we have used for this shape must be defined. We put them
    into a `dimens.xml` file under `res/values`.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个形状使用的所有尺寸都必须定义。我们将它们放入`res/values`下的`dimens.xml`文件中。
- en: '[PRE201]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: We also added a couple more colors for the button border and the text color
    in `colors.xml`.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`colors.xml`中为按钮边框和文字颜色添加了几个更多颜色。
- en: '[PRE202]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Finally we are going to make use of styles to keep the code on the layouts cleaner.
    Styles on Android allow you to define several XML attributes and associate them
    with a name. Then you can reference the style by name on any layout and it will
    be applied.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将利用样式来使布局上的代码更整洁。Android上的样式允许你定义多个XML属性并将它们与一个名称关联。然后你可以在任何布局中通过名称引用样式，它将被应用。
- en: The intention of styles is to define the look and feel in a single place so
    it can be changed and/or updated easily. The concept is similar to CSS for web
    pages.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 样式的目的是在单个位置定义外观和感觉，以便可以轻松更改和/或更新。这个概念与网页的CSS类似。
- en: Note
  id: totrans-1739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Styles are very handy for keeping layouts clean and having the definition of
    the look and feel in a single place.
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 样式对于保持布局整洁并将外观和感觉的定义放在一个地方非常有用。
- en: We are going to define a style for the round buttons. This goes into the `styles.xml`
    file under `res/values` (and again, any name for the file will work, but it is
    better to follow the conventions).
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为圆形按钮定义一个样式。这将在`res/values`下的`styles.xml`文件中（而且，文件名可以是任何名称，但最好遵循约定）。
- en: '[PRE203]'
  id: totrans-1742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'To complete this section, let''s look at the updated version of `fragment_main_menu.xml`
    with all these changes included:'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，让我们看看包含所有这些更改的`fragment_main_menu.xml`的更新版本：
- en: '[PRE204]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '![Shape drawables](img/B04757_07_03.jpg)'
  id: totrans-1745
  prefs: []
  type: TYPE_IMG
  zh: '![形状可绘制](img/B04757_07_03.jpg)'
- en: The GameFragment
  id: totrans-1746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏片段
- en: Now that we have tweaked the main menu, it is time to work on the `GameFragment`.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经调整了主菜单，现在是时候开始处理`GameFragment`了。
- en: 'There are two essential game features we have not even built yet: score and
    lives. We are going remedy that now. First we need to make space for them in the
    layout, then we have to write some code to actually take care of both features.'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有构建的两个基本游戏功能：得分和生命值。我们现在将解决这个问题。首先，我们需要在布局中为它们腾出空间，然后我们必须编写一些代码来实际处理这两个功能。
- en: For the UI of the score and lives we are going to use standard Android components.
    We have built a lot of features into our `GameEngine`, but we do not want to reinvent
    the wheel. Since Android provides a good way to define layouts and make UIs we
    are familiar with, it would be a waste to not make use of it.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 对于得分和生命值的UI，我们将使用标准的Android组件。我们已经在我们的`GameEngine`中构建了许多功能，但我们不想重新发明轮子。由于Android提供了一个很好的方式来定义布局并创建我们熟悉的UI，不利用它将是浪费的。
- en: Note
  id: totrans-1750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the standard Android Views can save you a lot of time.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的Android视图可以为您节省大量时间。
- en: We are going to make the game area smaller by adding a column to each side.
    We will place the new UI elements there and we will link them to `GameObjects`
    to update them as the game progresses.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在每边添加一列来缩小游戏区域。我们将把新的UI元素放在那里，并将它们链接到`GameObjects`以在游戏过程中更新它们。
- en: While we could overlay the controls on top of the `GameView` instead of having
    letterboxes, note that we are using a `SurfaceView`, and its performance plummets
    dramatically when other views are overlaid on top of it. We also think it looks
    nicer to have the gameplay area separated from the controls. If you want to use
    an overlay, you should change the `GameView` to be a `StandardGameView`.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在`GameView`上叠加控件而不是使用信封，但请注意，我们正在使用`SurfaceView`，当其他视图叠加在其上时，其性能会急剧下降。我们也认为将游戏区域与控件分开看起来更好。如果您想使用叠加，您应该将`GameView`更改为`StandardGameView`。
- en: Now that we are working with `fragment_game.xml`, it is a good moment to also
    update the Pause button with the same style we created for sound and music.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用`fragment_game.xml`，这是一个更新暂停按钮的好时机，使其与为声音和音乐创建的相同样式保持一致。
- en: 'The new version of `fragment_game.xml` is like this:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '`fragment_game.xml`的新版本如下：'
- en: '[PRE205]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The `GameView` in now inside a `FrameLayout` that is centered and has margins
    to each side with values for the columns (`R.dimen.game_menu_width`). The `FrameLayout`
    is used to display a red frame around the `GameView` to clearly separate the play
    area from the rest of the UI.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameView`现在位于一个居中且具有每边边距的`FrameLayout`中，边距值对应于列（`R.dimen.game_menu_width`）。`FrameLayout`用于在`GameView`周围显示一个红色边框，以清楚地将游戏区域与其他UI部分分开。'
- en: 'The frame background is a rectangular shape drawable similar to the ones we
    have already defined:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 边框背景是一个类似于我们已定义的矩形形状的可绘制对象：
- en: '[PRE206]'
  id: totrans-1759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: On the left we have a `RelativeLayout`, which we will use to place the controls
    for the score and lives. In front of this we have the virtual joystick we were
    already using, and that covers the entire screen. Finally, we have the pause button,
    which has to remain in the foreground, otherwise the virtual joystick will capture
    the touch event. As we have already mentioned, the pause button is now using the
    same look and feel as the music and sound buttons on the main menu.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有一个`RelativeLayout`，我们将使用它来放置得分和生命值的控件。在这个控件前面，我们有我们之前已经使用的虚拟摇杆，它覆盖了整个屏幕。最后，我们有暂停按钮，它必须保持在前景，否则虚拟摇杆将捕获触摸事件。正如我们之前提到的，暂停按钮现在使用与主菜单中的音乐和声音按钮相同的样式和感觉。
- en: '![The GameFragment](img/B04757_07_04.jpg)'
  id: totrans-1761
  prefs: []
  type: TYPE_IMG
  zh: '![游戏片段](img/B04757_07_04.jpg)'
- en: Now that we have the space, let's start adding items there! We are going to
    just display scores and lives, but you could use the space for anything relevant
    to the game, from top scores to In-App Purchases buttons.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了空间，让我们开始添加项目！我们只是会显示得分和生命值，但您可以使用这个空间来显示与游戏相关的任何内容，从最高分到应用内购买按钮。
- en: Adding a score
  id: totrans-1763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加得分
- en: Let's implement the score counter. For that we need to define a way to give
    points to the player as well.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现得分计数器。为此，我们需要定义一种给玩家记分的方法。
- en: We are going to use a `TextView` to display the score on the screen. To control
    this `TextView`, we will create a `ScoreGameObject` that is in many ways similar
    to the one we used in [Chapter 1](ch21.html "Chapter 1. Setting Up the Project"),
    *Setting Up the Project* to show the coordinates of the `Player`.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`TextView`在屏幕上显示得分。为了控制这个`TextView`，我们将创建一个`ScoreGameObject`，它在许多方面与我们在[第1章](ch21.html
    "第1章。设置项目")中使用的类似，用于显示`Player`的坐标。
- en: The score will be calculated inside the `ScoreGameObject` class and it will
    be updated based on game events. This also implies that the `GameEngine` must
    propagate the events to the game objects (until now it has only propagated them
    to the `SoundEngine`).
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 得分将在`ScoreGameObject`类内部计算，并根据游戏事件进行更新。这也意味着`GameEngine`必须将事件传播到游戏对象（到目前为止，它只将事件传播到`SoundEngine`）。
- en: We will give 50 points each time the player hits an asteroid, and remove one
    point each time an asteroid escapes. An `Asteroid` escaping is a new `GameEvent`
    we will have to create and trigger. Both score modification values will be set
    as constants as good practice for readability and ease of change.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家击中一个小行星时，我们将给予50分，每次小行星逃脱时，我们将扣除1分。小行星逃脱是一个新的 `GameEvent`，我们将必须创建并触发它。这两个分数修改值都将设置为常量，作为可读性和易于更改的良好实践。
- en: 'First things first: let''s make `GameEngine` propagate `GameEvents` to all
    the `GameObjects` that are currently active. For this, we modify the method `onGameEvent`
    of `GameEngine`.'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 首先：让我们让 `GameEngine` 将 `GameEvents` 传播给所有当前活动的 `GameObjects`。为此，我们修改 `GameEngine`
    的 `onGameEvent` 方法。
- en: '[PRE207]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Note that this implies creating a method named `onGameEvent` in `GameObject`,
    which will be empty by default.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这暗示在 `GameObject` 中创建一个名为 `onGameEvent` 的方法，默认情况下该方法为空。
- en: We are going to use a new `GameEvent` that is triggered when the asteroid goes
    out of the screen (`AsteroidMissed`). We have to add that value to the `GameEvents`
    enum and also trigger the event from the `onUpdate` method of the `Asteroid`.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个新的 `GameEvent`，当小行星超出屏幕时触发（`AsteroidMissed`）。我们必须将此值添加到 `GameEvents`
    枚举中，并从 `Asteroid` 的 `onUpdate` 方法中触发事件。
- en: '[PRE208]'
  id: totrans-1772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Now let''s add the `TextView` to the left column of our `fragment_game.xml`.
    We will have two new text views: one with the text "`Score:"` (`R.id.score_title`)
    and another one with the score itself (`R.id.score_value`).'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 `TextView` 添加到我们的 `fragment_game.xml` 的左侧列。我们将有两个新的文本视图：一个带有文本 "`Score:"`
    (`R.id.score_title`)，另一个带有实际的分数 (`R.id.score_value`)。
- en: '[PRE209]'
  id: totrans-1774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'We have everything in place, it is time to link them together with the `ScoreGameObject`
    class. It is a fairly simple one:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有东西，现在是时候用 `ScoreGameObject` 类将它们连接起来。这是一个相当简单的类：
- en: '[PRE210]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: This class sets the points to 0 when the game is started, and then reacts to
    `GameEvents` by modifying the total points of the player. Once the value of the
    score has been modified, we signal it with a boolean variable so we know it needs
    to be updated during the next call to `onDraw`. This is done to prevent unnecessary
    redraws on the `TextView`.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在游戏开始时将分数设置为0，然后通过修改玩家的总分数来响应 `GameEvents`。一旦分数值被修改，我们将通过一个布尔变量发出信号，这样我们就可以知道在下次调用
    `onDraw` 时需要更新它。这样做是为了防止在 `TextView` 上进行不必要的重绘。
- en: Remember that `onDraw` is invoked on the `UIThread` when we are using a `StandardGameView`,
    but it is called from the `UpdateThread` in the case of a `SurfaceGameView`. Since
    the views can only be updated on the `UIThread`, we use a `Runnable` that gets
    posted to the `UIThread`, which then updates the value of the `TextView` to make
    it work for both `StandardGameView` and `SurfaceGameView`.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用 `StandardGameView` 时，`onDraw` 是在 `UIThread` 上调用的，但在 `SurfaceGameView`
    的情况下，它是在 `UpdateThread` 上调用的。由于视图只能在 `UIThread` 上更新，我们使用一个 `Runnable`，该 `Runnable`
    被发布到 `UIThread`，然后更新 `TextView` 的值，使其对 `StandardGameView` 和 `SurfaceGameView`
    都有效。
- en: Note
  id: totrans-1779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: View modifications must always be done on the `UIThread`.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 视图修改必须在 `UIThread` 上进行。
- en: We use `String.format` to get a number consisting of 6 digits, filling in with
    0s to the left if the integer does not have enough digits. This just makes the
    score look a lot nicer.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `String.format` 来获取一个由6位数字组成的数字，如果整数位数不足，则在左侧用0填充。这只是为了使分数看起来更美观。
- en: The only remaining link is to add this `GameObject` to the `GameEngine` initialization
    in the `GameFragment`.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一链接是将这个 `GameObject` 添加到 `GameFragment` 中的 `GameEngine` 初始化中。
- en: '[PRE211]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: We can now play the game and finally score some points.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以玩游戏了，并最终得分。
- en: Adding lives
  id: totrans-1785
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加生命值
- en: We are also going to have a lives indicator in the left column. For this we
    have to update the game quite a lot since we only have one life currently and
    the game does not do anything when we die.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在左侧列中添加一个生命值指示器。为此，我们必须对游戏进行大量更新，因为我们目前只有一条生命，游戏在玩家死亡时不会做任何事情。
- en: As we did for the score, we will have a `LivesCounter` object that takes care
    of the display, but in this case the lives count will rely on the `GameController`.
    The synchronization between the `GameController` and the `LivesCounter` will be
    done via `GameEvents`.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 与分数类似，我们将有一个 `LivesCounter` 对象来处理显示，但在这个情况下，生命值将依赖于 `GameController`。`GameController`
    和 `LivesCounter` 之间的同步将通过 `GameEvents` 完成。
- en: Another thing to consider is that once the player dies, the wave must stop.
    Only once the screen is empty can we spawn a new `Player` object and then restart
    the wave after a few seconds.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的是，一旦玩家死亡，波次必须停止。只有当屏幕为空时，我们才能生成一个新的 `Player` 对象，然后在几秒钟后重新开始波次。
- en: To manage this, we will have `GameController` be a state machine and transition
    from one state to the other based on `GameEvents`. This is a common technique
    for the controllers of games in general.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这一点，我们将 `GameController` 设计为一个状态机，并根据 `GameEvents` 在状态之间进行转换。这是游戏控制器中常用的技术。
- en: Note
  id: totrans-1790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Having the `GameController` be a state machine is a common technique for games.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `GameController` 设计为状态机是游戏中的常用技术。
- en: We are going to start with the modifications in `GameController` first and then
    `LivesCounter`.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先对 `GameController` 进行修改，然后是 `LivesCounter`。
- en: For the state of the `GameController` we will create an enum that we will call
    `GameControllerState`.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GameController` 的状态，我们将创建一个枚举，我们将其称为 `GameControllerState`。
- en: '[PRE212]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Let''s describe each one of the states:'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述每个状态：
- en: '`StoppingWave`: this state is time based. While the `GameController` is in
    it, no asteroids are spawned. Combined with the timeout it effectively stops the
    current wave. From this state the controller will transition either to `GameOver`
    if there are no lives left, or to `PlacingSpaceship` if there are.'
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StoppingWave`：这个状态是基于时间的。当 `GameController` 处于这个状态时，不会生成任何小行星。与超时结合使用，它有效地停止了当前波次。从这个状态开始，控制器将根据是否有剩余生命而转换到
    `GameOver` 或 `PlacingSpaceship`。'
- en: '`SpawningEnemies`: the normal state. This is the equivalent of the behavior
    of the previous version without states. It transitions to `StoppingWave` when
    the spaceship is destroyed.'
  id: totrans-1797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpawningEnemies`：正常状态。这是之前版本没有状态的行为的等价物。当飞船被摧毁时，它转换到 `StoppingWave`。'
- en: '`PlacingSpaceship`: the controller puts a `Player` object into play and sends
    a `GameEvent` about it. This transitions automatically to `Waiting`.'
  id: totrans-1798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlacingSpaceship`：控制器将一个 `Player` 对象放入游戏中，并发送关于它的 `GameEvent`。这会自动转换到 `Waiting`
    状态。'
- en: '`Waiting`: similar to `StoppingWave`, this state is also time based but it
    always transitions to `SpawningEnemies`. This state exists to allow the player
    some time to relax after the new spaceship is placed on the screen.'
  id: totrans-1799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Waiting`：类似于 `StoppingWave`，这个状态也是基于时间的，但它总是转换到 `SpawningEnemies`。这个状态的存在是为了让玩家在新飞船放置到屏幕上后有足够的时间放松。'
- en: '![Adding lives](img/B04757_07_05.jpg)'
  id: totrans-1800
  prefs: []
  type: TYPE_IMG
  zh: '![添加生命](img/B04757_07_05.jpg)'
- en: The `GameController` starts in the `PlacingSpaceship` state, which gets one
    life and places a spaceship on the screen. The `GameController` will move into
    `Waiting` and then into `SpawningEnemies`.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameController` 从 `PlacingSpaceship` 状态开始，获得一条生命并在屏幕上放置一艘飞船。`GameController`
    将移动到 `Waiting` 状态，然后移动到 `SpawningEnemies` 状态。'
- en: When a `SpaceshipHit` event arrives we move into `StoppingWave`. Once there
    are no more `Asteroids` on the screen, we check the number of lives remaining.
    If it is 0, that's `GameOver`, otherwise, we go to `PlacingSpaceship` (which triggers
    a `LifeLost` game event) and then moves to `Waiting` again until we can move to
    `SpawningEnemies`.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `SpaceshipHit` 事件到达时，我们进入 `StoppingWave` 状态。一旦屏幕上没有更多的 `Asteroids`，我们检查剩余的生命数量。如果它是
    0，那么就是 `GameOver`，否则，我们转到 `PlacingSpaceship`（这会触发一个 `LifeLost` 游戏事件）然后再次移动到 `Waiting`
    状态，直到我们可以移动到 `SpawningEnemies`。
- en: 'Let''s see the code to start a game:'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看启动游戏的代码：
- en: '[PRE213]'
  id: totrans-1804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: First we reset all the counters and we run a loop over the amount of lives we
    have initially, sending the game event `LifeAdded`. This event is processed in
    this class as well as in the `LivesCounter`.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重置所有计数器，然后我们对初始生命数量进行循环，发送游戏事件 `LifeAdded`。这个事件在这个类以及 `LivesCounter` 中被处理。
- en: The main advantages to adding lives this way is that we can process lives that
    are given by other means than starting the game, that is, any extra lives. We
    also have the value of initial lives in a single place.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式添加生命的主要优点是，我们可以处理除了启动游戏之外的其他方式给出的生命，也就是说，任何额外的生命。我们还有一个初始生命的值在单一位置。
- en: Finally we move to the state of `PlacingSpaceship` as we described before.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移动到之前描述的 `PlacingSpaceship` 状态。
- en: 'As an important note: since we are starting on `PlacingSpaceship`, we now don''t
    need to add the player object to the `GameEngine` anymore because we do it from
    this class. We must remove that code from the initialization of the engine.'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个重要的注意事项：由于我们是从 `PlacingSpaceship` 开始的，我们现在不再需要将玩家对象添加到 `GameEngine` 中，因为我们是从这个类中做的。我们必须从引擎的初始化中删除那段代码。
- en: Note
  id: totrans-1809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GameController` now takes care of adding the `Player` to the game. We don't
    have to add it by hand on the `GameEngine` creation anymore.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameController` 现在负责将 `Player` 添加到游戏中。我们不再需要在 `GameEngine` 创建时手动添加它。'
- en: We could start the `GameController` in the `StoppingWave` state as well. That
    would give us some time before the life is removed and then added. Play with this,
    and decide which one you like better.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 `StoppingWave` 状态下启动 `GameController`。这样，在生命值被移除并添加之前，我们会有一段时间。尝试一下，看看你更喜欢哪一个。
- en: 'Next let''s look at the `onGameEvent` method of `GameController`:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `GameController` 的 `onGameEvent` 方法：
- en: '[PRE214]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: This does react to a `SpaceshipHit` event by moving into the `StoppingWave`
    state, and it also resets the waiting time. That state will check if there are
    remaining lives to be used or not and trigger the `GameOver` event if needed.
    We will see that when we look into `onUpdate`.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实会响应 `SpaceshipHit` 事件，通过移动到 `StoppingWave` 状态，并且它也会重置等待时间。该状态将检查是否有剩余的生命值可以使用，如果需要，将触发
    `GameOver` 事件。我们将在查看 `onUpdate` 时看到这一点。
- en: The method reacts to the `GameOver` event by putting itself in `GameOver` state.
    This event is only sent by the `GameController` at the moment, but it is nice
    to have it like this for future usage. Maybe we will want to have a very powerful
    enemy that can end the game in one go.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过将自己置于 `GameOver` 状态来响应 `GameOver` 事件。目前，这个事件只由 `GameController` 发送，但为了未来的使用，这样很好。也许我们想要一个非常强大的敌人，它可以一次性结束游戏。
- en: Finally, when `LifeAdded` arrives it increases the lives counter. Again, this
    event is only sent on construction of this class, but we could implement an extra
    life mechanic and then trigger it from somewhere else.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当 `LifeAdded` 到来时，它会增加生命值计数器。同样，这个事件仅在构建此类时发送，但我们可以实现一个额外的生命值机制，然后从其他地方触发它。
- en: The real juice is inside the `onUpdate` method.
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的核心在于 `onUpdate` 方法中。
- en: '[PRE215]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: You can see that the code we had before is now the code for the `SpawningEnemies`
    state. There is nothing new about spawning asteroids.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们之前有的代码现在是 `SpawningEnemies` 状态的代码。关于生成小行星没有新的内容。
- en: To stop a wave we just have to wait some milliseconds. Since there are no new
    `Asteroids` being spawned, this timeout just needs to be longer than the time
    it takes an `Asteroid` to cross the screen. We could count the asteroids when
    they are returned to the pool instead, but this method always waits the same amount
    of time and feels better to the player.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止一个波，我们只需要等待几毫秒。由于没有新的 `小行星` 正在被生成，这个超时时间只需要比 `小行星` 穿过屏幕的时间长即可。我们也可以在它们返回池中时计数，但这种方法总是等待相同的时间，并且对玩家来说感觉更好。
- en: 'The `PlacingSpaceship` state only lasts for one iteration. It will either send
    a `GameOver` event (which will move it to the `GameOver` state) or use a life,
    which includes:'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlacingSpaceship` 状态只持续一个迭代周期。它要么发送一个 `GameOver` 事件（这将将其移动到 `GameOver` 状态），要么使用一个生命值，这包括：'
- en: Sending the `LifeLost` event
  id: totrans-1822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 `LifeLost` 事件
- en: Creating a `Player` object, initializing it and adding it to the `GameEngine`
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Player` 对象，初始化它并将其添加到 `GameEngine`
- en: Moving to the `Waiting` state and resetting the waiting time
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转入 `Waiting` 状态并重置等待时间
- en: At this time we are not doing anything when the `GameOver` event happens, but
    we will take care of this in the second part of the chapter, by showing a game
    over dialog.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，当 `GameOver` 事件发生时，我们不做任何事情，但我们在本章的第二部分会处理这个问题，通过显示一个游戏结束对话框。
- en: Finally, while in the `Waiting` state we count the milliseconds, just as we
    do on the `StoppingWave`, and then we move to the `SpawningEnemies` state.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `Waiting` 状态下，我们计算毫秒数，就像我们在 `StoppingWave` 中做的那样，然后我们移动到 `SpawningEnemies`
    状态。
- en: This is all we need to make the `GameController` handle the state machine properly.
    It is time to move on to the `LivesCounter`.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的，让 `GameController` 正确处理状态机。现在是时候转向 `LivesCounter` 了。
- en: To show the lives on the screen we need to add some views to the layout and
    also implement the class that handles them. We want each life to be displayed
    as an icon of the spaceship on the left, under the score counter.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示生命值，我们需要在布局中添加一些视图，并实现处理它们的类。我们希望每个生命值都显示为飞船的图标，位于分数计数器下方左侧。
- en: 'We need to add the following code to the left column of the `fragment_game.xml`
    layout:'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将以下代码添加到 `fragment_game.xml` 布局的左侧列：
- en: '[PRE216]'
  id: totrans-1830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: We have a `TextView` that displays the text "`Lives`"`:` and a horizontal `LinearLayout`
    in which we will add and remove `ImageViews` when we receive the respective `GameEvents`.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个显示文本 "`Lives`"` 的 `TextView` 和一个水平方向的 `LinearLayout`，当我们收到相应的 `GameEvents`
    时，我们将在其中添加和移除 `ImageViews`。
- en: 'The code for `LivesCounter` is as easy as this:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: '`LivesCounter` 的代码就像这样简单：'
- en: '[PRE217]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: As you can see, this class does not take into account the amount of lives that
    the player has. It only reacts to the events `LifeAdded` and `LifeLost` by adding
    or removing an item to the `LinearLayout`.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个类并没有考虑到玩家拥有的生命值数量。它只通过向`LinearLayout`添加或移除项目来响应`LifeAdded`和`LifeLost`事件。
- en: 'We add and remove views by posting a runnable object for the same reason as
    for the `ScoreGameObject`: modifying views must be done in the `UIThread`, and
    `onDraw` does run in the `UpdateThread` when we use `SurfaceGameView`.'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过发布一个可运行的runnable对象来添加和移除视图，这与`ScoreGameObject`的原因相同：修改视图必须在`UIThread`中完成，而当我们使用`SurfaceGameView`时，`onDraw`确实在`UpdateThread`中运行。
- en: 'The last piece is the layout `view_spaceship.xml` we are inflating, which is
    just an `ImageView`:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分是我们正在填充的布局`view_spaceship.xml`，它只是一个`ImageView`：
- en: '[PRE218]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The dimension `life_size` is set to 30dp in the file `dimens.xml` file, so there
    is enough horizontal space for three spaceships.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dimens.xml`文件中，`life_size`维度被设置为30dp，因此有足够的空间放置三个飞船。
- en: '![Adding lives](img/B04757_07_06.jpg)'
  id: totrans-1839
  prefs: []
  type: TYPE_IMG
  zh: '![添加生命值](img/B04757_07_06.jpg)'
- en: Custom dialogs
  id: totrans-1840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义对话框
- en: The next step in making our UI nicer is to stop using the standard Android dialogs
    and create our own custom ones instead. Once again this is something completely
    discouraged for apps but it makes a lot of sense for games.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的UI更美观的下一步是停止使用标准的Android对话框，而是创建我们自己的自定义对话框。再次强调，这完全是不被鼓励在应用程序中做的事情，但对于游戏来说却非常有意义。
- en: 'There are many reasons why a custom dialog system is better for games:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多原因说明为什么自定义对话框系统更适合游戏：
- en: The default dialogs will look different in different Android versions. This
    is in fact great when you use `AlertDialog` in an app, since it mimics the dialogs
    of all the rest of the apps, but not the games. We want consistency.
  id: totrans-1843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认对话框在不同版本的Android上看起来会有所不同。事实上，当你在应用程序中使用`AlertDialog`时，这实际上是非常好的，因为它模仿了其他所有应用程序的对话框，但不是游戏的。我们想要一致性。
- en: Default dialogs use the system font.
  id: totrans-1844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认对话框使用系统字体。
- en: If you try to set a custom background or a custom content view, `AlertDialogs`
    look terrible. Again, you should never do that in an app, but you definitely want
    it in a game.
  id: totrans-1845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试设置自定义背景或自定义内容视图，`AlertDialogs`看起来会很糟糕。同样，你绝对不应该在应用程序中这样做，但在游戏中你肯定想要。
- en: The standard dialogs ruin the immersive experience by showing the notifications
    and system bars when they are on screen.
  id: totrans-1846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准对话框通过在屏幕上显示通知和系统栏来破坏沉浸式体验。
- en: It is hard to replace the animations of `AlertDialog` with custom ones.
  id: totrans-1847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用自定义动画替换`AlertDialog`的动画很困难。
- en: We are going to build a system that shows our dialogs on screen, with a gray
    semi‑transparent overlay behind them. These dialogs will have a custom background
    made out of a shape drawable and will use the custom font we have selected for
    the game.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个系统，在屏幕上显示我们的对话框，并在它们后面显示一个灰色半透明的覆盖层。这些对话框将使用由形状可绘制物制成的自定义背景，并使用我们为游戏选定的自定义字体。
- en: Finally, the dialog itself is just a layout we put in front of the content.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对话框本身只是我们放在内容前面的一个布局。
- en: It is worth noting that we need to define a policy for what to do when we are
    showing a dialog and a new one is trying to display on top. In our game, the old
    dialog will stay and the new one will not be displayed, but nevertheless we will
    provide a method to dismiss the previous one and show the new one in case you
    want that behavior in your game.
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当我们显示一个对话框而另一个新的对话框试图显示在顶部时，我们需要定义一个策略。在我们的游戏中，旧对话框将保持，新对话框将不会显示，但无论如何，我们将提供一个方法来关闭前一个对话框并显示新的对话框，以防你在游戏中想要这种行为。
- en: We are going to describe the architecture first (including modifications to
    `YassBaseFragment`), and then we will start by making the dialog for quitting
    the game because it is the simplest one. After that we will replace the current
    pause dialog and finally we will make a new dialog for game over.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将描述架构（包括对`YassBaseFragment`的修改），然后我们将从制作退出游戏的对话框开始，因为它是最简单的。之后，我们将替换当前的暂停对话框，最后我们将制作一个新的游戏结束对话框。
- en: BaseCustomDialog
  id: totrans-1852
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BaseCustomDialog
- en: 'The custom dialog framework we are going to create is composed of three items:'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的自定义对话框框架由三个项目组成：
- en: '`BaseCustomDialog`: the base class of all the dialogs'
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseCustomDialog`：所有对话框的基础类'
- en: '`my_overlay_dialog`: a layout that is the parent of all the dialogs'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_overlay_dialog`：所有对话框的父布局'
- en: Utility functions in the base fragment class
  id: totrans-1856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础片段类中的实用函数
- en: Most of the work is done in the `BaseCustomDialog` class, which provides methods
    to `setContentView`, `show`, and `dismiss`.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作都是在`BaseCustomDialog`类中完成的，它提供了`setContentView`、`show`和`dismiss`等方法。
- en: 'The complete code of `BaseCustomDialog` class is as follows:'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseCustomDialog` 类的完整代码如下：'
- en: '[PRE219]'
  id: totrans-1859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: During construction we store the reference to the main activity into the member
    variable `mParent`, to be used later.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，我们将主活动的引用存储到成员变量 `mParent` 中，以便稍后使用。
- en: 'There are a few other member variables in the class:'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 类中还有一些其他的成员变量：
- en: '`mRootLayout`: this is the layout we inflate that is common to all dialogs
    and which is used as a background.'
  id: totrans-1862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mRootLayout`：这是我们为所有对话框充气的布局，它用作背景。'
- en: '`mRootView`: the root of the content view. This is used to show and hide the
    dialog itself.'
  id: totrans-1863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mRootView`：内容视图的根。这用于显示和隐藏对话框本身。'
- en: '`mIsShowing`: a variable to determine whether the dialog is showing or not.'
  id: totrans-1864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mIsShowing`：一个变量，用来确定对话框是否正在显示。'
- en: During `setContentView`, we inflate the view for the dialog and store the reference
    in `mRootView`, but we do not add it to any `ViewGroup` yet. For inflation, we
    use the parameters of the content view of the app (`android.R.id.content`). The
    last parameter of the inflate method is used to determine if the system should
    add the view as a child of the parent or not. We pass `false`, so the view does
    not get added to the hierarchy. Finally we apply the custom typeface to it.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setContentView` 期间，我们充气对话框的视图并将其引用存储在 `mRootView` 中，但我们还没有将其添加到任何 `ViewGroup`
    中。对于充气，我们使用应用程序的内容视图的参数（`android.R.id.content`）。充气方法的最后一个参数用于确定系统是否应该将视图添加为父视图的子视图。我们传递
    `false`，因此视图不会被添加到层次结构中。最后，我们将其应用到自定义字型上。
- en: Note that `setContentView` is usually called during construction and not during
    show; that is the reason why the views are not added to the hierarchy at this
    point.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setContentView` 通常在构建期间调用，而不是在显示期间；这就是为什么在这个点上视图没有被添加到层次结构中的原因。
- en: To show the dialog, we first check if it is already being shown and, if that
    is the case, we return and do nothing. Otherwise we set `mIsShowing` to `true`
    and proceed.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示对话框，我们首先检查它是否已经被显示，如果是的话，我们就返回并什么都不做。否则，我们将 `mIsShowing` 设置为 `true` 并继续进行。
- en: To properly show the dialog, we inflate the root layout and add it to the main
    content, then we add the root view to it. This makes the dialog the foremost item
    in the foreground of the view hierarchy.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确显示对话框，我们充气根布局并将其添加到主要内容中，然后我们将其根视图添加到其中。这使得对话框成为视图层次结构前景中的最前面项。
- en: We also add the class as a touch listener that does nothing to `mRootLayout`.
    This has the purpose of filtering out all the touch and click events in items
    that are behind the dialog. If we want a dialog to be dismissed when the user
    clicks outside its bounds, we just need to add a call to `dismiss` inside this
    listener.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将该类作为触摸监听器添加到 `mRootLayout`，但它什么都不做。这的目的是过滤掉对话框后面的所有触摸和点击事件。如果我们想让对话框在用户点击其边界之外时消失，我们只需在这个监听器内部添加对
    `dismiss` 的调用即可。
- en: Finally, `dismiss` first checks that the dialog is showing, and if so it removes
    the views from the hierarchy.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`dismiss` 首先检查对话框是否正在显示，如果是的话，它将移除视图层次结构中的视图。
- en: We also have utility methods such as `findViewById` and `isShowing`.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有如 `findViewById` 和 `isShowing` 这样的实用方法。
- en: 'The layout for `mRootLayout` is just a gray semi-transparent overlay and its
    code is like this:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '`mRootLayout` 的布局只是一个灰色的半透明覆盖层，其代码如下：'
- en: '[PRE220]'
  id: totrans-1873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Note that this is already designed to make it easy to add animations to the
    process of showing and dismissing the dialog (discussed in the next chapter).
    This is particularly true when it comes to having a completely gray background
    independent of the content view.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这已经设计得很容易添加动画到显示和取消对话框的过程（将在下一章中讨论）。这尤其适用于拥有完全灰色的背景，且与内容视图无关的情况。
- en: The last stage in our dialog framework is to provide some utility methods in
    the base fragment to facilitate using our custom dialogs.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对话框框架的最后一个阶段是在基础片段中提供一些实用方法，以方便使用我们的自定义对话框。
- en: '[PRE221]'
  id: totrans-1876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: We are going to show a dialog by calling the `showDialog` method on the fragment.
    This will store a reference to the dialog currently being displayed that can be
    used to determine if there is something else being shown and dismiss it if required.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在片段上调用 `showDialog` 方法来显示对话框。这将存储当前显示的对话框的引用，可以用来确定是否还有其他内容正在显示，并在需要时将其取消。
- en: By default we are going to not display a dialog if another one is already on
    the screen but, in the event you want to do it in your game, there is a version
    of `showDialog` that receives a boolean parameter to dismiss other dialogs, if
    present.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果屏幕上已经有一个对话框，我们不会显示对话框，但如果你想在游戏中这样做，`showDialog`有一个版本接受一个布尔参数，如果存在，则关闭其他对话框。
- en: We also take care of handling the back key presses and use them to dismiss a
    dialog if it is being shown and return `true`, to indicate that the event has
    been consumed by the fragment.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还负责处理返回键的按下，并使用它们来关闭显示的对话框，并返回`true`，以指示事件已被片段消耗。
- en: Now that we have all the foundations, let's make a quit dialog for our game.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有的基础，让我们为我们的游戏创建一个退出对话框。
- en: Quit dialog
  id: totrans-1881
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出对话框
- en: The quit dialog has to appear when the back key is pressed while in the `MainMenuFragment`.
    It will display some text and two buttons to exit or continue playing.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`MainMenuFragment`中按下返回键时，必须显示退出对话框。它将显示一些文本和两个按钮，用于退出或继续游戏。
- en: This is a simple dialog that will help us understand how all the pieces fit
    into the architecture before we start creating more complex dialogs.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的对话框，它将帮助我们理解在开始创建更复杂的对话框之前，所有这些部分是如何融入架构中的。
- en: We will create the file `dialog_game_over.xml` under the `layouts` folder to
    define it. We are using a naming convention that gives all dialog layout definitions
    a name that starts with dialog (similar to the convention for fragments and activities).
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`layouts`文件夹下创建名为`dialog_game_over.xml`的文件来定义它。我们使用了一种命名约定，即所有对话框布局定义都以“对话框”开头（类似于片段和活动的约定）。
- en: 'The layout is as follows:'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 布局如下：
- en: '[PRE222]'
  id: totrans-1886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'This is quite simple, but we still have a few remarks to make:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，但我们还有一些注意事项：
- en: The buttons will have the IDs `btn_exit` and `btn_resume`, and they use a transparent
    image we got from a free icon set.
  id: totrans-1888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮将具有`btn_exit`和`btn_resume`的ID，并使用我们从免费图标集中获得的透明图像。
- en: Both buttons use the style `iconButton` we created for the home screen, which
    sets the round state list background image.
  id: totrans-1889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个按钮都使用了我们在主页面上创建的`iconButton`样式，它设置了圆形状态列表背景图像。
- en: To make the buttons centered, we place them into a `LinearLayout` that is itself
    centered in the `RelativeLayout`. This is the easiest way to center several buttons.
  id: totrans-1890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使按钮居中，我们将它们放置在一个自身在`RelativeLayout`中居中的`LinearLayout`中。这是居中多个按钮的最简单方法。
- en: We use the drawable `dialog_bg` as background. It is a shape drawable similar
    to the one for the square buttons, but with different colors.
  id: totrans-1891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`dialog_bg`可绘制资源作为背景。它是一个类似于正方形按钮的形状可绘制资源，但颜色不同。
- en: The width and height of the dialog are extracted as dimensions. They will be
    the same for all dialogs. We have set them at 400x250dp.
  id: totrans-1892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框的宽度和高度被提取为尺寸。它们将适用于所有对话框。我们将其设置为400x250dp。
- en: 'The class that extends from `BaseCustomDialog` is quite simple as well:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 从`BaseCustomDialog`扩展的类同样很简单：
- en: '[PRE223]'
  id: totrans-1894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: In the constructor we set listeners to the buttons and then inside `onClick`
    we either just dismiss the dialog if resume is clicked, or dismiss the dialog
    and exit if exit is clicked.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们设置按钮的监听器，然后在`onClick`方法中，如果点击了继续，则仅关闭对话框；如果点击了退出，则关闭对话框并退出。
- en: This highlights the typical architecture we are going to use. The dialog has
    a custom listener associated, and there is a method in the listener for each particular
    action that can be triggered from the dialog.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 这突出了我们将要使用的典型架构。对话框有一个自定义的监听器相关联，并且监听器中有一个方法对应于可以从对话框触发的每个特定操作。
- en: Note
  id: totrans-1897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each dialog will have a listener with methods for each particular option the
    dialog presents.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对话框都将有一个监听器，其中包含针对对话框提供的每个特定选项的方法。
- en: Using an interface instead of the fragment class from which the dialog is called
    allows us to decouple the functionality and invoke the dialog from other places.
    It is also good practice in itself.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口而不是调用对话框的片段类，我们可以解耦功能，并从其他地方调用对话框。这本身也是一种良好的实践。
- en: 'Now, `MainFragment` is responsible for showing this dialog and is also the
    class that implements `QuitDialogListener`. Let''s look at the code we have to
    change in the fragment to handle the dialog:'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`MainFragment`负责显示这个对话框，同时也是实现`QuitDialogListener`的类。让我们看看在片段中我们需要更改的代码来处理对话框：
- en: '[PRE224]'
  id: totrans-1901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: This is fairly simple. In the case of back pressed, we first check if the parent
    fragment handles the event (that is, if a dialog is being shown). If `false` is
    returned we create a `QuitDialog`, set this fragment to be the listener, and use
    the method `showDialog` of the base class to show it.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。在按返回键的情况下，我们首先检查父片段是否处理了事件（也就是说，如果正在显示对话框）。如果返回 `false`，我们创建一个 `QuitDialog`，设置此片段为监听器，并使用基类的
    `showDialog` 方法来显示它。
- en: Either way the event is consumed by this fragment, so `onBackPressed` always
    returns `true`.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，事件都会被这个片段消耗，所以 `onBackPressed` 总是返回 `true`。
- en: The method we have to implement because of the `QuitDialogListener` interface
    is `exit`, which is as simple as getting the parent `Activity` and calling `finish`
    in it.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `QuitDialogListener` 接口，我们必须实现的方法是 `exit`，这就像获取父 `Activity` 并在其中调用 `finish`
    一样简单。
- en: '![Quit dialog](img/B04757_07_07.jpg)'
  id: totrans-1905
  prefs: []
  type: TYPE_IMG
  zh: '![退出对话框](img/B04757_07_07.jpg)'
- en: Pause dialog
  id: totrans-1906
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停对话框
- en: Let's do something a bit more complex. We are going to replace the existing
    Pause dialog with a custom one, and we will also add buttons to control sounds
    and music.
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些更复杂的事情。我们将用自定义对话框替换现有的暂停对话框，并且我们还将添加按钮来控制声音和音乐。
- en: 'Again, we have some pieces that have to come together:'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有一些必须组合在一起的部件：
- en: A layout for the dialog
  id: totrans-1909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框的布局
- en: A class that extends `BaseCustomDialog` to handle it
  id: totrans-1910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展 `BaseCustomDialog` 的类来处理它
- en: A listener interface for the actions performed in the dialog
  id: totrans-1911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框中执行的操作的监听器接口
- en: Code in the `GameFragment` to handle it
  id: totrans-1912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `GameFragment` 中的代码来处理它
- en: Let's start with the layout. This one will have two groups of buttons, one at
    the bottom left for exit and resume, and one at the bottom right for the sound
    and music settings.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从布局开始。这个布局将有两个按钮组，一个在左下角用于退出和继续，另一个在右下角用于声音和音乐设置。
- en: 'The layout is a simple `RelativeLayout`:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是一个简单的 `RelativeLayout`：
- en: '[PRE225]'
  id: totrans-1915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Each button is aligned to the left or right of another button or the dialog
    itself. Given how we have picked the dimensions of the dialog frame and the buttons,
    we can ensure that the four buttons will fit in the screen nicely. We are also
    sure that this dialog will look the same on all devices.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都对齐到另一个按钮或对话框本身的左侧或右侧。鉴于我们已经选择了对话框框架和按钮的尺寸，我们可以确保四个按钮将很好地适应屏幕。我们也确信这个对话框在所有设备上看起来都一样。
- en: '![Pause dialog](img/B04757_07_08.jpg)'
  id: totrans-1917
  prefs: []
  type: TYPE_IMG
  zh: '![暂停对话框](img/B04757_07_08.jpg)'
- en: The code for the **Pause** dialog itself is a little more complex than the one
    for `QuitDialog`, mainly because it has four different actions; it also needs
    to check the sound and music status to decide which image to use.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: '**暂停**对话框本身的代码比 `QuitDialog` 的代码要复杂一些，主要是因为它有四个不同的操作；它还需要检查声音和音乐状态来决定使用哪个图像。'
- en: 'Let''s dig into the code:'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入代码：
- en: '[PRE226]'
  id: totrans-1920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The structure is the same as before. We set the class to be the click listener
    for each button, and react accordingly inside `onClick`. We have hidden the code
    of `updateSoundAndMusicButtons` because it is very similar to the one in `MainFragment`.
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 结构与之前相同。我们设置每个按钮的类作为点击监听器，并在 `onClick` 中相应地做出反应。我们已经隐藏了 `updateSoundAndMusicButtons`
    的代码，因为它与 `MainFragment` 中的代码非常相似。
- en: Note that `PauseDialogListener` only cares about exiting and resuming the game.
    Modifications to the sound status are done directly through the `SoundManager`,
    which is accessed via the parent activity.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PauseDialogListener` 只关心退出和继续游戏。对声音状态的修改是通过 `SoundManager` 直接完成的，它通过父活动访问。
- en: 'The last part is the modifications in `GameFragment`; this is basically replacing
    the old `AlertDialog.Builder` with the new class, since the other functionality
    was already there:'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是 `GameFragment` 中的修改；这基本上是将旧的 `AlertDialog.Builder` 替换为新的类，因为其他功能已经存在：
- en: '[PRE227]'
  id: totrans-1924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Game Over dialog
  id: totrans-1925
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束对话框
- en: Let's go for one more dialog, the **Game Over** one that will ask us to choose
    between playing again or exiting to the main menu. To handle the `GameOverDialog`,
    we need to add some code to the `GameFragment` to start a new game. We will extract
    the code we already have for that into a method that can be called from the fragment.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来一个对话框，即 **游戏结束** 对话框，它将询问我们是在重新开始游戏还是退出到主菜单。为了处理 `GameOverDialog`，我们需要在
    `GameFragment` 中添加一些代码来开始新游戏。我们将提取我们已有的代码到一个可以从片段中调用的方法中。
- en: We also need access to the fragment from "somewhere" inside the `GameEngine`
    to be able to display the dialog when the event happens. We are going to do that
    by passing the fragment to the `GameController`.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从 `GameEngine` 的“某个地方”访问片段，以便在事件发生时显示对话框。我们将通过将片段传递给 `GameController` 来做到这一点。
- en: The dialog itself is very similar to `PauseDialog`, so we will not include the
    layout or the code here, just the interface we have defined for it that we called
    `GameOverDialogListener`.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 该对话框本身与 `PauseDialog` 非常相似，所以我们不会在这里包含布局或代码，只包含我们为其定义的接口，我们称之为 `GameOverDialogListener`。
- en: '[PRE228]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '![Game Over dialog](img/B04757_07_09.jpg)'
  id: totrans-1930
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束对话框](img/B04757_07_09.jpg)'
- en: Let's start with the modifications to `GameFragment`. This class will be the
    one implementing `GameOverDialogListener`.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对 `GameFragment` 的修改开始。这个类将实现 `GameOverDialogListener`。
- en: As it happens, `GameFragment` already has a method called `exitGame`, which
    we were invoking from the `PauseDialog`, so the only one to implement is `startNewGame`.
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`GameFragment` 已经有一个名为 `exitGame` 的方法，我们是从 `PauseDialog` 中调用的，所以唯一需要实现的是
    `startNewGame`。
- en: 'For that we are going to extract all the logic for creating the `GameEngine`
    to a method and then we will call it from the two places where a game can start:'
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建 `GameEngine` 的所有逻辑提取到一个方法中，然后从游戏可以开始的两个地方调用它：
- en: The `onGlobalLayout` method when the fragment is created and measured
  id: totrans-1934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当片段创建和测量时调用的 `onGlobalLayout` 方法
- en: '`startNewGame` when the "**Play Again?**" button is clicked on the `GameOver`
    dialog'
  id: totrans-1935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在 `GameOver` 对话框中点击 "**再玩一次？**" 按钮时，`startNewGame`。
- en: 'The code is like this:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE229]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: When we start the game, we first have to stop the previous one. Even when the
    `GameOverDialog` is in front, the `GameEngine` is not paused or stopped. In fact
    we can see the parallax background moving behind the dialog. This is a nice effect
    and we want to keep it like that, but that means we need to stop the current game
    before starting a new one or we will have two engines running at the same time,
    which is terrible for performance and battery life.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始游戏时，我们首先必须停止上一个游戏。即使 `GameOverDialog` 在前面，`GameEngine` 也不会暂停或停止。实际上，我们可以看到透视背景在对话框后面移动。这是一个很好的效果，我们希望保持这种效果，但这意味着在开始新游戏之前我们需要停止当前游戏，否则我们将有两个引擎同时运行，这对性能和电池寿命都是灾难性的。
- en: Note that there is no creation of a `Player` in the initialization. This is
    something we removed when we made the `GameController` manage the lives, but it
    is worth highlighting this again.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，初始化过程中没有创建 `Player`。这是我们在使 `GameController` 管理生命值时移除的，但再次强调这一点是值得的。
- en: On the other hand we need to be able to show a dialog from inside the `GameController`
    since the utility methods for showing dialogs are implemented on the base fragment.
    That is why we need to pass a parameter to the constructor and store it as a member
    variable.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们需要能够在 `GameController` 内部显示对话框，因为显示对话框的实用方法是在基础片段中实现的。这就是为什么我们需要向构造函数传递一个参数并将其存储为成员变量的原因。
- en: '[PRE230]'
  id: totrans-1941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: As part of the handling of the `GameOver` event, we create and show the `GameOverDialog`.
    Note that since game events arrive in the `UpdateThread` and the creation and
    display of the dialog must be run on the `UIThread`, we need to use a `Runnable`
    object.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 作为处理 `GameOver` 事件的一部分，我们创建并显示 `GameOverDialog`。请注意，由于游戏事件在 `UpdateThread` 中到达，而对话框的创建和显示必须在
    `UIThread` 上运行，因此我们需要使用 `Runnable` 对象。
- en: Other dialogs
  id: totrans-1943
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他对话框
- en: 'There are two more dialogs in the game that we have not worked with yet. Those
    dialogs are:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中还有两个我们尚未处理的对话框。这些对话框是：
- en: The Notice dialog of a controller being connected.
  id: totrans-1945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器连接的通知对话框
- en: The Touch Control information dialog
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸控制信息对话框
- en: Both dialogs are just an image, and tapping on them should dismiss them so there
    are neither complex layouts nor any need for custom listeners.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对话框只是一个图像，点击它们应该关闭它们，因此既没有复杂的布局，也不需要自定义监听器。
- en: 'We will, however, work on the controller connected dialog in [Chapter 10](ch30.html
    "Chapter 10. To the Big Screen"), *To the Big Screen* because we want to show
    it in different circumstances: on a TV rather than on a phone.'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将在第 [10 章](ch30.html "第10章。迈向大屏幕") "迈向大屏幕" 中处理与控制器连接的对话框，因为我们希望在不同的环境下显示它：在电视上而不是在手机上。
- en: Designing for multiple screen sizes
  id: totrans-1949
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多个屏幕尺寸设计
- en: While we have designed our `GameView` to scale equally in all screen sizes and
    aspect ratios by making use of the appropriate screen units, Android views do
    not work this way; however, we can follow the standard Android procedures for
    them.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经通过使用适当的屏幕单位使我们的 `GameView` 在所有屏幕尺寸和纵横比中均匀缩放，但 Android 视图并不这样做；然而，我们可以遵循标准
    Android 程序来处理它们。
- en: For apps, it is recommended that you tweak the layout based on the screen size.
    For games it makes sense to keep the same layout across all screen sizes and only
    vary the size and margins of some items.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，建议根据屏幕尺寸调整布局。对于游戏，保持所有屏幕尺寸相同的布局并仅调整某些项目的尺寸和边距是有意义的。
- en: Note
  id: totrans-1952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Games should keep the same layout for all screen sizes.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏应保持所有屏幕尺寸相同的布局。
- en: As a rule of thumb, you should always use `RelativeLayout` to design your layouts,
    where every item on the screen is positioned relative to something else. This
    allows the layout to adapt smoothly to all screen sizes. This concept is at the
    core of responsive design.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，你应该始终使用`RelativeLayout`来设计你的布局，其中屏幕上的每个项目都是相对于其他项目定位的。这允许布局平滑地适应所有屏幕尺寸。这个概念是响应式设计的核心。
- en: To have a proper display in all screen sizes, we are going to qualify the dimensions;
    this is included on the Android SDK and is recommended practice.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在所有屏幕尺寸上正确显示，我们将指定尺寸；这是Android SDK的一部分，也是推荐的做法。
- en: Note
  id: totrans-1956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Qualifying dimensions is a best practice for apps and games.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 指定尺寸是应用程序和游戏的最佳实践。
- en: Qualifying resources works by selecting different dimension specifications based
    on the screen sizes and applying them dynamically. Note that since Android 3.2
    qualifying resources using the `normal`, `large`, and `xlarge` keywords has been
    considered obsolete (although it is the first thing you find when looking at the
    documentation).
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 根据屏幕尺寸选择不同的尺寸规范并动态应用资源，这是通过指定资源实现的。注意，自Android 3.2以来，使用`normal`、`large`和`xlarge`关键字进行资源指定已被视为过时（尽管这是查看文档时首先看到的内容）。
- en: 'There are three ways to qualify resources based on screen size:'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 根据屏幕尺寸，有三种方法来指定资源：
- en: '**Smallest width**: this takes the smallest width of the device regardless
    of whether it is in landscape or in portrait. This is useful when you need to
    guarantee the minimum size of any dimension. It does not change on screen rotation.'
  id: totrans-1960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小宽度**：无论设备是横屏还是竖屏，都取设备的最小宽度。这在需要保证任何尺寸的最小大小时很有用。它不会在屏幕旋转时改变。'
- en: '**Available screen width**: the current screen width. Note that this changes
    when the orientation changes, and other resources, such as layouts, may change
    as well.'
  id: totrans-1961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用屏幕宽度**：当前屏幕宽度。注意，当方向改变时，这会发生变化，其他资源，如布局，也可能发生变化。'
- en: '**Available screen height**: complementary to the previous one.'
  id: totrans-1962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用屏幕高度**：与上一个选项互补。'
- en: The way to use these is to create a `resources` directory appending the qualifier,
    such as `values-sw720dp` or `values-w820dp`. Note that these qualifiers are defined
    in dips.
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些资源的方法是创建一个带有后缀的`resources`目录，例如`values-sw720dp`或`values-w820dp`。注意，这些后缀是在dips中定义的。
- en: A normal phone will have values between 320x480dp and 480x800dp since they can
    vary from 3.2 to over 5 inches.
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通手机的大小在320x480dp到480x800dp之间，因为它们可以从3.2英寸到超过5英寸不等。
- en: A 7'' tablet will start at around 600x960dp.
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7英寸平板电脑的起始分辨率大约为600x960dp。
- en: A 10'' tablet will typically have at least 720x1280dp.
  id: totrans-1966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10英寸平板电脑的典型分辨率至少为720x1280dp。
- en: We are going to qualify some dimensions based on the available screen width
    and we are going to separate phones, small tablets, and large tablets. We will
    use the directories `values-w820dp` (which is already created by the wizard) and
    `values-w1024dp`.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据可用屏幕宽度指定一些尺寸，并将手机、小型平板电脑和大型平板电脑分开。我们将使用`values-w820dp`（由向导已创建）和`values-w1024dp`目录。
- en: 'Let''s look at the dimensions we have defined for our game so far:'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们为游戏定义的尺寸：
- en: '[PRE231]'
  id: totrans-1969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Note that since our `TextViews` are using the standard android styles, we have
    no dimensions for text sizes. If you are using your own styles for text, qualifying
    the text size is also advisable.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们的`TextViews`使用的是标准的Android样式，我们无法指定文本大小。如果你使用自己的样式来设置文本，建议也指定文本大小。
- en: We will not modify the size of the touch targets. Because of that, we are keeping
    the square and round button dimensions for all sizes.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会修改触摸目标的大小。因此，我们将保持所有尺寸的方形和圆形按钮尺寸。
- en: Note
  id: totrans-1972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The size of touch targets should not change in line with screen sizes.
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸目标的大小不应随着屏幕尺寸的变化而变化。
- en: The margins were defined by Android Studio for `w820dp` when we created the
    default project so we do not need to touch these either.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建默认项目时，Android Studio为`w820dp`定义了边距，所以我们也不需要修改这些。
- en: The margins of the game and the size of the dialogs are the dimensions we do
    need to update. This alone will make it look much better on 7" and 10" tablets.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的边距和对话框的大小是我们需要更新的维度。仅此一项，就能让7英寸和10英寸的平板电脑看起来好得多。
- en: Our worst case for phones is the narrowest one, when it has 480 dp width, because
    it leaves us with only 280 dp of game area. Even then though, this is more than
    50 percent of the screen and looks OK.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 对于手机来说，最糟糕的情况是宽度为480 dp的窄屏幕，因为它只给我们留下了280 dp的游戏区域。尽管如此，这仍然超过屏幕的50%，看起来还不错。
- en: On the other hand, the layout starts looking bad when the aspect ratio of the
    game is too wide. So for `w820dp` we will take 150 dp for the margin instead,
    and for `w1280dp` we will take 200 dp. You can easily play with the preview tool
    on Android Studio and tweak these values until you like the result. Life size
    should also be larger, since the space for three of them is also larger on those
    screens.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当游戏的宽高比过于宽时，布局开始看起来很糟糕。因此，对于`w820dp`，我们将使用150 dp作为边距，而对于`w1280dp`，我们将使用200
    dp。你可以轻松地在Android Studio的预览工具中调整这些值，直到你满意为止。在那些屏幕上，全尺寸也应该更大，因为三个它们的间距也更大。
- en: We will make the dialogs slightly larger on larger screens as well.
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会在更大的屏幕上使对话框稍微大一些。
- en: 'All in all, `values-w820dp` will have the following `dimens.xml`:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`values-w820dp`将具有以下`dimens.xml`：
- en: '[PRE232]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'While for `values-w1080dp` we will have these:'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于`values-w1080dp`，我们将有这些：
- en: '[PRE233]'
  id: totrans-1982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This technique allows us to modify the UI to adapt to larger screens without
    touching the layout at all.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术允许我们修改UI以适应更大的屏幕，而无需触摸布局。
- en: '![Designing for multiple screen sizes](img/B04757_07_10.jpg)'
  id: totrans-1984
  prefs: []
  type: TYPE_IMG
  zh: '![为多种屏幕尺寸设计](img/B04757_07_10.jpg)'
- en: Before and after qualifying the layouts for w820dp
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 在为w820dp合格前后
- en: Summary
  id: totrans-1986
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned how to customize the UI of our game using the standard tools,
    drawables, and views that Android provides. This includes custom fonts, state
    lists drawables, shape drawables and, especially, custom dialogs that replace
    the default ones in a way that matches the look and feel of our game.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用Android提供的标准工具、可绘制对象和视图来定制游戏的用户界面。这包括自定义字体、状态列表可绘制对象、形状可绘制对象，尤其是自定义对话框，它们以与我们的游戏外观和感觉相匹配的方式替换了默认对话框。
- en: We also modified the game to include a score and multiple lives. We modified
    the UI of the `GameFragment` to display both of them. For that functionality.
    we extended the game event system to work as an event bus for all the `GameObjects`.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了游戏以包括得分和多个生命值。我们修改了`GameFragment`的UI以显示这两个功能。为此，我们扩展了游戏事件系统，使其作为所有`GameObjects`的事件总线工作。
- en: While the game is starting to look complete, it still feels a bit clunky at
    times and that is because we are not using any animations. In the next chapter
    we will learn the different techniques for animations that Android provides and
    will apply them.
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始看起来完整时，它有时仍然感觉有点笨拙，这是因为我们没有使用任何动画。在下一章中，我们将学习Android提供的不同动画技术，并将它们应用到游戏中。
- en: Chapter 8. The Animation Framework
  id: totrans-1990
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。动画框架
- en: Android provides a variety of powerful APIs to apply animation to UI elements.
    This chapter aims at providing an overview of the options available to help you
    decide which approach is best for your needs.
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了一系列强大的API来将动画应用于UI元素。本章旨在提供概述，帮助您决定哪种方法最适合您的需求。
- en: Before we start adding animations, we will refactor our code a bit to make the
    usage of animations easier by creating a callback on our base fragment once the
    layout has been completed.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始添加动画之前，我们将对我们的代码进行一些重构，通过在布局完成后在我们的基础片段上创建一个回调，使动画的使用更加容易。
- en: Then, we will see how to define a traditional frame-by-frame animations that
    can be used in an `ImageView`. We will also see how to incorporate them in our
    `GameEngine` in the form of `AnimatedSprite`.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将了解如何定义传统的帧动画，这些动画可以在`ImageView`中使用。我们还将了解如何将它们以`AnimatedSprite`的形式纳入我们的`GameEngine`中。
- en: The core of the chapter is about the different ways to animate views. We will
    start talking about interpolators and their role in the Android Animation Framework.
    Then, we will learn about the old method called view animation and we will use
    it to animate some areas of the game, including how to show and hide our custom
    dialogs.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的核心是关于动画视图的不同方式。我们将从讨论插值器和它们在Android动画框架中的作用开始。然后，我们将了解旧的方法，即视图动画，并使用它来动画化游戏的一些区域，包括如何显示和隐藏我们的自定义对话框。
- en: Then, we will talk about `ValueAnimator`, `PropertyAnimator`, and finally, `ViewPropertyAnimator`,
    explaining how they are different, more versatile, and complex than view animations
    and in which cases each of them are preferred. We will also do some examples of
    them.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将讨论`ValueAnimator`、`PropertyAnimator`，最后是`ViewPropertyAnimator`，解释它们如何比视图动画更不同、更灵活、更复杂，以及在哪些情况下每个都是首选的。我们还将做一些它们的例子。
- en: Finally, we will animate the TextViews of the main screen using different approaches
    so you can check their differences and similarities.
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用不同的方法来动画化主屏幕的`TextView`，以便你可以检查它们的差异和相似之处。
- en: Updating BaseFragment
  id: totrans-1997
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`BaseFragment`
- en: Usually animations (especially `ViewPropertyAnimator`) require the layout of
    the views to be completed before they can be applied. We already have a method
    for this in the `GameFragment`, so we are going to generalize it and make it a
    part of the `BaseFragment`.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，动画（尤其是`ViewPropertyAnimator`）需要在应用之前完成视图的布局。我们已经在`GameFragment`中有一个处理这个问题的方法，所以我们将对其进行泛化，使其成为`BaseFragment`的一部分。
- en: 'The method uses `ViewTreeObserver` to check when the layout of the view has
    been completed. The code we will add to the `BaseFragment` is like this:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用`ViewTreeObserver`来检查视图布局何时完成。我们将添加到`BaseFragment`的代码如下：
- en: '[PRE234]'
  id: totrans-2000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Since we have removed a lot of code from `GameFragment`, the new version is
    much simpler:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`GameFragment`中移除了很多代码，新版本要简单得多：
- en: '[PRE235]'
  id: totrans-2002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: With these modifications, we can use `onLayoutCompleted` in the `MainMenuFragment`
    later in the chapter when we start adding animations.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，我们可以在本章后面添加动画时在`MainMenuFragment`中使用`onLayoutCompleted`。
- en: AnimationDrawable
  id: totrans-2004
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AnimationDrawable`'
- en: 'The `AnimationDrawable` is how you define a frame-by-frame animation in Android.
    It describes a drawable as a list of other drawable resources that are played
    sequentially to create an animation. This is an animation in the most traditional
    sense: a sequence of independent images, played one after another.'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationDrawable`是你在Android中定义逐帧动画的方式。它将可绘制资源描述为一系列其他可绘制资源，这些资源按顺序播放以创建动画。这是最传统的动画：一系列独立图像，依次播放。'
- en: 'We can define the frames of an animation in code using the `AnimationDrawable`
    class, but it is much easier to use XML. This file lists the frames that compose
    the animation and their duration. The XML is composed by a root node of the `<animation-list>`
    type and a series of child nodes of the `<item>` type that define a frame using
    a drawable resource and the frame duration:'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AnimationDrawable`类在代码中定义动画的帧，但使用XML会更简单。此文件列出了组成动画的帧及其持续时间。XML由一个`<animation-list>`类型的根节点和一系列定义帧的`<item>`类型子节点组成，这些节点使用可绘制资源和帧持续时间：
- en: '[PRE236]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: This XML file belongs to the `res/drawable/` directory of your Android project,
    because it is considered a drawable.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 此XML文件属于你的Android项目的`res/drawable/`目录，因为它被视为可绘制资源。
- en: Note
  id: totrans-2009
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `AnimationDrawable` resources are placed in the `drawable` directory.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationDrawable`资源放置在`drawable`目录中。'
- en: 'Let''s see this with an example. We are going to make a simple animation that
    makes the lights of our spaceship blink. For this, we will use four frames:'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看。我们将制作一个简单的动画，使我们的宇宙飞船的灯光闪烁。为此，我们将使用四个帧：
- en: Lights off (normal spaceship)
  id: totrans-2012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭灯光（正常宇宙飞船）
- en: Left light on
  id: totrans-2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开左灯
- en: Lights off (again)
  id: totrans-2014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭灯光（再次）
- en: Right light on
  id: totrans-2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开右灯
- en: Note that we can reuse the same drawable for different frames, allowing us to
    save some space.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以为不同的帧重用相同的可绘制资源，从而节省一些空间。
- en: '![AnimationDrawable](img/B04757_08_01.jpg)'
  id: totrans-2017
  prefs: []
  type: TYPE_IMG
  zh: '![AnimationDrawable](img/B04757_08_01.jpg)'
- en: The four frames of our spaceship animation
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 我们宇宙飞船动画的四个帧
- en: 'The definition of the spaceship with blinking lights is like this:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁灯光的宇宙飞船定义如下：
- en: '[PRE237]'
  id: totrans-2020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: We make the light stay on only for 400 milliseconds and then no lights for 600
    milliseconds. Then, we go for the other light.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让灯光只亮400毫秒，然后600毫秒没有灯光。然后，我们切换到另一盏灯。
- en: We have defined `oneShot` to `false`. This makes the animation repeat from the
    beginning once the last frame has finished. If you want to have animations that
    are played only once, you should set `oneShot` to `true`.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`oneShot`设置为`false`。这意味着一旦最后一帧完成，动画将从开始处重复。如果你想要只播放一次的动画，你应该将`oneShot`设置为`true`。
- en: 'To test this, we can add an `ImageView` to the layout of the main menu and
    set the `AnimationDrawable` for it:'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我们可以在主菜单布局中添加一个`ImageView`，并为其设置`AnimationDrawable`：
- en: '[PRE238]'
  id: totrans-2024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: If we try this, we will see that the animation does not work. `AnimationDrawable`
    is not auto played. Also, it's important to note that the `start` method of the
    `AnimationDrawable` cannot be called inside the activity's `onCreate` method,
    because the `AnimationDrawable` is not yet fully attached to the window. We will
    have to wait until the window is fully created, which will be notified by the
    `onWindowFocusChanged` method in the activity.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试这样做，我们会发现动画无法正常工作。`AnimationDrawable`不会自动播放。此外，需要注意的是，`AnimationDrawable`的`start`方法不能在活动的`onCreate`方法内部调用，因为`AnimationDrawable`尚未完全附加到窗口。我们必须等待窗口完全创建，这将在活动的`onWindowFocusChanged`方法中通知我们。
- en: Note
  id: totrans-2026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: AnimationDrawables are not played automatically, we have to start them in code.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 动画可绘制资源不会自动播放，我们必须在代码中启动它们。
- en: 'However, the animation can be started from the `onViewCreated` method of the
    fragment. Since we already have the `onLayoutCompleted` method that is called
    a bit later, we will use this one instead for consistency:'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，动画可以从片段的`onViewCreated`方法启动。由于我们已经有稍后调用的`onLayoutCompleted`方法，我们将使用这个方法以保持一致性：
- en: '[PRE239]'
  id: totrans-2029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'But this is not enough for us: `AnimationDrawable` defines a frame-by-frame
    animation that can be used in `ImageView`. What is really interesting is to be
    able to use this same XML definition to describe animated sprites. For this, we
    are going to create a new class that extends from `Sprite` and takes care of the
    animation.'
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 但这对我们来说还不够：`AnimationDrawable`定义了一个可以用于`ImageView`的逐帧动画。真正有趣的是能够使用相同的XML定义来描述动画精灵。为此，我们将创建一个新的类，它从`Sprite`扩展并处理动画。
- en: Animated sprites
  id: totrans-2031
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画精灵
- en: To create animated sprites, we need to take care of the specifics of `AnimationDrawable`.
    Since we already have all the code that draws a `Sprite` on the screen, the new
    `AnimatedSprite` class will only have to take care of counting the time to select
    which bitmap should be drawn.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建动画精灵，我们需要注意`AnimationDrawable`的细节。由于我们已经有在屏幕上绘制`Sprite`的所有代码，新的`AnimatedSprite`类只需负责计算时间以选择应该绘制的位图。
- en: Note that this will only work for `AnimationDrawable` when all the frames are
    defined as bitmaps, other XML resources such as shapes are not supported by our
    `Sprite` base class.
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅适用于所有帧都定义为位图的`AnimationDrawable`，我们的`Sprite`基类不支持其他XML资源，如形状。
- en: 'Let''s look at the code of `AnimatedSprite`:'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`AnimatedSprite`的代码：
- en: '[PRE240]'
  id: totrans-2035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: We have created a new method named `obtainDefaultBitmap` that is called from
    the constructor. For normal sprites, this method just returns the bitmap. In the
    case of `AnimatedDrawable`, we initialize it to the first frame.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`obtainDefaultBitmap`的新方法，该方法从构造函数中调用。对于普通精灵，此方法仅返回位图。在`AnimatedDrawable`的情况下，我们将其初始化为第一帧。
- en: The constructor has the same parameters as the normal sprite, but if the drawable
    resource is not an `AnimationDrawable`, a `ClassCastException` will be thrown.
    Error handling was not included to make the code easier to follow.
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数具有与普通精灵相同的参数，但如果可绘制资源不是`AnimationDrawable`，则会抛出`ClassCastException`。为了使代码更易于理解，没有包含错误处理。
- en: Another thing that is done in the constructor is the calculation of the total
    time of the `AnimationDrawable` by adding the duration of all the frames. We will
    need this value each time we run `onUpdate`, so we should get it in advance.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中做的另一件事是计算`AnimationDrawable`的总时间，即所有帧的持续时间之和。每次我们运行`onUpdate`时都需要这个值，因此我们应该提前获取它。
- en: During `onUpdate`, we add the elapsed milliseconds to the total time, then we
    check whether the total time the `AnimatedSprite` has been running is longer than
    the total time of the animation. If this is the case, we check whether `AnimationDrawable`
    is set to `oneShot` or not. If it is `oneShot`, we do nothing, since the last
    image has already been set. If the animation is to be repeated, we just make `mCurrentTime`
    get back into the interval by applying the module operator.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onUpdate`期间，我们将已过时的毫秒数添加到总时间，然后检查`AnimatedSprite`运行的总时间是否长于动画的总时间。如果是这种情况，我们检查`AnimationDrawable`是否设置为`oneShot`。如果是`oneShot`，我们不做任何事情，因为最后一帧已经设置。如果动画需要重复，我们只需通过应用模运算符使`mCurrentTime`回到间隔内。
- en: Once we know that the current time will be in the animation time range, we iterate
    over the frames, checking which one is the current frame and setting the bitmap
    in this frame to the `mImage` member variable, which is the one used by the base
    class to draw on the canvas.
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道当前时间将在动画时间范围内，我们就遍历帧，检查哪一个是当前帧，并将这个帧中的位图设置到`mImage`成员变量中，这是基类用来在画布上绘制的。
- en: Drawing the bitmap on the canvas is already done by the parent `Sprite` class.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制位图已经由父`Sprite`类完成了。
- en: Note that all the classes that extend from `AnimatedSprite` must call the super
    method while overriding `onUpdate.` Otherwise, the code that updates the image
    will not be executed.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有从`AnimatedSprite`扩展的类都必须在重写`onUpdate`时调用super方法。否则，更新图像的代码将不会执行。
- en: Note
  id: totrans-2043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When extending `AnimatedSprite`, don't forget to call super while overriding
    `onUpdate`.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展`AnimatedSprite`时，不要忘记在重写`onUpdate`时调用super。
- en: Now, let's animate our in-game spaceship.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为游戏中的飞船添加动画。
- en: 'We just need to update `Player` to extend from `AnimatedSprite`, change the
    image resource we pass to the constructor, and remember to call the super method
    in `onUpdate`:'
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将`Player`更新为从`AnimatedSprite`扩展，更改传递给构造函数的图像资源，并记得在`onUpdate`中调用super方法：
- en: '[PRE241]'
  id: totrans-2047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: We have a spaceship with blinking lights!
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个带有闪烁灯光的飞船！
- en: Animating views
  id: totrans-2049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化视图
- en: 'The Android framework provides two animation systems:'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: Android框架提供了两个动画系统：
- en: View animation
  id: totrans-2051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看动画
- en: Property animation
  id: totrans-2052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性动画
- en: View animation has been present since the first version of Android, while property
    animation was introduced in Android 3.0\. The latter is recommended, because it
    is more consistent and offers more features.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 视图动画自Android的第一个版本以来就存在了，而属性动画是在Android 3.0中引入的。后者是推荐的，因为它更一致，并且提供了更多功能。
- en: The view animation system can only be used to animate views. It is also constrained
    in that it only exposes a few aspects of a `View` object to animate, such as the
    scaling and rotation of a view but not the background color for instance.
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 视图动画系统只能用来动画化视图。它还受到限制，因为它只暴露了`View`对象的一些方面以进行动画化，例如视图的缩放和旋转，但不是例如背景颜色等。
- en: Another disadvantage of the view animation system is that it only modifies where
    the view is drawn and not the actual view itself. For example, if you animate
    a button to move across the screen, the button will draw correctly, but the actual
    location considered for a click on the button does not change and this can be
    problematic.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 视图动画系统的另一个缺点是它只修改视图的绘制位置，而不是实际的视图本身。例如，如果你将一个按钮动画化使其在屏幕上移动，按钮的绘制将是正确的，但按钮实际考虑的点击位置并没有改变，这可能会出现问题。
- en: Note
  id: totrans-2056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: View animation modifies the place where the view is drawn, not the view itself.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: View动画修改的是视图绘制的地方，而不是视图本身。
- en: On the other hand, the property animation system allows us to animate any property
    of any object (views and nonviews) and the object itself is actually modified.
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，属性动画系统允许我们动画化任何对象的任何属性（视图和非视图），并且对象本身实际上是被修改的。
- en: The view animation system, however, is easier to use and requires less code.
    If view animation accomplishes everything you need to do, there is no need to
    use the property animation system.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，视图动画系统更容易使用，并且需要的代码更少。如果视图动画能够完成你需要做的所有事情，就没有必要使用属性动画系统。
- en: Note
  id: totrans-2060
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: View animation is simpler. Property animation is more advanced.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 视图动画更简单。属性动画更高级。
- en: While using `ViewPropertyAnimation`, the animation only receives a parameter
    of the final value, because it is animated from the current one. This may require
    some initialization.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`ViewPropertyAnimation`时，动画只接收一个最终值的参数，因为它是从当前值动画化的。这可能需要一些初始化。
- en: All in all, it is good to know both the animation systems and apply the one
    that fits best for each case.
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，了解两个动画系统并应用最适合每个情况的系统是很好的。
- en: Regardless of the system, animations are usually easy to implement in Android,
    but it takes a lot of work to tweak the parameters to make the animation feel
    right. An animation that does not feel good is worse than no animation at all,
    but an animation that is right makes the game feel much nicer and smoother. Be
    prepared to pay a lot of attention to the detail while working on them.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是哪个系统，在Android中实现动画通常比较容易，但调整参数以使动画感觉正确则需要大量的工作。一个感觉不好的动画甚至比没有动画更糟，但一个正确的动画会使游戏感觉更加舒适和流畅。在处理它们时，请准备好投入大量的注意力到细节上。
- en: Note
  id: totrans-2065
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tweaking animations requires a lot of time.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 调整动画需要花费很多时间。
- en: As a rule of thumb, animations should be long enough to be noticeable (otherwise,
    adding them will be pointless), but not so long that they make the game feel slow.
    This means that a transition animation should have a duration between 300 and
    400 milliseconds.
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，动画应该足够长以引起注意（否则，添加它们将是徒劳的），但又不至于让游戏感觉缓慢。这意味着过渡动画的持续时间应该在300到400毫秒之间。
- en: XML versus code
  id: totrans-2068
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML与代码
- en: Both view animation and property animation (as almost any resource) can be defined
    in code or XML. Unless you require some value that could only be obtained in runtime
    it is better to use XML because all the files are external to the code and the
    animation can be modified without touching the Java source.
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 视图动画和属性动画（几乎任何资源）都可以在代码或XML中定义。除非你需要只能在运行时获得的一些值，否则最好使用XML，因为所有文件都是外部于代码的，并且可以修改动画而无需触摸Java源代码。
- en: Having the animations defined as a resource also allows us to use them at different
    places in the code and be sure that any change in the animation will affect all
    the places where it is used. If we define the animations in code we will have
    to check each place where the animation is built or rely on utility classes, which
    are not nice to handle.
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: 将动画定义为资源也允许我们在代码的不同地方使用它们，并且可以确信任何动画的变化都会影响它被使用的地方。如果我们用代码定义动画，我们就必须检查动画构建的每个地方，或者依赖于实用类，这并不容易处理。
- en: There is a middle ground where you can define the animation in XML and then
    read it and modify some of the parameters using code. This approach is quite powerful;
    it gives us control over the animation while keeping most of its definition outside
    the code.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中间地带，你可以使用XML定义动画，然后通过代码读取并修改一些参数。这种方法相当强大；它让我们在保持大多数定义在代码之外的同时控制动画。
- en: Interpolators
  id: totrans-2072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值器
- en: The animation system plays an animation between a start time and end time. Every
    frame of the animation is displayed at a specific time between the start and end.
    By default it follows a linear function, but this can be changed. In games, this
    technique is usually known as **tweening**, but in Android it is called **interpolation**.
    Let's see how it works.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 动画系统在开始时间和结束时间之间播放动画。动画的每一帧都在开始和结束之间的特定时间显示。默认情况下，它遵循线性函数，但这可以改变。在游戏中，这种技术通常被称为**缓动**，但在Android中它被称为**插值**。让我们看看它是如何工作的。
- en: Note
  id: totrans-2074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interpolators are the equivalent of tweening animations in general game jargon.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用游戏术语中，插值器相当于缓动动画。
- en: Animations use a time index to calculate the values. This time index is basically
    a normalized time, a value between 0.0 and 1.0.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 动画使用时间索引来计算值。这个时间索引基本上是一个归一化时间，一个介于0.0和1.0之间的值。
- en: In the simplest case, the value of the time index is taken to calculate the
    transformation of the object. In the case of a transformation, 0.0 corresponds
    to the start position, 1.0 to the end position, and 0.5 to halfway between the
    start and the end. This is exactly what the linear interpolator does.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，时间索引的值用于计算对象的转换。在转换的情况下，0.0对应于起始位置，1.0对应于结束位置，0.5对应于起始和结束之间的一半。这正是线性插值器所做的事情。
- en: In general, we can transform the time index into another value by using a mathematical
    function. This is exactly what an interpolator does.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以通过使用数学函数将时间索引转换成另一个值。这正是插值器所做的事情。
- en: A time interpolator is essentially a function that takes a value between 0.0
    and 1.0 and transforms it into another value that is used to calculate the animation
    as the time index.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 时间插值器本质上是一个函数，它接受一个介于0.0和1.0之间的值，并将其转换成另一个用于计算动画作为时间索引的值。
- en: Android provides a set of default interpolators that cover the basic configurations
    and should be enough for most cases. In case you need something very special,
    you can create your own interpolator that just needs to implement a one-method
    interface.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了一套默认的插值器，涵盖了基本配置，应该足够用于大多数情况。如果你需要非常特殊的东西，你可以创建自己的插值器，只需要实现一个单方法接口。
- en: 'We are not going to enter the detail of the mathematical functions, but just
    an overview of what they look like. The interpolators defined in Android are:'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会进入数学函数的细节，而只是概述它们的外观。Android中定义的插值器有：
- en: '**Linear**: a simple linear function.'
  id: totrans-2082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性**：一个简单的线性函数。'
- en: '**Cycle**: the animation follows a sinusoidal curve using time index 1 as a
    full circumference.'
  id: totrans-2083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**：动画使用时间索引1作为完整圆周的正弦曲线。'
- en: '**Bounce**: the animation bounces back a few times when it reaches the end.'
  id: totrans-2084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹跳**: 当动画到达末端时，会弹跳几次。'
- en: '**Decelerate**: the animation slows towards the end.'
  id: totrans-2085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减速**: 动画在结束时减速。'
- en: '**Accelerate**: the animation goes faster towards the end.'
  id: totrans-2086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速**: 动画在末端会变得更快。'
- en: '**AccelerateDecelerate**: The animation accelerates in the beginning and slows
    down at the end.'
  id: totrans-2087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速减速**: 动画在开始时加速，在结束时减速。'
- en: '**Overshoot**: The animation goes over the end and then goes back.'
  id: totrans-2088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超调**: 动画超过终点后返回。'
- en: '**Anticipate**: Before starting, the animation goes back to get an impulse.
    This is the opposite of overshoot.'
  id: totrans-2089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期**: 在开始之前，动画会返回以获得一个脉冲。这与超调相反。'
- en: '**AnticipateOvershoot**: This combines both overshoot and anticipate.'
  id: totrans-2090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期超调**: 这结合了超调和预期。'
- en: '![Interpolators](img/B04757_08_02.jpg)'
  id: totrans-2091
  prefs: []
  type: TYPE_IMG
  zh: '![插值器](img/B04757_08_02.jpg)'
- en: The different interpolators of Android
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的不同插值器
- en: There are a few more interpolators added to API level 21 for the animations
    that follow the Material Design guidelines. We do not really need them for a game.
    We want funny, good looking animations; we do not care if they do not look real,
    which is a core characteristic of Material Design.
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循 Material Design 指南的动画，API 级别 21 添加了一些额外的插值器。对于游戏，我们并不真的需要它们。我们想要有趣、好看的动画；我们并不关心它们是否看起来真实，这是
    Material Design 的核心特征。
- en: Interpolators are a common concept that can be applied to all the ways of animating
    views we are going to work with.
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 插值器是一个常见概念，可以应用于我们将要处理的动画的所有方式。
- en: View animation
  id: totrans-2095
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图动画
- en: The original and simpler way of animating views in Android is to use view animation.
    This creates an `Animation` object either by loading it from XML or programmatically,
    which is then applied to the view. They are relatively easy to set up and offer
    enough capabilities to meet most needs.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，动画视图的原始和简单方式是使用视图动画。这可以通过从 XML 加载或程序化创建一个`Animation`对象，然后将其应用于视图。它们相对容易设置，并且提供了足够的功能来满足大多数需求。
- en: 'There are some important details about view animations. They are as follows:'
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视图动画有一些重要的细节。它们如下：
- en: When we animate a view, all the children of the view are affected as well.
  id: totrans-2098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们动画化一个视图时，视图的所有子视图也会受到影响。
- en: Regardless of how your animation may move or resize, the bounds of the view
    that is animated will not automatically adjust to accommodate it. Even so, the
    animation will still be drawn beyond the bounds of its view and will not be clipped.
    However, clipping will occur if the animation exceeds the bounds of the parent
    view. This can be fixed by setting `clipChildren` to false in the parent view.
  id: totrans-2099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你的动画如何移动或调整大小，动画视图的边界将不会自动调整以适应它。即便如此，动画仍然会超出其视图边界并不会被裁剪。然而，如果动画超出父视图的边界，将会发生裁剪。这可以通过在父视图中设置`clipChildren`为`false`来修复。
- en: The views will return to their original state once the animation is completed.
    If you plan to use this type of animations to reveal or hide a view, you must
    be sure of setting its visibility to the desired state before the animation starts
    and after the animation ends. This can be easily achieved using a listener.
  id: totrans-2100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画完成后，视图将返回到其原始状态。如果你计划使用此类动画来显示或隐藏视图，你必须确保在动画开始之前和动画结束后将其可见性设置为所需状态。这可以通过使用监听器轻松实现。
- en: The bounds of the view are not changed during animation. This implies that the
    touch area is the same regardless of the place where the view is drawn. This is
    one of the most relevant reasons why we would want to use property animations
    instead.
  id: totrans-2101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图的边界在动画过程中不会改变。这意味着无论视图绘制在何处，触摸区域都是相同的。这是我们想要使用属性动画而不是视图动画的最相关原因之一。
- en: 'The files that define the animations must be placed under the `res/animation`
    folder and their definition is as follows:'
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 定义动画的文件必须放置在`res/animation`文件夹下，其定义如下：
- en: '[PRE242]'
  id: totrans-2103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Some of the attributes defined in the format are positions. They can be defined
    in three different ways:'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 格式中定义的一些属性是位置。它们可以以三种不同的方式定义：
- en: Pixels relative to the default position (for example 50)
  id: totrans-2105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于默认位置的像素（例如 50）
- en: Percentage relative to the View itself (for example 50%)
  id: totrans-2106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于视图本身的百分比（例如 50%）
- en: Percentage relative to the parent View (for example 50%p)
  id: totrans-2107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于父视图的百分比（例如 50%p）
- en: The usage of pixels is discouraged, the percentage relative to the view or the
    parent view is normally the way to go.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用像素，相对于视图或父视图的百分比通常是更好的选择。
- en: A set is nothing more than a way to group other properties. Most of the times,
    you'll use only one, but they can be nested to define more complex animations.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不过是一种将其他属性分组的方式。大多数时候，你只会使用一个，但它们可以嵌套以定义更复杂的动画。
- en: The set can have an interpolator, which will be applied to all the children
    if the `shareInterpolator` attribute is set to true. This allows all the animations
    to flow together smoothly. This is how it is used most of the time, but it is
    possible for each component to have its own interpolator.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 该集合可以有一个插值器，如果将`shareInterpolator`属性设置为true，则将应用于所有子元素。这允许所有动画流畅地一起流动。这通常是使用它的方式，但每个组件也可以有自己的插值器。
- en: The concepts are pretty much the same ones we already used when we used the
    transformation matrix on the `DrawThread`. We can scale, translate, rotate, and
    modify the alpha.
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念与我们之前在`DrawThread`上使用变换矩阵时使用的概念几乎相同。我们可以缩放、平移、旋转和修改透明度。
- en: Alpha is the simplest one; it just has initial and final values.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度是最简单的一个；它只有初始和最终值。
- en: Scale receives the initial and final scale on both axes and also the pivot point.
    This pivot point is the position from where the scale will be applied. It is usually
    provided as a percentage. The most common configuration is to put 50 percent on
    both axes, so it grows from the center of the view. But other configurations can
    work nicely like 0 percent on both, which will make it grow from the top left.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放接收两个轴上的初始和最终缩放值以及旋转中心点。这个旋转中心点是应用缩放的位置。它通常以百分比的形式提供。最常见的配置是将50%放在两个轴上，这样它就从视图的中心开始生长。但其他配置也可以很好地工作，比如两个轴上都是0%，这将使它从左上角开始生长。
- en: Translate receives the deltas of origin and the destination on both axes. They
    are also positions, and can be defined with references of the percentage to the
    parent view.
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 平移接收两个轴上的原点和目标点的增量。它们也是位置，可以用相对于父视图的百分比来定义。
- en: Rotate receives the from and to degrees and also the pivot point from which
    the rotation is applied. Note that this allows you to rotate a view from a position
    relative to the parent view or even outside the view itself, which may come in
    handy.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转接收从和到度数以及应用旋转的旋转中心点。请注意，这允许您从相对于父视图的位置或甚至视图本身之外的位置旋转视图，这可能很有用。
- en: 'There are a few attributes that are common to all the tags. They are as follows:'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些属性是所有标签共有的。它们如下：
- en: '`startOffset`: allows us to define an offset so the animation does not start
    straight away.'
  id: totrans-2117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startOffset`：允许我们定义一个偏移量，这样动画就不会立即开始。'
- en: '`duration`: defines how long the animation is going to last.'
  id: totrans-2118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`：定义动画将持续多长时间。'
- en: '`repeatCount`: allows us to make the animation repeat, either infinitely or
    a specific number of times.'
  id: totrans-2119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeatCount`：允许我们使动画重复，无论是无限重复还是特定次数。'
- en: '`repeatMode`: only used while repeating. It allows us to reverse the animation
    instead of repeating it from the beginning.'
  id: totrans-2120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeatMode`：仅在重复时使用。它允许我们反转动画而不是从开始重复。'
- en: '`interpolator`: The interpolator to use (in case `shareInterpolator` is set
    to false).'
  id: totrans-2121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpolator`：要使用的插值器（如果`shareInterpolator`设置为false）。'
- en: There is a known issue of `repeatCount` not working for sets when defined in
    XML, although it does work for individual animations. You can, however, set the
    `repeatCount` in code after loading the animation and this works too.
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 已知问题是在XML中为集合定义时`repeatCount`不起作用，尽管它对单个动画有效。然而，您可以在加载动画后通过代码设置`repeatCount`，这也有效。
- en: Note
  id: totrans-2123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: r`epeatCount` will not work when defined for sets in XML.
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 当在XML中为集合定义时，`repeatCount`将不起作用。
- en: The way a repeating animation interacts with `startOffset` could be counter
    intuitive. The offset is considered a part of the animation and it is therefore
    repeated. We will see an example of that later in this chapter.
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 重复动画与`startOffset`的交互方式可能不太直观。偏移量被视为动画的一部分，因此它会被重复。我们将在本章后面看到这个例子。
- en: Again, as happened with the transformation matrix, the order of the definition
    in the animation is very important. The result of first translate and then rotate
    is not the same as when we first rotate and then translate. This should be clear
    to everyone by now.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如变换矩阵发生的情况一样，动画中定义的顺序非常重要。首先平移然后旋转的结果与首先旋转然后平移的结果不同。现在应该对每个人都很清楚。
- en: Animating dialogs
  id: totrans-2127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画对话框
- en: We are going to animate the show and hide of dialogs in the game using view
    animations.
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用视图动画来动画化游戏中的对话框的显示和隐藏。
- en: Although we are not using the platform's default animations for the dialogs,
    it is advised to be consistent in our game and to ensure all the dialogs have
    the same animations. This is why the changes are to be made in a single place,
    so all the dialogs will use the same animations.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们未使用平台默认的动画效果来处理对话框，但建议在我们的游戏中保持一致性，并确保所有对话框都使用相同的动画。这就是为什么更改需要在单一位置进行，以确保所有对话框都使用相同的动画。
- en: 'Let''s see the modifications we have to make to `BaseCustomDialog` to add animations:'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要对`BaseCustomDialog`进行哪些修改以添加动画：
- en: '[PRE243]'
  id: totrans-2131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: We have a `startShowAnimation` method that is called at the end of `show`, and
    a `startHideAnimation` method that is called at the end of `dismiss`.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`startShowAnimation`方法，它在`show`方法结束时被调用，还有一个`startHideAnimation`方法，它在`dismiss`方法结束时被调用。
- en: Both methods are quite simple; they load an `Animation` using `AnimationUtils`
    and then apply it to `mRootView` using the `startAnimation` method.
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都很简单；它们使用`AnimationUtils`加载一个`Animation`，然后使用`startAnimation`方法将其应用到`mRootView`上。
- en: 'However, there are some details that need comments:'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些细节需要注释说明：
- en: We are adding views to the content just before starting the animation and removing
    them when the animation is done, so there is no need to change their visibility.
    In other cases (when the views remain in the hierarchy after the animation finishes),
    you may need to update the visibility of the view in the `AnimationListener`.
  id: totrans-2135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在动画开始前将视图添加到内容中，并在动画完成后移除它们，因此不需要更改它们的可见性。在其他情况下（当视图在动画完成后仍然保留在层次结构中时），你可能需要在`AnimationListener`中更新视图的可见性。
- en: The `BaseCustomDialog` implements `AnimationListener`, and we use it to detect
    when the hiding animation has finished to remove the views at that moment.
  id: totrans-2136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseCustomDialog`实现了`AnimationListener`接口，我们使用它来检测隐藏动画何时完成，以便在那个时刻移除视图。'
- en: We have a new method named `onDismissed`. This is called once the animation
    has ended. Until now, the dismissal of the dialog was an instantaneous operation.
    This is no longer the case. The actions that were done when dismissing should
    be moved to `onDismiss`.
  id: totrans-2137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`onDismissed`的新方法。这个方法在动画结束后被调用。到目前为止，对话框的关闭是一个瞬间操作。现在情况不再是这样了。在关闭对话框时执行的操作应该移动到`onDismiss`。
- en: 'We are using two variables to determine the status of the dialog: `mIsShowing`
    and `mIsHiding`. The dialog is considered to be showing from the moment the show
    animation begins till the dismiss animation is completed. However we should not
    dismiss a dialog that is already being dismissed, so there is a need for `mIsHiding`
    to prevent this case.'
  id: totrans-2138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用两个变量来确定对话框的状态：`mIsShowing`和`mIsHiding`。从显示动画开始到关闭动画完成，对话框被认为是显示状态。然而，我们不应该关闭一个已经正在关闭的对话框，因此需要`mIsHiding`来防止这种情况发生。
- en: 'The animations themselves are defined in XML, so they are independent of the
    fact that the dialogs are animated. We are going to see several animations for
    dialogs to get a deeper understanding of the framework and its possibilities.
    We will work with pairs of animations that are complementary:'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 动画本身是在XML中定义的，因此它们与对话框是否动画化无关。我们将查看几个对话框动画，以更深入地了解框架及其可能性。我们将使用成对的互补动画：
- en: Grow from center / shrink to center
  id: totrans-2140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从中心放大 / 向中心缩小
- en: Enter from top / exit through top
  id: totrans-2141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从顶部进入 / 从顶部退出
- en: To make the dialog grow and shrink from and to the center, we just need to use
    scale.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 要使对话框从中心放大和缩小，我们只需使用缩放即可。
- en: 'The code to grow from the center is like this:'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: 从中心放大的代码如下：
- en: '[PRE244]'
  id: totrans-2144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'The definition to shrink to the center is as follows:'
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 向中心缩小的定义如下：
- en: '[PRE245]'
  id: totrans-2146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: As you can see, both animations are similar but the parameters of `from` and
    `to` are reversed.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，两种动画都很相似，但`from`和`to`的参数是相反的。
- en: Note that we start on a scale of 0.5 instead of 0\. The animation of a smaller
    size is not really visible, mostly because of the decelerate interpolator, but
    you can set it to 0 if you want.
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从一个缩放值为0.5开始，而不是0。较小的尺寸动画实际上并不明显，这主要是因为减速插值器，但如果你想的话，可以将其设置为0。
- en: We also have the pivot point set to 50% on both axes. This is what makes it
    scale from the center.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将旋转中心点设置为两个轴上的50%。这就是它从中心缩放的原因。
- en: An interesting variant is to apply the scale only on one axis. It feels like
    the view is unfolded from the middle of the screen. This is left as an exercise
    for the reader.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的变体是只在单一轴上应用缩放。这感觉就像视图是从屏幕中间展开的。这留作读者的练习。
- en: The other pair of animations use translation instead of scale. We will make
    the dialog enter and exit from the top, but it is really easy to change the code
    to make it use any side of the screen.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一对动画使用平移而不是缩放。我们将使对话框从顶部进入和退出，但更改代码使其使用屏幕的任何一边非常容易。
- en: 'This is the animation''s definition to enter from the top:'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是动画从顶部进入的定义：
- en: '[PRE246]'
  id: totrans-2153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'This the code to exit through the top:'
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过顶部退出的代码：
- en: '[PRE247]'
  id: totrans-2155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Note that the *y* delta is using the percentage relative to the parent view.
    The entering animation starts at -100 percent of the size of the parent from the
    top (one whole screen up). For the exiting animation, we only have to reverse
    the deltas.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*y*增量是相对于父视图的百分比。进入动画从顶部开始，位于父视图大小的-100%（整个屏幕向上）。对于退出动画，我们只需反转增量。
- en: 'Finally, there is another important decision to make about these animations,
    that is which interpolators to use. The most common configurations are:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于这些动画，还有一个重要的决定要做，那就是选择使用哪种插值器。最常用的配置有：
- en: 'Linear on both: simple, but a bit boring'
  id: totrans-2158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个都是线性：简单，但有点无聊
- en: 'Decelerate to show / accelerate to hide: this feels smoother than the linear,
    and gives a more professional look'
  id: totrans-2159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减速显示/加速隐藏：这比线性更平滑，给人一种更专业的效果
- en: 'Overshoot to show / anticipate to hide: since the view goes over the end position
    and then goes back, it makes the animation feel more playful'
  id: totrans-2160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出显示/隐藏以预测：由于视图会超出结束位置然后返回，这使得动画感觉更加有趣
- en: You can use any combination of the animations and interpolators or create your
    own look and feel. Modify the code and try it until you are happy with the result.
    Just by changing the interpolator the animation feels different.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用动画和插值器的任何组合，或创建自己的外观和感觉。修改代码并尝试，直到您对结果满意。只需更改插值器，动画感觉就不同了。
- en: Delaying the action in the dialogs to onDismissed
  id: totrans-2162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在对话框中延迟动作到`onDismissed`
- en: Because the animations take some time, the actions that were performed on the
    dialog when the user clicked on a button should be delayed until the animation
    is finished.
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动画需要一些时间，当用户点击按钮时在对话框上执行的动作应延迟到动画完成。
- en: To do this, we are going to store the id of the view that was clicked, and then
    check on it in the `onDismissed` method to trigger the appropriate action. This
    is a change we have to make to each dialog.
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将存储被点击视图的ID，然后在`onDismissed`方法中检查它以触发相应的操作。这是我们必须对每个对话框进行的更改。
- en: 'Let''s start by looking at the changes we have to make to `GameOverDialog`:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们需要对`GameOverDialog`进行的更改：
- en: '[PRE248]'
  id: totrans-2166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Simple, right? The code is almost the same as before but moved from `onClick`
    to `onDismiss`, so it is executed later.
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？代码几乎和以前一样，但已从`onClick`移动到`onDismiss`，因此它会在稍后执行。
- en: 'Next, `PauseDialog` is similar:'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`PauseDialog`类似：
- en: '[PRE249]'
  id: totrans-2169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: This case is a bit more complex, since there are buttons that still initiate
    some action (music and sound), but do not dismiss the dialog. We also add a default
    selected action (resume in this case) to be used when the user dismisses the dialog.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例稍微复杂一些，因为有一些按钮仍然会启动某些动作（音乐和声音），但不会关闭对话框。我们还添加了一个默认选中动作（在这种情况下是恢复），以便在用户关闭对话框时使用。
- en: Note that both actions inside `onClick` call the `super.dismiss()` method explicitly
    to avoid being overwritten by the default action.
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`onClick`中的两个动作都明确调用`super.dismiss()`方法，以避免被默认动作覆盖。
- en: 'Finally, for `QuitDialog`, we have the same idea again:'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`QuitDialog`，我们又有同样的想法：
- en: '[PRE250]'
  id: totrans-2173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: This is it. The dialogs are animated and the actions are performed after the
    dialog is dismissed.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。对话框已经动画化，动作在对话框关闭后执行。
- en: Pulsating buttons
  id: totrans-2175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳动的按钮
- en: Let's add one more animation using animated views. We will animate the button
    to start the game, making it grow and shrink in both axes in a loop, simulating
    the button pulsating. The idea is that it is a button that "wants to be clicked".
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个使用动画视图的动画。我们将动画化按钮以启动游戏，使其在两个轴向上循环增长和缩小，模拟按钮的跳动。想法是它是一个“想要被点击”的按钮。
- en: For this, we are going to use a composite animation. The animation will scale
    the button on the X and Y axis, but the animations will be different. The X will
    grow for the complete duration of the animation, while the Y will only do it in
    the second part. Then we make the animations repeat indefinitely in reverse mode.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用组合动画。动画将在X和Y轴上缩放按钮，但动画将不同。X将在动画的整个持续时间内增长，而Y只在第二部分增长。然后我们使动画以反向模式无限重复。
- en: 'The code for the animation in XML is like this:'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 中动画的代码如下：
- en: '[PRE251]'
  id: totrans-2179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: As we mentioned in a previous section, the `repeatCount` attribute does not
    work for the `<set>` tag. We could do it in code, but it is simpler to just add
    it to each of the animations since we only have two. This is why `repeatCount`
    and `repeatMode` are set on both `<scale>` tags.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`repeatCount` 属性对 `<set>` 标签不起作用。我们可以在代码中实现它，但只需将其添加到每个动画中会更简单，因为我们只有两个。这就是为什么
    `repeatCount` 和 `repeatMode` 都设置在 `<scale>` 标签上。
- en: Note that the `infinite` keyword is accepted as `repeatCount`. We do not need
    to use awkward constants for it.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`infinite` 关键字被接受为 `repeatCount`。我们不需要为此使用尴尬的常量。
- en: The way repeat interacts with `startOffset` is sometimes counter-intuitive.
    The value of `startOffset` will be applied to each iteration. In this particular
    case, this behavior comes in handy because we want the animation on the *y* axis
    to start later than the one on *x* during every iteration. But if we were to make
    a repeating animation that has a delayed start, it would not work as expected.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 重复与 `startOffset` 的交互有时是反直觉的。`startOffset` 的值将应用于每个迭代。在这个特定的情况下，这种行为很有用，因为我们希望动画在
    *y* 轴上的开始时间晚于在 *x* 轴上的开始时间。但如果我们想要创建一个具有延迟开始的重复动画，它可能不会按预期工作。
- en: Note
  id: totrans-2183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `startOffset` is part of the animation and it will be included in each repetition.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: '`startOffset` 是动画的一部分，它将被包含在每次重复中。'
- en: For a repeating animation with a delayed start, the best solution is to use
    a different method to add an initial delay. Android provides us with `Timer`/`TimerTask`
    and the possibility to post a `Runnable` with a delay for this.
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有延迟开始的重复动画，最佳解决方案是使用不同的方法来添加初始延迟。Android 提供了 `Timer`/`TimerTask` 以及延迟发布 `Runnable`
    的可能性，用于此目的。
- en: 'Setting the animation to the view is very simple, just a couple lines of code
    in `MainMenuFragment`; one to load the `Animation` and one to start it:'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 将动画设置到视图中非常简单，只需在 `MainMenuFragment` 中写几行代码；一行用于加载 `Animation`，另一行用于启动它：
- en: '[PRE252]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Feel free to play with the parameters, even make the two components have different
    times, so they offset each other. The values we have in the example are chosen
    to make it very noticeable; you can make it more subtle using a smaller final
    scale and/or a longer period, which I recommend.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 随意调整参数，甚至让两个组件有不同的时间，这样它们可以相互抵消。示例中我们选择的值是为了让它非常明显；你可以通过使用更小的最终比例和/或更长的周期来让它更微妙，我推荐这样做。
- en: Property animation
  id: totrans-2189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性动画
- en: The second way to manage animations in Android was introduced in Android 3.0
    (API level 11). It is designed in a very generic way, so it can handle animations
    on any property of any object. The system is extensible and lets you animate properties
    of custom types as well.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 管理安卓中动画的第二种方式是在 Android 3.0（API 级别 11）中引入的。它设计得非常通用，因此可以处理任何对象的任何属性上的动画。该系统是可扩展的，并允许你动画化自定义类型的属性。
- en: There are many ways to use property animations. The simplest one is to use `ValueAnimator`.
    This is as easy as defining an animation that goes from one value to another,
    has a duration, and optionally an interpolator. Then you add a listener that is
    invoked each time there is a new value, and finally you start the animation.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性动画有很多种方法。最简单的一种是使用 `ValueAnimator`。这就像定义一个从某个值到另一个值的动画，有一个持续时间，可选的插值器。然后你添加一个监听器，每次有新值时都会被调用，最后你开始动画。
- en: 'This code will create a `ValueAnimator` that animates a float from 0 to 42
    along 1,000 milliseconds:'
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将创建一个 `ValueAnimator`，在 1,000 毫秒内将浮点数从 0 动画到 42：
- en: '[PRE253]'
  id: totrans-2193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Value animators do not modify values per se, but you have control over what
    you want to do with the animated value inside the `onAnimationUpdate` method of
    the listener.
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 值动画本身并不修改值，但你可以在监听器的 `onAnimationUpdate` 方法中对动画值进行控制。
- en: 'We are not going to use any `ValueAnimator` in YASS, but they can be really
    useful for other types of games. We can use them whenever we want a smooth transition
    of a variable from one value to the next. Some cases where value animators are
    interesting for games are:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 YASS 中不会使用任何 `ValueAnimator`，但它们对于其他类型的游戏非常有用。我们可以在需要变量从一值平滑过渡到下一值时使用它们。一些情况下，值动画对游戏很有趣，例如：
- en: Adding bonus scores after finishing a level
  id: totrans-2196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成一个等级后添加加分
- en: Adding XP points after finishing a quest / defeating an opponent
  id: totrans-2197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成一个任务/击败对手后添加经验值
- en: Decreasing HP points after a hit / increasing after a recovery potion
  id: totrans-2198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在受到打击后减少 HP 点数/在恢复药水后增加
- en: In general, value animators can be used any time we have a value that we want
    to animate smoothly. You can even use a custom progress bar to display the value
    and just update it on the callback of the `ValueAnimator`.
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，值动画器可以在我们想要平滑动画化任何值的时候使用。你甚至可以使用自定义进度条来显示值，并在`ValueAnimator`的回调中更新它。
- en: You can use a `PropertyAnimator` instead of a `ValueAnimator` if you want Android
    to modify the value of the property in the object directly. For this particular
    case of views, we have a special class called `ViewPropertyAnimator` that is easier
    to use and read than `PropertyAnimator` and is designed specially to animate views.
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让Android直接修改对象中属性的值，可以使用`PropertyAnimator`而不是`ValueAnimator`。对于视图的特定情况，我们有一个名为`ViewPropertyAnimator`的特殊类，它比`PropertyAnimator`更容易使用和阅读，并且专门设计用于动画化视图。
- en: ViewPropertyAnimator
  id: totrans-2201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewPropertyAnimator
- en: This animation technique provides a simple way to animate several properties
    of a view in parallel using a single underlying `Animator` object. It also modifies
    the actual values of the view's properties.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动画技术提供了一种简单的方法，通过单个底层的`Animator`对象并行动画化视图的多个属性。它还会修改视图属性的真正值。
- en: One drawback of using `ViewPropertyAnimator` is that it is more limited. We
    can only animate the basic attributes of the view (position, scale, alpha, and
    rotation), while with `PropertyAnimation` we can animate virtually anything.
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ViewPropertyAnimator`的一个缺点是它更有限。我们只能动画化视图的基本属性（位置、缩放、透明度和旋转），而使用`PropertyAnimation`我们可以动画化几乎任何东西。
- en: It is worth mentioning in advance that this animation technique only requires
    final values for an animation. It is meant to start the animation from the current
    values of the view. This means that sometimes, you may need to initialize the
    view to an initial position.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 预先提一下，这种动画技术只需要动画的最终值。它的目的是从视图的当前值开始动画。这意味着有时你可能需要将视图初始化到初始位置。
- en: Because this type of animation works as a modification of the values of the
    view, animated views stay in their final state once the animation is completed.
    This makes them very useful for puzzle-like or board games.
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种动画是通过修改视图的值来工作的，一旦动画完成，动画视图将保持在它们最终状态。这使得它们对于类似拼图或棋盘游戏非常有用。
- en: Note
  id: totrans-2206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Views animated with `ViewPropertyAnimator` stay at the end position after the
    animation has ended.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ViewPropertyAnimator`动画化的视图在动画结束后将保持在最终位置。
- en: '`ViewPropertyAnimator` uses two concepts to obtain the coordinates where the
    view is drawn: position and translation. You can animate the position or you can
    animate the translation. If you are going to use only one of them, it does not
    make much of a difference. Just remember that `translateX` will have the origin
    (also known as [0,0]) at the current position of the view and that a view will
    be drawn at the vectorial sum of its position and translation.'
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPropertyAnimator`使用两个概念来获取视图绘制的坐标：位置和转换。你可以动画化位置或转换。如果你只使用其中一个，那么差别不大。只需记住，`translateX`将以视图的当前位置为原点（也称为[0,0]），视图将在其位置和转换的矢量和中绘制。'
- en: Moving a spaceship around
  id: totrans-2209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动飞船
- en: To see the power of `ViewPropertyAnimator`, we are going to add another animation
    to the main menu. We are going to take the spaceship we used to display the frame-by-frame
    animation and then make it move around the screen randomly.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到`ViewPropertyAnimator`的力量，我们将在主菜单中添加另一个动画。我们将使用之前用来显示逐帧动画的宇宙飞船，然后让它随机地在屏幕上移动。
- en: I believe this animation is too much and makes the main menu feel too crowded,
    so I recommend removing it in the final game, but it is nevertheless a great example
    of how the framework works.
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这种动画太多了，使得主菜单显得过于拥挤，所以我建议在最终游戏中移除它，但无论如何，它都是一个很好的框架工作示例。
- en: Because each animation starts from the previous position of the view, the resulting
    effect is something you cannot achieve with the old framework.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个动画都是从视图的先前位置开始的，所以最终效果是老框架无法实现的。
- en: 'Let''s look at the code:'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE254]'
  id: totrans-2214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: We are invoking `animateShip` once the layout is completed and then we will
    do it again each time the animation is completed.
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 当布局完成时，我们调用一次`animateShip`，然后每次动画完成后都会再次调用它。
- en: To animate the ship, we get the view we want to animate and then select a random
    position on the screen using `Random` and the dimensions of the root view of the
    fragment.
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画化飞船，我们获取要动画化的视图，然后使用`Random`和片段根视图的尺寸在屏幕上选择一个随机位置。
- en: We call `animate` on the view. This returns an object of `ViewPropertyAnimator`
    type. We can configure the animation using different methods on this object and
    each of them will return the object again, so they can be chained in a very easy
    to read code.
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在视图中调用`animate`。这返回一个`ViewPropertyAnimator`类型的对象。我们可以使用这个对象上的不同方法来配置动画，并且每个方法都会返回这个对象，因此它们可以非常容易地链式调用，易于阅读的代码。
- en: We are configuring the animation by setting the target *x* and *y* positions
    (we are not touching the translation at all), selecting the duration, and setting
    an interpolator of `AccelerateDecelerateInterpolator` type. We are also setting
    a listener, so we are notified when the animation ends and we can call `animateShip`
    to create another one. Note that `AnimationListener` is an interface and we must
    implement all its methods even if we don't use them.
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置目标*x*和*y*位置（我们根本不触碰平移），选择持续时间，并设置`AccelerateDecelerateInterpolator`类型的插值器来配置动画。我们还设置了一个监听器，这样我们就可以在动画结束时得到通知，并可以调用`animateShip`来创建另一个动画。注意，`AnimationListener`是一个接口，即使我们不使用它，我们也必须实现它的所有方法。
- en: Finally, we could call `start` to make the animation start immediately, but
    it is not necessary.
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用`start`来立即开始动画，但这不是必需的。
- en: We are always using the same animation duration, so sometimes the ship will
    move much faster than others. We could make it have a constant speed by using
    the distance between the origin and the destination points to calculate the duration
    of the animation.
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是使用相同的动画持续时间，所以有时船只的移动速度会比其他船只快得多。我们可以通过使用起点和终点之间的距离来计算动画的持续时间，使其保持恒定速度。
- en: It is important to check at which position in the layout the `ImageView` was
    added, since the z-index is provided by the order. I recommend you place the ship
    straight after the background image, so it goes behind the titles and buttons.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要检查`ImageView`在布局中的位置，因为z-index是由顺序提供的。我建议你将船只直接放置在背景图像之后，这样它就会在标题和按钮后面。
- en: Animating the main menu
  id: totrans-2222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画主菜单
- en: 'To complete the chapter, we are going to animate the game title and subtitle.
    To give a comparison of the different possibilities Android offers to make animations,
    we will create each of them in three different ways: view animation in XML, `ViewPropertyAnimation`
    in code, and object animator in XML.'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，我们将对游戏标题和副标题进行动画处理。为了比较Android提供的不同动画可能性，我们将以三种不同的方式创建每个动画：XML中的视图动画、代码中的`ViewPropertyAnimation`以及XML中的对象动画器。
- en: First, we will animate the main title to make it enter from the left of the
    screen to its normal position at the center. We will use a bounce interpolator
    to make it look fun.
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对主标题进行动画处理，使其从屏幕左侧进入并到达其正常位置的中心。我们将使用弹跳插值器使其看起来更有趣。
- en: 'As good practice, we will externalize the start offset and the duration of
    the animation as integers using a file named `integers.xml` under the `res/values`
    folder:'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，我们将动画的开始偏移和持续时间作为整数外部化，使用名为`integers.xml`的文件，位于`res/values`文件夹下：
- en: '[PRE255]'
  id: totrans-2226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: The animation will not start straight away to give the player some time to actually
    notice the screen. We have a long duration, because the bounce interpolator does
    not look good otherwise.
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 动画不会立即开始，以给玩家一些时间真正注意到屏幕。我们有一个很长的持续时间，因为否则弹跳插值器看起来不好。
- en: 'The first version using view animation in XML is defined like this:'
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XML中的视图动画的第一版定义如下：
- en: '[PRE256]'
  id: totrans-2229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: We use percentage related to the parent view as the original delta to put the
    view completely out of the screen. The -100%p means 100 percent of the parent
    width to the left.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与父视图相关的百分比作为原始delta值，将视图完全移出屏幕。-100%p意味着父视图宽度的100%在左侧。
- en: 'The code to load the animation and start it is to be placed inside `onLayoutCompleted`
    and it is very simple:'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 加载动画并开始它的代码应该放在`onLayoutCompleted`内部，并且非常简单：
- en: '[PRE257]'
  id: totrans-2232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Note that the animation is considered to be started as soon as we call `startAnimation`.
    This means that the translation is also animated during the start offset and is
    set to the initial value of the animation.
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦我们调用`startAnimation`，动画就被认为是开始了。这意味着在开始偏移期间，平移也是动画化的，并设置为动画的初始值。
- en: Note
  id: totrans-2234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The start offset is considered a part of the animation for view animators and
    the value is set to the initial one while the animation is waiting to start.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图动画器来说，开始偏移被认为是动画的一部分，其值在动画等待开始时设置为初始值。
- en: 'Let''s compare this definition with the one for `ViewPropertyAnimator` in code:'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较这个定义与代码中`ViewPropertyAnimator`的定义：
- en: '[PRE258]'
  id: totrans-2237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Because the duration and offset are defined as integers, we need to obtain them
    before running the animation.
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持续时间和偏移量定义为整数，我们需要在运行动画之前获取它们。
- en: Since the view is initially placed at the location we want it to finish, we
    are going to animate the translation and keep the position as it is.
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图最初放置的位置是我们希望它结束的位置，我们将对平移进行动画处理，并保持位置不变。
- en: Note that since `ViewPropertyAnimator` only receives the final value as a parameter,
    we need to set it to a default initial position outside the screen. To do this,
    we use the `setTranslationX` method of the view. By doing this, the final value
    of the translation is 0.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`ViewPropertyAnimator`只接收最终值作为参数，我们需要将其设置为屏幕外的默认初始位置。为此，我们使用视图的`setTranslationX`方法。通过这样做，平移的最终值为0。
- en: Finally, we set the interpolator and call `start`. The result is the same as
    with the previous method but, as you have seen, there are a few significant differences
    in the procedure.
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置插值器并调用`start`。结果是与之前的方法相同，但如您所见，在程序中有一些显著的不同。
- en: 'The third approach is to define this same animation as an object animator in
    XML and then load and use it in code. The XML definition is as follows:'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是在XML中将相同的动画定义为对象动画器，然后加载并在代码中使用它。XML定义如下：
- en: '[PRE259]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: The `<objectAnimator>` tag is generic in itself and uses `propertyName` as the
    name of the property to modify using reflection.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: '`<objectAnimator>`标签本身是通用的，并使用`propertyName`作为通过反射修改的属性的名称。'
- en: 'Once the animation is defined, we have to load and start it:'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦动画被定义，我们必须加载并启动它：
- en: '[PRE260]'
  id: totrans-2246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: As happened in the previous example, we need to make an initialization of the
    translation. Although we could set a `valueFrom` in XML, we do not know the size
    of the screen when we define XML and we cannot use the values referenced to the
    parent view, so we have to initialize it in code.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，我们需要对平移进行初始化。虽然我们可以在XML中设置`valueFrom`，但在定义XML时我们不知道屏幕的大小，我们也不能使用引用父视图的值，因此我们必须在代码中初始化它。
- en: All in all, the three versions perform the same animation conceptually, but
    the way they are defined is slightly different.
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这三种版本在概念上执行相同的动画，但它们的定义方式略有不同。
- en: Let's see another example. For the subtitle, we are going to animate the alpha
    to make it appear after the animation of the title is finished. To make this animation
    run after the previous one, we can use start delay or we can set a listener to
    the previous animation and start it when this animation finishes.
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。对于字幕，我们将对alpha进行动画处理，使其在标题动画完成后出现。为了使这个动画在之前的动画之后运行，我们可以使用启动延迟，或者我们可以设置一个监听器到之前的动画，并在这个动画完成后启动它。
- en: 'Using a listener is more precise, but adding delay is way simpler so we will
    go for this. As we did for the title animation, we will define some integers for
    the duration and the start offset, which in this case is the sum of the duration
    and the start offset of the title animation:'
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用监听器更精确，但添加延迟要简单得多，所以我们将选择这种方法。就像我们为标题动画所做的那样，我们将定义一些用于持续时间和启动偏移的整数，在这种情况下，它是标题动画的持续时间和启动偏移量的总和：
- en: '[PRE261]'
  id: totrans-2251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'The XML for doing it using view animation is like this:'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图动画执行此操作的XML如下所示：
- en: '[PRE262]'
  id: totrans-2253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'The code to run it is also very similar to what we just saw for the title:'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它的代码也与之前看到的标题动画的代码非常相似：
- en: '[PRE263]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Again, the fact that `startOffset` is considered a part of the animation is
    very convenient, because it allows us to set the alpha to 0 for the first 2,000
    milliseconds without touching the view.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于`startOffset`被视为动画的一部分，这非常方便，因为它允许我们在不接触视图的情况下将alpha设置为0，持续前2,000毫秒。
- en: 'Let''s compare it with `ViewPropertyAnimation`:'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与`ViewPropertyAnimation`进行比较：
- en: '[PRE264]'
  id: totrans-2258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Also, very similarly to the previous one, we need to initialize the value of
    alpha in the view. We also need to load the integer values to use them in the
    configuration.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与上一个例子非常相似，我们需要在视图中初始化alpha的值。我们还需要加载整数值以在配置中使用它们。
- en: 'Lastly, the same animation is defined as a `PropertyAnimation` in XML:'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，相同的动画在XML中定义为`PropertyAnimation`：
- en: '[PRE265]'
  id: totrans-2261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'Then, it is loaded and assigned to the subtitle view:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它被加载并分配给字幕视图：
- en: '[PRE266]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: In this case, we also need to preset the alpha to 0, because the start offset
    is not considered a part of the animation for `PropertyAnimator`. If we do not
    set it, it will stay set to 1 until the animation starts running.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还需要预先设置alpha值为0，因为对于`PropertyAnimator`来说，起始偏移量不被视为动画的一部分。如果我们不设置它，它将保持为1，直到动画开始运行。
- en: In general, there is no silver bullet and each type of animation is better for
    different cases. While using simple visual effects to make a game look nicer,
    view animators are usually enough and also easier to set up. If the view is going
    to be interactive and you use animation to translate the elements of the game,
    then `PropertyAnimation` (or any of its variants) is the only way to go.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，没有一劳永逸的解决方案，每种类型的动画更适合不同的场景。当使用简单的视觉效果使游戏看起来更美观时，视图动画器通常就足够了，而且也更容易设置。如果视图将要交互，并且你使用动画来转换游戏元素，那么`PropertyAnimation`（或其任何变体）是唯一的选择。
- en: Summary
  id: totrans-2266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned how to do frame-by-frame animations and how to animate views
    using the two different frameworks that Android provides, view animation and `PropertyAnimation`.
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何进行逐帧动画，以及如何使用Android提供的两种不同的框架来动画化视图：视图动画和`PropertyAnimation`。
- en: We have studied the differences between and limitations of each of them and
    learned when to use one or the other.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了它们之间的差异和局限性，并学会了何时使用哪一个。
- en: We have animated the dialogs and also the main menu. For the titles, we have
    seen how we could achieve the same result with different approaches.
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对对话框和主菜单进行了动画处理。对于标题，我们看到了如何通过不同的方法达到相同的效果。
- en: All in all, the game looks much smoother since a lot of the content is animated
    now.
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，游戏看起来更加流畅，因为现在很多内容都进行了动画处理。
- en: We could say that the game is finished, but we will add some more features to
    make it more interesting. Google provides us with an API to manage achievements
    and leaderboards. Both features are a part of Google Play services and this is
    what we will do next!
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说游戏已经完成，但我们还会添加一些新功能来使其更有趣。谷歌为我们提供了一个API来管理成就和排行榜。这两个功能都是Google Play服务的一部分，这就是我们接下来要做的！
- en: Chapter 9. Integrating Google Play Services
  id: totrans-2272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：集成Google Play Services
- en: Google provides Google Play Services as a way to use special features in apps.
    Being the game services subset the one that interests us the most. Note that Google
    Play Services are updated as an app that is independent from the operating system.
    This allows us to assume that most of the players will have the latest version
    of Google Play Services installed.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌提供Google Play Services作为在应用中使用特殊功能的方式。作为游戏服务子集，这是最吸引我们的一部分。请注意，Google Play
    Services作为独立于操作系统的应用程序进行更新。这让我们可以假设大多数玩家都将安装最新的Google Play Services版本。
- en: More and more features are being moved from the Android SDK to the Play Services
    because of this.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，越来越多的功能正从Android SDK迁移到Play Services。
- en: Play Services offer much more than just services for games, but there is a whole
    section dedicated exclusively to games, **Google Play Game Services** (**GPGS**).
    These features include achievements, leaderboards, quests, save games, gifts,
    and even multiplayer support.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: Play Services不仅提供游戏服务，还有一个专门针对游戏的独立部分，即**Google Play Game Services**（**GPGS**）。这些功能包括成就、排行榜、任务、保存游戏、礼物，甚至多人游戏支持。
- en: GPGS also comes with a standalone app called "Play Games" that shows the user
    the games he or she has been playing, the latest achievements, and the games his
    or her friends play. It is a very interesting way to get exposure for your game.
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: GPGS还附带一个名为“Play Games”的独立应用程序，它向用户展示他们正在玩的游戏、最新的成就以及他们的朋友正在玩的游戏。这是一种非常有趣的方式来推广你的游戏。
- en: Even as a standalone feature, achievements and leaderboards are two concepts
    that most games use nowadays, so why make your own custom ones when you can rely
    on the ones made by Google?
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 即使作为一个独立的功能，成就和排行榜是现在大多数游戏都会使用的两个概念，所以为什么还要自己制作定制的呢，当你可以依赖谷歌提供的那些呢？
- en: 'GPGS can be used on many platforms: Android, iOS and web among others. It is
    more used on Android, since it is included as a part of Google apps.'
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: GPGS可以在许多平台上使用：Android、iOS和网页等。它在Android上使用得更多，因为它被包含在谷歌应用的一部分中。
- en: There is extensive step-by-step documentation online, but the details are scattered
    over different places. We will put them together here and link you to the official
    documentation for more detailed information.
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有大量的分步指南文档，但这些细节散布在不同的地方。我们将它们汇总在这里，并为您提供官方文档的链接以获取更详细的信息。
- en: For this chapter, you are supposed to have a developer account and have access
    to the Google Play Developer Console. It is also advisable for you to know the
    process of signing and releasing an app. If you are not familiar with it, there
    is very detailed official documentation at [http://developer.android.com/distribute/googleplay/start.html](http://developer.android.com/distribute/googleplay/start.html).
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你应拥有一个开发者账户并能够访问Google Play开发者控制台。了解签名和发布应用的流程也是明智的。如果你不熟悉，官方文档在[http://developer.android.com/distribute/googleplay/start.html](http://developer.android.com/distribute/googleplay/start.html)有非常详细的说明。
- en: 'There are two sides of GPGS: the developer console and the code. We will alternate
    from one to the other while talking about the different features.'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: GPGS有两个方面：开发者控制台和代码。在讨论不同功能时，我们将交替使用这两个方面。
- en: Setting up the developer console
  id: totrans-2282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发者控制台
- en: Now that we are approaching the release state, we have to start working with
    the developer console.
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正接近发布状态，我们必须开始使用开发者控制台。
- en: 'The first thing we need to do is to get into the **Game services** section
    of the console to create and configure a new game. In the left menu, we have an
    option labeled **Game services**. This is where you have to click. Once in the
    **Game services** section, click on **Add new game**:'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是进入控制台的**游戏服务**部分来创建和配置一个新的游戏。在左侧菜单中，有一个标记为**游戏服务**的选项。这就是你需要点击的地方。一旦进入**游戏服务**部分，点击**添加新游戏**：
- en: '![Setting up the developer console](img/B04757_09_01.jpg)'
  id: totrans-2285
  prefs: []
  type: TYPE_IMG
  zh: '![设置开发者控制台](img/B04757_09_01.jpg)'
- en: This bring us to the set up dialog. If you are using other Google services like
    **Google Maps** or **Google Cloud Messaging** (**GCM**) in your game, you should
    select the second option and move forward. Otherwise, you can just fill in the
    fields for **I don't use any Google APIs on my game yet** and continue. If you
    don't know whether you are already using them, you probably aren't.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到设置对话框。如果你在游戏中使用其他Google服务，如**Google Maps**或**Google Cloud Messaging**（**GCM**），你应该选择第二个选项并继续。否则，你只需填写**我在游戏中还没有使用任何Google
    API**的字段并继续。如果你不知道你是否已经使用它们，你很可能没有。
- en: '![Setting up the developer console](img/B04757_09_02.jpg)'
  id: totrans-2287
  prefs: []
  type: TYPE_IMG
  zh: '![设置开发者控制台](img/B04757_09_02.jpg)'
- en: Now, it is time to link a game to it. I recommend you publish your game beforehand
    as an alpha release. This will let you select it from the list when you start
    typing the package name.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将一个游戏链接到它了。我建议你先发布你的游戏作为alpha版本。这将让你在开始输入包名时从列表中选择它。
- en: Note
  id: totrans-2289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Publishing the game to the alpha channel before adding it to Game services makes
    it much easier to configure.
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其添加到游戏服务之前发布游戏到alpha通道会使配置变得容易得多。
- en: If you are not familiar with signing and releasing your app, check out the official
    documentation at [http://developer.android.com/tools/publishing/app-signing.html](http://developer.android.com/tools/publishing/app-signing.html).
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对你应用的签名和发布不熟悉，请查看官方文档[http://developer.android.com/tools/publishing/app-signing.html](http://developer.android.com/tools/publishing/app-signing.html)。
- en: Finally, there are only two steps that we have to take when we link the first
    app. We need to authorize it and provide branding information. The authorization
    will generate an OAuth key—that we don't need to use since it is required for
    other platforms—and also a game ID. This ID is unique to all the linked apps and
    we will need it to log in. But there is no need to write it down now, it can be
    found easily in the console at anytime.
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们链接第一个应用时，我们只需要进行两个步骤。我们需要授权它并提供品牌信息。授权将生成一个OAuth密钥——我们不需要使用它，因为它需要用于其他平台——以及一个游戏ID。这个ID对所有链接的应用都是唯一的，我们将需要它来登录。但现在没有必要写下它，它可以在控制台中随时轻松找到。
- en: Note
  id: totrans-2293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Authorizing the app will generate the game ID, which is unique to all linked
    apps.
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 授权应用将生成游戏ID，这个ID对所有链接的应用都是唯一的。
- en: 'Note that the app we have added is configured with the release key. If you
    continue and try the login integration, you will get an error telling you that
    the app was signed with the wrong certificate:'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加的应用已配置为使用发布密钥。如果你继续并尝试登录集成，你会得到一个错误，告诉你应用是用错误的证书签名的：
- en: '![Setting up the developer console](img/B04757_09_03.jpg)'
  id: totrans-2296
  prefs: []
  type: TYPE_IMG
  zh: '![设置开发者控制台](img/B04757_09_03.jpg)'
- en: 'You have two ways to work with this limitation:'
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种方法来处理这个限制：
- en: Always make a release build to test GPGS integration
  id: totrans-2298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是创建发布构建以测试GPGS集成
- en: Add your debug-signed game as a linked app
  id: totrans-2299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的调试签名游戏作为链接应用添加
- en: 'I recommend that you add the debug signed app as a linked app. To do this,
    we just need to link another app and configure it with the SHA1 fingerprint of
    the debug key. To obtain it, we have to open a terminal and run the keytool utility:'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你将调试签名应用作为链接应用添加。为此，我们只需要链接另一个应用，并使用调试密钥的SHA1指纹进行配置。要获取它，我们必须打开终端并运行keytool实用程序：
- en: '[PRE267]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Note that in Windows, the debug `keystore` can be found at `C:\Users\<USERNAME>\.android\debug.keystore`.
    On Mac and Linux, the debug `keystore` is typically located at `~/.android/debug.keystore`.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Windows中，调试`keystore`位于`C:\Users\<USERNAME>\.android\debug.keystore`。在Mac和Linux上，调试`keystore`通常位于`~/.android/debug.keystore`。
- en: '![Setting up the developer console](img/B04757_09_04.jpg)'
  id: totrans-2303
  prefs: []
  type: TYPE_IMG
  zh: '![设置开发者控制台](img/B04757_09_04.jpg)'
- en: Dialog to link the debug application on the Game Services console
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏服务控制台中链接调试应用的对话框
- en: Now, we have the game configured. We could continue creating achievements and
    leaderboards in the console, but we will put it aside and make sure that we can
    sign in and connect with GPGS.
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经配置了游戏。我们可以在控制台中继续创建成就和排行榜，但我们将把它放在一边，确保我们能够登录并连接到GPGS。
- en: The only users who can sign in to GPGS while a game is not published are the
    testers. You can make the alpha and/or beta testers of a linked app become testers
    of the game services, and you can also add e-mail addresses by hand for this.
    You can modify this in the Testing tab.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏未发布时，只有测试者可以登录到GPGS。你可以使链接应用的alpha和/或beta测试者成为游戏服务的测试者，你也可以手动添加电子邮件地址。你可以在测试选项卡中修改这些。
- en: Note
  id: totrans-2307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only test accounts can access a game that is not published.
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 只有测试账户可以访问未发布的游戏。
- en: The e-mail of the owner of the developer console is prefilled as a tester. Just
    in case you have problems logging in, double-check the list of testers.
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者控制台所有者的电子邮件已预先填充为测试者。以防你登录时出现问题，请再次检查测试者列表。
- en: A game service that is not published will not appear in the feed of the Play
    Services app, but it will be possible to test and modify it. This is why it is
    a good idea to keep it in draft mode until the game itself is ready and publish
    both the game and the game services at the same time.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 未发布的游戏服务不会出现在Play服务应用的源中，但可以进行测试和修改。这就是为什么在游戏本身准备好并同时发布游戏和游戏服务之前，将其保持在草案模式是一个好主意。
- en: Setting up the code
  id: totrans-2311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: The first thing we need to do is to add the Google Play Services library to
    our project. This should already have been done by the wizard when we created
    the project, but I recommend you to double-check it now.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将Google Play服务库添加到我们的项目中。在创建项目时，向导应该已经完成了这项工作，但我建议你现在再次检查。
- en: The library needs to be added to the `build.gradle` file of the main module.
    Note that Android Studio projects contain a top-level `build.gradle` and a module-level
    `build.gradle` for each module. We will modify the one that is under the `mobile`
    module.
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将库添加到主模块的`build.gradle`文件中。请注意，Android Studio项目包含一个顶级`build.gradle`和每个模块的模块级`build.gradle`。我们将修改位于`mobile`模块下的那个。
- en: 'Make sure that the play services'' library is listed under dependencies:'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在依赖项下列出了play服务库：
- en: '[PRE268]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: At the point of writing, the latest version is 7.3.0\. The basic features have
    not changed much and they are unlikely to change. You could force Gradle to use
    a specific version of the library, but in general I recommend you use the latest
    version.
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新版本是7.3.0。基本功能没有太大变化，并且不太可能改变。你可以强制Gradle使用库的特定版本，但通常我建议你使用最新版本。
- en: Once you have it, save the changes and click on **Sync Project with Gradle Files**.
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加，保存更改并点击**同步项目与Gradle文件**。
- en: To be able to connect with GPGS, we need to let the game know what the game
    ID is. This is done through the `<meta-data>` tag on `AndroidManifest.xml`. You
    could hardcode the value here, but it is highly recommended that you set it as
    a resource in your Android project.
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够连接到GPGS，我们需要让游戏知道游戏ID。这是通过`AndroidManifest.xml`中的`<meta-data>`标签完成的。你可以在这里硬编码值，但强烈建议你将其设置为Android项目中的资源。
- en: 'We are going to create a new file for this under `res/values`, which we will
    name `play_services.xml`. In this file we will put the game ID, but later we will
    also have the achievements and leaderboard IDs in it. Using a separate file for
    these values is recommended because they are constants that do not need to be
    translated:'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `res/values` 目录下创建一个新文件，命名为 `play_services.xml`。在这个文件中，我们将放置游戏 ID，但稍后我们也将把成就和排行榜
    ID 放进去。使用单独的文件来存储这些值是推荐的，因为它们是常数，不需要翻译：
- en: '[PRE269]'
  id: totrans-2320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Adding this metadata is extremely important. If you forget to update the `AndroidManifest.xml`,
    the app will crash when you try to sign in to Google Play services. Note that
    the integer for the gms version is defined in the library and we do not need to
    add it to our file.
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此元数据非常重要。如果您忘记更新 `AndroidManifest.xml`，当您尝试登录 Google Play 服务时，应用将会崩溃。请注意，gms
    版本的整数在库中定义，我们不需要将其添加到我们的文件中。
- en: Note
  id: totrans-2322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you forget to add the game ID to the strings the app will crash.
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记将游戏 ID 添加到字符串中，应用将会崩溃。
- en: Now, it is time to proceed to sign in. The process is quite tedious and requires
    many checks, so Google has released an open source project named BaseGameUtils,
    which makes it easier. Unfortunately this project is not a part of the play services'
    library and it is not even available as a library. So, we have to get it from
    GitHub (either check it out or download the source as a ZIP file).
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行登录了。这个过程相当繁琐，需要许多检查，因此 Google 发布了一个名为 BaseGameUtils 的开源项目，这使得它更容易实现。不幸的是，这个项目不是
    play services 库的一部分，甚至不能作为一个库提供。因此，我们必须从 GitHub（无论是检出还是下载 ZIP 文件）获取它。
- en: Note
  id: totrans-2325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BaseGameUtils abstracts us from the complexity of handling the connection with
    Play Services.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: BaseGameUtils 将我们从与 Play Services 的连接复杂性中抽象出来。
- en: Even more cumbersome, BaseGameUtils is not available as a standalone download
    and has to be downloaded together with another project. The fact that this significant
    piece of code is not a part of the official library makes it quite tedious to
    set up. Why it has been done like this is something that I do not comprehend myself.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 更为麻烦的是，BaseGameUtils 不能作为独立下载，必须与另一个项目一起下载。这个重要的代码片段不是官方库的一部分，这使得设置起来相当繁琐。为什么它会这样做，我自己都不理解。
- en: The project that contains BaseGameUtils is called `android-basic-samples` and
    it can be downloaded from [https://github.com/playgameservices/android-basic-samples](https://github.com/playgameservices/android-basic-samples).
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 BaseGameUtils 的项目被称为 `android-basic-samples`，可以从 [https://github.com/playgameservices/android-basic-samples](https://github.com/playgameservices/android-basic-samples)
    下载。
- en: Note
  id: totrans-2329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding BaseGameUtils is not as straightforward as we would like it to be.
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 BaseGameUtils 并不像我们希望的那样简单。
- en: Once `android-basic-samples` is downloaded, open your game project in Android
    Studio. Click on **File** > **Import Module** and navigate to the directory where
    you downloaded `android-basic-samples`. Select the `BaseGameUtils` module in the
    `BasicSamples/libraries` directory and click on **OK**.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了 `android-basic-samples`，请在 Android Studio 中打开您的游戏项目。点击 **文件** > **导入模块**，并导航到您下载
    `android-basic-samples` 的目录。在 `BasicSamples/libraries` 目录中选择 `BaseGameUtils` 模块，然后点击
    **确定**。
- en: 'Finally, update the dependencies in the `build.gradle` file for the `mobile`
    module and sync gradle again:'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新 `build.gradle` 文件中 `mobile` 模块的依赖项，并再次同步 gradle：
- en: '[PRE270]'
  id: totrans-2333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: After all these steps to set up the project, we are finally ready to begin the
    sign in.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些设置项目的步骤后，我们终于准备好开始登录了。
- en: We will make our main `Activity` extend from `BaseGamesActivity`, which takes
    care of all the handling of the connections, and sign in with Google Play Services.
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使我们的主要 `Activity` 继承自 `BaseGamesActivity`，该类负责处理所有连接的交互，并使用 Google Play 服务进行登录。
- en: 'One more detail: until now, we were using `Activity` and not `FragmentActivity`
    as the base class for `YassActivity` (`BaseGameActivity` extends from `FragmentActivity`)
    and this change will mess with the behavior of our dialogs while calling `navigateBack`.
    We can change the base class of `BaseGameActivity` or modify `navigateBack` to
    perform a pop-on fragment navigation hierarchy. I recommend the second approach:'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节：到目前为止，我们使用 `Activity` 而不是 `FragmentActivity` 作为 `YassActivity`（`BaseGameActivity`
    继承自 `FragmentActivity`）的基类，这个更改将会影响我们在调用 `navigateBack` 时的对话框行为。我们可以更改 `BaseGameActivity`
    的基类或修改 `navigateBack` 以在片段导航层次结构上执行弹出。我推荐第二种方法：
- en: '[PRE271]'
  id: totrans-2337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: This util class has been designed to work with single-activity games. It can
    be used in multiple activities, but it is not straightforward. This is another
    good reason to keep the game in a single activity.
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用类被设计用于与单活动游戏一起工作。它可以在多个活动中使用，但这并不简单。这也是将游戏保持在单个活动中的另一个好理由。
- en: Note
  id: totrans-2339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The BaseGameUtils is designed to be used in single-activity games.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: BaseGameUtils 是设计用于单活动游戏的。
- en: The default behavior of `BaseGameActivity` is to try to log in each time the
    `Activity` is started. If the user agrees to sign in, the sign in will happen
    automatically. But if the user rejects doing so, he or she will be asked again
    several times.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseGameActivity` 的默认行为是在每次 `Activity` 启动时尝试登录。如果用户同意登录，登录将自动发生。但如果用户拒绝这样做，他们将被多次询问。'
- en: I personally find this intrusive and annoying, and I recommend you to only prompt
    to log in to Google Play services once (and again, if the user logs out). We can
    always provide a login entry point in the app.
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人觉得这很侵扰且令人烦恼，我建议你只提示登录一次 Google Play 服务（并且再次，如果用户注销）。我们始终可以在应用中提供一个登录入口。
- en: 'This is very easy to change. The default number of attempts is set to 3 and
    it is a part of the code of `GameHelper`:'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易更改。默认尝试次数设置为 3，这是 `GameHelper` 代码的一部分：
- en: '[PRE272]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'So, we just have to configure it for our activity, adding one line of code
    during `onCreate` to change the default behavior with the one we want: just try
    it once:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需在我们的活动中进行配置，在 `onCreate` 期间添加一行代码来更改默认行为，以实现我们想要的行为：只需尝试一次：
- en: '[PRE273]'
  id: totrans-2346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'Finally, there are two methods that we can override to act when the user successfully
    logs in and when there is a problem: `onSignInSucceeded` and `onSignInFailed`.
    We will use them when we update the main menu at the end of the chapter.'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两种方法我们可以覆盖以在用户成功登录和出现问题时执行：`onSignInSucceeded` 和 `onSignInFailed`。我们将在本章末尾更新主菜单时使用它们。
- en: Further use of GPGS is to be made via the `GameHelper` and/or the `GoogleApiClient`,
    which is a part of the `GameHelper`. We can obtain a reference to the `GameHelper`
    using the `getGameHelper` method of `BaseGameActivity`.
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步使用 GPGS 应通过 `GameHelper` 和/或 `GoogleApiClient` 进行，后者是 `GameHelper` 的一部分。我们可以使用
    `BaseGameActivity` 的 `getGameHelper` 方法来获取 `GameHelper` 的引用。
- en: Now that the user can sign into Google Play services we can continue with achievements
    and leaderboards. Let's go back to the developer console.
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以登录 Google Play 服务，我们可以继续处理成就和排行榜。让我们回到开发者控制台。
- en: Achievements
  id: totrans-2350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成就
- en: We will first define a few achievements in the developer console and then see
    how to unlock them in the game. Note that to publish any game with GPGS, you need
    to define at least five achievements. No other feature is mandatory, but achievements
    are.
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将在开发者控制台中定义几个成就，然后看看如何在游戏中解锁它们。请注意，要发布任何带有 GPGS 的游戏，您至少需要定义五个成就。没有其他功能是强制性的，但成就是。
- en: Note
  id: totrans-2352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We need to define at least five achievements to publish a game with Google Play
    Game services.
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少需要定义五个成就才能发布带有 Google Play Game 服务的游戏。
- en: If you want to use GPGS with a game that has no achievements, I recommend you
    to add five dummy secret achievements and let them be.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在没有任何成就的游戏中使用 GPGS，我建议你添加五个虚拟的秘密成就并让它们保持原样。
- en: 'To add an achievement, we just need to navigate to the **Achievements** tab
    on the left and click on **Add achievement**:'
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个成就，我们只需导航到左侧的 **成就** 选项卡并点击 **添加成就**：
- en: '![Achievements](img/B04757_09_05.jpg)'
  id: totrans-2356
  prefs: []
  type: TYPE_IMG
  zh: '![成就](img/B04757_09_05.jpg)'
- en: 'The menu to add a new achievement has a few fields that are mostly self-explanatory.
    They are as follows:'
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新成就的菜单有几个字段，大部分都是自我解释的。它们如下：
- en: '**Name**: the name that will be shown (can be localized to different languages).'
  id: totrans-2358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：将要显示的名称（可以本地化为不同的语言）。'
- en: '**Description**: the description of the achievement to be shown (can also be
    localized to different languages).'
  id: totrans-2359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：将要显示的成就描述（也可以本地化为不同的语言）。'
- en: '**Icon**: the icon of the achievement as a 512x512 px PNG image. This will
    be used to show the achievement in the list and also to generate the locked image
    and the in-game popup when it is unlocked.'
  id: totrans-2360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**：成就的图标，作为 512x512 像素的 PNG 图像。这将被用于在列表中显示成就，并在解锁时生成锁定图像和在游戏中的弹出窗口。'
- en: '**Incremental achievements**: if the achievement requires a set of steps to
    be completed, it is called an incremental achievement and can be shown with a
    progress bar. We will have an incremental achievement to illustrate this.'
  id: totrans-2361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐步成就**：如果成就需要完成一系列步骤，则称为逐步成就，可以用进度条显示。我们将有一个逐步成就来展示这一点。'
- en: '**Initial state**: **Revealed**/**Hidden** depending on whether we want the
    achievement to be shown or not. When an achievement is shown, the name and description
    are visible, players know what they have to do to unlock it. A hidden achievement,
    on the other hand, is a secret and can be a funny surprise when unlocked. We will
    have two secret achievements.'
  id: totrans-2362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始状态**：**显示**/**隐藏**取决于我们是否希望显示成就。当成就显示时，名称和描述是可见的，玩家知道他们需要做什么来解锁它。另一方面，隐藏成就是一个秘密，当解锁时可能会带来有趣的惊喜。我们将有两个秘密成就。'
- en: '**Points**: GPGS allows each game to have 1,000 points to give for unlocking
    achievements. This gets converted to XP in the player profile on Google Play games.
    This can be used to highlight that some achievements are harder than others, and
    therefore grant a bigger reward. You cannot change these once they are published,
    so if you plan to have more achievements in the future, plan ahead with the points.'
  id: totrans-2363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积分**：GPGS允许每个游戏有1000积分用于解锁成就。这些积分将在Google Play游戏玩家的个人资料中转换为经验值。这可以用来突出某些成就比其他成就更难，因此可以获得更大的奖励。一旦发布，就不能更改这些积分，所以如果你计划未来有更多的成就，请提前规划积分。'
- en: '**List order**: The order of the achievements is shown. It is not followed
    all the time, since on the Play Games app the unlocked ones are shown before the
    locked ones. It is still handy to rearrange them.![Achievements](img/B04757_09_06.jpg)'
  id: totrans-2364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表顺序**：成就的顺序是显示的。并不总是遵循这个顺序，因为在Play Games应用中，解锁的成就会在锁定成就之前显示。重新排列它们仍然很有用。![成就](img/B04757_09_06.jpg)'
- en: Dialog to add an achievement on the developer console
  id: totrans-2365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开发者控制台中添加成就的对话框
- en: 'As we already decided, we will have five achievements in our game and they
    will be as follows:'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前决定的，我们的游戏将有五个成就，它们如下：
- en: '**Big Score**: score over 100,000 points in one game. This is to be granted
    while playing.'
  id: totrans-2367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高分**：在一局游戏中获得超过100,000分。这是在游戏中获得的。'
- en: '**Asteroid killer**: destroy 100 asteroids. This will count them across different
    games and is an incremental achievement.'
  id: totrans-2368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小行星杀手**：摧毁100颗小行星。这将跨不同游戏计算，是一个逐步成就。'
- en: '**Survivor**: survive for 60 seconds.'
  id: totrans-2369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幸存者**：存活60秒。'
- en: '**Target acquired**: a hidden achievement. Hit 20 asteroids in a row without
    missing a hit. This is meant to reward players that only shoot when they should.'
  id: totrans-2370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标达成**：一个隐藏成就。连续击中20颗小行星，不得有失误。这是为了奖励那些只在应该射击时射击的玩家。'
- en: '**Target lost**: this is supposed to be a funny achievement, granted when you
    miss with 10 bullets in a row. It is also hidden, because otherwise it would be
    too easy to unlock.'
  id: totrans-2371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标丢失**：这是一个有趣的成就，当你连续10次射击失误时获得。它也是隐藏的，否则解锁会太容易。'
- en: So, we created some images for them and added them to the console.
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为它们创建了一些图片，并将它们添加到控制台中。
- en: '![Achievements](img/B04757_09_07.jpg)'
  id: totrans-2373
  prefs: []
  type: TYPE_IMG
  zh: '![成就](img/B04757_09_07.jpg)'
- en: The developer console with all the configured achievements
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了所有成就的开发者控制台
- en: Each achievement has a string ID. We will need these ids to unlock the achievements
    in our game, but Google has made it easy for us. We have a link at the bottom
    named **Get resources** that pops up a dialog with the string resources we need.
    We can just copy them from there and paste them in our project in the `play_services.xml`
    file we have already created.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 每个成就都有一个字符串ID。我们需要这些ID来在我们的游戏中解锁成就，但谷歌已经为我们简化了这一过程。我们在底部有一个名为**获取资源**的链接，它会弹出一个对话框，显示我们需要的字符串资源。我们可以直接从那里复制它们，并将它们粘贴到我们已创建的`play_services.xml`文件中。
- en: '![Achievements](img/B04757_09_08.jpg)'
  id: totrans-2376
  prefs: []
  type: TYPE_IMG
  zh: '![成就](img/B04757_09_08.jpg)'
- en: Architecture
  id: totrans-2377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: For our game, given that we only have five achievements, we are going to add
    the code for achievements directly into the `ScoreObject`. This will make it less
    code for you to read so we can focus on how it is done. However, for a real production
    code I recommend you define a dedicated architecture for achievements.
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，鉴于我们只有五个成就，我们将直接将成就的代码添加到`ScoreObject`中。这将减少你的阅读代码量，我们可以专注于如何实现。然而，对于真正的生产代码，我建议你为成就定义一个专门的架构。
- en: 'The recommended architecture is to have an `AchievementsManager` class that
    loads all the achievements when the game starts and stores them in three lists:'
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的架构是有一个`AchievementsManager`类，在游戏开始时加载所有成就并将它们存储在三个列表中：
- en: All achievements
  id: totrans-2380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有成就
- en: Locked achievements
  id: totrans-2381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已锁定成就
- en: Unlocked achievements
  id: totrans-2382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已解锁成就
- en: 'Then, we have an `Achievement` base class with an abstract `check` method that
    we implement for each one of them:'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`Achievement`基类，它有一个抽象的`check`方法，我们为每个实例实现它：
- en: '[PRE274]'
  id: totrans-2384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: This base class takes care of loading the achievement state from local storage
    (I recommend using `SharedPreferences` for this) and modify it as per the result
    of `check`.
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类负责从本地存储（我推荐使用`SharedPreferences`）加载成就状态，并根据`check`的结果进行修改。
- en: The achievements check is done at `AchievementManager` level using a `checkLockedAchievements`
    method that iterates over the list of achievements that can be unlocked. This
    method should be called as a part of `onEventReceived` of `GameEngine`.
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 成就检查是在`AchievementManager`级别通过`checkLockedAchievements`方法完成的，该方法遍历可以解锁的成就列表。这个方法应该作为`GameEngine`的`onEventReceived`方法的一部分被调用。
- en: This architecture allows you to check only the achievements that are yet to
    be unlocked and also all the achievements included in the game in a specific dedicated
    place.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构允许你在特定的地方检查尚未解锁的成就，以及游戏中包含的所有成就。
- en: In our case, since we are keeping the score inside the `ScoreGameObject`, we
    are going to add all achievements code there.
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，因为我们把分数保存在`ScoreGameObject`中，所以我们将把所有成就的代码添加到那里。
- en: Note that making the `GameEngine` take care of the score and having it as a
    variable that other objects can read are also recommended design patterns, but
    it was simpler to do this as a part of `ScoreGameObject`.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，让`GameEngine`负责分数，并使其成为其他对象可以读取的变量，也是推荐的设计模式之一，但将其作为`ScoreGameObject`的一部分来实现更为简单。
- en: Unlocking achievements
  id: totrans-2390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解锁成就
- en: 'To handle achievements, we need to have access to an object of the class `GoogleApiClient`.
    We can get a reference to it in the constructor of `ScoreGameObject`:'
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理成就，我们需要访问`GoogleApiClient`类的对象。我们可以在`ScoreGameObject`的构造函数中获取对其的引用：
- en: '[PRE275]'
  id: totrans-2392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: The parent `Fragment` has a reference to the `Activity`, which has a reference
    to the `GameHelper`, which has a reference to the `GoogleApiClient`.
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 父级`Fragment`引用了`Activity`，`Activity`又引用了`GameHelper`，而`GameHelper`则引用了`GoogleApiClient`。
- en: Unlocking an achievement requires just a single line of code, but we also need
    to check whether the user is connected to Google Play services or not before trying
    to unlock an achievement. This is necessary because if the user has not signed
    it, an exception is thrown and the game crashes.
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁一个成就只需要一行代码，但在尝试解锁成就之前，我们还需要检查用户是否连接到Google Play服务。这是必要的，因为如果用户未签名，则会抛出异常，导致游戏崩溃。
- en: Note
  id: totrans-2395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlocking an achievement requires just a single line of code.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁一个成就只需要一行代码。
- en: But this check is not enough. In the edge case, when the user logs out manually
    from Google Play services (which can be done in the achievements screen), the
    connection will not be closed and there is no way to know whether he or she has
    logged out.
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个检查还不够。在边缘情况下，当用户手动从Google Play服务中注销（这可以在成就屏幕中完成）时，连接不会关闭，也没有办法知道他或她是否已经注销。
- en: 'We are going to create a utility method to unlock the achievements that does
    all the checks and also wraps the unlock method into a `try/catch` block and make
    the API client disconnect if an exception is raised:'
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个实用方法来解锁成就，这个方法会执行所有检查，并将解锁方法包装在一个`try/catch`块中，如果抛出异常，则使API客户端断开连接：
- en: '[PRE276]'
  id: totrans-2399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Even with all the checks, the code is still very simple.
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 即使进行了所有检查，代码仍然非常简单。
- en: Let's work on the particular achievements we have defined for the game. Even
    though they are very specific, the methodology to track game events and variables
    and then check for achievements to unlock is in itself generic, and serves as
    a real-life example of how to deal with achievements.
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于为游戏定义的特定成就。尽管它们非常具体，但跟踪游戏事件和变量以及检查解锁成就的方法本身是通用的，并且作为一个真实世界的例子，展示了如何处理成就。
- en: 'The achievements we have designed require us to count some game events and
    also the running time. For the last two achievements, we need to make a new `GameEvent`
    for the case when a bullet misses, which we have not created until now. The code
    in the `Bullet` object to trigger this new `GameEvent` is as follows:'
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的成就要求我们统计一些游戏事件以及运行时间。对于最后两个成就，我们需要为子弹未击中的情况创建一个新的`GameEvent`，这是我们之前尚未创建的。触发这个新`GameEvent`的`Bullet`对象中的代码如下：
- en: '[PRE277]'
  id: totrans-2403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Now, let''s work inside `ScoreGameObject`. We are going to have a method that
    checks achievements each time an asteroid is hit. There are three achievements
    that can be unlocked when that event happens:'
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`ScoreGameObject`内部工作。我们将有一个方法，每次击中小行星时检查成就。当发生该事件时，可以解锁三个成就：
- en: '**Big score**, because hitting an asteroid gives us points'
  id: totrans-2405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高分**，因为击中小行星会给我们加分'
- en: '**Target acquired**, because it requires consecutive asteroid hits'
  id: totrans-2406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标已锁定**，因为它需要连续击中小行星'
- en: '**Asteroid killer**, because it counts the total number of asteroids that have
    been destroyed'
  id: totrans-2407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小行星杀手**，因为它统计了被摧毁的小行星总数'
- en: 'The code is like this:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE278]'
  id: totrans-2409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: We check the total points and the number of consecutive hits to unlock the corresponding
    achievements.
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查总分数和连续击中次数来解锁相应的成就。
- en: The "Asteroid killer" achievement is a bit of a different case, because it is
    an incremental achievement. These type of achievements do not have an `unlock`
    method, but rather an `increment` method. Each time we increment the value, progress
    on the achievement is updated. Once the progress is 100 percent, it is unlocked
    automatically.
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: “小行星杀手”成就是一个有点不同的情况，因为它是一个增量成就。这类成就没有`unlock`方法，而是有一个`increment`方法。每次我们增加值，成就的进度就会更新。一旦进度达到100%，它就会自动解锁。
- en: Note
  id: totrans-2412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Incremental achievements are automatically unlocked, we just have to increment
    their value.
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: 增量成就自动解锁，我们只需增加它们的值。
- en: This makes incremental achievements much easier to use than tracking the progress
    locally. But we still need to do all the checks as we did for `unlockSafe`.
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得增量成就比跟踪本地进度更容易使用。但我们需要像为`unlockSafe`所做的那样进行所有检查。
- en: 'We are using a variable named `mConsecutiveHits`, which we have not initialized
    yet. This is done inside `onGameEvent`, which is the place where the other hidden
    achievement target lost is checked. Some initialization for the "Survivor" achievement
    is also done here:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个名为`mConsecutiveHits`的变量，我们尚未初始化它。这是在`onGameEvent`中完成的，这是检查其他隐藏成就目标丢失的地方。这里也进行了一些“幸存者”成就的初始化：
- en: '[PRE279]'
  id: totrans-2416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Each time we hit an asteroid, we increment the number of consecutive asteroid
    hits and reset the number of consecutive misses. Similarly, each time we miss
    a bullet, we increment the number of consecutive misses and reset the number of
    consecutive hits.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们击中一颗小行星，我们都会增加连续击中小行星的次数并重置连续未击中的次数。同样，每次我们错过一枪，我们都会增加连续未击中的次数并重置连续击中的次数。
- en: 'As a side note, each time the spaceship is destroyed we reset the time without
    dying, which is used for "Survivor", but this is not the only time when the time
    without dying should be updated. We have to reset it when the game starts, and
    modify it inside `onUpdate` by just adding the elapsed milliseconds that have
    passed:'
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条旁注，每次太空船被摧毁时，我们都会重置时间而不死亡，这被用于“幸存者”模式，但这并不是唯一需要更新无死亡时间的情况。我们在游戏开始时也要重置它，并在`onUpdate`内部通过仅添加已过去的时间毫秒来修改它：
- en: '[PRE280]'
  id: totrans-2419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: So, once the game has been running for 60,000 milliseconds since it started
    or since a spaceship was destroyed, we unlock the "Survivor" achievement.
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦游戏自开始以来运行了60,000毫秒，或者自太空船被摧毁以来，我们就解锁“幸存者”成就。
- en: 'With this, we have all the code we need to unlock the achievements we have
    created for the game. Let''s finish this section with some comments on the system
    and the developer console:'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们就有了解锁游戏为我们创建的成就所需的全部代码。让我们以对系统和开发者控制台的一些评论来结束这一部分：
- en: As a rule of thumb, you can edit most of the details of an achievement until
    you publish it to production.
  id: totrans-2422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一条经验法则，你可以在发布到生产之前编辑成就的大部分细节。
- en: Once your achievement has been published, it cannot be deleted. You can only
    delete an achievement in its prepublished state. There is a button labeled Delete
    at the bottom of the achievement screen for this.
  id: totrans-2423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你的成就被发布，就不能删除。你只能在预发布状态下删除成就。成就屏幕底部有一个标有删除的按钮用于此操作。
- en: You can also reset the progress for achievements while they are in draft. This
    reset happens for all players at once. There is a button labeled **Reset achievement
    progress** at the bottom of the achievement screen for this.
  id: totrans-2424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以在成就处于草稿状态时重置成就进度。这个重置会一次性对所有玩家生效。在成就屏幕底部有一个标记为**重置成就进度**的按钮用于此操作。
- en: Also note that `GameBaseActivity` does a lot of logging. So, if your device
    is connected to your computer and you run a debug build, you may see that it lags
    sometimes. This does not happen in a release build for which the log is removed.
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`GameBaseActivity`做了很多日志记录。所以，如果您的设备连接到您的计算机，并且您运行的是调试版本，您可能会看到它有时会卡顿。这种情况不会在发布版本中发生，因为日志已经被移除。
- en: Leaderboards
  id: totrans-2426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排行榜
- en: Since YASS has only one game mode and one score in the game, it makes sense
    to have only one leaderboard on Google Play Game Services. Leaderboards are managed
    from their own tab inside the Game services area of the developer console.
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 由于YASS只有一个游戏模式和游戏中的一个分数，因此只在一个Google Play Game Services上有一个排行榜是有意义的。排行榜在开发者控制台的游戏服务区域内的自己的标签中管理。
- en: Unlike achievements, it is not mandatory to have any leaderboard to be able
    to publish your game.
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 与成就不同，您不需要有任何排行榜就可以发布您的游戏。
- en: If your game has different levels of difficulty, you can have a leaderboard
    for each of them. This also applies if the game has several values that measure
    player progress, you can have a leaderboard for each of them.
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的游戏有不同的难度级别，您可以为每个难度级别创建一个排行榜。如果游戏有几个衡量玩家进度的值，您也可以为每个值创建一个排行榜。
- en: '![Leaderboards](img/B04757_09_09.jpg)'
  id: totrans-2430
  prefs: []
  type: TYPE_IMG
  zh: '![排行榜](img/B04757_09_09.jpg)'
- en: Managing leaderboards on Play Games console
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 在Play Games控制台管理排行榜
- en: 'Leaderboards can be created and managed in the **Leaderboards** tag. When we
    click on Add leaderboard, we are presented with a form that has several fields
    to be filled. They are as follows:'
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 排行榜可以在**排行榜**标签中创建和管理。当我们点击添加排行榜时，会看到一个表单，其中包含几个需要填写字段。它们如下：
- en: '**Name**: the display name of the leaderboard, which can be localized. We will
    simply call it `High Scores`.'
  id: totrans-2433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 排行榜的显示名称，可以是本地化的。我们将简单地称其为`High Scores`。'
- en: '**Score formatting**: this can be **Numeric**, **Currency**, or **Time**. We
    will use **Numeric** for YASS.'
  id: totrans-2434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数格式化**: 这可以是**数值**、**货币**或**时间**。我们将为YASS使用**数值**。'
- en: '**Icon**: a 512x512 px icon to identify the leaderboard.'
  id: totrans-2435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**: 一个512x512像素的图标，用于识别排行榜。'
- en: '**Ordering**: **Larger is better** / **Smaller is better**. We are going to
    use **Larger is better**, but other score types may be **Smaller is better** as
    in a racing game.'
  id: totrans-2436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**: **数值越大越好** / **数值越小越好**。我们将使用**数值越大越好**，但其他分数类型可能像赛车游戏一样是**数值越小越好**。'
- en: '**Enable tamper protection**: this automatically filters out suspicious scores.
    You should keep this on.'
  id: totrans-2437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用篡改保护**: 这会自动过滤掉可疑的分数。您应该保持这个选项开启。'
- en: '**Limits**: if you want to limit the score range that is shown on the leaderboard,
    you can do it here. We are not going to use this'
  id: totrans-2438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**: 如果您想限制在排行榜上显示的分数范围，您可以在这里进行设置。我们不会使用这个功能。'
- en: '**List order**: the order of the leaderboards. Since we only have one, it is
    not really important for us.![Leaderboards](img/B04757_09_10.jpg)'
  id: totrans-2439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表顺序**: 排行榜的顺序。由于我们只有一个，对我们来说并不重要。![排行榜](img/B04757_09_10.jpg)'
- en: Setting up a leaderboard on the Play Games console
  id: totrans-2440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Play Games控制台设置排行榜
- en: Now that we have defined the leaderboard, it is time to use it in the game.
    As happens with achievements, we have a link where we can get all the resources
    for the game in XML. So, we proceed to get the ID of the leaderboard and add it
    to the strings defined in the `play_services.xml` file.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了排行榜，是时候在游戏中使用它了。就像成就一样，我们有一个链接，可以获取游戏中所有资源的XML。因此，我们继续获取排行榜的ID，并将其添加到`play_services.xml`文件中定义的字符串中。
- en: We have to submit the scores at the end of the game (that is, a `GameOver` event),
    but also when the user exits a game via the pause button. To unify this, we will
    create a new `GameEvent` called `GameFinished` that is triggered after a `GameOver`
    event and after the user exits the game.
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在游戏结束时提交分数（即`GameOver`事件），也当用户通过暂停按钮退出游戏时。为了统一，我们将创建一个新的`GameEvent`，称为`GameFinished`，它在`GameOver`事件之后和用户退出游戏后触发。
- en: 'We will update the `stopGame` method of `GameEngine`, which is called in both
    cases to trigger the event:'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`GameEngine`的`stopGame`方法，该方法在两种情况下都会被调用以触发事件：
- en: '[PRE281]'
  id: totrans-2444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: We have to set the `updateThread` to null after sending the event, to prevent
    this code being run twice. Otherwise, we could send each score more than once.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送事件后，我们必须将`updateThread`设置为null，以防止此代码被运行两次。否则，我们可能会发送每个分数多次。
- en: Similarly, as happens for achievements, submitting a score is very simple, just
    a single line of code. But we also need to check that the `GoogleApiClient` is
    connected and we still have the same edge case when an Exception is thrown. So,
    we need to wrap it in a `try`/`catch` block.
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于成就，提交分数非常简单，只需一行代码。但我们也需要检查`GoogleApiClient`是否已连接，并且当抛出异常时，我们仍然会遇到相同的边缘情况。因此，我们需要将其包裹在`try`/`catch`块中。
- en: 'To keep everything in the same place, we will put this code inside `ScoreGameObject`:'
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一切都在同一个地方，我们将这段代码放在`ScoreGameObject`内部：
- en: '[PRE282]'
  id: totrans-2448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: This is really straightforward. GPGS is now receiving our scores and it takes
    care of the timestamp of the score to create daily, weekly, and all time leaderboards.
    It also uses your Google+ circles to show the social score of your friends. All
    this is done automatically for you.
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。现在GPGS正在接收我们的分数，并负责创建每日、每周和所有时间排行榜的分数时间戳。它还使用你的Google+圈子来显示你朋友的社会分数。所有这些都会自动为你完成。
- en: The final missing piece is to let the player open the leaderboards and achievements
    UI from the main menu as well as trigger a sign in if they are signed out.
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺少的部分是让玩家可以从主菜单打开排行榜和成就UI，如果他们未登录，还可以触发登录。
- en: Opening the Play Games UI
  id: totrans-2451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开Play Games UI
- en: To complete the integration of achievements and leaderboards, we are going to
    add buttons to open the native UI provided by GPGS to our main menu.
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成成就和排行榜的集成，我们将在主菜单中添加按钮，以打开GPGS提供的原生UI。
- en: For this, we are going to place two buttons in the bottom–left corner of the
    screen, opposite the music and sound buttons. We will also check whether we are
    connected or not; if not, we will show a single sign-in button.
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在屏幕左下角放置两个按钮，与音乐和声音按钮相对。我们还将检查我们是否已连接；如果没有，我们将显示一个单独的登录按钮。
- en: For these buttons we will use the official images of GPGS, which are available
    for developers to use. Note that you must follow the brand guidelines while using
    the icons and they must be displayed as they are and not modified. This also provides
    a consistent look and feel across all the games that support Play Games.
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些按钮，我们将使用GPGS的官方图像，这些图像可供开发者使用。请注意，在使用图标时，必须遵循品牌指南，并且它们必须以原始形式显示，不得修改。这也为支持Play
    Games的所有游戏提供了一致的外观和感觉。
- en: Since we have seen a lot of layouts already, we are not going to include another
    one that is almost the same as something we already have.
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了很多布局，我们不会包括另一个几乎与现有布局相同的布局。
- en: '![Opening the Play Games UI](img/B04757_09_11.jpg)'
  id: totrans-2456
  prefs: []
  type: TYPE_IMG
  zh: '![打开Play Games UI](img/B04757_09_11.jpg)'
- en: The main menu with the buttons to view achievements and leaderboards.
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 带有查看成就和排行榜按钮的主菜单。
- en: 'To handle these new buttons we will, as usual, set the `MainMenuFragment` as
    `OnClickListener` for the views. We do this in the same place as the other buttons,
    that is, inside `onViewCreated`:'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些新按钮，我们将像往常一样，将`MainMenuFragment`设置为视图的`OnClickListener`。我们在与其它按钮相同的地方这样做，即在`onViewCreated`内部：
- en: '[PRE283]'
  id: totrans-2459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'As happened with achievements and leaderboards, the work is done using static
    methods that receive a `GoogleApiClient` object. We can get this object from the
    `GameHelper` that is a part of the `BaseGameActivity`, like this:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 正如成就和排行榜所发生的那样，工作是通过接收`GoogleApiClient`对象的静态方法完成的。我们可以从`BaseGameActivity`中的`GameHelper`获取这个对象，如下所示：
- en: '[PRE284]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: To open the native UI, we have to obtain an `Intent` and then start an `Activity`
    with it. It is important that you use `startActivityForResult`, since some data
    is passed back and forth.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开原生UI，我们必须获取一个`Intent`，然后使用它启动一个`Activity`。使用`startActivityForResult`非常重要，因为一些数据需要在它们之间来回传递。
- en: 'To open the achievements UI, the code is like this:'
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开成就UI，代码如下：
- en: '[PRE285]'
  id: totrans-2464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '![Opening the Play Games UI](img/B04757_09_12.jpg)'
  id: totrans-2465
  prefs: []
  type: TYPE_IMG
  zh: '![打开Play Games UI](img/B04757_09_12.jpg)'
- en: This works out of the box. It automatically grays out the icons for the unlocked
    achievements, adds a counter and progress bar to the one that is in progress,
    and a padlock to the hidden ones.
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接生效。它会自动将解锁成就的图标变灰，为正在进行的成就添加计数器和进度条，并为隐藏的成就添加一个锁。
- en: 'Similarly, to open the leaderboards UI we obtain an intent from the `Games.Leaderboards`
    class instead:'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要打开排行榜UI，我们从`Games.Leaderboards`类获取一个意图：
- en: '[PRE286]'
  id: totrans-2468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: In this case, we are asking for a specific leaderboard, since we only have one.
    We could use `getLeaderboardsIntent` instead, which will open the Play Games UI
    for the list of all the leaderboards.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们请求一个特定的排行榜，因为我们只有一个。我们可以使用`getLeaderboardsIntent`代替，这将打开所有排行榜的Play
    Games UI。
- en: Note
  id: totrans-2470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can have an intent to open the list of leaderboards or a specific one.
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个意图来打开排行榜列表或特定的一个。
- en: 'What remains to be done is to replace the buttons for the login one when the
    user is not connected. For this, we will create a method that reads the state
    and shows and hides the views accordingly:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 需要完成的事情是在用户未连接时替换登录按钮。为此，我们将创建一个读取状态并相应地显示和隐藏视图的方法：
- en: '[PRE287]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'This method decides whether to remove or make visible the views based on the
    state. We will call it inside the important state-changing methods:'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法根据状态决定是否删除或显示视图。我们将在重要的状态更改方法中调用它：
- en: '`onLayoutCompleted`: the first time we open the game to initialize the UI.'
  id: totrans-2475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLayoutCompleted`：我们第一次打开游戏以初始化UI时。'
- en: '`onSignInSucceeded`: when the user successfully signs in to GPGS.'
  id: totrans-2476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSignInSucceeded`：当用户成功登录到GPGS时。'
- en: '`onSignInFailed`: this can be triggered when we auto sign in and there is no
    connection. It is important to handle it.'
  id: totrans-2477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSignInFailed`：当我们自动登录且没有连接时可以触发。处理它很重要。'
- en: '`onActivityResult`: when we come back from the Play Games UI, in case the user
    has logged out.'
  id: totrans-2478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onActivityResult`：当我们从游戏UI返回时，如果用户已经注销。'
- en: But nothing is as easy as it looks. In fact, when the user signs out and does
    not exit the game, `GoogleApiClient` keeps the connection open. Therefore the
    value of `isSignedIn` from `GameHelper` still returns true. This is the edge case
    we have been talking about all through the chapter.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有事情像看起来那么简单。事实上，当用户注销且未退出游戏时，`GoogleApiClient`保持连接打开。因此，`GameHelper`中的`isSignedIn`的值仍然返回true。这是我们一直在本章中讨论的边缘情况。
- en: As a result of this edge case, there is an inconsistency in the UI that shows
    the achievements and leaderboards buttons when it should show the login one.
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个边缘情况，UI显示成就和排行榜按钮时应该显示登录按钮。
- en: Note
  id: totrans-2481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the user logs out from Play Games, `GoogleApiClient` keeps the connection
    open. This can lead to confusion.
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从Play Games注销时，`GoogleApiClient`保持连接打开。这可能导致困惑。
- en: Unfortunately, this has been marked as work as expected by Google. The reason
    is that the connection is still active and it is our responsibility to parse the
    result in the `onActivityResult` method to determine the new state. But this is
    not very convenient.
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这已被Google标记为预期的工作。原因是连接仍然活跃，并且我们有责任在`onActivityResult`方法中解析结果以确定新状态。但这并不方便。
- en: 'Since it is a rare case we will just go for the easiest solution, which is
    to wrap it in a `try/catch` block and make the user sign in if he or she taps
    on leaderboards or achievements while not logged in. This is the code we have
    to handle the click on the achievements button, but the one for leaderboards is
    equivalent:'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个罕见的情况，我们将采取最简单的解决方案，即在`try/catch`块中包裹它，并在用户未登录时点击排行榜或成就时让用户登录。这是我们处理成就按钮点击的代码，但排行榜的代码是等效的：
- en: '[PRE288]'
  id: totrans-2485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: Basically, we have the old code to open the achievements activity, but we wrap
    it in a `try`/`catch` block. If an exception is raised, we disconnect the game
    helper and begin a new login using the `beginUserInitiatedSignIn` method.
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们有打开成就活动的旧代码，但我们将其包裹在`try`/`catch`块中。如果抛出异常，我们将断开游戏助手并使用`beginUserInitiatedSignIn`方法开始新的登录。
- en: It is very important to disconnect the `gameHelper` before we try to log in
    again. Otherwise, the login will not work.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次尝试登录之前，非常重要地断开`gameHelper`。否则，登录将不会工作。
- en: Note
  id: totrans-2488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must disconnect from GPGS before we can log in using the method from the
    `GameHelper`.
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`GameHelper`中的方法登录之前，我们必须从GPGS断开连接。
- en: 'Finally, there is the case when the user clicks on the login button, which
    just triggers the login using the `beginUserInitiatedSignIn` method from the `GameHelper`:'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户点击登录按钮时，这仅仅触发使用`GameHelper`中的`beginUserInitiatedSignIn`方法进行登录：
- en: '[PRE289]'
  id: totrans-2491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Once you have published your game and the game services, achievements and leaderboards
    will not appear in the game description on Google Play straight away. It is required
    that "a fair amount of users" have used them. You have done nothing wrong, you
    just have to wait.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您发布了游戏和游戏服务，成就和排行榜不会立即出现在Google Play的游戏描述中。需要“相当数量的用户”使用它们。您没有做错什么，您只需要等待。
- en: Other features of Google Play services
  id: totrans-2493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Play服务的其他功能
- en: Google Play Game Services provides more features for game developers than achievements
    and leaderboards. None of them really fit the game we are building, but it is
    useful to know they exist just in case your game needs them. You can save yourself
    lots of time and effort by using them and not reinventing the wheel.
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play游戏服务为游戏开发者提供了比成就和排行榜更多的功能。它们中的任何一个都不太适合我们正在构建的游戏，但了解它们的存在是有用的，以防万一您的游戏需要它们。通过使用它们而不是重新发明轮子，您可以节省大量的时间和精力。
- en: 'The other features of Google Play Games Services are:'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play游戏服务的其他功能包括：
- en: '**Events and quests**: these allow you to monitor game usage and progression.
    Also, they add the possibility of creating time-limited events with rewards for
    the players.'
  id: totrans-2496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件和任务**：这些功能允许您监控游戏使用情况和进度。此外，它们还增加了创建有时间限制的事件并为玩家提供奖励的可能性。'
- en: '**Gifts**: as simple as it sounds, you can send a gift to other players or
    request one to be sent to you. Yes, this is seen in the very mechanical Facebook
    games popularized a while ago.'
  id: totrans-2497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**礼物**：正如其名，您可以给其他玩家发送礼物或请求别人给您发送礼物。是的，这是在几年前流行起来的非常机械的Facebook游戏中看到的。'
- en: '**Saved games**: the standard concept of a saved game. If your game has progression
    or can unlock content based on user actions, you may want to use this feature.
    Since it is saved in the cloud, saved games can be accessed across multiple devices.'
  id: totrans-2498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存的游戏**：保存游戏的标准概念。如果您的游戏具有基于用户行为的进度或可以解锁内容，您可能希望使用此功能。由于它保存在云端，因此保存的游戏可以在多个设备上访问。'
- en: '**Turn-based and real-time multiplayer**: Google Play Game Services provides
    an API to implement turn-based and real-time multiplayer features without you
    needing to write any server code.'
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回合制和实时多人游戏**：Google Play游戏服务提供了一个API，允许您实现回合制和实时多人游戏功能，而无需编写任何服务器代码。'
- en: If your game is multiplayer and has an online economy, it may be worth making
    your own server and granting virtual currency only on the server to prevent cheating.
    Otherwise, it is fairly easy to crack the gifts/reward system and a single person
    can ruin the complete game economy.
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的游戏是多人游戏并且具有在线经济，可能值得自己建立服务器，并且只在服务器上授予虚拟货币以防止作弊。否则，破解礼物/奖励系统相对容易，一个人就可以破坏整个游戏经济。
- en: However, if there is no online game economy, the benefits of gifts and quests
    may be more important than the fact that someone can hack them.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有在线游戏经济，礼物和任务的好处可能比有人可以破解它们的事实更重要。
- en: Let's take a look at each of these features.
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些功能。
- en: Events
  id: totrans-2503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: The event's APIs provides us with a way to define and collect gameplay metrics
    and upload them to Google Play Game Services.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的API为我们提供了一种定义和收集游戏度量指标并将其上传到Google Play游戏服务的方法。
- en: This is very similar to the `GameEvents` we are already using in our game. Events
    should be a subset of the game events of our game. Many of the game events we
    have are used internally as a signal between objects or as a synchronization mechanism.
    These events are not really relevant outside the engine, but others could be.
    Those are the events we should send to GPGS.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们已经在游戏中使用的`GameEvents`非常相似。事件应该是我们游戏游戏事件的一个子集。我们拥有的许多游戏事件都是作为对象之间的信号或同步机制在内部使用的。这些事件在引擎外部并不真正相关，但其他事件可能相关。那些是我们应该发送给GPGS的事件。
- en: To be able to send an event from the game to GPGS, we have to create it in the
    developer console first.
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 要从游戏中发送事件到GPGS，我们必须首先在开发者控制台中创建它。
- en: 'To create an event, we have to go to the **Events** tab in the developer console,
    click on **Add new event**, and fill in the following fields:'
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个事件，我们必须进入开发者控制台中的**事件**选项卡，点击**添加新事件**，并填写以下字段：
- en: '**Name**: a short name of the event. The name can be up to 100 characters.
    This value can be localized.'
  id: totrans-2508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：事件的简短名称。名称最多可以有100个字符。此值可以进行本地化。'
- en: '**Description**: a longer description of the event. The description can be
    up to 500 characters. This value can also be localized.'
  id: totrans-2509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：事件的更详细描述。描述最多可以有500个字符。此值也可以进行本地化。'
- en: '**Icon**: the icon for the event of the standard 512x512 px size.'
  id: totrans-2510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**：事件的图标，标准大小为512x512 px。'
- en: '**Visibility**: as for achievements, this can be revealed or hidden.'
  id: totrans-2511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**：与成就一样，这可以是显示或隐藏。'
- en: '**Format**: as for leaderboards, this can be **Numeric**, **Currency**, or
    **Time**.'
  id: totrans-2512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式**：与排行榜一样，这可以是**数值**、**货币**或**时间**。'
- en: '**Event type**: this is used to mark events that create or spend premium currency.
    This can be **Premium currency sink**, **Premium currency source**, or **None**.'
  id: totrans-2513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件类型**：这用于标记创建或消耗高级货币的事件。这可以是**高级货币消耗**、**高级货币来源**或**无**。'
- en: 'While in the game, events work pretty much as incremental achievements. You
    can increment the event counter using the following line of code:'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，事件的工作方式几乎与增量成就相同。您可以使用以下代码行增加事件计数器：
- en: '[PRE290]'
  id: totrans-2515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: You can delete events that are in the draft state or that have been published
    as long as the event is not in use by a quest. You can also reset the player progress
    data for the testers of your events as you can do for achievements.
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 只要事件没有被任务使用，您就可以删除处于草稿状态或已发布的事件。您还可以像处理成就一样重置您的事件测试者的玩家进度数据。
- en: While the events can be used as an analytics system, their real usefulness appears
    when they are combined with quests.
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然事件可以用作分析系统，但它们真正的实用性在于与任务结合使用时。
- en: Quests
  id: totrans-2518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: A quest is a challenge that asks players to complete an event a number of times
    during a specific time frame to receive a reward.
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是一个挑战，要求玩家在特定时间段内完成事件多次以获得奖励。
- en: Because a quest is linked to an event, to use quests you need to have created
    at least one event.
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任务与事件相关联，要使用任务，您至少需要创建一个事件。
- en: 'You can create a quest from the quests tab in the developer console. A quest
    has the following fields to be filled:'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从开发者控制台中的任务选项卡创建任务。任务有以下字段需要填写：
- en: '**Name**: the short name of the quest. This can be up to 100 characters and
    can be localized.'
  id: totrans-2522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：任务的简称。这可以最多包含 100 个字符，并且可以进行本地化。'
- en: '**Description**: a longer description of the quest. Your quest description
    should let players know what they need to do to complete the quest. The description
    can be up to 500 characters. The first 150 characters will be visible to players
    on cards such as those shown in the Google Play Games app.'
  id: totrans-2523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：任务的较长描述。您的任务描述应让玩家知道他们需要做什么来完成任务。描述可以最多包含 500 个字符。前 150 个字符将在 Google
    Play Games 应用程序中显示的卡片等上对玩家可见。'
- en: '**Icon**: a square icon that will be associated with the quest.'
  id: totrans-2524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**：一个将与任务关联的方形图标。'
- en: '**Banner**: a rectangular image that will be used to promote the quest.'
  id: totrans-2525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横幅**：一个用于推广任务的矩形图像。'
- en: '**Completion Criteria**: this is the configuration of the quest itself. It
    consists of an event and the number of times the event must occur.'
  id: totrans-2526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成标准**：这是任务本身的配置。它由一个事件和事件必须发生的次数组成。'
- en: '**Schedule**: the start and end date and time for the quest. GPGS uses your
    local time zone, but stores the values as UTC. Players will see these values appear
    in their local time zone. You can mark a checkbox to notify users when the quest
    is about to end.'
  id: totrans-2527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间表**：任务的开始和结束日期和时间。GPGS 使用您的本地时区，但以 UTC 存储值。玩家将看到这些值以他们的本地时区显示。您可以选择复选框以在任务即将结束时通知用户。'
- en: '**Reward Data**: this is specific to each game. It can be a JSON object, specifying
    the reward. This is sent to the client when the quest is completed.'
  id: totrans-2528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奖励数据**：这针对每个游戏都是特定的。它可以是指定奖励的 JSON 对象。当任务完成时，这将被发送到客户端。'
- en: 'Once configured in the developer console, you can do two things with the quests:'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在开发者控制台中配置完毕，您可以对任务执行以下两项操作：
- en: Display the list of quests
  id: totrans-2530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示任务列表
- en: Process a quest completion
  id: totrans-2531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理任务完成
- en: 'To get the list of quests, we start an activity with an intent that is provided
    to us via a static method as usual:'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取任务列表，我们通常通过静态方法启动一个提供给我们意图的活动：
- en: '[PRE291]'
  id: totrans-2533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'To be notified when a quest is completed, all we have to do is register a listener:'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务完成时，我们只需注册一个监听器即可收到通知：
- en: '[PRE292]'
  id: totrans-2535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Once we have set the listener, the `onQuestCompleted` method will be called
    once the quest is completed. After completing the processing of the reward, the
    game should call `claim` to inform Play Game services that the player has claimed
    the reward.
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了监听器，一旦任务完成，`onQuestCompleted` 方法将被调用一次。在完成奖励的处理后，游戏应调用 `claim` 以通知 Play
    Game 服务玩家已领取奖励。
- en: 'The following code snippet shows how you might override the `onQuestCompleted`
    callback:'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了您可能如何覆盖 `onQuestCompleted` 回调：
- en: '[PRE293]'
  id: totrans-2538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: The rewards themselves are defined by the client. As we mentioned before, this
    will make the game quite easy to crack and get rewards. But usually, avoiding
    the hassle of writing your own server is worth it.
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励本身由客户端定义。正如我们之前提到的，这将使游戏变得非常容易破解并获得奖励。但通常，避免编写自己的服务器所带来的麻烦是值得的。
- en: Gifts
  id: totrans-2540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 礼物
- en: The gifts feature of GPGS allows us to send gifts to other players and to request
    them to send us one as well. This is intended to make the gameplay more collaborative
    and to improve the social aspect of the game.
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: GPGS的礼物功能允许我们向其他玩家发送礼物，并请求他们向我们发送礼物。这是为了使游戏玩法更具协作性，并提高游戏的社会性。
- en: As for other GPGS features, we have a built-in UI provided by the library that
    can be used. In this case, to send and request gifts for in-game items and resources
    to and from friends in their Google+ circles. The request system can make use
    of notifications.
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其他GPGS功能，我们提供了由库提供的内置UI，可以用于。在这种情况下，用于向和从他们的Google+圈子中的朋友发送和请求游戏内物品和资源的礼物。请求系统可以利用通知。
- en: 'There are two types of requests that players can send using the game gifts
    feature in Google Play Game Services:'
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以使用Google Play游戏服务中的游戏礼物功能发送两种类型的请求：
- en: A wish request to ask for in-game items or some other form of assistance from
    their friends
  id: totrans-2544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个愿望请求，用于向他们的朋友请求游戏内物品或某种形式的帮助
- en: A gift request to send in-game items or some other form of assistance to their
    friends
  id: totrans-2545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个礼物请求，用于向他们的朋友发送游戏内物品或某种形式的帮助
- en: A player can specify one or more target request recipients from the default
    request-sending UI. A gift or wish can be consumed (accepted) or dismissed by
    a recipient.
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以从默认的请求发送UI中指定一个或多个目标请求接收者。礼物或愿望可以被接收者接受（消费）或取消。
- en: To see the gifts API in detail, you can visit [https://developers.google.com/games/services/android/giftRequests](https://developers.google.com/games/services/android/giftRequests).
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解礼物API，您可以访问[https://developers.google.com/games/services/android/giftRequests](https://developers.google.com/games/services/android/giftRequests)。
- en: Again, as for quest rewards, this is done entirely by the client, which makes
    the game susceptible to piracy.
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，关于任务奖励，这是完全由客户端完成的，这使得游戏容易受到盗版的影响。
- en: Saved games
  id: totrans-2549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存游戏
- en: The saved games service offers cloud game saving slots. Your game can retrieve
    the saved game data to allow returning players to continue a game at their last
    save point from any device.
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 保存游戏服务提供云游戏保存槽位。您的游戏可以检索保存的游戏数据，以便让回归玩家可以从任何设备继续他们在上次保存点停止的游戏。
- en: This service makes it possible to synchronize a player's game data across multiple
    devices. For example, if you have a game that runs on Android, you can use the
    saved games service to allow a player to start a game on their Android phone and
    then continue playing the game on a tablet without losing any of their progress.
    This service can also be used to ensure that a player's game play continues from
    where it was left off even if their device is lost, destroyed, or traded in for
    a newer model or if the game was reinstalled
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务使玩家能够在多个设备之间同步游戏数据成为可能。例如，如果您有一个在Android上运行的游戏，您可以使用保存游戏服务允许玩家在他们的Android手机上开始游戏，然后在没有丢失任何进度的情况下在平板电脑上继续玩游戏。此服务还可以用于确保即使玩家的设备丢失、损坏、更换为新款或游戏重新安装，玩家的游戏玩法也能从上次停止的地方继续。
- en: The saved games service does not know about the game internals, so it provides
    a field that is an unstructured binary blob where you can read and write the game
    data. A game can write an arbitrary number of saved games for a single player
    subjected to user quota, so there is no hard requirement to restrict players to
    a single save file.
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 保存游戏服务不了解游戏内部结构，因此它提供了一个字段，该字段是一个非结构化的二进制blob，您可以在其中读取和写入游戏数据。一个游戏可以为单个玩家写入任意数量的保存游戏，受用户配额限制，因此没有硬性要求限制玩家只能有一个保存文件。
- en: Note
  id: totrans-2553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Saved games are done in an unstructured binary blob.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 保存游戏是以非结构化的二进制blob形式进行的。
- en: The API for saved games also receives some metadata that is used by Google Play
    Games to populate the UI and to present useful information in the Google Play
    Game app (for example, last updated timestamp).
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: 保存游戏的API还接收一些元数据，这些数据由Google Play游戏用于填充UI并在Google Play游戏应用中显示有用信息（例如，最后更新时间戳）。
- en: Saved games has several entry points and actions, including how to deal with
    conflicts in the saved games. To know more about these check out the official
    documentation at [https://developers.google.com/games/services/android/savedgames](https://developers.google.com/games/services/android/savedgames).
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的游戏有几个入口点和操作，包括如何处理保存游戏中的冲突。要了解更多信息，请查看官方文档[https://developers.google.com/games/services/android/savedgames](https://developers.google.com/games/services/android/savedgames)。
- en: Multiplayer games
  id: totrans-2557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多人游戏
- en: If you are going to implement multiplayer, GPGS can save you a lot of work.
    You may or may not use it for the final product, but it will remove the need to
    think about the server-side until the game concept is validated.
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要实现多人游戏，GPGS可以为您节省大量工作。您可能或可能不会将其用于最终产品，但它将消除在游戏概念得到验证之前考虑服务器端的需求。
- en: You can use GPGS for turn-based and real-time multiplayer games. Although each
    one is completely different and uses a different API, there is always an initial
    step where the game is set up and the opponents are selected or invited.
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用GPGS来开发回合制和实时多人游戏。尽管每个都是完全不同的，并使用不同的API，但总有一个初始步骤，即设置游戏并选择或邀请对手。
- en: In a turn-based multiplayer game, a single shared state is passed among the
    players and only the player that owns the turn has permission to modify it. Players
    take turns asynchronously according to an order of play determined by the game.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 在回合制多人游戏中，一个共享状态在玩家之间传递，只有拥有回合的玩家才有权修改它。玩家根据游戏确定的播放顺序异步轮流进行。
- en: A turn is finished explicitly by the player using an API call. Then the game
    state is passed to the other players, together with the turn.
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过API调用明确完成一个回合。然后，将游戏状态连同回合一起传递给其他玩家。
- en: 'There are many cases: selecting opponents, creating a match, leaving a match,
    canceling, and so on. The official documentation at [https://developers.google.com/games/services/android/turnbasedMultiplayer](https://developers.google.com/games/services/android/turnbasedMultiplayer)
    is quite exhaustive and you should read through it if you plan to use this feature.'
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况：选择对手、创建比赛、离开比赛、取消等等。官方文档[https://developers.google.com/games/services/android/turnbasedMultiplayer](https://developers.google.com/games/services/android/turnbasedMultiplayer)非常详尽，如果您计划使用此功能，应该阅读它。
- en: 'In a real-time multiplayer there is no concept of turn. Instead, the server
    uses the concept of room: a virtual construct that enables network communication
    between multiple players in the same game session and lets players send data directly
    to one another, a common concept for game servers.'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时多人游戏中，没有回合的概念。相反，服务器使用房间的概念：这是一个虚拟结构，它使得多个玩家在同一游戏会话中能够进行网络通信，并允许玩家直接向彼此发送数据，这是游戏服务器的常见概念。
- en: Note
  id: totrans-2564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Real-time multiplayer service is based on the concept of Room.
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: 实时多人服务基于房间的概念。
- en: 'The API of real-time multiplayer allows us to easily:'
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 实时多人游戏的API使我们能够轻松地：
- en: Manage network connections to create and maintain a real-time multiplayer room
  id: totrans-2567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理网络连接以创建和维护实时多人房间
- en: Provide a player-selection user interface to invite players to join a room,
    look for random players for auto-matching, or a combination of both
  id: totrans-2568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个玩家选择用户界面，邀请玩家加入房间，寻找随机玩家进行自动匹配，或者两者的组合
- en: Store participant and room-state information on the Play Game services' servers
    while the game is running
  id: totrans-2569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏运行时，将参与者和房间状态信息存储在Play Game服务的服务器上
- en: Send room invitations and updates to players
  id: totrans-2570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向玩家发送房间邀请和更新
- en: To check the complete documentation for real-time games, please visit the official
    web at [https://developers.google.com/games/services/android/realtimeMultiplayer](https://developers.google.com/games/services/android/realtimeMultiplayer).
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实时游戏的完整文档，请访问官方网站[https://developers.google.com/games/services/android/realtimeMultiplayer](https://developers.google.com/games/services/android/realtimeMultiplayer)。
- en: Summary
  id: totrans-2572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have added Google Play services to YASS, including setting up the game in
    the developer console and adding the required libraries to the project.
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将Google Play服务添加到YASS中，包括在开发者控制台中设置游戏，并将所需的库添加到项目中。
- en: Then, we defined a set of achievements and added the code to unlock them. We
    have used normal, incremental, and hidden achievement types to showcase the different
    options available.
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一套成就，并添加了解锁它们的代码。我们使用了普通、递增和隐藏的成就类型来展示可用的不同选项。
- en: We have also configured a leaderboard and submitted the scores, both when the
    game is finished and when it is exited via the pause dialog.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还配置了排行榜，并提交了分数，无论是游戏完成时还是通过暂停对话框退出时。
- en: Finally, we have added links to the native UI for leaderboards and achievements
    to the main menu.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主菜单中添加了链接到本地UI的排行榜和成就。
- en: We have also introduced the concepts of events, quests, and gifts and the features
    of saved games and multiplayer that Google Play Game services offers.
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了事件、任务和礼物等概念，以及Google Play游戏服务提供的保存游戏和多人游戏功能。
- en: The game is ready to publish now. In the next chapter, we will see how to make
    it work on Android TV.
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在可以发布了。在下一章中，我们将看到如何让它运行在Android TV上。
- en: Chapter 10. To the Big Screen
  id: totrans-2579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。迈向大屏幕
- en: We have a game that runs properly on phones and tablets. So what about Android
    TV?
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个在手机和平板电脑上运行良好的游戏。那么Android TV呢？
- en: 'I believe Android TV has the potential to become a big gaming platform in the
    near future. Although other systems have tried to bring Android games to the big
    screen—namely OUYA, GameStick, and Amazon FireTV—there is a major difference:
    Android TV is not designed to be a box you plug into your TV but rather the Operating
    System in your SmartTV.'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信Android TV在不久的将来有可能成为一个大型游戏平台。尽管其他系统尝试将Android游戏带到大屏幕上——即OUYA、GameStick和Amazon
    FireTV——但有一个主要区别：Android TV不是设计成可以插入电视的盒子，而是SmartTV中的操作系统。
- en: That makes a lot of difference because people will have it by default. I was
    skeptical about OUYA until I tried it. It was a great experience, but if I hadn't
    been an Android game developer I probably would not have tried it. Android TV
    can break that barrier.
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 这会带来很大的不同，因为人们会默认拥有它。我之前对OUYA持怀疑态度，直到我尝试了它。那是一次美妙的体验，但如果我不是Android游戏开发者，我可能就不会尝试它。Android
    TV可以打破这个障碍。
- en: In addition to that, adding support to Android TV is fairly simple and it may
    allow you to get more reach, so, why not do it anyway?
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为Android TV添加支持相当简单，这可能让你能够触及更广泛的用户群体，所以，为什么不试试呢？
- en: TVs are different from phones, they are bigger and they do not have a touch
    screen. They are also usually watched from a larger distance. Because of that
    Android TV has a different UI and some extra requirements for apps to run on it.
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: 电视与手机不同，它们更大，没有触摸屏。它们通常从更远的距离观看。正因为如此，Android TV有一个不同的用户界面，并且对应用程序在电视上运行有一些额外的要求。
- en: The main requirements when it comes to porting a game to Android TV are to support
    landscape orientation and be usable with a controller. We already do that. If
    your game does not support landscape or is not designed to work with a gamepad,
    then porting to Android TV will require a lot more work and may not be the best
    investment for your time; however, if you have landscape and controller support,
    go for it!
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏移植到Android TV时的主要要求是支持横屏方向，并且可以使用控制器。我们已经做到了这一点。如果你的游戏不支持横屏或未设计为与游戏手柄一起使用，那么移植到Android
    TV将需要更多的工作，可能不是你时间的最佳投资；然而，如果你有横屏和控制器支持，那就去做吧！
- en: Project configuration
  id: totrans-2586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目配置
- en: 'There are two different approaches to adding Android TV to your project. They
    are conceptually different but the code you have to write is almost the same for
    both of them, although in different places. According to the characteristics of
    your project, you may prefer one or another. These options are:'
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加Android TV有两种不同的方法。它们在概念上是不同的，但你需要为这两种方法编写的代码几乎相同，尽管在不同的地方。根据你项目的特点，你可能更喜欢其中的一种。这些选项是：
- en: Building a separate APK for Android TV
  id: totrans-2588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Android TV构建单独的APK
- en: Using the same APK for phones, tablets, and TVs
  id: totrans-2589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的APK为手机、平板电脑和电视使用
- en: The default option of Android Studio is to create a build variant for Android
    TV. It did that when we used the wizard to set up our project and we added TV
    support. That is why we have the `mobile` and `tv` directories. The main project
    is `mobile` and `tv` is configured to be a build variant or "flavor".
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio的默认选项是创建一个适用于Android TV的构建变体。我们在使用向导设置项目并添加TV支持时，它就是这样做的。这就是为什么我们有`mobile`和`tv`目录。主要项目是`mobile`，而`tv`被配置为构建变体或“口味”。
- en: Flavors are a powerful way to build different APKs from the same code base,
    allowing us to modify parts, be it code or resources. It is particularly useful
    when you have to publish the same game in different markets. On the other hand,
    if you have a single APK, it has to be able to adapt to the different configurations
    on its own.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: Flavors是构建不同APK的强大方式，允许我们修改代码或资源的一部分。当你必须在不同市场发布同一款游戏时，这尤其有用。另一方面，如果你有一个单个APK，它必须能够自行适应不同的配置。
- en: Each approach has advantages and disadvantages.
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点。
- en: 'Some reasons why you would want to have a separate APK for Android TV are:'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要为Android TV创建一个单独的APK的原因包括：
- en: Using a lower target API for the mobile version (Android TV requires target
    SDK 21 – Lollipop)
  id: totrans-2594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动版本使用较低的目标API（Android TV需要目标SDK 21 – Lollipop）
- en: Using higher-resolution assets for TV without including them into the mobile
    package
  id: totrans-2595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为电视使用更高分辨率的资源，而不将其包含在移动包中
- en: Having separated special features for mobile/TV
  id: totrans-2596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动/电视提供分离的特殊功能
- en: 'On the other hand, the main advantages of having a single APK are:'
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，拥有单个APK的主要优势包括：
- en: Easier to publish (only one file to upload)
  id: totrans-2598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易发布（只需上传一个文件）
- en: Easier to maintain
  id: totrans-2599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易维护
- en: Given that we will not have any special features built in for Android TV, we
    are going to use the single-APK approach. Note that, if you want to do a build
    variant, the modifications are almost the same, but done in the `tv` directory
    instead.
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会为Android TV内置任何特殊功能，我们将采用单APK方法。请注意，如果你想要创建构建变体，修改几乎相同，但需要在`tv`目录中进行。
- en: Note
  id: totrans-2601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Publishing on Android TV requires target SDK 21.
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android TV上发布需要目标SDK 21。
- en: The official documentation suggests that we include the `Leanback` library,
    which requires `minSDK` version 17\. Since we are not building an app, but a game,
    and the library is about UIs, we can ignore it and keep the `minSDK` to 15.
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档建议我们包含`Leanback`库，该库需要`minSDK`版本17。由于我们不是在构建一个应用，而是一个游戏，并且该库是关于UI的，我们可以忽略它并将`minSDK`保持为15。
- en: Testing for Android TV
  id: totrans-2604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android TV的测试
- en: There are several ways to test the builds for Android TV. The obvious and simplest
    one is to use an emulator.
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以测试Android TV的构建。最明显且最简单的方法是使用模拟器。
- en: Emulators for Android TV—as for phones—are virtual machines that run exactly
    the same version of the operating system as the real device. Therefore they are
    very reliable but also quite slow.
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: Android TV的模拟器——就像手机一样——是运行与真实设备完全相同操作系统版本的虚拟机。因此，它们非常可靠，但同时也相当慢。
- en: Of course, ideally you should be able to test your game on a real device. At
    the time of writing, there are several smart TVs announced with Android TV, but
    the best devices to test are the ADT-1 (Developer Kit) and the Nexus Player.
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，理想情况下，你应该能够在真实设备上测试你的游戏。在撰写本文时，有几款宣布搭载Android TV的智能电视，但最好的测试设备是ADT-1（开发者套件）和Nexus
    Player。
- en: ADT-1 however is in short supply and is hard to get. The Nexus Player on the
    other hand is a fairly cheap device.
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ADT-1供应短缺，难以获得。另一方面，Nexus Player则相对便宜。
- en: However, unless you require to test gameplay, navigation can be easily tested
    with an emulator.
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非你需要测试游戏玩法，否则导航可以通过模拟器轻松测试。
- en: Note
  id: totrans-2610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unless you require to test gameplay, an emulator should be enough to test the
    game.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你需要测试游戏玩法，否则模拟器应该足以测试游戏。
- en: Note that emulators do not include Google Play Services but a real device will
    have them.
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模拟器不包括Google Play服务，但真实设备将包含它们。
- en: I also noticed that the theme on the ADT-1 is slightly different than the one
    on the emulator and the text on the Start button was of a different color. Nothing
    major, and also easy to fix.
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 我还注意到ADT-1的主题与模拟器略有不同，并且启动按钮上的文字颜色也不同。这不是什么大问题，也容易修复。
- en: Declaring a TV Activity
  id: totrans-2614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明TV Activity
- en: Android TV uses the Leanback interface, which is designed for big screens controlled
    by a remote. This UI displays apps and games in a different way from phones. The
    launcher is also different. Because of this, apps and games need to declare an
    Activity with a particular intent filter so the Leanback launcher can find them
    and make them available to the user.
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: Android TV使用Leanback界面，该界面是为由遥控器控制的超大屏幕设计的。这个UI以与手机不同的方式显示应用和游戏。启动器也有所不同。正因为如此，应用和游戏需要声明一个具有特定intent
    filter的Activity，以便Leanback启动器能够找到它们并使它们对用户可用。
- en: This intent filter will declare the app to be available for launch on a Leanback
    interface.
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: 此intent filter将声明应用可在Leanback界面上启动。
- en: 'The easiest way to proceed is to create a new `Activity` that extends from
    our normal activity and then override some methods if necessary to adapt to the
    TV interface. For now, we will create `YassTvActivity` that just extends `YassActivity`:'
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 进行操作的最简单方法是创建一个新的 `Activity`，它扩展自我们的正常活动，并在必要时覆盖一些方法以适应电视界面。目前，我们将创建 `YassTvActivity`，它只是扩展
    `YassActivity`：
- en: '[PRE294]'
  id: totrans-2618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'We will then declare it on `AndroidManifest.xml` with the proper intent filter:'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用适当的 intent 过滤器在 `AndroidManifest.xml` 中声明它：
- en: '[PRE295]'
  id: totrans-2620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: As you can see, the intent filter is almost the same as the one for the normal
    launch activity except that the category has a different name (`LEANBACK_LAUNCHER`
    instead of `LAUNCHER`).
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，intent 过滤器几乎与正常启动活动的相同，只是类别有不同的名称（`LEANBACK_LAUNCHER` 而不是 `LAUNCHER`）。
- en: 'Note that on Android you cannot declare the same activity twice on the manifest,
    but you can declare multiple intent filters for the same activity. You can use
    the same activity for both mobile and TV, like this:'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Android 上，您不能在清单中声明同一活动两次，但可以为同一活动声明多个 intent 过滤器。您可以使用相同的活动为移动和电视使用，如下所示：
- en: '[PRE296]'
  id: totrans-2623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: We are going to use a separate activity to allow minor tweaks in the code, but
    keep the possibility of having the same activity with two intent filters in mind,
    although I advise using it only if you are sure that you will not need to override
    anything.
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个独立的活动来允许对代码进行细微调整，但考虑到可能需要具有两个 intent 过滤器的相同活动，尽管我建议只有在你确定你不需要覆盖任何内容的情况下才使用它。
- en: There is no way to define qualifiers for TV, and that has been done purposefully
    by the Android team to enforce responsive layout design. The only way to know
    we are running on a TV is to programmatically check for the Leanback feature or
    to use a specific activity for TVs and override some methods on it.
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 无法为电视定义限定符，这是 Android 团队有意为之，以强制响应式布局设计。唯一知道我们正在电视上运行的方法是程序性地检查 Leanback 功能或使用特定的电视活动并覆盖其上的某些方法。
- en: Providing a home screen banner
  id: totrans-2626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供主屏幕横幅
- en: Android TV apps must declare a banner in the manifest. This is another requirement
    that does not exist for mobile apps.
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: Android TV 应用必须在清单中声明横幅。这是移动应用不存在的要求之一。
- en: The banner is used by the Leanback UI to navigate among apps and games. It has
    a different aspect ratio than the icon. In particular, the banner is an image
    of 320x180 px that we have to put under the `drawable-xhdpi` directory.
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 横幅由 Leanback UI 用于在应用程序和游戏之间导航。它具有与图标不同的宽高比。特别是，横幅是一个 320x180 像素的图片，我们必须将其放在
    `drawable-xhdpi` 目录下。
- en: '![Providing a home screen banner](img/B04757_10_01.jpg)'
  id: totrans-2629
  prefs: []
  type: TYPE_IMG
  zh: '![提供主屏幕横幅](img/B04757_10_01.jpg)'
- en: The banner is a 320x180 px image
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 横幅是一个 320x180 像素的图片
- en: This image is as important for TV as the icon is for mobile, it is the entry
    point to your game on the TV. While we—as developers—can install and run apps
    on a TV without providing this, there is no easy entry point to launch the app
    from the Leanback UI without providing the banner.
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片对电视的重要性就像图标对移动设备的重要性一样，它是电视上游戏的入口点。虽然我们——作为开发者——可以在不提供横幅的情况下安装和运行电视上的应用程序，但没有横幅，从
    Leanback UI 启动应用程序就没有简单的入口点。
- en: To define which image is to be used as the banner, we need to add it as one
    of the attributes of the `<appication>` tag in the `AndroidManifest.xml`.
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义要使用的横幅图片，我们需要将其添加到 `AndroidManifest.xml` 中 `<application>` 标签的属性之一。
- en: '[PRE297]'
  id: totrans-2633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: This attribute was introduced on Lollipop and it is one of the reasons why we
    need to compile with target SDK 21 to be able to publish for Android TV.
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是在 Lollipop 中引入的，这也是我们需要使用目标 SDK 21 编译以便能够发布到 Android TV 的原因之一。
- en: '![Providing a home screen banner](img/B04757_10_02.jpg)'
  id: totrans-2635
  prefs: []
  type: TYPE_IMG
  zh: '![提供主屏幕横幅](img/B04757_10_02.jpg)'
- en: Our game in the Leanback UI of an emulator
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模拟器 Leanback UI 中的游戏
- en: Declaring it as a game
  id: totrans-2637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明为游戏
- en: As you can see in the previous screenshot, the Leanback UI separates apps from
    games, and our game is listed among the apps. We are building a game and we want
    to be classified as such.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的屏幕截图中所见，Leanback UI 将应用程序与游戏分开，我们的游戏列在应用程序中。我们正在开发一个游戏，并希望被归类为游戏。
- en: This is another property of the `<application>` tag that was also introduced
    in Lollipop for Android TV; we can declare the app to be a game.
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `<application>` 标签的另一个属性，它也是在 Lollipop 中为 Android TV 引入的；我们可以声明应用程序为游戏。
- en: '[PRE298]'
  id: totrans-2640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: This will show the banner in the **Games** category.
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 **游戏** 类别中显示横幅。
- en: '![Declaring it as a game](img/B04757_10_03.jpg)'
  id: totrans-2642
  prefs: []
  type: TYPE_IMG
  zh: '![声明为游戏](img/B04757_10_03.jpg)'
- en: YASS listed in the Games category on an ADT-1
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: YASS 在 ADT-1 上的游戏类别中列出
- en: Declaring Leanback support
  id: totrans-2644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明 Leanback 支持
- en: 'To allow Google Play to list our game when searching from an Android TV, we
    need to specifically declare that we support the Leanback UI. To do that, we have
    to declare that we use the Leanback feature:'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Google Play在从Android TV搜索时列出我们的游戏，我们需要明确声明我们支持Leanback UI。为此，我们必须声明我们使用Leanback功能：
- en: '[PRE299]'
  id: totrans-2646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Note that we declare that we use it but we mark it as not required. This is
    important because otherwise the game will not appear for devices that do not have
    the Leanback feature. If we were to have two separate APKs, we should mark this
    feature as required on the TV build variant only.
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们声明我们使用它，但我们将其标记为非必需。这很重要，因为否则游戏将不会出现在没有Leanback功能的设备上。如果我们有两个单独的APK，我们应该仅在TV构建变体上标记此功能为必需。
- en: Declaring a `uses-feature` means that your app makes use of it. Marking it as
    not required means that it can do without it, but it will make use of it if present.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`uses-feature`意味着你的应用使用了它。将其标记为非必需意味着它可以不使用它，但如果存在，它将使用它。
- en: Note
  id: totrans-2649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Declaring a `uses-feature` means that your app makes use of it. Marking it as
    not required means that it can do without it.
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`uses-feature`意味着你的应用使用了它。将其标记为非必需意味着它可以不使用它。
- en: If you are using separate APKs for mobile and TV, you should declare the `uses-feature`
    for Leanback only on the TV build variant and do nothing on the mobile one. By
    doing that, the TV APK will appear only on devices with Leanback UI and the mobile
    APK will appear only on devices without Leanback support.
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为移动和电视使用单独的APK，你应该仅在TV构建变体上声明`uses-feature`，在移动版本上不做任何操作。通过这样做，TV APK将仅出现在具有Leanback
    UI的设备上，而移动APK将仅出现在没有Leanback支持的设备上。
- en: The default state for the Leanback feature is to not be required.
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: Leanback功能的默认状态是不必需的。
- en: Declaring touchscreen capability as not required
  id: totrans-2653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明触摸屏能力为非必需
- en: Because of how the `uses-feature` system works, we need to fix the requested
    features to make our game available on Android TV. Essentially this means that
    we cannot ask for features that the TV does not have, otherwise the game will
    not appear as available for it.
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`uses-feature`系统的工作方式，我们需要修复请求的功能，以便我们的游戏可以在Android TV上可用。本质上这意味着我们不能请求电视没有的功能，否则游戏将不会显示为对该设备可用。
- en: This is not as simple as it looks since some features get automatically included
    without doing anything.
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不简单，因为有些功能会自动包含，而无需做任何事情。
- en: Because of the nature of Android, touchscreen capability is required by default
    but, if we don't mark it as not required, the game will not be listed on Google
    Play for Android TV, since the device does not have a touchscreen.
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android的特性，触摸屏能力默认是必需的，但如果我们不将其标记为非必需，游戏将不会在Google Play上列出，因为该设备没有触摸屏。
- en: Note
  id: totrans-2657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The touchscreen feature is required by default on Android apps.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用中，触摸屏功能默认是必需的。
- en: This is really easy to fix, we just need to declare touchscreen capability as
    not required on the `AndroidManifest.xml`.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上很容易解决，我们只需要在`AndroidManifest.xml`中将触摸屏能力声明为非必需。
- en: '[PRE300]'
  id: totrans-2660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: Note that this also means that the game should be completely usable without
    a touchscreen. For that we have a special section about handling menus with a
    controller later in this chapter.
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也意味着游戏应该在没有触摸屏的情况下完全可用。为此，我们在本章后面有一个专门关于使用控制器处理菜单的特殊部分。
- en: 'There are other features that are not available on Android TV and you must
    make sure to mark them as not required (and handle cases when they are not available)
    if you use them. The features are:'
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: Android TV上还有其他不可用的功能，如果你使用它们，必须确保将它们标记为非必需（并在它们不可用时处理这些情况）。这些功能包括：
- en: 'Touchscreen: `android.hardware.touchscreen`'
  id: totrans-2663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏：`android.hardware.touchscreen`
- en: 'Touchscreen emulator: `android.hardware.faketouch`'
  id: totrans-2664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏模拟器：`android.hardware.faketouch`
- en: 'Telephony: `android.hardware.telephony`'
  id: totrans-2665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电信：`android.hardware.telephony`
- en: 'Camera: `android.hardware.camera`'
  id: totrans-2666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机：`android.hardware.camera`
- en: 'Bluetooth: `android.hardware.bluetooth`'
  id: totrans-2667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙：`android.hardware.bluetooth`
- en: 'Near Field Communications (NFC): `android.hardware.nfc`'
  id: totrans-2668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近场通信（NFC）：`android.hardware.nfc`
- en: 'GPS: `android.hardware.location.gps`'
  id: totrans-2669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPS：`android.hardware.location.gps`
- en: 'Microphone: `android.hardware.microphone`'
  id: totrans-2670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克风：`android.hardware.microphone`
- en: 'Sensors: `android.hardware.sensor`'
  id: totrans-2671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器：`android.hardware.sensor`
- en: For games only, the touchscreen and sensor aspect may be worrying, but there
    are games that use location and/or the camera as an integral part of the game.
    This may be a deal-breaker when it comes to bringing the game to the TV.
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏来说，触摸屏和传感器可能令人担忧，但有些游戏将位置和/或摄像头作为游戏不可或缺的一部分。当将游戏带到电视上时，这可能会成为决定性的因素。
- en: Note
  id: totrans-2673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your game relies on GPS or the Camera, it's probably not a good fit for a
    TV.
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏依赖于GPS或摄像头，可能不适合在电视上运行。
- en: 'In addition to this, some `uses-permission` declarations imply a requirement
    for hardware features. The permissions that implicitly require features are:'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些`uses-permission`声明隐含了对硬件功能的要求。隐含需要功能的权限是：
- en: '`RECORD_AUDIO` requires the use of `android.hardware.microphone`.'
  id: totrans-2676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RECORD_AUDIO`需要使用`android.hardware.microphone`。'
- en: '`CAMERA` requires:'
  id: totrans-2677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAMERA`需要：'
- en: '`android.hardware.camera`'
  id: totrans-2678
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.hardware.camera`'
- en: '`android.hardware.camera.autofocus`'
  id: totrans-2679
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.hardware.camera.autofocus`'
- en: '`ACCESS_COARSE_LOCATION` requires:'
  id: totrans-2680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_COARSE_LOCATION`需要：'
- en: '`android.hardware.location`'
  id: totrans-2681
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.hardware.location`'
- en: '`android.hardware.location.network`'
  id: totrans-2682
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.hardware.location.network`'
- en: '`ACCESS_FINE_LOCATION` requires:'
  id: totrans-2683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_FINE_LOCATION`需要：'
- en: '`android.hardware.location`'
  id: totrans-2684
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.hardware.location`'
- en: '`android.hardware.location.gps`'
  id: totrans-2685
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.hardware.location.gps`'
- en: If you use any of these permissions, you should ensure to mark the appropriate
    feature as not required and act accordingly when not present.
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这些权限中的任何一项，你应该确保将适当的功能标记为非必需，并在不存在时相应地操作。
- en: 'To detect if a feature is present or not to enable or disable some parts of
    the game on runtime, you can use the `hasSystemFeature` method of `PackageManager`.
    Like this:'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测一个功能是否存在，以便在运行时启用或禁用游戏的一些部分，你可以使用`PackageManager`的`hasSystemFeature`方法。如下所示：
- en: '[PRE301]'
  id: totrans-2688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: Note that `getPackageManager` is available at the `Context` level, so you can
    access it from the `Activity`.
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getPackageManager`在`Context`级别可用，因此你可以从`Activity`中访问它。
- en: Reviewing the manifest
  id: totrans-2690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查清单文件
- en: Once we have added the activity for the TV to the Leanback launcher, made sure
    that the Leanback and touchscreen features are requested but not required, configured
    the banner, and marked it as a game, we are done modifying `AndroidManifest.xml`.
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将TV的活动添加到Leanback启动器中，确保请求了Leanback和触摸屏功能但不是必需的，配置了横幅，并将其标记为游戏，我们就完成了对`AndroidManifest.xml`的修改。
- en: 'The updated version of the manifest is as follows:'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的清单文件如下所示：
- en: '[PRE302]'
  id: totrans-2693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Showing controller instructions
  id: totrans-2694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示控制器说明
- en: 'One of the special requirements for an app to be approved for Android TV is
    to provide a dialog indicating how the controller is mapped. For this Google provides
    us with a template that we can use and it is available online: ([http://developer.android.com/training/tv/games/index.html](http://developer.android.com/training/tv/games/index.html)).'
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用要获得Android TV的批准的特殊要求之一是提供一个对话框，指示控制器是如何映射的。为此，谷歌为我们提供了一个模板，我们可以使用，它可在网上找到：([http://developer.android.com/training/tv/games/index.html](http://developer.android.com/training/tv/games/index.html))。
- en: '![Showing controller instructions](img/B04757_10_04.jpg)'
  id: totrans-2696
  prefs: []
  type: TYPE_IMG
  zh: '![显示控制器说明](img/B04757_10_04.jpg)'
- en: Template for controller mapping
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器映射模板
- en: We already have a dialog that is displayed when a controller is connected, but
    we never updated it from being just an `AlertDialog`. It is time we made it a
    custom dialog.
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个在控制器连接时显示的对话框，但我们从未将其更新为只是一个`AlertDialog`。现在是时候将其改为自定义对话框了。
- en: 'The logic for phones was to show the dialog only the first time the main menu
    was loaded and a controller was connected. For Android TV, we want a different
    behavior: we want to show the dialog every time the game is opened.'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 对于手机，逻辑是在主菜单第一次加载并连接控制器时显示对话框。对于Android TV，我们希望有不同的行为：我们希望在每次游戏打开时都显示对话框。
- en: To do this, we are going to overwrite the method `showControllerHelp` on `MainMenuFragment`
    to use a custom dialog with the template image modified to include the controls
    of our game.
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将覆盖`MainMenuFragment`上的`showControllerHelp`方法，使用一个带有修改后的模板图像以包含我们游戏控制的自定义对话框。
- en: 'As for other custom dialogs we have already made, we have to create a layout
    and a class. The layout is extremely simple, just an image:'
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们已创建的其他自定义对话框，我们必须创建一个布局和一个类。布局非常简单，只是一个图像：
- en: '[PRE303]'
  id: totrans-2702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'And the class is also very simple thanks to `BaseCustomDialog`:'
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BaseCustomDialog`的存在，这个类也非常简单：
- en: '[PRE304]'
  id: totrans-2704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: We are setting the layout and then handling the click on the image as a dismiss.
    When using a controller, the dialog will only be dismissed when using the keys
    *B* or back; we will take care of proper key handling on dialogs later in the
    chapter and make it also dismiss when clicking on the *A* button.
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置布局，然后处理图像的点击作为关闭。当使用控制器时，对话框只有在使用键*B*或返回键时才会关闭；我们将在本章后面处理对话框的正确键处理，并使其在点击*A*按钮时也关闭。
- en: 'Finally, we need to do some changes on `MainMenuFragment` to show this newly
    created dialog and also to modify the logic of when to show it:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对`MainMenuFragment`进行一些修改，以便显示这个新创建的对话框，并修改何时显示它的逻辑：
- en: '[PRE305]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: In the method `shouldDisplayGamePadHelp` we will check if we use the Leanback
    feature to know if we are on a TV or not.
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shouldDisplayGamePadHelp`方法中，我们将检查是否使用Leanback功能来了解我们是否在电视上。
- en: 'If the Leanback feature is not present, we use the same code as before: we
    display the dialog if a controller is connected and we have not displayed it before.'
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Leanback功能不存在，我们将使用之前的相同代码：如果控制器已连接且之前未显示过对话框，则显示对话框。
- en: As mentioned before, we will keep the logic we had for phones, but for TVs we
    will always display the dialog.
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将保留为手机设计的逻辑，但对于电视，我们始终会显示对话框。
- en: In the case of an Android TV, we want to show it when the app is opened. Since
    `shouldDisplayGamepadHelp` is executed during the `onResume` method of the fragment,
    we will store the fact that it has been shown already in a static variable, so
    the dialog is not shown again when we come back to the fragment after a game over.
    Then we return true if the dialog has not been shown yet.
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android TV的情况下，我们希望在应用程序打开时显示它。由于`shouldDisplayGamepadHelp`在片段的`onResume`方法中执行，我们将把已经显示的事实存储在一个静态变量中，这样在游戏结束后返回片段时，对话框就不会再次显示。然后，如果对话框尚未显示，我们返回true。
- en: '![Showing controller instructions](img/B04757_10_05.jpg)'
  id: totrans-2712
  prefs: []
  type: TYPE_IMG
  zh: '![显示控制器说明](img/B04757_10_05.jpg)'
- en: If you plan to support other controllers or consoles such as the MOGA, OUYA,
    or Nvidia Shield, you should have a different image for each of the controllers
    and detect which one is connected by using the device descriptor. In the particular
    case of OUYA, since it is a different marketplace, you can just have another build
    variant with a special graphic.
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划支持其他控制器或游戏机，如MOGA、OUYA或Nvidia Shield，你应该为每个控制器提供不同的图像，并通过使用设备描述符检测哪个控制器已连接。在OUYA的特定情况下，由于它是一个不同的市场，你可以有一个带有特殊图形的另一个构建变体。
- en: Dealing with overscan
  id: totrans-2714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理过扫描
- en: Layouts for TV have some special requirements due to the evolution of TV standards
    and the desire to always present a full screen picture to viewers. For this reason,
    TV devices may clip the outside edge of an app layout in order to ensure that
    the entire display is filled. This behavior is generally referred to as **overscan**.
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电视标准的发展和始终向观众展示全屏画面的需求，电视布局有一些特殊要求。因此，电视设备可能会裁剪应用程序布局的外边缘，以确保整个显示区域被填满。这种行为通常被称为**过扫描**。
- en: To avoid screen elements being clipped due to overscan, it is recommended to
    add a 10% margin on all sides of layouts. When talking about dips, this translates
    into a 48dp margin on the left and right edges and a 27dp margin on the top and
    bottom.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免由于过扫描而裁剪屏幕元素，建议在布局的所有边上添加10%的边距。当谈到dips时，这相当于左侧和右侧边缘的48dp边距，以及顶部和底部边缘的27dp边距。
- en: While we could just add that padding on the layout for all the devices, we will
    create special layouts for Android TV as a practical example of how to do it.
    As we mentioned before, there is no resource qualifier for TV; we have to rely
    on the Leanback feature being present or not.
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在所有设备上直接在布局中添加该填充，但我们将为Android TV创建特殊的布局，作为一个实际示例，展示如何操作。如前所述，没有为电视设置资源限定符；我们必须依赖于Leanback功能是否存在。
- en: We already have a special activity that is launched on the Leanback interface.
    We will also create special fragments for TV where the only difference will be
    the layout. To put the two pieces together, we will override the methods that
    create the fragments and replace them on the TV activity.
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个在Leanback界面启动的特殊活动。我们还将为电视创建特殊片段，唯一的区别将是布局。为了将这两部分结合起来，我们将覆盖创建片段的方法，并在电视活动中替换它们。
- en: This means that we need to first extract the creation of the fragments to a
    method we can override. This is already the case for the `GameFragment`, which
    is created when we start a game, but not for `MainMenuFragment`. That fragment
    is only created during `onCreate` of the activity, so we will refactor the code
    by extracting the creation of the `MainMenuFragment` to a new method.
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要首先将片段的创建提取到一个我们可以覆盖的方法中。对于`GameFragment`来说，这是在开始游戏时创建的，但对于`MainMenuFragment`来说则不是。该片段仅在活动的`onCreate`期间创建，因此我们将通过提取`MainMenuFragment`的创建到一个新方法中来重构代码。
- en: '[PRE306]'
  id: totrans-2720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'To add the margins to the game itself, we will create a file `fragment_game_tv.xml`
    as the layout for the `GameTvFragment` with the following declaration:'
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 要将边距添加到游戏本身，我们将创建一个名为`fragment_game_tv.xml`的文件，作为`GameTvFragment`的布局，以下是其声明：
- en: '[PRE307]'
  id: totrans-2722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: We just put a `FrameLayout` at the top level with the padding required to deal
    with overscan and then include the layout that is normally used for the game.
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在顶级放置一个`FrameLayout`，并添加必要的填充来处理过扫描，然后包含通常用于游戏的布局。
- en: Note that we use padding and not margin because we want to make the background
    to be a child of the `FrameLayout` so it fills the rest of the layout.
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用填充而不是边距，因为我们希望背景成为`FrameLayout`的子项，以便填充布局的其余部分。
- en: 'On the code side, the class for `GameTvFragment` is also quite simple:'
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，`GameTvFragment`的类也很简单：
- en: '[PRE308]'
  id: totrans-2726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: We extend `GameFragment` and override the method `onCreateView` to use the alternative
    layout we just created. Since the normal layout is imported, all the views keep
    their ids and nothing else is necessary for the `GameTvFragment` to work.
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展`GameFragment`并重写`onCreateView`方法以使用我们刚刚创建的替代布局。由于正常布局已被导入，所有视图都保留了它们的ID，对于`GameTvFragment`来说，不需要做其他任何事情。
- en: '![Dealing with overscan](img/B04757_10_06.jpg)'
  id: totrans-2728
  prefs: []
  type: TYPE_IMG
  zh: '![处理过扫描](img/B04757_10_06.jpg)'
- en: GameFragment with extra padding to deal with overscan on TVs
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: 带有额外填充以处理电视上过扫描的GameFragment
- en: 'The case of the main menu is a bit more complicated because of the background
    image being an `ImageView` inside the layout. We have two possible solutions:'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 由于布局中有一个`ImageView`作为背景图像，主菜单的情况稍微复杂一些。我们有两个可能的解决方案：
- en: Import the layout as before and set the visibility of the background image to
    `GONE`
  id: totrans-2731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述导入布局，并将背景图像的可见性设置为`GONE`
- en: Extract all the common layout to a new file and import it on both the mobile
    and the TV layouts
  id: totrans-2732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有通用布局提取到新文件中，并在移动设备和电视布局中导入它。
- en: The last option is easier to read and maintain, so we will do it that way.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项更容易阅读和维护，所以我们将以这种方式进行。
- en: We'll move all the layout information to a new file named `fragment_main_menu_common.xml`,
    which is essentially all the layout except the background image, which will go
    on each of the other layouts.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有布局信息移动到一个名为`fragment_main_menu_common.xml`的新文件中，这基本上是除了背景图像之外的所有布局，背景图像将放在其他每个布局中。
- en: 'Then we create two files for the different layouts; the one for mobiles looks
    like this:'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为不同的布局创建了两个文件；用于移动设备的布局看起来像这样：
- en: '[PRE309]'
  id: totrans-2736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Simple enough—we have replaced the top level view with a `FrameLayout`, added
    the background, and included the common elements.
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到极致——我们用`FrameLayout`替换了顶级视图，添加了背景，并包含了通用元素。
- en: 'The layout for Android TV is essentially the same, but we add margins to the
    imported layout:'
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: Android TV的布局基本上是相同的，但我们给导入的布局添加了边距：
- en: '[PRE310]'
  id: totrans-2739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Note that, to make the margins work with an `include` tag, you also need to
    set the `width` and the `height` but, thankfully, Android Studio gives us a warning
    on that.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使边距与`include`标签一起工作，你还需要设置`width`和`height`，但幸运的是，Android Studio会给我们一个警告。
- en: Going into the code, we will implement a different way of doing the layout replacement
    on the TV fragment. We will extract the layout resource id to a method that can
    be overridden on the extended class. We will do it like this for the `MainMenuFragment`.
    This technique is especially useful when your fragment does some work during `onCreateView`.
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: 进入代码，我们将在TV片段上实现不同的布局替换方式。我们将提取布局资源ID到一个可以被扩展类覆盖的方法中。我们将像这样对`MainMenuFragment`做这件事。这种技术在你想要你的片段在`onCreateView`期间做些工作时特别有用。
- en: 'The code on `MainMenuFragment` will be slightly modified to extract the layout
    resource to a method:'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainMenuFragment`上的代码将稍作修改，以将布局资源提取到方法中：'
- en: '[PRE311]'
  id: totrans-2743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: Since we are extracting the layout because we do not want to override `onCreateView`,
    we are also declaring it final.
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提取布局是因为我们不希望覆盖`onCreateView`，所以我们也将它声明为final。
- en: 'Now the `MainMenuTvFragment` class is just like this:'
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`MainMenuTvFragment`类就像这样：
- en: '[PRE312]'
  id: totrans-2746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '![Dealing with overscan](img/B04757_10_07.jpg)'
  id: totrans-2747
  prefs: []
  type: TYPE_IMG
  zh: '![处理过扫描](img/B04757_10_07.jpg)'
- en: The main menu before and after applying margins for overscan
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 应用过扫描边距的主菜单前后对比
- en: 'Finally, we have to override the specific methods that create the fragments
    in `YassTvActivity`. At last some code is added into that class:'
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须覆盖`YassTvActivity`中创建片段的特定方法。最后，我们在这个类中添加了一些代码：
- en: '[PRE313]'
  id: totrans-2750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'Now that we have illustrated how to solve the problem of overscan in a few
    different ways, let''s move on to the last aspect: navigating the game with a
    controller.'
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了如何以几种不同的方式解决过度扫描的问题，让我们继续到最后一个方面：使用控制器导航游戏。
- en: Controller-based navigation
  id: totrans-2752
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于控制器的导航
- en: The most complex requirement for Android TV is that all the options of the game
    must be accessible using a controller. If you are planning to release on console,
    you should think about it in advance and not make overly complicated menus or
    dialogs.
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android TV来说，最复杂的要求是游戏的所有选项都必须使用控制器可访问。如果您计划在控制台发布，您应该提前考虑，不要制作过于复杂的菜单或对话框。
- en: Note
  id: totrans-2754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For Android TV, all the options in the game must be accessible using a gamepad.
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android TV，游戏中的所有选项都必须使用游戏手柄可访问。
- en: This is where the use of the native Android UI comes in handy. The Android framework
    handles directional navigation between layout elements automatically, so in principle
    you do not need to make any extra effort. However, you should still test the navigation
    with a controller to see if there are any navigation problems.
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用原生Android UI的好处。Android框架自动处理布局元素之间的方向导航，所以原则上你不需要做任何额外的工作。然而，你仍然应该使用控制器测试导航，看看是否有任何导航问题。
- en: Users can also navigate your app using the arrow keys on a keyboard (the behavior
    is the same as when navigating with a D-Pad or trackball). Android provides a
    best-guess as to which view should be given focus in a given direction based on
    the layout of the views on screen. Sometimes, however, Android might guess wrong.
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以使用键盘上的箭头键（行为与使用D-Pad或轨迹球导航时相同）来导航您的应用程序。Android根据屏幕上视图的布局提供了一个最佳猜测，关于在给定方向上哪个视图应该被给予焦点。然而，有时Android可能会猜错。
- en: 'If the system does not pass focus to the view we want when navigating, we can
    override it by specifying which view should receive focus with the following attributes:'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统在导航时没有将焦点传递到我们想要的视图，我们可以通过指定以下属性来覆盖它，以确定哪个视图应该接收焦点：
- en: '`android:nextFocusUp`'
  id: totrans-2759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusUp`'
- en: '`android:nextFocusDown`'
  id: totrans-2760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusDown`'
- en: '`android:nextFocusLeft`'
  id: totrans-2761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusLeft`'
- en: '`android:nextFocusRight`'
  id: totrans-2762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusRight`'
- en: Generally speaking, you should always have the `A` button provide the positive
    action and the `B` button provide the back action. Some controllers (such as the
    one on the ADT-1) provide dedicated back and home buttons, which should also work
    as such. All this is already handled by Android for you.
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，你应该始终让`A`按钮提供正面操作，让`B`按钮提供返回操作。一些控制器（如ADT-1上的控制器）提供专门的返回和主页按钮，它们也应该这样工作。所有这些都已经由Android为你处理。
- en: Note
  id: totrans-2764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The A button should always be a positive action and the B button should act
    as cancel/back.
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`按钮始终应该是正面操作，而`B`按钮应作为取消/返回操作。'
- en: In our case, there are a few problems with YASS that we have to address to provide
    full navigation. These problems are interesting because they are also common pitfalls.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，YASS存在一些问题，我们必须解决这些问题以提供完整的导航。这些问题很有趣，因为它们也是常见的陷阱。
- en: 'If we run the game now we can see that the only focusable control on the main
    menu is the start button. It is not possible to navigate to any other view. This
    is a non-obvious particularity of the Android framework: `ImageView` is not focusable
    by default.'
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行游戏，我们可以看到主菜单上唯一可聚焦的控制是开始按钮。无法导航到任何其他视图。这是Android框架的一个不明显特性：`ImageView`默认不可聚焦。
- en: Note
  id: totrans-2768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ImageViews are not focusable by default.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageView`默认不可聚焦。'
- en: 'Luckily we have defined a style for the round buttons. We can set `focusable`
    to true on the style and it will apply to all round buttons in the application:'
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经为圆形按钮定义了一种样式。我们可以在样式中将`focusable`设置为true，它将应用于应用程序中的所有圆形按钮：
- en: '[PRE314]'
  id: totrans-2771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: We could also use `ImageButton` instead of `ImageView`, which is focusable by
    default, but I think making the `ImageView` focusable is clearer.
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`ImageButton`代替`ImageView`，因为`ImageView`默认是可聚焦的，但我认为使`ImageView`可聚焦更清晰。
- en: Now we can navigate around the menu with the controller and we can see that
    the default navigation Android provides is good. The next step is to check the
    dialogs.
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用控制器在菜单中导航，并且可以看到Android提供的默认导航是好的。下一步是检查对话框。
- en: There are a couple of side effects when we interact with dialogs. Since they
    are not the standard Android dialogs, focus can be moved out of the dialog. Also
    the `GameFragment` uses a game input controller that is taking care of all the
    events. We need to do some fixes.
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与对话框交互时，会有一些副作用。由于它们不是标准的Android对话框，焦点可以移出对话框。此外，`GameFragment`使用一个游戏输入控制器，该控制器负责处理所有事件。我们需要做一些修复。
- en: Dialogs and controllers
  id: totrans-2775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话框和控制器
- en: We are going to solve the problems one at a time. The first one is that focus
    can go to views outside the dialog.
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个解决这些问题。第一个问题是焦点可以移动到对话框外的视图。
- en: This can be easily replicated by opening the game and moving the focus over
    the buttons on the background while the controller help dialog is present. The
    same issue is present on the quit dialog. In both cases, we can start a game with
    the dialog on top, which is wrong.
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过打开游戏，在控制器帮助对话框存在时，将焦点移动到背景按钮上来轻松复制。同样的问题也存在于退出对话框中。在这两种情况下，我们可以以对话框在顶部的方式开始游戏，这是不正确的。
- en: For touch, we solved that with the background view that acts as a click screen
    getting all the clicks and not letting the event pass to the other views behind
    it. For the controller navigation, however, we need something else.
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 对于触摸，我们通过充当点击屏幕的背景视图来解决，该视图获取所有点击事件，并不让事件传递到其后的其他视图。然而，对于控制器导航，我们需要其他东西。
- en: 'There are several ways to fix this. One is to override the navigation on the
    layout; another is to ignore `onClick` events on the fragment if a dialog is being
    shown. We are going for yet another approach: passing the key events to the dialogs
    and filtering them there.'
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。一种是在布局上重写导航；另一种是在显示对话框时忽略片段的`onClick`事件。我们选择另一种方法：将按键事件传递给对话框并在那里过滤它们。
- en: 'This approach also solves the second problem: while in a game, the input controller
    collects and consumes the controller presses.'
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也解决了第二个问题：在游戏中，输入控制器收集并消耗控制器按键。
- en: Since all the `KeyEvent` and `MotionEvent` handling is done at activity level,
    we are going to do a small refactoring and move the logic of showing a dialog
    from the fragment to the activity.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有的`KeyEvent`和`MotionEvent`处理都是在活动级别完成的，我们将进行一些重构，并将显示对话框的逻辑从片段移动到活动。
- en: We will move the method `showDialog` and the variable `mCurrentDialog` from
    `YassBaseFragment` to `YassActivity`.
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`showDialog`方法和变量`mCurrentDialog`从`YassBaseFragment`移动到`YassActivity`。
- en: 'In the base fragment we just have to replace the code of the `showDialog` method
    with this:'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本片段中，我们只需用以下代码替换`showDialog`方法的代码：
- en: '[PRE315]'
  id: totrans-2784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: The next step is to refactor the `dispatchKeyEvent` and `dispatchGenericMotionEvent`
    methods of `YassActivity` by making the dialog have preference over the input
    controller.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对`YassActivity`的`dispatchKeyEvent`和`dispatchGenericMotionEvent`方法进行重构，使对话框优先于输入控制器。
- en: 'The updated version of `dispatchKeyEvent` is as follows:'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatchKeyEvent`的更新版本如下：'
- en: '[PRE316]'
  id: totrans-2787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: If the current dialog is not null and it is showing, then we call a method on
    it also called `dispatchKeyEvent`. If the key event was consumed (the method returned
    true) we return true.
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前对话框不为空且正在显示，我们将在其上调用一个也称为`dispatchKeyEvent`的方法。如果按键事件被消耗（方法返回true），则返回true。
- en: Similarly we proceed with the gamepad controller listener if no dialog is being
    shown. We also return true if the event was consumed by the gamepad controller.
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果没有显示对话框，我们也会对游戏手柄控制器监听器进行同样的处理。如果事件被游戏手柄控制器消耗，我们也会返回true。
- en: Finally, if the event was not consumed yet, we call the super method, which
    will take care of the event normally. This includes moving the focus around the
    views.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果事件尚未被消耗，我们调用超类方法，这将正常处理事件。这包括在视图之间移动焦点。
- en: 'Similarly, we will modify `dispatchGenericMotionEvent`. Although we are not
    going to override any of those events on our dialogs, if you plan to customize
    navigation with the directional keys you also have to take care of the analog
    joysticks and you will need this method for that:'
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也会修改`dispatchGenericMotionEvent`。尽管我们不会在我们的对话框上重写任何这些事件，但如果您计划使用方向键自定义导航，您也必须注意模拟摇杆，并且您将需要这个方法来做到这一点：
- en: '[PRE317]'
  id: totrans-2792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'Finally, we have to update the handling of the back key:'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更新返回键的处理：
- en: '[PRE318]'
  id: totrans-2794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'If we are showing a dialog, we just dismiss it. Otherwise we keep the code
    we had before: we ask the current fragment to handle the back key press and, if
    the event was not consumed, we pass it to the parent class.'
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在显示对话框，我们只需将其关闭。否则，我们保留之前的代码：我们要求当前片段处理返回键的按下，如果事件没有被消耗，我们将其传递给父类。
- en: Note that passing the back key event to the current fragment is important. In
    our game a back press while in the `GameFragment` means that we want to pause
    the game.
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将返回键事件传递给当前片段是很重要的。在我们的游戏中，当在`GameFragment`中按下返回键时，意味着我们想要暂停游戏。
- en: 'To complete this, we have to make the dialogs handle the keys. The default
    implementation on `BaseCustomDialog` is to just return false, meaning that the
    event was not consumed:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个，我们必须让对话框处理按键。`BaseCustomDialog`的默认实现是只返回false，意味着事件没有被消耗：
- en: '[PRE319]'
  id: totrans-2798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: We are going to do a very simple handling where we will only process the OK
    click when one of the buttons on the dialog is selected, but you could also prevent
    the focus from going to views outside the dialog with a more elaborate handling.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一个非常简单的处理，其中我们只处理当对话框上的某个按钮被选中时的OK点击，但你也可以通过更复杂的方式来防止焦点移动到对话框外的视图。
- en: 'For `ControllerHelpDialog`, we will just dismiss it whenever an **OK** is pressed,
    regardless of which view is in focus:'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ControllerHelpDialog`，我们将在按下**OK**按钮时将其关闭，无论哪个视图处于焦点：
- en: '[PRE320]'
  id: totrans-2801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: Note that, from the controller point of view, the **A** button is the **OK**
    button, but certain controllers also have the D-Pad center button and sometimes
    the *Enter* key, so we accept any of those key events as an **OK**.
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从控制器的角度来看，**A**按钮是**OK**按钮，但某些控制器也有D-Pad中心按钮，有时还有*Enter*键，所以我们接受任何这些按键事件作为**OK**。
- en: 'In the case of the Quit dialog, the code is slightly different:'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出对话框的情况下，代码略有不同：
- en: '[PRE321]'
  id: totrans-2804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: In this dialog, whenever we get an OK event, we check if one of our buttons
    is focused. If that is the case, we return false, meaning that we let the upper
    level process it. That will pass the event to the activity, when it will be processed
    and sent back as a click.
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对话框中，每当收到OK事件时，我们检查是否有我们的按钮被聚焦。如果是这样，我们返回false，意味着我们让上层处理它。这将把事件传递给活动，然后进行处理并返回点击。
- en: If none of our actions are focused, we return true, meaning that we are consuming
    the event and nothing else should be done with it.
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的任何操作都没有被聚焦，我们返回true，意味着我们正在消耗事件，不应该对它做任何其他处理。
- en: In any other case, we return false (again, not consuming the event) to let the
    activity handle the key event normally.
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他情况下，我们返回false（再次，不消耗事件）以让活动正常处理按键事件。
- en: Finally, in the case of the pause and game over dialogs that are shown in the
    `GameFragment`, we do not need to do anything because the only item that is focusable
    on that UI is the pause button.
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`GameFragment`中显示的暂停和游戏结束对话框的情况下，我们不需要做任何事情，因为那个UI上唯一可聚焦的项目就是暂停按钮。
- en: 'What we will do is set the pause button to not focusable and then let the system
    handle the keys:'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的就是将暂停按钮设置为不可聚焦，然后让系统处理按键：
- en: '[PRE322]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Note that, while `ImageView` is not focusable by default, we have set that property
    at the style level, and we can always overwrite the value of the style in the
    definition of the layout.
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然`ImageView`默认情况下不可聚焦，但我们已经在样式级别设置了该属性，并且我们可以在布局定义中覆盖样式的值。
- en: With all this changes all the UI of our game is usable with a gamepad and we
    are finally ready to publish on Android TV.
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些更改，我们游戏的UI都可以用游戏手柄使用，我们终于准备好在Android TV上发布了。
- en: Beyond this book
  id: totrans-2813
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超出这本书的范围
- en: We made it! We have built a game from scratch using the Android SDK. We have
    built a game engine that has a separate `UpdateThread` and `DrawThread`, we have
    sprites that can move around, we have handled touch and gamepad controllers, and
    added collision detection, sound, and even particles.
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们从头开始使用Android SDK构建了一个游戏。我们构建了一个具有单独的`UpdateThread`和`DrawThread`的游戏引擎，我们有可以移动的精灵，我们处理了触摸和游戏手柄控制器，并添加了碰撞检测、声音，甚至粒子。
- en: We have also used the components of the Android framework to build our menus
    and dialogs and made use of the animation tools to make it more dynamic.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了Android框架的组件来构建我们的菜单和对话框，并利用动画工具使其更加动态。
- en: YASS also has achievements and leaderboards using Google Play Game Services
    and now it is ready to be played on Android TV as well.
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: YASS还使用了Google Play游戏服务的成就和排行榜，现在它也准备好在Android TV上玩了。
- en: 'At this point, there are a few things that can be done to improve the game
    and that can be a good exercise to help you move forward, if you feel like it.
    Some ideas are:'
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，有一些事情可以做以改进游戏，这也可以作为一个好的练习，帮助你前进，如果你愿意的话。一些想法包括：
- en: Spawn multiple waves with increasing difficulty
  id: totrans-2818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成多个难度递增的波
- en: Include bigger asteroids that break in smaller parts when hit
  id: totrans-2819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含更大的小行星，当被击中时会破碎成更小的部分
- en: 'Add ship selection: provide several ships with different characteristics (speed,
    fire ratio, and so on)'
  id: totrans-2820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加船只选择：提供具有不同特性（速度、火率等）的几艘船
- en: Implement power-ups like shields or improved lasers
  id: totrans-2821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现像护盾或改进的激光这样的增强功能
- en: While this book focuses on the development of a game, there are other aspects
    of making a game that have been overlooked but are also very important. The most
    relevant of them are game design and monetization.
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书主要关注游戏开发，但制作游戏的其他方面也被忽视，但同样非常重要。其中最相关的是游戏设计和盈利模式。
- en: Note
  id: totrans-2823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Game design and monetization are key aspects of making a game.
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计和盈利模式是制作游戏的关键方面。
- en: '**Game design** is a discipline-independent from platform and code and it requires
    high-level considerations about the game itself. Game design is about making a
    game that is fun and engages the user. There are many books that are dedicated
    solely to this concept and it is beyond the scope of this book.'
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏设计**是一个独立于平台和代码的学科，它需要对游戏本身进行高级考虑。游戏设计是关于制作一个有趣并能吸引用户的游戏。有许多书籍专门讨论这个概念，但这本书的范围不包括这个内容。'
- en: '**Monetization** is also a big topic nowadays. If you plan to release a game
    just for fun you do not need to worry about it, but if you mean to make some money
    out of it, it is something to be evaluated.'
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: '**盈利模式**现在也是一个很大的话题。如果你只是想为了乐趣发布一款游戏，你不需要担心这个问题，但如果你打算从中赚钱，那么这是一个需要评估的问题。'
- en: 'The main options to monetize a game are:'
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏盈利的主要选项有：
- en: '**Premium**: Make it a paid game'
  id: totrans-2828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级版**：将其制作成付费游戏'
- en: '**Ads**: Monetize the game by showing ads to the user, either banners or interstitials'
  id: totrans-2829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告**：通过向用户展示广告来盈利游戏，无论是横幅还是插页式广告'
- en: '**In-App Purchases**: Offer the user the chance to purchase items inside the
    game'
  id: totrans-2830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用内购买**：为用户提供在游戏内购买物品的机会'
- en: The advantage of making a paid game is that it is much simpler to build and
    it will give you fewer headaches.
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 制作付费游戏的优点是它构建起来要简单得多，而且会给你带来更少的麻烦。
- en: Some examples of premium games that have done well on mobile are Monument Valley,
    Threes, and The Room (1 and 2).
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在移动设备上表现良好的高级游戏示例包括纪念碑谷、三和房间（1和2）。
- en: The advantage of a free game, either with ads or In-App Purchases, is that the
    install barrier is the lowest there is. If someone is interested in the game,
    installing it is free. Paying for a game requires a conscious decision and many
    people will opt out, regardless of the price.
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: 免费游戏的优点，无论是带广告还是应用内购买，是安装门槛是最低的。如果有人对游戏感兴趣，安装它是免费的。为游戏付费需要做出有意识的决策，很多人会选择放弃，无论价格如何。
- en: If you are planning to go the Free2Play road, be ready to worry about retention
    and conversion of the players. You will get familiar with terms like DAU, MAU,
    ARPU, and ARPPU, to name a few.
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算走免费游玩的道路，要做好担心玩家留存和转换的准备。你将熟悉DAU、MAU、ARPU和ARPPU等术语，仅举几个例子。
- en: Some examples of successful free games with different monetization schemes are
    Candy Crush Saga, Clash of Clans, and Angry Birds.
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 一些成功的免费游戏，具有不同的盈利模式，例如糖果传奇、部落冲突和愤怒的小鸟。
- en: Most studies will tell you that people make more money with In-App Purchases
    than with paid apps. While that it is true, creating a Free2Play game that monetizes
    well requires time and effort to tune it right; so does designing compelling In-App
    Purchases.
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数研究都会告诉你，人们通过应用内购买比付费应用赚更多的钱。虽然这是真的，但要创建一个盈利良好的免费游玩游戏需要时间和精力来调整它；设计吸引人的应用内购买也是如此。
- en: In my experience, making a good monetization design for a Free2Play game takes
    about as much time as making the game itself. If you do not design it carefully,
    you can get really low conversion rates, which turns into little or no revenue.
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，为免费游玩游戏设计良好的盈利模式需要的时间和制作游戏本身的时间差不多。如果你没有仔细设计，你可能会得到非常低的转换率，这会导致收入很少或没有收入。
- en: As a rule of thumb, do not push a monetization model in a game that does not
    feel right and invest your efforts into making the game fun.
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，不要在感觉不合适的情况下推动游戏中的盈利模式，并投入精力使游戏变得有趣。
- en: Summary
  id: totrans-2839
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have our game ready for Android TV. We have updated the manifest to provide
    an activity to launch from the Leanback interface as well as a banner to show
    on the UI, and we have marked it as a game. We also reviewed the permissions to
    be sure that the game will be available on Google Play for Android TV, mainly
    marking touchscreen capability and Leanback as requested but not required.
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为Android TV准备好了游戏。我们更新了清单文件，以提供一个从Leanback界面启动的活动以及一个在UI上显示的横幅，并将其标记为游戏。我们还审查了权限，以确保游戏可以在Android
    TV的Google Play上可用，主要标记了触摸屏能力和Leanback，如请求但非必需。
- en: From the code point of view, we added some extra padding to all the screens
    when running on the TV, to make sure the important content is never cut off because
    of overscan, and we tweaked the code on the dialogs to make them work nicely with
    controllers.
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的角度来看，我们在电视上运行时为所有屏幕添加了一些额外的填充，以确保重要内容不会被过扫描裁剪掉，并且我们调整了对话框上的代码，使其与控制器配合得很好。
- en: Finally we mentioned some pointers about how to improve the game further and
    talked briefly about game design and monetization.
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了一些关于如何进一步改进游戏的提示，并简要讨论了游戏设计和盈利模式。
- en: It is time to start making your own game. Good luck and have fun!
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始制作你自己的游戏了。祝你好运，玩得开心！
- en: Appendix A. API Levels for Android Versions
  id: totrans-2844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. Android版本API级别
- en: 'The following table shows the API levels of different Android platform versions,
    along with the version code:'
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了不同Android平台版本的API级别，以及版本代码：
- en: '| Platform Version | API Level | VERSION_CODE |'
  id: totrans-2846
  prefs: []
  type: TYPE_TB
  zh: '| 平台版本 | API 级别 | 版本代码 |'
- en: '| --- | --- | --- |'
  id: totrans-2847
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Android 5.1 | 22 | `LOLLIPOP_MR1` |'
  id: totrans-2848
  prefs: []
  type: TYPE_TB
  zh: '| Android 5.1 | 22 | `LOLLIPOP_MR1` |'
- en: '| Android 5.0 | 21 | `LOLLIPOP` |'
  id: totrans-2849
  prefs: []
  type: TYPE_TB
  zh: '| Android 5.0 | 21 | `LOLLIPOP` |'
- en: '| Android 4.4W | 20 | `KITKAT_WATCH` |'
  id: totrans-2850
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.4W | 20 | `KITKAT_WATCH` |'
- en: '| Android 4.4 | 19 | `KITKAT` |'
  id: totrans-2851
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.4 | 19 | `KITKAT` |'
- en: '| Android 4.3 | 18 | `JELLY_BEAN_MR2` |'
  id: totrans-2852
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.3 | 18 | `JELLY_BEAN_MR2` |'
- en: '| Android 4.2, 4.2.2 | 17 | `JELLY_BEAN_MR1` |'
  id: totrans-2853
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.2, 4.2.2 | 17 | `JELLY_BEAN_MR1` |'
- en: '| Android 4.1, 4.1.1 | 16 | `JELLY_BEAN` |'
  id: totrans-2854
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.1, 4.1.1 | 16 | `JELLY_BEAN` |'
- en: '| Android 4.0.3, 4.0.4 | 15 | `ICE_CREAM_SANDWICH_MR1` |'
  id: totrans-2855
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.0.3, 4.0.4 | 15 | `ICE_CREAM_SANDWICH_MR1` |'
- en: '| Android 4.0, 4.0.1, 4.0.2 | 14 | `ICE_CREAM_SANDWICH` |'
  id: totrans-2856
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.0, 4.0.1, 4.0.2 | 14 | `ICE_CREAM_SANDWICH` |'
- en: '| Android 3.2 | 13 | `HONEYCOMB_MR2` |'
  id: totrans-2857
  prefs: []
  type: TYPE_TB
  zh: '| Android 3.2 | 13 | `HONEYCOMB_MR2` |'
- en: '| Android 3.1.x | 12 | `HONEYCOMB_MR1` |'
  id: totrans-2858
  prefs: []
  type: TYPE_TB
  zh: '| Android 3.1.x | 12 | `HONEYCOMB_MR1` |'
- en: '| Android 3.0.x | 11 | `HONEYCOMB` |'
  id: totrans-2859
  prefs: []
  type: TYPE_TB
  zh: '| Android 3.0.x | 11 | `HONEYCOMB` |'
- en: '| Android 2.3.4Android 2.3.3 | 10 | `GINGERBREAD_MR1` |'
  id: totrans-2860
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.3.4Android 2.3.3 | 10 | `GINGERBREAD_MR1` |'
- en: '| Android 2.3.2Android 2.3.1Android 2.3 | 9 | `GINGERBREAD` |'
  id: totrans-2861
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.3.2Android 2.3.1Android 2.3 | 9 | `GINGERBREAD` |'
- en: '| Android 2.2.x | 8 | `FROYO` |'
  id: totrans-2862
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.2.x | 8 | `FROYO` |'
- en: '| Android 2.1.x | 7 | `ECLAIR_MR1` |'
  id: totrans-2863
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.1.x | 7 | `ECLAIR_MR1` |'
- en: '| Android 2.0.1 | 6 | `ECLAIR_0_1` |'
  id: totrans-2864
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.0.1 | 6 | `ECLAIR_0_1` |'
- en: '| Android 2.0 | 5 | `ECLAIR` |'
  id: totrans-2865
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.0 | 5 | `ECLAIR` |'
- en: '| Android 1.6 | 4 | `DONUT` |'
  id: totrans-2866
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.6 | 4 | `DONUT` |'
- en: '| Android 1.5 | 3 | `CUPCAKE` |'
  id: totrans-2867
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.5 | 3 | `CUPCAKE` |'
- en: '| Android 1.1 | 2 | `BASE_1_1` |'
  id: totrans-2868
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.1 | 2 | `BASE_1_1` |'
- en: '| Android 1.0 | 1 | `BASE` |'
  id: totrans-2869
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.0 | 1 | `BASE` |'
