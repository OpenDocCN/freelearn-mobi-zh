- en: Chapter 4. Structural Patterns – Adapter and Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss two new structural patterns: the adapter and
    facade patterns. We will focus on the adapter pattern that joins together types
    that were not designed to work with each other. Then, we will discuss the facade
    pattern that simplifies the interface of a set of complex systems.'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is often used when dealing with frameworks, libraries, and APIs
    to easily "adapt" the old and existing interfaces to the new requirements of a
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The adapter pattern converts the interface of another existing class into an
    interface waited by the existing clients to allow them to work together. Thanks
    to this pattern, you can integrate components for which you normally cannot modify
    the source code and things that often appear with the use of a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you should avoid using this pattern if you already have source code
    access to the component.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic class diagram of the pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you can see the four participants of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ITarget`: This introduces the method signature of the object through this
    interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: The client interacts with objects that implement the `ITarget` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Adapter`: This class implements the method of the `ITarget` interface and
    invokes the method of the adapted object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Adaptee`: This is the object for which we need to adapt its interface to make
    it manipulable by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client invokes the `methodA()`adapter that itself invokes the `methodB()`adapter
    of the `adaptee` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following following screenshot represent the organization of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collaboration](img/4852_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sales director of your company wants to produce a universal battery charger
    for mobile phones. This charger can deliver up to 10 volts as output. As the CIO
    of the company, a member of your development team presents you a first prototype
    of the charger.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I created a new OS X Command Line Tool project that you'll
    find in the `first_prototype` folder, and I have named it `ChargerPrototype`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our first prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our project is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Interfaces` folder contains the definition of the methods that the client
    will invoke to charge the phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PhonePrototype.swift` file is a class that defines our test phone and implements
    the `IChargeable` protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing our first prototype](img/4582_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ChargeableProtocol` interface is a simple protocol that defines the signature
    of the `charge` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider that Swift protocols have the same concepts as interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some differences between protocols and Java interfaces, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Swift protocols can also specify properties that must be implemented (for example,
    fields)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift protocols need to deal with values/references through the use of the mutating
    keyword (because protocols can be implemented by structs and classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can combine protocols at any point with the `protocol<>` keyword, for example,
    declaring a function parameter that must adhere to the `A` and `B` protocols,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `PhonePrototype` class that can be charged using the `ChargeableProtocol`
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the comments added to the code here. With Swift, you can add organized
    comments that allow you to see the information with a popover (by holding *Alt*
    + pointing mouse cursor on the swift the method you want usage information). To
    check the result of how the comment are displayed proceed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Charger.swift` file. This file represents our universal charger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap and hold the *Alt* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the mouse `charge` that appears in the `self.phone.charge(volts)` statement.
    An interrogation point `?` will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on charge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you will see the following popover, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing our first prototype](img/4582_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should consider detailed comments of your functions as best practices.
    Make sure that all your methods are fully commented. You can check how the popover
    is well-documented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `///` to start documenting your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `– Parameter parametername: description of the parameter` to describe your
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `– returns: type to return` to describe the returned type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on existing keywords to document your code, you should
    check out the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/](http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/).'
  prefs: []
  type: TYPE_NORMAL
- en: Your engineers present you the prototype of the charger and it seems to work
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the `ChargerPrototype.xcodeproject` file in Xcode, click on run
    to launch the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the console, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing our first prototype](img/4582_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how the `Charger` class has been implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the preceding code is quite simple. By reading it line
    by line we can deduct how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Our charger contains a reference to a phone. The phone must implement `ChargeableProtocol`.
    Of course, our universal charger will only communicate with this interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have a method where we can plug our phone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We assign the phone to our reference and call the charge method of the referenced
    phone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, your mobile phone charger works fine with all mobile phone chargers that
    implement `ChargeableProtocol`.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a problem. Your charger works fine with all phones that implement
    `ChargeableProtocol` but not with mobile phones available on the market. Indeed,
    each mobile phone manufacturer has its own interface to charge its own products.
  prefs: []
  type: TYPE_NORMAL
- en: It is impossible to use our charger with the existing mobile phone! A roof for
    a company that wants to sell universal mobile phone chargers.
  prefs: []
  type: TYPE_NORMAL
- en: You can plan an urgent meeting with your teams in order to find a solution to
    avoid the bankruptcy of your company.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mike, a new developer of your company, proposes a solution: "To make all mobile
    phones work with our charger, they need to implement `ChargeableProtocol`, but
    we cannot modify the mobile phones because we do not have the source code. So,
    we can tell each manufacturer to implement `ChargeableProtocol` on their iPhones."'
  prefs: []
  type: TYPE_NORMAL
- en: Kevin, the IT project manager, replies, "Mike, welcome to the company, but your
    solution is not a good choice. Manufacturers have their own systems and they don't
    want to change them. And what would we do with the phones that are already sold
    that don't implement `ChargeableProtocol`?"
  prefs: []
  type: TYPE_NORMAL
- en: Kevin continues, "The problem that we have is not the manufacturers' problem;
    he doesn't have to adapt their code to make our charger work with their products,
    it is up to our company to adapt ours. Yes, we must adapt our code."
  prefs: []
  type: TYPE_NORMAL
- en: Mike then asks, "So, how do you want to proceed?"
  prefs: []
  type: TYPE_NORMAL
- en: Kevin replies, "Well, the concept is simple. If you plan a trip to France, the
    electrical outlet specifications and shapes are not adapted to the ones that we
    have here in the U.S. I stumbled upon an adapter that I bought from an electrical
    shop near my home. This adapter accepts the shape and specification of my American
    cable and the other one that can be plugged into the French electrical outlet
    because the side plugged in has the same shape and specification as the French
    one. All transformations between the U.S. and French specifications are done in
    the adapter itself."
  prefs: []
  type: TYPE_NORMAL
- en: '"The problem is the same here. We must adapt our charger, depending on the
    manufacturer. So, we will have an adapter per mobile phone and continue to have
    a unique charger."'
  prefs: []
  type: TYPE_NORMAL
- en: Julien, the CEO, replies, "Great, Kevin! Let's go now. We must make our universal
    charger available before Christmas!"
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing that we need to do is to prepare our adapter to make it work
    with our charger. The charger works only with object that implements `ChargeableProtocol`.
    We will need to implement `ChargeableProtocol` with each adapter that we will
    create.
  prefs: []
  type: TYPE_NORMAL
- en: Once the side charger "plugged to" adapter is completed by implementing `ChargeableProtocol`,
    we will add a reference to the mobile phone that the adapter adapts. Our universal
    charger doesn't manipulate the mobile phone instance; it is the role of the adapter
    to manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ChargerWithAdapter.xcodeproj` project and check the organization
    of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have grouped our actors in the following three folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Adaptees`: This contains the component that we must adapt. You can consider
    this one if you do not have the source code. Remember that you should not use
    the adapter pattern if you own the source code of the `Adaptee` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Adapters`: This contains our adapters depending on the mobile phones that
    we must charge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Interface`: This contains the interface implemented by our adapters and manipulated
    by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.swift`: This represents the client: the universal charger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Charger.swift`: This is the object that needs to be adapted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of our adaptees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s study two mobiles phones that we need to adapt: the "Pear" mobile phone
    and "SamSing" mobile phone: Note that in real life, you will not have the source
    code of the adaptee, the object that needs to be adapted, you''ll only work with
    their known interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first analyze the SamSing mobile phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s analyze the Pear mobile phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These two classes represent our objects that need to be adapted: the first
    one is the `SamSingMobilePhone` class that has a method called `chargeBattery`.
    This is the method used by the original charger to charge the SamSing mobile phone.'
  prefs: []
  type: TYPE_NORMAL
- en: The second one is the `PearMobilePhone` class that allows the original charger
    to charge the battery but this one is simply called `charge`. Note that the two
    mobiles phone need different voltages to be charged.
  prefs: []
  type: TYPE_NORMAL
- en: So what you see here is that our universal charger will need to be adapted to
    call the `charge` method when the Pear mobile phone is plugged in and call the
    `chargeBattery` method when the SamSing mobile phone is plugged in.
  prefs: []
  type: TYPE_NORMAL
- en: We will have to make an adapter for each mobile phone type that we want to be
    able to charge.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, you should not have the source code of the `adaptee` object
    when you use the adapter pattern. The source code is provided here only for demonstration
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Have you checked the source code of our two adaptees? I have voluntary introduced
    two new Swift keywords that I wish to present you.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, both classes have an enumeration of possible errors that the charger
    can handle. The SamSing will throw an error if the voltage is too high or too
    low; the Pear model can throw the same errors and can throw another one if there
    is absolutely no power when it is plugged to the charger. As mentioned in the
    documentation, in Swift, errors are represented by values of type conforming to
    the `ErrorType` protocol. This is the reason why you see each enumeration implementing
    the `ErrorType` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Having this enumeration is not sufficient; we need to handle errors when the
    `charge` method is called. For this, we need to tell the method to throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we simply add the `throw` keyword just before we define the return
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that this function definition is exactly the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Not providing the return type is equivalent to stating that the return type
    is of the type `Void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, once our method is informed that it can handle errors, we still have
    to raise an error when it is necessary to do so. We make some conditional checks
    at the beginning of the method, and if something goes wrong, it throws an exception.
    To raise an exception, we simply use the `throw` keyword just before the `ErrorType`
    object (implementing the ErrorType protocol) that we want to raise. (Here is a
    `VoltageError`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the `PearMobilePhone` class raises an error; this is when
    the method receives `0` voltage from the charger. In this case, the `PearVoltageError.NoPower`
    value of the `PearVoltageError` enumeration type will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s investigate the `charge` method of the `PearMobilePhone` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the two `if` statements check whether the voltage is, superior
    to 5.5 volts in the first case, and inferior to 5.5 volts in the second case.
    Each of these `if` statements can throw an error: `TooHigh` or `TooLow`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check how the `NoPower` error is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This statement introduces the new Swift 2 keyword, `guard … else {`.
  prefs: []
  type: TYPE_NORMAL
- en: The `guard` statement is like an `if` statement. It executes statements depending
    on the Boolean value of an expression. The condition must be true for the program
    to continue after the `guard` statement. A `guard` statement always has an `else`
    clause. The statement in this clause is executed if the expression is not true.
  prefs: []
  type: TYPE_NORMAL
- en: The `guard` statement allows you to perform an early exit when checking conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something that I really like about `guard` is to be able to use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With an earlier version of Swift, you would have written something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, come back to our pattern. We have seen that our two mobile phones don''t
    have the same interface, and we now need to create an adapter for each of them,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation of our adaptees](img/4852_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of the SamSingAdapter class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can now code our new adapter that will be able
    to work with the SamSing mobile phone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We created a new `SamSingAdapter` class that implements `ChargeableProtocol`.
    We need to provide a `charge` method that takes the voltage as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: We add a constant called `samSingPhone` that instantiates a `SamSingMobilePhone()`
    object, which we will use to call its own `chargeBattery` method.
  prefs: []
  type: TYPE_NORMAL
- en: We pass `SamSingMobilePhone` as an argument to the constructor of the adapter
    to get a reference to the mobile that we want to charge. Then, we implement the
    code of the charge method. (Remember that this is the only method that the client
    knows.)
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I want to show you some new things that appear with Swift 2.
  prefs: []
  type: TYPE_NORMAL
- en: Swift 2 introduces the `do`, `try`, `catch`, and `throw` mechanisms. We already
    discussed the `throw` statement when we discovered our two `Adaptee` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method that has the `throw` keyword in its definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It must be called using the `try` statement, as this is designed to be clear
    for developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_` symbol is a wildcard because the `chargeBattery` method of the SamSing
    mobile doesn''t return any value (in fact, it returns `Void`). It is useless to
    write such a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you want to handle errors that can be thrown by the `chargeBattery`
    method, this statement must be inside a `do { } catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in the `do` block, you''ll add the called method that might throw an error,
    and if you want to handle it, you can catch it in the `catch` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `catch` statement will silence all errors and the code will continue to
    run. If you want to know more about error handling with Swift 2, I recommend that
    you check out the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch](https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch).'
  prefs: []
  type: TYPE_NORMAL
- en: Our `SamSingAdapter` class is now ready. We will now do the same with the `PearAdapter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the PearAdapter class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will proceed in the same way as the `SamSingAdapter` class but with the
    Pear mobile phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the main differences are that we now have a reference to a `PearMobilePhone`
    object and our `charge` method (that implements `ChargeableProtocol`) calls the
    `pearMobilePhone.charge` method.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to manage the voltage sent to the phone. An adapter must transform
    any value to conform to the interface of the adaptee. If we send a very high voltage,
    our mobile phone will burn and our customers will stop buying our products. So,
    in our adapter, we set the voltage value sent to the Pear mobile phone to 5.5
    volts.
  prefs: []
  type: TYPE_NORMAL
- en: We also catch all the errors that can be thrown by the `charge` method of the
    `pearMobilePhone` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift 2 requires an exhaustive `try`/`catch` error handling. The last `catch`
    statement is our default catch-all block.
  prefs: []
  type: TYPE_NORMAL
- en: As we have set the value to 5.5 volts, which is the only voltage accepted by
    the Pear mobile phone, we will never raise an error, so it is quiet unreadable
    to have so many catch blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, Apple proposes an alternative to you. You can write our adapter like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `try!` method allows you to avoid using `do`/`catch` because you are promising
    that the call will never fail.
  prefs: []
  type: TYPE_NORMAL
- en: We have our universal charger, already ready, two adapters, and two mobile phones
    to test our charger. Remember that our charger provides 10 volts by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our simple test program in the `main.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I don't think that I need to provide you with more details as the complete code
    is mentioned here. We prepare our charger, take the first phone, use an appropriate
    adapter, and then plug the adapter (which is plugged in to our phone too) to the
    charger. We do the same with the second phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code and check our result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation of the PearAdapter class](img/4582_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, it doesn't matter what the mobile is; using our appropriate adapter, by
    default, the charger will send 10 volts, to the adapter, then the adapter will
    transform this voltage (or not) and call the appropriate charge method on the
    phone itself.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the discovery of the adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The facade pattern is a simple pattern used to group the interfaces of a group
    of objects and a unified interface that is easier to use by a client.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The facade pattern allows you to provide the operations that might be desirable
    by a user. The pattern encapsulates the interface of each object that is considered
    as a low-level interface. To construct the unified interface, we might need to
    implement some methods that will compose the low-level interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be used to provide a simple interface of a complex system. The architecture
    of the system can be composed of several small classes that allow great modularity,
    but clients don't need such properties. They only need something simple that meets
    to their needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to divide the system into subsystems. The façade will be an interface
    that allows the communication between subsystems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be also used to encapsulate the implementation of a system toward an
    external consumer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The facade pattern is designed to hide the complexity of a system. Its interface
    can be entirely new. It must not conform to the existing interface. We can provide
    several facades to the same system depending on the end user that we have and
    the functionality that we want to provide to the facade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Facade and its interface are the abstract parts of the system that are exposed
    to the clients. This class has some references to classes and components that
    are part of the system, and they have their methods used by the facade to implement
    the unified interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes and components of the system implement the functionalities of the
    system and answer requests coming from the facade. They do not need the facade
    to be able to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clients communicate with the system through the facade façade. Then, the façade
    itself invokes classes and components of the system. The facade doesn't only send
    requests to classes and components of the subsystem. It must also adapt its own
    interface to the objects and components interfaces, using a specific code to allow
    communication of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram describes this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collaboration](img/4852_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clients using the facade should not directly access the objects of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to provide a simple interface to provide our clients with an easy way
    to find hotels near an input address and corresponding to some criteria (such
    as the number of stars.)
  prefs: []
  type: TYPE_NORMAL
- en: In our company, we have a subsystem that provides a catalog of hotels that includes
    their locations and number of stars for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a FindPoi Webservice that can search for a hotel near a location
    point (latitude and longitude), which uses some criteria: the maximum distance
    to search and the numbers of stars we want.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the service needs a location point, which means that we pass
    an object with a latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: As the consumer of our facade will only tell us its real address, we need services
    that will geocode the address to a GPS point with a latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence diagram shows you what we will do to provide our simplified interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration](img/4852_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open the Xcode project called `FacadePattern` and the `main.swift` file. This
    file represents a client that will consume our facade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our facade is, in fact, a service that allows a client to search for a hotel
    near the location that is sent as an input that has two criteria: `distanceMax`
    and number of stars for the hotel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the service will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code of the client is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We open a connection for our `ServiceFindHotelNearBy` service. We tell what
    our current address is and then display the results if any. Here, we have 125
    results (from 1,000 generated in the `HotelCatalog` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration](img/4582_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of the facade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on the sequence diagram and method of the service consumed by the client,
    the facade called `ServiceFindHotelNearBy` in our sample project will have the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The facade is well-described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make a connection to all the needed systems: the `Geocoding`, `FindPoi`,
    and `SystemHotelCatalog` Webservices (our subsystems).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we orchestrate our calls based on the sequence diagram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first geocode the address into a GPS point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we get `allHotels` from the `systemHotelCatalog` object (which represent
    a subsystem) because we need to send it as an argument to the `FindPoi` service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is what we need to do in our next statement. We need to pass the `distanceMax`
    value, number of stars value, and GPS point we just geocoded as arguments of the
    `findPoiNearBy` method of the `FindPoi` service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we return the results to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the facade has encapsulated all the needed calls to the subsystem,
    hiding the complexity of retrieving hotels corresponding to the wishes of the
    client. This concludes the description of the facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concludes the discovery of the seven structural patterns. The adapter
    pattern has much more in common with the bridge pattern. The main difference is
    in the purpose of the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A bridge separates an interface and its implementation, whereas an adapter changes
    the interface of an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator adds a functionality to an object without changing its interface
    and should be transparent to the application. For the adapter, this is not the
    case, it is not transparent from the client perspective: the adapter is the named
    implementation of the interface that a client sees, so the adapter is not hidden
    from the client.'
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern doesn't change any interface. It defines substitute objects
    for other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern transforms high-level requests into low-level requests by
    communicating with other subsystems. It hides the complexity of these subsystems
    by providing a simple interface that the client can see.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will start with our first three behavioral patterns:
    the `Strategy`, `State`, and `Template` methods.'
  prefs: []
  type: TYPE_NORMAL
