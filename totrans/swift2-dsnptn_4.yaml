- en: Chapter 4. Structural Patterns – Adapter and Facade
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 结构模式 - 适配器和外观
- en: 'In this chapter, we will discuss two new structural patterns: the adapter and
    facade patterns. We will focus on the adapter pattern that joins together types
    that were not designed to work with each other. Then, we will discuss the facade
    pattern that simplifies the interface of a set of complex systems.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两种新的结构模式：适配器模式和外观模式。我们将重点关注适配器模式，它将那些未被设计为相互协作的类型联合起来。然后，我们将讨论外观模式，它简化了一组复杂系统的接口。
- en: The adapter pattern
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: This pattern is often used when dealing with frameworks, libraries, and APIs
    to easily "adapt" the old and existing interfaces to the new requirements of a
    program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理框架、库和API时，这种模式经常被用来轻松地将旧的和现有的接口适应到程序的新需求。
- en: Roles
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The adapter pattern converts the interface of another existing class into an
    interface waited by the existing clients to allow them to work together. Thanks
    to this pattern, you can integrate components for which you normally cannot modify
    the source code and things that often appear with the use of a framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式将另一个现有类的接口转换为现有客户端期望的接口，以便它们可以一起工作。多亏了这个模式，您可以集成那些通常无法修改源代码的组件，以及那些经常与框架使用相关的事物。
- en: Note that you should avoid using this pattern if you already have source code
    access to the component.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您已经可以访问组件的源代码，应避免使用此模式。
- en: Design
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic class diagram of the pattern is as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的通用类图如下：
- en: '![Design](img/4852_04_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_04_01.jpg)'
- en: Participants
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'In the preceding diagram, you can see the four participants of this pattern:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到这个模式的四个参与者：
- en: '`ITarget`: This introduces the method signature of the object through this
    interface'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITarget`：通过这个接口引入了对象的函数签名'
- en: '`Client`: The client interacts with objects that implement the `ITarget` interface'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：客户端与实现`ITarget`接口的对象交互'
- en: '`Adapter`: This class implements the method of the `ITarget` interface and
    invokes the method of the adapted object'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Adapter`：这个类实现了`ITarget`接口的方法，并调用适配对象的相应方法'
- en: '`Adaptee`: This is the object for which we need to adapt its interface to make
    it manipulable by the client'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Adaptee`：这是我们需要适配其接口以使其可由客户端操作的对象'
- en: Collaboration
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The client invokes the `methodA()`adapter that itself invokes the `methodB()`adapter
    of the `adaptee` object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 客户调用`methodA()`适配器，该适配器本身调用`adaptee`对象的`methodB()`适配器。
- en: 'The following following screenshot represent the organization of our project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了我们项目的组织结构：
- en: '![Collaboration](img/4852_04_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![协作](img/4852_04_02.jpg)'
- en: Illustration
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: The sales director of your company wants to produce a universal battery charger
    for mobile phones. This charger can deliver up to 10 volts as output. As the CIO
    of the company, a member of your development team presents you a first prototype
    of the charger.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您公司的销售总监希望生产一款适用于手机的通用电池充电器。这款充电器可以输出高达10伏的电压。作为公司的CIO，您的开发团队向您展示了这个充电器的第一个原型。
- en: In this chapter, I created a new OS X Command Line Tool project that you'll
    find in the `first_prototype` folder, and I have named it `ChargerPrototype`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我在`first_prototype`文件夹中创建了一个新的OS X命令行工具项目，您可以在其中找到它，并将其命名为`ChargerPrototype`。
- en: Implementing our first prototype
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现我们的第一个原型
- en: 'Our project is organized as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目组织如下：
- en: The `Interfaces` folder contains the definition of the methods that the client
    will invoke to charge the phone
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interfaces`文件夹包含了客户端将要调用的方法定义，用于给手机充电'
- en: The `PhonePrototype.swift` file is a class that defines our test phone and implements
    the `IChargeable` protocol
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhonePrototype.swift`文件是一个类，它定义了我们的测试手机并实现了`IChargeable`协议'
- en: 'The result is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Implementing our first prototype](img/4582_04_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的第一个原型](img/4582_04_03.jpg)'
- en: 'The `ChargeableProtocol` interface is a simple protocol that defines the signature
    of the `charge` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChargeableProtocol`接口是一个简单的协议，它定义了`charge`方法的签名：'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Consider that Swift protocols have the same concepts as interfaces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Swift协议与接口有相同的概念。
- en: 'There are some differences between protocols and Java interfaces, which are
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和Java接口之间有一些区别，如下所示：
- en: Swift protocols can also specify properties that must be implemented (for example,
    fields)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift协议也可以指定必须实现（例如，字段）的属性
- en: Swift protocols need to deal with values/references through the use of the mutating
    keyword (because protocols can be implemented by structs and classes)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift协议需要通过使用`mutating`关键字来处理值/引用（因为协议可以被结构体和类实现）
- en: 'You can combine protocols at any point with the `protocol<>` keyword, for example,
    declaring a function parameter that must adhere to the `A` and `B` protocols,
    which is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何位置使用`protocol<>`关键字组合协议，例如，声明一个必须遵循`A`和`B`协议的函数参数，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define a `PhonePrototype` class that can be charged using the `ChargeableProtocol`
    protocol:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`PhonePrototype`类，它可以使用`ChargeableProtocol`协议进行充电：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the comments added to the code here. With Swift, you can add organized
    comments that allow you to see the information with a popover (by holding *Alt*
    + pointing mouse cursor on the swift the method you want usage information). To
    check the result of how the comment are displayed proceed like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里添加的代码注释。使用Swift，你可以添加有组织的注释，这样你可以通过弹出窗口（通过按住*Alt*键并指向鼠标光标在Swift方法上）来查看信息。要检查注释的显示结果，请按照以下步骤操作：
- en: Open the `Charger.swift` file. This file represents our universal charger.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Charger.swift`文件。此文件代表我们的通用充电器。
- en: Tap and hold the *Alt* key.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住并保持*Alt*键。
- en: Position the mouse `charge` that appears in the `self.phone.charge(volts)` statement.
    An interrogation point `?` will appear.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标定位在`self.phone.charge(volts)`语句中出现的`charge`上。一个问号`?`会出现。
- en: Click on charge.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击充电。
- en: 'Then, you will see the following popover, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到以下弹出窗口，如图所示：
- en: '![Implementing our first prototype](img/4582_04_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的第一个原型](img/4582_04_04.jpg)'
- en: 'You should consider detailed comments of your functions as best practices.
    Make sure that all your methods are fully commented. You can check how the popover
    is well-documented, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑详细注释你的函数作为最佳实践。确保所有你的方法都得到了充分的注释。你可以检查弹出窗口是如何得到良好文档化的，如下所示：
- en: Use `///` to start documenting your code
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`///`开始注释你的代码
- en: 'Use `– Parameter parametername: description of the parameter` to describe your
    parameter'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`– 参数 parametername: 参数描述`来描述你的参数'
- en: 'Use `– returns: type to return` to describe the returned type'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`– 返回: 类型`来描述返回的类型'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on existing keywords to document your code, you should
    check out the following website:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于现有关键字以文档化你的代码的更多信息，你应该查看以下网站：
- en: '[http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/](http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/](http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/)。'
- en: Your engineers present you the prototype of the charger and it seems to work
    fine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工程师向你展示了充电器的原型，它看起来工作得很好。
- en: After loading the `ChargerPrototype.xcodeproject` file in Xcode, click on run
    to launch the code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中加载`ChargerPrototype.xcodeproject`文件后，点击运行以启动代码。
- en: 'On the console, you will see the following result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台上，你会看到以下结果：
- en: '![Implementing our first prototype](img/4582_04_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的第一个原型](img/4582_04_05.jpg)'
- en: 'Let''s see how the `Charger` class has been implemented:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Charger`类是如何实现的：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The implementation of the preceding code is quite simple. By reading it line
    by line we can deduct how it works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的实现相当简单。通过逐行阅读，我们可以推断出它是如何工作的：
- en: Our charger contains a reference to a phone. The phone must implement `ChargeableProtocol`.
    Of course, our universal charger will only communicate with this interface.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的充电器包含一个对手机的引用。该手机必须实现`ChargeableProtocol`。当然，我们的通用充电器只会与这个接口通信。
- en: Then, we have a method where we can plug our phone.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个可以插入手机的方法。
- en: We assign the phone to our reference and call the charge method of the referenced
    phone.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将手机分配给我们的引用并调用引用手机的充电方法。
- en: So, your mobile phone charger works fine with all mobile phone chargers that
    implement `ChargeableProtocol`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的手机充电器与所有实现`ChargeableProtocol`的手机充电器都工作得很好。
- en: However, there is a problem. Your charger works fine with all phones that implement
    `ChargeableProtocol` but not with mobile phones available on the market. Indeed,
    each mobile phone manufacturer has its own interface to charge its own products.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题。你的充电器与所有实现`ChargeableProtocol`的手机都工作得很好，但与市场上可用的手机不兼容。确实，每个手机制造商都有自己的接口来为其产品充电。
- en: It is impossible to use our charger with the existing mobile phone! A roof for
    a company that wants to sell universal mobile phone chargers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们现有的充电器给手机充电是不可能的！这是想要销售通用手机充电器的公司的屋顶。
- en: You can plan an urgent meeting with your teams in order to find a solution to
    avoid the bankruptcy of your company.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安排一个紧急会议，与你的团队一起找到解决方案，以避免你公司的破产。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Mike, a new developer of your company, proposes a solution: "To make all mobile
    phones work with our charger, they need to implement `ChargeableProtocol`, but
    we cannot modify the mobile phones because we do not have the source code. So,
    we can tell each manufacturer to implement `ChargeableProtocol` on their iPhones."'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mike，你们公司的新开发人员，提出了解决方案：“为了让所有手机都能使用我们的充电器，它们需要实现`ChargeableProtocol`，但我们不能修改手机，因为我们没有源代码。所以，我们可以告诉每个制造商在他们自己的iPhone上实现`ChargeableProtocol`。”
- en: Kevin, the IT project manager, replies, "Mike, welcome to the company, but your
    solution is not a good choice. Manufacturers have their own systems and they don't
    want to change them. And what would we do with the phones that are already sold
    that don't implement `ChargeableProtocol`?"
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kevin，IT项目经理，回答说：“Mike，欢迎加入我们公司，但你的解决方案不是一个好的选择。制造商有自己的系统，他们不想改变它们。对于已经售出且没有实现`ChargeableProtocol`的手机，我们该怎么办？”
- en: Kevin continues, "The problem that we have is not the manufacturers' problem;
    he doesn't have to adapt their code to make our charger work with their products,
    it is up to our company to adapt ours. Yes, we must adapt our code."
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Kevin继续说：“我们遇到的问题不是制造商的问题；他们不需要调整他们的代码来让我们的充电器与他们的产品一起工作，这是我们的公司需要调整的地方。是的，我们必须调整我们的代码。”
- en: Mike then asks, "So, how do you want to proceed?"
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Mike问道：“那么，你打算怎么进行？”
- en: Kevin replies, "Well, the concept is simple. If you plan a trip to France, the
    electrical outlet specifications and shapes are not adapted to the ones that we
    have here in the U.S. I stumbled upon an adapter that I bought from an electrical
    shop near my home. This adapter accepts the shape and specification of my American
    cable and the other one that can be plugged into the French electrical outlet
    because the side plugged in has the same shape and specification as the French
    one. All transformations between the U.S. and French specifications are done in
    the adapter itself."
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Kevin回答说：“嗯，这个概念很简单。如果你计划去法国旅行，那里的电源插座规格和形状并不适合我们美国的。我在我家附近的电器店偶然发现了一个适配器。这个适配器接受我的美国电缆的形状和规格，以及可以插入法国电源插座的另一个适配器，因为插入的一侧具有与法国相同的形状和规格。所有美国和法国规格之间的转换都在适配器本身完成。”
- en: '"The problem is the same here. We must adapt our charger, depending on the
    manufacturer. So, we will have an adapter per mobile phone and continue to have
    a unique charger."'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “这里的问题也是一样的。我们必须根据制造商调整我们的充电器。所以，我们将为每款手机配备一个适配器，并继续使用一个独特的充电器。”
- en: Julien, the CEO, replies, "Great, Kevin! Let's go now. We must make our universal
    charger available before Christmas!"
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Julien，首席执行官，回答说：“太好了，Kevin！我们现在就去。我们必须在圣诞节前让我们的通用充电器可用！”
- en: Implementation
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: The first thing that we need to do is to prepare our adapter to make it work
    with our charger. The charger works only with object that implements `ChargeableProtocol`.
    We will need to implement `ChargeableProtocol` with each adapter that we will
    create.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是准备我们的适配器，使其与我们的充电器一起工作。充电器只与实现`ChargeableProtocol`的对象一起工作。我们将需要为我们将要创建的每个适配器实现`ChargeableProtocol`。
- en: Once the side charger "plugged to" adapter is completed by implementing `ChargeableProtocol`,
    we will add a reference to the mobile phone that the adapter adapts. Our universal
    charger doesn't manipulate the mobile phone instance; it is the role of the adapter
    to manipulate it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过实现`ChargeableProtocol`完成充电器侧的“插入”适配器，我们将添加一个引用到适配器适配的手机。我们的通用充电器不会操作手机实例；这是适配器的角色来操作它。
- en: 'Open the `ChargerWithAdapter.xcodeproj` project and check the organization
    of our code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`ChargerWithAdapter.xcodeproj`项目并检查我们代码的组织结构：
- en: '![Implementation](img/4582_04_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4582_04_06.jpg)'
- en: 'We have grouped our actors in the following three folders:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的演员分成了以下三个文件夹：
- en: '`Adaptees`: This contains the component that we must adapt. You can consider
    this one if you do not have the source code. Remember that you should not use
    the adapter pattern if you own the source code of the `Adaptee` folder.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`适配器`：这包含我们必须适配的组件。如果你没有源代码，可以考虑这个。记住，如果你拥有`适配器`文件夹的源代码，你不应该使用适配器模式。'
- en: '`Adapters`: This contains our adapters depending on the mobile phones that
    we must charge.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Adapters`：这包含了根据我们想要充电的手机类型而必须使用的适配器。'
- en: '`Interface`: This contains the interface implemented by our adapters and manipulated
    by the client.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interface`：这包含了我们的适配器实现的接口和客户端操作的接口。'
- en: '`main.swift`: This represents the client: the universal charger.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.swift`：这代表客户端：通用充电器。'
- en: '`Charger.swift`: This is the object that needs to be adapted.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Charger.swift`：这是需要适配的对象。'
- en: Implementation of our adaptees
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器的实现
- en: 'Let''s study two mobiles phones that we need to adapt: the "Pear" mobile phone
    and "SamSing" mobile phone: Note that in real life, you will not have the source
    code of the adaptee, the object that needs to be adapted, you''ll only work with
    their known interfaces.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究两个需要适配的手机：即“Pear”手机和“SamSing”手机：请注意，在现实生活中，你将不会拥有`adaptee`对象的源代码，即需要适配的对象，你将只与它们的已知接口打交道。
- en: 'Let''s first analyze the SamSing mobile phone:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先分析一下SamSing手机：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s analyze the Pear mobile phone:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析一下Pear手机：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These two classes represent our objects that need to be adapted: the first
    one is the `SamSingMobilePhone` class that has a method called `chargeBattery`.
    This is the method used by the original charger to charge the SamSing mobile phone.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类代表了我们需要适配的对象：第一个是`SamSingMobilePhone`类，它有一个名为`chargeBattery`的方法。这是原始充电器用来为SamSing手机充电的方法。
- en: The second one is the `PearMobilePhone` class that allows the original charger
    to charge the battery but this one is simply called `charge`. Note that the two
    mobiles phone need different voltages to be charged.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`PearMobilePhone`类，它允许使用原始充电器来充电电池，但这个类简单地被称作`charge`。请注意，这两种手机需要不同的电压来充电。
- en: So what you see here is that our universal charger will need to be adapted to
    call the `charge` method when the Pear mobile phone is plugged in and call the
    `chargeBattery` method when the SamSing mobile phone is plugged in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你在这里看到的是，我们的通用充电器在Pear手机插入时需要调用`charge`方法，而在SamSing手机插入时需要调用`chargeBattery`方法。
- en: We will have to make an adapter for each mobile phone type that we want to be
    able to charge.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不为每种我们想要能够充电的手机类型制作一个适配器。
- en: As mentioned earlier, you should not have the source code of the `adaptee` object
    when you use the adapter pattern. The source code is provided here only for demonstration
    purposes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你使用适配器模式时，你不应该有`adaptee`对象的源代码。这里提供的源代码只是为了演示目的。
- en: Have you checked the source code of our two adaptees? I have voluntary introduced
    two new Swift keywords that I wish to present you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你检查过我们两个`adaptee`的源代码了吗？我自愿引入了两个新的Swift关键字，我想向你介绍。
- en: 'First, both classes have an enumeration of possible errors that the charger
    can handle. The SamSing will throw an error if the voltage is too high or too
    low; the Pear model can throw the same errors and can throw another one if there
    is absolutely no power when it is plugged to the charger. As mentioned in the
    documentation, in Swift, errors are represented by values of type conforming to
    the `ErrorType` protocol. This is the reason why you see each enumeration implementing
    the `ErrorType` protocol:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这两个类都有一个可能的错误枚举，充电器可以处理。如果电压过高或过低，SamSing将抛出一个错误；Pear型号可以抛出相同的错误，如果手机插入充电器时完全没有电，它还可以抛出另一个错误。如文档中所述，在Swift中，错误由符合`ErrorType`协议的类型值表示。这就是为什么每个枚举都实现了`ErrorType`协议的原因：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Having this enumeration is not sufficient; we need to handle errors when the
    `charge` method is called. For this, we need to tell the method to throw an exception.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这个枚举是不够的；我们需要在调用`charge`方法时处理错误。为此，我们需要告诉方法抛出一个异常。
- en: 'For this, we simply add the `throw` keyword just before we define the return
    type, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们只需在定义返回类型之前简单地添加`throw`关键字，如下所示：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember that this function definition is exactly the same as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个函数定义与以下定义完全相同：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not providing the return type is equivalent to stating that the return type
    is of the type `Void`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不提供返回类型相当于声明返回类型是`Void`类型。
- en: 'Well, once our method is informed that it can handle errors, we still have
    to raise an error when it is necessary to do so. We make some conditional checks
    at the beginning of the method, and if something goes wrong, it throws an exception.
    To raise an exception, we simply use the `throw` keyword just before the `ErrorType`
    object (implementing the ErrorType protocol) that we want to raise. (Here is a
    `VoltageError`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，一旦我们的方法被告知它可以处理错误，我们仍然需要在必要时引发错误。我们在方法开始处进行一些条件检查，如果出现问题，就抛出异常。要引发异常，我们只需在想要引发的（实现ErrorType协议的）`ErrorType`对象之前使用`throw`关键字。（这里是一个`VoltageError`）：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As mentioned earlier, the `PearMobilePhone` class raises an error; this is when
    the method receives `0` voltage from the charger. In this case, the `PearVoltageError.NoPower`
    value of the `PearVoltageError` enumeration type will be raised.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`PearMobilePhone`类会引发错误；这是当方法从充电器接收`0`电压时。在这种情况下，`PearVoltageError.NoPower`的`PearVoltageError`枚举类型值将被引发。
- en: 'Let''s investigate the `charge` method of the `PearMobilePhone` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查`PearMobilePhone`类的`charge`方法：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We see that the two `if` statements check whether the voltage is, superior
    to 5.5 volts in the first case, and inferior to 5.5 volts in the second case.
    Each of these `if` statements can throw an error: `TooHigh` or `TooLow`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，两个`if`语句检查电压是否在第一种情况下高于5.5伏，在第二种情况下低于5.5伏。每个`if`语句都可以抛出一个错误：`TooHigh`或`TooLow`。
- en: 'Now, let''s check how the `NoPower` error is raised:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查如何引发`NoPower`错误：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This statement introduces the new Swift 2 keyword, `guard … else {`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句引入了Swift 2的新关键字`guard … else {`。
- en: The `guard` statement is like an `if` statement. It executes statements depending
    on the Boolean value of an expression. The condition must be true for the program
    to continue after the `guard` statement. A `guard` statement always has an `else`
    clause. The statement in this clause is executed if the expression is not true.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`语句类似于`if`语句。它根据表达式的布尔值执行语句。在`guard`语句之后，程序必须继续执行的条件必须为真。`guard`语句始终有一个`else`子句。如果表达式不为真，则执行该子句中的语句。'
- en: The `guard` statement allows you to perform an early exit when checking conditions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`语句允许你在检查条件时执行早期退出。'
- en: 'Something that I really like about `guard` is to be able to use it as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢`guard`能够这样使用：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With an earlier version of Swift, you would have written something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift的早期版本中，你会写类似这样的事情：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, come back to our pattern. We have seen that our two mobile phones don''t
    have the same interface, and we now need to create an adapter for each of them,
    as shown in the following diagram:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们的模式。我们已经看到我们的两个手机接口不同，我们现在需要为每个手机创建一个适配器，如下面的图所示：
- en: '![Implementation of our adaptees](img/4852_04_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![我们适配器的实现](img/4852_04_07.jpg)'
- en: Implementation of the SamSingAdapter class
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SamSingAdapter类的实现
- en: 'In the preceding diagram, we can now code our new adapter that will be able
    to work with the SamSing mobile phone as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们现在可以编写我们的新适配器，使其能够与SamSing手机一起工作，如下所示：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a new `SamSingAdapter` class that implements `ChargeableProtocol`.
    We need to provide a `charge` method that takes the voltage as an argument.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`SamSingAdapter`类，该类实现了`ChargeableProtocol`。我们需要提供一个`charge`方法，该方法接受电压作为参数。
- en: We add a constant called `samSingPhone` that instantiates a `SamSingMobilePhone()`
    object, which we will use to call its own `chargeBattery` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`samSingPhone`的常量，它实例化了一个`SamSingMobilePhone()`对象，我们将使用它来调用其自己的`chargeBattery`方法。
- en: We pass `SamSingMobilePhone` as an argument to the constructor of the adapter
    to get a reference to the mobile that we want to charge. Then, we implement the
    code of the charge method. (Remember that this is the only method that the client
    knows.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`SamSingMobilePhone`作为参数传递给适配器的构造函数，以获取我们想要充电的手机的引用。然后，我们实现`charge`方法的代码。（记住，这是客户端知道的唯一方法。）
- en: Once again, I want to show you some new things that appear with Swift 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我想向你展示一些Swift 2带来的新特性。
- en: Swift 2 introduces the `do`, `try`, `catch`, and `throw` mechanisms. We already
    discussed the `throw` statement when we discovered our two `Adaptee` classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2引入了`do`、`try`、`catch`和`throw`机制。当我们发现我们的两个`Adaptee`类时，我们已经讨论了`throw`语句。
- en: 'A method that has the `throw` keyword in its definition is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中包含`throw`关键字的`方法`如下：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It must be called using the `try` statement, as this is designed to be clear
    for developers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须使用`try`语句调用，因为这个设计是为了让开发者更清晰：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `_` symbol is a wildcard because the `chargeBattery` method of the SamSing
    mobile doesn''t return any value (in fact, it returns `Void`). It is useless to
    write such a statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`符号是一个通配符，因为SamSing手机上的`chargeBattery`方法不返回任何值（实际上，它返回`Void`）。写这样的语句是没有用的：'
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because you want to handle errors that can be thrown by the `chargeBattery`
    method, this statement must be inside a `do { } catch` block:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您想处理`chargeBattery`方法可能抛出的错误，所以这个语句必须在一个`do { } catch`块内：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, in the `do` block, you''ll add the called method that might throw an error,
    and if you want to handle it, you can catch it in the `catch` blocks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`do`块中，您将添加可能抛出错误的调用方法，如果您想处理它，可以在`catch`块中捕获它：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `catch` statement will silence all errors and the code will continue to
    run. If you want to know more about error handling with Swift 2, I recommend that
    you check out the following website:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`语句将静默所有错误，代码将继续运行。如果您想了解更多关于Swift 2中错误处理的信息，我建议您查看以下网站：'
- en: '[https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch](https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch](https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch)。'
- en: Our `SamSingAdapter` class is now ready. We will now do the same with the `PearAdapter`
    class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SamSingAdapter`类现在已经准备好了。我们现在将对`PearAdapter`类做同样的事情。
- en: Implementation of the PearAdapter class
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PearAdapter类的实现
- en: 'We will proceed in the same way as the `SamSingAdapter` class but with the
    Pear mobile phone:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照`SamSingAdapter`类的方式继续进行，但使用Pear手机：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the main differences are that we now have a reference to a `PearMobilePhone`
    object and our `charge` method (that implements `ChargeableProtocol`) calls the
    `pearMobilePhone.charge` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，主要的不同之处在于我们现在有一个`PearMobilePhone`对象的引用，并且我们的`charge`方法（实现了`ChargeableProtocol`）调用`pearMobilePhone.charge`方法。
- en: We also need to manage the voltage sent to the phone. An adapter must transform
    any value to conform to the interface of the adaptee. If we send a very high voltage,
    our mobile phone will burn and our customers will stop buying our products. So,
    in our adapter, we set the voltage value sent to the Pear mobile phone to 5.5
    volts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要管理发送到手机的电压。适配器必须将任何值转换为适配对象接口的规范。如果我们发送过高的电压，我们的手机会烧毁，我们的客户将停止购买我们的产品。因此，在我们的适配器中，我们将发送到Pear手机的电压值设置为5.5伏。
- en: We also catch all the errors that can be thrown by the `charge` method of the
    `pearMobilePhone` object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还捕获了`pearMobilePhone`对象的`charge`方法可能抛出的所有错误。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift 2 requires an exhaustive `try`/`catch` error handling. The last `catch`
    statement is our default catch-all block.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2要求详尽的`try`/`catch`错误处理。最后的`catch`语句是我们的默认捕获所有错误的块。
- en: As we have set the value to 5.5 volts, which is the only voltage accepted by
    the Pear mobile phone, we will never raise an error, so it is quiet unreadable
    to have so many catch blocks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将电压值设置为5.5伏，这是Pear手机唯一接受的电压，所以我们永远不会引发错误，因此拥有如此多的捕获块是难以阅读的。
- en: 'Well, Apple proposes an alternative to you. You can write our adapter like
    this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，苹果为您提供了一个替代方案。您可以这样编写我们的适配器：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `try!` method allows you to avoid using `do`/`catch` because you are promising
    that the call will never fail.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`try!`方法允许您避免使用`do`/`catch`，因为您承诺调用永远不会失败。'
- en: We have our universal charger, already ready, two adapters, and two mobile phones
    to test our charger. Remember that our charger provides 10 volts by default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了现成的通用充电器，两个适配器和两部手机来测试我们的充电器。请记住，我们的充电器默认提供10伏。
- en: 'Let''s write our simple test program in the `main.swift` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`main.swift`文件中编写我们的简单测试程序：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I don't think that I need to provide you with more details as the complete code
    is mentioned here. We prepare our charger, take the first phone, use an appropriate
    adapter, and then plug the adapter (which is plugged in to our phone too) to the
    charger. We do the same with the second phone.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我不需要提供更多细节，因为完整的代码已经在这里提到了。我们准备我们的充电器，拿起第一部手机，使用适当的适配器，然后将适配器（它也连接到我们的手机）插入充电器。我们对第二部手机也做同样的事情。
- en: 'Let''s run the code and check our result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码并检查我们的结果：
- en: '![Implementation of the PearAdapter class](img/4582_04_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![PearAdapter类的实现](img/4582_04_08.jpg)'
- en: Well, it doesn't matter what the mobile is; using our appropriate adapter, by
    default, the charger will send 10 volts, to the adapter, then the adapter will
    transform this voltage (or not) and call the appropriate charge method on the
    phone itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，不管手机是什么型号；使用我们适当的适配器，默认情况下，充电器会将10伏电压发送到适配器，然后适配器将转换这种电压（或不会转换）并在手机本身上调用适当的充电方法。
- en: This concludes the discovery of the adapter pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了适配器模式的发现。
- en: The facade pattern
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门面模式
- en: The facade pattern is a simple pattern used to group the interfaces of a group
    of objects and a unified interface that is easier to use by a client.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式是一种简单的模式，用于将一组对象的接口和易于客户端使用的统一接口组合在一起。
- en: Roles
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: 'The facade pattern allows you to provide the operations that might be desirable
    by a user. The pattern encapsulates the interface of each object that is considered
    as a low-level interface. To construct the unified interface, we might need to
    implement some methods that will compose the low-level interfaces:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式允许你提供用户可能需要的操作。该模式封装了每个被视为低级接口的对象的接口。为了构建统一接口，我们可能需要实现一些方法，这些方法将组合低级接口：
- en: It must be used to provide a simple interface of a complex system. The architecture
    of the system can be composed of several small classes that allow great modularity,
    but clients don't need such properties. They only need something simple that meets
    to their needs.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须用来提供一个复杂系统的简单接口。系统的架构可以由几个小型类组成，这些类允许极大的模块化，但客户端不需要这些属性。他们只需要满足他们需求的东西。
- en: It can be used to divide the system into subsystems. The façade will be an interface
    that allows the communication between subsystems.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用来将系统划分为子系统。门面将成为子系统之间通信的接口。
- en: It can be also used to encapsulate the implementation of a system toward an
    external consumer.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还可以用来封装系统对外部消费者的实现。
- en: Design
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The facade pattern is designed to hide the complexity of a system. Its interface
    can be entirely new. It must not conform to the existing interface. We can provide
    several facades to the same system depending on the end user that we have and
    the functionality that we want to provide to the facade:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式旨在隐藏系统的复杂性。它的接口可以是全新的。它必须不符合现有接口。我们可以根据我们拥有的最终用户和想要提供给门面的功能，为同一系统提供几个门面：
- en: '![Design](img/4852_04_09.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_04_09.jpg)'
- en: Participants
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of this pattern are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的参与者如下：
- en: Facade and its interface are the abstract parts of the system that are exposed
    to the clients. This class has some references to classes and components that
    are part of the system, and they have their methods used by the facade to implement
    the unified interface.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面及其接口是系统暴露给客户端的抽象部分。此类包含对系统内其他类和组件的引用，它们使用门面实现统一接口的方法。
- en: The classes and components of the system implement the functionalities of the
    system and answer requests coming from the facade. They do not need the facade
    to be able to work.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的类和组件实现系统的功能，并响应来自门面的请求。它们不需要门面就能工作。
- en: Collaboration
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: Clients communicate with the system through the facade façade. Then, the façade
    itself invokes classes and components of the system. The facade doesn't only send
    requests to classes and components of the subsystem. It must also adapt its own
    interface to the objects and components interfaces, using a specific code to allow
    communication of objects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过门面与系统通信。然后，门面本身调用系统的类和组件。门面不仅向子系统中的类和组件发送请求。它还必须使用特定的代码将自己的接口适配到对象和组件接口，以允许对象通信。
- en: 'The following sequence diagram describes this case:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列图描述了这种情况：
- en: '![Collaboration](img/4852_04_10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![协作](img/4852_04_10.jpg)'
- en: Clients using the facade should not directly access the objects of the system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用门面的客户端不应直接访问系统的对象。
- en: Illustration
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: We want to provide a simple interface to provide our clients with an easy way
    to find hotels near an input address and corresponding to some criteria (such
    as the number of stars.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供一个简单的接口，让我们的客户端能够轻松地找到输入地址附近的酒店，并符合某些标准（如星级数量。）
- en: In our company, we have a subsystem that provides a catalog of hotels that includes
    their locations and number of stars for each of them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们公司，我们有一个子系统，它提供包含每个酒店位置和星级的酒店目录。
- en: 'We already have a FindPoi Webservice that can search for a hotel near a location
    point (latitude and longitude), which uses some criteria: the maximum distance
    to search and the numbers of stars we want.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个可以搜索位置点（纬度和经度）附近的酒店的`FindPoi` Web服务，它使用一些标准：搜索的最大距离和我们想要的星级数量。
- en: As you can see, the service needs a location point, which means that we pass
    an object with a latitude and longitude.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务需要一个位置点，这意味着我们传递一个包含纬度和经度的对象。
- en: As the consumer of our facade will only tell us its real address, we need services
    that will geocode the address to a GPS point with a latitude and longitude.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们建筑立面的消费者只会告诉我们其实际地址，我们需要能够将地址地理编码到具有纬度和经度的GPS点的服务。
- en: 'The sequence diagram shows you what we will do to provide our simplified interface:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 序列图显示了我们将如何提供简化的接口：
- en: '![Illustration](img/4852_04_11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![插图](img/4852_04_11.jpg)'
- en: Open the Xcode project called `FacadePattern` and the `main.swift` file. This
    file represents a client that will consume our facade.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开名为`FacadePattern`的Xcode项目以及`main.swift`文件。此文件代表一个将消费我们的立面的客户端。
- en: 'Our facade is, in fact, a service that allows a client to search for a hotel
    near the location that is sent as an input that has two criteria: `distanceMax`
    and number of stars for the hotel.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的立面实际上是一个服务，允许客户端搜索输入位置附近的酒店，该输入有两个标准：`distanceMax`和酒店的星级数量。
- en: 'This is how the service will be called:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务将被调用的方式：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The complete code of the client is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的完整代码如下：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We open a connection for our `ServiceFindHotelNearBy` service. We tell what
    our current address is and then display the results if any. Here, we have 125
    results (from 1,000 generated in the `HotelCatalog` object):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`ServiceFindHotelNearBy`服务打开一个连接。我们告诉我们的当前地址，然后显示结果（如果有）。在这里，我们有125个结果（来自`HotelCatalog`对象中生成的1,000个结果）：
- en: '![Illustration](img/4582_04_12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![插图](img/4582_04_12.jpg)'
- en: Implementation of the facade
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象实现
- en: 'Based on the sequence diagram and method of the service consumed by the client,
    the facade called `ServiceFindHotelNearBy` in our sample project will have the
    following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 根据序列图和客户端使用的服务方法，我们样本项目中的`ServiceFindHotelNearBy`立面将具有以下代码：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The facade is well-described as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 立面可以这样描述：
- en: 'First, we make a connection to all the needed systems: the `Geocoding`, `FindPoi`,
    and `SystemHotelCatalog` Webservices (our subsystems).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们连接到所有需要的系统：`Geocoding`、`FindPoi`和`SystemHotelCatalog` Web服务（我们的子系统）。
- en: Then, we orchestrate our calls based on the sequence diagram.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们根据序列图编排我们的调用。
- en: We first geocode the address into a GPS point.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将地址地理编码到一个GPS点。
- en: Then, we get `allHotels` from the `systemHotelCatalog` object (which represent
    a subsystem) because we need to send it as an argument to the `FindPoi` service.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们从`systemHotelCatalog`对象（代表一个子系统）中获取`allHotels`，因为我们需要将其作为参数传递给`FindPoi`服务。
- en: This is what we need to do in our next statement. We need to pass the `distanceMax`
    value, number of stars value, and GPS point we just geocoded as arguments of the
    `findPoiNearBy` method of the `FindPoi` service.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们下一个语句中需要做的事情。我们需要将`distanceMax`值、星级数量值和刚刚地理编码的GPS点作为`FindPoi`服务的`findPoiNearBy`方法的参数传递。
- en: Then, we return the results to the client.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将结果返回给客户端。
- en: As you can see, the facade has encapsulated all the needed calls to the subsystem,
    hiding the complexity of retrieving hotels corresponding to the wishes of the
    client. This concludes the description of the facade pattern.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，立面封装了所有必要的子系统调用，隐藏了获取符合客户愿望的酒店的复杂性。这完成了对外观模式的描述。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter concludes the discovery of the seven structural patterns. The adapter
    pattern has much more in common with the bridge pattern. The main difference is
    in the purpose of the pattern.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了对七个结构模式的发现。适配器模式与桥接模式有很多共同之处。主要区别在于模式的目的。
- en: A bridge separates an interface and its implementation, whereas an adapter changes
    the interface of an existing object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接将接口与其实现分离，而适配器则改变现有对象的接口。
- en: 'The decorator adds a functionality to an object without changing its interface
    and should be transparent to the application. For the adapter, this is not the
    case, it is not transparent from the client perspective: the adapter is the named
    implementation of the interface that a client sees, so the adapter is not hidden
    from the client.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者在不改变对象接口的情况下添加功能，并且应该对应用程序是透明的。对于适配器来说，情况并非如此，它从客户端的角度来看并不透明：适配器是客户端看到的接口的命名实现，因此适配器不会被客户端隐藏。
- en: The proxy pattern doesn't change any interface. It defines substitute objects
    for other objects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式不会改变任何接口。它为其他对象定义了替代对象。
- en: The facade pattern transforms high-level requests into low-level requests by
    communicating with other subsystems. It hides the complexity of these subsystems
    by providing a simple interface that the client can see.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式通过与其他子系统通信，将高级请求转换为低级请求。它通过提供一个简单的客户端可以看到的接口来隐藏这些子系统的复杂性。
- en: 'In the next chapter, we will start with our first three behavioral patterns:
    the `Strategy`, `State`, and `Template` methods.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从我们的前三个行为模式开始：`策略`、`状态`和`模板`方法。
