- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Structures and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spent time and effort on our resume, performing company research and building
    our developer brand. But what for? To start an interview process at a company
    we want to work for, and *get hired*!
  prefs: []
  type: TYPE_NORMAL
- en: So, now that the first step has been achieved, we will turn to our next challenge,
    passing the iOS technical interview.
  prefs: []
  type: TYPE_NORMAL
- en: The first topic to pass the iOS technical interview will cover data structures
    such as classes, structs, dictionaries, and arrays. While we could begin with
    the fundamental principles of the Swift language, that could be considered a more
    technical subject. In contrast, *data structures involve more abstract concepts*.
    Therefore, we will leave the Swift language for [*Chapter 5*](B18653_05.xhtml#_idTextAnchor163).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the basic data structures often asked about in iOS
    technical interviews. To that end, we will cover the following topics in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the importance of data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering classes and struct questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering questions about Swift array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the Codable protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing for dictionary- and set-related interview questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin, let’s take a moment to understand the significance of data
    structures and why I have chosen to start our technical discussion on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the importance of data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are the building blocks of our iOS development. In fact, data
    structures are the building blocks of many programming languages, and having a
    deep understanding in that area is the key to success in development and, therefore,
    passing an iOS interview.
  prefs: []
  type: TYPE_NORMAL
- en: What are considered to be data structures? Well, classes, structs, arrays, dictionaries,
    and sets are all examples of data structures.
  prefs: []
  type: TYPE_NORMAL
- en: But what precisely makes data structures so important? Here are a couple of
    reasons why data structures are an integral part of an iOS interview. Let’s list
    them before we go over some interview questions.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We always have shortages and constraints when we discuss resources. Even though
    iOS devices have become much more powerful in the last few years, iOS development
    is no exception to the need for efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Each data structure has its own strength in terms of time and space complexity;
    therefore, it will have a different usage in our code. Sometimes, the difference
    in performance can be so significant that it can cause our app to run much slower
    on even the most powerful iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: What is “space and time complexity?”
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity refers to the amount of time required to execute an algorithm
    or solve a problem as a function of the input size. It is usually measured in
    terms of the number of basic operations performed by the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity, on the other hand, refers to the amount of memory required
    to execute an algorithm or solve a problem as a function of the input size. It
    is usually measured in terms of the amount of memory used by the algorithm to
    store data and intermediate results.
  prefs: []
  type: TYPE_NORMAL
- en: Showing a drastic knowledge gap in an interview will raise a big red flag, and
    having basic knowledge is a minimum requirement for an iOS developer, even juniors.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, let’s try to change the book atmosphere – not everything is red
    flags, and we can even earn points in an interview. Modularity is one example.
  prefs: []
  type: TYPE_NORMAL
- en: Making our code modular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Call me a “super-geek,” but I think a great use of data structures is making
    our code look like a piece of art. Modularity is perhaps the best example of an
    artistic code.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures provide a way to organize and encapsulate our code, making it
    easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Developers who follow my online content already know that I’m a big fan of the
    **single responsibility principle**, which is part of SOLID set of principles.
    This principle states that each module, function, class, or even variable should
    have its one and only one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: About SOLID principles
  prefs: []
  type: TYPE_NORMAL
- en: SOLID is an acronym for a set of principles in object-oriented programming that
    help to design more maintainable, scalable, and reusable code. The SOLID principles
    were introduced by Robert C. Martin in his paper *Design Principles and Design
    Patterns* in the early 2000s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The five SOLID principles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Single Responsibility Principle** (**SRP**): A class should have only one
    reason to change'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Open-Closed Principle** (**OCP**): Software entities should be open for
    extension but closed for modification'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Liskov Substitution Principle** (**LSP**): Subtypes should be substitutable
    for their base types'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Interface Segregation Principle** (**ISP**): Clients should not be forced
    to depend on interfaces they do not use'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Dependency Inversion Principle** (**DIP**): High-level modules should not
    depend on low-level modules; both should depend on abstractions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ve got an `Employee` class with two responsibilities – the first is to *store*
    the employee’s personal data, and the second is to *calculate* the payroll.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with the basics – this is not a piece of code you want your interviewer
    to see, as it mixes two responsibilities in one class. It is much better to take
    the `calculatePayroll()` function and move it to a separate class named `Payroll`
    (for example).
  prefs: []
  type: TYPE_NORMAL
- en: The reason why code separation is essential is that we understand that having
    control of what’s happening in our code is crucial. If a class or a struct has
    more responsibilities, it can create a side effect that may lead to other issues.
  prefs: []
  type: TYPE_NORMAL
- en: We always need to explain (to the interviewer and ourselves) the goal of the
    class or the function we just wrote, what its role is in the design pattern we
    chose, and do the same thing for methods and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Modular code is not only for logic separation – it also plays a significant
    role in my next point, which is reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do I need to explain the importance of code reuse?
  prefs: []
  type: TYPE_NORMAL
- en: But just in case, when writing code that can be used in different places, code
    reuse can prevent bugs and inconsistent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse in data structures refers to the reuse of both logic and data. This
    can include using classes and structs to reuse logic and data structures, such
    as arrays and dictionaries, to store and access data in a reusable manner.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s where code reusability relates to the previous point of modularity
    – if a data structure has one responsibility, it is easier to reuse, as there
    are no side effects that can prevent us from using that code in other places.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of code reuse in data structures is *class inheritance*. When
    we create a subclass, we can use all the superclass code.
  prefs: []
  type: TYPE_NORMAL
- en: In general, interviewers love to see reusable code, as it makes our code more
    effective and less error-prone. A data structure can also make our code less error-prone
    in another way, which is an API and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using data structures for an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another excellent usage for the data structure is for an **API** and interfaces.
    We should think of a data structure as a way to represent an entity or some other
    complex data collection. Creating API interfaces between the different components
    in our code is much easier if you think of it that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at what it means in code by writing a `sendPersonToServer()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `sendPersonToServer()` function’s goal is to send a person’s details to
    the server, but we can easily see the main problem here. First, we need to provide
    a long list of parameters, which is very inconvenient. But, much more importantly,
    it looks like all the parameters together *can be encapsulated* into a data structure
    that we can call – `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the function interface looks once we extract it to a `Person`
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It’s much more elegant, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: It looks like the interface for `sendPersonToServer()` function is much clearer
    now but also more consistent. Whenever we add a new variable to `Person`, we won’t
    have to update our functions header anymore because it is now capsulated within
    the struct definition.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why interviewers often appreciate seeing solutions that involve the reuse
    of functions and API interfaces when discussing potential strategies.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the importance of data structures – we mentioned efficiency, modularity,
    reusable code, and interfaces. My main goal was to provide you with a knowledge
    infrastructure to help you build your answers during the interview.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s review some interview questions about data structure, starting with
    *classes* and *structs*!
  prefs: []
  type: TYPE_NORMAL
- en: Answering classes and struct questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the umbrella of data structures, classes, and struct questions are probably
    the most basic forms we use in our projects. The reason is that not only do classes
    and structs contain data, but they also provide the main logic of the app and
    the objects they represent.
  prefs: []
  type: TYPE_NORMAL
- en: When Apple announced Swift, they constantly pushed using structs over classes
    in many cases. The trend became even more extreme when **SwiftUI** was announced,
    which was based solely on structs over classes. So, it goes without saying why
    classes and struct questions play a significant role in iOS interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move to the first and the most popular question – classes versus structs.
  prefs: []
  type: TYPE_NORMAL
- en: “What’s the difference between a class and a struct?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: A class and a struct have many features in common – they are both used to define
    complex data types, **methods**, and **properties**.
  prefs: []
  type: TYPE_NORMAL
- en: “Functions” or “methods?”
  prefs: []
  type: TYPE_NORMAL
- en: Having a job interview in iOS development means that we need to be professional.
    As part of being professional, terminology is crucial, so it is important to distinguish
    between a function and a method. A function is a code block that performs a specific
    task and can be called from anywhere in the program. In contrast, a “method” is
    a function that is associated with a class or a struct.
  prefs: []
  type: TYPE_NORMAL
- en: However, classes and structs also have some significant differences that influence
    our choice when approaching a problem we want to solve.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main differences between classes and structs:'
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is that *classes are reference types*, while structs are
    *value types*. This means that when we pass an object that is based on a class
    to a function or another instance, we are actually working and modifying the original
    instance because the object we passed is just a reference. That’s not the case
    with structs – whenever we pass a struct to a function, we work with a copy of
    that struct, not the original one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result of the code will be `Avi`, and then `John`. However, if we declare
    `A` as a class, the results would be `John` and `John` because it’s a reference
    to the original variable.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is the fact that *we can inherit classes*, and by that, we
    mean we can derive a class from another class, including properties and methods.
    Structs cannot be derived from another struct (or class, for that matter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last difference is **mutability**. Because a struct is a value type, we
    cannot change its properties if we mark it as **let**. That’s not the case with
    a class – if a class is marked as **let**, we can still mutate its properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code will raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we change `A` to a class, that will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, let’s clear up something – there’s no such thing as “better”
    in topics such as data structures. There’s always a trade-off; we should emphasize
    that fact in our interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to the next question.
  prefs: []
  type: TYPE_NORMAL
- en: “Which is better, a class or a struct?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: To thoroughly impress the interviewer, it is essential to not only be able to
    distinguish between a struct and a class, but also to demonstrate an understanding
    of when it is appropriate to use each data structure in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier in this chapter, structs and classes have different
    features, so their use cases are also different. This is a more practical question
    than just knowing the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Both are great data structures for different purposes. It’s a good idea to start
    with a struct and see whether it meets our needs. If we need additional capabilities,
    we can change it to a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should use a class if we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use it as a *reference* type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inherit* from another class (such as subclassing **UIViewController**, for
    example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should use a struct if need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass it between *threads*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize *performance*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to state that there’s no such thing as “better” without context.
    It is all based on the use cases and the requirements of our code.
  prefs: []
  type: TYPE_NORMAL
- en: “Why are structs faster than classes?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question may not be meaningful on its own, but interviewers like to ask
    it because they want to check how deeply the candidate understands how structs
    and classes are stored in a device’s memory. Knowing the answer to that question
    or even explaining the difference in other cases can give us points on our interview
    scoreboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Structs are faster than classes because of the way *they are stored in memory*.
    Structs are value types; therefore, they are stored in the **stack**, which also
    stores local variables and function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, classes are reference types, and they are stored indirectly
    in the **heap**. The heap is used to store dynamically allocated objects.
  prefs: []
  type: TYPE_NORMAL
- en: The stack is faster than the heap because it is organized more predictably,
    and I/O operations are performed faster.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to say that the performance difference is not significant. We
    should first choose the proper data structure according to our needs. Only if
    we encounter performance issues should we consider optimizing it.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and structs are extremely important topics in iOS development. We meet
    these data structures daily, and knowing them well is crucial to writing compelling
    and great code.
  prefs: []
  type: TYPE_NORMAL
- en: But in coding, data structures are often created upon other data structures.
    That’s the case with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make sure we have a complete understanding of how arrays work in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Answering questions about Swift array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike many other data structures, arrays are considered tricky. On the one
    hand, arrays are great to store a collection of data and are valuable in many
    widespread use cases, such as managing lists of objects and entities. On the other
    hand, we need to know their strengths and weakness to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Interviewers like to ask questions about arrays that check our more profound
    knowledge about how they work internally.
  prefs: []
  type: TYPE_NORMAL
- en: Questions such as, “*How do you declare an array?*” are not that common because
    it is given that an iOS developer knows how to create an array.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are exciting interview questions about arrays?
  prefs: []
  type: TYPE_NORMAL
- en: Usually, questions about arrays focus on pros and cons, memory management, and
    data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the advantages.
  prefs: []
  type: TYPE_NORMAL
- en: “Please list the Swift array advantages”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Swift arrays have several advantages that make them useful. If a developer is
    unaware of these advantages, an array might not be the correct data structure
    to use. It’s essential to remember that for every advantage, there may also be
    a disadvantage.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several advantages to arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy element access by index**: Elements can be retrieved or modified quickly
    by providing the index number of the desired element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type-safety**: An array can hold only an element from a pre-defined type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in operations**: Arrays have many actions, such as adding, removing,
    filtering, sorting, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, questions such as these are the foundation for many more to follow,
    such as “*What are the use cases for arrays?*” or “*List the disadvantages of
    arrays.*” Diving into the material can help prepare you for any unexpected surprises.
  prefs: []
  type: TYPE_NORMAL
- en: “How to remove duplicates from an array?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `Set` data structure, a Swift array can contain duplicate items.
    The question tests our ability to manipulate an array of data and discuss the
    solution with the interviewer. There are several ways to solve that, and showing
    some of them will give the interviewer the feeling that we can manipulate the
    data from different directions.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #1'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to remove duplicate elements is to convert the array to `Set`
    and then back to the array. `Set` is a data structure that cannot contain duplicates,
    and converting the array to `Set` removes these duplicates. Let’s see that in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This simple and elegant code snippet will work great! But for some interviewers,
    doing that may seem like “cheating.”
  prefs: []
  type: TYPE_NORMAL
- en: Remember that converting to a `Set` may *disrupt the order* of the items, so
    if the order is important, this may not be the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: So, it is better to make clear that we have additional solutions to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #2'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another solution would be to build a new array and add items only if they do
    not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While this solution will work, it is considered a **brute-force** solution.
  prefs: []
  type: TYPE_NORMAL
- en: What is a “brute force” solution?
  prefs: []
  type: TYPE_NORMAL
- en: A brute-force solution is an algorithm that relies on sheer computational power
    to solve a problem rather than using a cleverer approach. This can often be a
    simple and straightforward approach, but it can also be very time-consuming and
    may not be the most efficient solution for more significant problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make the loop more efficient is to use `Set` to check whether the
    item already exists, instead of using `array.contains()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the array’s `contains` method, the `contains` method of `Set` has an
    average time complexity of `O(1)`, which would improve our answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #3'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more elegant way is to use the array’s **filter** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Generally, we should always prefer the filter method over looping elements.
    The filter method is easier to read and more efficient because of native optimizations
    of the Swift language (we don’t need to get into details during the interview,
    even though I admit it is fascinating).
  prefs: []
  type: TYPE_NORMAL
- en: “How do you implement a queue using an array?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple question if we know what a **queue** means in computer science
    and the basic array manipulation methods.
  prefs: []
  type: TYPE_NORMAL
- en: These are the reasons why this question is relatively popular. It demonstrates
    our understanding of the basic concepts of a queue and the general trade-offs
    when using an array for that task.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: To create a queue using an array, we should start by creating a `Queue` struct
    with basic methods, such as `isEmpty`, `count`, `enqueue`, and `dequeue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Queue` struct contains an underline array, and we can use the `append`
    and `removeFirst` array methods to execute the queue’s basic functionality. Let’s
    see an example of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Don’t be scared. There’s no need to memorize that solution!
  prefs: []
  type: TYPE_NORMAL
- en: The best thing to do is improve our understanding of queues and remember the
    `append()` and `removeFirst()` array methods.
  prefs: []
  type: TYPE_NORMAL
- en: It is better to practice once or twice to ensure we nail this question the first
    time.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you create a new array by mapping the elements of an existing array
    in Swift?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from searching arrays, an iOS developer also needs to know how to manipulate
    and transform data from one data structure to another. This capability is not
    only for arrays but also dictionaries and sets.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming or mapping data is a common practice in development, especially
    in the world of **combine** and **reactive programming**.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `map` method to map an array to a new one. The map method takes
    a closure as an argument and, for each element, returns a new value. That way,
    the map method produces a new array with new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a basic map method that takes an array of integers and returns a
    new array by doubling its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After the loop has ended, the array contains the [2, 4, 6, 8, 10] values.
  prefs: []
  type: TYPE_NORMAL
- en: 'An even more elegant way to use a map is with a Swift feature called **implicit
    closure parameter syntax**. Using that feature, we can create even shorter and
    more readable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`$0` represents the first argument in the closure, and there’s no need for
    the `return` keyword, making the statement look even shorter!'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that arrays are fundamental in Swift and iOS development, playing
    a major in data storage, states, API interfaces, and many more cases where we
    need to handle collections. Manipulating arrays elegantly and efficiently is something
    that interviewers like to test!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are done with simple data structures and will move on to serialize them
    with Codable.
  prefs: []
  type: TYPE_NORMAL
- en: Covering the Codable protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Codable** protocol is an important Swift feature that allows us to *convert
    serialized data such as a string to a data structure* we can work with.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to know about the Codable protocol is that it combines two other
    protocols – “Encodable” and “Decodable.” These two protocols help us to convert
    data both ways.
  prefs: []
  type: TYPE_NORMAL
- en: Data objects (such as structs) need to conform to the Codable protocol so that
    we can convert them back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code block, `Person` conforms to Codable, and
    therefore, we can convert it to data in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we need to know about Codable is that all struct properties
    must conform to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example adds the `Child` property to `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the `Child` struct conforms to Codable makes the `Person` struct
    also conform to Codable.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over some questions about the Codable protocol!
  prefs: []
  type: TYPE_NORMAL
- en: “How do you handle optional properties when using the Codable protocol?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Optional properties are essential when working with Codable because it is helpful
    in cases where we need to work with APIs. Sometimes (or should I say, often),
    the returned data may not include all the properties we define in our struct.
  prefs: []
  type: TYPE_NORMAL
- en: Being familiar with how Codable works in common API use cases demonstrates your
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: To handle optional properties, we simply need to declare them as optional using
    the `?` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the `Person` struct from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that both the `address` and `age` properties are optional. If we
    don’t receive these values in an API response, they will remain nil.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if a value is not marked as optional and no default value
    is set, an exception will be thrown if the corresponding key is not present in
    the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you use CodingKeys enumeration to map the keys in a JSON object to the
    properties of a custom data type?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CodingKeys** enumeration allows us to customize the keys used in the **encoding/decoding**
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: A good answer about CodingKey shows us that we fully understand how Codable
    protocols work and can handle more complex parsing when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The way Codable maps keys to properties is by using their names. If we take
    the `Person` struct example, the `name` property will be mapped to the `name`
    key in the JSON structure because they have an identical key name.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can customize that easily using CodingKey enumeration by defining
    a custom mapping.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create `enum` under the struct that conforms to CodingKey and define
    a new mapping value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the JSON with the `full_name` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using CodingKeys helps us go through different naming between our structs and
    the data we need to parse. However, CodingKeys doesn’t help when converting one
    data type to another. In that case, we have a decoder. Let’s see an interview
    question explicitly related to that.
  prefs: []
  type: TYPE_NORMAL
- en: “How can you convert a formatted date string to a date object in Codable?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: When working with APIs, there’s no way of representing a date value other than
    with `String` or `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: If we want a struct that contains a date value, we need a way to convert the
    `Double` or `String` value to a date object.
  prefs: []
  type: TYPE_NORMAL
- en: We need to understand that these kinds of use cases are not rare.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more examples where we need to convert a value we have in a JSON
    object to another type we have in our struct. Here are some of these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a JSON value to enum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating nested objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling default values in the case of optional properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, parsing API responses is a common and important responsibility for
    iOS developers, and proficiency in this area is essential.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use several features to convert a string-based date to a date object. The
    first is CodingKey to map the keys and properties, as we learned in our previous
    question. Second, initialize the `using init(from decoder: Decoder)` struct, and
    finally, use `DateFormatter` to convert the string to a date object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. This is the `Person` properties list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the `init(from decoder:` `Decoder)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is a lengthy piece of code worth mentioning!
  prefs: []
  type: TYPE_NORMAL
- en: During an interview, it’s important to provide a detailed explanation of how
    to implement the features that were mentioned earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '`init(from:)` is called when we want to create a struct based on serialized
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: With this method, we can enter the keys container of the received data and map
    them to the struct properties. This provides us complete flexibility when parsing
    more complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: One important note about Codable before we move one is that, technically, we
    don’t “have” to use Codable in our projects. There are other solutions to parse
    and serialize objects and structs. But in modern Swift development, Codable is
    a major player in API management and data storage; therefore, it is a must topic
    for interviews, and we need to ensure we are fully prepared.
  prefs: []
  type: TYPE_NORMAL
- en: The Codable protocol is a great match for structs, yet it’s not the only option
    to manage complex data structures. Dictionaries are a flexible method of organizing
    data of diverse types and structures, and they are often utilized in interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for dictionary- and set-related interview questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries and sets are both highly effective data structures that enable
    fast storage, retrieval, and data manipulation. In particular, dictionaries offer
    the ability to store data using a key-value format, and they also serve as the
    foundation to encode and decode complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an iOS developer, there are some use cases where we can use dictionaries
    in our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick lookup**: Dictionaries are excellent to save and retrieve data quickly,
    since they use key-value to store data. This makes dictionaries ideal to save
    user accounts, lists of settings, cache data, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Counting and frequency tracking**: When the dictionary key represents the
    item’s type, and the value is the number of instances of that type, we can use
    it to track the frequency of words, items, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encoding and decoding complex data structures**: Dictionaries are so flexible
    that we can store almost any data structure. Moreover, dictionaries are in the
    form of JSON, so they are suitable to encode and decode API requests and responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration data**: The key-value nature of dictionaries makes them ideal
    to store configuration data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to think of these use cases as a basis for interview questions about dictionaries.
    Knowing the primary dictionary’s advantages and usage can easily help us pass
    dictionary-related questions.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are similar to dictionaries in the sense that they are both effective ways
    to store and retrieve data quickly. However, sets do not use the key-value structure
    as dictionaries do. Instead, they are lists of unique values that can be accessed
    with a time complexity of `O(1)`, which makes them very efficient data structures
    in so many use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it is more appropriate to compare sets to arrays. If we do not need
    our list of items to be sorted or include duplicates, sets are a superior choice
    to arrays in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like dictionaries, let’s look at some set use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing duplicates from an array**: Do you remember the example of using
    sets to remove duplicates from an array? This is a classic application of sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast membership testing**: Sets help determine whether a particular value
    has already been used. The **contains** function in sets is much more efficient
    than an array and can be helpful in many situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationships between entities**: Sets are an ideal data structure to create
    relationships between two entities, such as **User** and **Product**, because
    they do not require sorting or duplicates. This is why sets are the default choice
    for “to-many” relationships in core data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we look at some interview questions related to sets and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you use a dictionary to store configuration data?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, dictionaries are a valuable tool to store key-value
    pairs of data, and configuration data is a common use case for this data structure.
    This question involves creating a “configuration manager” class that utilizes
    a dictionary as its primary data structure and designing an interface to store
    and retrieve values from the dictionary. The task combines multiple coding skills,
    including creating a class and implementing a dictionary data structure.
  prefs: []
  type: TYPE_NORMAL
- en: And here’s a great tip!
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, as an iOS developer, this is a pattern we meet in our day-to-day
    work and, therefore, in interviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the pattern again:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Decide the data structure suitable for the task'
  prefs: []
  type: TYPE_NORMAL
- en: '- Encapsulate the data structure within a class'
  prefs: []
  type: TYPE_NORMAL
- en: '- Design and create a simple interface to work with that data structure'
  prefs: []
  type: TYPE_NORMAL
- en: Following these guidelines is the key to many answers!
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a great code example to store configuration data in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the code, we can see the three principles I mentioned – a data structure
    (dictionary), a wrapping class (`Configuration`), and an interface (`setValue()`
    and `value()`). That would be a perfect answer.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you use the filter method to select a subset of key-value pairs from
    a dictionary based on a condition?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question tests our ability to manipulate dictionary data. To do that, we
    need to accomplish two tasks – *iterate* the dictionary values and create a *new
    dictionary* for some of the values according to a condition.
  prefs: []
  type: TYPE_NORMAL
- en: This operation is helpful in many different types of programs, as it allows
    you to focus only on the key-value pairs relevant to a particular task. For instance,
    you might use it to select only the key-value pairs for students who received
    an “A” grade on a test, or only the key-value pairs for words used frequently
    in a text.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to tackle this question – the `for` loop, filtering,
    and iterating the dictionary keys.
  prefs: []
  type: TYPE_NORMAL
- en: Solution number one – the for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The for-loop solution iterates the dictionary keys and values and performs
    a simple `if-then` check to fill up a new filtered dictionary, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the syntax to iterate a dictionary using the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That will be useful in other questions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Solution number two – using the filter() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `filter` method solution is considered much *more elegant* than the `for`
    loop because it is more readable and optimized. Moreover, it combines the two
    operations (iterating and filtering) into one method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to perform the same task with a filter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Look at how much less code we used here. This is how the professionals do it!
  prefs: []
  type: TYPE_NORMAL
- en: Solution number three – looping the keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not necessary for the condition in the filter to be based on the dictionary’s
    values; it could also be found in the keys. In this case, we would need to iterate
    through the keys and apply the filter to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code filters the same dictionary, but this time, it creates a
    dictionary subset of fruits whose name starts with `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This solution allows us to perform more powerful dictionary filtering for more
    potential use cases and questions.
  prefs: []
  type: TYPE_NORMAL
- en: “What is the time complexity of common set operations, such as inserting an
    element or checking for membership?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: The **time complexity** for operations is a popular topic in data structures
    questions, mainly when we discuss sets.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with this term, it’s time to catch up! One of the decisions
    we make as iOS developers is choosing the proper data structure for the right
    task.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of using a set over an array is its operation efficiency,
    such as inserting an element and checking for membership. Therefore, we will choose
    a set when handling caching, avoiding duplicate items, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The time complexity of common set operations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an item into a set has an average time complexity of O(1) and a worst-case
    time complexity of O(n)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same goes for checking for membership – the average time complexity of O(1)
    and the worst-case time complexity of O(n)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets can have an average time complexity of O(n) in common operations because
    there are cases where a set can be clustered, and the time complexity depends
    on the size of the set.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, a set is much more efficient than an array in inserting and checking.
  prefs: []
  type: TYPE_NORMAL
- en: “Is it possible to store any type of data in a set collection in Swift?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question evaluates our comprehension of Swift’s set data structure and
    the process of hashing data types.
  prefs: []
  type: TYPE_NORMAL
- en: Working with primitive data types such as `Int` or `Double` is straightforward.
    But that’s not the case with other types, especially those we define ourselves,
    such as structs or classes.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, understanding how to use the **Hashable** protocol with a set data
    structure is crucial for iOS developers.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to store any type of data in a set collection *as long as it
    conforms to the Hashable protocol*. The Hashable protocol allows custom types
    to generate a unique value that needs to be stored in set and dictionary data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of how to store a struct named `Person` in a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It’s crucial to understand the `Hashable` protocol when working with sets and
    dictionaries in Swift, as it determines how values and keys are stored in these
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the importance of data structures and why they
    are so important in interviews. We covered structs and classes, arrays, the Codable
    protocol, sets, and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: This was a crucial chapter, and we now know so much more about data structures!
  prefs: []
  type: TYPE_NORMAL
- en: However, that was just a warmup because, in the next chapter, we will go over
    another critical topic in iOS interviews – nothing less than the Swift language
    itself.
  prefs: []
  type: TYPE_NORMAL
