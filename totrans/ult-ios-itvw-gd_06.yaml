- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Data Structures and Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构与算法
- en: We spent time and effort on our resume, performing company research and building
    our developer brand. But what for? To start an interview process at a company
    we want to work for, and *get hired*!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在简历上投入了时间和精力，进行了公司研究并建立了我们的开发者品牌。但我们为什么要这样做？为了开始我们想要工作的公司的面试流程，并且*被雇佣*！
- en: So, now that the first step has been achieved, we will turn to our next challenge,
    passing the iOS technical interview.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经迈出了第一步，我们将转向我们的下一个挑战，通过iOS技术面试。
- en: The first topic to pass the iOS technical interview will cover data structures
    such as classes, structs, dictionaries, and arrays. While we could begin with
    the fundamental principles of the Swift language, that could be considered a more
    technical subject. In contrast, *data structures involve more abstract concepts*.
    Therefore, we will leave the Swift language for [*Chapter 5*](B18653_05.xhtml#_idTextAnchor163).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过iOS技术面试的第一个主题将涵盖类、结构体、字典和数组等数据结构。虽然我们可以从Swift语言的基本原则开始，但这可能被认为是一个更技术性的主题。相比之下，*数据结构涉及更抽象的概念*。因此，我们将把Swift语言留到[*第五章*](B18653_05.xhtml#_idTextAnchor163)。
- en: 'This chapter will cover the basic data structures often asked about in iOS
    technical interviews. To that end, we will cover the following topics in this
    chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖在iOS技术面试中经常被问到的基础数据结构。为此，我们将在本章中介绍以下内容：
- en: Learning the importance of data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习数据结构的重要性
- en: Answering classes and struct questions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答类和结构体的问题
- en: Answering questions about Swift array
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答关于Swift数组的提问
- en: Covering the Codable protocol
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖Codable协议
- en: Preparing for dictionary- and set-related interview questions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备与字典和集合相关的面试问题
- en: Before we begin, let’s take a moment to understand the significance of data
    structures and why I have chosen to start our technical discussion on this topic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们花一点时间来理解数据结构的重要性以及为什么我选择从这一主题开始我们的技术讨论。
- en: Learning the importance of data structures
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习数据结构的重要性
- en: Data structures are the building blocks of our iOS development. In fact, data
    structures are the building blocks of many programming languages, and having a
    deep understanding in that area is the key to success in development and, therefore,
    passing an iOS interview.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是我们iOS开发的基石。实际上，数据结构是许多编程语言的基石，对该领域的深入理解是成功开发和因此通过iOS面试的关键。
- en: What are considered to be data structures? Well, classes, structs, arrays, dictionaries,
    and sets are all examples of data structures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是数据结构？嗯，类、结构体、数组、字典和集合都是数据结构的例子。
- en: But what precisely makes data structures so important? Here are a couple of
    reasons why data structures are an integral part of an iOS interview. Let’s list
    them before we go over some interview questions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但究竟是什么使得数据结构如此重要？以下是一些为什么数据结构是iOS面试不可或缺部分的原因。在我们讨论一些面试问题之前，让我们先列出它们。
- en: Increasing efficiency
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高效率
- en: We always have shortages and constraints when we discuss resources. Even though
    iOS devices have become much more powerful in the last few years, iOS development
    is no exception to the need for efficiency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论资源时，我们总是面临短缺和限制。尽管iOS设备在过去几年中变得更为强大，但iOS开发也不例外，需要效率。
- en: Each data structure has its own strength in terms of time and space complexity;
    therefore, it will have a different usage in our code. Sometimes, the difference
    in performance can be so significant that it can cause our app to run much slower
    on even the most powerful iPhone.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数据结构在时间和空间复杂度方面都有其独特的优势；因此，在我们的代码中会有不同的用途。有时，性能的差异可能非常显著，以至于它可以使我们的应用程序在即使是功能最强大的iPhone上也运行得非常慢。
- en: What is “space and time complexity?”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是“时间和空间复杂度？”
- en: Time complexity refers to the amount of time required to execute an algorithm
    or solve a problem as a function of the input size. It is usually measured in
    terms of the number of basic operations performed by the algorithm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度是指执行算法或解决问题所需的时间，它是输入大小的函数。它通常以算法执行的基本操作数量来衡量。
- en: Space complexity, on the other hand, refers to the amount of memory required
    to execute an algorithm or solve a problem as a function of the input size. It
    is usually measured in terms of the amount of memory used by the algorithm to
    store data and intermediate results.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，空间复杂度是指执行算法或解决问题所需的内存量，它是输入大小的函数。它通常以算法用于存储数据和中间结果的内存量来衡量。
- en: Showing a drastic knowledge gap in an interview will raise a big red flag, and
    having basic knowledge is a minimum requirement for an iOS developer, even juniors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中展示出巨大的知识差距会引发一个大红旗，而对于iOS开发者来说，即使对于初级开发者，具备基本知识也是一个最低要求。
- en: Nevertheless, let’s try to change the book atmosphere – not everything is red
    flags, and we can even earn points in an interview. Modularity is one example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们尝试改变一下书本氛围——不是所有东西都是红旗，我们甚至可以在面试中得分。模块化就是一个例子。
- en: Making our code modular
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使我们的代码模块化
- en: Call me a “super-geek,” but I think a great use of data structures is making
    our code look like a piece of art. Modularity is perhaps the best example of an
    artistic code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 叫我“超级极客”吧，但我认为数据结构的一个很好的用途是让我们的代码看起来像一件艺术品。模块化可能是艺术代码的最佳例子。
- en: Data structures provide a way to organize and encapsulate our code, making it
    easier to read and maintain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构提供了一种组织和封装我们代码的方法，使其更容易阅读和维护。
- en: Developers who follow my online content already know that I’m a big fan of the
    **single responsibility principle**, which is part of SOLID set of principles.
    This principle states that each module, function, class, or even variable should
    have its one and only one responsibility.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随我的在线内容的开发者已经知道，我是一个**单一职责原则**的大粉丝，这是SOLID原则集的一部分。这个原则指出，每个模块、函数、类，甚至变量都应该只有一个且仅有一个职责。
- en: About SOLID principles
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SOLID原则
- en: SOLID is an acronym for a set of principles in object-oriented programming that
    help to design more maintainable, scalable, and reusable code. The SOLID principles
    were introduced by Robert C. Martin in his paper *Design Principles and Design
    Patterns* in the early 2000s.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是面向对象编程中一组原则的缩写，有助于设计更易于维护、可扩展和可重用的代码。SOLID原则是由Robert C. Martin在2000年代初的论文《设计原则和设计模式》中提出的。
- en: 'The five SOLID principles are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 五个SOLID原则如下：
- en: '- **Single Responsibility Principle** (**SRP**): A class should have only one
    reason to change'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '- **单一职责原则**（**SRP**）：一个类应该只有一个改变的理由'
- en: '- **Open-Closed Principle** (**OCP**): Software entities should be open for
    extension but closed for modification'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '- **开闭原则**（**OCP**）：软件实体应该对扩展开放但对修改封闭'
- en: '- **Liskov Substitution Principle** (**LSP**): Subtypes should be substitutable
    for their base types'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '- **里氏替换原则**（**LSP**）：子类型应该是其基类型的可替换的'
- en: '- **Interface Segregation Principle** (**ISP**): Clients should not be forced
    to depend on interfaces they do not use'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '- **接口隔离原则**（**ISP**）：客户端不应该被迫依赖于它们不使用的接口'
- en: '- **Dependency Inversion Principle** (**DIP**): High-level modules should not
    depend on low-level modules; both should depend on abstractions'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '- **依赖倒置原则**（**DIP**）：高层模块不应该依赖于低层模块；两者都应依赖于抽象'
- en: 'Let’s look at the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve got an `Employee` class with two responsibilities – the first is to *store*
    the employee’s personal data, and the second is to *calculate* the payroll.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Employee`类，它有两个职责——第一个是*存储*员工的个人数据，第二个是*计算*工资。
- en: I’ll start with the basics – this is not a piece of code you want your interviewer
    to see, as it mixes two responsibilities in one class. It is much better to take
    the `calculatePayroll()` function and move it to a separate class named `Payroll`
    (for example).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从基础知识开始讲起——这不是你希望面试官看到的代码片段，因为它在一个类中混合了两种职责。将`calculatePayroll()`函数移到名为`Payroll`（例如）的单独类中会更好。
- en: The reason why code separation is essential is that we understand that having
    control of what’s happening in our code is crucial. If a class or a struct has
    more responsibilities, it can create a side effect that may lead to other issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分离之所以至关重要，是因为我们理解，控制我们代码中发生的事情是至关重要的。如果一个类或结构有更多的职责，它可能会产生副作用，导致其他问题。
- en: We always need to explain (to the interviewer and ourselves) the goal of the
    class or the function we just wrote, what its role is in the design pattern we
    chose, and do the same thing for methods and variables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是需要解释（对面试官和我们自己）我们刚刚编写的类或函数的目标，它在所选的设计模式中的作用，以及为方法和变量做同样的事情。
- en: Modular code is not only for logic separation – it also plays a significant
    role in my next point, which is reusability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化代码不仅用于逻辑分离——它还在我的下一个要点中扮演着重要的角色，那就是可重用性。
- en: Reusing our code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码的重用
- en: Do I need to explain the importance of code reuse?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要解释代码重用的重要性吗？
- en: But just in case, when writing code that can be used in different places, code
    reuse can prevent bugs and inconsistent behavior.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但以防万一，当编写可以在不同地方使用的代码时，代码重用可以防止错误和不一致的行为。
- en: Code reuse in data structures refers to the reuse of both logic and data. This
    can include using classes and structs to reuse logic and data structures, such
    as arrays and dictionaries, to store and access data in a reusable manner.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据结构中的代码重用指的是逻辑和数据的双重重用。这可以包括使用类和结构体来重用逻辑和数据结构，例如数组和字典，以可重用的方式存储和访问数据。
- en: And that’s where code reusability relates to the previous point of modularity
    – if a data structure has one responsibility, it is easier to reuse, as there
    are no side effects that can prevent us from using that code in other places.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 而这正是代码重用与先前的模块化要点相关联的地方——如果一个数据结构只有一个职责，它就更容易重用，因为没有副作用会阻止我们在其他地方使用这段代码。
- en: Another example of code reuse in data structures is *class inheritance*. When
    we create a subclass, we can use all the superclass code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构中代码重用的另一个例子是*类继承*。当我们创建一个子类时，我们可以使用所有超类代码。
- en: In general, interviewers love to see reusable code, as it makes our code more
    effective and less error-prone. A data structure can also make our code less error-prone
    in another way, which is an API and interfaces.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，面试官喜欢看到可重用代码，因为它使我们的代码更有效且更少出错。数据结构还可以以另一种方式减少我们的代码出错，那就是API和接口。
- en: Using data structures for an API
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据结构进行API设计
- en: Another excellent usage for the data structure is for an **API** and interfaces.
    We should think of a data structure as a way to represent an entity or some other
    complex data collection. Creating API interfaces between the different components
    in our code is much easier if you think of it that way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构的另一个优秀用途是用于**API**和接口。我们应该将数据结构视为表示实体或某些其他复杂数据集合的方式。如果你这样想，创建我们代码中不同组件之间的API接口会更容易。
- en: 'Let’s have a look at what it means in code by writing a `sendPersonToServer()`
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个`sendPersonToServer()`函数来看看它在代码中的含义：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `sendPersonToServer()` function’s goal is to send a person’s details to
    the server, but we can easily see the main problem here. First, we need to provide
    a long list of parameters, which is very inconvenient. But, much more importantly,
    it looks like all the parameters together *can be encapsulated* into a data structure
    that we can call – `Person`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendPersonToServer()`函数的目标是将一个人的详细信息发送到服务器，但我们很容易看到这里的主要问题。首先，我们需要提供一个很长的参数列表，这非常不方便。但更重要的是，看起来所有参数都可以封装到一个我们可以称之为的数据结构中——`Person`。'
- en: 'Let’s see how the function interface looks once we extract it to a `Person`
    struct:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一旦我们将它提取到一个`Person`结构体中，函数接口看起来会是什么样子：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s much more elegant, isn’t it?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更优雅，不是吗？
- en: It looks like the interface for `sendPersonToServer()` function is much clearer
    now but also more consistent. Whenever we add a new variable to `Person`, we won’t
    have to update our functions header anymore because it is now capsulated within
    the struct definition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`sendPersonToServer()`函数的接口现在更清晰了，也更一致。每次我们向`Person`添加一个新变量时，我们不再需要更新函数头，因为它现在被封装在结构体定义中。
- en: That’s why interviewers often appreciate seeing solutions that involve the reuse
    of functions and API interfaces when discussing potential strategies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么面试官在讨论潜在策略时，通常会欣赏看到涉及函数和API接口重用的解决方案。
- en: We discussed the importance of data structures – we mentioned efficiency, modularity,
    reusable code, and interfaces. My main goal was to provide you with a knowledge
    infrastructure to help you build your answers during the interview.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了数据结构的重要性——我们提到了效率、模块化、可重用代码和接口。我的主要目标是为你提供一个知识基础设施，帮助你面试时构建答案。
- en: Now, let’s review some interview questions about data structure, starting with
    *classes* and *structs*!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一些关于数据结构的面试问题，从*类*和*结构体*开始！
- en: Answering classes and struct questions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答类和结构体问题
- en: Under the umbrella of data structures, classes, and struct questions are probably
    the most basic forms we use in our projects. The reason is that not only do classes
    and structs contain data, but they also provide the main logic of the app and
    the objects they represent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据结构、类和结构体的范畴下，类和结构体问题可能是我们在项目中使用的最基本形式。原因是类和结构体不仅包含数据，还提供了应用的主要逻辑以及它们所代表的对象。
- en: When Apple announced Swift, they constantly pushed using structs over classes
    in many cases. The trend became even more extreme when **SwiftUI** was announced,
    which was based solely on structs over classes. So, it goes without saying why
    classes and struct questions play a significant role in iOS interviews.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当苹果宣布Swift时，他们不断强调在许多情况下使用结构体而不是类。当宣布基于结构体而非类的**SwiftUI**时，这一趋势变得更加极端。因此，不言而喻，为什么类和结构体的问题在iOS面试中扮演着重要的角色。
- en: Let’s move to the first and the most popular question – classes versus structs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到第一个也是最流行的问题——类与结构体的比较。
- en: “What’s the difference between a class and a struct?”
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “类和结构体之间的区别是什么？”
- en: '*Why is this* *question important?*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: A class and a struct have many features in common – they are both used to define
    complex data types, **methods**, and **properties**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体有许多共同特征——它们都用于定义复杂的数据类型、**方法**和**属性**。
- en: “Functions” or “methods?”
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “函数”还是“方法？”
- en: Having a job interview in iOS development means that we need to be professional.
    As part of being professional, terminology is crucial, so it is important to distinguish
    between a function and a method. A function is a code block that performs a specific
    task and can be called from anywhere in the program. In contrast, a “method” is
    a function that is associated with a class or a struct.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发中进行工作面试意味着我们需要专业。作为专业的一部分，术语至关重要，因此区分函数和方法很重要。函数是一个执行特定任务的代码块，可以从程序的任何地方调用。相比之下，“方法”是与类或结构体相关联的函数。
- en: However, classes and structs also have some significant differences that influence
    our choice when approaching a problem we want to solve.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类和结构体也有一些重要的区别，这些区别会影响我们解决问题时的选择。
- en: '*What is* *the answer?*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'There are three main differences between classes and structs:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体之间有三个主要区别：
- en: The first difference is that *classes are reference types*, while structs are
    *value types*. This means that when we pass an object that is based on a class
    to a function or another instance, we are actually working and modifying the original
    instance because the object we passed is just a reference. That’s not the case
    with structs – whenever we pass a struct to a function, we work with a copy of
    that struct, not the original one.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个区别是，*类是引用类型*，而结构体是*值类型*。这意味着当我们将基于类的对象传递给函数或另一个实例时，我们实际上是在操作和修改原始实例，因为我们传递的对象只是一个引用。结构体则不是这样——每次我们将结构体传递给函数时，我们都在处理该结构体的一个副本，而不是原始的那个。
- en: 'Have a look at the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of the code will be `Avi`, and then `John`. However, if we declare
    `A` as a class, the results would be `John` and `John` because it’s a reference
    to the original variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果将是`Avi`，然后是`John`。然而，如果我们将`A`声明为类，结果将是`John`和`John`，因为它是对原始变量的引用。
- en: Another difference is the fact that *we can inherit classes*, and by that, we
    mean we can derive a class from another class, including properties and methods.
    Structs cannot be derived from another struct (or class, for that matter).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个区别是我们*可以继承类*，这意味着我们可以从一个类派生出一个类，包括属性和方法。结构体不能从另一个结构体（或类）派生。
- en: The last difference is **mutability**. Because a struct is a value type, we
    cannot change its properties if we mark it as **let**. That’s not the case with
    a class – if a class is marked as **let**, we can still mutate its properties.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的区别是**可变性**。因为结构体是值类型，如果我们将其标记为**let**，则不能更改其属性。类则不是这样——如果类被标记为**let**，我们仍然可以修改其属性。
- en: 'The following code will raise an error:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将引发错误：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if we change `A` to a class, that will work:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将`A`改为类，那么这将有效：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before we continue, let’s clear up something – there’s no such thing as “better”
    in topics such as data structures. There’s always a trade-off; we should emphasize
    that fact in our interviews.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们澄清一下——在诸如数据结构这样的主题中，并不存在“更好”这一说法。总是存在权衡；我们应该在我们的面试中强调这一事实。
- en: Let’s now move on to the next question.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论下一个问题。
- en: “Which is better, a class or a struct?”
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “类和结构体哪个更好？”
- en: '*Why is this* *question important?*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: To thoroughly impress the interviewer, it is essential to not only be able to
    distinguish between a struct and a class, but also to demonstrate an understanding
    of when it is appropriate to use each data structure in different situations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要给面试官留下深刻印象，不仅需要能够区分结构体和类，而且还需要展示对不同情况下何时使用每种数据结构的理解。
- en: As we discussed earlier in this chapter, structs and classes have different
    features, so their use cases are also different. This is a more practical question
    than just knowing the differences.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的那样，结构体和类有不同的特性，因此它们的使用场景也不同。这是一个比仅仅知道它们之间的区别更实际的问题。
- en: '*What is* *the answer?*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**是什么** **答案**？'
- en: Both are great data structures for different purposes. It’s a good idea to start
    with a struct and see whether it meets our needs. If we need additional capabilities,
    we can change it to a class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是针对不同目的的绝佳数据结构。从结构体开始，看看它是否满足我们的需求是个好主意。如果我们需要额外的功能，我们可以将其更改为类。
- en: 'We should use a class if we need to do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要做以下事情，我们应该使用类：
- en: Use it as a *reference* type
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其用作**引用**类型
- en: '*Inherit* from another class (such as subclassing **UIViewController**, for
    example)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个类**继承**（例如，例如从**UIViewController**子类化）
- en: 'We should use a struct if need to do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要做以下事情，我们应该使用结构体：
- en: Pass it between *threads*
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**线程**之间传递
- en: Optimize *performance*
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化**性能**
- en: It is important to state that there’s no such thing as “better” without context.
    It is all based on the use cases and the requirements of our code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，没有上下文就没有“更好”这一说。一切都基于用例和我们的代码需求。
- en: “Why are structs faster than classes?”
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “为什么结构体（struct）比类（class）更快？”
- en: '*Why is this* *question important?*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么** **这个问题重要**？'
- en: This question may not be meaningful on its own, but interviewers like to ask
    it because they want to check how deeply the candidate understands how structs
    and classes are stored in a device’s memory. Knowing the answer to that question
    or even explaining the difference in other cases can give us points on our interview
    scoreboard.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题本身可能没有意义，但面试官喜欢问它，因为他们想检查候选人是否深入理解结构体和类在设备内存中的存储方式。知道这个问题的答案，甚至在其他情况下解释差异，都可以在我们的面试得分板上加分。
- en: '*What is* *the answer?*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**是什么** **答案**？'
- en: Structs are faster than classes because of the way *they are stored in memory*.
    Structs are value types; therefore, they are stored in the **stack**, which also
    stores local variables and function parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体比类更快，是因为它们在内存中的存储方式。结构体是值类型；因此，它们存储在**栈**中，栈也存储局部变量和函数参数。
- en: On the other hand, classes are reference types, and they are stored indirectly
    in the **heap**. The heap is used to store dynamically allocated objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类是引用类型，并且它们间接存储在**堆**中。堆用于存储动态分配的对象。
- en: The stack is faster than the heap because it is organized more predictably,
    and I/O operations are performed faster.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 栈比堆更快，因为它的组织更可预测，并且 I/O 操作执行得更快。
- en: It is important to say that the performance difference is not significant. We
    should first choose the proper data structure according to our needs. Only if
    we encounter performance issues should we consider optimizing it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要说明，性能差异并不显著。我们应该首先根据我们的需求选择合适的数据结构。只有当我们遇到性能问题时，才考虑对其进行优化。
- en: Classes and structs are extremely important topics in iOS development. We meet
    these data structures daily, and knowing them well is crucial to writing compelling
    and great code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体是 iOS 开发中极其重要的主题。我们每天都会遇到这些数据结构，并且对它们的深入了解对于编写引人入胜和优秀的代码至关重要。
- en: But in coding, data structures are often created upon other data structures.
    That’s the case with arrays.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但在编码中，数据结构通常是在其他数据结构之上创建的。数组就是这样。
- en: Let’s make sure we have a complete understanding of how arrays work in Swift.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们对 Swift 中数组的工作方式有一个全面的理解。
- en: Answering questions about Swift array
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答关于 Swift 数组的疑问
- en: Unlike many other data structures, arrays are considered tricky. On the one
    hand, arrays are great to store a collection of data and are valuable in many
    widespread use cases, such as managing lists of objects and entities. On the other
    hand, we need to know their strengths and weakness to use them effectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他数据结构不同，数组被认为比较棘手。一方面，数组非常适合存储数据集合，并且在许多广泛使用的情况下非常有价值，例如管理对象和实体的列表。另一方面，我们需要了解它们的优缺点才能有效地使用它们。
- en: Interviewers like to ask questions about arrays that check our more profound
    knowledge about how they work internally.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官喜欢问一些问题，以检查我们对数组内部工作原理的更深入知识。
- en: Questions such as, “*How do you declare an array?*” are not that common because
    it is given that an iOS developer knows how to create an array.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的问题，“*如何声明一个数组?*”并不常见，因为假设 iOS 开发者知道如何创建数组。
- en: So, what are exciting interview questions about arrays?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于数组的有趣面试问题有哪些？
- en: Usually, questions about arrays focus on pros and cons, memory management, and
    data manipulation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关于数组的问题集中在优缺点、内存管理和数据处理上。
- en: Let’s start with the advantages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从优点开始。
- en: “Please list the Swift array advantages”
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “请列出 Swift 数组的优点”
- en: '*Why is this* *question important?*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要?*'
- en: Swift arrays have several advantages that make them useful. If a developer is
    unaware of these advantages, an array might not be the correct data structure
    to use. It’s essential to remember that for every advantage, there may also be
    a disadvantage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组具有几个优点，使它们非常有用。如果开发者不了解这些优点，数组可能不是正确的数据结构。记住，对于每个优点，也可能存在缺点。
- en: '*What is* *the answer?*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案?*'
- en: 'There are several advantages to arrays:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有几个优点：
- en: '**Easy element access by index**: Elements can be retrieved or modified quickly
    by providing the index number of the desired element'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过索引轻松访问元素**：可以通过提供所需元素的索引号快速检索或修改元素'
- en: '**Type-safety**: An array can hold only an element from a pre-defined type'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：数组只能包含来自预定义类型的元素'
- en: '**Built-in operations**: Arrays have many actions, such as adding, removing,
    filtering, sorting, and more'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置操作**：数组有许多操作，例如添加、删除、过滤、排序等'
- en: Remember, questions such as these are the foundation for many more to follow,
    such as “*What are the use cases for arrays?*” or “*List the disadvantages of
    arrays.*” Diving into the material can help prepare you for any unexpected surprises.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，像这样的问题往往是更多问题的基石，比如“*数组的用例有哪些?*”或“*列出数组的缺点.*”深入研究材料可以帮助你为任何意外惊喜做好准备。
- en: “How to remove duplicates from an array?”
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何从数组中移除重复项？”
- en: '*Why is this* *question important?*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要?*'
- en: Unlike the `Set` data structure, a Swift array can contain duplicate items.
    The question tests our ability to manipulate an array of data and discuss the
    solution with the interviewer. There are several ways to solve that, and showing
    some of them will give the interviewer the feeling that we can manipulate the
    data from different directions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Set` 数据结构不同，Swift 数组可以包含重复项。这个问题测试了我们操纵数据数组的能力，并与面试官讨论解决方案。有几种方法可以解决这个问题，展示其中一些方法可以让面试官感觉到我们能够从不同方向操纵数据。
- en: '*What is* *the answer?*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案?*'
- en: Let’s see the possible solutions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可能的解决方案。
- en: 'Solution #1'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '解决方案 #1'
- en: 'The simplest way to remove duplicate elements is to convert the array to `Set`
    and then back to the array. `Set` is a data structure that cannot contain duplicates,
    and converting the array to `Set` removes these duplicates. Let’s see that in
    action:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 移除重复元素最简单的方法是将数组转换为 `Set`，然后再将其转换回数组。`Set` 是一种不能包含重复元素的数据结构，将数组转换为 `Set` 会移除这些重复元素。让我们看看它是如何实现的：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple and elegant code snippet will work great! But for some interviewers,
    doing that may seem like “cheating.”
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单优雅的代码片段将非常有效！但对于一些面试官来说，这样做可能看起来像“作弊。”
- en: Remember that converting to a `Set` may *disrupt the order* of the items, so
    if the order is important, this may not be the best solution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，将转换为 `Set` 可能会 *破坏项目的顺序*，所以如果顺序很重要，这可能不是最佳解决方案。
- en: So, it is better to make clear that we have additional solutions to the problem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好明确我们还有其他解决问题的方法。
- en: 'Solution #2'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '解决方案 #2'
- en: 'Another solution would be to build a new array and add items only if they do
    not exist:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是构建一个新的数组，并且只有当项目不存在时才添加：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While this solution will work, it is considered a **brute-force** solution.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案是可行的，但它被认为是一种 **暴力** 解决方案。
- en: What is a “brute force” solution?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是“暴力”解法？
- en: A brute-force solution is an algorithm that relies on sheer computational power
    to solve a problem rather than using a cleverer approach. This can often be a
    simple and straightforward approach, but it can also be very time-consuming and
    may not be the most efficient solution for more significant problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力解法是一种依赖于纯粹的计算能力来解决而不是使用更巧妙方法的算法。这通常是一种简单直接的方法，但这也可能非常耗时，并且可能不是解决更大问题的最有效方法。
- en: 'One way to make the loop more efficient is to use `Set` to check whether the
    item already exists, instead of using `array.contains()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一种使循环更高效的方法是使用 `Set` 来检查项目是否已存在，而不是使用 `array.contains()`：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unlike the array’s `contains` method, the `contains` method of `Set` has an
    average time complexity of `O(1)`, which would improve our answer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组的 `contains` 方法不同，`Set` 的 `contains` 方法的平均时间复杂度为 `O(1)`，这将提高我们的答案。
- en: 'Solution #3'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '解决方案 #3'
- en: 'A more elegant way is to use the array’s **filter** method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更优雅的方法是使用数组的 **filter** 方法：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Generally, we should always prefer the filter method over looping elements.
    The filter method is easier to read and more efficient because of native optimizations
    of the Swift language (we don’t need to get into details during the interview,
    even though I admit it is fascinating).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该始终优先选择 filter 方法而不是循环元素。filter 方法更易于阅读且更高效，因为 Swift 语言的本地优化（我们不需要在面试中深入了解，尽管我承认这很迷人）。
- en: “How do you implement a queue using an array?”
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何使用数组实现队列？”
- en: '*Why is this* *question important?*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This is a simple question if we know what a **queue** means in computer science
    and the basic array manipulation methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道在计算机科学中 **队列** 的含义以及基本的数组操作方法，这个问题就很简单。
- en: These are the reasons why this question is relatively popular. It demonstrates
    our understanding of the basic concepts of a queue and the general trade-offs
    when using an array for that task.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是为什么这个问题相对流行的原因。它展示了我们对队列基本概念的理解，以及在使用数组执行此任务时的通常权衡。
- en: '*What is* *the answer?*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: To create a queue using an array, we should start by creating a `Queue` struct
    with basic methods, such as `isEmpty`, `count`, `enqueue`, and `dequeue`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用数组创建队列，我们应该首先创建一个具有基本方法（如 `isEmpty`、`count`、`enqueue` 和 `dequeue`）的 `Queue`
    结构体。
- en: 'The `Queue` struct contains an underline array, and we can use the `append`
    and `removeFirst` array methods to execute the queue’s basic functionality. Let’s
    see an example of that:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 结构体包含一个底层数组，我们可以使用 `append` 和 `removeFirst` 数组方法来执行队列的基本功能。让我们看看一个例子：'
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don’t be scared. There’s no need to memorize that solution!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕。没有必要记住那个解决方案！
- en: The best thing to do is improve our understanding of queues and remember the
    `append()` and `removeFirst()` array methods.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是提高我们对队列的理解，并记住 `append()` 和 `removeFirst()` 数组方法。
- en: It is better to practice once or twice to ensure we nail this question the first
    time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最好练习一次或两次，以确保我们第一次就能解决这个问题。
- en: “How do you create a new array by mapping the elements of an existing array
    in Swift?”
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在Swift中通过映射现有数组的元素来创建一个新数组？”
- en: '*Why is this* *question important?*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Aside from searching arrays, an iOS developer also needs to know how to manipulate
    and transform data from one data structure to another. This capability is not
    only for arrays but also dictionaries and sets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了搜索数组之外，iOS 开发者还需要知道如何从一个数据结构到另一个数据结构的操作和转换数据。这种能力不仅适用于数组，也适用于字典和集合。
- en: Transforming or mapping data is a common practice in development, especially
    in the world of **combine** and **reactive programming**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 转换或映射数据是开发中的常见做法，尤其是在 **combine** 和 **reactive programming** 的世界中。
- en: '*What is* *the answer?*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: We can use the `map` method to map an array to a new one. The map method takes
    a closure as an argument and, for each element, returns a new value. That way,
    the map method produces a new array with new values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `map` 方法将数组映射到新数组。`map` 方法接受一个闭包作为参数，并为每个元素返回一个新值。这样，`map` 方法就产生了一个包含新值的数组。
- en: 'Let’s see a basic map method that takes an array of integers and returns a
    new array by doubling its values:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的映射方法，它接受一个整数数组，并返回一个新数组，其值是原数组的两倍：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the loop has ended, the array contains the [2, 4, 6, 8, 10] values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，数组包含 [2, 4, 6, 8, 10] 的值。
- en: 'An even more elegant way to use a map is with a Swift feature called **implicit
    closure parameter syntax**. Using that feature, we can create even shorter and
    more readable code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射的另一种更优雅的方法是使用 Swift 的一个特性，称为 **隐式闭包参数语法**。使用该特性，我们可以创建更短、更易读的代码：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`$0` represents the first argument in the closure, and there’s no need for
    the `return` keyword, making the statement look even shorter!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`$0` 代表闭包中的第一个参数，不需要使用 `return` 关键字，这使得语句看起来更加简洁！'
- en: We can see that arrays are fundamental in Swift and iOS development, playing
    a major in data storage, states, API interfaces, and many more cases where we
    need to handle collections. Manipulating arrays elegantly and efficiently is something
    that interviewers like to test!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数组在 Swift 和 iOS 开发中是基本的，在数据存储、状态、API 接口以及许多需要处理集合的其他情况下扮演着重要角色。优雅且高效地操作数组是面试官喜欢测试的内容！
- en: Now, we are done with simple data structures and will move on to serialize them
    with Codable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了简单数据结构的处理，接下来我们将使用 Codable 来序列化它们。
- en: Covering the Codable protocol
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖 Codable 协议
- en: The **Codable** protocol is an important Swift feature that allows us to *convert
    serialized data such as a string to a data structure* we can work with.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Codable** 协议是 Swift 中的一个重要特性，它允许我们将序列化数据（如字符串）转换为我们可以处理的数据结构。'
- en: The first thing to know about the Codable protocol is that it combines two other
    protocols – “Encodable” and “Decodable.” These two protocols help us to convert
    data both ways.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Codable 协议的第一件事要知道的是，它结合了两个其他协议——“Encodable”和“Decodable”。这两个协议帮助我们双向转换数据。
- en: Data objects (such as structs) need to conform to the Codable protocol so that
    we can convert them back and forth.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对象（如结构体）需要遵循 Codable 协议，这样我们才能进行双向转换。
- en: 'Here’s a simple code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的代码片段：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see in the preceding code block, `Person` conforms to Codable, and
    therefore, we can convert it to data in both directions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，`Person` 结构体遵循 Codable 协议，因此我们可以将其转换为数据，并在两个方向上进行转换。
- en: The second thing we need to know about Codable is that all struct properties
    must conform to it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Codable 的第二件事是我们需要知道，所有结构体属性都必须遵循它。
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following example adds the `Child` property to `Person`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将 `Child` 属性添加到 `Person` 结构体中：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The fact that the `Child` struct conforms to Codable makes the `Person` struct
    also conform to Codable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child` 结构体遵循 Codable 协议的事实使得 `Person` 结构体也遵循 Codable 协议。'
- en: Let’s go over some questions about the Codable protocol!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于 Codable 协议的一些问题！
- en: “How do you handle optional properties when using the Codable protocol?”
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “在使用 Codable 协议时，你是如何处理可选属性的？”
- en: '*Why is this* *question important?*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: Optional properties are essential when working with Codable because it is helpful
    in cases where we need to work with APIs. Sometimes (or should I say, often),
    the returned data may not include all the properties we define in our struct.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性在处理 Codable 时是必不可少的，因为它在需要与 API 一起工作时非常有用。有时（或者说，经常），返回的数据可能不包括我们在结构体中定义的所有属性。
- en: Being familiar with how Codable works in common API use cases demonstrates your
    understanding.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Codable 在常见 API 用例中的工作方式，可以证明你对它的理解。
- en: '*What is* *the answer?*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: To handle optional properties, we simply need to declare them as optional using
    the `?` parameter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理可选属性，我们只需将它们声明为可选，使用 `?` 参数即可。
- en: 'Let’s take the `Person` struct from the previous example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以之前示例中的 `Person` 结构体为例：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that both the `address` and `age` properties are optional. If we
    don’t receive these values in an API response, they will remain nil.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `address` 和 `age` 属性都是可选的。如果我们没有在 API 响应中收到这些值，它们将保持为 nil。
- en: On the other hand, if a value is not marked as optional and no default value
    is set, an exception will be thrown if the corresponding key is not present in
    the JSON response.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个值没有被标记为可选，并且没有设置默认值，那么如果相应的键在 JSON 响应中不存在，将会抛出异常。
- en: “How do you use CodingKeys enumeration to map the keys in a JSON object to the
    properties of a custom data type?”
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你是如何使用 CodingKeys 枚举将 JSON 对象中的键映射到自定义数据类型的属性中的？”
- en: '*Why is this* *question important?*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: '**CodingKeys** enumeration allows us to customize the keys used in the **encoding/decoding**
    process.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**CodingKeys** 枚举允许我们自定义编码/解码过程中使用的键。'
- en: A good answer about CodingKey shows us that we fully understand how Codable
    protocols work and can handle more complex parsing when needed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于 CodingKey 的好答案表明我们完全理解 Codable 协议的工作方式，并在需要时可以处理更复杂的解析。
- en: '*What is* *the answer?*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The way Codable maps keys to properties is by using their names. If we take
    the `Person` struct example, the `name` property will be mapped to the `name`
    key in the JSON structure because they have an identical key name.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Codable 将键映射到属性的方式是通过使用它们的名称。如果我们以 `Person` 结构体为例，`name` 属性将被映射到 JSON 结构中的 `name`
    键，因为它们具有相同的键名。
- en: However, we can customize that easily using CodingKey enumeration by defining
    a custom mapping.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过定义自定义映射来使用CodingKey枚举轻松地自定义它。
- en: We need to create `enum` under the struct that conforms to CodingKey and define
    a new mapping value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在符合CodingKey的结构体下创建`enum`并定义一个新的映射值。
- en: 'Look at the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s the JSON with the `full_name` key:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有`full_name`键的JSON：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using CodingKeys helps us go through different naming between our structs and
    the data we need to parse. However, CodingKeys doesn’t help when converting one
    data type to another. In that case, we have a decoder. Let’s see an interview
    question explicitly related to that.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CodingKeys可以帮助我们处理我们结构体和需要解析的数据之间的不同命名。然而，当将一种数据类型转换为另一种数据类型时，CodingKeys并不能提供帮助。在这种情况下，我们有一个解码器。让我们看看一个与这个问题直接相关的问题。
- en: “How can you convert a formatted date string to a date object in Codable?”
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在Codable中将格式化的日期字符串转换为日期对象？”
- en: '*Why is this* *question important?*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题重要？*'
- en: When working with APIs, there’s no way of representing a date value other than
    with `String` or `Double`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当与API一起工作时，除了使用`String`或`Double`之外，没有其他方式来表示日期值。
- en: If we want a struct that contains a date value, we need a way to convert the
    `Double` or `String` value to a date object.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个包含日期值的结构体，我们需要一种方法将`Double`或`String`值转换为日期对象。
- en: We need to understand that these kinds of use cases are not rare.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解这些类型的用例并不罕见。
- en: 'There are more examples where we need to convert a value we have in a JSON
    object to another type we have in our struct. Here are some of these examples:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多示例，我们需要将JSON对象中已有的值转换为我们的结构体中的另一种类型。以下是一些这些示例：
- en: Converting a JSON value to enum.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JSON值转换为枚举。
- en: Creating nested objects
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建嵌套对象
- en: Handling default values in the case of optional properties
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可选属性中的默认值
- en: Ultimately, parsing API responses is a common and important responsibility for
    iOS developers, and proficiency in this area is essential.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，解析API响应是iOS开发者的一项常见且重要的职责，在这个领域的熟练度是必不可少的。
- en: '*What is* *the answer?*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案？*'
- en: 'We use several features to convert a string-based date to a date object. The
    first is CodingKey to map the keys and properties, as we learned in our previous
    question. Second, initialize the `using init(from decoder: Decoder)` struct, and
    finally, use `DateFormatter` to convert the string to a date object.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用几个特性来将基于字符串的日期转换为日期对象。第一个是CodingKey，用于映射键和属性，正如我们在上一个问题中学到的。其次，初始化`using
    init(from decoder: Decoder)`结构体，最后使用`DateFormatter`将字符串转换为日期对象。'
- en: 'Let’s see an example. This is the `Person` properties list:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。这是`Person`属性列表：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And this is the `init(from decoder:` `Decoder)` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`init(from decoder:)`函数：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a lengthy piece of code worth mentioning!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段值得注意的代码！
- en: During an interview, it’s important to provide a detailed explanation of how
    to implement the features that were mentioned earlier in this section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，提供关于如何实现本节中提到的先前功能的详细解释是很重要的。
- en: '`init(from:)` is called when we want to create a struct based on serialized
    data.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要根据序列化数据创建结构体时，会调用`init(from:)`。
- en: With this method, we can enter the keys container of the received data and map
    them to the struct properties. This provides us complete flexibility when parsing
    more complex data structures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以进入接收到的数据的键容器，并将它们映射到结构体属性上。这为我们解析更复杂的数据结构提供了完全的灵活性。
- en: One important note about Codable before we move one is that, technically, we
    don’t “have” to use Codable in our projects. There are other solutions to parse
    and serialize objects and structs. But in modern Swift development, Codable is
    a major player in API management and data storage; therefore, it is a must topic
    for interviews, and we need to ensure we are fully prepared.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个关于Codable的重要注意事项：从技术上讲，我们“不必”在我们的项目中使用Codable。还有其他解决方案可以解析和序列化对象和结构体。但在现代Swift开发中，Codable是API管理和数据存储的主要参与者；因此，它是面试中必须讨论的主题，我们需要确保我们完全准备好了。
- en: The Codable protocol is a great match for structs, yet it’s not the only option
    to manage complex data structures. Dictionaries are a flexible method of organizing
    data of diverse types and structures, and they are often utilized in interviews.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Codable协议非常适合结构体，但它不是管理复杂数据结构的唯一选项。字典是组织不同类型和结构数据的灵活方法，并且在面试中经常被使用。
- en: Preparing for dictionary- and set-related interview questions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备与字典和集合相关的面试问题
- en: Dictionaries and sets are both highly effective data structures that enable
    fast storage, retrieval, and data manipulation. In particular, dictionaries offer
    the ability to store data using a key-value format, and they also serve as the
    foundation to encode and decode complex data structures.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和集合都是高度有效的数据结构，能够实现快速存储、检索和数据操作。特别是，字典能够以键值格式存储数据，并且它们也是编码和解码复杂数据结构的基础。
- en: 'As an iOS developer, there are some use cases where we can use dictionaries
    in our projects:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名iOS开发者，在我们的项目中有一些可以使用字典的场景：
- en: '**Quick lookup**: Dictionaries are excellent to save and retrieve data quickly,
    since they use key-value to store data. This makes dictionaries ideal to save
    user accounts, lists of settings, cache data, and so on.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速查找**：由于字典使用键值来存储数据，因此它们非常适合快速保存和检索数据。这使得字典非常适合保存用户账户、设置列表、缓存数据等。'
- en: '**Counting and frequency tracking**: When the dictionary key represents the
    item’s type, and the value is the number of instances of that type, we can use
    it to track the frequency of words, items, and so on.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数和频率跟踪**：当字典键代表项目的类型，而值是该类型的实例数量时，我们可以用它来跟踪单词、项目等的频率。'
- en: '**Encoding and decoding complex data structures**: Dictionaries are so flexible
    that we can store almost any data structure. Moreover, dictionaries are in the
    form of JSON, so they are suitable to encode and decode API requests and responses.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码和解码复杂数据结构**：字典非常灵活，我们可以存储几乎任何数据结构。此外，字典以JSON的形式存在，因此它们适合编码和解码API请求和响应。'
- en: '**Configuration data**: The key-value nature of dictionaries makes them ideal
    to store configuration data.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置数据**：字典的键值性质使它们非常适合存储配置数据。'
- en: Try to think of these use cases as a basis for interview questions about dictionaries.
    Knowing the primary dictionary’s advantages and usage can easily help us pass
    dictionary-related questions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将这些用例作为面试中关于字典问题的基础。了解字典的主要优势和用法可以轻松帮助我们通过与字典相关的问题。
- en: Sets are similar to dictionaries in the sense that they are both effective ways
    to store and retrieve data quickly. However, sets do not use the key-value structure
    as dictionaries do. Instead, they are lists of unique values that can be accessed
    with a time complexity of `O(1)`, which makes them very efficient data structures
    in so many use cases.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储和快速检索数据的角度来看，集合与字典相似，但集合不使用字典那样的键值结构。相反，它们是唯一值的列表，可以通过`O(1)`的时间复杂度访问，这使得它们在许多用例中非常高效的数据结构。
- en: In fact, it is more appropriate to compare sets to arrays. If we do not need
    our list of items to be sorted or include duplicates, sets are a superior choice
    to arrays in most cases.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将集合与数组进行比较更为合适。如果我们不需要我们的项目列表排序或包含重复项，那么在大多数情况下，集合是比数组更好的选择。
- en: 'Just like dictionaries, let’s look at some set use cases:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字典一样，让我们看看一些集合的使用场景：
- en: '**Removing duplicates from an array**: Do you remember the example of using
    sets to remove duplicates from an array? This is a classic application of sets.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从数组中删除重复项**：你还记得使用集合从数组中删除重复项的例子吗？这是集合的经典应用。'
- en: '**Fast membership testing**: Sets help determine whether a particular value
    has already been used. The **contains** function in sets is much more efficient
    than an array and can be helpful in many situations.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速成员测试**：集合有助于确定某个特定值是否已经被使用。集合中的**contains**函数比数组更高效，在许多情况下都很有帮助。'
- en: '**Relationships between entities**: Sets are an ideal data structure to create
    relationships between two entities, such as **User** and **Product**, because
    they do not require sorting or duplicates. This is why sets are the default choice
    for “to-many” relationships in core data.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体之间的关系**：集合是创建两个实体（如**用户**和**产品**）之间关系的理想数据结构，因为它们不需要排序或重复。这就是为什么集合是核心数据中“多对一”关系的默认选择。'
- en: Now, we look at some interview questions related to sets and dictionaries.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看一些与集合和字典相关的面试题。
- en: “Can you use a dictionary to store configuration data?”
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能使用字典来存储配置数据吗？”
- en: '*Why is this* *question important?*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: As previously mentioned, dictionaries are a valuable tool to store key-value
    pairs of data, and configuration data is a common use case for this data structure.
    This question involves creating a “configuration manager” class that utilizes
    a dictionary as its primary data structure and designing an interface to store
    and retrieve values from the dictionary. The task combines multiple coding skills,
    including creating a class and implementing a dictionary data structure.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，字典是存储数据键值对的宝贵工具，配置数据是这种数据结构的一种常见用例。这个问题涉及到创建一个“配置管理器”类，该类使用字典作为其主要数据结构，并设计一个接口来存储和检索字典中的值。这个任务结合了多种编码技能，包括创建类和实现字典数据结构。
- en: And here’s a great tip!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很好的技巧！
- en: Generally speaking, as an iOS developer, this is a pattern we meet in our day-to-day
    work and, therefore, in interviews.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，作为一个 iOS 开发者，这是我们日常工作和面试中遇到的一种模式。
- en: 'Let’s go over the pattern again:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾一下这个模式：
- en: '- Decide the data structure suitable for the task'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '- 决定适合任务的数据结构'
- en: '- Encapsulate the data structure within a class'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在类中封装数据结构'
- en: '- Design and create a simple interface to work with that data structure'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '- 设计并创建一个简单的接口来处理该数据结构'
- en: Following these guidelines is the key to many answers!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些指南是许多答案的关键！
- en: '*What is* *the answer?*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Here is a great code example to store configuration data in a dictionary:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的代码示例，用于在字典中存储配置数据：
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Looking at the code, we can see the three principles I mentioned – a data structure
    (dictionary), a wrapping class (`Configuration`), and an interface (`setValue()`
    and `value()`). That would be a perfect answer.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看代码，我们可以看到我提到的三个原则 – 数据结构（字典）、包装类（`Configuration`）和接口（`setValue()` 和 `value()`）。这将是一个完美的答案。
- en: “How do you use the filter method to select a subset of key-value pairs from
    a dictionary based on a condition?”
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你是如何使用 filter 方法根据条件从字典中选择键值对子集的？”
- en: '*Why is this* *question important?*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question tests our ability to manipulate dictionary data. To do that, we
    need to accomplish two tasks – *iterate* the dictionary values and create a *new
    dictionary* for some of the values according to a condition.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了我们操作字典数据的能力。为了做到这一点，我们需要完成两个任务 – *遍历* 字典值并创建一个 *新字典*，根据某些条件存储一些值。
- en: This operation is helpful in many different types of programs, as it allows
    you to focus only on the key-value pairs relevant to a particular task. For instance,
    you might use it to select only the key-value pairs for students who received
    an “A” grade on a test, or only the key-value pairs for words used frequently
    in a text.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作在许多不同类型的程序中都很有用，因为它允许你只关注与特定任务相关的键值对。例如，你可能用它来选择只包含在测试中获得“A”级的学生键值对，或者只包含在文本中频繁使用的单词键值对。
- en: '*What is* *the answer?*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: There are several ways to tackle this question – the `for` loop, filtering,
    and iterating the dictionary keys.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几个方法 – `for` 循环、过滤和遍历字典键。
- en: Solution number one – the for loop
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一种解决方案 – for 循环
- en: 'The for-loop solution iterates the dictionary keys and values and performs
    a simple `if-then` check to fill up a new filtered dictionary, as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环解决方案遍历字典的键和值，并执行简单的 `if-then` 检查以填充一个新的过滤字典，如下所示：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remember the syntax to iterate a dictionary using the `for` loop:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记住使用 `for` 循环遍历字典的语法：
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That will be useful in other questions as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这在其他问题中也会很有用。
- en: Solution number two – using the filter() method
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二种解决方案 – 使用 filter() 方法
- en: The `filter` method solution is considered much *more elegant* than the `for`
    loop because it is more readable and optimized. Moreover, it combines the two
    operations (iterating and filtering) into one method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 方法解决方案被认为比 `for` 循环更 *优雅*，因为它更易读且优化。此外，它将两个操作（遍历和过滤）合并为一个方法。'
- en: 'Let’s see how to perform the same task with a filter method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 filter 方法执行相同的任务：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Look at how much less code we used here. This is how the professionals do it!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这里我们使用了多少更少的代码。这就是专业人士的做法！
- en: Solution number three – looping the keys
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三种解决方案 – 遍历键
- en: It is not necessary for the condition in the filter to be based on the dictionary’s
    values; it could also be found in the keys. In this case, we would need to iterate
    through the keys and apply the filter to them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: filter 中的条件不一定基于字典的值；它也可能存在于键中。在这种情况下，我们需要遍历键并应用过滤条件。
- en: 'The following code filters the same dictionary, but this time, it creates a
    dictionary subset of fruits whose name starts with `a`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码过滤了相同的字典，但这次它创建了一个以 `a` 开头的果名字典子集：
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This solution allows us to perform more powerful dictionary filtering for more
    potential use cases and questions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案使我们能够为更多潜在的使用案例和问题执行更强大的字典过滤。
- en: “What is the time complexity of common set operations, such as inserting an
    element or checking for membership?”
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “常见集合操作（如插入元素或检查成员资格）的时间复杂度是多少？”
- en: '*Why is this* *question important?*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: The **time complexity** for operations is a popular topic in data structures
    questions, mainly when we discuss sets.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的 **时间复杂度** 是数据结构问题中的热门话题，尤其是在我们讨论集合时。
- en: If you are unfamiliar with this term, it’s time to catch up! One of the decisions
    we make as iOS developers is choosing the proper data structure for the right
    task.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个术语不熟悉，是时候赶上进度了！作为 iOS 开发者，我们做出的一个决定是为正确的任务选择合适的数据结构。
- en: One of the key advantages of using a set over an array is its operation efficiency,
    such as inserting an element and checking for membership. Therefore, we will choose
    a set when handling caching, avoiding duplicate items, and so on.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合而不是数组的一个关键优势是其操作效率，例如插入元素和检查成员资格。因此，当处理缓存、避免重复项等情况时，我们将选择集合。
- en: '*What is* *the answer?*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'The time complexity of common set operations is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 常见集合操作的时间复杂度如下：
- en: Inserting an item into a set has an average time complexity of O(1) and a worst-case
    time complexity of O(n)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个项目插入到集合中具有平均时间复杂度 O(1) 和最坏情况时间复杂度 O(n)
- en: The same goes for checking for membership – the average time complexity of O(1)
    and the worst-case time complexity of O(n)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于检查成员资格也是如此——平均时间复杂度为 O(1) 和最坏情况时间复杂度为 O(n)
- en: Sets can have an average time complexity of O(n) in common operations because
    there are cases where a set can be clustered, and the time complexity depends
    on the size of the set.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 集合在常见操作中可以有平均时间复杂度 O(n)，因为在某些情况下集合可能会聚集，时间复杂度取决于集合的大小。
- en: Either way, a set is much more efficient than an array in inserting and checking.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，集合在插入和检查方面都比数组更高效。
- en: “Is it possible to store any type of data in a set collection in Swift?”
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “在 Swift 的集合集合中是否可以存储任何类型的数据？”
- en: '*Why is this* *question important?*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question evaluates our comprehension of Swift’s set data structure and
    the process of hashing data types.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题评估了我们对于 Swift 集合数据结构和数据类型哈希过程的理解。
- en: Working with primitive data types such as `Int` or `Double` is straightforward.
    But that’s not the case with other types, especially those we define ourselves,
    such as structs or classes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始数据类型（如 `Int` 或 `Double`）一起工作很简单。但其他类型，尤其是我们定义的类型，如结构体或类，则不是这样。
- en: As a result, understanding how to use the **Hashable** protocol with a set data
    structure is crucial for iOS developers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解如何使用 **Hashable** 协议与集合数据结构对于 iOS 开发者至关重要。
- en: '*What is* *the answer?*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: It is possible to store any type of data in a set collection *as long as it
    conforms to the Hashable protocol*. The Hashable protocol allows custom types
    to generate a unique value that needs to be stored in set and dictionary data
    structures.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 只要符合 `Hashable` 协议，就可以在集合集合中存储任何类型的数据。`Hashable` 协议允许自定义类型生成一个唯一值，该值需要存储在集合和字典数据结构中。
- en: 'Let’s see an example of how to store a struct named `Person` in a set:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将名为 `Person` 的结构体存储在集合中的示例：
- en: '[PRE26]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s crucial to understand the `Hashable` protocol when working with sets and
    dictionaries in Swift, as it determines how values and keys are stored in these
    collections.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中处理集合和字典时，理解 `Hashable` 协议至关重要，因为它决定了值和键在这些集合中的存储方式。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the importance of data structures and why they
    are so important in interviews. We covered structs and classes, arrays, the Codable
    protocol, sets, and dictionaries.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了数据结构的重要性以及为什么它们在面试中如此重要。我们涵盖了结构体和类、数组、Codable 协议、集合和字典。
- en: This was a crucial chapter, and we now know so much more about data structures!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键章节，我们现在对数据结构了解得更多了！
- en: However, that was just a warmup because, in the next chapter, we will go over
    another critical topic in iOS interviews – nothing less than the Swift language
    itself.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那只是一个热身，因为在下一章中，我们将讨论 iOS 面试中的另一个关键主题——Swift 语言本身。
