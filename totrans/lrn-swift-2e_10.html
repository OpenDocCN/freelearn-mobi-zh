<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Harnessing the Past – Understanding and Translating Objective-C</h1></div></div></div><p>While Apple's platforms have been around for many years, Swift is still a very new language. Even before the release of the first iPhone, Apple's primary language of choice was Objective-C. This means that there are a vast number of resources in the world for developing on Apple's platforms using Objective-C. There are many amazing tutorials, code libraries, articles, and more, that are written in Objective-C that are still incredibly valuable for a Swift developer.</p><p>To take advantage of these resources, you must have at least a basic understanding of Objective-C, so that you can translate the concepts learned in tutorials and articles into Swift, as well as make use of the time tested Objective-C libraries.</p><p>In this chapter, we will develop a basic understanding of Objective-C with a focus on how it compares to Swift with the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Swift's relationship to Objective-C</li><li class="listitem" style="list-style-type: disc">Background of Objective-C</li><li class="listitem" style="list-style-type: disc">Constants and variables</li><li class="listitem" style="list-style-type: disc">Containers</li><li class="listitem" style="list-style-type: disc">Control flow</li><li class="listitem" style="list-style-type: disc">Functions</li><li class="listitem" style="list-style-type: disc">Types</li><li class="listitem" style="list-style-type: disc">Projects</li><li class="listitem" style="list-style-type: disc">Calling Objective-C code from Swift</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Swift's relationship to Objective-C</h1></div></div></div><p>As we <a class="indexterm" id="id441"/>discussed already, Objective-C was previously the primary language for developing on Apple's platforms. This means that Objective-C had a lot of influence on Swift; the largest of which is that Swift was designed to interoperate with Objective-C. Swift code can call Objective-C code and, likewise, Objective-C code can call Swift code.</p><p>Ultimately, Swift was designed, and is still is being designed, to be the next step in programming languages, without having to throw away all of our Objective-C code. Apple's stated goals for the language are for Swift to be more modern, interactive, safe, fast, and powerful. These words would be pretty much meaningless if we didn't already have a baseline to compare Swift against. Since Swift was designed primarily for Apple's platforms, that baseline is largely Objective-C.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Background of Objective-C</h1></div></div></div><p>Before<a class="indexterm" id="id442"/> we can talk about the details of Objective-C, we need to acknowledge its history. Objective-C is based on a language called simply "C". The C programming language was one of the first highly portable languages. Portable means that the same C code could be compiled to run on any processor as long as someone writes a compiler for that platform. Before that, most of the code was written in Assembly; which always had to be written specifically for each processor it would run on.</p><p>C is what is commonly referred to as a procedural programming language. It is built on the concept of a series of functions that call each other. It has a very basic support to create your own types, but it has no built in concept of objects. Objective-C was developed as an object-oriented extension to C. Just as Swift is backwards compatible with Objective-C, Objective-C is backwards compatible with C. Really, it simply adds object-oriented features on top of C with some new syntax and built-in libraries.</p><p>The real important thing is that Apple developed their current APIs: Cocoa and Cocoa Touch, for Objective-C. This is one of the biggest reasons why Objective-C is still very relevant to us as Swift developers. Even though we are primarily writing Swift code, we are still going to be regularly interacting with the Cocoa and Cocoa Touch libraries written in Objective-C.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Constants and variables</h1></div></div></div><p>Now, we <a class="indexterm" id="id443"/>are ready to dive into the basics of the Objective-C language. Objective-C has constants and variables very similar to Swift but they are declared and worked with slightly differently. Let's take a look at declaring a variable in both Swift and Objective-C:</p><div><pre class="programlisting">var number: Int
int number;</pre></div><p>The<a class="indexterm" id="id444"/> first line should look familiar, as it is Swift. The Objective-C version doesn't actually look all that different. The important difference is that the type of the variable is declared before the name instead of after. It is also important to note that Objective-C has no concept of type inference. Every time a variable is declared, it must be given a specific type. You will also see that there is a semicolon after the name. This is because every line of code in Objective-C must end with a semicolon. Lastly, you should notice that we have not explicitly declared <code class="literal">number</code> as a variable. This is because all information is assumed to be variable in Objective-C unless specified otherwise. To define <code class="literal">number</code> as a constant, we will add the <code class="literal">const</code> keyword before its type:</p><div><pre class="programlisting">let number = 10
const int number = 10;</pre></div><p>Objective-C has value and reference types just like Swift. However, in Objective-C, the difference between them is more conceptual.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec96"/>Value types</h2></div></div></div><p>The <a class="indexterm" id="id445"/>number we declared above is a value type in both languages. They are copied if they are passed to another function and there cannot be more than one variable referencing the exact same instance.</p><p>It is actually easier to determine if a variable is a value type or a reference type in Objective-C because, as we will see, virtually all reference types are declared with an asterisk (<code class="literal">*</code>). If there is an asterisk, you can be safe to assume that it is a reference type.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec97"/>Reference types</h2></div></div></div><p>Objective-C <a class="indexterm" id="id446"/>actually allows you to make any type a reference type by adding an asterisk:</p><div><pre class="programlisting">int *number;</pre></div><p>This declares a reference to a number variable, more commonly referred to as a <strong>pointer</strong>. In a pointer declaration, the asterisk should always come after the type and before the name.</p><p>In Objective-C, reference types are actually loosely mixed with the concept of optional in Swift. All reference types are optional because a pointer can always point to nil:</p><div><pre class="programlisting">int *number = nil;</pre></div><p>A pointer can also always be tested for nil:</p><div><pre class="programlisting">number == nil;</pre></div><p>To access the referenced value, you must dereference it:</p><div><pre class="programlisting">int actualNumber = *number;</pre></div><p>You can dereference a pointer by adding an asterisk before it.</p><p>This is <a class="indexterm" id="id447"/>how pointers are similar to optionals in Swift. The difference is that there is no way to declare a non-optional reference type in Objective-C. Every reference type could technically be nil, even if you design it to never actually be nil. This can often add a lot of unnecessary nil checking and means every function you write that accepts a reference type should probably deal with the nil case.</p><p>Finally, the other difference between reference types in the two languages is that Objective-C is not very strict when it comes to what type the pointer is referencing. For example, Objective-C won't complain if we create a new double reference that points at the same thing as the <code class="literal">int</code> pointer:</p><div><pre class="programlisting">double *another = (double *)number;</pre></div><p>Now, we have two variables: <code class="literal">number</code> and <code class="literal">another</code>; they are pointing at the same value but assuming that they both are of different types. One of them is clearly going to be wrong, but Objective-C will happily try to use the same value as both a <code class="literal">double</code> and an <code class="literal">int</code> if you try. This is just one bug that Swift makes impossible by design.</p><p>So far, all of the Objective-C code we have looked at is actually strict C. We have not used any of the features that Objective-C added onto C. The main thing that Objective-C adds to C is its class system.</p><p>Lets take a look at our first actual Objective-C type called <code class="literal">NSString</code> compared to the Swift <code class="literal">String</code> type:</p><div><pre class="programlisting">var myString = "Hello World!"
NSString *myString = @"Hello World!";</pre></div><p>Just like in Swift, you can create a string instance using double quotes; however, in Objective-C you must put an <code class="literal">@</code> sign before it.</p><p>One big thing to remember with the Objective-C class system is that it is not possible to create an instance of a class that is a value type. All instances must be referenced by a reference type. We cannot create a plain <code class="literal">NSString</code>. It must always be an <code class="literal">NSString*</code> pointer.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Containers</h1></div></div></div><p>Objective-C <a class="indexterm" id="id448"/>has the same exact core containers that Swift does, with the two<a class="indexterm" id="id449"/> exceptions being that they are named slightly differently, and all of the containers in Objective-C are reference types because of the basic requirement that all Objective-C types must be reference types.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec98"/>Arrays</h2></div></div></div><p>In <a class="indexterm" id="id450"/>Objective-C arrays are called <code class="literal">NSArray</code>. Let's take a look at the initialization of an array in both Swift and Objective-C side-by-side:</p><div><pre class="programlisting">var array = [Int]()
NSArray *array = [NSArray alloc];
array = [array init];</pre></div><p>We have defined a variable called <code class="literal">array</code> that is a reference to the type <code class="literal">NSArray</code>. We then assign it to a newly allocated instance of <code class="literal">NSArray</code>. The square bracket notation in Objective-C allows us to call methods on a type or on an instance. Each separate call is always contained within a single set of square brackets. In this case, we are first calling the <code class="literal">alloc</code> method on the <code class="literal">NSArray</code> class. This returns a newly allocated variable that is of the type <code class="literal">NSArray</code>.</p><p>In contrast to Swift, Objective-C requires a two-step process to initialize a new instance. First, the memory must be allocated and then it must be initialized. Allocating means that we are reserving the memory for that object and initializing it means that we are setting it to its default value. This is what we are doing in the second line. The second line asks the instance to initialize itself. We reassign the array to the result of the call to <code class="literal">init</code>, because it is possible for <code class="literal">init</code> to return nil. Note that we are not dereferencing the <code class="literal">array</code> variable in order to make a call on it. We actually call the methods directly on the pointer.</p><p>Now, it is kind of a waste to use two lines to initialize a new instance, so often the calls are chained together:</p><div><pre class="programlisting">NSArray *array = [[NSArray alloc] init];</pre></div><p>This calls <code class="literal">alloc</code> on <code class="literal">NSArray</code> and then immediately calls on <code class="literal">init</code> on the result of that. The <code class="literal">array</code> variable is then assigned to the result of the <code class="literal">init</code> call. Be aware that it is possible for <code class="literal">alloc</code> to return nil, in which case we would be calling <code class="literal">init</code> on nil. In Objective-C this is OK; if you call a method on nil, it will simply always return nil. This is similar to how optional chaining works in Swift.</p><p>There is also an alternative to calling <code class="literal">alloc</code> and <code class="literal">init</code>; it's called simply <code class="literal">new</code>:</p><div><pre class="programlisting">NSArray *array = [NSArray new];</pre></div><p>This class method allocates and initializes the instance at the same time. This is great when you are not passing any arguments into <code class="literal">init</code>, but you will still need to call <code class="literal">alloc</code> separately when you are passing arguments into it. We will see examples of this later on.</p><p>You may <a class="indexterm" id="id451"/>have noticed that we have not specified what type this array is supposed to hold. This is because it is actually not possible. All arrays in Objective-C can contain any mix of types as long as they are not C types. This means that an <code class="literal">NSArray</code> cannot contain an <code class="literal">int</code> (there is an <code class="literal">NSNumber</code> class instead), but it can contain any mix of <code class="literal">NSStrings</code>, <code class="literal">NSArrays</code>, or any other Objective-C type. The compiler will not do any form of type checking for you, which means that we can write code expecting the wrong type to be in the array. This is yet another classification of bug that Swift makes impossible.</p><p>So how do we add objects to our array? The reality is that the <code class="literal">NSArray</code> class does not allow us to add or remove objects from it. In other words, <code class="literal">NSArray</code> is immutable. Instead, there is a version of an array called <code class="literal">NSMutableArray</code> that allows us to add and remove objects. Then we can use the <code class="literal">addObject:</code> method:</p><div><pre class="programlisting">NSMutableArray *array = [NSMutableArray new];
[array addObject:@"Hello World!"];</pre></div><p>Methods in Objective-C and Swift are named in the same way with a colon indicating each argument. In Objective-C, the colon is also used when calling the method to indicate the following code is the value to pass into the method.</p><p>The existence of a plain <code class="literal">NSArray</code> is to serve the same basic purpose as a constant array in Swift. In fact, we will see that all Objective-C containers are split into mutable and non-mutable versions. A mutable container can be passed into a method and treated like the non-mutable version to add some safety by not allowing unwanted code to modify the array.</p><p>Now, to access a value in an <code class="literal">NSArray</code> we have two options. The full way is to use the <code class="literal">objectAtIndex:</code> method:</p><div><pre class="programlisting">NSString *myString = [array objectAtIndex:0];</pre></div><p>We can also use square brackets, similar to Swift:</p><div><pre class="programlisting">NSString *myString = array[0];</pre></div><p>Note that we are just assuming that the type returned from the array is an <code class="literal">NSString</code>. We can just as easily assume that it is another type, say <code class="literal">NSArray</code>:</p><div><pre class="programlisting">NSArray *myString = array[0];</pre></div><p>As we know, this will be wrong and will almost certainly cause bugs later in the code but the compiler will not complain.</p><p>Lastly, to remove an object from a mutable array, we can use the <code class="literal">removeObjectAtIndex:</code> method:</p><div><pre class="programlisting">[array removeObjectAtIndex:0];</pre></div><p>The other important feature that you will need to be aware of is that Objective-C also has array literals, so you don't have to build them up dynamically:</p><div><pre class="programlisting">NSArray *array = @[@"one", @"two", @"three"];</pre></div><p>Array<a class="indexterm" id="id452"/> literals start with an <code class="literal">@</code> symbol just like a string, but then it is defined by a list of objects within square brackets just like Swift.</p><p>There is a lot more that arrays can do, but you should be able to understand what each method does when you see it because most are well named. The methods are also often named the same in each language or you can look them up online, where Apple has extensive documentation. The purpose of this chapter is just to get you comfortable enough to have a high-level understanding of Objective-C code.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec99"/>Dictionaries</h2></div></div></div><p>Following <a class="indexterm" id="id453"/>the same pattern as arrays, dictionaries in Objective-C are called <code class="literal">NSDictionary</code> and <code class="literal">NSMutableDictionary</code>. A dictionary is initialized in the exact same way as shown:</p><div><pre class="programlisting">NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];
NSDictionary *dict2 = [NSDictionary new];</pre></div><p>To set a value, we use the <code class="literal">setObject:forKey:</code> method:</p><div><pre class="programlisting">[dict setObject:@"World" forKey:@"Hello"];</pre></div><p>Just like with arrays, we cannot set new objects on non-mutable dictionaries. Also, this is our first example of a method that takes more than one argument. As you can see, each argument is contained within the square brackets but separated by a space and the label for that argument. In this pattern, Objective-C methods can have a number of arguments.</p><p>Now to access a value we can use the <code class="literal">objectForKey:</code> method or square brackets again:</p><div><pre class="programlisting">NSString *myString = [dict objectForKey:@"Hello"];
NSString *myString2 = dict[@"Hello"];</pre></div><p>Again, we are assuming that the resulting object being returned is a string, because we know what we just put into the dictionary. This assumption isn't always safe and we also need to always be aware that this method will return nil if an object does not exist for that key.</p><p>Lastly, to remove an object, we can use the <code class="literal">removeObjectForKey:</code> method:</p><div><pre class="programlisting"> [dict removeObjectForKey:@"Hello"];</pre></div><p>This is all relatively straightforward, especially when you are reading the code. This verbosity was always a great feature of Objective-C to write understandable code and this was definitely carried forward into Swift.</p><p>Dictionaries also have literals, but unlike <code class="literal">NSArrays</code> and Swift array literals, dictionary literals in Objective-C are declared using curly brackets. Otherwise, it looks very similar to Swift:</p><div><pre class="programlisting">NSDictionary *dict3 = @{@1: @"one", @2: @"two", @3: @"three"};</pre></div><p>Again, we <a class="indexterm" id="id454"/>have to start our literal with an <code class="literal">@</code> symbol. We can also see that we can use numbers as objects in our containers as long as we put an <code class="literal">@</code> symbol before each one. Instead of creating something such as an <code class="literal">int</code> type, this creates an <code class="literal">NSNumber</code> instance. You shouldn't need to know much about the <code class="literal">NSNumber</code> class except that it is a class to represent many different forms of numbers as objects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Control flow</h1></div></div></div><p>Objective-C <a class="indexterm" id="id455"/>has many of the same control flow paradigms <a class="indexterm" id="id456"/>as Swift. We will go through each of them quickly, but before we do, let's take a look at the Objective-C equivalent of <code class="literal">print</code>:</p><div><pre class="programlisting">var name = "Sarah"
println("Hello \(name)")
NSString *name = @"Sarah";
NSLog(@"Hello %@", name);</pre></div><p>Instead of <code class="literal">print</code>, we are using a function called <code class="literal">NSLog</code>. Objective-C does not have string interpolation, so <code class="literal">NSLog</code> is a somewhat more complex solution than <code class="literal">print</code>. The first argument to <code class="literal">NSLog</code> is a string that describes the format to be printed out. This includes a placeholder for each piece of information we want to log that indicates the type it should expect. Every placeholder starts with a percent symbol. In this case, we are using an at-symbol to indicate what we are going to be substituting in a string. Every argument after the initial format will be substituted for the placeholders in the same order they are passed in. Here, this means that it will end up logging <strong>Hello Sarah</strong> just like the Swift code.</p><p>Now, we are ready to look at the different methods of control flow in Objective-C.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec100"/>Conditionals</h2></div></div></div><p>A <a class="indexterm" id="id457"/>conditional looks exactly the same in both Swift and Objective-C except parentheses are required in Objective-C:</p><div><pre class="programlisting">var invitees = ["Sarah", "Jamison", "Roana"]
if invitees.count &gt; 20 {
    print("Too many people invited")
}
NSArray *invitees = @[@"Sarah", @"Jamison", @"Roana"];
if (invitees.count &gt; 20) {
    NSLog(@"Too many people invited");
}</pre></div><p>You can <a class="indexterm" id="id458"/>also include those parentheses in Swift, but they are optional. Here, you also see that Objective-C still has the idea of the dot syntax for calling some methods. In this case, we have used <code class="literal">invitees.count</code> instead of <code class="literal">[invitees count]</code>. This is only an option when we are accessing a property of the instance or we are calling a method that takes no arguments and returns something, as if it were a calculated property.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec101"/>Switches</h2></div></div></div><p>Switches <a class="indexterm" id="id459"/>in Objective-C are profoundly less powerful than switches in Swift. In fact, switches are a feature of strict C and are not enhanced at all by Objective-C. Switches cannot be used like a series of conditionals; they can only be used to do equality comparisons:</p><div><pre class="programlisting">switch invitees.count {
    case 1:
        print("One person invited")
    case 2:
        print("Two people invited")
    default:
        print("More than two people invited")
}
switch (invitees.count) {
    case 1:
        NSLog(@"One person invited");
        break;

    case 2:
        NSLog(@"Two people invited");
        break;
        
    default:
        NSLog(@"More than two people invited");
        break;
}</pre></div><p>Again, parentheses are required in Objective-C, where they are optional in Swift. The most important difference with Objective-C switches is that by default, one case will flow into the next unless you specifically use the <code class="literal">break</code> keyword to get out of the switch. That is the opposite of Swift, where it will only flow into the next case if you use the <code class="literal">fallthrough</code> keyword. In practice, this means that the vast majority of Objective-C switch cases will need to end with <code class="literal">break</code>.</p><p>Objective-C switches are not powerful enough to allow us to create cases for ranges of values and certainly cannot test a list of arbitrary conditionals like we can in Swift.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec102"/>Loops</h2></div></div></div><p>Just like <a class="indexterm" id="id460"/>conditionals, loops in Objective-C are very similar to Swift. While-loops are identical except that the parentheses are required:</p><div><pre class="programlisting">var index = 0
while index &lt; invitees.count {
    print("\(invitees[index]) is invited");
    index++
}
int index = 0;
while (index &lt; invitees.count) {
    NSLog(@"%@ is invited", invitees[index]);
    index++;
}</pre></div><p>The for-in loops are slightly different, in this you must specify the type of the variable you are looping through with the following:</p><div><pre class="programlisting">var showsByGenre = [
    "Comedy": "Modern Family",
    "Drama": "Breaking Bad"
]
for (genre, show) in showsByGenre {
    print("\(show) is a great \(genre)")
}
NSDictionary *showsByGenre=@{
    @"Comedy":@"Modern Family",
    @"Drama":@"Breaking Bad"
};
for (NSString *genre in showsByGenre) {
    NSLog(@"%@ is a great %@", showsByGenre[genre], genre);
}</pre></div><p>You may have also noticed that when we are looping through an <code class="literal">NSDictionary</code> in Objective-C you only get the key. This is because tuples do not exist in Objective-C. Instead, you must access the value from the original dictionary, using the key as you loop through.</p><p>The other feature that is missing from Objective-C is ranges. To loop through a range of numbers, Objective-C programmers must use a different kind of loop called a <code class="literal">for</code> loop:</p><div><pre class="programlisting">for number in 1 ... 10 {
    print(number)
}
for (int number = 1; number &lt;= 10; number++) {
    NSLog(@"%i", number);
}</pre></div><p>This loop is <a class="indexterm" id="id461"/>made up of three parts: an initial value, a condition to run until, and an operation to perform after each loop. This version loops through the numbers 1 to 10 just like the Swift version. Clearly, it is still possible to translate the Swift code into Objective-C; it just isn't as clean.</p><p>Even with that limitation, you can see that Objective-C and Swift loops are pretty much the same except for the parentheses requirement.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Functions</h1></div></div></div><p>So far <a class="indexterm" id="id462"/>we have called some Objective-C functions but we have<a class="indexterm" id="id463"/> not defined any yet. Let's see what the Objective-C versions are of the functions we defined in <a class="link" href="ch02.html" title="Chapter 2. Building Blocks – Variables, Collections, and Flow Control">Chapter 2</a>, <em>Building Blocks – Variables, Collections, and Flow Control</em>.</p><p>Our most basic function definition didn't take any arguments and didn't return anything. The Objective-C version looks similar to the following code:</p><div><pre class="programlisting">func sayHello() {
    print("Hello World!");
}
sayHello()
void sayHello() {
    NSLog(@"Hello World!");
}
sayHello();</pre></div><p>Objective-C functions always starts with the type that the function returns instead of the keyword <code class="literal">func</code>. In this case, we aren't actually returning anything, so we use the keyword <code class="literal">void</code> to indicate that.</p><p>Functions that take arguments and return values have more of a disparity between the two languages:</p><div><pre class="programlisting">func addInviteeToListIfSpotAvailable
    (
    invitees: [String],
    newInvitee: String
    )
    -&gt; [String]
{
    if invitees.count &gt;= 20 {
        return invitees
    }
    return invitees + [newInvitee]
}
addInviteeToListIfSpotAvailable(invitees, newInvitee: "Roana")
NSArray *addInviteeToListIfSpotAvailable
    (
    NSArray *invitees,
    NSString *newInvitee
    )
{
    if (invitees.count &gt;= 20) {
        return invitees;
    }
    NSMutableArray *copy = [invitees mutableCopy];
    [copy addObject:newInvitee];
    return copy;
}
addInviteeToListIfSpotAvailable(invitees, @"Roana");</pre></div><p>Again, the <a class="indexterm" id="id464"/>Objective-C version defines what it is returning at the <a class="indexterm" id="id465"/>beginning of the function. Also, just like variables, parameters to functions must have their type defined before their name instead of after. The rest however, is pretty similar: the arguments are contained within parentheses and separated by commas; the code of the function is contained within curly brackets and we use the <code class="literal">return</code> keyword to indicate what we want to return.</p><p>This specific implementation actually brings up an interesting requirement for dealing with arrays in Objective-C. Just like we want to avoid mutable arrays in Swift, we normally want to avoid them in Objective-C. In this case, we still don't want to modify the passed in array, we just want to add the new invitee to the end of a copied version. In Swift, because arrays are value types, the copy is made for us and we can use the addition operator to add on the new invitee. In Objective-C, we need to explicitly make a copy of the array. More than that, we need the copy to be mutable so that we can add the new invitee to it.</p><p>All in all, the biggest difference between Swift functions and Objective-C methods is the definition of the return value being at the beginning or the end of the parameters. The memory is handled in the same way in both languages. When passing in a pointer in Objective-C, the pointer itself is copied but both versions are going to reference the exact same instance. When a value type is passed into a function in Swift, the value is simply copied and the two versions have nothing to do with each other after that.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Types</h1></div></div></div><p>The<a class="indexterm" id="id466"/> type system<a class="indexterm" id="id467"/> in Objective-C is a little bit more disparate than Swift. This is because the structures and enumerations in Objective-C come from C. Only classes and categories come from the Objective-C extension.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec103"/>Structures</h2></div></div></div><p>In Swift, structures <a class="indexterm" id="id468"/>are very similar to classes, but in Objective-C, they are much more different. Structures in Objective-C are essentially just a way of giving a name to a collection of individual types. They cannot contain methods. Even more restrictive than that, structures can't contain Objective-C types. This leaves us with only basic possibilities:</p><div><pre class="programlisting">struct Cylinder {
    var radius: Int
    var height: Int
}
var c = Cylinder(radius: 10, height: 10)
typedef struct {
    int radius;
    int height;
} Cylinder;
Cylinder c;
c.radius = 10;
c.height = 5;</pre></div><p>Structures in Objective-C start with the keyword <code class="literal">typedef</code>, which is short for type definition. This is then followed by the <code class="literal">struct</code> keyword and the different components of the structure contained within curly brackets. Finally, after the curly brackets is the name of the structure.</p><p>Advanced C programmers will do a lot more with structures. There are ways to simulate some features of inheritance with structures and to do other more advanced things, but that is beyond the scope of this book and not very relevant in most modern programming projects. There are some types in Apple's APIs that are structures like CGRect so you should know how to interact with them, but you most likely won't have to deal with custom structure definitions when looking at Objective-C resources.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec104"/>Enumerations</h2></div></div></div><p>Enumerations <a class="indexterm" id="id469"/>are also much more restrictive in Objective-C. They are really just a simple mechanism to represent a finite list of related possible values. This allows us to still represent possible primary colors:</p><div><pre class="programlisting">enum PrimaryColor {
    case Red
    case Green
    case Blue
} 
var color = PrimaryColor.Blue

typedef enum {
    PrimaryColorRed,
    PrimaryColorGreen,
    PrimaryColorBlue,
} PrimaryColor;
PrimaryColor color = PrimaryColorBlue;</pre></div><p>Just like <a class="indexterm" id="id470"/>with structures, Objective-C enumerations start with the keyword <code class="literal">typedef</code> followed by <code class="literal">enum</code> with the name at the end of the definition. Each case is contained within the curly brackets and separated by a comma.</p><p>Notice that every case of the enumeration starts with the name of the enumeration. This is a very common convention, to make it easy for code completion and to show all possible values of an enumeration. This is because in Objective-C, you cannot specify a specific enumeration value through the name of the enumeration itself. Instead, every case is its own keyword. This is why when we are assigning our <code class="literal">color</code> variable to blue; we use the case name by itself.</p><p>Enumerations in Objective-C cannot have methods, associated values, or represent any other values except for integers. In fact, in Objective-C enumerations, every case has a numeric value. If you don't specify any, they start at <code class="literal">0</code> and go up by <code class="literal">1</code> for each case. If you want, you can manually specify a value for one or more of the cases:</p><div><pre class="programlisting">typedef enum {
    PrimaryColorRed,
    PrimaryColorGreen = 10,
    PrimaryColorBlue,
} PrimaryColor;</pre></div><p>Each case after a manually specified case will continue to increase by one. This means that in the preceding code <code class="literal">PrimaryColorRed</code> is still <code class="literal">0</code> but <code class="literal">PrimaryColorBlue</code> is <code class="literal">11</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec105"/>Classes</h2></div></div></div><p>Unlike <a class="indexterm" id="id471"/>Objective-C structures and enumerations, classes <a class="indexterm" id="id472"/>are very similar to their Swift counterparts. Objective-C classes can contain methods and properties, use inheritance, and get initialized. However, they look pretty different. Most notably, a class in Objective-C is split into two parts: its interface and its implementation. The interface is intended to be the public interface to the class, while the implementation includes the implementation of that interface in addition to any other private methods.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec25"/>Basic class</h3></div></div></div><p>Let's start <a class="indexterm" id="id473"/>by looking again at our contact class from <a class="link" href="ch03.html" title="Chapter 3. One Piece at a Time – Types, Scopes, and Projects">Chapter 3</a>, <em>One Piece at a Time – Types, Scopes, and Projects</em> and what it looks like in Objective-C:</p><div><pre class="programlisting">class Contact {
    var firstName: String = "First"
    var lastName: String = "Last"
}
@interface Contact : NSObject {
    NSString *firstName;
    NSString *lastName;
}
@end

@implementation Contact
@end</pre></div><p>Already Objective-C is taking a lot more lines of code. First, we have the interface declaration. This begins with the <code class="literal">@interface</code> keyword and ends with the <code class="literal">@end</code> keyword. Within the square brackets is a list of attributes. These are essentially the same as the attributes of a structure, except that you can include Objective-C objects in the attributes. These attributes are not commonly written like this because using the properties will create these automatically, as we will see later.</p><p>You will also notice that our class is inheriting from a class called <code class="literal">NSObject</code>, as indicated by <code class="literal">: NSObject</code>. This is because every class in Objective-C must inherit from <code class="literal">NSObject</code>, which makes <code class="literal">NSObject</code> the most basic form of class. However, don't let the term "basic" fool you; <code class="literal">NSObject</code> provides a lot of functionality. We won't really get into that here, but you should at least be aware of it.</p><p>The other part of the class is the implementation. It starts with the <code class="literal">@implementation</code> keyword followed by the name of the class we are implementing and then ends again with the <code class="literal">@end</code> keyword. Here, we have not actually added any extra functionality to our contact class. However, you may notice that our class is missing something that the Swift version has.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec26"/>Initializers</h3></div></div></div><p>Objective-C does <a class="indexterm" id="id474"/>not allow specifying default values for any attributes or properties. This means that we have to implement an initializer that sets the default values:</p><div><pre class="programlisting">@implementation Contact
- (id)init {
    self = [super init];
    if (self) {
        firstName = @"First";
        lastName = @"Last";
    }
    return self;
}
@end</pre></div><p>In Objective-C, initializers <a class="indexterm" id="id475"/>are the exact same as a method, except that by convention they start with the name <code class="literal">init</code>. This is actually just a convention but it is important, as it will cause problems down the line with memory management and interacting with the code from Swift.</p><p>The minus sign at the beginning indicates that this is a method. Next, the return type is specified within parentheses, which is then followed by the name of the method: in this case <code class="literal">init</code>. The body of the method is contained in curly brackets just like a function.</p><p>The return type for all initializers is going to be <code class="literal">id</code> by convention. This allows us to easily override initializers of subclasses.</p><p>Virtually all initializers will follow this same pattern. Just like in Swift, <code class="literal">self</code> references the instance that this method is being called on. The first line assigns the <code class="literal">self</code> reference to the result by calling the superclass's initializer with <code class="literal">[super init]</code>. We then allow for the possibility that the initializer fails and returns nil by testing it for nil in the <code class="literal">if (self)</code> statement. The <code class="literal">if</code> statement will fail if <code class="literal">self</code> is nil. If it is not nil, we assign the default values. Finally, we return self, so that calling code can maintain a reference to the newly initialized object. However, this is just a convention and Objective-C does not have any protection around properly initializing properties.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec27"/>Properties</h3></div></div></div><p>The <a class="indexterm" id="id476"/>Objective-C version of the contact class still isn't exactly like the Swift version because the <code class="literal">firstName</code> and <code class="literal">lastName</code> attributes are not accessible from outside the class. To make them accessible we need to define them as public properties and we can drop them from being explicit attributes:</p><div><pre class="programlisting">@interface Contact : NSObject {
}
@property NSString *firstName;
@property NSString *lastName;
@end</pre></div><p>Note that the properties are defined outside of the curly brackets but still within the <code class="literal">@interface</code>. In fact, you can leave off the curly brackets altogether if you have nothing to define in it. Properties automatically generate attributes by the same name except with an underscore at the beginning:</p><div><pre class="programlisting">@implementation Contact
- (id)init {
    self = [super init];
    if (self) {
        _firstName = @"First";
        _lastName = @"Last";
    }
    return self;
}
@end</pre></div><p>Alternatively, you<a class="indexterm" id="id477"/> can just set the values using <code class="literal">self</code>:</p><div><pre class="programlisting">@implementation Contact
- (id)init {
    self = [super init];
    if (self) {
        self.firstName = @"First";
        self.lastName = @"Last";
    }
    return self;
}
@end</pre></div><p>There are nuances to each approach but for just general reading purposes, it doesn't matter which one is used.</p><p>Also, just as you can define weak references in Swift, you can do so in Objective-C:</p><div><pre class="programlisting">@interface SteeringWheel : NSObject
@property (weak) Car *car;
@end</pre></div><p>If you want, you can replace <code class="literal">weak</code> with <code class="literal">strong</code>, but just like Swift, all properties are strong by default. Weak references in Objective-C will automatically be set to nil if the referenced object gets deallocated. You can also use the <code class="literal">unsafe_unretained</code> keyword, which is equivalent to unowned in Swift. However, this is rarely used as the only difference between the two in Objective-C is that <code class="literal">unsafe_unretained</code> does not reset the value to nil; instead, it will reference an invalid object if the object gets deallocated causing confusing crashes if used.</p><p>In addition to <code class="literal">weak</code> or <code class="literal">strong</code>, you can also specify that a property is <code class="literal">readonly</code> or <code class="literal">readwrite</code>:</p><div><pre class="programlisting">@interface SteeringWheel : NSObject
@property (weak, readonly) Car *car;
@end</pre></div><p>Each property <a class="indexterm" id="id478"/>attribute should be written inside the parentheses separated by a comma. As the <code class="literal">readonly</code> name implies, this makes it so that the property can be read but not written to. Every property is read-write by default, so normally it is not necessary to include it.</p><p>Note that you may also see the keyword <code class="literal">nonatomic</code> in the parentheses. This is a more advanced topic that is beyond the scope of this book.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec28"/>Methods</h3></div></div></div><p>We <a class="indexterm" id="id479"/>have already seen an example of a method in the form of an initializer, but let's take a look at some methods that take parameters:</p><div><pre class="programlisting">@implementation Contact
- (NSArray *)addToInviteeList:(NSArray *)invitees includeLastName:(BOOL)include {
    NSMutableArray *copy = [invitees mutableCopy];
    if (include) {
        NSString *newString = [self.firstName
           stringByAppendingFormat:@" %@", self.lastName
        ];
        [copy addObject:newString];
    }
    else {
        [copy addObject:self.firstName];
    }
    return copy;
}
@end</pre></div><p>Each parameter is defined with a public label followed by a colon, its type in parentheses, and an internal name. Then, each parameter is separated by a space or new line.</p><p>You can also see an example way to format a long method call with the creation of the <code class="literal">newString</code> instance. Similar to Swift, any space can be converted to a new line instead. This allows us to convert a single long line into multiple lines, as long as we don't put semicolons after the partial lines.</p><p>Like Swift, Objective-C also has the idea of class methods. Class methods are indicated with a plus sign instead of a minus sign:</p><div><pre class="programlisting">@implementation Contact
+ (void)printAvailablePhonePrefixes {
    NSLog(@"+1");
}
@end</pre></div><p>So now you can call the method directly on the class:</p><div><pre class="programlisting">[Contact printAvailablePhonePrefixes];</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec29"/>Inheritance</h3></div></div></div><p>Just as <a class="indexterm" id="id480"/>all of our classes so far have inherited from <code class="literal">NSObject</code>, any class can inherit from any other class just like in Swift and all the same rules apply. Methods and properties are inherited from their superclass and you can choose to override methods in subclasses. However, the compiler enforces the rules much less. The compiler does not force you to specify that you intend your method to override another. The compiler does not enforce any rules around initializers and whom they call. However, all the conventions exist because those conventions were the inspiration for the Swift requirements.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Categories</h2></div></div></div><p>Categories <a class="indexterm" id="id481"/>in Objective-C are just like Swift extensions. They allow you to add new methods to existing classes. They look very similar to plain classes:</p><div><pre class="programlisting">extension Contact {
    func fullName() -&gt; String {
        return "\(self.firstName) \(self.lastName)"
    }
}
@interface Contact (Helpers)
- (NSString *)fullName;
@end

@implementation Contact (Helpers)
- (NSString *)fullName {
    return [self.firstName stringByAppendingFormat:@" %@", self.lastName];
}
@end</pre></div><p>We know that this is a category instead of a normal class because we added a name within parentheses after the class name. Every category on a class must have a unique name. In this case, we are calling it <code class="literal">Helpers</code> and we are adding a method to return the contact's full name.</p><p>Here, for the first time, we are declaring a method inside the interface. This is also possible with classes. A method definition looks exactly like an implementation except that it ends in a semicolon instead of the code inside the curly brackets. This will allow us to call the method from outside the current file, as we will see in more detail in the upcoming projects section.</p><p>Categories can also add properties, but you will have to define your own getter and setter methods because just like Swift extensions can't add stored properties, Objective-C categories can't add attributes:</p><div><pre class="programlisting">@interface Contact (Helpers)
@property NSString *fullName;
@end

@implementation Contact (Helpers)
- (NSString *)fullName {
    return [self.firstName stringByAppendingFormat: @" %@",
        self.lastName
    ];
}
- (void)setFullName:(NSString *)fullName {
    NSArray *components = [fullName
        componentsSeperatedByString:@" "];
    ];
    if (components.count &gt; 0) {
        self.firstName = components[0];
    }
    if (components.count &gt; 1) {
        self.lastName = components[1];
    }
}
@end</pre></div><p>These <a class="indexterm" id="id482"/>types of properties are very similar to calculated properties. If you need to allow reading from a property, you must implement a method with the exact same name that takes no parameters and returns the same type. If you want to be able to write to the property you will have to implement a method that starts with <code class="literal">set</code>, followed by the same property name with a capital first letter, that takes the property type as a parameter and returns nothing. This allows outside classes to interact with the property as if it were an attribute, when in fact it is just another set of methods. Again, this is possible within a class or a category.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec107"/>Protocols</h2></div></div></div><p>Like <a class="indexterm" id="id483"/>Swift, Objective-C has the idea of protocols. Their definition looks similar to this:</p><div><pre class="programlisting">protocol StringContainer {
    var count: Int {get}
    func addString(string: String)
    func enumerateStrings(handler: () -&gt; ())
}
@protocol StringContainer
@property (readonly) NSInteger count;
- (void)addString:(NSString *)string;
- (void)enumerateStrings:(void(^)(NSString *))handler;
@end</pre></div><p>Here, we <a class="indexterm" id="id484"/>are using the <code class="literal">@protocol</code> keyword instead of <code class="literal">@interface</code> and it still ends with the <code class="literal">@end</code> keyword. We can define any properties or methods that we want. We can then say that a class implements the protocol similar to this:</p><div><pre class="programlisting">@interface StringList : NSObject &lt;StringContainer&gt;
@property NSMutableArray *contents;
@end</pre></div><p>The list of protocols that a class implements should be listed within angled brackets after the class it inherits from separated by commas. In this case we are only implementing a single protocol so we don't need any commas. This code also declares a <code class="literal">contents</code> property, so that we can implement the protocol as shown:</p><div><pre class="programlisting">@implementation StringList

- (NSInteger)count {
    return [self.contents count];
}

- (void)addString:(NSString *)string {
    if (self.contents == nil) {
        self.contents = [NSMutableArray new];
    }
    [self.contents addObject:string];
}

- (void)enumerateStrings:(void (^)(NSString *))handler {
    for (NSString *string in self.contents) {
        handler(string);
    }
}

@end</pre></div><p>Note that we don't do anything special in the implementation to implement a protocol; we just need to make sure the proper methods and computed properties are implemented.</p><p>The other thing you should be aware of is that protocols in Objective-C are not used in the same way as classes. You can't just define a variable to be a protocol; instead, you must give it a type and require that it implement the protocol. Most commonly, this is done with the <code class="literal">id</code> type:</p><div><pre class="programlisting">    id&lt;StringContainer&gt; container = [StringList new];</pre></div><p>Any variable declaration can require that it not only inherits from a specific type, but also implements certain protocols.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec108"/>Blocks</h2></div></div></div><p>Lastly, blocks<a class="indexterm" id="id485"/> are the Objective-C alternative to closures in Swift. They are actually a late addition to Objective-C so their syntax is somewhat complex:</p><div><pre class="programlisting">int (^doubleClosure)(int) = ^(int input){
    return input * 2;
};
doubleClosure(2);</pre></div><p>Let's break this down. We start like any other variable with the variable's name and type before the equals sign. The name starts with a carrot symbol (<code class="literal">^</code>) inside the first set of parentheses. In this case, we are calling it <code class="literal">doubleClosure</code>. The actual type of the closure surrounds that. The type it starts with is the type the closure returns, which in this case is an <code class="literal">int</code>. The second set of parentheses lists the types of the parameters the closure accepts. In total, this means that we are defining a closure called <code class="literal">doubleClosure</code> that accepts <code class="literal">int</code> and returns <code class="literal">int</code>.</p><p>Then, we move on to the business of implementing the closure. All closure implementations start with a carrot symbol followed by any arguments in parentheses and curly brackets with the actual implementation. Once a closure is defined, it can be called similar to any other function. However, you should always be aware that it is possible for a closure to be nil, in which calling it will cause the program to crash.</p><p>It is also possible to define a function or method that accepts a closure as a parameter. First, a function:</p><div><pre class="programlisting">id firstInArrayPassingTest(NSArray *array, BOOL(^test)(id)) {
    for (id element in array) {
        if (test(element)) {
            return element;
        }
    }
    return nil;
}
firstInArrayPassingTest(array, ^BOOL(id test) {
   return false;
});</pre></div><p>Note that the <a class="indexterm" id="id486"/>type <code class="literal">id</code> signifies any Objective-C object and even though it doesn't have an asterisk, it is a reference type. The usage above looks exactly like a standalone block usage. However, the syntax looks somewhat different in a method:</p><div><pre class="programlisting">- (id)firstInArray:(NSArray *)array
    passingTest:(BOOL(^)(id test))test
{
    for (id element in array) {
        if (test(element)) {
            return element;
        }
    }
    return nil;
}
[self firstInArray:array passingTest:^BOOL(id test) {
    return false;
}];</pre></div><p>This is because a method's parameter name is separated by parentheses. This causes the name of the parameter to be moved from being with the carrot to after the parentheses. In the end, we can say that the nuances of the syntax aren't too important when reading Objective-C code and translating to Swift, as long as you recognize that a carrot symbol indicates a block. Many Objective-C programmers look up the syntax of a block on a regular basis.</p><p>All of the same memory concerns exist in Objective-C with blocks. By default, all arguments are captured strongly and the syntax to capture them weakly is much more convoluted. Instead of including the weak captures in the block itself, you must create weak variables outside of the block and use them:</p><div><pre class="programlisting">@interface Ball : NSObject
@property int xLocation;
@property (strong) void (^onBounce)();
@end
@implementation Ball
@end

Ball *ball = [Ball new];
__weak Ball *weakBall = ball;
ball.onBounce = ^{
    NSLog(@"%d", weakBall.xLocation);
};</pre></div><p>Here we use the keyword <code class="literal">__weak</code> (that has two underscores) to indicate that the <code class="literal">weakBall</code> variable should only have a weak reference to <code class="literal">ball</code>. We can then safely reference the <code class="literal">weakBall</code> variable <a class="indexterm" id="id487"/>within the block and not create a circular reference.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Projects</h1></div></div></div><p>Now that <a class="indexterm" id="id488"/>we have a pretty good understanding of Objective-C, let's discuss what Objective-C code looks like in a project. Unlike the Swift code, Objective-C is written in two different types of files. One of the types is called a header file and ends in the extension <code class="literal">h</code>. The other type is called an implementation file and ends in the extension <code class="literal">m</code>.</p><p>Before we <a class="indexterm" id="id489"/>can really discuss what the difference is between the two, we first have to discuss code exposure. In Swift, all the code you write is accessible to all other code in your project. This is not true with Objective-C. In Objective-C, you must explicitly indicate that you want to have access to the code in another file.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Header files</h2></div></div></div><p>The header files<a class="indexterm" id="id490"/> are the types of files that can be included by other files. This means that header files should only contain the interfaces of types. In fact, this is why the separation exists between class interfaces and implementations. Any file can import a header file and that essentially inserts all the code of one file into the file that is importing it:</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "Car.h"

@interface SteeringWheel : NSObject
@property (weak) Car *car;
@end</pre></div><p>This allows us to separate each class into its own file just as we like to do in Swift. The danger is that we must only put code that can be safely imported into headers. If you try to put implementations in a header, you will end up with duplicate implementations for every time you import the header.</p><p>In the preceding example, we actually imported one header file into another. This means that if a different file now includes this header file, it will essentially be importing both header files.</p><p>You will also notice that there are two different ways to import a file. We import foundation with angled brackets and imported our car header with quotes. Angled brackets are used for importing header files from frameworks, while quotes are used for importing header files within the same framework or application.</p><p>A lot of the <a class="indexterm" id="id491"/>time it isn't actually necessary for one header file to include another because all it needs to know about is the existence of the class. If it doesn't need to know any actual details about the class, it can simply indicate that the class exists using the <code class="literal">@class</code> keyword:</p><div><pre class="programlisting">@class Car;

@interface SteeringWheel : NSObject
@property (weak) Car *car;
@end</pre></div><p>Now, the compiler will not complain that it doesn't know what <code class="literal">Car</code> is. However, you will most likely still need to import the car header in the implementation file because you will probably be interacting with some part of that class.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec110"/>Implementation files</h2></div></div></div><p>As you <a class="indexterm" id="id492"/>might have guessed, implementation files are generally for the implementation of your types. These files are not imported into others; they simply fulfill the promises of what the interface files have defined. This means that header and implementation files generally exist in pairs. If you are defining a steering wheel class, you will most likely create a <code class="literal">SteeringWheel.h</code> header and a <code class="literal">SteeringWheel.m</code> implementation file. Any other code that needs to interact with the details of the steering wheel class will import the header and at compile time, the compiler will make all of the implementations available to the running program.</p><p>Implementation files are also a great place to hide private code, because they cannot be imported by other code. Since the code is not visible anywhere else, it is unlikely to be interacted with. This means that people will sometimes add class interfaces to implementation files if their use is localized to just that file. It is also very common to add what is called an anonymous category to an implementation file:</p><div><pre class="programlisting">@interface SteeringWheel ()
@property NSString *somePrivateProperty;
- (void)somePrivateMethod;
@end</pre></div><p>This is considered anonymous because the category was not actually given a name. This means there is no way to pair an implementation directly with that category. Instead, the implementation should be defined within the normal implementation of the class. This provides a great way to define any private properties and methods at the top of an implementation file. You don't technically need to define any private methods because as long as they are implemented in the same file, they can be interacted with. However, it is often nice to have a concise list of the available properties and methods at the top of the file.</p><p>This brings<a class="indexterm" id="id493"/> up another point, that only methods that you intend to use from outside files should be declared in the header. You should always consider a header to be the public interface of your class and it should be as minimal as possible. It is always written from the perspective of outside files. This is the way that Objective-C implements access control. It isn't formally built into the language but the compiler will warn you if you try to interact with code that has not been imported. It is actually still possible to interact with these private interfaces, especially if you duplicate the interface declaration somewhere else, but it is considered best practice to not do that and Apple will actually reject your apps during review if you try to interact with private parts of their API.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec111"/>Organization</h2></div></div></div><p>Other<a class="indexterm" id="id494"/> than the obvious difference, the Objective-C projects will have two different types of files. They are organized in the exact same way as Swift files. It is still considered to be a good practice to create folders to group related files together. Most of the time you will want to keep header file and implementation file pairs together, as people will be switching between the two types of files a lot. However, people can also use the keyboard shortcuts <em>Control</em>/<em>Command</em> up arrow or <em>Control</em>/<em>Command</em> down arrow to quickly swap between a header file and its implementation file.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Calling Objective-C code from Swift</h1></div></div></div><p>The <a class="indexterm" id="id495"/>last and possibly the most critical component of understanding Objective-C for our purpose is to be able to call Objective-C code from Swift. This is actually pretty straightforward in most circumstances. We will not take any time to discuss calling Swift code from Objective-C because this book assumes that you are only writing Swift code.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec112"/>Bridging header</h2></div></div></div><p>The <a class="indexterm" id="id496"/>most important part of being able to call Objective-C code from Swift is how to make the code visible to Swift. As we now know, Objective-C code needs to be imported to be visible to other code. This still holds true with Swift, but Swift has no mechanism to import individual files. Instead, when you add your first Objective-C code to a Swift project, Xcode is going to ask you if you want to add what is called a <a class="indexterm" id="id497"/>
<strong>bridging header</strong>:</p><div><img alt="Bridging header" src="img/B05103_10_01.jpg"/></div><p>You should <a class="indexterm" id="id498"/>select <strong>Yes</strong> and then Xcode will automatically create a header file named after the project ending in <code class="literal">Bridging-Header.h</code>. This is the file where you need to import any Objective-C headers that you want to expose to Swift. It will just be a file with a list of imports. You still do not need to import any of the implementation files.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Using functions</h1></div></div></div><p>After you <a class="indexterm" id="id499"/>have exposed the headers to Swift, it is very <a class="indexterm" id="id500"/>simple to call functions. You can simply call the functions directly as if they didn't have parameter names:</p><div><pre class="programlisting">NSArray *addInviteeToListIfSpotAvailable
     (
     NSArray *invitees,
     NSString *newInvitee
     );
addInviteeToListIfSpotAvailable(inviteeList, "Sarah")</pre></div><p>Xcode will even autocomplete the code for you. From your Swift files point of view, there is no way to know if that function is implemented in Objective-C or Swift.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Using types</h2></div></div></div><p>You can <a class="indexterm" id="id501"/>use types the same way you use functions. Once the proper header files are imported in the bridging header, you can just use the type as if it were a Swift type:</p><div><pre class="programlisting">@interface Contact : NSObject
@property NSString *firstName;
@property NSString *lastName;
- (NSArray *)addToInviteeList:(NSArray *)invitees includeLastName:(BOOL)include;
@end
var contact = Contact()
contact.firstName = "First"
contact.lastName = "Last"
contact.addToInviteeList(inviteeList, includeLastName: false)</pre></div><p>Again, from <a class="indexterm" id="id502"/>Swift's point of view, there is absolutely no difference between how we write the code that uses our Objective-C class and how we would write it if the class were implemented in Objective-C. We were even able to call the <code class="literal">addToInviteeList:includeLastName:</code> method with the same parameter names. This makes it even more clear that Swift was designed with backwards compatibility in mind.</p><p>The only real restrictions are that all classes defined in Objective-C are still going to inherit from <code class="literal">NSObject</code> and Objective-C enumerations aren't going to translate perfectly into Swift enumerations. Instead, they are still exposed as individual constants:</p><div><pre class="programlisting">typedef enum {
    PrimaryColorRed,
    PrimaryColorGreen,
    PrimaryColorBlue,
} PrimaryColor;
var color: PrimaryColor = PrimaryColorRed</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec114"/>Containers</h2></div></div></div><p>You may <a class="indexterm" id="id503"/>have also noticed that the <code class="literal">NSString</code> and <code class="literal">NSArray</code> types seem to translate transparently to <code class="literal">String</code> and <code class="literal">Array</code> classes in the preceding code. This is another wonderful feature of the bridge between Swift and Objective-C. These types, as well as dictionaries, translate almost perfectly. The only difference is that since Objective-C does require an element type when defining a container, they are translated into Swift as containing objects of type <code class="literal">AnyObject</code>. If you want to treat them as a more specific type, you will have to cast them:</p><div><pre class="programlisting">inviteeList = contact.addToInviteeList(
    inviteeList,
    includeLastName: false
    ) as! [String]</pre></div><p>The actual return value of this method when translated to Swift is <code class="literal">[AnyObject]!</code>. Therefore, if you are sure that the method never returns nil and always returns an array of <code class="literal">Strings</code>, it is safe to do the forced casting that we did above. Otherwise, you should still check for nil and do an optional casting (<code class="literal">as?</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Annotations</h2></div></div></div><p>You will <a class="indexterm" id="id504"/>note that this acts as a pattern when Objective-C types <a class="indexterm" id="id505"/>are translated to Swift. Any reference type is going to be translated, by default, to an implicitly unwrapped optional because of the nature of Objective-C reference types. The compiler can't automatically know if the value returned could be nil or not, so it doesn't know if it should be translated as a regular optional or a non-optional. However, Objective-C developers can add annotations to let the compiler know if a value can be nil or not.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec30"/>Nullability</h3></div></div></div><p>The first <a class="indexterm" id="id506"/>thing Objective-C developers can add annotations for is whether a specific variable can be null or not:</p><div><pre class="programlisting">- (NSArray * __nonnull)addToInviteeList:
        (NSArray * __nullable)invitees;</pre></div><p>The <code class="literal">__nonnull</code> keyword indicates that it cannot be nil, so it will be translated in Swift to a non-optional and the <code class="literal">__nullable </code>keyword indicates that it can be nil, so in Swift it will translated to a regular optional.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec31"/>Container element types</h3></div></div></div><p>Objective-C developer <a class="indexterm" id="id507"/>can also annotate their container types to say what type they contain. For this, use the angled brackets just like Swift:</p><div><pre class="programlisting">- (NSArray&lt;NSString *&gt; * __nonnull)addStringToInviteeList:
        (NSArray&lt;NSString *&gt; * __nullable)invitees;</pre></div><p>Now, this method will really work just like Swift methods in that it will take an optional array of strings and return a non-optional array of strings; there will be no casting necessary:</p><div><pre class="programlisting">inviteeList = contact.addStringToInviteeList(inviteeList)</pre></div><p>If you have control over the Objective-C code you are importing then you may want to add it. Otherwise, you might be able to ask the developer of the code to add the annotations to make your Swift coding much easier and more clean.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Summary</h1></div></div></div><p>While Swift is the hot new language right now in the Apple development community, there is no immediate sign that Objective-C is getting replaced fully. All of Apple's APIs are still written in Objective-C and it would be a lot of work for Apple to rewrite them, if they even wanted to. Apple definitely designed Swift to be able to live alongside Objective-C, so for now we have to assume that Objective-C is here to stay. This makes understanding and being able to interact with Objective-C very valuable, even as a Swift developer.</p><p>In this chapter, we have gotten an overview of the most pertinent Objective-C features and syntax from the point of view of a primarily Swift developer. We have learned how Swift is basically a part of a long line of evolving languages. It was heavily influenced by Apple's desire to make it backwards compatible with Objective-C and Objective-C was actually an evolution of C which was an evolution of Assembly and so on. Objective-C is still a powerful language with the ability to express many of the same concepts as Swift. Objective-C has similar concepts of constants and variables with more of a stress on variables. It also has the same basic containers but control flow is slightly different in the two languages. Swift has more powerful switches and ranges, but the underlying concepts are still very much the same. Functions are almost identical between the two languages but the type system in Objective-C is somewhat more limited because it can only express classes unlike Swift which has a powerful concept of classes, structures, and enumerations. Structures and enumerations still exist in Objective-C, but they really come directly from C and can do a lot less. Finally, we saw that organizing Objective-C in a project is very much the same and calling Objective-C code from Swift is actually quite straightforward.</p><p>There is some debate in the Apple developer community about how relevant Objective-C will be moving forward. There are people that have jumped into Swift development full time and there are others that are waiting for Swift to mature even more before they commit energy to truly learning it. However, there is little debate over the fact that Objective-C knowledge is still going to be relevant for a while, most notably because of the vast resources that exist and the fact that all existing Apple APIs are written in Objective-C. We will put those APIs to use in our next chapter: <a class="link" href="ch11.html" title="Chapter 11. A Whole New World – Developing an App">Chapter 11</a>, <em>A Whole New World – Developing an App</em>, when we will finally dive into some real app development.</p></div></body></html>