- en: Functional Programming with Kotlin and RxKotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 和 RxKotlin 进行函数式编程
- en: Functional programming paradigms are slightly different than that of **Object-oriented
    programming** (**OOP**). It focuses on the use of declarative and expressive programs
    and immutable data rather than on statements. The definition of functional programming
    says *functional programming is a programming system that relies on structuring
    the program as the evaluation of mathematical functions with immutable data, and
    it avoids state-change*. It is a declarative programming paradigm that suggests
    use of small, reusable declarative functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式与面向对象编程（**OOP**）略有不同。它侧重于使用声明性和表达性的程序以及不可变数据，而不是语句。函数式编程的定义指出：“函数式编程是一种编程系统，它依赖于将程序结构化为不可变数据的数学函数的评估，并避免状态改变。”它是一种声明性编程范式，建议使用小型、可重用的声明性函数。
- en: We have seen the definition of functional programming; now, don't you want to
    delve into its definition and see what it exactly means? Do all languages support
    functional programming? If not, then which languages does and what about Kotlin?
    What exactly does reactive programming have to do with functional programming?
    And, finally, what do we need to learn, for functional programming?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了函数式编程的定义；现在，你难道不想深入了解它的定义，看看它究竟意味着什么吗？所有语言都支持函数式编程吗？如果不是，那么哪些语言支持，Kotlin
    又如何呢？响应式编程与函数式编程究竟有什么关系？最后，我们需要学习什么，才能进行函数式编程？
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程入门
- en: Relationship of functional programming with reactive programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程与响应式编程的关系
- en: The path breaking feature of Kotlin–coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 的突破性特性——协程
- en: Introducing functional programming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍函数式编程
- en: So, functional programming wants you to distribute your programming logic into
    small pieces of reusable declarative small and pure functions. Distributing your
    logic into small pieces of code will make the code modular and non-complex, thus
    you will be able to refactor/change any module/part of the code at any given point
    without any effects to other modules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数式编程希望您将编程逻辑分布到可重用的声明性小函数中。将您的逻辑分布到小块代码中会使代码模块化且不复杂，因此您可以在任何给定点重构/更改任何模块/代码的一部分，而不会对其他模块产生影响。
- en: 'Functional programming requires some interfaces and support from the language,
    thus we can''t say any language is functional unless it gives some sort of support
    to implement functional programming. However, functional programming isn''t something
    new; it is actually quite an old concept and has several languages supporting
    it. We call those languages functional programming languages, and the following
    is a list of some of the most popular functional programming languages:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程需要一些接口和语言的支持，因此我们不能说任何语言都是函数式的，除非它提供某种支持来实现函数式编程。然而，函数式编程并不是什么新事物；实际上，它是一个相当古老的概念，并且有几种语言支持它。我们称这些语言为函数式编程语言，以下是一些最受欢迎的函数式编程语言的列表：
- en: Lisp
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp
- en: Clojure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure
- en: Wolfram
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wolfram
- en: Erlang
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erlang
- en: OCaml
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCaml
- en: Haskell
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell
- en: Scala
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala
- en: F#
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#
- en: Lisp and Haskell are some of the oldest languages and are still used today in
    academia and industry. While talking about Kotlin, it has excellent support for
    functional programming from its first stable release in contrast to Java, which
    doesn't have any support for functional programming before Java 8\. You can use
    Kotlin in both object-oriented and functional-programming style or even in a mix
    of two, which is really a great benefit for us. With a first-class support for
    features, such as higher-order functions, function types, and lambdas, Kotlin
    is a great choice if you're doing or exploring functional programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 和 Haskell 是一些最古老的语言，并且至今仍在学术界和工业界中使用。当谈到 Kotlin 时，它从第一个稳定版本开始就提供了对函数式编程的出色支持，与
    Java 相比，Java 在 Java 8 之前没有任何对函数式编程的支持。你可以在面向对象和函数式编程风格之间，甚至两种风格的混合中使用 Kotlin，这对我们来说真的是一个巨大的好处。Kotlin
    对诸如高阶函数、函数类型和lambda等特性提供了第一级支持，如果你正在做或探索函数式编程，Kotlin 是一个不错的选择。
- en: The concept of **functional reactive programming** (**FRP**) is actually a product
    of mixing reactive programming with functional programming. The main objective
    of writing functional programming is to implement modular programming; this modular
    programming is really helpful, or sometimes a necessity to implement reactive
    programming or rather to implement the four principles of the Reactive Manifesto.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式响应式编程**（FRP）的概念实际上是将响应式编程与函数式编程相结合的产物。编写函数式编程的主要目的是实现模块化编程；这种模块化编程对于实现响应式编程或更确切地说，实现响应式宣言的四个原则非常有帮助，有时甚至是必需的。'
- en: Fundamentals of functional programming
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程基础
- en: Functional programming consists of few new concepts such as lambdas, pure functions,
    high-order functions, function types, and inline functions, which we will be learning.
    Quite interesting, isn't it?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程包含一些新的概念，如 Lambda、纯函数、高阶函数、函数类型和内联函数，我们将学习这些内容。非常有趣，不是吗？
- en: Note that, although in many programmers word, pure functions and lambdas are
    the same, they are actually not. In the following part of this chapter, we will
    learn more about them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在许多程序员的词汇中，纯函数和 Lambda 是相同的，但实际上它们并不相同。在本章的后续部分，我们将了解更多关于它们的内容。
- en: Lambda expressions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'Lambda or lambda expressions generally mean *anonymous functions*, that is,
    functions without names. You can also say a lambda expression is a function, but
    not every function is a lambda expression. Not every programming language provides
    support for lambda expressions, for instance, Java didn''t have it until Java
    8\. The implementations of lambda expressions are also different in respect to
    languages. Kotlin has good support for lambda expressions and implementing them
    in Kotlin is quite easy and natural. Let''s now take a look at how lambda expressions
    work in Kotlin:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 或 Lambda 表达式通常意味着 *匿名函数*，即没有名称的函数。你也可以说 Lambda 表达式是一个函数，但并非每个函数都是 Lambda
    表达式。并非每种编程语言都支持 Lambda 表达式，例如，Java 直到 Java 8 才有这个功能。Lambda 表达式的实现也因语言而异。Kotlin
    对 Lambda 表达式有很好的支持，在 Kotlin 中实现它们既简单又自然。现在让我们看看 Kotlin 中 Lambda 表达式是如何工作的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding program, in comment `(1)`, we declare a lambda expression that
    will add two numbers and return the `sum` as result; in comment `(2)`, we call
    that function and print it; in comment `(3)`, we declare another lambda that will
    multiply a random number bound to `15` with the value `x` passed to it and return
    the result; in comment `(4)`, we, again, print it. Both the lambda expressions
    are actually functions, but without any function name; thus they are also referred
    to as an anonymous function. If you compare with Java, Java has a feature of anonymous
    class, but included lambda/anonymous functions only after Java 8.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，在注释（1）中，我们声明了一个 Lambda 表达式，该表达式将两个数字相加并返回结果 `sum`；在注释（2）中，我们调用该函数并打印它；在注释（3）中，我们声明了另一个
    Lambda，它将随机数与 `15` 绑定并乘以传递给它的值 `x`，然后返回结果；在注释（4）中，我们再次打印它。这两个 Lambda 表达式实际上都是函数，但没有函数名；因此，它们也被称为匿名函数。如果你与
    Java 比较，Java 有匿名类的功能，但直到 Java 8 才包含 lambda/匿名函数。
- en: 'If you are curious about the output, then refer to the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇输出结果，请参考以下截图：
- en: '![](img/89439c0a-af28-49ca-873c-7d67b118c364.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89439c0a-af28-49ca-873c-7d67b118c364.jpg)'
- en: Pure function
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'The definition of pure function says that *if the return value of a function
    is completely dependent on its arguments/parameters, then this function may be
    referred to as a pure function*. So, if we declare a function as `fun func1(x:Int):Int`,
    then its return value will be strictly dependent on its argument `x`; say, if
    you call `func1` with a value of `3` twice, then, for both the times, its return
    value will be the same. A pure function can be a lambda or a named function as
    well. In the previous example, the first lambda expression was a pure function
    but not the second one, as for the second one, its return value can be different
    at different times with the same value passed to it. Let''s look at the following
    example to understand it better:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的定义是，如果函数的返回值完全依赖于其参数/输入，那么这个函数可以被称为纯函数。所以，如果我们声明一个函数为 `fun func1(x:Int):Int`，那么它的返回值将严格依赖于其参数
    `x`；比如说，如果你两次调用 `func1` 并传入值 `3`，那么两次的返回值将是相同的。纯函数可以是 Lambda 或命名函数。在前面的例子中，第一个
    Lambda 表达式是一个纯函数，但第二个不是，因为对于第二个来说，即使传入相同的值，其返回值也可能在不同时间不同。让我们看看以下例子来更好地理解它：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both the functions, `(1)` and `(2)`, here are pure functions–one is named, while
    the other is lambda. If you pass the value `3` to any of the functions `n` times,
    their return value will be the same for each time. Pure functions don't have side
    effects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个函数，`(1)`和`(2)`，都是纯函数——一个是命名的，而另一个是lambda。如果你将值`3`传递给任一函数`n`次，它们的返回值在每次都会相同。纯函数没有副作用。
- en: '**Side effects**: A function or expression is said to have a side effect if
    it modifies some state outside its scope or has an observable interaction with
    its calling functions or the outside world besides returning a value.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**：如果一个函数或表达式修改了其作用域之外的状态，或者除了返回值之外还有可观察的与调用函数或外部世界的交互，那么它就被说成有副作用。'
- en: Source–Wikipedia [https://en.wikipedia.org/wiki/Side_effect_(computer_science)](https://en.wikipedia.org/wiki/Side_effect_(computer_science)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 来源-Wikipedia [https://en.wikipedia.org/wiki/Side_effect_(computer_science)](https://en.wikipedia.org/wiki/Side_effect_(computer_science))。
- en: It is to note that, as we said earlier, pure functions have nothing to do with
    lambda expressions, their definitions are completely different.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，正如我们之前所说的，纯函数与lambda表达式无关，它们的定义完全不同。
- en: 'The following is the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: High-order functions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'Those functions that take another function as an argument or return a function
    as result are called **high-order functions**. Consider the following example
    to understand it better:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那些接受另一个函数作为参数或返回函数作为结果的函数被称为**高阶函数**。考虑以下示例以更好地理解它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this program, we've declared a `highOrderFunc` function, which will take
    an `Int` and a `validityCheckFunc(Int)` function. We are calling the `validityCheckFunc`
    function inside the `highOrderFunc` function, to check whether the value was valid
    or not. However, we are defining the `validityCheckFunc` function at runtime,
    while we are calling the `highOrderFunc` function inside the `main` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们声明了一个`highOrderFunc`函数，它将接受一个`Int`和一个`validityCheckFunc(Int)`函数。我们在`highOrderFunc`函数内部调用`validityCheckFunc`函数，以检查值是否有效。然而，我们在调用`main`函数内部的`highOrderFunc`函数时定义了`validityCheckFunc`函数。
- en: Note that the `isEven` function in this program is an extension function that
    has been defined inside the `project` files you got with the book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个程序中，`isEven`函数是一个扩展函数，它是在你与书一起获得的`project`文件内部定义的。
- en: 'Here is the output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inline functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联函数
- en: 'While functions are a great way to write modular code, it may sometimes increase
    program execution time and reduce memory optimization due to function stack maintenance
    and overhead. Inline functions are a great way to avoid those hurdles in functional
    programming. For example, see the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数是编写模块化代码的绝佳方式，但它有时可能会因为函数栈维护和开销而增加程序执行时间并减少内存优化。内联函数是避免函数式编程中这些障碍的绝佳方法。例如，请参见以下代码片段：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's recite the definition of inline function; it says that *inline functions
    are an enhancement feature to improve the performance and memory optimization
    of a program*. Functions can be instructed to the compiler to make them inline
    so that the compiler can replace those function definitions wherever those are
    being called. Compiler replaces the definition of inline functions at compile
    time instead of referring function definition at runtime; thus, no extra memory
    is needed for a function call, stack maintenance, and more, and getting the benefits
    of functions as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下内联函数的定义；它说，*内联函数是提高程序性能和内存优化的增强功能*。函数可以被指示给编译器，使其成为内联函数，这样编译器就可以在函数被调用的任何地方替换这些函数定义。编译器在编译时替换内联函数的定义，而不是在运行时引用函数定义；因此，不需要为函数调用、栈维护等额外内存，同时还能获得函数的好处。
- en: 'The preceding program declares a function that adds two numbers and returns
    the result, and we will call the function in the loop. Instead of declaring a
    function for this, we can write the addition code right in the place where we
    will call the function, but declaring a function gives us freedom to modify the
    addition logic anytime without any effect on the remaining code, for example,
    if we want to modify the addition with multiplication or something else. If we
    declare a function as inline, then the code inside that function will replace
    all the function calls, thus improving performance while keeping our freedom intact.
    Consider the following code snippet as an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序声明了一个函数，用于添加两个数字并返回结果，我们将在循环中调用这个函数。而不是为这个目的声明一个函数，我们可以在将要调用函数的地方直接编写加法代码，但声明一个函数让我们可以在不影响剩余代码的情况下随时修改加法逻辑，例如，如果我们想修改加法为乘法或其他操作。如果我们将函数声明为内联的，那么该函数内部的代码将替换所有的函数调用，从而在保持自由度的同时提高性能。以下代码片段作为例子：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output of the program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出结果：
- en: '![](img/c9bc3123-9667-4acf-a4ff-d8ec701d34d0.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9bc3123-9667-4acf-a4ff-d8ec701d34d0.jpg)'
- en: 'There is one more feature Kotlin provides with inline functions–if you declare
    a high-order function as `inline`, then the `inline` keyword affects both the
    function itself and the lambda passed to it. Let''s modify the high-order function
    code with `inline`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin通过内联函数提供的一个额外功能是，如果你将一个高阶函数声明为`inline`，那么`inline`关键字将影响该函数本身以及传递给它的lambda。让我们用`inline`修改高阶函数的代码：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler will replace all calls to `validityCheckFunc` with its lambda,
    as it would do with `highOrderFuncInline` with its definition. As you can see,
    there's not much modification of the code, just a small change of adding `inline`
    before a function declaration can improve performance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将用其lambda替换所有对`validityCheckFunc`的调用，就像它会对具有定义的`highOrderFuncInline`做的那样。正如你所见，代码的修改并不多，只是在函数声明前添加了`inline`关键字，就能提高性能。
- en: Applying functional programming to the ReactiveCalculator class
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数式编程应用于`ReactiveCalculator`类
- en: 'So, now, after trying to understand the `ReactiveCalculator` class from the
    previous chapter, we will try to optimize the code as well. Let''s first take
    a look at the `init` block of the `ReactiveCalculator` class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，在尝试理解上一章中的`ReactiveCalculator`类之后，我们将尝试优化代码。让我们首先看看`ReactiveCalculator`类的`init`块：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, now, with the knowledge of functional programming, we can easily say that
    the `map` and `subscribe` methods are high-order functions that take function
    as parameter. However, do you really think that many `subject` and subscriber
    are required? Shouldn''t subscriber on the class be sufficient to accomplish the
    job itself? Let''s try to modify and optimize the following piece of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，有了函数式编程的知识，我们可以轻松地说，`map`和`subscribe`方法是接受函数作为参数的高阶函数。然而，你真的认为需要很多`subject`和`subscriber`吗？类上的`subscriber`不就足够完成这项工作了吗？让我们尝试修改和优化以下代码片段：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we have removed all other `subscriber` and are doing the job with only
    one. And here''s the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们移除了所有其他的`subscriber`，只用一个来完成工作。以下是输出结果：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We subscribe to the class object itself; so, whenever its variables get changed,
    we get notified, and we perform all the tasks right there in the `subscribe` method.
    Moreover, as we have made the functions inline, they'll also help in the optimization
    of performance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅了类本身；因此，每当其变量发生变化时，我们会收到通知，并在`subscribe`方法中直接执行所有任务。此外，由于我们已经将函数声明为内联的，它们还将有助于性能优化。
- en: Coroutines
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Path breaking and, probably, the most exciting feature in Kotlin are coroutines.
    They are a new way to write asynchronous, non-blocking code somewhere like the
    threads, but way more simple, efficient, and lightweight. Coroutines were added
    in Kotlin 1.1 and are still experimental, so think before using it in production.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 路径突破，可能是Kotlin中最令人兴奋的功能是协程。它们是编写异步、非阻塞代码的新方法，类似于线程，但更简单、更高效、更轻量级。协程是在Kotlin
    1.1中添加的，并且仍然是实验性的，所以在生产环境中使用之前请三思。
- en: In the later chapters of this book, you'll learn about Schedulers in RxKotlin,
    which encapsulates the complexities of threading, but you can use it only in RxKotlin
    chain, while you can use coroutines anywhere and everywhere. That is indeed a
    path-breaking feature of Kotlin. They provide a great abstraction on threads,
    making context changes and concurrency easier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，你将了解 RxKotlin 中的调度器，它封装了线程的复杂性，但你只能在 RxKotlin 链中使用它，而协程可以在任何地方和任何时候使用。这确实是
    Kotlin 的一个突破性特性。它们在线程上提供了很好的抽象，使得上下文变化和并发变得更容易。
- en: Keep in mind that RxKotlin does not use coroutines yet; the reason is quite
    simple–both coroutines and Schedulers in RxKotlin share nearly the same internal
    architecture; while coroutines are new, Schedulers have been there for a long
    time with RxJava, RxJs, RxSwift, and more.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，RxKotlin 目前还没有使用协程；原因很简单——协程和 RxKotlin 中的调度器几乎具有相同的内部架构；虽然协程是新的，但调度器在 RxJava、RxJs、RxSwift
    以及更多中已经存在很长时间了。
- en: Coroutines are the best fit for developers to implement concurrency when they're
    not using/can't use RxKotlin Schedulers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是开发者在不使用/无法使用 RxKotlin Schedulers 时实现并发的最佳选择。
- en: 'So, let''s start by adding it to our project. If you are using Gradle, follow
    these steps (`apply plugin` could be `''kotlin''` or `''kotlin-android''`, depending
    on whether you use it for JVM or Android):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先将其添加到我们的项目中。如果你正在使用 Gradle，请按照以下步骤操作（`apply plugin` 可以是 `'kotlin'` 或
    `'kotlin-android'`，具体取决于你是否用于 JVM 或 Android）：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And then, we have to add the following dependency:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加以下依赖项：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you are using Maven, then add the following code block in the `pom.xml`
    file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Maven，那么请在 `pom.xml` 文件中添加以下代码块：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Apache Maven is a software project management and comprehension tool. Based
    on the concept of a **Project Object Model** (**POM**), Maven can manage a project's
    build, reporting, and documentation from a central piece of information. Please
    refer to the following URL for more information–[https://maven.apache.org/](https://maven.apache.org/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Maven 是一个软件项目管理与理解工具。基于**项目对象模型**（**POM**）的概念，Maven 可以从中央信息点管理项目的构建、报告和文档。请参考以下网址获取更多信息–[https://maven.apache.org/](https://maven.apache.org/)。
- en: So, what exactly is a coroutine? While developing applications, we often come
    into situations where we need to perform long running or time taking operations,
    such as network call, database operations, or some complex computations. The only
    option in Java is to use a thread to handle such situations, which is very complex
    itself. Whenever we face those situations, we feel the need for a simple yet powerful
    API to handle such cases. Developers from the .NET domain, especially those who
    used C# before, are familiar with the `async`/`await` operators; this is somehow
    the closest to Kotlin coroutines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，协程究竟是什么？在开发应用程序时，我们经常遇到需要执行长时间运行或耗时操作的情况，例如网络调用、数据库操作或一些复杂的计算。Java 中处理这种情况的唯一选项是使用线程，而这本身就是一个非常复杂的过程。每当面对这些情况时，我们都感到需要一种简单而强大的
    API 来处理这些情况。来自 .NET 领域的开发者，尤其是那些之前使用过 C# 的开发者，对 `async`/`await` 操作符很熟悉；这某种程度上与
    Kotlin 协程最为接近。
- en: Getting started with coroutines
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用协程
- en: 'So, let''s take the following example into consideration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑以下示例：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will inspect through the code, but let''s first see the output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查代码，但首先让我们看看输出结果：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, now, let''s understand the code. On comment `(1)`, while declaring the
    function, we mark the function with the `suspend` keyword, which is used to mark
    a function as suspending, that is, while executing the function the program should
    wait for its result; therefore, execution of suspending a function in main thread
    is not allowed (giving you a clear barrier between main thread and suspending
    functions). On comment `(2)`, we started a block with `measureTimeMillis` and
    assigned its value to the (`val`) `time` variable. The job of `measureInMillis`
    is quite simple–it executes the block passed to it while measuring its execution
    time, and returns the same. We will use the `delay` function on comment `(3)`
    to intentionally delay the program execution by `2` seconds. The `runBlocking`
    block in the `main` function on comment `(4)` makes the program wait until the
    called `longRunningTsk` function on comment `(5)` completes. So, this was a quite
    simple example; however, we are making the main thread wait here. Sometimes, you
    will not want this; instead, you will want to do asynchronous operations. So,
    let''s try to achieve this as well:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们来理解代码。在注释（1）中，当我们声明函数时，我们使用`suspend`关键字标记函数，这个关键字用来标记一个函数为挂起状态，即当执行函数时，程序应该等待其结果；因此，不允许在主线程中挂起函数（这为你提供了主线程和挂起函数之间清晰的障碍）。在注释（2）中，我们使用`measureTimeMillis`启动了一个代码块，并将其值赋给了`val`类型的`time`变量。`measureInMillis`的功能相当简单——它执行传递给它的代码块，同时测量其执行时间，并返回相同的值。我们将在注释（3）中使用`delay`函数故意延迟程序执行2秒钟。在注释（4）中的`main`函数中的`runBlocking`代码块使程序等待直到注释（5）中调用的`longRunningTsk`函数完成。所以，这是一个相当简单的例子；然而，我们在这里使主线程等待。有时，你可能不希望这样；相反，你可能想要进行异步操作。所以，让我们也尝试实现这一点：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we kept `longRunningTsk` same, just modified the `main` function. On comment
    `(1)`, we assigned the `time` variable to the value of `longRunningTsk` inside
    the `async` block. The `async` block is quite interesting; it executes the code
    inside its block asynchronously on the coroutine context passed to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持`longRunningTsk`不变，只是修改了`main`函数。在注释（1）中，我们将`time`变量赋值给`async`代码块内部的`longRunningTsk`。`async`代码块非常有趣；它在传递给它的协程上下文中异步执行其代码块内的代码。
- en: There are basically three types of coroutine contexts. `Unconfined` means it'll
    run on the main thread, `CommonPool` runs on the common thread pool, or you can
    create a new coroutine context as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有三种协程上下文类型。`Unconfined`表示它将在主线程上运行，`CommonPool`在公共线程池上运行，或者你也可以创建一个新的协程上下文。
- en: On comment `(2)` we run a blocking code that will make the `main` function wait
    until the value of the `time` variable is available; the `await` function helps
    us accomplish this task–it tells the `runBlocking` block to wait until the `async`
    block completes execution to make the value of `time` available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释（2）中，我们运行了一个阻塞代码，这将使`main`函数等待直到`time`变量的值可用；`await`函数帮助我们完成这个任务——它告诉`runBlocking`代码块等待直到`async`代码块完成执行，以便`time`变量的值可用。
- en: Building sequences
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建序列
- en: As I mentioned earlier, Kotlin coroutines are something more than threads in
    Java and `async`/`await` in C#. Here is a feature that, after learning, you will
    be pissed that it was not there while you were learning to code. To add icing
    on the cake, this feature is application level, it is even shipped with `kotlin-stdlib`,
    so you can use it right there without doing anything or even using coroutines
    explicitly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，Kotlin协程不仅仅是Java中的线程和C#中的`async`/`await`。这是一个在学习后你会感到愤怒的功能，因为它在你学习编码时并不存在。为了锦上添花，这个功能是应用级别的，它甚至包含在`kotlin-stdlib`中，所以你可以在那里直接使用，无需做任何事情，甚至无需显式使用协程。
- en: 'Before learning what I am talking about, let''s do some old school code, say
    the fibonacci series? Consider the following piece of code as an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习我所说的内容之前，让我们做一些老式的代码，比如说斐波那契数列？以下代码块作为例子：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, this is the old-school fibonacci series program in Kotlin. This code becomes
    more problematic when you plan to take the user input for how many numbers to
    print. What if I say Kotlin has a `buildSequence` function that can do this task
    for you, that too pretty naturally and in a simpler way? So, let''s modify the
    code now:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是用Kotlin编写的老式斐波那契数列程序。当你计划让用户输入要打印的数字数量时，这段代码会变得更有问题。如果我告诉你Kotlin有一个`buildSequence`函数可以为你完成这个任务，而且做得非常自然，方式也更简单？所以，现在让我们修改代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output for both the programs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对两个程序输出的描述：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let's understand the program. On comment `(1)`, we declare `val fibonacciSeries`
    to be filled up by the `buildSequence` block. Whenever we have computed some value
    to output to the sequence/series, we will yield that value (in comment `2` and
    `3`). On comment `4`, we call `fibonacciSeries` to compute up to the `10`^(th)
    variable and join elements of the sequence with a comma (`,`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解这个程序。在注释（1）中，我们声明`val fibonacciSeries`由`buildSequence`块填充。每当我们在序列/数列中计算出一个要输出的值时，我们将输出那个值（在注释`2`和`3`中）。在注释`4`中，我们调用`fibonacciSeries`来计算到第`10`个变量，并用逗号（`,`）连接序列的元素。
- en: So, you learned coroutine; now, let's implement it into our program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你学习了协程；现在，让我们将其实现到我们的程序中。
- en: The ReactiveCalculator class with coroutines
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有协程的`ReactiveCalculator`类
- en: 'So far, in the `ReactiveCalculator` program, we were performing everything
    on the same thread; don''t you think we should rather do the things asynchronously?
    So, let''s do it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在`ReactiveCalculator`程序中，我们都在同一个线程上执行所有操作；你不认为我们应该异步地做这些事情吗？所以，让我们这样做：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On comment `(1)`, we will declare the `handleInput` function as suspending,
    which tells the JVM that this function is supposed to take longer, and the execution
    of the context calling this function should wait for it to complete. As I already
    mentioned earlier, suspending functions cannot be called in the main context;
    so, on comment `(2)`, we created an `async` block to call the function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释（1）中，我们将`handleInput`函数声明为挂起，这告诉JVM这个函数应该需要更长的时间，调用此函数的上下文执行应该等待它完成。正如我之前已经提到的，挂起函数不能在主上下文中调用；所以，在注释（2）中，我们创建了一个`async`块来调用这个函数。
- en: Functional programming – monads
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程 – 单子
- en: 'Functional programming is incomplete without monads. If you are into functional
    programming, then you know it very well; otherwise, you are hearing it for the
    first time. So, what is a monad? Let''s learn about it. The concept of monad is
    quite abstract; the definition says *monad is a structure that creates a new type
    by encapsulating a value and adding some extra functionalities to it*. So, let''s
    start by using a monad; take a look at the following program:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程没有单子是不完整的。如果你对函数式编程感兴趣，那么你非常了解它；否则，你可能是第一次听说。那么，什么是单子呢？让我们来了解一下。单子的概念相当抽象；定义说“单子是一个结构，通过封装一个值并添加一些额外的功能来创建一个新的类型”。所以，让我们先使用单子；看看下面的程序：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `Maybe` is a monad that encapsulates an `Int` value with some added functionalities.
    The `Maybe` monad says it may or may not contain a value, and it completes with
    or without a value or with an error. So, if there's an error, then it would obviously
    call `onError`; if there are no errors, and if it has a value, it will call `onSuccess`
    with the value; and, if it doesn't have a value and no error as well, it will
    call `onComplete`. The thing to note is that all three methods here, `onError`,
    `onComplete`, and `onSuccess`, are terminal methods, meaning either one of these
    three will get called by a `Maybe` monad, and others will never be called.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Maybe`是一个封装了`Int`值并添加了一些额外功能的单子。`Maybe`单子表示它可能包含或不包含值，并且可以带或不带值或错误完成。所以，如果有错误，那么它显然会调用`onError`；如果没有错误，并且它有一个值，它将使用该值调用`onSuccess`；如果没有值也没有错误，它将调用`onComplete`。需要注意的是，这里的三个方法`onError`、`onComplete`和`onSuccess`都是终止方法，这意味着这三个中的任何一个都可能被`Maybe`单子调用，而其他的方法将永远不会被调用。
- en: 'Let''s go through the program to understand the monads better. On comment `(1)`,
    we will declare a `Maybe` monad and assign a value of `14` to it. On comment `(2)`,
    we will subscribe to the monad. On comment `(3)`, we will again declare a `Maybe`
    monad, this time with an empty value. The subscription takes three lambdas as
    parameter–when the monad contains a value, `onSuccess` gets called; when it doesn''t
    contain any value, `onComplete` gets called; and if any error occurs, then `onError`
    gets called. Let''s see the output now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析程序，以便更好地理解单子。在注释（1）中，我们将声明一个`Maybe`单子并将其赋值为`14`。在注释（2）中，我们将订阅这个单子。在注释（3）中，我们再次声明一个`Maybe`单子，这次赋予一个空值。订阅需要三个lambda表达式作为参数——当单子包含一个值时，`onSuccess`会被调用；当它不包含任何值时，`onComplete`会被调用；如果发生任何错误，则`onError`会被调用。现在让我们看看输出结果：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, as we can see, for `maybeValue`, `onSuccess` gets called, but for `maybeEmpty`
    , the `onComplete` method gets called.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，对于`maybeValue`，`onSuccess`被调用，但对于`maybeEmpty`，`onComplete`方法被调用。
- en: Single monad
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一单子
- en: '`Maybe` is just another type of monad, there are a lot more; we will cover
    a few of the most important ones in later chapters, and combine them with reactive
    programming as well.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 只不过是另一种类型的单子，还有很多；我们将在后面的章节中介绍其中一些最重要的，并将它们与响应式编程结合起来。'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about functional programming. If you grasped the
    concept of functional programming well enough, the puzzles for reactive programming
    will automatically get solved for you. We also learned the meaning of functional
    reactive programming.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了函数式编程。如果你对函数式编程的概念掌握得足够好，响应式编程的谜题将自动为你解决。我们还学习了函数式响应式编程的含义。
- en: By learning functional programming, we also got a clear idea on the constraints
    from the previous chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习函数式编程，我们也对前一章中的约束有了清晰的认识。
- en: We also got our hands on the introduction to coroutines, which is a path breaking
    new feature of the Kotlin language.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还获得了对协程的介绍，这是 Kotlin 语言的一个突破性新特性。
- en: We have modified our `ReactiveCalculator` class with coroutine and a few new
    concepts of functional programming and optimized it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用协程和几个新的函数式编程概念修改了我们的 `ReactiveCalculator` 类，并对其进行了优化。
