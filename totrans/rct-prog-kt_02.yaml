- en: Functional Programming with Kotlin and RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming paradigms are slightly different than that of **Object-oriented
    programming** (**OOP**). It focuses on the use of declarative and expressive programs
    and immutable data rather than on statements. The definition of functional programming
    says *functional programming is a programming system that relies on structuring
    the program as the evaluation of mathematical functions with immutable data, and
    it avoids state-change*. It is a declarative programming paradigm that suggests
    use of small, reusable declarative functions.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the definition of functional programming; now, don't you want to
    delve into its definition and see what it exactly means? Do all languages support
    functional programming? If not, then which languages does and what about Kotlin?
    What exactly does reactive programming have to do with functional programming?
    And, finally, what do we need to learn, for functional programming?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationship of functional programming with reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path breaking feature of Kotlin–coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, functional programming wants you to distribute your programming logic into
    small pieces of reusable declarative small and pure functions. Distributing your
    logic into small pieces of code will make the code modular and non-complex, thus
    you will be able to refactor/change any module/part of the code at any given point
    without any effects to other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming requires some interfaces and support from the language,
    thus we can''t say any language is functional unless it gives some sort of support
    to implement functional programming. However, functional programming isn''t something
    new; it is actually quite an old concept and has several languages supporting
    it. We call those languages functional programming languages, and the following
    is a list of some of the most popular functional programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: Lisp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wolfram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCaml
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp and Haskell are some of the oldest languages and are still used today in
    academia and industry. While talking about Kotlin, it has excellent support for
    functional programming from its first stable release in contrast to Java, which
    doesn't have any support for functional programming before Java 8\. You can use
    Kotlin in both object-oriented and functional-programming style or even in a mix
    of two, which is really a great benefit for us. With a first-class support for
    features, such as higher-order functions, function types, and lambdas, Kotlin
    is a great choice if you're doing or exploring functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of **functional reactive programming** (**FRP**) is actually a product
    of mixing reactive programming with functional programming. The main objective
    of writing functional programming is to implement modular programming; this modular
    programming is really helpful, or sometimes a necessity to implement reactive
    programming or rather to implement the four principles of the Reactive Manifesto.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming consists of few new concepts such as lambdas, pure functions,
    high-order functions, function types, and inline functions, which we will be learning.
    Quite interesting, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Note that, although in many programmers word, pure functions and lambdas are
    the same, they are actually not. In the following part of this chapter, we will
    learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda or lambda expressions generally mean *anonymous functions*, that is,
    functions without names. You can also say a lambda expression is a function, but
    not every function is a lambda expression. Not every programming language provides
    support for lambda expressions, for instance, Java didn''t have it until Java
    8\. The implementations of lambda expressions are also different in respect to
    languages. Kotlin has good support for lambda expressions and implementing them
    in Kotlin is quite easy and natural. Let''s now take a look at how lambda expressions
    work in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, in comment `(1)`, we declare a lambda expression that
    will add two numbers and return the `sum` as result; in comment `(2)`, we call
    that function and print it; in comment `(3)`, we declare another lambda that will
    multiply a random number bound to `15` with the value `x` passed to it and return
    the result; in comment `(4)`, we, again, print it. Both the lambda expressions
    are actually functions, but without any function name; thus they are also referred
    to as an anonymous function. If you compare with Java, Java has a feature of anonymous
    class, but included lambda/anonymous functions only after Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious about the output, then refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89439c0a-af28-49ca-873c-7d67b118c364.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pure function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of pure function says that *if the return value of a function
    is completely dependent on its arguments/parameters, then this function may be
    referred to as a pure function*. So, if we declare a function as `fun func1(x:Int):Int`,
    then its return value will be strictly dependent on its argument `x`; say, if
    you call `func1` with a value of `3` twice, then, for both the times, its return
    value will be the same. A pure function can be a lambda or a named function as
    well. In the previous example, the first lambda expression was a pure function
    but not the second one, as for the second one, its return value can be different
    at different times with the same value passed to it. Let''s look at the following
    example to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both the functions, `(1)` and `(2)`, here are pure functions–one is named, while
    the other is lambda. If you pass the value `3` to any of the functions `n` times,
    their return value will be the same for each time. Pure functions don't have side
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Side effects**: A function or expression is said to have a side effect if
    it modifies some state outside its scope or has an observable interaction with
    its calling functions or the outside world besides returning a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Source–Wikipedia [https://en.wikipedia.org/wiki/Side_effect_(computer_science)](https://en.wikipedia.org/wiki/Side_effect_(computer_science)).
  prefs: []
  type: TYPE_NORMAL
- en: It is to note that, as we said earlier, pure functions have nothing to do with
    lambda expressions, their definitions are completely different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: High-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Those functions that take another function as an argument or return a function
    as result are called **high-order functions**. Consider the following example
    to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we've declared a `highOrderFunc` function, which will take
    an `Int` and a `validityCheckFunc(Int)` function. We are calling the `validityCheckFunc`
    function inside the `highOrderFunc` function, to check whether the value was valid
    or not. However, we are defining the `validityCheckFunc` function at runtime,
    while we are calling the `highOrderFunc` function inside the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `isEven` function in this program is an extension function that
    has been defined inside the `project` files you got with the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inline functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While functions are a great way to write modular code, it may sometimes increase
    program execution time and reduce memory optimization due to function stack maintenance
    and overhead. Inline functions are a great way to avoid those hurdles in functional
    programming. For example, see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's recite the definition of inline function; it says that *inline functions
    are an enhancement feature to improve the performance and memory optimization
    of a program*. Functions can be instructed to the compiler to make them inline
    so that the compiler can replace those function definitions wherever those are
    being called. Compiler replaces the definition of inline functions at compile
    time instead of referring function definition at runtime; thus, no extra memory
    is needed for a function call, stack maintenance, and more, and getting the benefits
    of functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding program declares a function that adds two numbers and returns
    the result, and we will call the function in the loop. Instead of declaring a
    function for this, we can write the addition code right in the place where we
    will call the function, but declaring a function gives us freedom to modify the
    addition logic anytime without any effect on the remaining code, for example,
    if we want to modify the addition with multiplication or something else. If we
    declare a function as inline, then the code inside that function will replace
    all the function calls, thus improving performance while keeping our freedom intact.
    Consider the following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9bc3123-9667-4acf-a4ff-d8ec701d34d0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is one more feature Kotlin provides with inline functions–if you declare
    a high-order function as `inline`, then the `inline` keyword affects both the
    function itself and the lambda passed to it. Let''s modify the high-order function
    code with `inline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will replace all calls to `validityCheckFunc` with its lambda,
    as it would do with `highOrderFuncInline` with its definition. As you can see,
    there's not much modification of the code, just a small change of adding `inline`
    before a function declaration can improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Applying functional programming to the ReactiveCalculator class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now, after trying to understand the `ReactiveCalculator` class from the
    previous chapter, we will try to optimize the code as well. Let''s first take
    a look at the `init` block of the `ReactiveCalculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, with the knowledge of functional programming, we can easily say that
    the `map` and `subscribe` methods are high-order functions that take function
    as parameter. However, do you really think that many `subject` and subscriber
    are required? Shouldn''t subscriber on the class be sufficient to accomplish the
    job itself? Let''s try to modify and optimize the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have removed all other `subscriber` and are doing the job with only
    one. And here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We subscribe to the class object itself; so, whenever its variables get changed,
    we get notified, and we perform all the tasks right there in the `subscribe` method.
    Moreover, as we have made the functions inline, they'll also help in the optimization
    of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Path breaking and, probably, the most exciting feature in Kotlin are coroutines.
    They are a new way to write asynchronous, non-blocking code somewhere like the
    threads, but way more simple, efficient, and lightweight. Coroutines were added
    in Kotlin 1.1 and are still experimental, so think before using it in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the later chapters of this book, you'll learn about Schedulers in RxKotlin,
    which encapsulates the complexities of threading, but you can use it only in RxKotlin
    chain, while you can use coroutines anywhere and everywhere. That is indeed a
    path-breaking feature of Kotlin. They provide a great abstraction on threads,
    making context changes and concurrency easier.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that RxKotlin does not use coroutines yet; the reason is quite
    simple–both coroutines and Schedulers in RxKotlin share nearly the same internal
    architecture; while coroutines are new, Schedulers have been there for a long
    time with RxJava, RxJs, RxSwift, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines are the best fit for developers to implement concurrency when they're
    not using/can't use RxKotlin Schedulers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start by adding it to our project. If you are using Gradle, follow
    these steps (`apply plugin` could be `''kotlin''` or `''kotlin-android''`, depending
    on whether you use it for JVM or Android):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we have to add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Maven, then add the following code block in the `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Apache Maven is a software project management and comprehension tool. Based
    on the concept of a **Project Object Model** (**POM**), Maven can manage a project's
    build, reporting, and documentation from a central piece of information. Please
    refer to the following URL for more information–[https://maven.apache.org/](https://maven.apache.org/).
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly is a coroutine? While developing applications, we often come
    into situations where we need to perform long running or time taking operations,
    such as network call, database operations, or some complex computations. The only
    option in Java is to use a thread to handle such situations, which is very complex
    itself. Whenever we face those situations, we feel the need for a simple yet powerful
    API to handle such cases. Developers from the .NET domain, especially those who
    used C# before, are familiar with the `async`/`await` operators; this is somehow
    the closest to Kotlin coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s take the following example into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will inspect through the code, but let''s first see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, let''s understand the code. On comment `(1)`, while declaring the
    function, we mark the function with the `suspend` keyword, which is used to mark
    a function as suspending, that is, while executing the function the program should
    wait for its result; therefore, execution of suspending a function in main thread
    is not allowed (giving you a clear barrier between main thread and suspending
    functions). On comment `(2)`, we started a block with `measureTimeMillis` and
    assigned its value to the (`val`) `time` variable. The job of `measureInMillis`
    is quite simple–it executes the block passed to it while measuring its execution
    time, and returns the same. We will use the `delay` function on comment `(3)`
    to intentionally delay the program execution by `2` seconds. The `runBlocking`
    block in the `main` function on comment `(4)` makes the program wait until the
    called `longRunningTsk` function on comment `(5)` completes. So, this was a quite
    simple example; however, we are making the main thread wait here. Sometimes, you
    will not want this; instead, you will want to do asynchronous operations. So,
    let''s try to achieve this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we kept `longRunningTsk` same, just modified the `main` function. On comment
    `(1)`, we assigned the `time` variable to the value of `longRunningTsk` inside
    the `async` block. The `async` block is quite interesting; it executes the code
    inside its block asynchronously on the coroutine context passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: There are basically three types of coroutine contexts. `Unconfined` means it'll
    run on the main thread, `CommonPool` runs on the common thread pool, or you can
    create a new coroutine context as well.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)` we run a blocking code that will make the `main` function wait
    until the value of the `time` variable is available; the `await` function helps
    us accomplish this task–it tells the `runBlocking` block to wait until the `async`
    block completes execution to make the value of `time` available.
  prefs: []
  type: TYPE_NORMAL
- en: Building sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, Kotlin coroutines are something more than threads in
    Java and `async`/`await` in C#. Here is a feature that, after learning, you will
    be pissed that it was not there while you were learning to code. To add icing
    on the cake, this feature is application level, it is even shipped with `kotlin-stdlib`,
    so you can use it right there without doing anything or even using coroutines
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before learning what I am talking about, let''s do some old school code, say
    the fibonacci series? Consider the following piece of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is the old-school fibonacci series program in Kotlin. This code becomes
    more problematic when you plan to take the user input for how many numbers to
    print. What if I say Kotlin has a `buildSequence` function that can do this task
    for you, that too pretty naturally and in a simpler way? So, let''s modify the
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output for both the programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's understand the program. On comment `(1)`, we declare `val fibonacciSeries`
    to be filled up by the `buildSequence` block. Whenever we have computed some value
    to output to the sequence/series, we will yield that value (in comment `2` and
    `3`). On comment `4`, we call `fibonacciSeries` to compute up to the `10`^(th)
    variable and join elements of the sequence with a comma (`,`).
  prefs: []
  type: TYPE_NORMAL
- en: So, you learned coroutine; now, let's implement it into our program.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveCalculator class with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, in the `ReactiveCalculator` program, we were performing everything
    on the same thread; don''t you think we should rather do the things asynchronously?
    So, let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On comment `(1)`, we will declare the `handleInput` function as suspending,
    which tells the JVM that this function is supposed to take longer, and the execution
    of the context calling this function should wait for it to complete. As I already
    mentioned earlier, suspending functions cannot be called in the main context;
    so, on comment `(2)`, we created an `async` block to call the function.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming – monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional programming is incomplete without monads. If you are into functional
    programming, then you know it very well; otherwise, you are hearing it for the
    first time. So, what is a monad? Let''s learn about it. The concept of monad is
    quite abstract; the definition says *monad is a structure that creates a new type
    by encapsulating a value and adding some extra functionalities to it*. So, let''s
    start by using a monad; take a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Maybe` is a monad that encapsulates an `Int` value with some added functionalities.
    The `Maybe` monad says it may or may not contain a value, and it completes with
    or without a value or with an error. So, if there's an error, then it would obviously
    call `onError`; if there are no errors, and if it has a value, it will call `onSuccess`
    with the value; and, if it doesn't have a value and no error as well, it will
    call `onComplete`. The thing to note is that all three methods here, `onError`,
    `onComplete`, and `onSuccess`, are terminal methods, meaning either one of these
    three will get called by a `Maybe` monad, and others will never be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the program to understand the monads better. On comment `(1)`,
    we will declare a `Maybe` monad and assign a value of `14` to it. On comment `(2)`,
    we will subscribe to the monad. On comment `(3)`, we will again declare a `Maybe`
    monad, this time with an empty value. The subscription takes three lambdas as
    parameter–when the monad contains a value, `onSuccess` gets called; when it doesn''t
    contain any value, `onComplete` gets called; and if any error occurs, then `onError`
    gets called. Let''s see the output now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, as we can see, for `maybeValue`, `onSuccess` gets called, but for `maybeEmpty`
    , the `onComplete` method gets called.
  prefs: []
  type: TYPE_NORMAL
- en: Single monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Maybe` is just another type of monad, there are a lot more; we will cover
    a few of the most important ones in later chapters, and combine them with reactive
    programming as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about functional programming. If you grasped the
    concept of functional programming well enough, the puzzles for reactive programming
    will automatically get solved for you. We also learned the meaning of functional
    reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: By learning functional programming, we also got a clear idea on the constraints
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We also got our hands on the introduction to coroutines, which is a path breaking
    new feature of the Kotlin language.
  prefs: []
  type: TYPE_NORMAL
- en: We have modified our `ReactiveCalculator` class with coroutine and a few new
    concepts of functional programming and optimized it.
  prefs: []
  type: TYPE_NORMAL
