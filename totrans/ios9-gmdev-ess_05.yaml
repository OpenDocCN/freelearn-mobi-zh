- en: Chapter 4. SceneKit and 3D Game Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will be going over the iOS framework used for 3D game development
    known as SceneKit. SceneKit first became available in iOS 7 but originally was
    just used for MacOS development. Previously, developers had to code 3D games using
    OpenGL or third-party frameworks and engines, such as Cocos3D, Unreal Engine,
    Havok, and Unity. As the graphical power in the iOS family of devices improved,
    so did the need for an immersive, hands-on first-party 3D game design engine.
    SceneKit shortly became available for iOS giving developers an Xcode built-in
    solution to make 3D games.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we approached iOS game development in a more code-based
    methodology. We'll still be working in some code, but since the introduction of
    Xcode 5 and Xcode 6, Apple has provided some great demos that show how the IDE
    can be just as visually dynamic of a game engine as multiplatform game engines
    are. The benefit of using Xcode and the SpriteKit/SceneKit frameworks over those
    engines is that you have a dedicated design environment for a specific platform.
    In our case, that platform is iOS and the Apple family of devices. As iOS frequently
    updates and continues to give new features, Xcode and these frameworks will update
    with it. Updates to the multiplatform engines usually occur at a later date with
    sometimes the additional need to install plugins to ensure that your app runs
    smoothly in future updates.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the very dynamic and tool-rich DemoBots SpriteKit demo, the *June
    2015 World Wide Developer's Conference* also introduced a wonderful SceneKit demo
    named Fox. The Fox demo also makes use of features introduced in iOS 9 that we
    can use for either SpriteKit or SceneKit, such as reusable actions, components,
    and state machines.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go over the basics of SceneKit and we will make a simple
    SceneKit scene (known as `SCNScene`) using both code and the visual design tools
    Xcode provides. We will then add physics, lights, and particles to our SceneKit
    objects and scene. We will then wrap up with a look into the *WWDC15* Fox Demo
    and some of the features/APIs it uses, which became available in iOS 8 and iOS
    9.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we left out much of these asset creation features in
    our discussion on SpriteKit. With SpriteKit scene files, (`.sks`), we can also
    create game assets, such as lights, physics fields, bounding boxes/physics constraints,
    normal maps, textures, entire levels, and characters in the same fashion that
    SceneKit scene files (`.scn`) work. We will at times show the SpriteKit method
    to similar features.
  prefs: []
  type: TYPE_NORMAL
- en: Since SpriteKit and SceneKit scene assets work similarly and can be together
    in the same scene (thanks to their inherit node/tree functionality), we thought
    that it was best to save the visual and asset tool discussion for this chapter.
    The previous chapter's talk on the game/render loop and much of the scene code
    functionality will work in SceneKit much like it did previously in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: So in other words, we are already set up to dive right into SceneKit.
  prefs: []
  type: TYPE_NORMAL
- en: SceneKit basics and working with nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like SpriteKit, SceneKit is based on the concept of nodes. SpriteKit objects
    are children of the `SKNode` class, while SceneKit objects are children of the
    `SCNNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![SceneKit basics and working with nodes](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is the SceneGraph hierarchy from Apple's SceneKit introduction.
    As we see, SceneKit has various nodes that branch off from the `SCNScene` class.
    These include the generic `SCNNode` for lights, geometry, and the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes are a tree data structure that can have other nodes added to them and
    have information of other nodes in the structure. As seen in the preceding graph,
    it's shown with the `childNode[]` array and parent properties. Spatial information,
    such as position, scale, and orientation, can be received from these properties.
    This is what makes nodes unique to other parent-child structuring in object-oriented
    design (OOD).
  prefs: []
  type: TYPE_NORMAL
- en: 'In SpriteKit, we''d typically add a node to our scene or to another node within
    our scene via the `addChild()` function. In SceneKit, the same functionality is
    done with `addChildNode()`. For example, the main root node in a SceneKit scene
    is the `SCNScene` node that is placed in the `SCNView` node, that is, the framework''s
    unique version of the `UIView` class. To add a basic sphere object to our scene,
    we''d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As stated with SpriteKit, working with nodes in SpriteKit can allow us to group
    various members of our game scene together into their own parent nodes and make
    actions on them in one call also iterating through for loops or other iteration
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: SpriteKit / SceneKit interactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One great feature of SceneKit is that we can have a SpriteKit scene overlay
    our 3D game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the `SCNView` property `overlaySKcene`, we can take an already established
    `SKScene` node (which can be a character, an animation sequence, an HUD, and more)
    and have them in our 3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: Want to have a cute sprite animation overlay your 3D character's stage win or
    maybe want to make a 2.5D game with 2D sprites and physics overlaying a 3D background?
    Then this is how you can do it.
  prefs: []
  type: TYPE_NORMAL
- en: '![SpriteKit / SceneKit interactivity](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The most common functionality of mixing SpriteKit with SceneKit is that SpriteKit
    is the HUD for the SceneKit scene. The lives, collectables, and character icon
    seen in the earlier Fox demo shows a SpriteKit node overlaying a SceneKit scene.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes in general can help add a functional structure to your game and game scenes.
    A high reliance on nodes and inheritance in game design doesn't come without its
    flaws though.
  prefs: []
  type: TYPE_NORMAL
- en: The issue with inheritance-based structuring and game design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going forward, we should mention about a certain pitfall that could plague
    a game that relies too much on the concept of nodes and even the general concept
    of inheritance-based structuring in OOD. When possible, it's best not to rely
    too much on inheritance for your game logic and work more with what's known as
    composite-based structuring. We'll go deeper into this in our next chapter when
    we talk about the helper game development framework first introduced in iOS 9,
    GamePlayKit, but here's a glance so that we know that working with inheritance
    and even nodes might not always be the best solution in our games.
  prefs: []
  type: TYPE_NORMAL
- en: '![The issue with inheritance-based structuring and game design](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At first glance, one might think that inheritance-based structuring is perfectly
    made for game development. Many of us familiar with OOD know that we can have
    generic parent classes or nodes of our game objects, such as an all-encompassing
    `GameObject` class, and then use inheritance and polymorphism to work with unique
    child classes from this base class. For small, simplistic games that will hold
    true, but games tend to have objects that could share some of the same functionality,
    but make no sense to have in a parent-child structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this typical structuring in a tower-based strategy game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The issue with inheritance-based structuring and game design](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In a typical tower game, we'd have our base, tower, and enemy objects that can
    all inherit from a generic `GameObject` class we define. Towers can fire at enemies
    but so can enemies back at the towers and other player-based objects. Part of
    good programming and design is to have reusable code and methods. Normally, we'd
    do this with inheritance. The preceding graph shows two-way inheritance that can
    solve this. We would then want a `ShootingEnemy` class that inherits the movement
    and shooting functionality. We can't do this, as that would involve inheriting
    from two separate and rather unrelated classes of objects. In OOD, there's only
    one child-parent relationship. The next solution shown on the right would be to
    have the generic `GameObject` class have this functionality. The issue that arises
    is that our once simple `GameObject` parent class becomes all but simple and we
    inevitably want to add additional features and functionalities to objects in our
    game. In the past, this would involve refactoring tons of code to accommodate
    what essentially are simple design add-ons. Protocols used to be somewhat of a
    solution to this as they'd force us to make a class in a certain way, but even
    they could get confusing and don't involve the implementation of these features.
  prefs: []
  type: TYPE_NORMAL
- en: The solution would be to work with entities and components.
  prefs: []
  type: TYPE_NORMAL
- en: '![The issue with inheritance-based structuring and game design](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This preceding diagram gives an example of composite-based structuring. With
    this methodology, we can have components that share similar functionality, being
    used by multiple and usually unrelated game objects. This way, the generic `GameObject`
    class in this example doesn't have to have every possible function of its child
    class and we can keep `Enemy` classes as being members of `Enemy`. The shared
    functionality can be written once and then used throughout the game and even in
    the other games we wish to make. iOS 9's SpriteKit demo, DemoBots, and the SceneKit
    demo mentioned earlier, Fox, both use composite-based structuring for actions
    and animations.
  prefs: []
  type: TYPE_NORMAL
- en: It's important when thinking with nodes in both SpriteKit and SceneKit that
    they are used in the context of the View of the MVC model, or in both frameworks,
    the context of their scenes.
  prefs: []
  type: TYPE_NORMAL
- en: As for scenes in SceneKit, let's move on to making a very basic one.
  prefs: []
  type: TYPE_NORMAL
- en: Our first SceneKit scene – the Xcode template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D art and animation is a very in-depth topic. We could go on *ad nauseam* about
    materials, shaders, lighting, sculpting, PVR textures, and all of the topics of
    what makes great 3D objects for games, movies, architecture, or any other 3D object-based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the details of these topics are beyond the scope of this book, so for
    now, let's keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first SceneKit scene – the Xcode template](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s work with the default SceneKit scene and objects that Xcode gives us
    as a start, as shown in the preceding image:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of the time of writing this book, we used the SceneKit template for Xcode
    7 – Beta. Based on the version you use, there might be some differences.
  prefs: []
  type: TYPE_NORMAL
- en: First, open Xcode, create a new project, and select the **Game** template.![Our
    first SceneKit scene – the Xcode template](img/00040.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, name your project, make sure that the **Game Technology** field says **SceneKit**,
    and click on **Next**.![Our first SceneKit scene – the Xcode template](img/00041.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The project files and structure are about the same as we saw with SpriteKit
    but with a couple of differences, particularly the `art.scnassets` folder. The
    only difference is that there is now an `art.scnassets` folder in addition to
    `Assests.xcassets`. This is where our 3D objects are held. Click on that folder
    to see the `ship.dae` asset that Apple provides.![Our first SceneKit scene – the
    Xcode template](img/00042.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the SceneKit editor, we can view and edit the following 3D file types:'
  prefs: []
  type: TYPE_NORMAL
- en: DAE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OBJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alembic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PLY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example given to us is a spaceship of the type DAE and with the `ship.dae`
    file as the ship's texture file (`texture.png`). Before we look into the code
    and how the scene works, build and run the program on either your own device or
    the Xcode device simulator.
  prefs: []
  type: TYPE_NORMAL
- en: From the sample scene, we see our spaceship rotating in front of a black background
    and we can change its orientation when we swipe the ship. Tapping on the ship
    causes it to glow red for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see what's going on with the code and then we'll get into the tools
    the editor gives us to edit our objects and scenes without any code.
  prefs: []
  type: TYPE_NORMAL
- en: SceneKit project flow and structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like SpriteKit, a SceneKit scene uses the same game-rendering loop as we saw
    from the previous chapter and the same type of entry point structuring we mentioned
    in *Chapter 2*, *Structuring and Planning a Game Using iOS 9 Storyboards and Segues*.
    We have the `AppDelegate.swift` file that is our entry point with the ability
    to control special app functionality based on upper level device events, such
    as the app closing, going into the background, and coming back from being in the
    background. We also have the launch screen and `Main.storyboard` files as seen
    before in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![SceneKit project flow and structure](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The difference with the `Main.storyboard` file is that it has a SceneKit scene
    icon, shown with the cube, as seen in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewController` class the AppDelegate moves to is the `GameViewController.swift`
    class. This is where all of our code for the demo takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that we begin with the overwritten `viewDidLoad()` function. SceneKit
    lets us create an entire scene with even an instance of our 3D object/assets,
    as seen from the unwrapped `let scene = SCNScene(named: "art.scnassets/ship.dae")!`
    call. This simply creates the scene object. To get the object seen on the screen,
    we still need to attach this to the `SCNView` node, as we will see later in the
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some more of the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `viewDidLoad()` function mentioned earlier is provided to us in the template.
    It''s actually rather simple to follow and other than the `handleTap()` function,
    does practically all that''s needed to create this scene. Anyone who''s created
    3D graphics in OpenGL either for iOS or other platforms would appreciate how SceneKit
    gives us a number of simple upper level controls for the scene and objects. Here
    are more details of the provided code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On line `(1)`, an `SCNNode` named cameraNode is created, and we assign the
    `camera` attribute of `SCNNode` to the `SCNCameraNode` type. Then, the camera
    is placed in a three-dimensional space using the `SCNVector3()` function on the
    camera''s `position` property. In this case, the camera is placed at (`x: 0`,
    `y: 0`, `z: 15`). In other words, the *x* and *y* coordinates are set at the origin
    while the camera is moved slightly backwards in the *z* axis.'
  prefs: []
  type: TYPE_NORMAL
- en: '![SceneKit project flow and structure](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can find the SceneKit coordinate diagram at [https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/).
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate system in SceneKit is what's known as a **Right-Handed Coordinate
    System**. One trick to understand the 3D coordinates is if we take our right hand,
    make a gun-like gesture out with our thumb up in the air and pointer finger straight
    ahead of us while our middle finger to the side at a right angle from the pointer
    finger, we'd have our *x*, *y*, and *z* coordinates. Your middle finger would
    be on the *x* axis (left/right), your thumb would be on the *y* axis (up/down),
    and your pointer finger would be on the *z* axis (backward/forward).
  prefs: []
  type: TYPE_NORMAL
- en: In the `(2)` block of code, we are adding lights to our screen. SceneKit, as
    well as SpriteKit, lets us create a number of different lighting effects, from
    ambient occlusion, the use of normal maps, and more. Here, an instance of `SCNNode`
    is created with the name `lightNode`, and the `SCNNode` property light is assigned
    the `SCNLight` class type. The first light created and added to the scene is what's
    known as an `SCNLightTypeOmni` type light, as seen from the implicitly unwrapped
    call `lightNode.light!.type = SCNLightTypeOmni`. This type of light is typically
    used more for debugging as the next light added, `ambientLightNode`, would be
    one of the types used to create the atmosphere to your game. As we see with the
    line, `ambientLightNode.light!.color = UIColor.darkGrayColor()`, we can assign
    a color to that light in code.
  prefs: []
  type: TYPE_NORMAL
- en: More information on `SCNLights` can be found at [https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: We'll soon see how to visually add lights and other aspects of the demo `viewDidLoad()`
    function to our scene, but it's usually beneficial to understand the boilerplate
    code behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the line `(3)`, `let ship = scene.rootNode.childNodeWithName("ship", recursively:
    true)!` is how we add our `ship` object to the scene''s root node. This is not
    too much different than other objects in the scene. It takes the string `ship`
    from the name of our `ship.dae` object in the `art.scnassets` folder. The `recursively:
    true` parameter in the `childNodeWithName` function tells the scene that it should
    add all child nodes of the object to the scene. Depending on how the 3D object
    was modeled and rigged in its original 3D model program, the object might have
    a complex array of child nodes. Setting recursively to `true` will iterate through
    not just the child nodes but their child nodes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following long line (part of line `(4)`) is a compact way of telling the
    ship to rotate continually by *x*, *y*, and/or *z* angles based on its current
    orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This can be broken down into its various parts, as it's an `SCNAction` within
    an `SCNAction`, namely, the `rotateByX` function wrapped into a `repeatActionForever`
    function of `SCNAction`. Actions in both SceneKit (`SCNAction`) and SpriteKit
    (`SKAction`) cannot only be added to objects by code but also in Xcode's visual
    editor, as we shall see later in our review of the Fox demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find more on both the `SCNAction` and `SKAction` classes here:'
  prefs: []
  type: TYPE_NORMAL
- en: For `SCNAction`, refer to [https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/).
  prefs: []
  type: TYPE_NORMAL
- en: For `SKAction`, refer to [https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/](https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/).
  prefs: []
  type: TYPE_NORMAL
- en: In line `(5)`, we create the `SCNView` object and assign it as the view of `GameViewController`
    with the line `let scnView = self.view as! SCNView`. The scene and its nodes that
    we created with the object named `scene` back in line `(1)` then gets assigned
    to the `scene` attribute of `scnView` via `scnView.scene = scene`. There is a
    slight bit of ambiguity as to which scene is assigned to what node, but this essentially
    has to do with the setting up of `rootNode` itself.
  prefs: []
  type: TYPE_NORMAL
- en: The next few lines (of `(6)`) show some of the properties that we can use from
    the `SCNView` class; the first being the ability to control the camera with the
    `allowsCameraControl` property. Setting this to `false` would prevent the player
    from being able to move the camera about. This could be great for in-game cut
    scenes or locking the camera during a part of a stage where it would be necessary.
    The line `scnView.showsStatistics = true` tells the scene to show any rendering
    data that would be beneficial to debugging. For example, we could see the **frames
    per second** (**fps**) our game is running at.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to a SpriteKit scene's code part of `skView.showsFPS` and
    `skView.showsNodeCount`, where `skView` is the name of an `SKView` object.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, `scnView.backgroundColor = UIColor.blackColor()`, allows us to
    set the background color to black, just the same way as we did with `ambientLightNode.light!.color
    = UIColor.darkGrayColor()` using the `UIColor` class.
  prefs: []
  type: TYPE_NORMAL
- en: SceneKit Debugging Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of iOS 9, even more debugging options became available through the use of
    the `SCNDebugOptions` struct and the `debugOptions` attribute of `SCNView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to write the following, we''d be able to see our ship''s bounding
    boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are other options such as `ShowLightInfluences`, `ShowPhysicsShapes`,
    and `ShowWireframe`.
  prefs: []
  type: TYPE_NORMAL
- en: '![SceneKit Debugging Options](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: WWDC15's Fox Demo with the .ShowBoundingBoxes and ShowPhysicsShapes options
    enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in line `(7)`, `let tapGesture = UITapGestureRecognizer(target: self,
    action: "handleTap:")` creates a `UITapGestureRecognizer` object named `tapGesture`,
    which will call the function `handleTap(gestureRecognize: UIGestureRecognizer)`
    when any tap is performed and `scnView.addGestureRecognizer(tapGesture)` adds
    that recognizer to the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling user input in SceneKit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UITapGestureRecognizer` objects are great in order to selectively organize
    the input we receive from the player. This goes for both SceneKit and SpriteKit
    scenes. We can have recognizers for taps, swipes in each direction, panning, pinches,
    and long presses; long presses are great for when you'd need to possibly handle
    a character charging their attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the documentation of the `UITapGestureRecognizer` class for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at that `handleTaps` function as it contains an object of
    the SceneKit class, `SCNTransaction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In line `(1)`, we are just creating a reference to the current `SCNView` object
    named `scnView`. Next, the constant `p` is created using `gestureRecognize.locationInView(scnView)`.
    What this is doing is capturing the gesture's location in the view we wish to
    keep tabs on. In this case, it's the entire view, `scnView`. If we had subviews,
    say a game's menu screen, then we could if we'd wish only target gestures there
    in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If building a game where the player has to tap at the spur of the moment and
    many times for a character's movement or dodging, we did find the `touchesBegan()`
    functionality we spoke about in SpriteKit to be a bit faster than `UITapGestureRecognizer`.
    This might eventually become a moot point with each new and faster iOS device,
    but if your game's controls are heavily dependent on quickness of the player,
    you might notice some lag in response to the gestures via the `UITapGesterRecognizer`
    approach. This could effect the goal of your game, so try the `touchesBegan()`
    function to see what works best for your game. Using `touchesBegan()` for swipes
    and other non-tap gestures could be rather tricky, so there's a trade-off there
    on the development side too.
  prefs: []
  type: TYPE_NORMAL
- en: Next in line `(2)`, we take a count of how many of these gestures, taps in our
    case, were captured in the view using the `hitTest()` function of `SCNView` and
    only counting if that gesture made contact with any object in our scene by passing
    the position constant, `p`, as a parameter. The function `hitTest()` returns an
    array of event results, and the `count` property then counts how large that array
    is. We can then capture a reference to the first tap by referencing the first
    member of that array. We only have a single object in this demo provided for us,
    the spaceship, so we can just get an instance of Swift's most upper parent object,
    `AnyObject`. Our `hitTest` object, `hitResults`, is an array containing references
    to every object tapped in this context. Again, this is just our spaceship object,
    so we can simply take the first object instanced at `hitTest[0]`. This is what
    the result constant represents.
  prefs: []
  type: TYPE_NORMAL
- en: The line `let material = result.node!.geometry!.firstMaterial!` shows us how
    we get a reference to that object's material by drilling down the node's children
    using the dot operator while also implicitly unwrapping each node via the exclamation
    point (`!`). This material reference is needed for when the tap needs to make
    the spaceship turn red.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is actually a nice broad example of how we can select only certain objects
    in our SceneKit scene to be the focus of a player's input. Here, it just picks
    any object using the broad type `AnyObject` class, but imagine a game where only
    a certain type of character or characters are selectable; think of an isometric
    top down shooter or **real-time strategy** (**RTS**) game. We could possibly check
    whether the tapped object only is a member of a certain class type (`isKindOfClass()`)
    or conforms to a certain protocol (`conformsToProtocol()`) before taking any action
    on those selected game objects. Want the player in your RTS game to only take
    actions on Tank objects? Then combining this with a menu that tells the game which
    object type is the focus could be what gives you that ability here in SceneKit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line `(3)`, the default SceneKit template also hands us this useful bit
    of code showing the use of `SCNTransaction`. The `SCNTransaction` class first
    became available in iOS 8, and we can think of `SCNTransaction` as a laundry list
    of changes and animations we want in the scene to take place at a certain specified
    set of time. An `SCNTransaction` class begins with the `SCNTransaction.begin()`
    call and ends at the `SCNTransaction.commit()` call. Scene graph animation calls
    that are within that block get called, by default, with a 0 second delay. In many
    cases, we''d want to control the duration of these animations, thus we use the
    `setAnimationDuration()` function at the beginning of the `SCNTransaction` block
    to set that. The line `SCNTransaction.setAnimationDuration(0.5)` sets the time
    to complete this block at half a second. Do note that within this block is another
    block of code starting with `SCNTransaction.setCompletionBlock{…}`. What this
    does is execute the call only after the `SCNTransation` block it''s within completes.
    In the case of this template demo, at first for half a second, the ship is highlighted
    red, as done in the `material.emission.contents = UIColor.redColor()` line. After
    this completes, for another half a second, the ship is brought back to it''s original
    color by setting its material emission back to `UIColor.blackColor()`. This is
    a bit confusing at first but there are a slew of animations and transactions we
    can do for our scenes with this method in just one block. Check out this link
    to the documentation; other transitions/transactions can be for fading in/out,
    camera field of view, rotation, translations, lighting, and more: [https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey).'
  prefs: []
  type: TYPE_NORMAL
- en: As for the default SceneKit template, that's all the code used to make the scene.
    It's a basic scene and far from a game, but it should give us a basic understanding
    of what essentially makes up the main structure and logic of a scene in SceneKit.
    Before we look into the Fox demo and thus an actual full game project, let's look
    at a few other features that were added to Xcode as of iOS 9 / Xcode 7.
  prefs: []
  type: TYPE_NORMAL
- en: SceneKit features introduced in iOS 9 / Xcode 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go back to transitions and animations. As of iOS 9, we can change a character
    or other 3D object's blend mode very easily in SceneKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![SceneKit features introduced in iOS 9 / Xcode 7](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A display of the various blend modes in SceneKit from WWDC2015
  prefs: []
  type: TYPE_NORMAL
- en: Blend modes can be changed simply with one line, `aSCNMaterial.blendMode = .Add`,
    where `aSCNMaterial` is an object representing the material of `SCNNode`. Changing
    blend modes can create a number of effects. Some games use a player's *ghost*
    to show a past run through they are trying to beat, or there's the fade effect
    boss characters make when defeated. Combine with `SCNTransaction` to have characters
    fade in and out of these modes.
  prefs: []
  type: TYPE_NORMAL
- en: Audio nodes and 3D sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of iOS 9, we can place 3D sounds into our SceneKit scenes. The `addAudioPlayer()`
    function of the `SCNNode` class function lets us append a sound to that node,
    and wherever that node is in 3D space, the sound will adhere to 3D audio mixing;
    that is, if the audio source''s `positional` property is set to `true`. Here''s
    how we''d create 3D sound with audio nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This gives a sound effect to the game object, the `SCNNode` named node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually play the sound, we''d need to call `SCNAction` on it, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `waitForCompletion` property makes sure that the action goes as long as
    the sound is. This might not be the best for a character sound effect though as
    you might want it stopped midway (that is, the player hits the enemy, canceling
    their previously started chant, yell, or something to that degree).
  prefs: []
  type: TYPE_NORMAL
- en: Ambience and music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add music and ambience, we could follow exactly the same method as adding
    a sound effect to a node: create an `SCNAudioSource` object; add that to an `SCNAudioSource`
    object; and add this to our node with `addAudioPlayer`. The only difference is
    that we''d loop the music and set it''s `positional` property to `false` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: SpriteKit scene transitions in SceneKit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SpriteKit has some great scene transitions. We could make it look like a door
    is opening up or a page is turning. This could add extra character and polish
    to your game. Before iOS 9, we couldn''t do these 2D transitions in our 3D SceneKit,
    but since Xcode 7 and iOS 9, we can do so in SceneKit and here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, `aSCNView` is just a general reference to some `SCNView` object and when
    we present the scene to that view, we have the option of passing an `SKTransition`
    object for the `withTransition` parameter. The `incomingPointofView` parameter
    can be a reference to a camera's point of view during the transition, and the
    `completionHandler` parameter is the name of a completion block that is called
    after the scene transitions. For example, we could call the functions that start
    the count up of our last stage's score in a score scene that was transitioned
    to after the stage completed. We might not want to begin the counting and other
    functions of the new scene until we know that the scene has been 100% transitioned
    to or, in this case, after we know the total points from the prior scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out some more examples of `SKTransition` on the class reference page,
    maybe there''s a transition that could help add to your game''s design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Fox demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been spending much of our time in both SpriteKit and here in SceneKit
    on the boilerplate code that makes up our game logic. As Xcode continues to update,
    so does the visual design features for iOS game design that don't involve a strong
    understanding of code. There's always some scripting involved, but one of the
    key features in game design is, well, the design aspect of it. At the *WWDC15*
    event, the introduction to iOS 9 and Xcode 7 was a great game demo that can not
    only teach us some of the visual design features that Xcode can do, but also gives
    us a beautiful start to a platforming game in SceneKit. That demo is named *Fox*
    and granted, though it actually stars a red panda and not a fox, we could forgive
    that mixup for how feature-rich and essential it can be to learn how to develop
    SceneKit-powered iOS games.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fox demo](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Fox demo image showing our player character and level assets
  prefs: []
  type: TYPE_NORMAL
- en: There's much more to this demo than we can show here, so it's encouraged to
    download it for yourself and check out all of the SceneKit features it provides.
    We will focus on a few topics yet to be covered in either SceneKit or SpriteKit,
    such as particles, physics, and the scene graph. The Fox demo also makes use of
    3D game/art design features, such as skyboxes, ambient occlusion, cubemap lighting,
    collision meshes, and more. It really is a nice-quality demo to make beautiful
    games in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the download link provided by Apple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, the Fox demo was written only in Objective-C. We have
    focused on Swift in the entirety of this book, but don't worry too much if some
    aspects of Objective-C are foreign to you. The goal is to see the visual tools
    Xcode provides. In a future date, the Fox demo is bound to be available in Swift,
    be it by Apple themselves or by third-party programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the basic assets in any game, be it SpriteKit or SceneKit built, are
    the various particle effects we'd add to characters, objects, or an entire scene.
    Particles can add to the feel of collecting that item, give the player a signal
    that something is happening to the player, like they are gaining or losing health,
    or show the presence and power of an incoming boss fight.
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle systems](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Collectable particle effect from the Fox demo
  prefs: []
  type: TYPE_NORMAL
- en: In the past, the process of making a particle effect would be to manually create
    sometimes rather complex particle emitter shader objects using OpenGL code. This
    can still be done if we so choose (using either Apple's fast, low-level API, Metal,
    or OpenGL), but over time, the process of visually creating and editing particle
    effects has gotten easier. Not too long ago in the iOS development history, frameworks
    such as Cocos2D/ Cocos3D allowed us to use third-party particle effects builders
    to import into our games. With both SpriteKit and SceneKit, Xcode as of about
    iOS 7/iOS 8, a more visual representation of particles was created in Xcode thus
    saving us a large amount of time and effort in creating the effects we want and
    expect to see in our games. The image previously shown displays the Xcode particle
    systems editor with the Fox demo's collectable sparkle effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your own particle effect in SceneKit, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file as we did in the past by navigating to **File** | **New**
    … or simply the keyboard shortcut *command* + *N*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then select the **Resource** section under iOS and select the **SceneKit
    Particle System** template. (If working with SpriteKit, select **SpriteKit Particle
    File**.)![Particle systems](img/00049.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the SpriteKit and SceneKit particle options give us a list of basic particle
    templates we can start from, such as Reactor, Sparkle, or Bokeh. Select one of
    your choosing or check out a collectable one here in the demo. For SpriteKit,
    this creates an SKS file and the image mask for the particles. The SceneKit template
    creates the 3D particle effect via an SCNP file and the image mask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's take a look back at the particle system we created for the collectable
    particle in the demo. If not selected already, click on the attributes inspector
    to view various controls we can edit to customize our particle effects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle systems](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to test a number of the variables and fields within the inspector.
    There's the birth rate, which controls how often the particles restart their start
    and end animation, the image, which can make up the shape and color of the particles,
    and the various angles that determine the overall direction of the effects. There's
    also the **Looping** dropdown, which keeps the particles repeating during the
    life of the particle system in the scene. Additionally, the **affected by gravity**
    toggle is what we use to have the particles fall based on the scene's gravity.
    The collection particles loop constantly without gravity, and the confetti particles
    happen once and fall to gravity, as we'd expect confetti to behave. If an object
    in our scene has a physics field, we can also have the particles react to that.
  prefs: []
  type: TYPE_NORMAL
- en: Placing particles into our pioscene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create SpriteKit or SceneKit particles, we can call them in our scene
    via code in either the SpriteKit or SceneKit:'
  prefs: []
  type: TYPE_NORMAL
- en: SpriteKit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SpriteKit particles aren''t in the Fox demo but to backtrack a bit to our talk
    on SpriteKit, if we''d wanted to add particles to a 2D SpriteKit game, here''s
    an example of how we''d accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We create a path to our app's bundle with the `NSBundle.mainBundle().pathForResource()`
    function call, and we pass the string of the particle file's name, in this case,
    `Spark`, with the file type, SKS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create the `sparkParticle` object using the `NSKeyedUnarchiver.unarchiveObjectWithFile(path!)`
    call that, as we see, takes the path we created in part `(1)`. It''s casted as
    the particle object for SpriteKit, `SKEmitterNode`. `NSKeyedUnarchiver` is a class
    used to decode named objects from keyed archives, an encoded hierarchy of archives.
    This class has some support of what is known type coercion. In short, it can decode
    objects in files, be it whether in a 32-bit or 64-bit architecture. More on this
    special file decoding class here: [https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set a position and name for this particle effect and target it to the
    scene while also adding it to the scene node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Though this example isn't given in the Fox demo, this is a great example of
    how we can target specific files in our project's navigation hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: SceneKit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SceneKit particles are members of the `SCNParticleSystem` class. We add these
    particles to our scene with the `addParticleSystem` function of the `SCNNode`
    class. The Fox demo does this in the `collectFlower()` function with the following
    Objective-C line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What this code is doing is calling the scene in the designated view and adding
    the particles, which are declared earlier in the class as `_collectParticles`
    to our scene. It then tells the scene at which point in space this effect will
    appear. In this case, it's the `particalPosition` variable that when traced back
    is taken from the `SCNNode` parameter passed into the `collectFlower()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s how this would be written in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Swift's `addParticleSystem` API unfortunately doesn't have the `withTransform`
    parameter as in Objective-C, so we'd have to add the particle system to the node
    it will be emitting from, which is denoted by the `particleEmitNode` variable.
    This most likely will change in future API changes of Swift 2.x and later.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SceneKit and SpriteKit physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at the `collectFlower()` function from our particle example, we
    see that there's an `SCNNode` parameter passed. This node comes from the function
    `physicsWorld`. In both SpriteKit and SceneKit, we can create an overall set of
    physics rules and handle various physics-related interactions, most notably, contacts
    between two or more nodes. One of the most basic aspects of any game is to do
    something when game objects hit each other. This could be when the player touches
    a collectable, when enemies contact the player or the player hits the enemy with
    an attack. In iOS development and in game engines, we call these boundaries between
    2D sprites or 3D objects as bounding boxes. We mentioned these physics objects
    briefly in our talk of iOS 9 and later `debugOptions` property. Bounding boxes
    for SceneKit objects are created automatically based on the simplified version
    of an object's geometry, but we can edit these shapes with the `SCNBoundingVolume`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: More documentation of this class can be found at [https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Game physics in iOS and game development in general are much larger topics than
    we can discuss in this chapter. So for now, let's just see how the Fox demo and
    iOS games in general handle the simple concept of two nodes contacting their bounding
    boxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Preceding is a Swift pseudo code example of the Fox demo's `physicsWorld` function.
    The function takes in two parameters, `world` of the type `SCNPhysicsWorld` that
    represents the entire physics environment of a scene and the object representing
    the physics contact of the type `SCNPhysicsContact`. The function here checks
    the bitmask of the nodes in the contact. If the first or second node of the contact
    (`nodeA` or `nodeB`) are in the flower's specific category, then the `collectFlower()`
    function is called and that collectable's node is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmasking is when we designate a set of bits for another set of bits that can
    be combined together using bitwise math. Think of it as using 1s and 0s to not
    only categorize a range of ones and zeros but also allow us to handle situations
    where many categories happen in the same context.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have different categories of objects/events in our game and
    we fit them in their own *slots* in a byte (8 bits). In the Fox demo, the game
    collisions are a bitshift value of 2, thus they represent 00000100 in binary.
    The *category designation* of collectables in the Fox demo a bitshift of 3 or
    00001000, the enemies are 4, 00010000.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the demo, we see the following code for `AAPLBitmaskSuperCollectable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the category bitmask in either `nodeA` or `nodeB` of the collision match
    the flower collectable (if the *slot* is *on* per say, or equal to 1, then we
    know the collectable was involved in the collision).
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift version 1 didn''t really have a similar way to mimic bitmasking as done
    in Objective-C with NSOptions, but as of Swift 2.0, we can perform bitmasking
    like the demo in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, it's a struct that returns bitshifted static variables of itself.
    It's not as elegant as seen in Objective-C and in past C implementation, but if
    we wish to use bitmasking in boilerplate code in Swift, this should allow you
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: One last note about the `physicsWorld()` function, in order for the function
    to be called during the collision of two physics bodies, we need to set the physics
    world delegate. In most cases, that delegate would be the current game scene.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Xcode will most likely tell you that a physics world delegate wasn't set and
    if you haven't, this is the code that is usually placed in the `viewDidLoad()`
    function of `ViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Visually composed game scenescgs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting back to the visual aspects of the Fox demo, let's look at the game scene
    objects created in the project and how we can view the nodes in what's known as
    the **scene graph**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually composed game scenescgs](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We see that game objects and particle effects in the Fox demo can be visually
    manipulated in Xcode and together in one view. The preceding image shows the flower
    collectable and its components that consist of the 3D mesh, lighting, bounding
    boxes, and the particle effects. In SceneKit, we do this with a SceneKit scene
    file (SCN).
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually composed game scenescgs](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the scene''s scene graph, click on the side window icon found toward
    the bottom-left of the Xcode window under the visual editor window of the scene,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually composed game scenescgs](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the scene graph. Those familiar with the game engines,
    such as Unity and Unreal Engine, will be quite familiar with this type of component/game
    scene view. The scene graph shows the dropdown hierarchy of all the objects in
    the scene including their own internal components. The flower power-up consists
    of a 3D mesh model named *flower* that has two child particle effects as well
    as a physics body. All three are denoted by the three symbols seen on the right-hand
    side of the graph's objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually composed game scenescgs](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can move the model around in the scene, using *X*, *Y*, and *Z* markers seen
    in the preceding image. We can also zoom in, zoom out, rotate the scene, as well
    as add more objects to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually composed game scenescgs](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To add more objects to the scene, follow these:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **media library** found in the library windows at the bottom-right
    of the screen (seen in the prior image).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now search for `grass` and simply drag and drop it into the scene. Now the premade
    grass object is in this scene as a reference.![Visually composed game scenescgs](img/00056.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is actually how the `level.scn` file was composed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's also the option to add primitive objects to the scene and build them
    up from there, which is again very similar to the design-centric game engines.
    Simply select from the object library tab right next to the media library icon
    and search `geometry`. There are primitive objects, such as spheres, planes, and
    boxes.![Visually composed game scenescgs](img/00057.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The primitive objects lack the lighting, materials and other details that we
    can see in the grass and other premade objects in the projects. Use the even more
    detailed inspector windows for these objects to see and edit various details,
    such as the physics bodies, materials, baking the lighting, and object name identification
    for any scripting/coding.![Visually composed game scenescgs](img/00058.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's also actions that can be added to these objects. Click on the secondary
    editor icon (the upside down triangle in a square at the button right of the flow
    scene's view). This will open the secondary editor that shows a `RotateByEuler`
    action if the flower asset is selected in the scene graph.![Visually composed
    game scenescgs](img/00059.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What this action does is rotate the flower once every second. To see this in
    action, click on the Play button seen just above the secondary editor window timeline.
    We can see how this object will rotate from this action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The action can be shortened or extended by expanding or condensing it in the
    secondary editor timeline. More details about the action can be edited in the
    Inspector window, and if we'd like, we can use the library to add more actions
    to this object or remove the one provided to have it act in a different way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test out a few actions, times, and properties yourself. We can see how, without
    any code, we can set up a scene visually and dynamically control actions of each
    object in that scene. Many of these visual features and actions work for both
    SceneKit and SpriteKit scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually composed game scenescgs](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Look at the `level.scn` file to see a scene with a fully composed level camera
    object (as seen in the previous screenshot). Do you want to make a similar level
    with maybe more obstacles and a different skybox? Copy the level and change those
    assets and name it `level2`. This can save a monumental amount of time in the
    design of games and levels. From Xcode 7 onwards, we have tools directly in the
    IDE that originally were only for the multiplatform game engines. It really puts
    the design back into game design.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the manual code we've gone over could get daunting, especially for those
    of us who may want to get into game design but are still relatively new to coding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to reference a scene from the visually designed tools. Add
    it to the view's root node like we spoke about in the SceneKit basic template
    and it's ready to go. Use code to add spawning enemies, the player, and the 2D
    SpriteKit overlay (which can itself have actions and visual designs in its SKS
    file), and it's a full-fledged game.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the SceneKit framework as well as the latest updates
    and additions to its library, see the full documentation link as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of this chapter, we first spoke briefly about the history of 3D
    game design in iOS and how SceneKit came to be from the necessity to have a first-party,
    dynamically robust framework aimed at the complexities of 3D game development.
    We then went over the basic structure of SceneKit and how it and SpriteKit from
    the previous chapter work off the concept of nodes, starting from the view and
    moving on to the scene node and child nodes in that scene. Next, we went over
    how SpriteKit and SceneKit can be used together in the same scene as we then moved
    on to dissecting the default SceneKit template given to us in Xcode, and its various
    assets. In addition to a review of template project's code, we also reviewed some
    of the features, code, and assets, such as the audio nodes, lend modes, and debug
    options that became available as of iOS 9 / Xcode 7\. Finally, for the remainder
    of the chapter, we spoke much about the Fox demo shown during the *WWDC15* convention
    and the various visual game design features that became available since the announcement
    of Xcode 7.
  prefs: []
  type: TYPE_NORMAL
- en: For our next chapter, we will go into the features of the GameplayKit framework,
    which we introduced briefly when we went over the benefits of using composite-based
    structuring when building our games. With GameplayKit, we can duplicate and reuse
    premade game actions and rules as we did here in this chapter with the visual
    components of our games.
  prefs: []
  type: TYPE_NORMAL
