- en: Chapter 6. Scheduling Work with AlarmManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining the responsiveness of foreground apps has been our primary focus
    throughout this book, and we've explored numerous ways to shift work away from
    the main thread and run work in the background.
  prefs: []
  type: TYPE_NORMAL
- en: In all of our discussions so far, we wanted to get the work done as soon as
    possible, so although we moved it to a background thread, we still performed the
    work concurrently with ongoing main thread operations, such as updating the user
    interface and responding to user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will learn how to defer work with `AlarmManager` to run at
    some distant time in the future, initiating work without user intervention, and
    even waking up the device from an idle state if it is really necessary. Meanwhile,
    we will introduce you to some power saving features introduced with Android Marshmallow
    6 and explain how to adapt your application to this new paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling alarms with AlarmManager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling alarms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling repeating alarms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling alarms in Doze Mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an alarm clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging AlarmManager alarms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling alarms with Activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling alarms with BroadcastReceivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staying awake with WakeLocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring alarms on system boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications of AlarmManager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AlarmManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Performing Work with Looper, Handler, and
    HandlerThread"), *Performing Work with Looper, Handler, and HandlerThread,* we
    learned how to schedule work on a `HandlerThread` using `postDelayed`, `postAtTime`,
    `sendMessageDelayed`, and `sendMessageAtTime`. These mechanisms are fine for short-term
    scheduling of work while our application is running in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we want to schedule an operation to run at some point in the distant
    future, we'll run into problems. First, our application may be terminated before
    that time arrives, removing any chance of the Handler running those scheduled
    operations. Second, the device may be asleep, and with its CPU powered down it
    cannot run our scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution to this is to use an alternative scheduling approach, one that
    is designed to overcome these problems: `AlarmManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.app.AlarmManager` is a class that has been available in the Android
    SDK since the first version, delivering an advanced API to fire off Intents in
    the future at one specific time or time window defined by the user. The schedules
    are managed by the Android system, taking into account the device power cycles
    and states to keep energy consumption at a low level.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `AlarmManager` is a system service that provides scheduling capabilities
    far beyond those of Handler. Being a system service, AlarmManager cannot be terminated
    and has the capacity, under certain conditions, to wake the device from sleep
    to deliver scheduled alarms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The leading features of `android.app.AlarmManager` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to wake up the device from idle states**: The user is able to control
    how the system should handle your alarm when it is in energy saving mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel Alarms**: a mechanism to cancel a previously created alarm based on
    Intent comparison'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update Alarms**: a mechanism to update an existing scheduled alarm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exact and Inexact Alarms**: an API that is able to control the exactness
    of our scheduling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling managed by the Android system**: The alarms will fire even when
    your application is not running, and without consuming any application resources
    to manage the timers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling alarms with AlarmManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we said before, all the alarm operations are managed through the singleton
    object `AlarmManager`, an Android global system service that can be retrieved
    by any class with access to a `Context` instance. As an example, in an `Activity`
    we can get the `AlarmManager` from any member method by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a reference to the `AlarmManager`, we can schedule an alarm to
    deliver a `PendingIntent` object to a `Service`, an `Activity` or `BroadcastReceiver`,
    at a time of our choosing. The simplest way to do that is using the `set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we set an alarm, we must also specify a `type` flag—the first parameter
    to the `set` method. The `type` flag sets the conditions under which the alarm
    should fire and which clock to use for our schedule.
  prefs: []
  type: TYPE_NORMAL
- en: There are two conditions and two clocks, resulting in four possible `type` settings.
  prefs: []
  type: TYPE_NORMAL
- en: The first condition specifies whether or not the device will be woken up if
    it is in a sleeping state at the time of the scheduled alarm—whether the alarm
    is a `wakeup` alarm or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The clocks provide a reference time against which we set our schedules, defining
    exactly what we mean when we set a value to `triggerAtMillis`. We could base our
    schedules on the following time references:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elapsed-time system clock—`android.os.SystemClock`—measures time as the
    number of milliseconds that have passed since the device booted, including any
    time spent in deep sleep. The current time according to the system clock can be
    found using this code term:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The real-time clock (Unix Time) - measures time in milliseconds since the Unix
    epoch. The current time according to the real-time clock can be found as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java, `System.currentTimeMillis()` returns the number of milliseconds since
    midnight on January 1, 1970, Coordinated Universal Time (UTC)—a point in time
    known as the Unix epoch.
  prefs: []
  type: TYPE_NORMAL
- en: UTC is the internationally recognized successor to **Greenwich Mean Time** (**GMT**)
    and forms the basis for expressing international time zones, which are typically
    defined as positive or negative offsets from UTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these two conditions and two clocks, these are the four possible `type`
    values we can use when setting alarms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.app.AlarmManager.ELAPSED_REALTIME`: This schedules the alarm relative
    to the system clock. If the device is asleep at the scheduled time it will not
    be delivered immediately; instead, the alarm will be delivered the next time the
    device wakes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP`: This schedules the alarm
    relative to the system clock. If the device is asleep, it will be woken to deliver
    the alarm at the scheduled time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.app.AlarmManager.RTC`: This schedules the alarm in UTC relative to
    the Unix epoch. If the device is asleep at the scheduled time, the alarm will
    be delivered when the device is next woken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.app.AlarmManager.RTC_WAKEUP`: This schedules the alarm relative to
    the Unix epoch. If the device is asleep it will be awoken, and the alarm is delivered
    at the scheduled time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start setting an alarm at a particular time, to go off 24 hours after
    the initial boot. We''ll use the `TimeUnit` class from the `java.lang.concurrent`
    package to calculate times in milliseconds. To set the previous alarm, we need
    to calculate the number of milliseconds in 24 hours, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set an alarm to go off five minutes from now, using the system time,
    by adding five minutes to the current time. Using the system clock, it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To set an alarm for 9:00 pm today (or tomorrow, if it''s already past 9:00
    pm today), we can use the `Calendar` class to do some time calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'None of the examples so far will wake the device if it is sleeping at the time
    of the alarm. To do that, we need to use one of the `WAKEUP` alarm conditions,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is also important to understand that when the alarm clock time is in the
    past, the alarm will sound immediately after we invoke the `AlarmManager` set
    alarm functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting alarms in recent Android versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If our application targets an API level below 19 (KitKat), scheduled alarms
    will run exactly at the alarm time. For applications targeting KitKat or later,
    the schedule is considered inexact and the system may re-order or group alarms
    to minimize wake-ups and save battery.
  prefs: []
  type: TYPE_NORMAL
- en: After API Level 23, the Android Development team went a little further and Doze
    mode was introduced on the Android System to reduce battery consumption when the
    device is unplugged from the power adapter, motionless, and not used by the user
    for a long period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Doze system will try to decrease the device''s wake-up frequency deferring
    background jobs, network updates, syncs, and our precious alarm until the device
    exits Doze mode or a recurring maintenance window runs to execute pending jobs,
    certain alarms, or synchronization with the network. After the maintenance window
    finishes, the device would enter Doze mode again if it was not used in the meantime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting alarms in recent Android versions](img/Image_B05062_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Doze Mode Timeline'
  prefs: []
  type: TYPE_NORMAL
- en: Doze mode is likely to impact your application and will defer your alarms until
    a maintenance window comes in, unless you use the methods `setAndAllowWhileIdle()`
    and `setExactAndAllowWhileIdle()` to allow the execution of your alarms in a deep
    idle state.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the number of times that the Doze Mode maintenance window runs will
    be less frequent in cases of long-term inactivity, so the impact of this new mechanism
    on our scheduling will increase, hence causing more unpredictable jitters at the
    alarm time.
  prefs: []
  type: TYPE_NORMAL
- en: During the doze mode the applications are also not allowed to access the network,
    the WakeLocks are ignored and Wi-Fi scans are not executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need precision scheduling and you are targeting Marshmallow or later,
    we shall use the new `setExactAndAllowWhileIdle()` method introduced at API level
    23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android system has protection that prevents abuse for exact alarms that
    fire off too frequently. `AlarmManager` only wakes up the device and dispatches
    one alarm per minute, and in low power mode it can be as low as one every 15 mins.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application targets a version between KitKat (API Level 19) and Marshmallow
    (API Level 23), the `setExact` method is enough for timing precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But we''ll need to check that the methods exist before we try to call it; otherwise,
    our app will crash when run under earlier API levels. Lets sketch out our new
    exact alarm code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will deliver our alarm at exactly the specified time on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that you should only use exact scheduling when you really need
    it, for example, to deliver alerts to the user at a specific time. For most other
    cases, allowing the system to adjust our schedule a little to preserve battery
    life is usually acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Android Marshmallow API Level 23 also comes with the `setAndAllowWhileIdle`
    function, which allows us to create an alarm to sound in Doze mode, but with less
    exactness compared to `setExactAndAllowWhileIdle()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system will try to batch these kinds of alarm across the entire system,
    minimizing the number of times the device wakes up, and hence reducing the energy
    consumption of the system. Here is the code to create an alarm that triggers,
    even in Doze mode, 10 hours from now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Testing your alarms in Doze Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to test your application's behavior in doze mode, the Android SDK team
    added some new commands to the dumpsys tool to manually change the device's power
    state from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important to remember that Doze mode requires that your device is
    unplugged from the charger. To force the device to a state where it is disconnected
    from the charger, we should run the following command on a command line with access
    to SDK Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to enter idle mode, we should turn off the screen and run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the device is put in idle mode, we can enable the maintenance window
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the same step again the device goes back to an idle state; however,
    if we want to go back to an active state, we should run the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With these handy commands we are able to verify that the alarm sounds even in
    deep idle states.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a Window alarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more addition in KitKat is `setWindow()`, which introduces a compromise
    between exact and inexact alarms by allowing us to specify the time window within
    which the alarm must be delivered. This still allows the system some freedom to
    play with the schedules for efficiency, but lets us choose just how much freedom
    to allow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we would use `sentindo()` to schedule an alarm to be delivered
    within a 3 minute window—at the earliest 5 minutes from now and at the latest
    8 minutes from now—using the real-time clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Debugging AlarmManager alarms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android System comes with a handy diagnostic tool that outputs to the developer
    a list of registered alarms on the device. To get a list, we run the following
    command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the exact 5 minute alarm on Android API Level 23, the
    system will output our registered alarm on the command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Alarm system tries to organize the alarm execution in batches for battery
    saving purposes, so in the first line we have information about the alarm batch
    that our alarm belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The details of the batch output format are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bfce57`: Batch internal identifier number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num=1`: Number of alarms in this batch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start=6199180`: It refers to the time, in terms of elapsed milliseconds since
    system boot, at which the batch should be started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end=6199180`: It refers to the time, in terms of elapsed milliseconds since
    system boot, at which the batch will end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the batch, our alarm gets detailed over the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d38d44`: An internal identifier number used by the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type 0 (RTC_WAKEUP)`: Alarm type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when`: Alarm time based on the clock time (milliseconds since epoch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag=*walarm*:my_alarm`: Action specified on Intent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.packpublishing.asynchronousandroid`: Application package that created
    the alarm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whenElapsed=+58s670ms`: Refers to the time since the system started at which
    this alarm will be triggered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when= 2015-12-03 22:23:39`: The date/time at which this alarm will be triggered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window= 180000`: Refers to the value specified in the window field when the
    `setWindow()` method is used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeatInterval=0`: Used in repeating alarms to specify the interval between
    repeats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count=0`: Number of times the alarm sounded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operation= PendingIntent...`: Pending intent that will be triggered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the alarm is set, it can be canceled very easily by invoking the `AlarmManger.cancel`
    method with an intent that matches the alarm that we want to cancel.
  prefs: []
  type: TYPE_NORMAL
- en: The process of matching uses the `filterEquals` method of Intent, which compares
    the action, data, type, class, component, package, and categories of both `Intent`
    to test for equivalence. Any extras we may have set in the Intent are not taken
    into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will show you how to create an alarm that fires off
    in 1 hour and the cancel code to dismiss it using different intent instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since in our example we use the same method to construct the set and cancel
    `PendingIntent`, both will have the same action and match, so if the `AlarmManager.cancel`
    runs and it finds a match, the Android system will remove the alarm previously
    set from the list of enabled alarms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To debug the cancellation of your alarm you could verify again with an `adb
    shell dumpsys` alarm that the alarm disappeared from the system alarm batches.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that whenever we create alarm using a pending intent
    with the `FLAG_UPDATE_CURRENT`, we implicitly update any existing alarm with the
    new Intent and its extras.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling repeating alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as setting a one-off alarm, we have the option to schedule repeating
    alarms using `setRepeating()` and `setInexactRepeating()`. Both methods take an
    additional parameter that defines the interval in milliseconds at which to repeat
    the alarm. Generally, it is advisable to avoid `setRepeating()` and always use
    `setInexactRepeating()`, allowing the system to optimize device wake-ups and giving
    more consistent behavior on devices running different Android versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`AlarmManager` provides some handy constants for typical repeat intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now build up an example that creates a repeating alarm to be delivered
    approximately 2 hours from now, then repeating every 15 minutes or so thereafter
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'From API level 19, all repeating alarms are inexact—that is, if our application
    targets KitKat or above, our repeat alarms will be inexact even if we use `setRepeating()`.
    To have similar inexact behavior across all the Android versions you should use
    the `setInexactRepeating()`(API Level 3) rather than `setRepeating()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The inexact repeating tells the system that your alarm time could be adjusted
    to reduce the device waking up frequently and increase the system's overall power
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: If we really need exact repeat alarms, we can use `setExact()`/`setExactAndAllowWhileIdle()`,
    instead, and schedule the next alarm while handling the current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we might increase the repeating alarm interval and even change the `Intent`
    Extras by calling the `setRepeating()` with an Intent that matches the previous
    Intent and the flag `FLAG_UPDATE_CURRENT`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling an alarm clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From API Level 21, `setAlarmClock`, which sets a new alarm and displays a status
    bar alarm icon, was introduced in the `AlarmManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example we are going to create an alarm clock that goes off tomorrow
    at 10:00 pm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a recent device, once we set the previous alarm we see the
    clock icon on the system status bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scheduling an alarm clock](img/Image_B05062_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To cancel the alarm clock, we have to invoke the `cancel` method with a matching
    intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Handling alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learned how to schedule exact and inexact alarms over the `AlarmManager
    Service` singleton, so at this point we are ready to take a look at how to handle
    the alarm in any Android application component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, we can schedule anything that can be started with a `PendingIntent`,
    which means we can use alarms to start Activities, Services, and `BroadcastReceivers`.
    To specify the target of our alarm, we need to use the static factory methods
    of `PendingIntent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All static methods offered to create a pending intent, receiving as arguments
    a Context object, an integer request code to identify the pending intent, an Intent
    or an array of Intents that will be delivered to the component, and finally an
    integer to specify the `PendingIntent` flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PendingIntent` flags used on the factory method play an important role
    in Intent handling, so it is crucial to understand the flags that we can use to
    indicate how the system should process an intent that already exists, to make
    an Intent immutable or to set an intent that is only delivered once:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLAG_CANCEL_CURRENT`: Indicates that the system should invalidate and generates
    a new Intent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLAG_NO_CREATE`: If the `PendingIntent` does not already exist, a new intent
    is not created and factory method returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLAG_ONE_SHOT`: Indicates that the pending intent created can only be used
    once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLAG_UPDATE_CURRENT`: Indicates that if the pending intent already exists,
    the Pending Intent is replaced with this one, including all the extras.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLAG_IMMUTABLE`: Indicates that the pending intent created cannot be modified
    afterwards. This flag is only available since API Level 23.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases we want to completely replace an existing Intent with a new one,
    so using `FLAG_UPDATE_CURRENT` is the right flag value to use.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll see build up examples for each type of `PendingIntent`
    that can be used with `AlarmManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling alarms with Activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting an `Activity` from an alarm is as simple as registering the alarm with
    a `PendingIntent` created by invoking the static `getActivity` method of `PendingIntent`.
  prefs: []
  type: TYPE_NORMAL
- en: When the alarm is delivered, the `Activity` will be started and brought to the
    foreground, displacing any app that was currently in use. Keep in mind that this
    is likely to surprise and perhaps annoy users!
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting Activities with alarms, we will probably want to set `Intent.FLAG_ACTIVITY_CLEAR_TOP`;
    so that if the application is already running, and our target `Activity` is already
    on the back stack, the new intent will be delivered to the old `Activity` and
    all the other activities on top of it will be closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Not all Activities are suited to being started with `getActivity`. We might
    need to start an `Activity` that normally appears deep within the app, where pressing
    back does not exit to the home screen, but returns to the next `Activity` on the
    back-stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine a situation where we want to start an `Activity` that is going
    to display the details about the model, and we want have an `Activity` that lists
    the models on the backstack.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where `getActivities` comes in. With `getActivities`, we can push more
    than one `Activity` onto the back-stack of the application, allowing us to populate
    the back-stack to create the desired navigation flow when the user presses "back".
    To do this, we create our `PendingIntent` by sending an array of Intents to `getActivities`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The array of Intents specifies the `Activity` to launch, in order. The logical
    sequence of events when this alarm is delivered is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the application is already running, any Activities on the back-stack above
    `ListActivity` are finished and removed, because we set the `Intent.FLAG_ACTIVITY_CLEAR_TOP`
    flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ListActivity` is (re)started.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DetailActivity` is started and placed on the back-stack above `ListActivity`.
    The `DetailActivity` becomes the foreground `Activity`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling alarms with `Activity` is good to know about, but is not a technique
    we will use often, since it is so intrusive. We are much more likely to want to
    handle alarms in the background, which we'll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Handling alarms with BroadcastReceiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We met `BroadcastReceiver` already in [Chapter 5](ch05.html "Chapter 5. Interacting
    with Services"), *Interacting with Services*, where we used it in an `Activity`
    to receive broadcasts from a `Service`. In this section, we'll use `BroadcastReceiver`
    to handle alarms set on the `AlarmManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '`BroadcastReceivers` can be registered and unregistered dynamically at runtime
    like we did in [Chapter 5](ch05.html "Chapter 5. Interacting with Services"),
    *Interacting with Services*, with `Service`, or statically in the Android manifest
    file with a `<receiver>` element, and can receive alarms regardless of how they
    are registered.'
  prefs: []
  type: TYPE_NORMAL
- en: It is more common to use a statically registered receiver for alarms, because
    these are known to the system and can be invoked by alarms to start an application
    if it is not currently running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a static defined `BroadcastReceiver` that is able to dispatch
    an SMS to a phone number when an alarm sounds. First we will define our `BroadcastReceiver`
    in the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `<intent-filter>` element gives us the opportunity to say which Intents
    we want to receive by specifying the action, data, and categories that should
    match.
  prefs: []
  type: TYPE_NORMAL
- en: Now its time to write the code to set up the schedule. To do that, we will create
    an Activity that is going to provide a form to set the destination number, the
    number of hours to defer the message dispatch, and the message text to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `SMSDispatchActivity` activity we will build a `PendingIntent` for the
    `sms_dispatcher` action, passing the arguments required over the Intent extras:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When this alarm is due, `AlarmManager` will wake the device even in deep idle
    states—if it isn't already awake—and deliver the Intent to the `BroadcastReceiver`
    is `onReceive` method. The Alarm Manager will hold a wake lock as long as the
    alarm receiver's `onReceive()` runs. Therefore, it guarantees that the device
    will remain awake at least until `onReceive` completes, which means we can be
    sure of getting some work done before the device will be allowed to return to
    sleep.
  prefs: []
  type: TYPE_NORMAL
- en: Working with BroadcastReceiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the system delivers an alarm to our `BroadcastReceiver` it does so on the
    main thread, so the usual main thread limitations apply; we cannot perform networking
    and we should not perform heavy processing or use blocking operations.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a statically registered `BroadcastReceiver` has a very limited
    lifecycle. It cannot create user interface elements other than toasts or notifications
    posted via `NotificationManager`, the `onReceive` method must complete within
    10 seconds or its process may be killed, and once `onReceive` completes, the receiver's
    life is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the work that we need in response is not intensive, we can simply complete
    it during `onReceive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That's it; once the alarm fires off, the `BroadcastReceiver.onReceive` gets
    called dispatching an SMS to the destination number with the text specified on
    the UI Form.
  prefs: []
  type: TYPE_NORMAL
- en: We can make this more useful by delivering a notification to the user when we
    receive the message delivery report from the mobile network.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a new action on the `AndroidManifest.xml` to be processed
    by our `BroadcastReceiver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will change the `onReceive` method to process both kinds of `Intent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the code to dispatch the message to set up a new `PendingIntent`
    for the message delivery report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the code to process the message delivery report intent and
    inform the user, in the notification drawer, if the message was delivered with
    success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Although we can spend up to 10 seconds doing work in our `BroadcastReceiver`,
    we really shouldn't—if the app is in the foreground when the alarm is triggered
    the user will suffer noticeable lag if `onReceive` takes more than a hundred milliseconds
    to complete on the main Thread. Exceeding the 10 second budget will cause the
    system to kill the application and report a background ANR.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if we try to execute the `onReceive` work in a background thread and
    the `onReceive` returns, the Android system is allowed to recycle the component.
    Whenever no other Android component is running, the system could consider the
    process to be empty and aggressively kill it, stopping our background work immediately.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the UI glitching, and the `BroadcastReceiver` recycling, on Android
    API Level 11, the `BroacastReceiver.goAsync` method was announced to delegate
    work to a background thread for up to 10 seconds – we'll discuss this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous work with goAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If our application targets a minimum API level of 11, we can use a feature
    of `BroadcastReceiver.goAsync` to handle the `onReceive` execution in a parallel
    line of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With `goAsync` we can extend the lifetime of a `BroadcastReceiver` instance
    beyond the completion of its `onReceive` method, provided the whole operation
    still completes within the 10 second budget.
  prefs: []
  type: TYPE_NORMAL
- en: If we invoke `goAsync`, the system will not consider the `BroadcastReceiver`
    to have finished when `onReceive` completes. Instead, the `BroadcastReceiver`
    lives on until we call finish on the `PendingResult` returned to us by `goAsync`.
    We must ensure that finish is called within the 10 second budget, otherwise the
    system will kill the process with a background ANR.
  prefs: []
  type: TYPE_NORMAL
- en: Using `goAsync`, we can offload work to background threads using any appropriate
    concurrency construct—for example, an `AsyncTask`—and the device is guaranteed
    to remain awake until we call finish on the `PendingResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our SMS dispatcher to send the message asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AsyncTaskCompat` has been available in the Android Support Library since version
    21.0.0 and allows the developer to execute multiple `AsyncTask` in parallel on
    a pool of threads in a backward compatible fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: This is nice, though its utility is limited by the 10 second budget and the
    effects of fragmentation (it is only available to API level 11 or above). In the
    next section, we'll look at scheduling long-running operations with services.
  prefs: []
  type: TYPE_NORMAL
- en: Handling alarms with Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like starting Activities, starting a Service from an alarm involves scheduling
    an appropriate `PendingIntent` instance, this time using the static `getService`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you already know, the Service should be globally defined on the Android
    Manifest with a service element. Given that we are calling it explicitly using
    the class name, we only need to define the service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We almost certainly want our Service to do its work off the main thread, so
    sending work to an `IntentService` this way seems ideal, and an `IntentService`
    will also stop itself when the work is finished. This works reliably if the device
    is awake.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the device is asleep we have a potential problem. `AlarmManager`
    documentation tells us that the only guarantee we have about the wakefulness of
    the device is that it will remain awake until a `BroadcastReceiver` is `onReceive`
    method completes.
  prefs: []
  type: TYPE_NORMAL
- en: Since directly starting a `Service` does not involve a `BroadcastReceiver`,
    and in any case is an asynchronous operation, there is no guarantee that the `Service`
    will have started up before the device returns to sleep, so the work may not get
    done until the device is next awakened.
  prefs: []
  type: TYPE_NORMAL
- en: This is almost certainly not the behavior we want. We want to ensure that the
    Service starts up and completes its work, regardless of whether the device was
    awake when the alarm was delivered. To do that, we'll need a `BroadcastReceiver`
    and a little explicit power management, as we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Staying awake with WakeLocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter we learned that we can use a `BroadcastReceiver` to
    handle alarms, and even do work in the background for up to 10 seconds, though
    only on devices running API level 11 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we saw that handling alarms directly with services
    is not a reliable solution for scheduling long-running work, since there is no
    guarantee that our `Service` will start up before the device returns to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: We have a problem! If we want to perform long-running work in response to alarms,
    we need a solution that overcomes these limitations.
  prefs: []
  type: TYPE_NORMAL
- en: What we really want is to start a `Service` to handle the work in the background,
    and to keep the device awake until the `Service` has finished its work. Fortunately,
    we can do that by combining the waking guarantees of `BroadcastReceiver` to get
    the `Service` started, then keep the device awake with explicit power management
    using `PowerManager` and `WakeLock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might guess, `WakeLock` is a way to force the device to stay awake.
    `WakeLocks` come in various flavors, allowing apps to keep the screen on at varying
    brightness levels or just to keep the CPU powered up in order to do background
    work. To use `WakeLocks`, our application must request an additional permission
    in the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four different kinds of wakelock that may affect the system power
    management differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PowerManager.PARTIAL_WAKE_LOCK`: Ensures that the CPU is on, leaving the screen
    and the keyboard in the current state (idle or awake).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PowerManager.SCREEN_DIM_WAKE_LOCK`: Ensures that the CPU is on, the screen
    is on and may be in a dimmed state, and the keyboard could remain off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PowerManager.SCREEN_BRIGHT_WAKE_LOCK`: Ensures that the CPU is on, the screen
    is on full brightness, and the keyboard could remain off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PowerManager.FULL_WAKE_LOCK`: Ensures that the CPU is on and the screen and
    keyboard backlight are at full brightness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To keep the CPU powered up while we do background work in a `Service`, we only
    need `PARTIAL_WAKE_LOCK`, which won''t keep the screen on, and which we can request
    from the `PowerManager` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to acquire a `WakeLock` during our `BroadcastReceiver` is `onReceive`
    method, and find some way to hand it to our `Service` so that the `Service` can
    release the lock once its work is done.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `WakeLock` instances are not parcelable, so we can't just send
    them to the `Service` in an Intent. The simplest solution is to manage the `WakeLock`
    instance as a static property that both the `BroadcastReceiver` and the target
    Service can reach.
  prefs: []
  type: TYPE_NORMAL
- en: This is not difficult to implement, but we don't actually need to implement
    it ourselves—we can use the handy v4 support library class, `WakefulBroadcastReceiver`.
  prefs: []
  type: TYPE_NORMAL
- en: '`WakefulBroadcastReceiver` exposes two static methods that take care of acquiring
    and releasing a partial `WakeLock`. We can acquire the `WakeLock` and start the
    `Service` with a single call to `startWakefulService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And when our Service has finished its work, it can release the `WakeLock` with
    the corresponding call to `completeWakefulIntent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will update our SMS schedule `BroadcastReceiver` to acquire the `wakelock`
    and dispatch the intent over the `startWakefulService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We must make sure to release the `WakeLock` once the Service has finished its
    work, otherwise we''ll drain the battery by keeping the CPU powered up unnecessarily.
    Let''s implement the `IntentService` that receives the intent from the wakeful
    `BroadcastReceiver` and sends the message in the service background thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is great—by using a statically registered `BroadcastReceiver` we've ensured
    that we receive the alarm, even if our application is not running when the alarm
    is due. When we receive the alarm, we acquire a `WakeLock`, keeping the device
    awake while our `Service` starts up and does its potentially long-running work.
  prefs: []
  type: TYPE_NORMAL
- en: Once our work is done, we release the `WakeLock` to allow the device to sleep
    again and conserve power.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting alarms after a system reboot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AlarmManager` service is a convenient class to schedule working on your
    Android application; however, when the device shuts down or reboots, all your
    alarms will be lost since the system does not retain them between system restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reset the alarm, we should persist your alarms and create a `BroadcastReceiver`
    that sets our alarms whenever a system boot happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In order to store our alarms, we created a `POJO` class `SMSSchedule` as the
    model for our schedules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, in the Android Manifest we have to register our `BroadcastReceiver`
    to receive the boot event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add the permission to receive the boot complete event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now after a system reboot, we re-create our alarms and they fire off even after
    a system reboot. We also advise that the alarms using `ELAPSED_REALTIME` should
    be adjusted after a system reboot since the the clock where those alarms are based
    is going to be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of AlarmManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AlarmManager` allows us to schedule work to run without user intervention.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can arrange to do work pre-emptively, for example, to prepare
    data that our application will need to present to the user when they next open
    the application, or to alert the user to new or updated information with notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases include things like periodically checking for new e-mails, SMS
    scheduling, time notifications, periodic data processing, downloading new editions
    of periodical publications (for example, daily newspapers and magazines), or uploading
    data from the device to a cloud backup service.
  prefs: []
  type: TYPE_NORMAL
- en: The `AlarmManager` is able to start future work effectively but the API should
    be used carefully to keep your application battery power consumption at low levels.
    To achieve that, the developer should try to keep the alarm frequency under certain
    levels and use the exact set functions that force the device to wake up only in
    cases where it is really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to schedule work for our applications to perform
    at some time in the distant future, either as a one-shot operation or at regular
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to set alarms relative to the system clock or real time, how to wake
    the device up from a deep sleep and doze mode, how to cancel alarms when we no
    longer need them, and how to set exact alarms on the most recent Android versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we introduced the reader to Doze Mode, a new power management
    feature that saves battery cycles by deferring jobs and tasks to a maintenance
    window. We learned how to test our alarms taking into account the new power management
    states introduced by the doze mode.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to debug alarms created with `AlarmManager` and how to analyze
    the information printed from the `dumpsys` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Our exploration covered various options for responding to alarms, including
    bringing an `Activity` to the foreground or doing work directly in a `BroadcastReceiver`,
    synchronously or asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we arranged for an `IntentService` to be launched with a `WakeLock`
    to keep the CPU from powering down while our long-running background work is completed,
    and to finish we learned how to re-create the alarms after a system boot using
    a boot `BroadcastReceiver`.
  prefs: []
  type: TYPE_NORMAL
- en: The `AlarmManager` is a very useful class to schedule work in the background
    but it has some major disadvantages. First, it does not take into account the
    device current context, like if the device is connected to the charger, or whether
    the device is connected to a Wi-Fi network. Second, we can only schedule our background
    work based on the time condition.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these issues, the Android team introduced in Android Lollipop API Level
    5.0 the `JobScheduler` API; an API that allows the execution of background work
    based on a number of time and context criteria.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we are going to explain how to exercise the `JobScheduler`
    API to schedule tasks that will only run when the appropriate energy and environment
    device conditions are met.
  prefs: []
  type: TYPE_NORMAL
