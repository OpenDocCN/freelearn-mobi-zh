- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using DataStore to Store Data and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern Android Development practices help Android developers create better applications.
    DataStore is a data storage solution provided by the Android Jetpack library.
    It allows developers to store key-value pairs or complex objects asynchronously
    and with consistency guarantees. Data is critical in Android development, and
    how we save and persist data matters. In this chapter, we will explore using DataStore
    to persist our data and look at best practices using DataStore.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DataStore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Dependency Injection to DataStore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Android Proto DataStore versus DataStore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data migration with DataStore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for our DataStore instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DataStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building mobile applications, it is critical to ensure that you persist
    your data in order to allow for smooth loading, reduce network issues, or even
    handle data entirely offline. In this recipe, we will look at how to store data
    in our Android applications using the Modern Android Development Jetpack library
    called DataStore.
  prefs: []
  type: TYPE_NORMAL
- en: DataStore is a data storage solution for Android applications that enables you
    to store key-value pairs or any typed objects with protocol buffers. Moreover,
    DataStore uses Kotlin coroutines and flows to store data consistently, transactionally,
    and asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If you have built Android applications before, you might have used `SharedPreferences`.
    The new Preferences DataStore aims to replace this old method. It is also fair
    to say that Preferences DataStore harnesses the power of `SharedPreferences` since
    they are pretty similar. In addition, Google’s documentation recommends that if
    you’re currently using `SharedPreferences` in your project to store data, you
    consider migrating to the latest DataStore version.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to store data in Android is by using Room. This will be covered
    in [*Chapter 6*](B18827_06.xhtml#_idTextAnchor283), *Using the Room Database and
    Testing*; for now, we will just look at DataStore. Moreover, it is essential to
    note that DataStore is ideal for simple or small datasets and does not have support
    for partial updates or referential integrity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go ahead and create a new, empty Compose project and call it `DataStoreSample`.
    In our example project, we will create a task entry app where users can save tasks.
    We will allow users to enter only three tasks, then use DataStore to store the
    tasks and later log the data and see whether it was inserted correctly. An additional
    exercise to try is to display data when users want to see it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our newly created project, let’s go ahead and delete code that we don’t
    need. In this case, we’re referring to the `Greeting(name: String)` that comes
    with all empty Compose projects. Keep the Preview function since we will use it
    to view the screen we create.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s go on and add the required dependencies for DataStore and sync the
    project. Also, note that there are versions of the DataStore library that are
    specific to RxJava 2 and 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new package and call it `data`. Inside `data`, create a new Kotlin
    data class and call it `Tasks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s now go ahead and construct our data class with the expected input fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the same package, let’s add a `TaskDataSource` enum since we will reuse
    this project to showcase saving data using Proto DataStore in the *Using Android
    Proto DataStore versus* *DataStore* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside our package, let’s go ahead and add a `DataStoreManager` interface. Inside
    our class, we will have a `saveTasks()` function to save the data and a `getTasks()`
    function to help us retrieve the saved data. A `suspend` function in Kotlin is
    simply a function that can be paused and resumed later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition, the suspend functions can execute long-running operations and
    await completion without blocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement our interface, so let’s go ahead and create a `DataStoreManagerImpl`
    class and implement the `DataStoreManager`. To refresh your knowledge of Flows,
    refer to [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137), *Handling the UI State
    in Jetpack Compose and* *Using Hilt*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that once we’ve implemented the interface, we brought a view
    to the function, but it says `TODO`, and nothing has been implemented. To continue
    with this step, let’s go ahead and add DataStore and pass `Preference` in our
    constructor. We will also need to create the string preference key for each task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s finish our implementation of the `DataStore` section by adding
    functionality to the `getTasks` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `MainActivity` class, let’s go on and create a simple UI: three `TextField`
    and a **Save** button. The **Save** button will save our data, and we can try
    to log data once everything works as expected. Refer to the *Technical requirements*
    section of this chapter to get the UI code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.1 – The DataStore UI exam\uFEFFple](img/Figure_5.1_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The DataStore UI example
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our implementation ready, in the following recipe, *Adding
    Dependency Injection to DataStore*, we will add Dependency Injection and then
    glue everything together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new Modern Android Development Jetpack library called Preferences DataStore’s
    main objective is to replace `SharedPreferences`. To implement Preferences DataStore,
    as you have seen in the recipe, we use a DataStore interface that takes in a `Preference`
    abstract class, and we can use this to edit and map the entry data. Furthermore,
    we create keys for the crucial parts of the key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To save our data in DataStore, we use `edit()`, which is a suspend function
    that needs to be called from `CoroutineContext`. A key difference in using Preferences
    DataStore compared to `SharedPreferences` is that DataStore is safe to call on
    the UI thread since it uses `dispatcher.IO` under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: You also do not need to use `apply{}` or `commit` functions to save the changes,
    as is required in `SharedPreferences`. Moreover, it handles data updates transactionally.
    More features are listed in *Figure 5**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com](img/Figure_5.2_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com
  prefs: []
  type: TYPE_NORMAL
- en: There is more to learn, and it is fair to acknowledge that what we covered in
    this recipe is just a tiny part of what you can do with DataStore. We will cover
    more features in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Dependency Injection to DataStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dependency Injection is an important design pattern in software engineering,
    and its use in Android app development can lead to cleaner and more maintainable
    code. When it comes to DataStore in Android, which is a modern data storage solution
    introduced in Android Jetpack, adding Dependency Injection can bring several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: By using Dependency Injection, you can separate the concerns of creating an
    instance of DataStore from the code that uses it. This means that your business
    logic code will not have to worry about how to create a DataStore instance and
    can instead focus on what it needs to do with the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection makes it easier to write unit tests for your app. By injecting
    a mock DataStore instance into your tests, you can ensure that your tests are
    not affected by the actual state of the DataStore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection can help you break down your code into smaller, more manageable
    modules. This makes it easier to add new features or modify existing ones without
    affecting the entire code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Dependency Injection, you can easily switch between different implementations
    of DataStore. This can be useful when testing different types of data storage
    or when migrating from one storage solution to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to have completed the previous recipe to continue with this one by
    executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your project and add the necessary Hilt dependency. See the *Handling the
    UI State in Jetpack Compose and Using Hilt* recipe in [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137)
    if you need help setting it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let’s go ahead and add our `@HiltAndroidApp` class, and in our `Manifest`
    folder, add the `.name =` `TaskApp: android:name=".TaskApp"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have implemented Dependency Injection, let’s go ahead and add `@AndroidEntryPoint`
    to the `MainActivity` class, and in `DataStoreManagerImpl`, let’s go ahead and
    add the `@Inject constructor`. We should have something similar to the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a new folder and call it `di`; this is where we will
    put our `DataStoreModule` class. We create a file called `store_tasks` to store
    the Preference values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need to create an `abstract` class for `DataStoreManagerModule`
    inside our `di` package. In order to reduce the boilerplate code using manual
    Dependency Injection, our application also supplies the required dependencies
    to the classes that need them. You can learn more about this in [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and* *Using Hilt*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now go ahead and create a new package and call it `service`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also ensure we have the required dependencies for the newly created service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we are done with Dependency Injection and adding all the functionalities
    required for DataStore, we will go ahead and add a `ViewModel` class and implement
    functionality to save the data once the user clicks the Save button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `saveTaskData` function inside the Compose Save button in the Compose
    view to save our data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we will need to verify that everything is working, that is, our UI and
    data storing process. We can verify this, by typing input data in our TextFields
    and clicking the Save button, and when we log the message it confirms the data
    is indeed saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The entry of tasks](img/Figure_5.3_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The entry of tasks
  prefs: []
  type: TYPE_NORMAL
- en: If you missed it initially, the code for this view can be found in the *Technical
    requirement* section. Now, you will notice that when we enter the data, as in
    *Figure 5**.4*, we should be able to log the data on our Logcat and verify that
    our data was inserted correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The entry of tasks through debugging](img/Figure_5.4_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The entry of tasks through debugging
  prefs: []
  type: TYPE_NORMAL
- en: A log message should also be displayed in the Logcat tab if all is working as
    expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.5 – The debug log indicating that data was i\uFEFFnserted correctly](img/Figure_5.5_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The debug log indicating that data was inserted correctly
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we opted to use Dependency Injection to supply the required
    dependencies to specific classes. We’ve already covered what Dependency Injection
    is in depth, so we will not explain it again but instead talk about the modules
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we created `DataStoreManagerModule` and `DataStoreModule`,
    and all we did was supply the required dependencies. We created a file and called
    it `store_tasks`, which helps us store the Preference values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, DataStore uses coroutines and returns a flow value. Some important
    rules to remember while using DataStore, as per the documentation, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: DataStore requires only one instance for a given file in the same process. Hence,
    we should never create more than one instance of DataStore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always have the generic `DataStore` type be immutable to reduce unnecessary
    and hard-to-trace bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should never mix the usage of a single-process DataStore and multi-process
    DataStore in the same file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an exercise, you can try to add another button and display the saved data
    in a lazy column or a text field.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to learn about DataStore, and this recipe has only given you an
    overview of what you can do with DataStore. You can learn more by following the
    link at [https://developer.android.com/topic/libraries/architecture/datastore](https://developer.android.com/topic/libraries/architecture/datastore).
  prefs: []
  type: TYPE_NORMAL
- en: Using Android Proto DataStore versus DataStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 5**.2* shows the differences between `PreferencesDataStore`, `SharedPreferences`,
    and `ProtoDataStore`. In this recipe, we will explore how we can use Proto DataStore.
    The Proto DataStore implementation uses DataStore and Protocol Buffers to persist
    typed objects to the disk.'
  prefs: []
  type: TYPE_NORMAL
- en: Proto DataStore is similar to Preferences DataStore, but unlike Preferences
    DataStore, Proto does not use key-value pairs and just returns the generated object
    in the flow. The file types and structure of the data depend on the schema of
    the `.``protoc` files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use our already created project to show how you can use Proto DataStore
    in Android. We will also use already created classes and just give the functions
    different names.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to start by setting up the required dependencies, so let’s go
    ahead and add the following to our Gradle app-level file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will need to add `protobuf` to `plugins` in our `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to add the `protobuf` configuration to our `build.gradle` file
    to finalize our setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside our `package` folder, we will need to add our `proto` file under
    `app/src/main/`, then create a new directory and call it `proto`. You should now
    have this in your `app/src/main/proto` file directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That was a lot to set up. We can now start adding code to hook everything up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify classes that might need `ProtoDataStore`. First, let’s add `PROTO_DATA_STORE`
    to the `TaskDataSource` enum class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `DataStoreManager`, let’s add `saveTaskToProtoStore()` and `getUserFromProtoStore()`,
    and our new interface will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we just modified our interface, we will need to go ahead and add new
    functionalities to the implementation class. You will also notice that the project
    will complain once you add the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As recommended, we will need to define a class that implements `Serializer<Type>`,
    where the type is defined in the Proto file. The purpose of this serializer class
    is to tell DataStore how to read and write our data type. So, let’s create a new
    object and call it `TaskSerializer()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TaskPreference` class is auto-generated, and you can access it directly
    by clicking on it but cannot edit it. Auto-generated files are not editable unless
    you change the original file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A screenshot showing the auto-generated TaskPreference class](img/Figure_5.6_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A screenshot showing the auto-generated TaskPreference class
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our data type class, we need to create a `taskProtoDataStore:
    DataStore<TaskPreference>` with the context used with DataStore. Hence, inside
    `DataStoreModule`, let’s go ahead and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s go back to `DataStoreManagerImpl` and work on the functions that
    we are yet to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `TaskService`, we will also go ahead and add `getTasksFromProto`, and `getTasks()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you implement an interface, at first the class that is being implemented
    will might show compile error, which will prompt you to override the interface
    functionalities into the class. Hence, inside the `TaskServiceImpl` class, add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, now that we have all our data saved, we can Log to ensure the data
    is as expected on the UI; check out the link with the code in the *Technical requirements*
    section to see how this is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Apple M1 has a reported problem with proto. There is an issue open for this;
    follow this link to resolve the issue: [https://github.com/grpc/grpc-java/issues/7690](https://github.com/grpc/grpc-java/issues/7690).
    Hopefully, it will be fixed by the time the book is published. It is important
    to note that if you use the `DataStore-preferences-core` artifact with Proguard,
    you have to manually add Proguard rules to your rule file to prevent your already
    written fields from being deleted. Also, you can follow the same process to Log
    and check whether the data is inserted as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that we stored our custom data type as an instance. That
    is what Proto DataStore does; it stores data as instances of custom data types.
    The implementations require us to define a schema using protocol buffers, but
    it provides type safety.
  prefs: []
  type: TYPE_NORMAL
- en: In Android's Proto Datastore library, the `Serializer<Type>` interface converts
    objects of a specific type (`Type`) into their corresponding protocol buffer format
    and vice versa. This interface provides methods for serializing objects to bytes
    and deserializing bytes back into objects.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers in Android is a language and platform-neutral extensible mechanism
    for serializing your structured data. Protocol buffers encodes and decodes your
    data in a binary stream that is really lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: The override val defaultValue is used when defining a property in a data class
    or a serialized model class. It is part of the Kotlin Serialization library, which
    is commonly used for serializing and deserializing objects to and from different
    data formats such as JSON or protocol buffers.
  prefs: []
  type: TYPE_NORMAL
- en: We expose the appropriate property by exposing the flow DataStore data from
    our stored object and writing a proto DataStore that provides us with an `updateData()`
    function that transactionally updates a stored object.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateData` function gives us the current state of the data as an instance
    of our data type and updates it in an atomic read-write-modify operation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is more to learn about how to create defined schemas. You can check out
    the protobuf language guide here: [https://developers.google.com/protocol-buffers/docs/proto3](https://protobuf.dev/programming-guides/proto3/).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling data migration with DataStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have built Android applications before, you might have used `SharedPreferences`;
    the good news now is that there is support for migration, and you can migrate
    from `SharedPreferences` to DataStore using `SharedPreferenceMigration`. As with
    any data, we will always modify our dataset; for instance, we might want to rename
    our data model values or even change their type.
  prefs: []
  type: TYPE_NORMAL
- en: In such a scenario, we will need a DataStore to DataStore migration; that is
    what we will be working on in this recipe. The process is pretty similar to the
    migration from `SharedPreferences`; as a matter of fact, `SharedPreferencesMigration`
    is an implementation of the `DataMigration` interface class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we just created a new `PreferenceDataStore`, we will not need to migrate
    it, but we can look at ways to implement a migration in case a need arises.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at how you can utilize the knowledge learned to
    help you when a need to migrate to DataStore arises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the interface that helps with migration. The following
    code section showcases the `DataMigration` interface, which `SharedPreferencesMigration`
    implements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Tasks` data, we might want to change the entries to `Int`; this means
    changing one of our data types. We will imagine this scenario and try to create
    a migration based on this. We can start by creating a new `migrateOnePreferencesDataStore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s go on to implement `DataMigration` and override its functions. You
    will need to specify your condition for whether the migration should happen. The
    migration data shows instructions on how exactly the old data is transformed into
    new data. Then, once the migration is over, clean up the old storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s create the `oldToNew()` function, which is where we can add
    the data we want to migrate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better understand how `DataMigration` works, we will need to look into the
    functions that are in the `DataMigration` interface. In our interface, we have
    three functions, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: The `shouldMigrate()` function, as the name suggests, establishes whether the
    migration needs to be performed or not. If, for instance, no migration is done,
    which means this will return `false`, then no migration or cleanup will occur.
    Also, it is crucial to note that this function is initialized every time we call
    our DataStore instance. `Migrate()`, on the other hand, performs the migration.
  prefs: []
  type: TYPE_NORMAL
- en: By chance, if the action fails or does not work as expected, DataStore will
    not commit any data to the disk. Furthermore, the cleanup process will not occur,
    and an exception will be thrown. Finally, `cleanUp()`, as it suggests, just clears
    any old data from previous data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for our DataStore instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests is crucial in Android development, and in this recipe, we will
    write some tests for our DataStore instance. To test our DataStore instance or
    any DataStore instance, we first need to have instrumentation testing set up since
    we will be reading and writing in actual files (DataStore), and it is vital to
    verify that accurate updates are being made.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a simple unit test to test our view model function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our unit test folder, create a new folder and call it `test`, and inside
    it, go ahead and create a new class called `TaskViewModelTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will need to add some testing dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have added the required dependencies, let’s go ahead and create
    our mock task service class and mock it, then initialize it in the setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we use a coroutine, we will set up our dispatcher in @`Before annotation`
    and clear any stored data in the `@After` annotation using the `Dispatchers.resetMain()`.
    If you run your tests without setting up a coroutine, they will fail with an error.
    The module with the `Main` dispatcher failed to initialize. For tests, `Dispatchers.setMain`
    from the `kotlinx-coroutines-test` module can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that is completed, let’s go on and create a new test called `Verify add
    tasks function adds tasks as needed`. In this test, we will create a `fakeTask`,
    add those tasks to `saveTaskData`, and ensure data is inserted as expected by
    checking that we did not store `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, when you run the unit test, it should pass, and you will see a green
    check mark.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The test passing in the view model](img/Figure_5.7_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The test passing in the view model
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different mocking libraries used in Android: `Mockito`, `Mockk`,
    and more. In this recipe, we used `Mockk`, a user-friendly mocking library for
    Android. `testImplementation "io.mockk:mockk:1.13.3"` is used for unit tests,
    and `androidTestImplementation "io.mockk:mockk-android:1.13.3"` is used for UI
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the UI, we will need to follow a pattern, creating a test DataStore
    instance with default values stored inside it. Then, we create the test subject
    and verify that the test DataStore values coming from our function match the expected
    results. We will also need to use `TestCoroutineDispatcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code performs the execution of the coroutines, which is, by default,
    immediate. This simply means any tasks scheduled to be run without delays are
    executed immediately. We also use the same coroutines for our view models. That
    is also because DataStore is based on Kotlin coroutines; hence we need to ensure
    our tests have the right setup.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is more to learn about DataStore. We cannot cover it all in just one
    chapter. For more information on DataStore, that is, Preference and Proto, you
    can check out this link: [https://developer.android.com/topic/libraries/architecture/datastore](https://developer.android.com/topic/libraries/architecture/datastore).'
  prefs: []
  type: TYPE_NORMAL
