- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Using DataStore to Store Data and Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DataStore 存储数据并进行测试
- en: Modern Android Development practices help Android developers create better applications.
    DataStore is a data storage solution provided by the Android Jetpack library.
    It allows developers to store key-value pairs or complex objects asynchronously
    and with consistency guarantees. Data is critical in Android development, and
    how we save and persist data matters. In this chapter, we will explore using DataStore
    to persist our data and look at best practices using DataStore.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Modern Android Development 实践帮助 Android 开发者创建更好的应用程序。DataStore 是 Android Jetpack
    库提供的数据存储解决方案。它允许开发者异步和具有一致性保证地存储键值对或复杂对象。数据在 Android 开发中至关重要，我们如何保存和持久化数据至关重要。在本章中，我们将探讨使用
    DataStore 持久化我们的数据，并查看使用 DataStore 的最佳实践。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Implementing DataStore
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 DataStore
- en: Adding Dependency Injection to DataStore
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖注入添加到 DataStore
- en: Using Android Proto DataStore versus DataStore
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Android Proto DataStore 与 DataStore
- en: Handling data migration with DataStore
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DataStore 处理数据迁移
- en: Writing tests for our DataStore instance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的 DataStore 实例编写测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在 [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five)
    找到。
- en: Implementing DataStore
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 DataStore
- en: When building mobile applications, it is critical to ensure that you persist
    your data in order to allow for smooth loading, reduce network issues, or even
    handle data entirely offline. In this recipe, we will look at how to store data
    in our Android applications using the Modern Android Development Jetpack library
    called DataStore.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建移动应用程序时，确保您持久化数据对于实现平滑加载、减少网络问题或完全离线处理数据至关重要。在本例中，我们将探讨如何使用名为 DataStore 的
    Modern Android Development Jetpack 库在 Android 应用程序中存储数据。
- en: DataStore is a data storage solution for Android applications that enables you
    to store key-value pairs or any typed objects with protocol buffers. Moreover,
    DataStore uses Kotlin coroutines and flows to store data consistently, transactionally,
    and asynchronously.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: DataStore 是 Android 应用程序的数据存储解决方案，它允许您使用协议缓冲区存储键值对或任何类型对象。此外，DataStore 使用 Kotlin
    协程和流来一致、事务和异步地存储数据。
- en: If you have built Android applications before, you might have used `SharedPreferences`.
    The new Preferences DataStore aims to replace this old method. It is also fair
    to say that Preferences DataStore harnesses the power of `SharedPreferences` since
    they are pretty similar. In addition, Google’s documentation recommends that if
    you’re currently using `SharedPreferences` in your project to store data, you
    consider migrating to the latest DataStore version.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前构建过 Android 应用程序，您可能已经使用了 `SharedPreferences`。新的 Preferences DataStore
    旨在取代这种方法。也可以说，Preferences DataStore 利用 `SharedPreferences` 的力量，因为它们非常相似。此外，Google
    的文档建议，如果您目前在项目中使用 `SharedPreferences` 存储数据，您应考虑迁移到最新的 DataStore 版本。
- en: Another way to store data in Android is by using Room. This will be covered
    in [*Chapter 6*](B18827_06.xhtml#_idTextAnchor283), *Using the Room Database and
    Testing*; for now, we will just look at DataStore. Moreover, it is essential to
    note that DataStore is ideal for simple or small datasets and does not have support
    for partial updates or referential integrity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中存储数据的另一种方式是使用 Room。这将在 [*第 6 章*](B18827_06.xhtml#_idTextAnchor283)，*使用
    Room 数据库和测试* 中介绍；现在，我们只需看看 DataStore。此外，需要注意的是，DataStore 适用于简单的或小型数据集，并且不支持部分更新或引用完整性。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s go ahead and create a new, empty Compose project and call it `DataStoreSample`.
    In our example project, we will create a task entry app where users can save tasks.
    We will allow users to enter only three tasks, then use DataStore to store the
    tasks and later log the data and see whether it was inserted correctly. An additional
    exercise to try is to display data when users want to see it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的、空的 Compose 项目，并将其命名为 `DataStoreSample`。在我们的示例项目中，我们将创建一个任务条目应用程序，用户可以保存任务。我们将允许用户只保存三个任务，然后使用
    DataStore 存储任务，并稍后记录数据以查看是否正确插入。另一个尝试的练习是在用户想要查看数据时显示数据：
- en: 'In our newly created project, let’s go ahead and delete code that we don’t
    need. In this case, we’re referring to the `Greeting(name: String)` that comes
    with all empty Compose projects. Keep the Preview function since we will use it
    to view the screen we create.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在我们新创建的项目中，让我们继续删除我们不需要的代码。在这种情况下，我们指的是所有空 Compose 项目中包含的 `Greeting(name: String)`。保留
    Preview 函数，因为我们将会使用它来查看我们创建的屏幕。'
- en: 'Now, let’s go on and add the required dependencies for DataStore and sync the
    project. Also, note that there are versions of the DataStore library that are
    specific to RxJava 2 and 3:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续添加 DataStore 和同步项目的所需依赖项。注意，DataStore 库有针对 RxJava 2 和 3 的特定版本：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new package and call it `data`. Inside `data`, create a new Kotlin
    data class and call it `Tasks`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包，并将其命名为 `data`。在 `data` 中，创建一个新的 Kotlin 数据类，并将其命名为 `Tasks`。
- en: 'Let’s now go ahead and construct our data class with the expected input fields:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在继续构建我们的数据类，并包含预期的输入字段：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the same package, let’s add a `TaskDataSource` enum since we will reuse
    this project to showcase saving data using Proto DataStore in the *Using Android
    Proto DataStore versus* *DataStore* recipe:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包内，让我们添加一个 `TaskDataSource` 枚举，因为我们将会重用这个项目来展示使用 Android Proto DataStore
    的 *Using Android Proto DataStore versus* *DataStore* 菜单：
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inside our package, let’s go ahead and add a `DataStoreManager` interface. Inside
    our class, we will have a `saveTasks()` function to save the data and a `getTasks()`
    function to help us retrieve the saved data. A `suspend` function in Kotlin is
    simply a function that can be paused and resumed later.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的包内，让我们继续添加一个 `DataStoreManager` 接口。在我们的类中，我们将有一个 `saveTasks()` 函数来保存数据，以及一个
    `getTasks()` 函数来帮助我们检索保存的数据。Kotlin 中的 `suspend` 函数简单地说是一个可以被暂停并在稍后恢复的函数。
- en: 'In addition, the suspend functions can execute long-running operations and
    await completion without blocking:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，挂起函数可以执行长时间运行的操作并等待完成，而不会阻塞：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to implement our interface, so let’s go ahead and create a `DataStoreManagerImpl`
    class and implement the `DataStoreManager`. To refresh your knowledge of Flows,
    refer to [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137), *Handling the UI State
    in Jetpack Compose and* *Using Hilt*:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现我们的接口，所以让我们继续创建一个 `DataStoreManagerImpl` 类并实现 `DataStoreManager`。为了刷新你对
    Flows 的了解，请参考 [*第 3 章*](B18827_03.xhtml#_idTextAnchor137)，*在 Jetpack Compose 中处理
    UI 状态以及使用 Hilt*：
- en: '[PRE12]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will notice that once we’ve implemented the interface, we brought a view
    to the function, but it says `TODO`, and nothing has been implemented. To continue
    with this step, let’s go ahead and add DataStore and pass `Preference` in our
    constructor. We will also need to create the string preference key for each task:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，一旦我们实现了接口，我们将一个视图带到了函数中，但它显示 `TODO`，并且还没有实现任何内容。为了继续这一步，让我们继续添加 DataStore
    并在我们的构造函数中传递 `Preference`。我们还需要为每个任务创建字符串偏好键：
- en: '[PRE20]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, let’s finish our implementation of the `DataStore` section by adding
    functionality to the `getTasks` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过向 `getTasks` 函数添加功能来完成 `DataStore` 部分的实现：
- en: '[PRE45]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In our `MainActivity` class, let’s go on and create a simple UI: three `TextField`
    and a **Save** button. The **Save** button will save our data, and we can try
    to log data once everything works as expected. Refer to the *Technical requirements*
    section of this chapter to get the UI code.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `MainActivity` 类中，让我们继续创建一个简单的 UI：三个 `TextField` 和一个 **保存** 按钮。**保存** 按钮将保存我们的数据，并且我们可以在一切按预期工作后尝试记录数据。请参考本章的
    *技术要求* 部分以获取 UI 代码。
- en: "![Figure 5.1 – The DataStore UI exam\uFEFFple](img/Figure_5.1_B18827.jpg)"
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – DataStore UI 示例](img/Figure_5.1_B18827.jpg)'
- en: Figure 5.1 – The DataStore UI example
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – DataStore UI 示例
- en: Now that we have our implementation ready, in the following recipe, *Adding
    Dependency Injection to DataStore*, we will add Dependency Injection and then
    glue everything together.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了实现，在接下来的菜谱中，*将依赖注入添加到 DataStore*，我们将添加依赖注入并将一切粘合在一起。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The new Modern Android Development Jetpack library called Preferences DataStore’s
    main objective is to replace `SharedPreferences`. To implement Preferences DataStore,
    as you have seen in the recipe, we use a DataStore interface that takes in a `Preference`
    abstract class, and we can use this to edit and map the entry data. Furthermore,
    we create keys for the crucial parts of the key-value pairs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Modern Android Development Jetpack 库 Preferences DataStore 的主要目标是替换 `SharedPreferences`。为了实现
    Preferences DataStore，正如你在菜谱中看到的，我们使用一个接受 `Preference` 抽象类的 DataStore 接口，我们可以使用它来编辑和映射条目数据。此外，我们为键值对的关键部分创建键：
- en: '[PRE53]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To save our data in DataStore, we use `edit()`, which is a suspend function
    that needs to be called from `CoroutineContext`. A key difference in using Preferences
    DataStore compared to `SharedPreferences` is that DataStore is safe to call on
    the UI thread since it uses `dispatcher.IO` under the hood.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据保存到 DataStore，我们使用 `edit()`，这是一个需要从 `CoroutineContext` 调用的挂起函数。与 `SharedPreferences`
    相比，使用 Preferences DataStore 的一个关键区别是，DataStore 在 UI 线程上调用是安全的，因为它在底层使用 `dispatcher.IO`。
- en: You also do not need to use `apply{}` or `commit` functions to save the changes,
    as is required in `SharedPreferences`. Moreover, it handles data updates transactionally.
    More features are listed in *Figure 5**.2*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不需要使用 `apply{}` 或 `commit` 函数来保存更改，正如在 `SharedPreferences` 中所要求的。此外，它以事务方式处理数据更新。更多功能列在
    *图 5.2* 中。
- en: '![Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com](img/Figure_5.2_B18827.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 从 developers.android.com 选取的 Datastore 功能示例](img/Figure_5.2_B18827.jpg)'
- en: Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 从 developers.android.com 选取的 Datastore 功能示例
- en: There is more to learn, and it is fair to acknowledge that what we covered in
    this recipe is just a tiny part of what you can do with DataStore. We will cover
    more features in the following recipes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多东西要学习，并且公平地说，我们在本菜谱中涵盖的内容只是 DataStore 可以做到的一小部分。我们将在接下来的菜谱中介绍更多功能。
- en: Adding Dependency Injection to DataStore
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将依赖注入添加到 DataStore
- en: 'Dependency Injection is an important design pattern in software engineering,
    and its use in Android app development can lead to cleaner and more maintainable
    code. When it comes to DataStore in Android, which is a modern data storage solution
    introduced in Android Jetpack, adding Dependency Injection can bring several benefits:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是软件工程中的一个重要设计模式，其在 Android 应用开发中的应用可以使代码更干净、更易于维护。当谈到 Android 中的 DataStore
    时，它是在 Android Jetpack 中引入的现代数据存储解决方案，添加依赖注入可以带来几个好处：
- en: By using Dependency Injection, you can separate the concerns of creating an
    instance of DataStore from the code that uses it. This means that your business
    logic code will not have to worry about how to create a DataStore instance and
    can instead focus on what it needs to do with the data.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用依赖注入，你可以将创建 DataStore 实例的关注点与使用它的代码分离。这意味着你的业务逻辑代码不需要担心如何创建 DataStore 实例，而可以专注于它需要处理的数据。
- en: Dependency Injection makes it easier to write unit tests for your app. By injecting
    a mock DataStore instance into your tests, you can ensure that your tests are
    not affected by the actual state of the DataStore.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入使得为你的应用编写单元测试变得更加容易。通过将模拟的 DataStore 实例注入到测试中，你可以确保测试不受 DataStore 实际状态的影响。
- en: Dependency Injection can help you break down your code into smaller, more manageable
    modules. This makes it easier to add new features or modify existing ones without
    affecting the entire code base.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入可以帮助你将代码分解成更小、更易于管理的模块。这使得添加新功能或修改现有功能变得更加容易，而不会影响整个代码库。
- en: By using Dependency Injection, you can easily switch between different implementations
    of DataStore. This can be useful when testing different types of data storage
    or when migrating from one storage solution to another.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用依赖注入，你可以轻松地在不同的 DataStore 实现之间切换。这在测试不同类型的数据存储或从一种存储解决方案迁移到另一种存储解决方案时非常有用。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You need to have completed the previous recipe to continue with this one by
    executing the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要完成前面的菜谱才能继续进行，通过执行以下步骤：
- en: Open your project and add the necessary Hilt dependency. See the *Handling the
    UI State in Jetpack Compose and Using Hilt* recipe in [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137)
    if you need help setting it up.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目并添加必要的 Hilt 依赖。如果你需要帮助设置它，请参阅 [*第 3 章*](B18827_03.xhtml#_idTextAnchor137)
    中的 *在 Jetpack Compose 中处理 UI 状态和使用 Hilt* 菜谱。
- en: 'Next, let’s go ahead and add our `@HiltAndroidApp` class, and in our `Manifest`
    folder, add the `.name =` `TaskApp: android:name=".TaskApp"`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，让我们继续添加我们的 `@HiltAndroidApp` 类，并在我们的 `Manifest` 文件夹中添加 `.name =` `TaskApp:
    android:name=".TaskApp"`:'
- en: '[PRE54]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have implemented Dependency Injection, let’s go ahead and add `@AndroidEntryPoint`
    to the `MainActivity` class, and in `DataStoreManagerImpl`, let’s go ahead and
    add the `@Inject constructor`. We should have something similar to the following
    code snippet:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了依赖注入，让我们继续将 `@AndroidEntryPoint` 添加到 `MainActivity` 类中，并在 `DataStoreManagerImpl`
    中添加 `@Inject constructor`。我们应该有类似以下代码片段的内容：
- en: '[PRE61]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we need to create a new folder and call it `di`; this is where we will
    put our `DataStoreModule` class. We create a file called `store_tasks` to store
    the Preference values:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的文件夹，并将其命名为`di`；这是我们放置`DataStoreModule`类的地方。我们创建一个名为`store_tasks`的文件来存储偏好值：
- en: '[PRE65]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We will also need to create an `abstract` class for `DataStoreManagerModule`
    inside our `di` package. In order to reduce the boilerplate code using manual
    Dependency Injection, our application also supplies the required dependencies
    to the classes that need them. You can learn more about this in [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and* *Using Hilt*:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在`di`包内部为`DataStoreManagerModule`创建一个`abstract`类。为了减少使用手动依赖注入的样板代码，我们的应用程序也为需要它们的类提供了所需的依赖。你可以在[*第3章*](B18827_03.xhtml#_idTextAnchor137)中了解更多信息，*处理Jetpack
    Compose中的UI状态*和*使用Hilt*：
- en: '[PRE78]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let’s now go ahead and create a new package and call it `service`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续创建一个新的包，并将其命名为`service`：
- en: '[PRE87]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let’s also ensure we have the required dependencies for the newly created service:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也确保我们有为新创建的服务所需的依赖：
- en: '[PRE100]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now that we are done with Dependency Injection and adding all the functionalities
    required for DataStore, we will go ahead and add a `ViewModel` class and implement
    functionality to save the data once the user clicks the Save button:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了依赖注入和添加DataStore所需的所有功能，我们将继续添加一个`ViewModel`类，并在用户点击保存按钮时实现保存数据的函数：
- en: '[PRE105]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Call the `saveTaskData` function inside the Compose Save button in the Compose
    view to save our data:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Compose视图中，在Compose保存按钮内部调用`saveTaskData`函数来保存我们的数据：
- en: '[PRE112]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Lastly, we will need to verify that everything is working, that is, our UI and
    data storing process. We can verify this, by typing input data in our TextFields
    and clicking the Save button, and when we log the message it confirms the data
    is indeed saved.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要验证一切是否正常工作，即我们的UI和数据存储过程。我们可以通过在TextFields中输入数据并点击保存按钮来验证这一点，当记录消息时，它确认数据确实已保存。
- en: '![Figure 5.3 – The entry of tasks](img/Figure_5.3_B18827.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 任务条目](img/Figure_5.3_B18827.jpg)'
- en: Figure 5.3 – The entry of tasks
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 任务条目
- en: If you missed it initially, the code for this view can be found in the *Technical
    requirement* section. Now, you will notice that when we enter the data, as in
    *Figure 5**.4*, we should be able to log the data on our Logcat and verify that
    our data was inserted correctly.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你最初错过了，这个视图的代码可以在*技术要求*部分找到。现在，当你输入数据时，就像*图5**.4*中那样，我们应该能够在Logcat中记录数据并验证我们的数据是否已正确插入。
- en: '![Figure 5.4 – The entry of tasks through debugging](img/Figure_5.4_B18827.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 通过调试进行任务条目](img/Figure_5.4_B18827.jpg)'
- en: Figure 5.4 – The entry of tasks through debugging
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 通过调试进行任务条目
- en: A log message should also be displayed in the Logcat tab if all is working as
    expected.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，也应该在Logcat标签中显示一条日志消息。
- en: "![Figure 5.5 – The debug log indicating that data was i\uFEFFnserted correctly](img/Figure_5.5_B18827.jpg)"
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 表示数据正确插入的调试日志](img/Figure_5.5_B18827.jpg)'
- en: Figure 5.5 – The debug log indicating that data was inserted correctly
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 表示数据正确插入的调试日志
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we opted to use Dependency Injection to supply the required
    dependencies to specific classes. We’ve already covered what Dependency Injection
    is in depth, so we will not explain it again but instead talk about the modules
    we created.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们选择使用依赖注入来为特定类提供所需的依赖。我们已经深入探讨了依赖注入是什么，所以我们将不再解释它，而是讨论我们创建的模块。
- en: 'In our project, we created `DataStoreManagerModule` and `DataStoreModule`,
    and all we did was supply the required dependencies. We created a file and called
    it `store_tasks`, which helps us store the Preference values:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们创建了`DataStoreManagerModule`和`DataStoreModule`，我们所做的一切只是提供所需的依赖。我们创建了一个名为`store_tasks`的文件，它帮助我们存储偏好值：
- en: '[PRE120]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'By default, DataStore uses coroutines and returns a flow value. Some important
    rules to remember while using DataStore, as per the documentation, are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DataStore使用协程并返回一个流值。根据文档，使用DataStore时需要记住的一些重要规则如下：
- en: DataStore requires only one instance for a given file in the same process. Hence,
    we should never create more than one instance of DataStore.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataStore在同一进程中为给定文件只需要一个实例。因此，我们永远不应该创建多个DataStore实例。
- en: Always have the generic `DataStore` type be immutable to reduce unnecessary
    and hard-to-trace bugs.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是让通用的`DataStore`类型不可变，以减少不必要的难以追踪的错误。
- en: You should never mix the usage of a single-process DataStore and multi-process
    DataStore in the same file.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你永远不应该在同一个文件中混合使用单进程 DataStore 和多进程 DataStore。
- en: There’s more…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As an exercise, you can try to add another button and display the saved data
    in a lazy column or a text field.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，你可以尝试添加另一个按钮，并在懒列或文本字段中显示保存的数据。
- en: See also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is more to learn about DataStore, and this recipe has only given you an
    overview of what you can do with DataStore. You can learn more by following the
    link at [https://developer.android.com/topic/libraries/architecture/datastore](https://developer.android.com/topic/libraries/architecture/datastore).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 DataStore 还有更多要学习的内容，这个菜谱只为你概述了你可以用 DataStore 做什么。你可以通过点击以下链接了解更多信息：[https://developer.android.com/topic/libraries/architecture/datastore](https://developer.android.com/topic/libraries/architecture/datastore)。
- en: Using Android Proto DataStore versus DataStore
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Android Proto DataStore 与 DataStore 的比较
- en: '*Figure 5**.2* shows the differences between `PreferencesDataStore`, `SharedPreferences`,
    and `ProtoDataStore`. In this recipe, we will explore how we can use Proto DataStore.
    The Proto DataStore implementation uses DataStore and Protocol Buffers to persist
    typed objects to the disk.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 展示了 `PreferencesDataStore`、`SharedPreferences` 和 `ProtoDataStore` 之间的区别。在这个菜谱中，我们将探讨我们如何使用
    Proto DataStore。Proto DataStore 实现使用 DataStore 和 Protocol Buffers 将类型化对象持久化到磁盘。'
- en: Proto DataStore is similar to Preferences DataStore, but unlike Preferences
    DataStore, Proto does not use key-value pairs and just returns the generated object
    in the flow. The file types and structure of the data depend on the schema of
    the `.``protoc` files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Proto DataStore 与 Preferences DataStore 类似，但与 Preferences DataStore 不同，Proto
    不使用键值对，只是在流程中返回生成的对象。文件类型和数据结构取决于 `.protoc` 文件的模式。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use our already created project to show how you can use Proto DataStore
    in Android. We will also use already created classes and just give the functions
    different names.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用已经创建的项目来展示如何在 Android 中使用 Proto DataStore。我们还将使用已经创建的类，只是给函数不同的名字。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will need to start by setting up the required dependencies, so let’s go
    ahead and add the following to our Gradle app-level file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要首先设置所需的依赖项，所以让我们继续在我们的 Gradle 应用级别文件中添加以下内容：
- en: '[PRE121]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, we will need to add `protobuf` to `plugins` in our `build.gradle` file:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `build.gradle` 文件中的 `plugins` 添加 `protobuf`：
- en: '[PRE123]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We will need to add the `protobuf` configuration to our `build.gradle` file
    to finalize our setup:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `build.gradle` 文件中添加 `protobuf` 配置来完成设置：
- en: '[PRE127]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now, inside our `package` folder, we will need to add our `proto` file under
    `app/src/main/`, then create a new directory and call it `proto`. You should now
    have this in your `app/src/main/proto` file directory:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的 `package` 文件夹内，我们需要在 `app/src/main/` 下添加我们的 `proto` 文件，然后创建一个新的目录并命名为
    `proto`。你现在应该在 `app/src/main/proto` 文件目录中看到以下内容：
- en: '[PRE141]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: That was a lot to set up. We can now start adding code to hook everything up.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 设置起来有很多。现在我们可以开始添加代码来连接一切了。
- en: 'Let’s modify classes that might need `ProtoDataStore`. First, let’s add `PROTO_DATA_STORE`
    to the `TaskDataSource` enum class:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改可能需要 `ProtoDataStore` 的类。首先，让我们将 `PROTO_DATA_STORE` 添加到 `TaskDataSource`
    枚举类中：
- en: '[PRE150]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'In `DataStoreManager`, let’s add `saveTaskToProtoStore()` and `getUserFromProtoStore()`,
    and our new interface will look like this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DataStoreManager` 中，让我们添加 `saveTaskToProtoStore()` 和 `getUserFromProtoStore()`，我们新的接口将看起来像这样：
- en: '[PRE154]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Since we just modified our interface, we will need to go ahead and add new
    functionalities to the implementation class. You will also notice that the project
    will complain once you add the functions:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们刚刚修改了我们的接口，我们还需要继续添加实现类的新功能。你也会注意到，一旦添加了函数，项目会抱怨：
- en: '[PRE160]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'As recommended, we will need to define a class that implements `Serializer<Type>`,
    where the type is defined in the Proto file. The purpose of this serializer class
    is to tell DataStore how to read and write our data type. So, let’s create a new
    object and call it `TaskSerializer()`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如推荐，我们需要定义一个实现 `Serializer<Type>` 的类，其中类型在 Proto 文件中定义。这个序列化类的目的是告诉 DataStore
    如何读取和写入我们的数据类型。所以，让我们创建一个新的对象并命名为 `TaskSerializer()`：
- en: '[PRE166]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The `TaskPreference` class is auto-generated, and you can access it directly
    by clicking on it but cannot edit it. Auto-generated files are not editable unless
    you change the original file.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskPreference` 类是自动生成的，你可以通过点击它直接访问它，但不能编辑它。除非你更改原始文件，否则自动生成的文件是不可编辑的。'
- en: '![Figure 5.6 – A screenshot showing the auto-generated TaskPreference class](img/Figure_5.6_B18827.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 显示自动生成的 TaskPreference 类的屏幕截图](img/Figure_5.6_B18827.jpg)'
- en: Figure 5.6 – A screenshot showing the auto-generated TaskPreference class
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 展示自动生成的 TaskPreference 类的屏幕截图
- en: 'Now that we have created our data type class, we need to create a `taskProtoDataStore:
    DataStore<TaskPreference>` with the context used with DataStore. Hence, inside
    `DataStoreModule`, let’s go ahead and add this code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们已经创建了我们的数据类型类，我们需要使用与 DataStore 一起使用的上下文创建一个 `taskProtoDataStore: DataStore<TaskPreference>`。因此，在
    `DataStoreModule` 中，让我们继续添加以下代码：'
- en: '[PRE182]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Now, let’s go back to `DataStoreManagerImpl` and work on the functions that
    we are yet to implement:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `DataStoreManagerImpl` 并着手实现我们尚未实现的函数：
- en: '[PRE191]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'In `TaskService`, we will also go ahead and add `getTasksFromProto`, and `getTasks()`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TaskService` 中，我们还将继续添加 `getTasksFromProto` 和 `getTasks()`：
- en: '[PRE207]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'When you implement an interface, at first the class that is being implemented
    will might show compile error, which will prompt you to override the interface
    functionalities into the class. Hence, inside the `TaskServiceImpl` class, add
    the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你实现一个接口时，首先被实现的类可能会显示编译错误，这会提示你将接口功能覆盖到类中。因此，在 `TaskServiceImpl` 类中，添加以下代码：
- en: '[PRE213]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Finally, now that we have all our data saved, we can Log to ensure the data
    is as expected on the UI; check out the link with the code in the *Technical requirements*
    section to see how this is implemented.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们已经保存了所有数据，我们可以记录以确保数据在 UI 上符合预期；查看 *技术要求* 部分的链接，了解这是如何实现的。
- en: Important note
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Apple M1 has a reported problem with proto. There is an issue open for this;
    follow this link to resolve the issue: [https://github.com/grpc/grpc-java/issues/7690](https://github.com/grpc/grpc-java/issues/7690).
    Hopefully, it will be fixed by the time the book is published. It is important
    to note that if you use the `DataStore-preferences-core` artifact with Proguard,
    you have to manually add Proguard rules to your rule file to prevent your already
    written fields from being deleted. Also, you can follow the same process to Log
    and check whether the data is inserted as expected.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Apple M1 有一个与 proto 相关的问题。为此问题已打开一个工单；通过以下链接解决问题：[https://github.com/grpc/grpc-java/issues/7690](https://github.com/grpc/grpc-java/issues/7690)。希望它会在本书出版时得到修复。重要的是要注意，如果你使用
    `DataStore-preferences-core` 仓库与 Proguard 一起使用，你必须手动将 Proguard 规则添加到你的规则文件中，以防止删除已经编写的字段。你还可以遵循相同的流程来记录并检查数据是否按预期插入。
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You might have noticed that we stored our custom data type as an instance. That
    is what Proto DataStore does; it stores data as instances of custom data types.
    The implementations require us to define a schema using protocol buffers, but
    it provides type safety.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们以实例的形式存储了我们的自定义数据类型。这正是 Proto DataStore 所做的；它以自定义数据类型的实例形式存储数据。实现需要我们使用协议缓冲区定义一个模式，但它提供了类型安全。
- en: In Android's Proto Datastore library, the `Serializer<Type>` interface converts
    objects of a specific type (`Type`) into their corresponding protocol buffer format
    and vice versa. This interface provides methods for serializing objects to bytes
    and deserializing bytes back into objects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 的 Proto Datastore 库中，`Serializer<Type>` 接口将特定类型（`Type`）的对象转换为相应的协议缓冲区格式，反之亦然。此接口提供了将对象序列化为字节和将字节反序列化为对象的方法。
- en: Protocol buffers in Android is a language and platform-neutral extensible mechanism
    for serializing your structured data. Protocol buffers encodes and decodes your
    data in a binary stream that is really lightweight.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Android 中的协议缓冲区是一种语言和平台无关的可扩展机制，用于序列化您的结构化数据。协议缓冲区以二进制流的形式编码和解码您的数据，这种流非常轻量级。
- en: The override val defaultValue is used when defining a property in a data class
    or a serialized model class. It is part of the Kotlin Serialization library, which
    is commonly used for serializing and deserializing objects to and from different
    data formats such as JSON or protocol buffers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义数据类或序列化模型类中的属性时，使用 `override val defaultValue`。它是 Kotlin 序列化库的一部分，该库通常用于将对象序列化和反序列化到不同的数据格式，如
    JSON 或协议缓冲区。
- en: We expose the appropriate property by exposing the flow DataStore data from
    our stored object and writing a proto DataStore that provides us with an `updateData()`
    function that transactionally updates a stored object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从存储对象中公开流式 DataStore 数据并编写一个提供 `updateData()` 函数的 proto DataStore 来公开适当的属性，该函数以事务方式更新存储对象。
- en: The `updateData` function gives us the current state of the data as an instance
    of our data type and updates it in an atomic read-write-modify operation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateData` 函数以我们数据类型的实例形式提供当前数据状态，并在原子读-写-修改操作中更新它。'
- en: See also
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There is more to learn about how to create defined schemas. You can check out
    the protobuf language guide here: [https://developers.google.com/protocol-buffers/docs/proto3](https://protobuf.dev/programming-guides/proto3/).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何创建定义良好的模式还有很多东西可以学习。您可以在以下位置查看 protobuf 语言指南：[https://developers.google.com/protocol-buffers/docs/proto3](https://protobuf.dev/programming-guides/proto3/)。
- en: Handling data migration with DataStore
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DataStore 处理数据迁移
- en: If you have built Android applications before, you might have used `SharedPreferences`;
    the good news now is that there is support for migration, and you can migrate
    from `SharedPreferences` to DataStore using `SharedPreferenceMigration`. As with
    any data, we will always modify our dataset; for instance, we might want to rename
    our data model values or even change their type.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前开发过 Android 应用程序，你可能使用过 `SharedPreferences`；现在的好消息是，现在有了迁移支持，你可以使用 `SharedPreferenceMigration`
    从 `SharedPreferences` 迁移到 DataStore。与任何数据一样，我们总是会修改我们的数据集；例如，我们可能想要重命名我们的数据模型值或甚至更改它们的类型。
- en: In such a scenario, we will need a DataStore to DataStore migration; that is
    what we will be working on in this recipe. The process is pretty similar to the
    migration from `SharedPreferences`; as a matter of fact, `SharedPreferencesMigration`
    is an implementation of the `DataMigration` interface class.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要进行 DataStore 到 DataStore 的迁移；这正是我们将在这个菜谱中工作的。这个过程与从 `SharedPreferences`
    迁移非常相似；事实上，`SharedPreferencesMigration` 是 `DataMigration` 接口类的一个实现。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we just created a new `PreferenceDataStore`, we will not need to migrate
    it, but we can look at ways to implement a migration in case a need arises.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚创建了一个新的 `PreferenceDataStore`，我们不需要迁移它，但我们可以看看在需要时如何实现迁移。
- en: How to do it…
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'In this recipe, we will look at how you can utilize the knowledge learned to
    help you when a need to migrate to DataStore arises:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何利用所学知识来帮助你处理需要迁移到 DataStore 的情况：
- en: 'Let’s start by looking at the interface that helps with migration. The following
    code section showcases the `DataMigration` interface, which `SharedPreferencesMigration`
    implements:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先看看帮助迁移的接口。以下代码部分展示了 `DataMigration` 接口，该接口由 `SharedPreferencesMigration`
    实现：
- en: '[PRE228]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'In the `Tasks` data, we might want to change the entries to `Int`; this means
    changing one of our data types. We will imagine this scenario and try to create
    a migration based on this. We can start by creating a new `migrateOnePreferencesDataStore`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Tasks` 数据中，我们可能想要将条目更改为 `Int`；这意味着更改我们的数据类型之一。我们将想象这个场景，并尝试基于此创建一个迁移。我们可以从创建一个新的
    `migrateOnePreferencesDataStore` 开始：
- en: '[PRE235]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Now, let’s go on to implement `DataMigration` and override its functions. You
    will need to specify your condition for whether the migration should happen. The
    migration data shows instructions on how exactly the old data is transformed into
    new data. Then, once the migration is over, clean up the old storage:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现 `DataMigration` 并覆盖其函数。您需要指定迁移是否应该发生的条件。迁移数据显示了如何将旧数据精确地转换为新数据。然后，一旦迁移完成，清理旧存储：
- en: '[PRE238]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Finally, let’s create the `oldToNew()` function, which is where we can add
    the data we want to migrate:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建 `oldToNew()` 函数，这是我们添加要迁移的数据的地方：
- en: '[PRE263]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: How it works…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To better understand how `DataMigration` works, we will need to look into the
    functions that are in the `DataMigration` interface. In our interface, we have
    three functions, as shown in the following code block:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 `DataMigration` 的工作原理，我们需要查看 `DataMigration` 接口中的函数。在我们的接口中，我们有三个函数，如下面的代码块所示：
- en: '[PRE274]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: The `shouldMigrate()` function, as the name suggests, establishes whether the
    migration needs to be performed or not. If, for instance, no migration is done,
    which means this will return `false`, then no migration or cleanup will occur.
    Also, it is crucial to note that this function is initialized every time we call
    our DataStore instance. `Migrate()`, on the other hand, performs the migration.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldMigrate()` 函数，正如其名所示，用于确定是否需要执行迁移。例如，如果没有执行迁移，这意味着该函数将返回 `false`，则不会进行迁移或清理。此外，需要注意的是，每次我们调用我们的
    DataStore 实例时，此函数都会被初始化。另一方面，`Migrate()` 函数执行迁移操作。'
- en: By chance, if the action fails or does not work as expected, DataStore will
    not commit any data to the disk. Furthermore, the cleanup process will not occur,
    and an exception will be thrown. Finally, `cleanUp()`, as it suggests, just clears
    any old data from previous data storage.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然情况下，如果操作失败或不符合预期，DataStore将不会将任何数据提交到磁盘。此外，清理过程将不会发生，并且会抛出异常。最后，`cleanUp()`正如其名，只是清除之前数据存储中的任何旧数据。
- en: Writing tests for our DataStore instance
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的DataStore实例编写测试
- en: Writing tests is crucial in Android development, and in this recipe, we will
    write some tests for our DataStore instance. To test our DataStore instance or
    any DataStore instance, we first need to have instrumentation testing set up since
    we will be reading and writing in actual files (DataStore), and it is vital to
    verify that accurate updates are being made.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中编写测试至关重要，在这个菜谱中，我们将为我们的DataStore实例编写一些测试。为了测试我们的DataStore实例或任何DataStore实例，我们首先需要设置instrumentation测试，因为我们将在实际的文件（DataStore）中进行读写操作，并且验证准确更新是至关重要的。
- en: How to do it…
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will start by creating a simple unit test to test our view model function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个简单的单元测试来测试我们的视图模型函数：
- en: 'In our unit test folder, create a new folder and call it `test`, and inside
    it, go ahead and create a new class called `TaskViewModelTest`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的单元测试文件夹中，创建一个新的文件夹，命名为`test`，并在其中创建一个新的类，命名为`TaskViewModelTest`：
- en: '[PRE275]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Next, we will need to add some testing dependencies:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些测试依赖项：
- en: '[PRE276]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Now that we have added the required dependencies, let’s go ahead and create
    our mock task service class and mock it, then initialize it in the setup:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所需的依赖项，让我们继续创建我们的模拟任务服务类，然后对其进行模拟，并在设置中初始化它：
- en: '[PRE279]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'Since we use a coroutine, we will set up our dispatcher in @`Before annotation`
    and clear any stored data in the `@After` annotation using the `Dispatchers.resetMain()`.
    If you run your tests without setting up a coroutine, they will fail with an error.
    The module with the `Main` dispatcher failed to initialize. For tests, `Dispatchers.setMain`
    from the `kotlinx-coroutines-test` module can be used:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用协程，我们将在`@Before`注解中设置我们的分发器，并在`@After`注解中使用`Dispatchers.resetMain()`清除任何存储的数据。如果你在没有设置协程的情况下运行测试，它们将因错误而失败。使用`Main`分发器的模块初始化失败。对于测试，可以使用`kotlinx-coroutines-test`模块中的`Dispatchers.setMain`：
- en: '[PRE286]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'After that is completed, let’s go on and create a new test called `Verify add
    tasks function adds tasks as needed`. In this test, we will create a `fakeTask`,
    add those tasks to `saveTaskData`, and ensure data is inserted as expected by
    checking that we did not store `null`:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成那之后，我们继续创建一个新的测试，命名为`Verify add tasks function adds tasks as needed`。在这个测试中，我们将创建一个`fakeTask`，将这些任务添加到`saveTaskData`中，并通过检查我们没有存储`null`来确保数据按预期插入：
- en: '[PRE295]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Finally, when you run the unit test, it should pass, and you will see a green
    check mark.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你运行单元测试时，它应该通过，你将看到一个绿色的勾号。
- en: '![Figure 5.7 – The test passing in the view model](img/Figure_5.7_B18827.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 视图模型中的测试通过](img/Figure_5.7_B18827.jpg)'
- en: Figure 5.7 – The test passing in the view model
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 视图模型中的测试通过
- en: How it works…
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are different mocking libraries used in Android: `Mockito`, `Mockk`,
    and more. In this recipe, we used `Mockk`, a user-friendly mocking library for
    Android. `testImplementation "io.mockk:mockk:1.13.3"` is used for unit tests,
    and `androidTestImplementation "io.mockk:mockk-android:1.13.3"` is used for UI
    tests.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中使用了不同的模拟库：`Mockito`、`Mockk`等。在这个菜谱中，我们使用了`Mockk`，这是一个用户友好的Android模拟库。`testImplementation
    "io.mockk:mockk:1.13.3"`用于单元测试，而`androidTestImplementation "io.mockk:mockk-android:1.13.3"`用于UI测试。
- en: 'To test the UI, we will need to follow a pattern, creating a test DataStore
    instance with default values stored inside it. Then, we create the test subject
    and verify that the test DataStore values coming from our function match the expected
    results. We will also need to use `TestCoroutineDispatcher`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试UI，我们需要遵循一个模式，创建一个包含默认值的测试DataStore实例。然后，我们创建测试主题，并验证从我们的函数中来的测试DataStore值是否与预期结果匹配。我们还需要使用`TestCoroutineDispatcher`：
- en: '[PRE305]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: The preceding code performs the execution of the coroutines, which is, by default,
    immediate. This simply means any tasks scheduled to be run without delays are
    executed immediately. We also use the same coroutines for our view models. That
    is also because DataStore is based on Kotlin coroutines; hence we need to ensure
    our tests have the right setup.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行协程，默认情况下是立即执行的。这仅仅意味着所有计划无延迟运行的任务都会立即执行。我们也为我们的视图模型使用相同的协程。这也是因为DataStore基于Kotlin协程；因此，我们需要确保我们的测试有正确的设置。
- en: See also
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There is more to learn about DataStore. We cannot cover it all in just one
    chapter. For more information on DataStore, that is, Preference and Proto, you
    can check out this link: [https://developer.android.com/topic/libraries/architecture/datastore](https://developer.android.com/topic/libraries/architecture/datastore).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 关于DataStore还有更多内容可以学习。我们无法在一章中涵盖所有内容。有关DataStore（即偏好设置和Proto）的更多信息，您可以查看此链接：[https://developer.android.com/topic/libraries/architecture/datastore](https://developer.android.com/topic/libraries/architecture/datastore)。
