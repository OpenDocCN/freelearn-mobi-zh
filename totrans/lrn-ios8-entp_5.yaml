- en: Chapter 5. Frameworks Introduced with iOS 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with PhotoKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handoff for resuming activities seamlessly among all devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with PhotoKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One new feature in iOS 8 has been revealed; it is named **PhotoKit**, also known
    as Photos Framework. It's a new extension that lets developers work more effectively
    with photos and videos stored in the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'PhotoKit consists of the following two new frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Photos Framework**: This will allow developers to retrieve and edit photos
    and videos. It is responsible for handling changes made from external apps and
    also provides the tools to build a complete app, such as the Photos app that is
    available in iOS by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Photos UI**: This is responsible for providing the ability to create editing
    extensions—in other words, to edit photos with our custom app directly from the
    iOS Camera roll.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Photos Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Photos Framework provides tools to access, add, edit, and remove the model objects
    (images, videos, albums, and moments).
  prefs: []
  type: TYPE_NORMAL
- en: These model instances have a key characteristic—that is, they're read-only.
    So, for example, we can edit an image, and it won't modify the original content;
    however, it will create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different model objects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assets**: They refer to images and videos, and are represented by the `PHAsset`
    class. It gives the ability to specify the type of media content (photo or video),
    the date of creation, location, and whether it''s a favorite or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset collections**: They''re also called moments, and they refer to ordered
    collections of assets, such as albums and smart albums. These objects are represented
    by `PHAssetCollection`, and its properties are title, type, and the start and
    end dates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection lists**: They''re an ordered collection of collections, and they
    usually represent a folder or a moment year. The class that manages them, `PHCollectionList`,
    stores the type, title, and the start and end dates of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Photos Framework also introduces **Transient collections**, which reference
    a group of assets that are the result of a search or user selection, and can be
    used to interchange with common collections. One more thing to take into account
    when using this framework is that we will need to make use of class methods such
    as the following ones to work with assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Photos UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Photos UI is a very interesting framework that allows us to create photo-editing
    extensions in our apps that will be available in the built-in Photos app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, when editing an image in the Camera roll, we can choose which
    app we want to use for this purpose; the result of this editing will be available
    for other apps and devices through iCloud and won''t modify the original as it''s
    read-only. To achieve this, we will need to create an app extension target that
    will provide a view controller that, in turn, will adopt the `PHContentEditingController`
    protocol. This is pretty simple, as the new version of Xcode provides a template
    to create photo-editing extensions; we just need to focus on the implementation
    of the following protocol methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can use Photos Framework to work with the photo and video assets managed
    by the Photos app, including the **iCloud Photo Library**. Use this framework
    to retrieve assets for display and playback, edit their image or video content,
    or work with collections of assets, such as albums, moments, and iCloud shared
    albums.
  prefs: []
  type: TYPE_NORMAL
- en: Features of PhotoKit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The features of PhotoKit are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fetching entities and requesting changes**: Instances of the Photos Framework
    model classes (`PHAsset`, `PHAssetCollection`, and `PHCollectionList`) represent
    the entities on which a user works within the Photos app. These entities are assets
    (images or videos), collections of assets (such as albums or moments), and lists
    of collections (such as album folders or moment clusters). These objects, also
    called photo entities, are read-only, immutable, and contain only metadata such
    as the asset''s media type and its creation date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We work with assets and collections by fetching the photo entities we're interested
    in and then using these objects to fetch the data we need to work with. To make
    changes to photo entities, we create change request objects and explicitly commit
    them to the shared `PHPhotoLibrary` object. This architecture makes it easy, safe,
    and efficient to work with the same assets from multiple threads or multiple apps
    and app extensions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Change observing**: Use the shared `PHPhotoLibrary` object to register a
    change handler for the photo entities you fetch. PhotoKit tells your app whenever
    another app or device changes the content or metadata of an asset or the list
    of assets in a collection. The `PHChange` objects provide information on the object
    state before and after each change, with semantics that make it easy to update
    a collection view or a similar interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for Photos app features**: Use the `PHCollectionList` class to find
    assets corresponding to the moments hierarchy in the Photos app. Use the `PHAsset`
    class to identify burst photos, panoramic photos, and high-frame-rate videos.
    When the iCloud Photo Library is enabled, assets and collections in Photos Framework
    reflect the content available across all the devices on the same iCloud account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset and thumbnail loading and caching**: Use the `PHImageManager` class
    to request images of assets in a specified size or AV Foundation objects to work
    with video assets. Photos Framework automatically downloads or generates images
    according to your specification, caching them for quick reuse. For faster performance
    with a large numbers of assets—for example, when populating a collection view
    with thumbnails—the `PHCachingImageManager` subclass adds bulk preloading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset content editing**: The `PHAsset` and `PHAssetChangeRequest` classes
    define the methods to request photo or video content to edit and to commit your
    edits to the photo library. To support continuity of editing between different
    apps and extensions, Photos keeps the current and previous versions of each asset,
    along with the `PHAdjusmentData` object that describes the last edit. If your
    app supports adjustment data from a previous edit, you can allow the user to revert
    or alter the edit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a lot of classes for PhotoKit; we will discuss them in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Classes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PHAdjustmentData` | When a user edits an asset, Photos saves this object
    along with the modified image or video data |'
  prefs: []
  type: TYPE_TB
- en: '| `PHAssetChangeRequest` | You can create and use this object within a photo
    library and change the block to create, delete, or modify `PHAsset` objects |'
  prefs: []
  type: TYPE_TB
- en: '| `PHAssetCollectionChangeRequest` | You can create and use this object within
    a photo library and change the block to create, delete, or modify `PHAssetCollection`
    objects |'
  prefs: []
  type: TYPE_TB
- en: '| `PHChange` | Photos provides this object to notify your app of any changes
    to the assets and collections managed by the Photos app |'
  prefs: []
  type: TYPE_TB
- en: '| `PHCollectionListChangeRequest` | You can create and use this object within
    a photo library and change the block to create, delete, or modify `PHCollectionList`
    objects |'
  prefs: []
  type: TYPE_TB
- en: '| `PHContentEditingInput` | This object describes an asset to be used for editing
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHContentEditingInputRequestOptions` | You can use this object to specify
    options when requesting to edit the image or video content of a `PHAsset` object
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHContentEditingOutput` | This object represents the results of editing
    the photo or video content of a Photos asset |'
  prefs: []
  type: TYPE_TB
- en: '| `PHFetchOptions` | You can use this object to specify options when using
    class methods on the `PHAsset`, `PHCollection`, `PHAssetCollection`, and `PHCollectionList`
    classes to retrieve photo entities |'
  prefs: []
  type: TYPE_TB
- en: '| `PHFetchResult` | This object is a container for an ordered list of photo
    entity objects |'
  prefs: []
  type: TYPE_TB
- en: '| `PHFetchResultChangeDetails` | This object provides detailed information
    about the differences between two fetch results—the one that you previously obtained
    and the updated one that would be the result if you performed the same fetch again
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHImageManager` | This is a shared object, and it provides methods to load
    images or video data associated with a `PHAsset` object |'
  prefs: []
  type: TYPE_TB
- en: '| `PHCachingImageManager` | This object fetches or generates image data for
    photo or video assets. |'
  prefs: []
  type: TYPE_TB
- en: '| `PHImageRequestOptions` | You can use this object to specify options when
    requesting image representations of photo assets from a `PHImageManager` object
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHObject` | This class is the abstract base class for photo-entity objects
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHAsset` | This object represents an image or video file that appears in
    the Photos app, including the iCloud Photos content |'
  prefs: []
  type: TYPE_TB
- en: '| `PHCollection` | This class is an abstract class that defines the behavior
    shared between the Photos collection classes |'
  prefs: []
  type: TYPE_TB
- en: '| `PHAssetCollection` | This object represents a collection of photos or video
    assets |'
  prefs: []
  type: TYPE_TB
- en: '| `PHCollectionList` | This object represents a group of asset collections
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHObjectPlaceholder` | This object is a read-only proxy that represents
    an object yet to be created |'
  prefs: []
  type: TYPE_TB
- en: '| `PHObjectChangeDetails` | This object provides detailed information about
    the differences between two states of a photo entity—one that you previously obtained
    and the updated state that would be the result if you fetched this entity again
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PHPhotoLibrary` | This is a shared object that represents the user''s Photos
    library—the entire set of assets and collections managed by the Photos app, including
    the objects stored in the local device and (if enabled) in iCloud Photos |'
  prefs: []
  type: TYPE_TB
- en: '| `PHVideoRequestOptions`  | You can use this object to specify options when
    requesting video assets from a `PHImageManager` object |'
  prefs: []
  type: TYPE_TB
- en: 'PhotoKit makes it easy to query model data through a variety of fetch methods.
    For example, to retrieve all images, you can call `PFAsset.Fetch,` passing the
    `PHAssetMediaType.Image` media type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `PHFetchResult` instance will then contain all the `PFAsset` instances that
    represent images. To get the images themselves, you can use `PHImageManager` (or
    the caching version, `PHCachingImageManager`) to make a request for the image
    by calling `requestImageForAsset`. For example, the following code retrieves an
    image for each asset in `PHFetchResult` to display in a collection view cell.
    This example is in the Swift language, so we need to understand Swift. To begin
    with Swift in a better way, you can go to [http://www.raywenderlich.com/tutorials](http://www.raywenderlich.com/tutorials).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you handle querying and reading data. You can also write changes
    back to the library. Since multiple interested applications are able to interact
    with the system''s photo library, you can register an observer to be notified
    of any changes using `PhotoLibraryObserver`. Then, when changes come in, your
    application can update accordingly. For example, here''s a simple implementation
    for reloading the collection view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually write changes back from your application, you can create a change
    request. Each of the model classes has an associated change request class. For
    example, to change `PHAsset`, you can create `PHAssetChangeRequest`. The steps
    to perform changes that are written back to the photo library and sent to observers,
    like the preceding code, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform the editing operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the filtered image data to a `PHContentEditingOutput` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a change request to publish the changes form the editing output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example that writes back a change to an image that applies a core
    image noir filter. You can also refer to [http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/](http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/)
    to understand in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user selects the button, the filter is applied, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Features of PhotoKit](img/1829OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thanks to `PHPhotoLibraryChangeObserver`, the change is reflected in the collection
    view when the user navigates back to the photo library.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the sample project from [https://github.com/mikebluestein/PhotoKitDemo](https://github.com/mikebluestein/PhotoKitDemo).
  prefs: []
  type: TYPE_NORMAL
- en: Handoff for seamlessly resuming activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handoff is a feature in OS X and iOS that extends the user experience of continuity
    across devices. Handoff enables users to begin an activity on one device and then
    switch to another device and resume the same activity there. For example, a user
    who is browsing a long article in Safari moves to an iOS device that's signed
    in to the same Apple ID; the same webpage now automatically opens in Safari on
    iOS, with the same scroll position as on the original device. Handoff makes this
    experience as seamless as possible.
  prefs: []
  type: TYPE_NORMAL
- en: To participate in Handoff, an app adopts a small API in foundation. Each ongoing
    activity in an app is represented by a user activity object that contains the
    data needed to resume an activity on another device. When the user chooses to
    resume this activity, the object is sent to the resuming device. Each user activity
    object has a delegate object that is invoked to refresh the activity state at
    opportune times, such as just before the user activity object is sent between
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: If continuing an activity requires more data than is easily transferred by the
    user activity object, the resuming app has the option to open a stream to the
    originating app. Document-based apps automatically support activity continuation
    for users working with iCloud-based documents. Apple apps use public APIs to implement
    Handoff for iOS 8 and OS X v10.10\. A third-party developer can use the same APIs
    to implement Handoff in apps that share the developer's team ID. Such apps must
    either be distributed through the App Store or signed by the registered developer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility with Handoff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s see what is compatible with Handoff:'
  prefs: []
  type: TYPE_NORMAL
- en: iOS devices with a Lightning connector along with 2012 or later Mac models support
    Handoff. Both have radio chips that support both Bluetooth Low Energy and Wi-Fi
    Direct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your device is compatible, you can enable Handoff in the **General** system
    preference on your Mac and in the **General** pane under the **Settings** app
    in iOS; in both cases, look for an option that includes the **Handoff** word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the devices have to be signed in to the same iCloud account. Handoff doesn't
    work with other users (this is what AirDrop is for).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, make sure that both Bluetooth and Wi-Fi are turned on for all devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, Apple has announced that Handoff will work with the following apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keynote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reminders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calendar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With them, we can start composing or reading an e-mail or website; editing a
    document, spreadsheet, or keynote; finding a location; typing a text; picking
    a reminder; entering an appointment; or looking up an address on your Mac and
    continuing or finishing it on your iPhone (iPad, or vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: App framework support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**UIKit** and **AppKit** provide support for Handoff in the document, responder,
    and app delegate classes. Although there are minor behavioral differences between
    the platforms, the basic mechanism that enables the apps to save and restore user
    activities is the same, and the APIs are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Handoff interactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Handing off a user activity involves the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a user activity object for each activity in which the user is engaged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the user activity object regularly with information on what the user
    is doing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue the user activity on a different device when the user requests it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing Handoff directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adopting Handoff in your app requires you to write the code that use APIs in
    UIKit and AppKit to create a user activity object, update the state of the object
    to track the activity, and continue the activity on another device.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user activity object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every user activity that can be handed off to a continuing device is represented
    by a user activity object instantiated from the `NSUserActivity` class. This class
    creates a user activity object for each user activity it supports. The types of
    those user activities depend on the app. For example, Safari lets the user to
    continue with the browser on the same site.
  prefs: []
  type: TYPE_NORMAL
- en: The following code creates the instance of `NSUserActivity`. The `myacitvity.userinfo`
    object stores the current URL with the scroll position. The `becomeCurrent` object
    contains the current state of our project, and it is updating every second. Creating
    an object for the current state is necessary; otherwise, other devices won't understand
    from where to start.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After terminating or finishing the app, the user activity object will release
    automatically. Then the object is removed from all the devices.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying an activity type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The activity type identifier is a short string that appears in your app's `Info.plist`
    property list file in its `NSUserActivityTypes` array, which lists all the activity
    types that your app supports. The same string is passed when you create the activity,
    where the activity object is created with the activity type of `com.myCompany.myBrowser.browsing`,
    a reverse-DNS-style notation intended to avoid collisions. When the user chooses
    to continue the activity, the activity type (along with the app's team ID) determines
    which app to launch on the receiving device to continue the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can specify the activity type of an `NSUserActivity` object when you create
    the instance. You cannot change the activity type of the object after it is created.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a Reminders-style app serializes the reminder list the user is
    looking at. When the user clicks on a new reminder list, the app tracks that activity
    in `NSUserActivityDelegate`. The following code shows a possible implementation
    of a method that gets called whenever the user switches to a different reminder
    list. This app appends an activity name to the app's bundle identifier to create
    the activity type to use when it creates its `NSUserActivity` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the `setNeedsSave`: accessor method to mark the user
    activity object when it needs to be updated. This enables the system to coalesce
    updates and perform them lazily.'
  prefs: []
  type: TYPE_NORMAL
- en: Populating the activity object's user info dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The activity object has a user info dictionary that contains whatever data
    is needed to hand off the activity to the continuing app. The user info dictionary
    can contain `NSArray`, `NSDate`, `NSDictionary`, `NSNull`, `NSNumber`, `NSSet`,
    `NSString`, and `NSUrl` objects. The system modifies the `NSUrl` objects that
    use the `file:` scheme and point at iCloud documents to point to the same items
    in the corresponding container on the receiving device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adopting Handoff in responders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can associate responder objects (inheriting from `NSResponder` on OS X
    or `UIResponder` on iOS) with a given user activity if you set the activity as
    the responder''s `userActivity` property. The system automatically saves the `NSUserActivity`
    object at appropriate times, calling the responder''s `updateUserActivityState`:
    override to add current data to the user activity object using the activity object''s
    `userInfoEntriesFromDictionary`: method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Continuing an activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handoff automatically advertises user activities that are available to be continued
    on iOS and OS X devices that are in physical proximity to the originating device
    and signed in to the same iCloud account as the originating device. When the user
    chooses to continue a given activity, Handoff launches the appropriate app and
    sends the app delegate messages that determine how the activity is resumed using
    the `AppDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `application:willContinueUserActivityWithType:` method to let
    the user know that the activity will continue shortly. Use the `application:continueUserActivity:restorationHandler:`
    method to configure the app to continue the activity. The system calls this method
    when the activity object, including the activity state data in its `userInfo`
    dictionary, is available to the continuing app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For URLs transferred in the `userinfo` dictionary of an `NSUserActivity` object,
    we must call `startAccessingSecurityScopedResource`, and it must return `YES`
    before we can access the URL. Call `stopAccessingSecurityScopedResource` when
    you are done using the file.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions to this requirement are URLs of `UIDocument` documents and those
    of `NSDocument` that are automatically created for `specifyingNSUbiquitousDocumentUserActivityType`
    apps and return NO from the `:continueUserActivity:restorationHandler:` application
    (or leave it unimplemented). See *Adopting Handoff in Document-Based Apps* at
    [https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17).
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional configuration of your app to continue the activity can optionally
    be performed by objects you give to the restoration handler block that is passed
    in with the `application:continueUserActivity:restorationHandler:` message. The
    following code shows a simple implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the app delegate has an array of `NSWindowController` objects,
    `windowControllers`. These window controllers know how to configure all of the
    app's windows to resume the activity. After you pass this array to the `restorationHandler`
    block, Handoff sends each of those objects a `restoreUserActivityState:` message,
    passing in the resuming activity's `NSUserActivity` object. The window controllers
    inherit the `restoreUserActivityState:` method from `NSResponder`; each controller
    object overrides this method to configure its window, using the information in
    the activity object's `userInfo` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: To support graceful failure, the app delegate should implement the `application:didFailToContinueUserActivityWithType:error:`
    method. If you don't implement this method, the app framework, nonetheless, displays
    diagnostic information contained in the passed-in `NSError` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UIApplicationDelegate` methods for Handoff described in this section are
    not called when either of the application delegate methods, `application:willFinishLaunchingWithOptions:`
    or `application:didFinishLaunchingWithOptions:`, returns NO.
  prefs: []
  type: TYPE_NORMAL
- en: Native App-to-Web Browser Handoff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using a native app on the originating device, the user might want to continue
    the activity on a corresponding native app. If there is a web page that corresponds
    to the activity, it can still be handed off. For example, video library apps enable
    users to browse movies available for viewing, and mail apps enable users to read
    and compose e-mails. In many cases, users can perform the same activity through
    a web page interface. In this case, the native app knows the URL for the web interface,
    possibly including syntax that designates a particular video being browsed or
    message being read. So, when the native app creates the `NSUserActivity` object,
    it sets the `webpageURL` property. If the receiving device doesn't have an app
    that supports the user activity's `activityType` property, it can resume the activity
    in the default web browser of the continuing platform.
  prefs: []
  type: TYPE_NORMAL
- en: A web browser on OS X that wants to continue an activity in this way should
    claim the `NSUserActivityTypeBrowsingWeb` activity type (by entering this string
    in its `NSUserActivityTypes` array in the app's `Info.plist` property list file).
    This ensures that, if the user selects any other browser as their default browser,
    it receives the activity object instead of Safari.
  prefs: []
  type: TYPE_NORMAL
- en: Web Browser-to-Native App Handoff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the opposite case, if the user is using a web browser on the originating
    device and the receiving device is an iOS device with a native app that claims
    the domain portion of the `webpageURL` property, then iOS launches the native
    app and sends it an `NSUserActivity` object with an `activityType` value of `NSUserActivityTypeBrowsingWeb`.
    The `webpageURL` property contains the URL that the user was visiting, while the
    `userInfo` dictionary is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The native app on the receiving device must adapt to this behavior by claiming
    a domain in the `com.apple.developer.associated-domains` entitlement. The value
    of this entitlement has the `<service>:<fully qualified domain name>` format,
    for example, `activitycontinuation:example.com`. In this case, the service must
    be `activitycontinuation`. Add the value for the `com.apple.developer.associated-domains`
    entitlement in Xcode in the **Associated Domains** section under the **Capabilities**
    tab of the **Target** settings.
  prefs: []
  type: TYPE_NORMAL
- en: If this domain matches the `webpageURL` property, Handoff downloads a list of
    approved app IDs from the domain. Domain-approved apps are authorized to continue
    the activity. On your website, you can list the approved apps in a signed JSON
    file named `apple-app-site-association`; for example, the web address becomes
    `https://example.com/apple-app-site-association` (you must use an actual device
    rather than the simulator to test download the JSON file).
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON file contains a dictionary that specifies a list of app identifiers
    in the `<team identifier>.<bundle identifier>` format in the **General** tab of
    the **Target** settings—for example, `YWBN8XTPBJ.com.example.myApp`. The following
    code shows an example of such a JSON file formatted for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To sign the JSON file (so that it is returned from the server with the correct
    content-type of `application/pkcs7-mime`), put the content in a text file and
    sign it. You can perform this task with terminal commands such as those shown
    in the following code, by removing the whitespace from the text for ease of manipulation.
    Use the `openssl` command with the certificate and key for an identity issued
    by a certificate authority trusted by iOS (which is listed at [http://support.apple.com/kb/ht5012](http://support.apple.com/kb/ht5012)).
    It need not be the same identity that hosts the web credentials (`https://example.com`
    in the example code), but it must be a valid TLS certificate for the domain name
    in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output of the `openssl` command is the signed JSON file that you put on
    your website at the `apple-app-site-association` URL—in this example, `https://example.com/apple-app-site-association`.
  prefs: []
  type: TYPE_NORMAL
- en: An app can set the `webpageURL` property to any web URL, but it only receives
    activity objects whose `webpageURL` domain is in the `com.apple.developer.associated-domains`
    entitlement. Also, the scheme of the `webpageURL` must be `http` or `https`. Any
    other scheme throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Using continuation streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If resuming an activity requires more data than can be efficiently transferred
    by the initial Handoff payload, a continuing app can call back to the originating
    app''s activity object to open streams between the apps and transfer more data.
    In this case, the originating app sets its `NSUserActivity` object''s Boolean
    property, `supportsContinuationStreams`, to `YES`, sets the user activity delegate,
    and then calls `becomeCurrent`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'On the continuing device, after users indicate that they want to resume the
    activity, the system launches the appropriate app and begins sending messages
    to the app delegate. The app delegate can then request streams back to the originating
    app by sending the `getContinuationStreamsWithCompletionHandler` message to its
    user activity object, as shown in the override implementation in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On the originating device, the user activity delegate receives the streams in
    a callback to its `userActivity:didReceiveInputStream:outputStream` method, which
    it implements to provide the data needed to continue the user activity on the
    resuming device using the streams.
  prefs: []
  type: TYPE_NORMAL
- en: '`NSInputStream` provides read-only access to stream data, and `NSOutputStream`
    provides write-only access. Therefore, data written to the output stream on the
    originating side is read from the input stream on the continuing side; and vice
    versa. Streams are meant to be used in a request-and-response fashion, that is,
    the continuing side uses the streams to request more continuation data from the
    originating side, which then uses the streams to provide the requested data.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuation streams are an optional feature of Handoff; most user activities
    do not need them for successful continuation. Even when streams are needed, in
    most cases there should be minimal back-and-forth between the apps. A simple request
    from the continuing app accompanied by a response from the originating app should
    be enough for most continuation events. You can download the sample project from
    [https://github.com/dokterdok/Continuity-Activation-Tool](https://github.com/dokterdok/Continuity-Activation-Tool).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the new iOS 8 APIs and little code snippets of
    Swift. You learned about the PhotoKit framework and Handoff with some code snippets.
    In the next chapter, we will discuss iCloud and security services in iOS, together
    with their implementations.
  prefs: []
  type: TYPE_NORMAL
