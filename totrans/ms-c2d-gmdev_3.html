<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Focusing on Physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Focusing on Physics</h1></div></div></div><p>This chapter is for those of you who want to incorporate physics into your games. Whether you're building a mini golf game that uses realistic wall bounces or a platformer with endless gravity, this chapter is for you. It will have tutorials on the physics side of games, as well as show you how to use a physics engine without gravity.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">How Chipmunk works</li><li class="listitem">Setting up a project and creating basic objects</li><li class="listitem">Setting gravity by tilting the device</li><li class="listitem">Handling collisions in Chipmunk</li></ul></div><div class="note" title="Note"><h3 class="title"><a id="note03"/>Note</h3><p>You must use Chipmunk for collision detection only (and not physics). Not all games need (or should even consider using) a physics engine. Sometimes, it's better to leave it out. However, if you feel your game will either be more polished or be produced faster, then by all means use it. That being said, the project in this book will not need a physics engine. So, instead of following the project here, we will create a small project that has many modular examples that can be adapted in your other projects. The book's main project will continue in the next chapter.</p></div><p>You may have been used to using the Box2D physics engine, but ever since version 3.0 of Cocos2d, there is no longer any support from the developers to make Box2D work out of the box as it did in previous versions. That being said, this chapter will focus on Chipmunk. If this<a id="id207" class="indexterm"/> chapter does not cover everything you need as far as physics is concerned, feel free to check out the documentation at <a class="ulink" href="http://chipmunk-physics.net/documentation.php">http://chipmunk-physics.net/documentation.php</a>. It also has a variety of online tutorials.</p><div class="section" title="Learn how Chipmunk works"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Learn how Chipmunk works</h1></div></div></div><p>As<a id="id208" class="indexterm"/> previously mentioned, Chipmunk is the physics engine that's integrated with Cocos2d, and is the main physics engine from version 3.0 onwards. The good news for both newcomers and fans of Box2D alike is that Chipmunk is very simple to use. Let's get down to how Chipmunk basically works.</p><div class="section" title="Overall structure of Chipmunk"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Overall structure of Chipmunk</h2></div></div></div><p>Chipmunk<a id="id209" class="indexterm"/> is a physics engine in Cocos2d that simulates real-world physics, that is, making use of gravity, collisions, objects bouncing off each other, and so on.</p><p>Chipmunk uses a "bodies within a world" way of doing things. This means that, as shown in the<a id="id210" class="indexterm"/> following diagram, there's a physics simulation happening (called a <span class="strong"><strong>world</strong></span>), and <a id="id211" class="indexterm"/>anything with physics applicable to it is a <span class="strong"><strong>body</strong></span>. You just create a world that will simulate physics on the bodies within, and off you go. Each world you create will have its own gravity attached to it.</p><p>This is a simple representation of bodies within a world. Note that the entire green rectangle is the world, and the individual squares are bodies within it.</p><div class="mediaobject"><img src="../Images/image00243.jpeg" alt="Overall structure of Chipmunk"/></div><p style="clear:both; height: 1em;"> </p><p>Each body has a type (explained in the next section) as well as properties such as density, mass, friction, elasticity, velocity, and more. In Cocos2d, you can attach a physics body to a sprite with a single line of code, and the sprite will move around to the place where the body is located.</p><p>When these <a id="id212" class="indexterm"/>objects have their boundaries touching/intersecting one another, it's a collision. When a collision occurs, you can handle it however you wish.</p></div><div class="section" title="Types of bodies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Types of bodies</h2></div></div></div><p>Chipmunk has<a id="id213" class="indexterm"/> three types of physics bodies that can be added to the world. They are static, dynamic, and kinematic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Static bodies</strong></span>: These are the walls, ground, immovable rocks, and other objects <a id="id214" class="indexterm"/>in the game. They will not be affected by any gravity or other forces that try to interact with them.</li><li class="listitem"><span class="strong"><strong>Dynamic bodies</strong></span>: These are the default when creating a <code class="literal">CCPhysicsBody</code> object. These<a id="id215" class="indexterm"/> are the objects that will go flying around, colliding with other objects, and have forces act upon them.</li><li class="listitem"><span class="strong"><strong>Kinematic bodies</strong></span>: These are a sort of hybrid body type that cannot be influenced <a id="id216" class="indexterm"/>by forces or gravity, but can still be moved by <code class="literal">CCActions</code> and other methods.</li></ul></div><p>In general, you will only be using static and dynamic bodies (and so is the case with this chapter). If you feel that you need more help with kinematic body types, check out the Cocos2d documentation<a id="id217" class="indexterm"/> about physics bodies at <a class="ulink" href="http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html">http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html</a>.</p><p>Now that you know how Chipmunk works from a technical perspective, let's actually get down to the coding so that we can see these physics bodies for ourselves.</p></div></div></div>
<div class="section" title="Setting up a project and creating basic objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Setting up a project and creating basic objects</h1></div></div></div><p>The <a id="id218" class="indexterm"/>Chipmunk physics engine is fairly well integrated within the<a id="id219" class="indexterm"/> Cocos2d library. It works within SpriteBuilder as well as programmatically within Cocos2d. As with the rest of this book, we will be focusing on creating the project with code, and only using SpriteBuilder as the tool for project creation. So, create a new project in SpriteBuilder and publish it. If you've forgotten how to do this, feel free to go back and reference the project creation in the first chapter.</p><div class="section" title="Setting up Cocos2d for use with physics"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Setting up Cocos2d for use with physics</h2></div></div></div><p>First, we <a id="id220" class="indexterm"/>need to lay down the groundwork so that we can begin to code with it, as the published SpriteBuilder project uses the SpriteBuilder files and not the actual coded scenes. Similar to the previous chapter, open <code class="literal">AppDelegate.m</code> and add the following line of code to the top of the file:</p><div class="informalexample"><pre class="programlisting">#import "MainScene.h"</pre></div><p>Then, in the <code class="literal">startScene</code> method of the <code class="literal">AppDelegate.m</code> file, replace that one line of code that already exists with the following:</p><div class="informalexample"><pre class="programlisting">return [MainScene scene];</pre></div><p>With that in place, open <code class="literal">MainScene.h</code> and add code such that your file looks something like this (make sure you change the <code class="literal">CCNode</code> inheritance to <code class="literal">CCScene</code>, or else some later methods won't work):</p><div class="informalexample"><pre class="programlisting">@interface MainScene : CCScene {
  CGSize winSize;
}
+(CCScene*)scene;
@end</pre></div><p>Finally, open <code class="literal">MainScene.m</code> and add this block of code between the <code class="literal">@implementation</code> and <code class="literal">@end</code> lines:</p><div class="informalexample"><pre class="programlisting">+(CCScene*)scene
{
  return [[self alloc] init];
}

-(id)init
{
  if ((self=[super init]))
  {
    winSize = [[CCDirector sharedDirector] viewSize];
    
    //these values range 0 to 1.0, so use float to get ratio
    CCNode *background = [CCNodeColor nodeWithColor:[CCColor colorWithRed:58/255.f green:138/255.f blue:88/255.f]];
    [self addChild:background];
  }
  return self;
}</pre></div><p>If you run the project at this point (in any simulator or on any device), you'll see a full, green screen. If you don't, go back and make sure you copy all of the code as instructed. If you do see the green color, then you're set to move on to the next section.</p></div><div class="section" title="Building a world for physics to exist"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Building a world for physics to exist</h2></div></div></div><p>Cocos2d is<a id="id221" class="indexterm"/> simply a graphics engine, and we need to create a Chipmunk physics simulation environment so that we can make use of the library. This sounds a lot more complicated than it actually is. Basically, we create a <code class="literal">CCPhysicsNode</code> object, and then add our sprites and nodes to this object, instead of <code class="literal">self</code>.</p><div class="note" title="Note"><h3 class="title"><a id="tip17"/>Tip</h3><p>Remember, <code class="literal">self</code> is a reference to the current object. In the past, we've added objects to the screen using <code class="literal">[self addChild:]</code>, but with the <code class="literal">CCPhysicsNode</code> object, we're going to add objects using [<code class="literal">world addChild:]</code>, since <code class="literal">world</code> will be the name of our <code class="literal">CCPhysicsNode</code> object.</p></div><p>So, open <code class="literal">MainScene.h</code> and add the declaration for the world variable below the <code class="literal">winSize</code> declaration:</p><div class="informalexample"><pre class="programlisting">CCPhysicsNode *world;</pre></div><p>Then open <code class="literal">MainScene.m</code> and add this block of code after the background is created in the <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">//create the physics simulation world
world = [CCPhysicsNode node];
world.debugDraw = YES;
world.gravity = ccp(0, -300);
[self addChild:world];</pre></div><p>And that's it! The preceding code will create a physics world that allows physics to be simulated. All we need to do next is create some <code class="literal">CCNode</code> objects, add physics bodies to the <code class="literal">CCNode</code> objects, then add the <code class="literal">CCNode</code> objects to the physics world (instead of <code class="literal">self</code>).</p><div class="note" title="Note"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>Setting <code class="literal">debugDraw</code> to <code class="literal">YES</code> ensures that whenever we attach any physics body to a <code class="literal">CCNode</code> object and add it to the world, we will have an outline of that body's shape drawn over our objects. Thus, we will know exactly where each body is and how it's colliding. Normally, when <code class="literal">debugDraw</code> is not turned on, we won't see these shapes.</p><p>The collision will still work the same whether you have <code class="literal">debugDraw</code> on or not. The main purpose is to, well, debug the project to make sure the physics bodies are added and colliding as intended.</p></div></div><div class="section" title="Enabling touch creation of our object"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Enabling touch creation of our object</h2></div></div></div><p>Now <a id="id222" class="indexterm"/>we are going to need some objects on the screen that we want to collide with one another. Instead of programmatically spawning the objects, let's have the objects spawn wherever the user touches the screen.</p><p>So, open <code class="literal">MainScene.m</code> and add the following line of code anywhere in the <code class="literal">init</code> method. This will allow you to grab any touch data from the user:</p><div class="informalexample"><pre class="programlisting">[self setUserInteractionEnabled:YES];</pre></div><p>Then, below the <code class="literal">init</code> method, we add this method so that we can start receiving touches in our scene. This method (as seen in the previous chapter) will grab any touch event, and we want to grab the location of the touch so that we can position the object accordingly. Then we will spawn a black square at the touch position:</p><div class="informalexample"><pre class="programlisting">-(void)touchBegan:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
  CGPoint touchPos = [touch locationInNode:self];
  //create a black square
  CGFloat width = winSize.width * 0.1f;
  CCNode *square = [CCNodeColor nodeWithColor:[CCColor colorWithRed:0 
  green:0 blue:0] width:width height:width];
  square.position = touchPos;
  square.anchorPoint = ccp(0.5f,0.5f);
  [world addChild:square];
}</pre></div><p>This will create a node that's 10 percent of the screen's width and add it to the <code class="literal">world</code> object. We're adding it to <code class="literal">world</code> instead of <code class="literal">self</code> because when we add physics bodies to the square, we want the simulation to handle the object's movement. We need to set the <code class="literal">anchorPoint</code> of the node because, by default, a <code class="literal">CCNode</code> has its anchor point at (0,0).</p><p>If you run the game at this point, you will see the same green screen. As you tap around the screen, black squares will appear, centered at the touch location.</p><p>However, you'll notice that even though we've added them to the world object, they aren't falling according to the gravity we set up, and they aren't colliding and pushing each other around. What we have to do next is create a <code class="literal">CCPhysicsBody</code> object and assign it to the created square so that the physics simulation will handle the movement properly.</p><div class="note" title="Note"><h3 class="title"><a id="tip20"/>Tip</h3><p>If you're still a bit unsure what exactly <code class="literal">CCPhysicsBody</code> is, it's essentially an object that has a shape, or perimeter, that defines where the object can collide with other objects. <code class="literal">CCPhysicsBody</code> also has other properties such as elasticity, restitution, density, and so on, and is best used when attached to a <code class="literal">CCNode</code> object so that the node can have its movement handled by the physics body.</p></div></div><div class="section" title="Making the objects fall – adding CCPhysicsBody"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Making the objects fall – adding CCPhysicsBody</h2></div></div></div><p>In the <code class="literal">MainScene.m</code> file, add the following code to the bottom of the touchBegan method. This<a id="id223" class="indexterm"/> will add the physics body we want to the square:</p><div class="informalexample"><pre class="programlisting">//add a physics body to the black square
CCPhysicsBody *squareBody = [CCPhysicsBody bodyWithRect:CGRectMake(0, 0, width, width) cornerRadius:0];
squareBody.elasticity = 0.5f;
square.physicsBody = squareBody;</pre></div><p>With this code in place, when you run the game, you will notice that the objects not only begin to fall but also have that debug square that was mentioned earlier. Notice that we don't have to declare the body type as <span class="strong"><strong>dynamic</strong></span>, as that's the default. Also note the <span class="strong"><strong>elasticity</strong></span> (which, as you might recall, is the bounciness) of 0.5. This is set so that the squares don't go bouncing all over the place. If we wanted that, we would've set the elasticity to a higher number, such as 1.0.</p><p>But oh no! The squares just fall off the screen as if it's a bottomless pit. Let's fix that.</p></div><div class="section" title="Adding the ground and walls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Adding the ground and walls</h2></div></div></div><p>Creating <a id="id224" class="indexterm"/>a ground object is easy, but since the walls and the ceiling <a id="id225" class="indexterm"/>are basically the same thing, let's define a method that will take in <code class="literal">CGRect</code> and create for us a static, invisible node with those dimensions.</p><p>So, anywhere in <code class="literal">MainScene.m</code>, add the following method:</p><div class="informalexample"><pre class="programlisting">-(void)addWallWithRect:(CGRect)rect
{
  CCPhysicsBody *wallBody = [CCPhysicsBody bodyWithRect:rect cornerRadius:0];
  wallBody.type = CCPhysicsBodyTypeStatic;
  wallBody.elasticity = .5f;
  
  CCNode *wall = [CCNode node];
  wall.physicsBody = wallBody;
  [world addChild:wall];
}</pre></div><p>This code is fairly similar to the square's code, except for one notable difference: the type of the physics body. We set it to <code class="literal">static</code> because we don't want the gravity affecting it, nor do we want the squares to push the ground in any direction.</p><p>Just because we declared a method doesn't mean it will automatically generate walls for us. So, go to your <code class="literal">init</code> method and add the following block of code to add the walls around <a id="id226" class="indexterm"/>the<a id="id227" class="indexterm"/> edges of the device:</p><div class="informalexample"><pre class="programlisting">/***** Add Ground, Walls, and Ceiling *****/
    
//ground
[self addWallWithRect:CGRectMake(0, 0, winSize.width, 1)];
    
//left wall
[self addWallWithRect:CGRectMake(0, 0, 1, winSize.height)];
    
//right wall
[self addWallWithRect:CGRectMake(winSize.width, 0, 1, winSize.height)];
    
//ceiling
[self addWallWithRect:CGRectMake(0, winSize.height, winSize.width, 1)];</pre></div><p>This code is fairly self-explanatory in terms of positioning. The bottom-left corner of every Cocos2d scene is (0,0), and the <code class="literal">CGRectMake</code> function takes in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates, and then the width and height of the rectangle.</p><p>That's all for creating a simple object with some physics acting on it! Feel free to mess around with some of the variables such as elasticity, gravity, and so on.</p><div class="note" title="Note"><h3 class="title"><a id="tip21"/>Tip</h3><p>At this point, if you notice that your objects seem to be lagging when they move across the screen—even though Xcode says the game is running at 60 FPS—add the following line of code at the top of the <code class="literal">startScene</code> method in <code class="literal">AppDelegate.m</code>:</p><div class="informalexample"><pre class="programlisting">[CCDirector sharedDirector].fixedUpdateInterval = 1.0f/120.f;</pre></div></div></div></div>
<div class="section" title="Setting gravity by tilting the device"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Setting gravity by tilting the device</h1></div></div></div><p>When <a id="id228" class="indexterm"/>your user tilts the device, the device's accelerometer will pick up that information at even the slightest, most minute values. This is beneficial to those who wish to use the accelerometer (or tilting) within their game, especially with regards to moving the character or manipulating gravity, which is what we'll cover in this section.</p><p>Ever since iOS 5.0, UIAccelerometer has been replaced by the Core Motion framework data. Thankfully, it's no more complicated, so let's get started.</p><div class="note" title="Note"><h3 class="title"><a id="tip22"/>Tip</h3><p>If you aren't a registered developer and can't use your actual device to test (and have been doing so on the simulator), note that it's not possible to test the accelerometer with the simulator unless the data can be sent to the simulator. Here's a link that might be useful in this situation: <a class="ulink" href="http://www.vimov.com/isimulate/">http://www.vimov.com/isimulate/</a>.</p><p>However, even<a id="id229" class="indexterm"/> if you can't test the accelerometer on the simulator by default, it will still work as intended on anyone's device, so if you plan to include the accelerometer in your game, feel free to still follow along.</p></div><div class="section" title="Setting up the accelerometer"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Setting up the accelerometer</h2></div></div></div><p>Open <code class="literal">MainScene.h</code> and import the Core Motion framework:</p><div class="informalexample"><pre class="programlisting">#import &lt;CoreMotion/CoreMotion.h&gt;</pre></div><p>Then <a id="id230" class="indexterm"/>add a variable for something called the <code class="literal">CMMotionManager</code>. This object will calculate the accelerometer data, and we can collect this data when we need it. Add the following line of code under the <code class="literal">world</code> variable:</p><div class="informalexample"><pre class="programlisting">CMMotionManager *motionManager;</pre></div><p>Now open <code class="literal">MainScene.m</code>, and anywhere in the <code class="literal">init</code> method, add the following block of code so that the motion manager we just declared will begin to grab the accelerometer's data:</p><div class="informalexample"><pre class="programlisting">//60 times per second, in theory once per frame
CGFloat interval = 1/60.f; 
motionManager = [[CMMotionManager alloc] init];
motionManager.accelerometerUpdateInterval = interval;
[motionManager startAccelerometerUpdates];</pre></div><p>Right now, if you run the game, you won't notice any changes in the way it plays or any debug information. Even though the motion manager is initialized and is grabbing the data, we must set up a method to collect the data so that we can do something with it.</p></div><div class="section" title="Reading the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Reading the data</h2></div></div></div><p>In <a id="id231" class="indexterm"/>your <code class="literal">init</code> method of <code class="literal">MainScene.m</code>, after you've initialized the motion manager, add the following line of code. It will run the specified method at the given interval (60 times per second):</p><div class="informalexample"><pre class="programlisting">[self schedule:@selector(getAccelerometerData:) interval:interval];</pre></div><p>Then, anywhere<a id="id232" class="indexterm"/> in <code class="literal">MainScene.m</code>, we add the method we want to be called at the specified interval so that we can read the accelerometer data:</p><div class="informalexample"><pre class="programlisting">-(void)getAccelerometerData:(CCTime)delta
{
NSLog(@"%f\t%f\t%f", 
motionManager.accelerometerData.acceleration.x, motionManager.accelerometerData.acceleration.y, motionManager.accelerometerData.acceleration.z);
}</pre></div><p>Now, if you run the game, you'll see a lot of information being printed in the console output in Xcode. If the numbers are changing as you tilt the device, it means everything's working. Yay! If not, go back and make sure you add everything correctly.</p><p>Next, we're going to actually set the game's gravity based on how the device is rotated at any given moment.</p></div><div class="section" title="Manipulating gravity to your heart's content"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Manipulating gravity to your heart's content</h2></div></div></div><p>Instead<a id="id233" class="indexterm"/> of typing that long line of text every time, let's make a method with a relevant name and pass the accelerometer data. That being said, modify your <code class="literal">getAccelerometerData</code> method to the following, and add this new method, which will set the gravity of the physics world based on the accelerometer's data:</p><div class="informalexample"><pre class="programlisting">-(void)getAccelerometerData:(CCTime)delta
{
  //NSLog(@"%f\t%f\t%f", motionManager.accelerometerData.acceleration.x, motionManager.accelerometerData.acceleration.y, motionManager.accelerometerData.acceleration.z);
  [self setGravityFromAcceleration: motionManager.accelerometerData.acceleration];
}

-(void)setGravityFromAcceleration:(CMAcceleration)accel
{
  CGFloat xGravity = 500 * accel.y;
  CGFloat yGravity = -500 * accel.x;
  world.gravity = ccp(xGravity, yGravity);
}</pre></div><p>Now, if you run the game and spawn a few blocks, you'll see them floating, falling down, sliding sideways, or in whichever direction your iOS device perceives as "down." You'll probably see something similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00244.jpeg" alt="Manipulating gravity to your heart's content"/></div><p style="clear:both; height: 1em;"> </p><p>From <a id="id234" class="indexterm"/>here onwards, feel free to turn off debug draw, maybe mess around with how much gravity is set, or even change the axis the gravity is affected by.</p><p>You might notice that a square stops moving on a wall, then doesn't move when you rotate the device; that's because the object's body is sleeping. This is done to help conserve CPU processing time as well as energy when an object has no active collisions and no forces acting on it.</p><p>However, if you need them to be constantly moving, add the following line of code to your <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">world.sleepTimeThreshold = 100000; //100,000 seconds, or about 27 hours</pre></div><p>This defaults to 0.5 seconds, and why the sleeping happens when the squares stop moving against a wall. Setting it to a relatively large value, such as 100,000, will ensure that they never stop moving (that is, unless the square is sitting still for that duration, but the higher the threshold is, the less likely it is to happen).</p></div></div>
<div class="section" title="Handling collisions in Chipmunk"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Handling collisions in Chipmunk</h1></div></div></div><p>It's <a id="id235" class="indexterm"/>relatively easy to handle collisions within Cocos2d when using Chipmunk (as is pretty much everything else in Cocos2d). That is why so many developers use Cocos2d. To do so, we need to do a few different steps so that Cocos2d can properly detect and handle our collisions.</p><div class="section" title="Setting the collision delegate"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/>Setting the collision delegate</h2></div></div></div><p>The <a id="id236" class="indexterm"/>delegate pattern is a common way to handle messages sent by a class to any of its potential parent classes. For example, if you want to use <code class="literal">UITableView</code> (which is the standard table in <code class="literal">UIKit</code>), you must set the delegate of the table view to the class you're adding it to so that when the table view tries to refresh the data in the table, it knows which class' methods to call.</p><p>That being said, we need to tell <code class="literal">MainScene</code> that it will be a delegate for our collision handler, so open up <code class="literal">MainScene.h</code> and add <code class="literal">CCPhysicsCollisionDelegate</code> to the <code class="literal">@interface</code> line. This will allow the <code class="literal">CCPhysicsNode</code> object to set collision detection events on our <code class="literal">MainScene</code> class:</p><div class="informalexample"><pre class="programlisting">@interface MainScene : CCScene &lt;CCPhysicsCollisionDelegate&gt;</pre></div><p>Then open <code class="literal">MainScene.m</code>, and in the <code class="literal">init</code> method, set the <code class="literal">world</code> object's collision delegate to <code class="literal">self</code>, like this:</p><div class="informalexample"><pre class="programlisting">world.collisionDelegate = self;</pre></div><p>Recall that <code class="literal">world</code> is our <code class="literal">CCPhysicsNode</code> object, so any collision detection events that happen within that world (or simulation) will need to be sent somewhere to be handled further. We're setting it to <code class="literal">self</code> because self refers to the current <code class="literal">MainScene</code> instance (our currently running scene). Finally, this helps us determine which objects collide with other objects. Without this line of code, we wouldn't be able to see in the code when two objects collide, let alone tell which objects they actually are.</p><p>Although this doesn't do anything directly if you run the game now, it properly sets up your physics simulation to be able to detect and handle collisions.</p></div><div class="section" title="Setting collision tags on game objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/>Setting collision tags on game objects</h2></div></div></div><p>Before<a id="id237" class="indexterm"/> we can create the method that will detect our collisions, we need to specify which objects will be colliding with one another. For now, we'll only be considering squares colliding with other squares.</p><p>Therefore, in the <code class="literal">touchBegan</code> method of the <code class="literal">MainScene.m</code> file, add the following line of code so that the collision detection delegate knows what object is colliding:</p><div class="informalexample"><pre class="programlisting">squareBody.collisionType = @"square";</pre></div><p>You can do this with any physics body, but for now, this is our only object. With that in place, let's<a id="id238" class="indexterm"/> add the code to detect the actual collision between two squares.</p></div><div class="section" title="Detecting collision"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Detecting collision</h2></div></div></div><p>The way <a id="id239" class="indexterm"/>Chipmunk handles collisions in Cocos2d is by detecting all collisions and sending method calls to the respective functions for each collision type. So, since we're going to be detecting the collision between two squares, both parameters have to be named square. Otherwise, the method won't get called properly. The actual names of the variables of the parameters (<code class="literal">firstSquare</code> and <code class="literal">secondSquare</code>) don't matter for the sake of detection.</p><p>So, anywhere in <code class="literal">MainScene.m</code>, add the following method:</p><div class="informalexample"><pre class="programlisting">-(BOOL)ccPhysicsCollisionBegin:(CCPhysicsCollisionPair *)pair square:(CCNode *)firstSquare square:(CCNode *)secondSquare
{
  NSLog(@"squares collided!");
  return YES;
}</pre></div><p>If you run the game at this point, you should see the <code class="literal">squares collided!</code> text being printed to the console output every time a square collides with another. If it doesn't, go back and make sure you add everything correctly. From here onwards, you can do whatever you want when the two objects collide, as you have a pointer to both objects as well as their types.</p><p>As another example, suppose we want to detect collisions between the squares and a wall; it's very easy. First, add <code class="literal">wall</code> as <code class="literal">collisionType</code> to the body in the addWallWithRect method:</p><div class="informalexample"><pre class="programlisting">wallBody.collisionType = @"wall";</pre></div><p>Then, add the method to detect square-wall collisions (notice the name change in the parameter from the previous <code class="literal">collisionBegan</code> method we added):</p><div class="informalexample"><pre class="programlisting">-(BOOL)ccPhysicsCollisionBegin:(CCPhysicsCollisionPair *)pair square:(CCNode *)nodeA wall:(CCNode *)nodeB
{
  NSLog(@"square-wall collision!");
  return YES;
}</pre></div><p>If you run the game at this point and spawn a square, as soon as it hits a wall, you should see the<a id="id240" class="indexterm"/> output being printed. And that's it for detecting collisions! Just set the <code class="literal">collisionDelegate</code> property, set the <code class="literal">collisionType</code> property, and add the collision methods.</p><p>What if you want to detect collisions on objects, but don't want them to be bouncing with other objects? In Chipmunk, you can do that.</p></div></div>
<div class="section" title="Using Chipmunk for just collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Using Chipmunk for just collision detection</h1></div></div></div><div class="note" title="Note"><h3 class="title"><a id="tip23"/>Tip</h3><p>Here is an important note: if <a id="id241" class="indexterm"/>you're going to just detect<a id="id242" class="indexterm"/> one of the following, you do not need to use a physics engine for your collision detection, but rather the listed method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For rectangles intersecting rectangles, use <code class="literal">CGRectIntersectsRect</code></li><li class="listitem">For points inside rectangles, use <code class="literal">CGRectContainsPoint</code></li><li class="listitem">For radius/distance intersection, use <code class="literal">ccpDistance</code></li></ul></div><p>If you're going to be detecting collisions with non-rectangular and noncircular objects, feel free to read on.</p></div><p>Sometimes, all you're doing is sending objects across the screen, or rotating them with your custom actions, and you just want to know when two objects collide, but don't want the bouncing, pushing, and colliding that comes with the entire physics engine. Luckily, we can do that in Chipmunk.</p><div class="section" title="Turning the physics body into a sensor"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Turning the physics body into a sensor</h2></div></div></div><p>Sensors, with<a id="id243" class="indexterm"/> respect to Chipmunk, are basically bodies that can detect collisions, but pass right through other bodies. These are helpful when you have areas or sections of the screen that trigger certain events, but don't actually cause any physics-based interactions.</p><p>For example, if you're making a top-down mini golf game with a physics engine and you want to include ramps, the best way to do this is to set the ramp as a sensor. When the ball and ramp collide, set the gravity in a certain direction.</p><p>To make a body a sensor, simply set the <code class="literal">sensor</code> variable to true, like this:</p><div class="informalexample"><pre class="programlisting">[squareBody setSensor:YES];</pre></div><p>If you run the game now, you'll notice that the blocks fall right through one another, as well as right through the floor.</p><p>And that's it! All you need is the collision handling (in the previous section), and the sensor <a id="id244" class="indexterm"/>variable set to true. Any physics body that's a sensor will trigger collision detection events, but not cause any movement or changes to other bodies.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Summary</h1></div></div></div><p>Throughout this chapter, you learned how to create a physics simulation, add bodies to the simulation, set the gravity of the world with the accelerometer, handle collisions, and even use the simulation for just collision detection.</p><p>When it comes to really complex physics engine mechanics, such as ropes, joints, and pivots, the Cocos2d documentation at <a class="ulink" href="http://www.cocos2d-swift.org/docs/api/index.html">http://www.cocos2d-swift.org/docs/api/index.html</a> explains a lot. At the time of writing this book, there are very few (if any) tutorials on such complex mechanics available.</p><p>In the next chapter, you'll learn about sound in Cocos2d and some of the cool things you can do to sound effects within the engine.</p></div></body></html>