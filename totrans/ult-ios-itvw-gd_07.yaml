- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swift Programming Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in [*Chapter 4*](B18653_04.xhtml#_idTextAnchor097), understanding
    data structures is a crucial and complex skill for any developer, regardless of
    the platform or language they work with. Data structures are the foundation of
    computer science programming and algorithms, and mastering them is essential for
    success as a developer. Now that we have a solid understanding of data structures,
    it’s time to move on to another important aspect of iOS development: Swift.'
  prefs: []
  type: TYPE_NORMAL
- en: Swift is a highly popular topic in iOS interviews, and it’s not only a programming
    language for iOS developers but also the core foundation of Apple’s new frameworks
    and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, understanding Swift’s primary features such as structs, property
    wrappers, generics, and more is vital to succeeding in iOS development and passing
    an interview. The close relationship between Swift and Apple’s latest technologies
    makes a deep understanding of the language crucial for any iOS developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about optionals, access levels, and closures.
    We will also review computed and lazy properties, extensions, generics, error
    handling, protocols, and memory management questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that end, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we master all Swift features?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Swift features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Swift language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s essential to ensure that we have a good grasp of the primary language features
    to excel in the iOS interview process. But how can we ensure that we are fully
    covered in knowledge and understanding? We will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How do we master all Swift features?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, reading this chapter will get us through most of the important Swift
    features interviewers ask about in the iOS technical interviews.
  prefs: []
  type: TYPE_NORMAL
- en: But that’s not enough.
  prefs: []
  type: TYPE_NORMAL
- en: To become a true professional, we must start acting like one.
  prefs: []
  type: TYPE_NORMAL
- en: For example, reading the *official Swift documentation* is an excellent start
    to ensure we are covered with the latest Swift enhancements. We will ensure we
    cover the basics by going over access levels, error handling, and extensions.
    But don’t think of Swift as just a programming language. Some features were developed
    with deep thinking and interesting methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we shouldn’t answer Swift interview questions just by memorizing the
    technical documentation – the interviewer would like to hear our thoughts, best
    practices, and recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain that idea with extensions.
  prefs: []
  type: TYPE_NORMAL
- en: A typical answer to the question “*Can you please tell me about Swift extensions*?”
    would be, “*Swift extensions allow us to add functionality to an existing class*
    *or struct*.”
  prefs: []
  type: TYPE_NORMAL
- en: 'While this answer is not a mistake, it is still very technical. Try to think
    deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need extensions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do extensions help us to write better code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the use cases that make extensions so powerful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A better answer would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Swift extensions are a powerful tool that allows developers to add new functionality
    to existing classes, structures, enumerations, and protocols. They enable code
    organization by grouping related functionality together, making it easier to read
    and maintain. They also increase the code reusability, readability,* *and testability.*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we must ensure we fully understand extensions to phrase this type
    of answer.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step would be to take what we’ve just learned about extensions and
    implement it on other topics, such as optionals, protocols, generics, and other
    Swift features. That’s precisely what we’re going to do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to know all Swift features? The answer is yes. Do we need to know
    all the features exceptionally well? It’s highly recommended, but we can pass
    some of the interviews without expertise on some of the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why I grouped the Swift features into two levels: basic and advanced.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with some basic language features such as optionals, access levels,
    and closures.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Swift features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a solid understanding of Swift’s basic concepts is essential, as a lack
    of knowledge in these areas can cause significant issues for iOS developers, not
    to mention job interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Answering optionals questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`?` after the variable type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, `name` can contain a value or nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to unwrap an optional and extract its value is the `if` `let`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that since Swift 5.7, it is possible to unwrap more elegantly, keeping
    the optional name as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `if let` shorthand makes it simpler to unwrap as it doesn’t require us to
    create another variable/constant with the same name as the optional.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move to some interview questions.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you give an example of a situation where you would use an optional in your
    code?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question tests our practical understanding of Swift optionals. Because
    optionals are a widespread feature that involves API interface design, functions
    declarations, and control flows, the interviewer needs to see if we understand
    correctly how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use optionals in our code in a few everyday situations. Here are some
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An optional parameter in function declarations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Handling situations where a function may return null:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Handling missing data in JSON response using optionals in a struct:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should use optionals in every place where we understand that we *may not
    receive a value* and receive nil instead.
  prefs: []
  type: TYPE_NORMAL
- en: “List all the options you know to unwrap an optional”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to unwrap an optional. It doesn’t mean that all of them
    are alternatives to each other – each method solves a different use case. Knowing
    most of the ways and their use cases shows our ability to unwrap optionals in
    our code elegantly and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over some of the ways to unwrap an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **if let** syntax to perform a code block with an unwrapped value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use Optional Chaining to avoid multiple **if** **let** statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use **guard let** to have a stop condition and exit the scope if the value
    is nil:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **!** operator. Force unwrap if we are certain the optional contains
    a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use nil coalescing (**??**) to provide a default value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no preferred way to unwrap a value. It all depends on the control flow
    and the situation.
  prefs: []
  type: TYPE_NORMAL
- en: “Using force unwrapping will crash our app in case of nil. So why would we use
    it?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a tricky question often asked in interviews. Take the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `optionalValue` is nil, we’ll get an exception. So, why are we using that
    method?
  prefs: []
  type: TYPE_NORMAL
- en: This interview question is not really about optionals – it’s about our ability
    to *manage exceptions* in our code and crash the app when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward answer would be, “When we are certain the value is
    not nil.” Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But that answer is not a complete one. Why would we even approach the `maybeString`
    variable, even if we just unwrapped it?
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, this question tests our ability to manage exceptions using
    optionals. There are cases where an optional must contain a value. Otherwise,
    the program cannot continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'One popular example would be declaring an `IBOutlet` as forced unwrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ll get an exception if the `label` is nil. In general, we don’t want our
    app to crash, but in this case, a crash indicates that *our program setup is broken*
    – we either disconnected that outlet or even removed it from the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Another good example is force-cast `UITableViewCell` in a `cellForRow` method.
    Even though it’s a casting operation, it is related to optionals because the result
    of casting is an optional value, and we force it to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program is not relevant if this casting fails, therefore we will use force-cast
    for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In summary, force unwrapping is not a common technique, but it can be helpful
    in certain situations where normal unwrapping is not applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Solving access-level questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first, access-level questions seem like a small topic. Technically speaking,
    it is a small topic. Learning and remembering the different access levels is pretty
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The question is always, do we use access levels properly?
  prefs: []
  type: TYPE_NORMAL
- en: While a single keyword represents access levels, they influence code encapsulation,
    visibility, project and organization, and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Access levels also influence how our interfaces between the simple app components
    look.
  prefs: []
  type: TYPE_NORMAL
- en: We should come to our interview knowing what the different levels represent
    and what they mean to our project structure.
  prefs: []
  type: TYPE_NORMAL
- en: “What are the different access levels in Swift, and what are their use cases?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question is considered a screening question, and its goal is to ensure
    we understand the basic access levels in Swift before we move on to more advanced
    questions on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: A screening question
  prefs: []
  type: TYPE_NORMAL
- en: A screening question is a question that the interviewer asks to make sure we
    pass the minimum qualifications for the position and that we have the basic knowledge
    for the role. Experienced developers may find these questions weird – but we should
    remember that the interviewer doesn’t have a previous acquaintance with us. We
    should be careful with these questions and ensure they won’t be a trap in our
    interview. A screening question is also called a “fundamental” or “core” question.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five different access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '*open* – Entities marked as open can be accessed and subclassed by any other
    module, including other frameworks. This level is used when we want to allow our
    class or method to be subclassed or overridden.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*public* – With public, we allow the entity to be accessible from any other
    module or framework *without subclassing* it. Sometimes, because of backward compatibility
    or security, we don’t want other users to subclass our class, and using public
    is a great way to ensure that.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*internal* – We should use the internal access level when we want our entity
    to be accessible *within the same module* but not from the outside. Marking an
    entity as internal is not mandatory – that’s the default access level in case
    we didn’t define it explicitly. But in libraries, it is a best practice to mark
    classes explicitly as internal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*fileprivate* – Entities marked as fileprivate are accessible *within the same
    file*. This is used when we have a class named A, and we want to add another class
    relevant only to class A. The **fileprivate** entity will ensure that constraint
    if we write both classes in the same file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*private* – private methods and variables are accessible only for the *same
    class or struct* (enclosing declaration). With private, we can hide code implementation
    outside the entity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “How do access levels affect code organization and readability?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the previous question, as iOS developers, we shouldn’t look at access
    levels as technical features. Access levels tremendously influence how our code
    is organized and viewed. As a matter of fact, in some way, access levels have
    a part in our code documentation, as it describes what methods are part of the
    interface and what methods are part of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access level affects code organization by separating it to interface and implementation.
    For example, let’s take the following `Game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `Game` has a `gameOver` property which is declared `private`,
    and a `restart()` method, which is `public`. We understand that `gameOver` is
    hidden and cannot be modified directly from outside the class. The only way to
    change it is by using the `restart()` method, and that leads us to my main point
    ‒ readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the `Game` class, we can immediately see that there’s only one
    way to stop the game: by calling `restart()`. They can safely ignore any other
    private methods or variables as it is used only for implementation. If `gameOver`
    was not private, it was possible to modify it from the outside without calling
    the necessary steps that are being done in the `restart()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: In short – the access level explains how to use the class or struct and separate
    them nicely to interface and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Handling questions about Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closures replaced what used to be Blocks in Objective-C and are widely used
    in Swift development. But the reason I put it under *basic Swift features* is
    because closures became a fundamental part of many advanced Swift features. It
    is used as completion handles, advanced collection type functions, SwiftUI, and
    Combine. Not knowing closures well can affect our ability as iOS developers to
    move fast and implement advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you use closures to handle callbacks in iOS?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: I chose to start with this question because callbacks and asynchronous operations
    are typical examples of how to use closures in many Swift applications. Unlike
    delegates, closures can make asynchronous tasks look simple and always in context.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Closures are passed to a function as a parameter and can be executed later.
    Suppose the asynchronous operation is based on a delegate or any other mechanism
    where the response is out of the function scope. In that case, we can handle that
    dependency by saving the closure to an instance variable and calling the closure
    whenever we finish the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example to explain that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let’s see how to use the closure without using any delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code blocks, I demonstrated how to encapsulate the delegate
    inside `SomeClass`, and expose only a closure to be run when the async operation
    ends. This pattern provides a clearer interface to the developer when calling
    `startAsyncOperation`.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how closure capture semantics in Swift can lead to retain cycles
    and how to avoid them?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This classic interview question is a common pitfall junior developers fall into
    when working with closures.
  prefs: []
  type: TYPE_NORMAL
- en: In iOS development, topics are related to each other, even though we deal with
    closures and not memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are powerful, but when we don’t use them correctly, they can produce
    memory leaks and affect our app performance.
  prefs: []
  type: TYPE_NORMAL
- en: This question tests our understanding of how closures work. It checks our knowledge
    of what happens in our app memory when we create and call closure and how scopes
    are handled.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Closures capture variables and constants from the surrounding scopes with a
    **strong reference**. One of these constants might be the objects that hold the
    closure itself, which can cause a **retain cycle**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `SomeClass` has a strong reference to `closure`, and `closure`
    prints `someProperty`, which requires `closure` to have a strong reference to
    `SomeClass` (aka `self`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to avoid a retain cycle is to declare `self` as a `weak` reference
    and, by that, untie the retain cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can also use `unowned` instead of `weak`, but this is a dangerous approach
    – the closure may still be alive while `self` gets deallocated, and that may lead
    to an exception. However, there are cases where using `unowned` instead of `weak`
    is safe, and that can be derived from the relationship between our classes. A
    good example would be the `Country` class and the `CapitalCity` class. A country
    has a reference to its capital city, and the capital city can have an `unowned`
    reference to its country. We understand that the lifetime of a capital city is
    aligned with its country’s lifetime, and therefore, it cannot exist without its
    country. Therefore, using an `unowned` reference in this scenario would be more
    practical, and if an exception occurs, it indicates an error in the code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example that demonstrates using `unowned` between a `Country`
    class and a `CapitalCity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Having an `unowned` reference between `CapitalCity` and `Country` ensures that
    we avoid the retain cycle while still maintaining references between our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have been through the basic Swift features, we are moving to more
    advanced Swift features to ensure we are covered over there.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Swift language features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, interviewers like to start up softly with Swift features, checking
    different language aspects and trying to locate any red flags we might have about
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through more advanced features of Swift, beginning
    with computed and lazy variables.
  prefs: []
  type: TYPE_NORMAL
- en: Solving computed and lazy variables questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computed and lazy variables are both advanced features of Swift variables, providing
    efficient ways to improve performance and code readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s be aligned about what computed and lazy variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Computed variable** – a variable that calculates its value *based on other
    properties*, doesn’t store its value in memory, and calculates it every time it’s
    accessed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following `Rectangle` class, `area` is a computed variable that is based
    on `width` and `height` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Lazy variable** – a variable whose initial value is *calculated once* when
    it’s first accessed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code example explains what a lazy variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `expensiveObject` variable is only initialized when we first access it.
    We can see the `lazy` keyword prefixed the variable declaration, making it lazy.
  prefs: []
  type: TYPE_NORMAL
- en: Many iOS developers make little use of computed and lazy variables, and most
    of the time, the reasons are a lack of understanding and premature optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive into our first question.
  prefs: []
  type: TYPE_NORMAL
- en: “When would you use a computed property instead of a stored property, and vice
    versa?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s a thoughtful question, and it helps to test our understanding of how
    to apply the theory in practice. Both computed and stored properties have their
    advantages and disadvantages in terms of performance and accuracy, so the question
    goes beyond just technical considerations.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties are used when the value needs to be calculated every time
    the property is being accessed. A computed property usually uses other properties
    to calculate its value. Some examples are date formatted, the area of a rectangle,
    or a full name value that is based on other properties such as first and last
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Stored properties, on the other hand, are stored and changed from the outside
    of the class based on user input or other events — for example, username, configuration
    value, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties have a more dynamic nature. They are being calculated constantly
    and are, therefore, more accurate. The downside is that they are less efficient
    in many cases, especially when the value tends to change.
  prefs: []
  type: TYPE_NORMAL
- en: There is a tension between computed and stored properties. Stored properties
    are excellent for performance, but we need to maintain their data accuracy. Computed
    properties are the opposite – they are always accurate but are calculated all
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: “How can you use lazy variables to improve the performance of an app that loads
    large amounts of data?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy variables are significant for performance and memory consumption. This
    question tests our ability to optimize our app and UI loading using lazy variables.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy variables can improve our app’s performance by delaying the data’s initialization
    until it is needed. Loading an object is always considered a heavy task, as the
    runtime environment needs to initialize the object and its properties. So, variables
    that need to initialize and load a large amount of data can affect the loading
    time (and the memory consumption) of the object being loaded. If there’s a possibility
    to postpone the data loading for later, it can improve the object loading time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a lazy loading code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the preceding code that the `largeData` variable can take time
    to be initialized, so we declared it as `lazy`. When we allocate `data`, `largeData`
    is still not allocated, not until we call it using the `print` command.
  prefs: []
  type: TYPE_NORMAL
- en: Solving extensions questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the features we discussed are related to code organization. For example,
    access levels are not just for technical restrictions; they are also part of organizing
    our code and declaring what’s part of the interface and what’s encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature in that area is **extensions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions in Swift have several important roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Extensions allow us to *add new functionality to existing classes*, structs,
    and enums without modifying their source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions can help us to *group related functionality* and improve our code
    readability and organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions are used to *add protocol conformance* to types, aligning their interface
    with other types conforming to the same protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see how many extensions are essential to Swift language, as they are
    widely used in our daily iOS development.
  prefs: []
  type: TYPE_NORMAL
- en: Even though extensions are powerful, they are effortless to use and understand.
    That’s why we must be highly prepared for this topic, as any mistake can raise
    a red flag for our interviewer.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s move to our first question.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you add new properties to a struct or class using an extension?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question seems like a simple yes/no question, but the reality is that it
    hides two more layers of understanding the interviewer wishes to hear.
  prefs: []
  type: TYPE_NORMAL
- en: First, they want to hear the practical layer – what is and is not *possible*
    in extensions (aka the full answer).
  prefs: []
  type: TYPE_NORMAL
- en: But second, and this is a bonus, they want to hear *why extensions work the
    way they work*. That will show how deeply we understand Swift memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry, we’ll cover both layers in our answer.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is “no,” we cannot add stored properties in extensions. But
    it is worth mentioning that it is possible to add computed properties. The reason
    is that we can add new functionality to a type but not its memory layout, which
    can imply to us what can/can’t be added to a type using extensions.
  prefs: []
  type: TYPE_NORMAL
- en: There are several workarounds for that – wrapping the original type or using
    a global variable to store the property value, but the idea stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the “bonus” part of the answer: a type’s memory layout is *determined
    in compile-time* and embedded in the binary. This means that we cannot add new
    stored properties on the fly using extensions, as they will make changes to the
    memory layout set earlier. Adding that fact to the answer would give us additional
    points in the interview!'
  prefs: []
  type: TYPE_NORMAL
- en: “Can you use an extension to add a method to a protocol? If so, how?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a tricky question. Protocols are not types. Extending the protocol is
    like adding new functionality to the conforming types. Confused? That’s why this
    question is tricky… Let’s see the answer to clear things up.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it is possible to extend a protocol. Extending a protocol adds new functionality
    to all types that conform to that protocol, allowing us to add a default implementation
    to protocol methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a code example of extending a protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `MyProtocol` extension adds a new method: `newMethod()`.
    The new method can be used in all types that conform to `MyProtocol`. Let’s continue
    the code example to explain that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I hope it’s clearer now, as `myStruct` can call `newMethod()` even though it
    wasn’t defined in the original protocol declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Solving generics questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Generics** are Swift features that allow iOS developers to write reusable
    code that can work with any type of data.'
  prefs: []
  type: TYPE_NORMAL
- en: For iOS developers, generics are particularly important because they can be
    used to write reusable and type-safe code. This means developers can write code
    used in multiple places within an app without worrying about typecasting or other
    type-related issues. Additionally, generics can help to prevent runtime errors
    and improve performance by allowing the compiler to optimize the code at compile
    time. Overall, generics are powerful tools that can help iOS developers write
    more robust and efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see an example of a reverse method for an array that can work with
    any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important thing to understand about that code snippet is this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `reverseArray()` method receives an array from a specific type and returns
    an array at the same time. Perhaps that’s the core concept of generics – not just
    creating reusable code but also maintaining type safety and avoiding type-casting
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you give an example of a problem that can be solved using generics?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Like previous questions, this question challenges us by taking a theoretical
    topic and asking for a real-life example of how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to other Swift features, it is harder to understand generics’ benefits
    without going over real-world problems and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: A caching class is an excellent example of a problem that can be solved using
    generics. If we want to cache data, we need to create a separate class for each
    type we want to cache or create a different method in some abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, generics let us reuse the same code for different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we use the `Cache` class with `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A cache is a good example because it doesn’t require us to cast the returned
    type. We can initialize a new cache instance that works with a different kind
    of data each time.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you use associated types in a generic protocol?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associated types** are features that iOS developers rarely use, but I still
    want to dedicate one question to them. The reason is that it can give you a better
    picture of generics’ usage and examples in Swift. It is difficult for many iOS
    developers to find practical use cases for generics, so providing an example from
    a different perspective may help your interview readiness.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Associated types are actually *generics for protocols*. They work the same way
    as classes and structs work with generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the associated type, we need to define it in a protocol using the keyword
    `associatedtype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `DataSource` protocol contains a `Data` `associatedtype`, but it is not
    specified what kind of type it will be used. We do that in the protocol implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is an implementation of `DataSource` with `Int` as `Data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Of course, other structs or classes can implement the protocol using a different
    type by defining it in the `Data` type alias, which makes this protocol flexible
    and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Solving error-handling questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Error handling is an essential topic in every language and platform. It lets
    us respond to unexpected events or conditions (which makes them “expected” when
    we think of it).
  prefs: []
  type: TYPE_NORMAL
- en: Error handling and Swift are interesting when we discuss job interviews – first,
    this area *improved tremendously* when we moved from Objective-C to Swift. Still,
    it also improved dramatically between the different Swift versions. Consider that
    by the time you read this book, probably more changes will have been made in error
    handling, so it is worth having a look.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the *increasing popularity of Combine and SwiftUI* made error handling
    even more popular. We can confidently say that error handling is a fundamental
    part of Combine data streams, and if that’s an area we feel insecure about, now
    is the time to catch up!
  prefs: []
  type: TYPE_NORMAL
- en: “How do you use the try? and try! operators for error handling in Swift?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: '`try?` and `try!` are operators that handle errors more concisely.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to explain the difference between the two operators and implement
    them in our code flow.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `do-catch` flow, we can use the `try?` operator to bypass
    it, similar to how we unwrap an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we wrap the call for `someThrowingFunction()` with the
    `try?` operator. The result is an optional value – if the function throws an exception,
    the returned value will be nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `try!` is exactly like force unwrapping. If the function throws an
    exception, our program will be terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we should use `try!` with caution and in cases where there’s no
    point in continuing our program if the function throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain and give an example of how you would write a function in Swift
    that throws an error?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Many developers know how to perform a basic `do-catch` block, mainly because
    it is required in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: The natural step forward is to perform the throwing action ourselves. Knowing
    how to write a function that throws an exception shows a good understanding of
    Swift’s error-handling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things we need to do to have a throwing function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing is to *add the* **throws** *keyword* to its declaration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second thing is having some kind of an *error to throw back* in case of
    a problem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third will be the implementation and *throwing the error in case of an
    exception* (complete code ahead):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remembering these three fundamental components of throwing functions will help
    us nail this function efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: If you still feel insecure about error handling, try to return to one of your
    projects and add error handling in places where you think it’s relevant. There’s
    nothing like practical experience to deal with topics with which you don’t feel
    strongly about.
  prefs: []
  type: TYPE_NORMAL
- en: Solving protocol questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important principles in computer science is the **Separation
    of Concerns**. To achieve that, one of the things we want to do is reduce coupling
    between different parts of our code – decoupling objects and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols play a significant part in this task, making our code more flexible
    and reusable. In modern iOS development, protocols are a fundamental part of the
    development, and we can find them heavily used in almost every API and SDK.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain the use of protocol-oriented programming in iOS development?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Even though that’s an open-ended question, it is common in interviews. Maybe
    because it is an open question, interviewers like to ask it so they can understand
    how candidates think.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols are like spices in cooking – technically, they are easy to use. The
    problem starts with how much and when.
  prefs: []
  type: TYPE_NORMAL
- en: We should be ready for this question, and it is also a chance to spread our
    methodologic point of view of protocol’s role in our code writing.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to understand about **Protocol-Oriented Programming** (**POP**)
    is that it’s a programming paradigm. This means that POP is a set of guidelines
    and rules for organizing and structuring our code.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of POP is that objects communicate with each other using protocols.
    This makes our code much more flexible and reusable, as different types can implement
    different behaviors and still work with other objects by conforming to the same
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: POP works with **Object-Oriented Programming** (**OOP**) and doesn’t replace
    it.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you decide when to use a protocol in your iOS app?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question takes a theory topic (protocol) and moves it to the practical
    world of considerations and tradeoffs. The interviewer doesn’t want to hear a
    dichotomous answer but rather a more profound solution involving our point of
    view on Swift’s development.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with the bottom line: we shouldn’t always use protocols. We should
    use them only when it is effective and they don’t make our project more cumbersome
    than it is already. We should do that with caution and according to the following
    factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Interface reusability* – if we want to reuse a specific interface between
    different types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Abstraction* – A protocol provides another level of abstraction to our code
    by defining a set of methods and properties used by different objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dependency injection* – We can use protocols to inject dependencies into a
    class and, by that, make it more flexible and testable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, protocols are a great solution whenever we need more flexibility
    and decreased coupling in our code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, protocols can add a layer of complexity to our code, adding
    a virtual layer between classes. And that’s an expected trade-off in programming
    – *complexity* *versus coupling*.
  prefs: []
  type: TYPE_NORMAL
- en: Solving memory management questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory management for iOS developers has been a critical issue from the beginning
    days of iOS development.
  prefs: []
  type: TYPE_NORMAL
- en: I must say that things have become better over the years – Apple added **Automatic
    Reference Counting** (**ARC**), debug tools became better, and the hardware has
    evolved dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, efficiency is still essential when discussing resource management.
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared for some questions on that topic in your next iOS technical interview.
  prefs: []
  type: TYPE_NORMAL
- en: “What is the difference between a strong and a weak reference in iOS?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strong** and **weak** references are the core components of the memory ownership
    concept we have in Swift.'
  prefs: []
  type: TYPE_NORMAL
- en: Ownership is the key to ARC, which is the basis of the memory management mechanism
    in iOS, and if we don’t understand how that mechanism works, we are on the path
    of creating **memory leaks** and **retaining cycles**.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is fairly simple: a strong reference (which is the default reference
    unless defined otherwise) is a way to indicate an object is being held in memory
    by one or more elements. In contrast, a weak reference allows the object to be
    deallocated when it is no longer needed.'
  prefs: []
  type: TYPE_NORMAL
- en: A strong reference *increases* the reference counting by one, while a weak reference
    *doesn’t change* the reference counting at all.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of weak reference usage is **a** **delegate pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we can see that the `ViewController` has a strong reference
    to its `delegate` object, while the `delegate` object has a weak reference to
    its `ViewController`. The reason for this arrangement is to avoid a retain cycle
    and, as a result, increase our app memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you handle low memory warnings in iOS?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question is designed to assess our understanding of managing resources.
    There are situations where it is acceptable to receive low memory warnings, but
    the question is how we should handle it when it occurs. Having control over the
    resources in our app allows us to manage and respond to these situations appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: One thing we need to do when we get a low memory warning is to release any unnecessary
    resources and reduce the app’s memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how to reduce our app’s memory footprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Release cache data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use autorelease pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use weak references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release unused resources such as off-screen views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use NSCache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s the time to dig in our memory from past projects and try to remember
    resources we could have released when we get low memory warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the many topics in Swift development, both basic
    and advanced. We covered optionals, access levels, closures, computed and lazy
    variables, extensions, generics, error handling, protocols, and memory management.
  prefs: []
  type: TYPE_NORMAL
- en: These are a lot of topics! But on the other hand, we are experienced Swift developers,
    and these all need to be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: As I said earlier, we are good iOS developers and know the job well. We just
    need to organize our knowledge to be prepared for our interview.
  prefs: []
  type: TYPE_NORMAL
- en: Our next chapter deals with something different than just Swift – we will talk
    about code management.
  prefs: []
  type: TYPE_NORMAL
