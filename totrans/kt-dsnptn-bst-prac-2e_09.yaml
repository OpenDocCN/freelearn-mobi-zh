- en: '*Chapter 7*: Controlling the Data Flow'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：控制数据流'
- en: 'The previous chapter covered an important **Kotlin** concurrency primitive:
    **coroutines**. In this chapter, we''ll discuss two other vital concurrent primitives
    in Kotlin: **channels** and **flows**. We''ll also touch on **higher-order functions**
    for **collections**, as their API is very similar to that of channels and flows.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了重要的**Kotlin**并发原语：**协程**。在这一章中，我们将讨论Kotlin中的另外两个重要的并发原语：**通道**和**流**。我们还将简要介绍**集合**的**高阶函数**，因为它们的API与通道和流非常相似。
- en: The idea of making extensive use of small, reusable, and composable functions
    comes directly from the **functional programming** paradigm, which we discussed
    in the previous chapter. These functions allow us to write code in a manner that
    describes *what* we want to do instead of *how* we want to do it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用小型、可重用和可组合函数的想法直接来自我们在上一章讨论的**函数式编程**范式。这些函数允许我们用描述*我们想要做什么*而不是*我们想要如何做*的方式来编写代码。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Reactive principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式原则
- en: Higher-order functions for collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的高阶函数
- en: Concurrent data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发数据结构
- en: Sequences
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: Channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Flows
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: After reading this chapter, you'll be able to efficiently communicate between
    different coroutines and process your data with ease.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将能够高效地在不同的协程之间进行通信，并轻松处理你的数据。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the technical requirements from the previous chapters, you will
    also need a **Gradle**-enabled Kotlin project to be able to add the required dependencies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章的技术要求外，你还需要一个启用了**Gradle**的**Kotlin**项目，以便能够添加所需的依赖项。
- en: 'You can find the source code used in this chapter on **GitHub** at the following
    location:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到本章使用的源代码，位于**GitHub**上：
- en: '[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07)'
- en: Reactive principles
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式原则
- en: We'll start this chapter with a brief detour into **Reactive programming**,
    as it forms the foundation of the **data streaming** concept.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，简要地探讨**反应式编程**，因为它构成了**数据流**概念的基础。
- en: Reactive programming is a paradigm based on functional programming in which
    we model our logic as a set of operations in a data stream. The fundamental concepts
    of reactive programming are summarized nicely in *The Reactive Manifesto* ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程是一种基于函数式编程的范式，其中我们将我们的逻辑建模为数据流中的一系列操作。反应式编程的基本概念在*反应式宣言*（[https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)）中得到了很好的总结。
- en: 'According to this manifesto, reactive programs should be all of the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这份宣言，反应式程序应该是以下所有内容：
- en: Responsive
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式
- en: Resilient
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Elastic
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Message-driven
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动
- en: To understand these four principles, we'll use an example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这四个原则，我们将使用一个例子。
- en: Let's imagine you are calling your Internet Service Provider, since your internet
    is slow, for example. *Do you have this picture in your mind?* Let's start then.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你正在给你的互联网服务提供商打电话，比如你的互联网速度很慢。*你脑海中有没有这样的画面？* 那我们就开始吧。
- en: Responsive principle
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式原则
- en: '*How much time are you willing to spend waiting on the line?* That depends
    on the urgency of the situation and how much time you have. If you''re in a hurry,
    you''ll probably drop the call sooner rather than later because you don''t know
    how much time you''ll need to wait while listening to that horrible music.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*你愿意花多少时间排队等待？* 这取决于情况的紧迫性和你拥有的时间。如果你很着急，你可能会早点挂断电话，因为你不知道在听那糟糕的音乐时你需要等待多长时间。'
- en: That's the system being *unresponsive* to you. This also happens with web systems.
    A request to a web server may get stuck in a queue when waiting for other requests
    to be processed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是系统对你**无响应**的情况。这种情况也发生在网络系统中。当等待其他请求被处理时，对网络服务器的请求可能会在队列中卡住。
- en: On the other hand, a responsive call center may tell you in a pleasant voice
    once in a while how many people are in the queue before you – or even how much
    time you'll have to wait.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个响应式的呼叫中心可能会偶尔用愉快的声音告诉你，在你之前有多少人在排队——甚至告诉你你需要等待多长时间。
- en: In both cases, the result is the same. You've wasted your time waiting on the
    line. But the second system was responsive to your needs, and you could make decisions
    based on that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，结果都是一样的。你在等待在线上浪费了时间。但第二个系统对你的需求做出了响应，你可以据此做出决定。
- en: Resilient principle
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性原则
- en: Let's move on to the **resilient** principle. Imagine you're waiting on the
    line for 10 minutes and then the line drops. That's the system not being resilient
    to failures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论**弹性**原则。想象一下，你在电话线上等了10分钟，然后线路断了。这就是系统对故障缺乏弹性的例子。
- en: 'The Reactive Manifesto recommends several ways to achieve resiliency:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式宣言建议了实现弹性的几种方法：
- en: '**Delegation**: You''ll probably hear, "*Our current representative is unable
    to resolve your slow internet; we are redirecting you to someone else.*"'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委派**：你可能听到，“*我们当前的代表无法解决你的慢速互联网问题；我们将把你转接到其他人。*”'
- en: '**Replication**: Then, you may hear, "*We are aware that many people are on
    the line; we are adding more representatives as we speak.*" This also relates
    to *elasticity*, which we''ll cover in the next section.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：然后，你可能听到，“*我们意识到很多人都在线上；我们正在说话时增加更多代表。*”这也与*弹性*有关，我们将在下一节中介绍。'
- en: '**Containment** and **isolation**: Finally, the automatic voice tells you,
    "*If you don''t want to wait, please leave your number and we''ll get back to
    you.*" *Containment* means that you are now decoupled from the scalability problems
    the system is having (that is, the system not having enough representatives).
    In contrast, *isolation* means that even if the system has issues with a phone
    line not being reliable, you don''t care.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**和**隔离**：最后，自动语音告诉你，“*如果你不想等待，请留下你的电话号码，我们会给你回电。*”**限制**意味着你现在与系统所面临的可扩展性问题（即系统代表不足）解耦了。相比之下，**隔离**意味着即使系统在电话线路不可靠方面存在问题，你也不关心。'
- en: Elastic principle
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性原则
- en: In the previous section, we discussed replication. To prevent failures, our
    call center always has at least three representatives on shift. Maybe all of them
    are answering calls, or perhaps they're just patiently waiting.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了复制。为了防止故障，我们的客服中心总是至少有三名代表在班上。也许他们都在接听电话，或者他们可能只是在耐心地等待。
- en: '*What happens, though, if some rabid mole chews through the internet cable?*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，如果某个狂热的鼹鼠咬断了互联网电缆会发生什么呢？*'
- en: Suddenly, there is a surge of calls from disgruntled customers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，有大量愤怒的客户来电。
- en: If our call center has only three phones, there is not much we can do about
    this. But if we had some extra resources, we could bring more representatives
    in to handle the incident and calm our customers. And after the cable was finally
    fixed, we could let them go back to their business. That's the system being *elastic*
    in response to the workload.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的客服中心只有三部电话，我们对此无能为力。但如果我们有一些额外的资源，我们可以增加代表来处理事件并安抚我们的客户。而且，当电缆最终修好时，我们可以让他们回去工作。这就是系统对工作量做出弹性的响应。
- en: '*Elasticity* builds on *scalability*. For example, we could manage all of the
    incoming calls if each representative could work independently by having their
    own phone. If we had more representatives than phones, the number of phones would
    become a *bottleneck*, with some representatives unable to answer any calls.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*弹性*建立在*可扩展性*的基础上。例如，如果我们每个代表都能通过拥有自己的电话独立工作，我们就可以管理所有 incoming calls。如果我们有比电话更多的代表，电话的数量就会成为*瓶颈*，一些代表将无法接听任何电话。'
- en: Message-driven principle
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息驱动原则
- en: The **message-driven** principle is also referred to as **asynchronous message
    passing**. So, in the previous section, we saw that if you could leave a message
    for any representative to call back, it could make the system more resilient.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息驱动**原则也被称为**异步消息传递**。所以，在上一节中，我们看到了如果你可以为任何代表留下信息让他们回电，这可以使系统更具弹性。'
- en: '*So, what if all customers only leave messages?*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，如果所有客户都只留下信息怎么办？*'
- en: Then, each representative could *prioritize* those messages or *batch* them.
    For example, printing all of the billing receipts together instead of working
    through the messages in a random order.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个代表都可以*优先处理*这些信息或*批量处理*它们。例如，一次性打印所有账单收据，而不是随机顺序处理信息。
- en: Using messages also allows applying backpressure. If a representative receives
    too many messages, they may collapse from stress. To avoid that, they may text
    you to say that you'll have to wait a bit longer to receive your answer. Again,
    we're also talking about *delegation* here, as all of these principles overlap.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息还可以应用背压。如果一个代表收到太多的消息，他们可能会因为压力而崩溃。为了避免这种情况，他们可能会给你发短信说你需要等待更长一点时间才能收到你的回复。同样，我们在这里也在谈论
    *委托*，因为所有这些原则都是重叠的。
- en: Messages are also *non-blocking*. After you leave the message, you don't sit
    there waiting for the representative's response. Instead, you usually go back
    to your regular tasks. The ability to perform other tasks while you wait is one
    of the cornerstones of *concurrency*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 消息也是 *非阻塞的*。在你发送消息后，你不需要在那里等待代表的回复。相反，你通常会回到你的常规任务。在等待时能够执行其他任务是 *并发* 的基石之一。
- en: In this section, we learned about the four reactive principles. Reactive applications
    are responsive, resilient, elastic, and message-driven. In the following sections,
    we'll see how these principles are applied in Kotlin. We'll start with *collections*,
    or as they'd be referred to in reactive programming terms, *static data streams*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了四个反应性原则。反应性应用是响应的、弹性的、可伸缩的，并且以消息驱动。在接下来的章节中，我们将看到这些原则如何在 Kotlin 中应用。我们将从
    *集合* 开始，或者在反应式编程术语中，称为 *静态数据流*。
- en: Higher-order functions on collections
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合上的高阶函数
- en: We briefly touched on this topic in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, but before we can discuss streams, let's make sure
    that those of us who come from languages that don't have higher-order functions
    on collections know what they are, what they do, and what the benefits of using
    them are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第一章*](B17816_01_ePub.xhtml#_idTextAnchor015)，*Kotlin 入门* 中简要提到了这个话题，但在我们讨论流之前，让我们确保那些来自没有集合高阶函数的语言的人知道它们是什么，它们做什么，以及使用它们的优点是什么。
- en: We won't be able to cover all of the functions available on collections, but
    we'll cover the most widely used ones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法涵盖集合上所有可用的函数，但我们将涵盖最广泛使用的那些。
- en: Mapping elements
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射元素
- en: The `map()` function takes each element of a collection and returns a new element
    of a possibly different type. To understand this idea better, let's say we have
    a list of letters and we would like to output their ASCII values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数接受集合中的每个元素，并返回一个可能不同类型的新元素。为了更好地理解这个想法，让我们假设我们有一个字母列表，我们想要输出它们的 ASCII
    值。'
- en: 'First, let''s implement it in an imperative way:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以命令式的方式实现它：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that even for such a trivial task, we had to write quite a lot of code.
    We also had to define our output list as mutable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使是这样一个简单的任务，我们也不得不编写相当多的代码。我们还必须将输出列表定义为可变的。
- en: 'Now, the same code using the `map()` function would look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `map()` 函数的相同代码将看起来像这样：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how much shorter the implementation is. We don't need to define a mutable
    list, nor do we need to write a `for-each` loop ourselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意实现有多么简短。我们不需要定义一个可变列表，也不需要自己编写 `for-each` 循环。
- en: Filtering elements
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤元素
- en: Another common task is filtering a collection. You know the drill – you iterate
    over it and only put values that fit your criteria in a new collection. For example,
    if given a range of numbers between `1` and `100`, we would like to return only
    those that are divisible by `3` or divisible by `5`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的任务是过滤集合。你知道该怎么做——你遍历它，只将符合你标准的值放入一个新的集合中。例如，如果给定一个介于 `1` 和 `100` 之间的数字范围，我们只想返回那些可以被
    `3` 或 `5` 整除的数字。
- en: 'In the imperative way, this function might look something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式方式中，这个函数可能看起来像这样：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In its functional variant, we would use the `filter()` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在其函数式变体中，我们会使用 `filter()` 函数：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, notice how much more concise our code becomes. We only specify *what*
    needs to be done, filtering elements that match the criteria, and not *how* this
    should be done (for example, using an `if` statement).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们的代码变得更加简洁。我们只指定 *需要做什么*，过滤符合标准的元素，而不是 *如何做*（例如，使用 `if` 语句）。
- en: Finding elements
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找元素
- en: 'Finding the first element in a collection is another common task. If we were
    to write a function for finding a number that is divisible by both `3` and `5`,
    we could implement it like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中查找第一个元素是另一个常见任务。如果我们编写一个查找既能被 `3` 又能被 `5` 整除的数字的函数，我们可以这样实现它：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The same functionality can be achieved using the `find` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能可以使用 `find` 函数实现：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In a similar way to the preceding imperative function, the `find` function returns
    `null` if there is no element that meets our criteria.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的命令式函数类似，如果没有任何元素符合我们的标准，`find` 函数将返回 `null`。
- en: There's also an accompanying `findLast()` method, which does the same, but which
    starts with the last element of the collection.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个配套的 `findLast()` 方法，它执行相同的操作，但以集合的最后一个元素开始。
- en: Executing code for each element
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每个元素执行代码
- en: 'All previous families of functions had one common characteristic: they all
    resulted in a stream. But not all the higher-order functions return streams. Some
    will return a single value, such as `Unit` or, for example, a number. Those functions
    are called **terminator functions**.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的函数族都有一个共同的特点：它们都产生一个流。但并非所有的高阶函数都返回流。有些会返回单个值，例如 `Unit` 或，例如，一个数字。这些函数被称为
    **终结函数**。
- en: In this section, we'll deal with the first terminator function. Terminator functions
    return something else rather than a new collection, so you can't chain the result
    of this call to other calls. Therefore, they *terminate* the chain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理第一个终结函数。终结函数返回的不是新集合，因此你不能将此调用的结果链式调用到其他调用。因此，它们 *终结* 链式调用。
- en: 'In the case of `forEach()`, it returns the result of the `Unit` type. The `Unit`
    type is akin to `void` in `forEach()` function is like the plain old `for` loop:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `forEach()` 的情况下，它返回 `Unit` 类型的结果。`Unit` 类型类似于 `forEach()` 函数中的 `void`。`forEach()`
    函数就像普通的 `for` 循环：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that `forEach()` has some minor performance impacts compared to the traditional
    `for` loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与传统的 `for` 循环相比，`forEach()` 有一些轻微的性能影响。
- en: 'There''s also `forEachIndexed()`, which provides an index in the collection
    alongside the actual value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `forEachIndexed()`，它提供了一个索引，与集合中的实际值一起：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output for the preceding code will be as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since Kotlin 1.1, there''s also the `onEach()` function, which is a bit more
    useful because it returns the collection again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Kotlin 1.1 以来，还有一个 `onEach()` 函数，它更有用一些，因为它会返回集合本身：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, this function is not terminating.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个函数不是终结的。
- en: Summing up elements
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求和元素
- en: Much like `forEach()`, `reduce()` is a terminating function. But instead of
    terminating with `Unit`, which is not very useful, it terminates with a single
    value of the same type as the collection it operates on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `forEach()` 类似，`reduce()` 是一个终结函数。但它不是以 `Unit` 终结，`Unit` 不是很有用，而是以与操作集合相同类型的单个值终结。
- en: 'To see how `reduce()` works in practice, let''s summarize all numbers between
    `1` and `100`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到 `reduce()` 在实际中的应用，让我们总结一下从 `1` 到 `100` 之间的所有数字：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s write the same code using `reduce`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `reduce` 来编写相同的代码：
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that here it lets us avoid declaring a mutable variable for storing the
    sum of the elements. Unlike previous higher-order functions we've seen, `reduce()`
    receives not one but two arguments. The first argument is the accumulator. In
    the imperative example, it's the `sum` variable. The second argument is the next
    element. We used the same names for the arguments, so it should be relatively
    easy to compare both implementations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里它让我们避免了声明一个用于存储元素总和的可变变量。与之前我们看到的高阶函数不同，`reduce()` 接收的不是单个参数，而是两个参数。第一个参数是累加器。在命令式示例中，它是
    `sum` 变量。第二个参数是下一个元素。我们使用了相同的参数名，所以应该相对容易比较这两种实现。
- en: Getting rid of nesting
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除嵌套
- en: 'Sometimes when working with collections, we may end up with a *collection of
    collections*. For example, consider the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理集合时，我们可能会得到一个 *集合的集合*。例如，考虑以下代码：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*But what if we wanted to turn this collection into a single list containing
    all of the nested elements?*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*但如果我们想将这个集合转换成一个包含所有嵌套元素的单一列表呢？*'
- en: 'Then, the output would look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出将如下所示：
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'One option is to iterate our input and use the `addAll` method that the mutable
    collections have:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是迭代我们的输入并使用可变集合的 `addAll` 方法：
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A better option is to use a `flatMap()` function, which will do the same:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择是使用 `flatMap()` 函数，它将执行相同操作：
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This concrete example could be simplified even further by using a `flatten()`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `flatten()` 函数，这个具体的例子可以进一步简化：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: But the `flatMap()` function is usually more useful, as it allows you to apply
    other functions to each collection, in an **Adapter** like pattern.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `flatMap()` 函数通常更有用，因为它允许你将其他函数应用于每个集合，以一种 **适配器** 模式。
- en: There are many other higher-order functions declared on collections, so we couldn't
    cover all of them in this short section. You must browse through the official
    documentation and learn about them. Nevertheless, the functions discussed previously
    should provide a solid ground for the next topic we'll cover.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合上声明了许多其他高阶函数，所以我们无法在这个简短的章节中涵盖所有这些。你必须浏览官方文档并了解它们。尽管如此，之前讨论的函数应该为我们将要讨论的下一个主题提供一个坚实的基础。
- en: Now, when you're familiar with how to transform and iterate over the *static
    data streams*, let's see how we can apply the same operations to *dynamic data
    streams*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你熟悉了如何转换和迭代*静态数据流*时，让我们看看我们如何将这些相同的操作应用到*动态数据流*上。
- en: Exploring concurrent data structures
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索并发数据结构
- en: Now we're familiar with some of the most common higher-order functions on collections,
    let's combine this knowledge with what we learned in the previous chapter about
    concurrency primitives in Kotlin to discuss the *concurrent data structures* Kotlin
    provides.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了集合上的一些最常见的高阶函数，让我们将这个知识与我们在上一章中关于Kotlin并发原语的知识结合起来，讨论Kotlin提供的**并发数据结构**。
- en: 'The two most essential concurrent data structures are *channels* and *flows*.
    However, before we can discuss them, we need to look at another data structure:
    **sequences**. While this data structure is not concurrent itself, it will provide
    us with a bridge into the concurrent world.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的并发数据结构是*通道*和*流*。然而，在我们可以讨论它们之前，我们需要看看另一个数据结构：**序列**。虽然这个数据结构本身不是并发的，但它将为我们提供进入并发世界的一个桥梁。
- en: Sequences
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: Higher-order functions on collections existed in many functional programming
    languages for a long time. But for Java developers, the higher-order functions
    for collections first appeared in Java 8 with the introduction of the **Stream
    API**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多函数式编程语言中，集合上的高阶函数已经存在很长时间了。但对于Java开发者来说，集合上的高阶函数首次出现在Java 8中，随着**Stream API**的引入。
- en: Despite providing developers with valuable functions such as `map()`, `filter()`,
    and some of the others we already discussed, there were two major drawbacks to
    the Stream API. First, in order to use these functions, you had to migrate to
    Java 8\. And second, your collection had to be converted to something called a
    **stream**, which had all of the functions defined on it. If you want to return
    a collection again after mapping and filtering your stream, you can collect it
    back.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Stream API为开发者提供了如`map()`、`filter()`等有价值的函数以及我们之前讨论的一些其他函数，但Stream API有两个主要的缺点。首先，为了使用这些函数，你必须迁移到Java
    8。其次，你的集合必须转换成称为**流**的东西，它上面定义了所有这些函数。如果你想在映射和过滤流之后再次返回一个集合，你可以将其收集回来。
- en: There is also another significant difference between streams and collections.
    Unlike collections, streams can be infinite. Since Kotlin doesn't limit itself
    to only **JVM** and is also backward-compatible to Java 6, it needed to provide
    another solution for the possibility of infinite collections. This solution was
    named **sequence** to avoid clashing with Java streams when they're available.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 流和集合之间还有一个重要的区别。与集合不同，流可以是无限的。由于Kotlin不仅限于**JVM**，并且向后兼容Java 6，因此它需要提供另一个解决方案来处理无限集合的可能性。这个解决方案被命名为**序列**，以避免与Java流冲突，当Java流可用时。
- en: 'We can create a new sequence using the `generateSequence()` function. For example,
    the next function will create an infinite sequence of numbers:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`generateSequence()`函数创建一个新的序列。例如，下一个函数将创建一个无限数字序列：
- en: '[PRE52]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As the first argument we specify the initial value, while the second argument
    is a lambda that generates the next value based on the previous one. The returned
    type, as you can see, is `Sequence`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个参数，我们指定初始值，而第二个参数是一个lambda表达式，它基于前一个值生成下一个值。如您所见，返回的类型是`Sequence`。
- en: 'A regular collection or a range can be converted to a sequence using the `asSequence()`
    function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`asSequence()`函数将常规集合或范围转换为序列：
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we need to build a sequence using more complex logic, you can use a `sequence()`
    builder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用更复杂的逻辑来构建序列，可以使用`sequence()`构建器：
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this example, we create a sequence of Fibonacci numbers. Then, we use the
    `yield()` function to return the next value in the series. Every time the sequence
    is used, the code will resume from the last `yield()` function invoked.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个斐波那契数列。然后，我们使用`yield()`函数来返回序列中的下一个值。每次使用序列时，代码将从最后一个调用的`yield()`函数处恢复。
- en: While the concept of sequences doesn't seem very useful in itself, there is
    a significant difference between sequences and collections. Sequences are *lazy*,
    while collections are *eager*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然序列的概念本身似乎并不很有用，但序列和集合之间存在显著的差异。序列是**懒加载的**，而集合是**急加载的**。
- en: This means that using higher-order functions on collections has a hidden cost
    for collections beyond a certain size. Most of them will copy the collection for
    the sake of immutability.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在集合上使用高阶函数对于超过一定大小的集合来说有一个隐藏的成本。大多数情况下，它们会为了不可变性而复制整个集合。
- en: 'To understand this difference, let''s look at the following code. First, we''ll
    create a list containing a million numbers and measure how much time it takes
    to square each number in the list –  once while operating on a *collection* and
    another while working on a *sequence*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种差异，让我们看看以下代码。首先，我们将创建一个包含一百万个数字的列表，并测量平方列表中每个数字所需的时间——一次在操作**集合**时，另一次在操作**序列**时：
- en: '[PRE66]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We use the `take()` function, which is another higher-order function on collections,
    to *take* just the first element of the calculation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`take()`函数，这是集合上的另一个高阶函数，用于仅获取计算的第一个元素。
- en: You can see that the code that uses a sequence executes much faster. This is
    because sequences, being lazy, execute the chain for each element. This means
    that only a single number from the entire list is squared.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，使用序列的代码执行得更快。这是因为序列是懒加载的，它会为每个元素执行链式操作。这意味着整个列表中只有一个数字被平方。
- en: On the other hand, functions on collections work on the entire collection. This
    means that first, all of the numbers are squared, then put in a new collection,
    and only a single number is taken from the results.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集合上的函数作用于整个集合。这意味着首先，所有的数字都被平方，然后放入一个新的集合中，然后只从结果中取出一个数字。
- en: Sequences, channels, and flows follow the *reactive principles*, so it's essential
    to understand them before moving on. Note that reactive principles are not tied
    to functional programming. You can also be reactive while writing object-oriented
    or procedural code. However, it's still easier to discuss these principles after
    learning about functional programming and its foundations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 序列、通道和流程遵循**响应式原则**，因此在继续之前理解它们是至关重要的。请注意，响应式原则并不局限于函数式编程。在编写面向对象或过程式代码时，您也可以是响应式的。然而，在学习了函数式编程及其基础之后，讨论这些原则仍然更容易。
- en: Channels
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: In the previous chapter, we learned how to spawn coroutines and control them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何生成协程并控制它们。
- en: '*But, what if two coroutines need to communicate with each other?*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是，如果两个协程需要相互通信怎么办？**'
- en: In Java, threads communicate either by using the `wait()`/`notify()`/`notifyAll()`
    pattern or by using one of the rich set of classes from the `java.util.concurrent`
    package – for example, `BlockingQueue`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，线程通过使用`wait()`/`notify()`/`notifyAll()`模式或使用`java.util.concurrent`包中的一系列丰富的类（例如，`BlockingQueue`）进行通信。
- en: 'In Kotlin, as you may have noticed, there are no `wait()`/`notify()` methods.
    Instead, to communicate between coroutines, Kotlin uses channels. `BlockingQueue`,
    but instead of blocking a thread, channels suspend a coroutine, which is a lot
    cheaper. We''ll use the following steps to create a channel and a coroutine:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，如您所注意到的，没有`wait()`/`notify()`方法。相反，为了在协程之间进行通信，Kotlin使用通道。`BlockingQueue`，但通道不会阻塞线程，而是挂起协程，这要便宜得多。我们将使用以下步骤来创建通道和协程：
- en: 'First, let''s create a channel:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个通道：
- en: '[PRE77]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Channels are typed. This channel can only receive integers.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通道是有类型的。这个通道只能接收整数。
- en: 'Then, let''s create a coroutine that reads from this channel:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个从该通道读取的协程：
- en: '[PRE78]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Reading from a channel is as simple as using a `for-each` loop.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从通道读取就像使用`for-each`循环一样简单。
- en: 'Now, let''s send some values to this channel. This is as simple as using the
    `send()` function:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向这个通道发送一些值。这和使用`send()`函数一样简单：
- en: '[PRE79]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Finally, we close the channel. Once closed, the coroutine that listens to the
    channel will also break out of the `for-each` loop, and if there's nothing else
    to do, the coroutine will terminate.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭通道。一旦关闭，监听通道的协程也将退出`for-each`循环，如果没有其他事情要做，协程将终止。
- en: This style of communication is called **Communicating Sequential Processes**,
    or more simply, **CSP**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信方式被称为**通信顺序进程**，或者更简单地说，**CSP**。
- en: As you can see, channels are a convenient and type-safe way to communicate between
    different coroutines. But we had to define the channels manually. In the following
    two sections, we'll see how this can be further simplified.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通道是在不同协程之间通信的一种方便且类型安全的途径。但我们必须手动定义通道。在接下来的两个部分中，我们将看到如何进一步简化这一点。
- en: Producers
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产者
- en: If we need a coroutine that supplies a stream of values, we could use the `produce()`
    function. This function creates a coroutine that is backed up by `ReceiveChannel<T>`,
    where `T` is the type the coroutine produces.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个提供值流的协程，我们可以使用`produce()`函数。这个函数创建了一个由`ReceiveChannel<T>`支持的协程，其中`T`是协程生成的类型。
- en: 'We could rewrite the example from the previous section, as follows, by using
    the `produce()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`produce()`函数重写上一节中的例子，如下所示：
- en: '[PRE80]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that inside the `produce()` block, the `send()` function is readily available
    for us to push new values to the channel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`produce()`块内部，`send()`函数随时可用，我们可以用它将新值推送到通道。
- en: 'Instead of using a `for-each` loop in our consumer coroutine, we can use a
    `consumeEach()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的消费者协程中，我们不需要使用`for-each`循环，我们可以使用`consumeEach()`函数：
- en: '[PRE90]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now, it's time to look at another example where a coroutine is bound to a channel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看另一个例子，其中协程被绑定到通道上了。
- en: Actors
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演员
- en: Similar to `producer()`, `actor()` is a coroutine bound to a channel. But instead
    of a channel going *out* of the coroutine, there's a channel going *into* the
    coroutine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与`producer()`类似，`actor()`是一个与通道绑定的协程。但与通道从协程*出去*不同，这里有一个通道进入协程。
- en: 'Let''s look at the following example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下例子：
- en: '[PRE95]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In this example, our main function is again producing the values and the actors
    consume them through the channel. This is very similar to the first example we
    saw, but instead of explicitly creating a channel and a separate coroutine, we
    have them bundled together.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的主函数再次生成值，并通过通道让演员消费它们。这与我们看到的第一个例子非常相似，但不同之处在于我们没有显式创建通道和单独的协程，而是将它们捆绑在一起。
- en: If you've worked with **Scala** or any other programming language that has actors,
    you may be familiar with a slightly different actor model from what we've described.
    For example, in some implementations, actors have both inbound and outbound channels
    (often called **mailboxes**). But in Kotlin, an actor has only an inbound mailbox
    in the form of a channel.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过**Scala**或任何其他具有演员的编程语言，你可能对我们描述的演员模型略有不同。例如，在某些实现中，演员既有输入通道也有输出通道（通常称为**邮箱**）。但在Kotlin中，演员只有一个以通道形式存在的输入邮箱。
- en: Buffered channels
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: In all of the previous examples, whether creating channels explicitly or implicitly,
    we in fact used their *unbuffered* version.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的例子中，无论是显式还是隐式地创建通道，我们实际上使用的是它们的*未缓冲*版本。
- en: 'To demonstrate what this means, let''s take a look at a slightly altered example
    from the previous section:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这意味着什么，让我们看看上一节中略微修改过的例子：
- en: '[PRE103]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, we have almost the same `actor` object, which receives timestamps and
    prints the difference between every two timestamps it gets. We also introduce
    a small delay before it can read the next value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们几乎有相同的`actor`对象，它接收时间戳并打印出它接收到的每个两个时间戳之间的差异。我们还在它能够读取下一个值之前引入了一个小延迟。
- en: 'Instead of sending a sequence of numbers, we would send the current timestamp
    to this `actor` object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是发送一系列数字，我们将当前时间戳发送到这个`actor`对象：
- en: '[PRE111]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, let''s take a look at the output of our code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们代码的输出：
- en: '[PRE115]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Notice that our producer is suspended until the channel is ready to accept the
    next value. Therefore, the `actor` object is able to apply backpressure on the
    producer, telling it not to send the next value until the `actor` object is ready.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的生产者在通道准备好接受下一个值之前是挂起的。因此，`actor`对象能够对生产者施加回压，告诉它不要发送下一个值，直到`actor`对象准备好。
- en: 'Now, let''s make a minor change to the way we define our `actor` object:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对我们的`actor`对象的定义方式做一些小的改动：
- en: '[PRE120]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Every channel has a *capacity*, which is zero by default. This means until a
    value is consumed from a channel, no other value can be sent over it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通道都有一个*容量*，默认为零。这意味着在从通道消耗一个值之前，无法通过它发送其他值。
- en: 'Now, if we run our code again, we''ll see a completely different output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行我们的代码，我们将看到完全不同的输出：
- en: '[PRE123]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The producer doesn't have to wait for the consumer anymore because the channel
    now buffers the messages. So, the messages are sent as fast as possible and the
    actor is still able to consume them at its own pace.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通道现在缓冲消息，生产者不再需要等待消费者。因此，消息尽可能快地发送，而actor仍然可以以自己的节奏消费它们。
- en: 'In a similar manner, `capacity` could be defined on the producer channel:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，`capacity`也可以定义在生产者通道上：
- en: '[PRE127]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'And it could be defined on the raw channel as well:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以定义在原始通道上：
- en: '[PRE132]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Buffered channels are a very powerful concept that allow us to *decouple* producers
    from consumers. You should use them carefully, though, as the larger the capacity
    of the channel is, the more memory it will require.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道是一个非常强大的概念，它允许我们将生产者与消费者*解耦*。不过，您应该谨慎使用它们，因为通道的容量越大，所需的内存就越多。
- en: Channels are a relatively low-level concurrency construct. So, let's take a
    look at another type of stream, which provides us with a higher level of abstraction.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是一种相对底层的并发结构。因此，让我们看看另一种类型的流，它为我们提供了更高层次的抽象。
- en: Flows
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: A **flow** is a cold, asynchronous stream and is an implementation of the **Observable
    design pattern** we covered in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**是一个冷、异步的流，是我们在[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)，“熟悉行为模式”中介绍的**可观察设计模式**的实现。'
- en: 'As a quick reminder, the Observable design pattern has two methods: `subscribe()`
    (which allows consumers to, well, subscribe for messages) and `publish()` (which
    sends a new message to all of the subscribers).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速提醒，可观察的设计模式有两个方法：`subscribe()`（允许消费者订阅消息）和`publish()`（向所有订阅者发送新消息）。
- en: The publish method of the `Flow` object is called `emit()`, while the subscribe
    method is called `collect()`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow`对象的发布方法是`emit()`，而订阅方法是`collect()`。'
- en: 'We can create a new flow using the `flow()` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`flow()`函数创建一个新的流：
- en: '[PRE133]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Inside the `flow` constructor, we can use the `emit()` function to publish a
    new value to all listeners.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flow`构造函数内部，我们可以使用`emit()`函数向所有监听器发布新的值。
- en: 'For example, here we create a flow that would publish ten numbers using the
    `flow` constructor:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们创建了一个使用`flow`构造函数发布十个数字的流：
- en: '[PRE136]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Now that we've covered how to publish a message, let's discuss how to subscribe
    to a flow.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何发布消息，让我们讨论如何订阅流。
- en: 'For that, we can use the `collect()` function available on the `flow` object:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用`flow`对象上可用的`collect()`函数：
- en: '[PRE142]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: If you run this code now, you'll see that the listener prints all the numbers
    it receives from the flow.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行此代码，您会看到监听器打印出它从流中接收到的所有数字。
- en: 'Unlike some other reactive frameworks and libraries, there is no special syntax
    to raise an exception to the listener. Instead, we can simply use the standard
    `throw` expression to do that:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他响应式框架和库不同，没有特殊的语法来向监听器抛出异常。相反，我们可以简单地使用标准的`throw`表达式来完成这个操作：
- en: '[PRE145]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'From the listener side, handling exceptions is as simple as wrapping the `collect()`
    function in a `try`/`catch` block:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从监听器方面来看，处理异常就像将`collect()`函数包裹在`try`/`catch`块中一样简单：
- en: '[PRE153]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Like channels, the Kotlin flows are suspending, but they are not concurrent.
    Flows support backpressure, although this is completely transparent to the user.
    To see what this means, let''s create multiple subscribers for the same flow:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与通道一样，Kotlin的流是挂起的，但它们不是并发的。流支持背压，尽管这对用户来说是完全透明的。为了了解这意味着什么，让我们为同一个流创建多个订阅者：
- en: '[PRE161]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Each subscriber runs in its own coroutine, with a delay of five seconds between
    each new subscription. This allows us to see them run concurrently.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个订阅者都在自己的协程中运行，每个新订阅之间有五秒的延迟。这允许我们看到它们并发运行。
- en: 'Now, let''s take a look at the output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看输出结果：
- en: '[PRE171]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'From this output, we can learn two important lessons:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以学习两个重要的教训：
- en: '`1`.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`。'
- en: '**Flows use backpressure**: Note that the next number is not sent until the
    previous number is received. This is similar to the behavior of unbuffered channels
    and different from buffered channels, where the producer can send numbers faster
    than the consumer can consume them.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流使用背压**：请注意，下一个数字只有在接收到前一个数字之后才会发送。这与未缓冲通道的行为相似，与缓冲通道不同，在缓冲通道中，生产者可以比消费者更快地发送数字。'
- en: Next, let's see how these two properties of flows can be altered, if necessary.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这些流的两个属性如何被修改（如果需要的话）。
- en: Buffering flows
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲流
- en: 'In some cases, for example, when we have plenty of available memory, we aren''t
    interested in applying backpressure on the producer right away. To do so, each
    consumer can specify that the flow should be *buffered* by using the `buffer()`
    function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，例如，当我们有足够的可用内存时，我们并不急于对生产者应用背压。为了做到这一点，每个消费者都可以指定使用`buffer()`函数来缓冲流程：
- en: '[PRE179]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'If we look at the output of the preceding code again, we''ll see a dramatic
    change:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看上述代码的输出，我们会看到显著的变化：
- en: '[PRE183]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: With a buffer, the flow produces values without any backpressure from the consumer
    until the buffer is filled. Then, the consumer is still able to collect the values
    at its own pace. This behavior is similar to buffered channels, and in fact, the
    implementation uses a channel under the hood.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓冲区，流程在缓冲区填满之前不会受到消费者任何背压的影响。然后，消费者仍然能够以自己的节奏收集值。这种行为类似于缓冲通道，实际上，实现使用了一个底层的通道。
- en: Buffering a flow is useful when it takes a considerable amount of time to process
    each message. Take uploading images from your phone as an example. Of course,
    the upload will take a different amount of time based on the size of the image.
    You don't want to block the user interface until the image is uploaded because
    that would be a bad user experience and against reactive principles.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲流程在处理每条消息需要相当多的时间时非常有用。以从手机上传图片为例。当然，上传所需的时间会根据图片的大小而有所不同。你不想在上传图片之前阻止用户界面，因为这会是一个糟糕的用户体验，并且违反了响应式原则。
- en: Instead, you could define a buffer that fits into the memory, upload the images
    at your own pace, and block the user interface only once the buffer is full of
    tasks.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以定义一个适合内存的缓冲区，以自己的节奏上传图片，并且只有在缓冲区充满任务时才阻止用户界面。
- en: In the case of images, we are dealing with a series of elements we don't want
    to lose. So, let's consider a different example, where we could allow dropping
    some of the elements in our flow.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片的情况下，我们处理的是一系列我们不希望丢失的元素。所以，让我们考虑一个不同的例子，在这个例子中，我们可以允许在我们的流程中丢弃一些元素。
- en: Conflating flows
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并流程
- en: 'Imagine we have a flow that produces changes in stock prices at a rate of ten
    times a second, and we have a UI that needs to display the latest stock values.
    To do this, we''ll just use a number that goes up by 1 for every tick:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个以每秒十次的速度产生股价变化的流程，并且我们有一个需要显示最新股价的UI。为此，我们只需使用一个每次滴答上升1的数字：
- en: '[PRE190]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The UI itself, however, doesn''t have to be refreshed ten times every second.
    Once every second is more than enough. If we simply try to use `collect()`, as
    in the previous example, we''ll be constantly behind the producer:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，UI本身不需要每秒刷新十次。每秒一次就足够了。如果我们简单地尝试使用`collect()`，就像前面的例子一样，我们将会不断落后于生产者：
- en: '[PRE197]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The preceding code outputs the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下内容：
- en: '[PRE203]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The preceding output is incorrect. The reason for this is that we apply backpressure
    to the flow, slowing it down. Another option would be to buffer 10 values, as
    we've seen in the previous example. But since we want to refresh the UI ten times
    slower than the flow refreshes itself, we'll have to discard nine values out of
    ten. We'll leave it to the readers to try and implement that logic.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是不正确的。原因是我们对流程应用了背压，使其减慢。另一个选择是缓冲10个值，就像我们在前面的例子中看到的那样。但因为我们希望UI的刷新速度比流程本身快十倍，所以我们将不得不丢弃十个值中的九个。我们将把这个逻辑的实现留给读者去尝试。
- en: 'A better solution would be to *conflate* the flow. A conflated flow doesn''t
    store all of the messages. Instead, it keeps only the most recent values. We implement
    this in the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是*合并*流程。合并流程不会存储所有消息。相反，它只保留最新的值。我们在以下代码中实现了这一点：
- en: '[PRE207]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Let''s first look at the output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看输出：
- en: '[PRE212]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: You can see that now the values are correct. On average, our counter is incremented
    ten times every second.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到现在值是正确的。平均来说，我们的计数器每秒增加十次。
- en: Now, our flow will never be suspended and the subscriber will receive only the
    most recent value that the flow has calculated.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的流程将永远不会中断，并且订阅者将只接收到流程计算出的最新值。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to practicing functional programming with reactive
    principles and learning the building blocks of functional programming in Kotlin.
    We also learned about the main benefits of reactive systems. For example, such
    systems should be responsive, resilient, elastic, and driven by messaging.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于练习使用响应式原则进行函数式编程，并学习 Kotlin 中函数式编程的构建块。我们还了解了响应式系统的主要好处。例如，这样的系统应该是响应的、弹性的、可伸缩的，并由消息驱动。
- en: Now, you should know how to transform your data, filter your collections, and
    find elements within the collection that meet your criteria.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该知道如何转换你的数据，过滤你的集合，并找到满足你标准的集合中的元素。
- en: You should also better understand the difference between *cold* and *hot* streams.
    A cold stream, such as a *flow*, starts working only when someone subscribes to
    it. A new subscriber will usually receive all of the events. On the other hand,
    a hot stream, such as a *channel*, continuously emits events, even if nobody is
    listening to them. A new subscriber will receive only the events that were sent
    after the subscription was made.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该更好地理解冷流和热流的区别。冷流，例如*流*，只有当有人订阅它时才开始工作。新订阅者通常会接收到所有的事件。另一方面，热流，例如*通道*，会持续发出事件，即使没有人监听它们。新订阅者只会接收到订阅后发送的事件。
- en: We also discussed the concept of backpressure, which can be implemented in a
    flow. For example, if the consumer is not able to process all of the events, it
    may suspend the producer, buffer the events in the hope of catching up, or conflate
    the stream, handling only some of the events.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了背压的概念，这可以在流中实现。例如，如果消费者无法处理所有的事件，它可能会暂停生产者，缓冲事件以期望赶上，或者合并流，只处理一些事件。
- en: The next chapter will cover concurrent design patterns, which allow us to architect
    concurrent systems in a scalable, maintainable, and extensible manner, using coroutines
    and reactive streams as building blocks.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍并发设计模式，这些模式允许我们以可扩展、可维护和可扩展的方式使用协程和响应式流作为构建块来构建并发系统。
- en: Questions
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between higher-order functions on collections and on
    concurrent data structures?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合上的高阶函数与并发数据结构上的高阶函数有什么区别？
- en: What is the difference between cold and hot streams of data?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冷流和热流数据有什么区别？
- en: When should a conflated channel or flow be used?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用合并的通道或流？
