- en: '*Chapter 7*: Controlling the Data Flow'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter covered an important **Kotlin** concurrency primitive:
    **coroutines**. In this chapter, we''ll discuss two other vital concurrent primitives
    in Kotlin: **channels** and **flows**. We''ll also touch on **higher-order functions**
    for **collections**, as their API is very similar to that of channels and flows.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of making extensive use of small, reusable, and composable functions
    comes directly from the **functional programming** paradigm, which we discussed
    in the previous chapter. These functions allow us to write code in a manner that
    describes *what* we want to do instead of *how* we want to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions for collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you'll be able to efficiently communicate between
    different coroutines and process your data with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the technical requirements from the previous chapters, you will
    also need a **Gradle**-enabled Kotlin project to be able to add the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code used in this chapter on **GitHub** at the following
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start this chapter with a brief detour into **Reactive programming**,
    as it forms the foundation of the **data streaming** concept.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is a paradigm based on functional programming in which
    we model our logic as a set of operations in a data stream. The fundamental concepts
    of reactive programming are summarized nicely in *The Reactive Manifesto* ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'According to this manifesto, reactive programs should be all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elastic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand these four principles, we'll use an example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine you are calling your Internet Service Provider, since your internet
    is slow, for example. *Do you have this picture in your mind?* Let's start then.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*How much time are you willing to spend waiting on the line?* That depends
    on the urgency of the situation and how much time you have. If you''re in a hurry,
    you''ll probably drop the call sooner rather than later because you don''t know
    how much time you''ll need to wait while listening to that horrible music.'
  prefs: []
  type: TYPE_NORMAL
- en: That's the system being *unresponsive* to you. This also happens with web systems.
    A request to a web server may get stuck in a queue when waiting for other requests
    to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a responsive call center may tell you in a pleasant voice
    once in a while how many people are in the queue before you â€“ or even how much
    time you'll have to wait.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the result is the same. You've wasted your time waiting on the
    line. But the second system was responsive to your needs, and you could make decisions
    based on that.
  prefs: []
  type: TYPE_NORMAL
- en: Resilient principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's move on to the **resilient** principle. Imagine you're waiting on the
    line for 10 minutes and then the line drops. That's the system not being resilient
    to failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Reactive Manifesto recommends several ways to achieve resiliency:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delegation**: You''ll probably hear, "*Our current representative is unable
    to resolve your slow internet; we are redirecting you to someone else.*"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replication**: Then, you may hear, "*We are aware that many people are on
    the line; we are adding more representatives as we speak.*" This also relates
    to *elasticity*, which we''ll cover in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containment** and **isolation**: Finally, the automatic voice tells you,
    "*If you don''t want to wait, please leave your number and we''ll get back to
    you.*" *Containment* means that you are now decoupled from the scalability problems
    the system is having (that is, the system not having enough representatives).
    In contrast, *isolation* means that even if the system has issues with a phone
    line not being reliable, you don''t care.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elastic principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed replication. To prevent failures, our
    call center always has at least three representatives on shift. Maybe all of them
    are answering calls, or perhaps they're just patiently waiting.
  prefs: []
  type: TYPE_NORMAL
- en: '*What happens, though, if some rabid mole chews through the internet cable?*'
  prefs: []
  type: TYPE_NORMAL
- en: Suddenly, there is a surge of calls from disgruntled customers.
  prefs: []
  type: TYPE_NORMAL
- en: If our call center has only three phones, there is not much we can do about
    this. But if we had some extra resources, we could bring more representatives
    in to handle the incident and calm our customers. And after the cable was finally
    fixed, we could let them go back to their business. That's the system being *elastic*
    in response to the workload.
  prefs: []
  type: TYPE_NORMAL
- en: '*Elasticity* builds on *scalability*. For example, we could manage all of the
    incoming calls if each representative could work independently by having their
    own phone. If we had more representatives than phones, the number of phones would
    become a *bottleneck*, with some representatives unable to answer any calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Message-driven principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **message-driven** principle is also referred to as **asynchronous message
    passing**. So, in the previous section, we saw that if you could leave a message
    for any representative to call back, it could make the system more resilient.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, what if all customers only leave messages?*'
  prefs: []
  type: TYPE_NORMAL
- en: Then, each representative could *prioritize* those messages or *batch* them.
    For example, printing all of the billing receipts together instead of working
    through the messages in a random order.
  prefs: []
  type: TYPE_NORMAL
- en: Using messages also allows applying backpressure. If a representative receives
    too many messages, they may collapse from stress. To avoid that, they may text
    you to say that you'll have to wait a bit longer to receive your answer. Again,
    we're also talking about *delegation* here, as all of these principles overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are also *non-blocking*. After you leave the message, you don't sit
    there waiting for the representative's response. Instead, you usually go back
    to your regular tasks. The ability to perform other tasks while you wait is one
    of the cornerstones of *concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the four reactive principles. Reactive applications
    are responsive, resilient, elastic, and message-driven. In the following sections,
    we'll see how these principles are applied in Kotlin. We'll start with *collections*,
    or as they'd be referred to in reactive programming terms, *static data streams*.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions on collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly touched on this topic in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, but before we can discuss streams, let's make sure
    that those of us who come from languages that don't have higher-order functions
    on collections know what they are, what they do, and what the benefits of using
    them are.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be able to cover all of the functions available on collections, but
    we'll cover the most widely used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `map()` function takes each element of a collection and returns a new element
    of a possibly different type. To understand this idea better, let's say we have
    a list of letters and we would like to output their ASCII values.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s implement it in an imperative way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that even for such a trivial task, we had to write quite a lot of code.
    We also had to define our output list as mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the same code using the `map()` function would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how much shorter the implementation is. We don't need to define a mutable
    list, nor do we need to write a `for-each` loop ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common task is filtering a collection. You know the drill â€“ you iterate
    over it and only put values that fit your criteria in a new collection. For example,
    if given a range of numbers between `1` and `100`, we would like to return only
    those that are divisible by `3` or divisible by `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the imperative way, this function might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In its functional variant, we would use the `filter()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Again, notice how much more concise our code becomes. We only specify *what*
    needs to be done, filtering elements that match the criteria, and not *how* this
    should be done (for example, using an `if` statement).
  prefs: []
  type: TYPE_NORMAL
- en: Finding elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding the first element in a collection is another common task. If we were
    to write a function for finding a number that is divisible by both `3` and `5`,
    we could implement it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The same functionality can be achieved using the `find` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In a similar way to the preceding imperative function, the `find` function returns
    `null` if there is no element that meets our criteria.
  prefs: []
  type: TYPE_NORMAL
- en: There's also an accompanying `findLast()` method, which does the same, but which
    starts with the last element of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Executing code for each element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All previous families of functions had one common characteristic: they all
    resulted in a stream. But not all the higher-order functions return streams. Some
    will return a single value, such as `Unit` or, for example, a number. Those functions
    are called **terminator functions**.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll deal with the first terminator function. Terminator functions
    return something else rather than a new collection, so you can't chain the result
    of this call to other calls. Therefore, they *terminate* the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `forEach()`, it returns the result of the `Unit` type. The `Unit`
    type is akin to `void` in `forEach()` function is like the plain old `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that `forEach()` has some minor performance impacts compared to the traditional
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also `forEachIndexed()`, which provides an index in the collection
    alongside the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Kotlin 1.1, there''s also the `onEach()` function, which is a bit more
    useful because it returns the collection again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function is not terminating.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like `forEach()`, `reduce()` is a terminating function. But instead of
    terminating with `Unit`, which is not very useful, it terminates with a single
    value of the same type as the collection it operates on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how `reduce()` works in practice, let''s summarize all numbers between
    `1` and `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the same code using `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that here it lets us avoid declaring a mutable variable for storing the
    sum of the elements. Unlike previous higher-order functions we've seen, `reduce()`
    receives not one but two arguments. The first argument is the accumulator. In
    the imperative example, it's the `sum` variable. The second argument is the next
    element. We used the same names for the arguments, so it should be relatively
    easy to compare both implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of nesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes when working with collections, we may end up with a *collection of
    collections*. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*But what if we wanted to turn this collection into a single list containing
    all of the nested elements?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'One option is to iterate our input and use the `addAll` method that the mutable
    collections have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A better option is to use a `flatMap()` function, which will do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This concrete example could be simplified even further by using a `flatten()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: But the `flatMap()` function is usually more useful, as it allows you to apply
    other functions to each collection, in an **Adapter** like pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other higher-order functions declared on collections, so we couldn't
    cover all of them in this short section. You must browse through the official
    documentation and learn about them. Nevertheless, the functions discussed previously
    should provide a solid ground for the next topic we'll cover.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you're familiar with how to transform and iterate over the *static
    data streams*, let's see how we can apply the same operations to *dynamic data
    streams*.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring concurrent data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're familiar with some of the most common higher-order functions on collections,
    let's combine this knowledge with what we learned in the previous chapter about
    concurrency primitives in Kotlin to discuss the *concurrent data structures* Kotlin
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most essential concurrent data structures are *channels* and *flows*.
    However, before we can discuss them, we need to look at another data structure:
    **sequences**. While this data structure is not concurrent itself, it will provide
    us with a bridge into the concurrent world.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-order functions on collections existed in many functional programming
    languages for a long time. But for Java developers, the higher-order functions
    for collections first appeared in Java 8 with the introduction of the **Stream
    API**.
  prefs: []
  type: TYPE_NORMAL
- en: Despite providing developers with valuable functions such as `map()`, `filter()`,
    and some of the others we already discussed, there were two major drawbacks to
    the Stream API. First, in order to use these functions, you had to migrate to
    Java 8\. And second, your collection had to be converted to something called a
    **stream**, which had all of the functions defined on it. If you want to return
    a collection again after mapping and filtering your stream, you can collect it
    back.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another significant difference between streams and collections.
    Unlike collections, streams can be infinite. Since Kotlin doesn't limit itself
    to only **JVM** and is also backward-compatible to Java 6, it needed to provide
    another solution for the possibility of infinite collections. This solution was
    named **sequence** to avoid clashing with Java streams when they're available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new sequence using the `generateSequence()` function. For example,
    the next function will create an infinite sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As the first argument we specify the initial value, while the second argument
    is a lambda that generates the next value based on the previous one. The returned
    type, as you can see, is `Sequence`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A regular collection or a range can be converted to a sequence using the `asSequence()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to build a sequence using more complex logic, you can use a `sequence()`
    builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a sequence of Fibonacci numbers. Then, we use the
    `yield()` function to return the next value in the series. Every time the sequence
    is used, the code will resume from the last `yield()` function invoked.
  prefs: []
  type: TYPE_NORMAL
- en: While the concept of sequences doesn't seem very useful in itself, there is
    a significant difference between sequences and collections. Sequences are *lazy*,
    while collections are *eager*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that using higher-order functions on collections has a hidden cost
    for collections beyond a certain size. Most of them will copy the collection for
    the sake of immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this difference, let''s look at the following code. First, we''ll
    create a list containing a million numbers and measure how much time it takes
    to square each number in the list â€“Â Â once while operating on a *collection* and
    another while working on a *sequence*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We use the `take()` function, which is another higher-order function on collections,
    to *take* just the first element of the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the code that uses a sequence executes much faster. This is
    because sequences, being lazy, execute the chain for each element. This means
    that only a single number from the entire list is squared.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, functions on collections work on the entire collection. This
    means that first, all of the numbers are squared, then put in a new collection,
    and only a single number is taken from the results.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences, channels, and flows follow the *reactive principles*, so it's essential
    to understand them before moving on. Note that reactive principles are not tied
    to functional programming. You can also be reactive while writing object-oriented
    or procedural code. However, it's still easier to discuss these principles after
    learning about functional programming and its foundations.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to spawn coroutines and control them.
  prefs: []
  type: TYPE_NORMAL
- en: '*But, what if two coroutines need to communicate with each other?*'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, threads communicate either by using the `wait()`/`notify()`/`notifyAll()`
    pattern or by using one of the rich set of classes from the `java.util.concurrent`
    package â€“ for example, `BlockingQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, as you may have noticed, there are no `wait()`/`notify()` methods.
    Instead, to communicate between coroutines, Kotlin uses channels. `BlockingQueue`,
    but instead of blocking a thread, channels suspend a coroutine, which is a lot
    cheaper. We''ll use the following steps to create a channel and a coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Channels are typed. This channel can only receive integers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, let''s create a coroutine that reads from this channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reading from a channel is as simple as using a `for-each` loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s send some values to this channel. This is as simple as using the
    `send()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we close the channel. Once closed, the coroutine that listens to the
    channel will also break out of the `for-each` loop, and if there's nothing else
    to do, the coroutine will terminate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This style of communication is called **Communicating Sequential Processes**,
    or more simply, **CSP**.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, channels are a convenient and type-safe way to communicate between
    different coroutines. But we had to define the channels manually. In the following
    two sections, we'll see how this can be further simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Producers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we need a coroutine that supplies a stream of values, we could use the `produce()`
    function. This function creates a coroutine that is backed up by `ReceiveChannel<T>`,
    where `T` is the type the coroutine produces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the example from the previous section, as follows, by using
    the `produce()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that inside the `produce()` block, the `send()` function is readily available
    for us to push new values to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a `for-each` loop in our consumer coroutine, we can use a
    `consumeEach()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to look at another example where a coroutine is bound to a channel.
  prefs: []
  type: TYPE_NORMAL
- en: Actors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `producer()`, `actor()` is a coroutine bound to a channel. But instead
    of a channel going *out* of the coroutine, there's a channel going *into* the
    coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our main function is again producing the values and the actors
    consume them through the channel. This is very similar to the first example we
    saw, but instead of explicitly creating a channel and a separate coroutine, we
    have them bundled together.
  prefs: []
  type: TYPE_NORMAL
- en: If you've worked with **Scala** or any other programming language that has actors,
    you may be familiar with a slightly different actor model from what we've described.
    For example, in some implementations, actors have both inbound and outbound channels
    (often called **mailboxes**). But in Kotlin, an actor has only an inbound mailbox
    in the form of a channel.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all of the previous examples, whether creating channels explicitly or implicitly,
    we in fact used their *unbuffered* version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate what this means, let''s take a look at a slightly altered example
    from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have almost the same `actor` object, which receives timestamps and
    prints the difference between every two timestamps it gets. We also introduce
    a small delay before it can read the next value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of sending a sequence of numbers, we would send the current timestamp
    to this `actor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the output of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our producer is suspended until the channel is ready to accept the
    next value. Therefore, the `actor` object is able to apply backpressure on the
    producer, telling it not to send the next value until the `actor` object is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a minor change to the way we define our `actor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Every channel has a *capacity*, which is zero by default. This means until a
    value is consumed from a channel, no other value can be sent over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run our code again, we''ll see a completely different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The producer doesn't have to wait for the consumer anymore because the channel
    now buffers the messages. So, the messages are sent as fast as possible and the
    actor is still able to consume them at its own pace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, `capacity` could be defined on the producer channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'And it could be defined on the raw channel as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Buffered channels are a very powerful concept that allow us to *decouple* producers
    from consumers. You should use them carefully, though, as the larger the capacity
    of the channel is, the more memory it will require.
  prefs: []
  type: TYPE_NORMAL
- en: Channels are a relatively low-level concurrency construct. So, let's take a
    look at another type of stream, which provides us with a higher level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **flow** is a cold, asynchronous stream and is an implementation of the **Observable
    design pattern** we covered in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick reminder, the Observable design pattern has two methods: `subscribe()`
    (which allows consumers to, well, subscribe for messages) and `publish()` (which
    sends a new message to all of the subscribers).'
  prefs: []
  type: TYPE_NORMAL
- en: The publish method of the `Flow` object is called `emit()`, while the subscribe
    method is called `collect()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new flow using the `flow()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `flow` constructor, we can use the `emit()` function to publish a
    new value to all listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here we create a flow that would publish ten numbers using the
    `flow` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've covered how to publish a message, let's discuss how to subscribe
    to a flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we can use the `collect()` function available on the `flow` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code now, you'll see that the listener prints all the numbers
    it receives from the flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike some other reactive frameworks and libraries, there is no special syntax
    to raise an exception to the listener. Instead, we can simply use the standard
    `throw` expression to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'From the listener side, handling exceptions is as simple as wrapping the `collect()`
    function in a `try`/`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Like channels, the Kotlin flows are suspending, but they are not concurrent.
    Flows support backpressure, although this is completely transparent to the user.
    To see what this means, let''s create multiple subscribers for the same flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Each subscriber runs in its own coroutine, with a delay of five seconds between
    each new subscription. This allows us to see them run concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'From this output, we can learn two important lessons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flows use backpressure**: Note that the next number is not sent until the
    previous number is received. This is similar to the behavior of unbuffered channels
    and different from buffered channels, where the producer can send numbers faster
    than the consumer can consume them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's see how these two properties of flows can be altered, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering flows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, for example, when we have plenty of available memory, we aren''t
    interested in applying backpressure on the producer right away. To do so, each
    consumer can specify that the flow should be *buffered* by using the `buffer()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the output of the preceding code again, we''ll see a dramatic
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: With a buffer, the flow produces values without any backpressure from the consumer
    until the buffer is filled. Then, the consumer is still able to collect the values
    at its own pace. This behavior is similar to buffered channels, and in fact, the
    implementation uses a channel under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering a flow is useful when it takes a considerable amount of time to process
    each message. Take uploading images from your phone as an example. Of course,
    the upload will take a different amount of time based on the size of the image.
    You don't want to block the user interface until the image is uploaded because
    that would be a bad user experience and against reactive principles.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you could define a buffer that fits into the memory, upload the images
    at your own pace, and block the user interface only once the buffer is full of
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of images, we are dealing with a series of elements we don't want
    to lose. So, let's consider a different example, where we could allow dropping
    some of the elements in our flow.
  prefs: []
  type: TYPE_NORMAL
- en: Conflating flows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine we have a flow that produces changes in stock prices at a rate of ten
    times a second, and we have a UI that needs to display the latest stock values.
    To do this, we''ll just use a number that goes up by 1 for every tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI itself, however, doesn''t have to be refreshed ten times every second.
    Once every second is more than enough. If we simply try to use `collect()`, as
    in the previous example, we''ll be constantly behind the producer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is incorrect. The reason for this is that we apply backpressure
    to the flow, slowing it down. Another option would be to buffer 10 values, as
    we've seen in the previous example. But since we want to refresh the UI ten times
    slower than the flow refreshes itself, we'll have to discard nine values out of
    ten. We'll leave it to the readers to try and implement that logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution would be to *conflate* the flow. A conflated flow doesn''t
    store all of the messages. Instead, it keeps only the most recent values. We implement
    this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: You can see that now the values are correct. On average, our counter is incremented
    ten times every second.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our flow will never be suspended and the subscriber will receive only the
    most recent value that the flow has calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to practicing functional programming with reactive
    principles and learning the building blocks of functional programming in Kotlin.
    We also learned about the main benefits of reactive systems. For example, such
    systems should be responsive, resilient, elastic, and driven by messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should know how to transform your data, filter your collections, and
    find elements within the collection that meet your criteria.
  prefs: []
  type: TYPE_NORMAL
- en: You should also better understand the difference between *cold* and *hot* streams.
    A cold stream, such as a *flow*, starts working only when someone subscribes to
    it. A new subscriber will usually receive all of the events. On the other hand,
    a hot stream, such as a *channel*, continuously emits events, even if nobody is
    listening to them. A new subscriber will receive only the events that were sent
    after the subscription was made.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the concept of backpressure, which can be implemented in a
    flow. For example, if the consumer is not able to process all of the events, it
    may suspend the producer, buffer the events in the hope of catching up, or conflate
    the stream, handling only some of the events.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover concurrent design patterns, which allow us to architect
    concurrent systems in a scalable, maintainable, and extensible manner, using coroutines
    and reactive streams as building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between higher-order functions on collections and on
    concurrent data structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between cold and hot streams of data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should a conflated channel or flow be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
