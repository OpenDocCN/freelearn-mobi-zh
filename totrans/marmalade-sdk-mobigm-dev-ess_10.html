<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Extending Marmalade with the Extensions Development Kit (EDK)</h1></div></div></div><p>In the previous chapter we mentioned how Marmalade's <a id="id1360" class="indexterm"/>
<strong>Extensions Development Kit</strong> (<strong>EDK</strong>) was a possible way of adding functionality to a Marmalade application that had not been otherwise exposed, by using the standard Marmalade APIs.</p><p>In this chapter we'll be looking at the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of what the EDK is and why it is needed</li><li class="listitem" style="list-style-type: disc">How to extend Marmalade by creating an EDK extension for Windows, iOS, and Android to support reading gyroscope information</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec61"/>Why is the EDK necessary?</h1></div></div></div><p>The Marmalade SDK manages<a id="id1361" class="indexterm"/> to work its magic of being able to take one codebase and deploy it to multiple platforms by providing a set of APIs that sit on top of the APIs specific to each platform.</p><p>A deployed application executable actually consists of two separate files. Our application code is compiled into an <a id="id1362" class="indexterm"/>
<strong>S3E file</strong>, which is the Marmalade equivalent of a Windows <a id="id1363" class="indexterm"/>
<strong>Dynamic Link Library</strong> (<strong>DLL</strong>). This file is the same across all platforms.</p><p>In order to execute our S3E file<a id="id1364" class="indexterm"/>, a <a id="id1365" class="indexterm"/>Loader program is used. This program is the glue between the platform we are running on and our own code. The loader program starts up first, loads the S3E file into memory, and then passes control to the code within it. If our code needs to make a platform-dependant call, it actually makes a request to a function in the loader that will then call the correct operating system function.</p><p>The loader program is a fixed entity and cannot be changed by us, so Marmalade provides us with the <a id="id1366" class="indexterm"/>EDK system to enable us to make platform-specific function calls. Certain parts of the Marmalade SDK have actually been implemented in just this manner; for example, the s3eFacebook API is actually an extension!</p><p>The only problem with the <a id="id1367" class="indexterm"/>EDK is that it is not a completely cross-platform solution. At the time of writing, it was only possible to write extensions for iOS, Android, Windows, and Mac OSX.</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>Since this book is primarily concerned with development using the Windows version of Marmalade, we won't be looking at how to build a Mac extension here, however we will need access to a Mac computer in order to build iOS extensions since, by necessity, we have to use the Apple iOS SDK, which is not available as a Windows download. For details on creating Mac extensions, look in the Marmalade documentation by going to <strong>Marmalade (C++)</strong> | <strong>Extensions Development Kit (EDK)</strong> | <strong>EDK Guides by Platform</strong> | <strong>OS X EDK Guide</strong>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec62"/>Creating an extension for gyroscope input</h1></div></div></div><p>To illustrate the process<a id="id1368" class="indexterm"/>
<a id="id1369" class="indexterm"/> of creating a Marmalade extension, we'll take a look at how to add support for gyroscope input. This is a useful addition since it lets us add a whole new input method to our games yet it also demonstrates just how easy it is to extend Marmalade's functionality.</p><p>Our extension will consist of the following functions:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GyroscopeAvailable</code>
<a id="id1370" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This function is automatically generated for us by the EDK build process. It returns <code class="literal">S3E_TRUE</code> if the Gyroscope extension is supported for the current platform, and <code class="literal">S3E_FALSE</code> if it isn't.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GyroscopeSupported</code>
<a id="id1371" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Not all mobile devices actually contain gyroscope hardware, so this function is provided to determine whether or not we can make use of the gyroscope in our game. The function returns a normal C++ <code class="literal">bool</code> value indicating whether a gyroscope is present.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GyroscopeStart</code> <a id="id1372" class="indexterm"/>and </p>
<p>
<code class="literal">GyroscopeStop</code>
<a id="id1373" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>These two functions start and stop the hardware generating gyroscope input data.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GyroscopeGetX</code>
<a id="id1374" class="indexterm"/>,</p>
<p>
<code class="literal">GyroscopeGetY</code>
<a id="id1375" class="indexterm"/>, and </p>
<p>
<code class="literal">GyroscopeGetZ</code>
<a id="id1376" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the current gyroscope data values for the X, Y, and Z axes. The values are returned as <code class="literal">float</code> values in radians per second.</p>
</td></tr></tbody></table></div><p>The API detailed <a id="id1377" class="indexterm"/>
<a id="id1378" class="indexterm"/>earlier provides the bare minimum functionality required to provide gyroscope support and has deliberately been kept simple in order to demonstrate the process of building an extension more clearly.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec148"/>Declaring the extension API</h2></div></div></div><p>The first step in creating an <a id="id1379" class="indexterm"/>extension is to specify the functions it will contain, which we will do using an <a id="id1380" class="indexterm"/>
<strong>S4E file</strong>. This file is used to define the API of our extension and is best illustrated by an example. If you want to follow along, create a new directory called <code class="literal">Gyroscope</code> and create a file called <code class="literal">Gyroscope.s4e</code> inside it with the following contents:</p><div><pre class="programlisting">include:
#include &lt;s3eTypes.h&gt;

functions:
bool GyroscopeSupported() false
void GyroscopeStart() void
void GyroscopeStop() void
float GyroscopeGetX() 0.0f
float GyroscopeGetY() 0.0f
float GyroscopeGetZ() 0.0f</pre></div><p>The example starts with the line <code class="literal">include:</code>, which is then followed by any number of C preprocessor commands, include files, structure definitions, and class definitions that will become part of the extension's main header file. In our case we are just including the <code class="literal">s3eTypes.h</code> file; but if we needed to pass lots of data between the extension and the calling code, we might want to add structures or classes, enumerations, and definitions here too.</p><p>Next we have the <code class="literal">functions:</code> section of the file, which is little more than a list of the functions that our extension will contain and can be called from within a Marmalade project that makes use of the extension.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>We do not have to list the<a id="id1381" class="indexterm"/> <code class="literal">GyroscopeAvailable</code> function explicitly in the list of functions. The EDK build process automatically generates this function for us by taking the name of the S4E file and appending "Available" to the end of it.</p></div></div><p>As you can see, the functions <a id="id1382" class="indexterm"/>are listed almost as if they were normal C function prototypes. Each function is listed on its own line by first stating the return type and then its name and parameter list (which all just happen to be empty in this example!).</p><p>Additionally, each function in the S4E file function list also specifies a default value it will return and can be followed by a number of optional directives that control the behavior of the function, how it is added to the extension, and how it is called. Our example makes no use of these directives, but the following table shows what can be specified:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Directive</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">run_on_osthread</code>
<a id="id1383" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Specifies that the extension function should only be executed on the main OS thread of the application. This is particularly important if the function performs any kind of user interface interaction, as many platforms will only allow UI calls to be made on the main thread.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no_lock</code>
<a id="id1384" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Disables thread-safe locking when calling this function. By default all extension functions can only be called on a single thread at any particular time and locking code is automatically generated to ensure that this happens.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fast</code>
<a id="id1385" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables fast stack switching. This is an optimization option, which means less data needs to be passed between our application and the loader when making an extension function call by using the same stack as the loader module. Normally the loader module and our application code have separate stacks.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no_assert</code>
<a id="id1386" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Stops an assert from being raised if an extension function is called on a platform for which the extension has not been built. The default value for the function will be returned.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">order</code>
<a id="id1387" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>By default each function listed in the S4E file will be added to the extension in list order and this order is used internally to locate the correct function pointer to call. As our extension develops over time, we may want to add or depreciate functions but still keep related functions together in the S4E file. By adding <code class="literal">order=x</code> after a function declaration we say that this function will occupy position <code class="literal">x</code> in the function order, with <em>x=1</em> being immediately after the last function that does not specify an order value. If that sounds confusing, don't worry; for our own projects we will probably never need to make use of this feature as it is only really an issue if we are making our extension available for other people to use!</p>
</td></tr></tbody></table></div><p>There are also a <a id="id1388" class="indexterm"/>number of global directives that can be specified in the S4E file and these should be listed at the very start of the file before the <code class="literal">include:</code> line. Again our example makes no use of these directives, but for your information they are listed in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Directive</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no_init_term</code>
<a id="id1389" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Specifies that the extension needs no initialization or termination functions to be automatically generated. It is unlikely you will ever use this directive since these functions are generally required in order to set up the interface between the extension and our project code.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">errors</code>
<a id="id1390" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows access to some macros that make communication of errors easier to implement by automatically generating functions, such as <code class="literal">GetError</code>, present in many of the S3E APIs that make up the low-level Marmalade API.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">globals</code>
<a id="id1391" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Declares that the extension will require a global structure block allocated for its internal use and makes some macros available in order to support getting and setting values in this structure.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">callbacks</code>
<a id="id1392" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>States that this extension wants to make use of callbacks and will automatically define callback IDs to support this using the same approach used in other built-in S3E APIs.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec149"/>Making an extension for Windows</h2></div></div></div><p>We'll begin by creating our <a id="id1393" class="indexterm"/>extension for use on Windows. Obviously it's unlikely that a Windows PC would feature gyroscope hardware (though I guess not impossible!), but starting with the Windows version is easiest as it does not require us to install any additional software or SDKs in order to build it.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec101"/>Creating a Windows extension</h3></div></div></div><p>Since we won't actually <a id="id1394" class="indexterm"/>be supporting gyroscope input on Windows, our API only needs to return <code class="literal">false</code> in the <code class="literal">GyroscopeSupported</code> function<a id="id1395" class="indexterm"/> and the functions for accessing current gyroscope values should always return a <code class="literal">0</code> value. Obviously the start and stop functions need to do absolutely nothing!</p><p>We've already created the S4E file, so now we'll put it to use. Open Windows Explorer, navigate to the <code class="literal">Gyroscope</code> directory, and then right-click on the <code class="literal">Gyroscope.s4e</code> file. Select the menu option <strong>Build Windows Extension</strong>, which will run a Python script that generates a number of <a id="id1396" class="indexterm"/>
<a id="id1397" class="indexterm"/>new files and directories.</p><p>In the main <code class="literal">Gyroscope</code> directory<a id="id1398" class="indexterm"/> three new files are created:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Gyroscope_build.mkf</code> <a id="id1399" class="indexterm"/>is the MKF file for the extension that allows us to specify additional generic or platform-dependant source files that are needed for building it</li><li class="listitem" style="list-style-type: disc"><code class="literal">Gyroscope.mkf</code> is the <a id="id1400" class="indexterm"/>MKF file any Marmalade project that makes use of our extension will need to include as a subproject to access the extension functions</li><li class="listitem" style="list-style-type: disc"><code class="literal">Gyroscope_windows.mkb</code> is <a id="id1401" class="indexterm"/>the MKB file that creates a Visual Studio project that we can use to compile the extension code</li></ul></div><p>There are four subdirectories created as well. We can safely ignore the <code class="literal">stamp</code> directory, which contains a file used internally by the EDK build scripts to track changes to the extension API. We can also ignore the files in the <code class="literal">interface</code> directory, which are autogenerated and should not be altered.</p><p>The <code class="literal">h</code> directory contains a single file, <code class="literal">Gyroscope.h</code>, which again we should not modify, as any changes we make will be overwritten by the extension creation scripts. This file is very useful, however, as it is the file we will include in our project sources to access the functions in the extension.</p><p>Finally there is the <code class="literal">source</code> directory that in turn contains three more subdirectories. The <code class="literal">generic</code> subdirectory contains source files that will define the default behavior of the extension if platform-specific source files are not provided. The <code class="literal">h</code> directory also contains files that are used across all platforms for building the extension code. While we can make changes to these files, it is unlikely we will ever need to.</p><p>This leaves us with the <code class="literal">windows</code> subdirectory that contains a single file called <code class="literal">Gyroscope_platform.cpp</code>. This<a id="id1402" class="indexterm"/> file contains stubs for each of our extension functions that were generated from the data provided in the functions list of the S4E file.</p><p>Note however that all the stubbed functions end with the suffix <code class="literal">_platform</code>. The EDK system actually generates a set of generic functions with the exact names specified in the S4E file that calls the equivalent functions that are suffixed with <code class="literal">_platform</code>, if they exist. This is necessary so that code that uses an extension can still be compiled and executed on a platform for which an extension has not, or cannot, be created.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec102"/>Implementing a Windows extension</h3></div></div></div><p>Ordinarily we <a id="id1403" class="indexterm"/>would need to modify the <code class="literal">Gyroscope_platform.cpp</code> file to implement the extension; but for our purposes no changes are actually necessary as the generated stubs provide the desired functionality on Windows.</p><p>Obviously, in this case a Windows extension is a little redundant, but bear in mind we could always create a more complex extension that somehow emulates gyroscope behavior, perhaps using a joystick or some other input device.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec103"/>Building a Windows extension</h3></div></div></div><p>To build the <a id="id1404" class="indexterm"/>extension, we just double-click the <code class="literal">Gyroscope\Gyroscope_windows.mkb</code> file to create a Visual Studio project. Once Visual Studio starts up, select the <strong>(x86) Release</strong> build type from the drop-down menu at the top of the Visual Studio IDE, go to the menu option <strong>Build</strong> | <strong>Build Solution</strong> (or just press the <em>F7</em> key), and the Windows version of the extension will be created. Simple!</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec150"/>Making an Android extension</h2></div></div></div><p>Now we'll turn our <a id="id1405" class="indexterm"/>attention to Android. We'll need to install some software before we can begin, though, as the build process needs to be able to access Java development tools and the Android SDK.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec104"/>Installing the required software for Android development</h3></div></div></div><p>First of all you will need to <a id="id1406" class="indexterm"/>install the Java JDK, which is available for download at the following address:</p><p>
<a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>
</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>When downloading the JDK, make sure it is Version 6 that you download and not the newer Version 7. The Android SDK is not guaranteed to work correctly with Version 7.</p></div></div><p>Once the install package has downloaded, execute it and follow the instructions to install the Java development tools to your PC.</p><p>Next you will need to download the Android SDK and NDK. The Android SDK is the Java library normally used to develop Android applications, while the NDK is an additional set of libraries that allows Java Android code to interface with compiled C++ code.</p><p>The Android SDK is available at the following URL:</p><p>
<a class="ulink" href="http://developer.android.com/sdk/index.html">http://developer.android.com/sdk/index.html</a>
</p><p>It comes as a Windows installer file; so just execute it, accept all the default install options, and wait for it to install.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>Once the Android SDK has been installed, it is useful to set the environment variable <code class="literal">ANDROID_ROOT</code> to the installation directory. This lets the Marmalade deployment tool know where the Android platform tools can be found so that it can automatically install and run generated package files on an Android device connected to your PC using a USB cable.</p></div></div><p>Next you can visit the <a id="id1407" class="indexterm"/>following URL to download the Android NDK:</p><p>
<a class="ulink" href="http://developer.android.com/tools/sdk/ndk/index.html">http://developer.android.com/tools/sdk/ndk/index.html</a>
</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>You will need different versions of the NDK depending on which version of Marmalade you are using. If you are using Marmalade 6.1 or higher, as expected in this book, you will need NDK version 8. For earlier versions of Marmalade, you will need NDK version 7.</p></div></div><p>The NDK is supplied as a ZIP archive, so you will need to decompress it using a suitable archiving program (for example, WinZip). The NDK should be contained in a directory named something like <code class="literal">android-ndk-xxx</code>, where <code class="literal">xxx</code> refers to the version number of the NDK. You can either copy this directory into the root of your <code class="literal">C:</code> or you can set the environment variable <code class="literal">NDK_ROOT</code> to point to the installation path.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec105"/>Creating an Android extension</h3></div></div></div><p>Now that we have the<a id="id1408" class="indexterm"/>
<a id="id1409" class="indexterm"/> necessary development tools in place, we can create the Android extension files by again using the Windows Explorer to locate the <code class="literal">Gyroscope.s4e</code> file. Right-click on the file and select the <strong>Build Android Extension</strong> menu option.</p><p>The files <code class="literal">Gyroscope_android.mkb</code> and <code class="literal">Gyroscope_android_java.mkb</code> will be created in the main <code class="literal">Gyroscope</code> directory. These files will be used later to build the extension code.</p><p>The <code class="literal">source</code> directory will now contain a new directory called <code class="literal">android</code> that contains two files <code class="literal">Gyroscope.java</code> and <code class="literal">Gyroscope_platform.cpp</code>. The former is where we can add Java code that uses the Android SDK code to implement our extension API. The latter is the C++ code that our Marmalade project will call, which in turn calls the Java implementation code.</p><p>It is possible to implement the entire extension in the <code class="literal">Gyroscope_platform.cpp</code> file by using the <strong>Java Native Interface</strong> (<strong>JNI</strong>)<a id="id1410" class="indexterm"/> to access and call into the compiled Java code; but this adds an extra layer of complexity and implementing the <a id="id1411" class="indexterm"/>
<a id="id1412" class="indexterm"/>extension in Java is normally a far easier proposition!</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec106"/>Implementing an Android extension</h3></div></div></div><p>To implement the gyroscope <a id="id1413" class="indexterm"/>code for Android, we will need to edit the file <code class="literal">source\android\Gyroscope.java</code>. First we need to make a reference to the Java classes we'll be using; so change the list of import declarations at the top of the file to look like this:</p><div><pre class="programlisting">import com.ideaworks3d.marmalade.LoaderAPI;
import com.ideaworks3d.marmalade.LoaderActivity;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;</pre></div><p>The first two imports allow us access to some helper functions that provide access to things such as the application's main <code class="literal">Activity</code> class (all applications in Android need to be derived from this base class). We'll need this to access some system resources.</p><p>The remaining imports are for the parts of the Android SDK that we will need to use to access the gyroscope data.</p><p>The EDK system has generated a Java class called <code class="literal">Gyroscope</code> that contains stubs for all the methods we need to implement. We will need to alter the class definition slightly, though, as we need to implement some methods that will receive gyroscope updates. Change the class definition as follows:</p><div><pre class="programlisting">class Gyroscope implements SensorEventListener</pre></div><p>
<code class="literal">SensorEventListener</code> is a Java interface that our class must implement in order to receive sensor events (in our case, gyroscope data).</p><p>We'll also add some member variables for caching the gyroscope values and a flag that we'll use to handle the fact that some Android devices return gyroscope values in degrees per second rather than radians per second. Add the following code to the bottom of the class definition:</p><div><pre class="programlisting">// Cached gyroscope values
private float x;
private float y;
private float z;
  
// Are the results in degrees/s or radians/s
private boolean mUsesDegrees;</pre></div><p>Before we start implementing the EDK itself, we'll add a couple of private helper functions to allow us to access the Android <code class="literal">SensorManager</code> and gyroscope <code class="literal">Sensor</code> instances that will allow us to retrieve the current gyroscope data. Add the following two methods at the beginning<a id="id1414" class="indexterm"/> of the class definition:</p><div><pre class="programlisting">// Helper function for accessing the Android SensorManager
private SensorManager GetSensorManager()
{
   Context lContext = (Context) LoaderActivity.m_Activity;
   SensorManager lSensorManager = (SensorManager)
      lContext.getSystemService(Context.SENSOR_SERVICE);
   return lSensorManager;
}

// Helper function for accessing the Android Gyroscope Sensor
private Sensor GetGyroscopeSensor()
{
   SensorManager lSensorManager = GetSensorManager();
   if (lSensorManager == null)
      return null;

   Sensor lGyroscope =
      lSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
   return lGyroscope;
}</pre></div><p>The <code class="literal">GetSensorManager</code> method<a id="id1415" class="indexterm"/> accesses the global <code class="literal">SensorManager</code> instance by using the main <code class="literal">Context</code> class of the Marmalade application. We do this using Marmalade's <code class="literal">LoaderActivity</code> class<a id="id1416" class="indexterm"/> that contains a member variable that is a reference to the main Android SDK <code class="literal">Activity</code> class instance. This reference can then be cast into a reference to a <code class="literal">Context</code> instance, since <code class="literal">Activity</code> derives from <code class="literal">Context</code>.</p><p>Once we have the <code class="literal">Context</code> reference, we use it to obtain a reference to the Android <code class="literal">SensorManager</code> class that is responsible for controlling input devices, including the gyroscope. If no reference is available, a <code class="literal">null</code> reference will be returned.</p><p>The <code class="literal">GetGyroscopeSensor</code> method<a id="id1417" class="indexterm"/> lets us check for the presence of a gyroscope by requesting the <code class="literal">SensorManager</code> class for the default gyroscope handler. If a suitable handler is not found (that is, a return value of <code class="literal">null</code>), there is no gyroscope hardware available on this device.</p><p>Now we can start implementing the API by looking at the<a id="id1418" class="indexterm"/> <code class="literal">GyroscopeSupported</code> method. This function needs to return <code class="literal">true</code> only if the device has gyroscope hardware. We can do this as follows:</p><div><pre class="programlisting">public boolean GyroscopeSupported()
{
   Sensor lSensor = GetGyroscopeSensor();
   return lSensor != null;
}</pre></div><p>It is now time to implement the function that will allow us to start receiving gyroscope data. Find the <code class="literal">GyroscopeStart</code> method<a id="id1419" class="indexterm"/> and change it to the following code snippet:</p><div><pre class="programlisting">public void GyroscopeStart()
{
  x = 0.0f;
  y = 0.0f;
  z = 0.0f;
  mUsesDegrees = false;
  
  Sensor lGyroscope = GetGyroscopeSensor();
  if (lGyroscope != null)
  {
    mUsesDegrees = lGyroscope.getMaximumRange() &gt; 100;
    GetSensorManager().registerListener(this, lGyroscope,
                  SensorManager.SENSOR_DELAY_FASTEST);
  }
}</pre></div><p>In this method we <a id="id1420" class="indexterm"/>start by ensuring that the cached gyroscope values are zero and we assume that the device will return values in radians per second. We then obtain the gyroscope's <code class="literal">Sensor</code> class instance using our private<a id="id1421" class="indexterm"/> <code class="literal">GetGyroscopeSensor</code> method.</p><p>To determine whether this device returns values in degrees or radians, we look at the maximum range value of the gyroscope sensor. We set the <code class="literal">mUsesDegrees</code> member variable to <code class="literal">true</code> if the maximum range is greater than 100, as there does not appear to be any more robust way of determining this.</p><p>We then set our class instance to be a listener for gyroscope data. Periodically, the<a id="id1422" class="indexterm"/> <code class="literal">onSensorChanged</code> method (which we have yet to implement) will be called with new gyroscope values.</p><p>Next we will implement the<a id="id1423" class="indexterm"/> <code class="literal">GyroscopeStop</code> function, which should look like this:</p><div><pre class="programlisting">public void GyroscopeStop()
{
  SensorManager lSensorManager = GetSensorManager();
  if (lSensorManager != null)
  {
    lSensorManager.unregisterListener(this);
  }
  
  x = 0.0f;
  y = 0.0f;
  z = 0.0f;
}</pre></div><p>Yet again we obtain the <code class="literal">SensorManager</code> class <a id="id1424" class="indexterm"/>reference and tell it that we no longer want to receive gyroscope data. We also clear the cached gyroscope values just in case our code tries to access them while the gyroscope hardware is not active.</p><p>The next three methods <a id="id1425" class="indexterm"/>we need to implement are those that return the cached gyroscope values. These are easy to implement and should look like this:</p><div><pre class="programlisting">public float GyroscopeGetX()
{
  return x;
}

public float GyroscopeGetY()
{
  return y;
}

public float GyroscopeGetZ()
{
  return z;
}</pre></div><p>We are now almost finished. All that is left to do is implement the listener methods that are part of the <code class="literal">SensorEventListener</code> interface<a id="id1426" class="indexterm"/> that we have derived the <code class="literal">Gyroscope</code> class<a id="id1427" class="indexterm"/> from. Add the following code after the<a id="id1428" class="indexterm"/> <code class="literal">GyroscopeGetZ</code> method.</p><div><pre class="programlisting">public void onAccuracyChanged(Sensor aSensor, int aAccuracy) 
{
}

public void onSensorChanged(SensorEvent aEvent) 
{
  if (aEvent.accuracy != SensorManager.SENSOR_STATUS_UNRELIABLE)
  {
    x = aEvent.values[0];
    y = aEvent.values[1];
    z = aEvent.values[2];

    if (mUsesDegrees)
    {
      x = (x * 3.14159267f) / 180.0f;
      y = (y * 3.14159267f) / 180.0f;
      z = (z * 3.14159267f) / 180.0f;
    }
  }
}</pre></div><p>The <code class="literal">onAccuracyChanged</code> method <a id="id1429" class="indexterm"/>is left empty since it must be implemented to satisfy the interface. The <code class="literal">onSensorChanged</code> method<a id="id1430" class="indexterm"/> is important, though, as this will receive the new gyroscope input values. We first check to see if the passed in <code class="literal">SensorEvent</code> contains reliable data (the device itself will determine what constitutes reliable data); then, we just pull out the new gyroscope values and store them in our member variables.</p><p>If we determined that the device is returning values in degrees per second, we do a quick conversion to radians to ensure that our extension always returns consistent values.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec107"/>Building an Android extension</h3></div></div></div><p>Our Android<a id="id1431" class="indexterm"/> extension code is now ready to be built and this is even simpler than it was with the Windows version. All we have to do is open Windows Explorer and navigate to the <code class="literal">Gyroscope</code> directory, and double-click first the <code class="literal">Gyroscope_android_java.mkb</code> file and then the <code class="literal">Gyroscope_android.mkb</code> file. The first MKB file will build the Java code, while the second will build the C++ code that will be called from our project code and that will in turn call the Java code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec151"/>Making an iOS extension</h2></div></div></div><p>Building an EDK<a id="id1432" class="indexterm"/>
<a id="id1433" class="indexterm"/> extension for iOS is a little more involved as it requires us to have access to the Apple iOS SDK and therefore an Apple Mac.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec108"/>Installing the required software for iOS development</h3></div></div></div><p>Firstly, you will need to download <a id="id1434" class="indexterm"/>the iOS SDK that is bundled together with Apple's XCode development environment. Head over to the following web page, which will contain a link to open the Mac App Store where the latest version of XCode can be downloaded:</p><p>
<a class="ulink" href="https://developer.apple.com/xcode/index.php">https://developer.apple.com/xcode/index.php</a>
</p><p>Once XCode has downloaded and you have installed it, you will then need to download the Marmalade SDK in its Mac OS X incarnation. Head over to the Marmalade website at the following URL, log in, and download the Mac version of Marmalade.</p><p>
<a class="ulink" href="https://www.madewithmarmalade.com/downloads">https://www.madewithmarmalade.com/downloads</a>
</p><p>Install the Marmalade <a id="id1435" class="indexterm"/>SDK to the default location. If you only have a single Marmalade license, you will need to use the Marmalade website to release the license from your PC so you can use it on the Mac. Refer to <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Marmalade">Chapter 1</a>, <em>Getting Started with Marmalade</em>, of this book for more information on how to do this.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec109"/>Creating an iOS extension</h3></div></div></div><p>Unsurprisingly, we <a id="id1436" class="indexterm"/>
<a id="id1437" class="indexterm"/>create the files needed for the iOS Extension in a similar manner to the Windows and Android extensions. Just right-click on the <code class="literal">Gyroscope.s4e</code> file and select the menu option <strong>Build iPhone Extension</strong>.</p><p>Just two new files will be created for the iOS extension. These are <code class="literal">Gyroscope_iphone.mkb</code>, which is the MKB file that we will use to build the extension code, and <code class="literal">source\iphone\Gyroscope_platform.mm</code>, which contains the auto-generated stubs for our API functions.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec110"/>Implementing an iOS extension</h3></div></div></div><p>To implement the<a id="id1438" class="indexterm"/> iOS version of the Gyroscope extension, we need to edit the <code class="literal">Gyroscope_platform.mm</code> file. This file is an Objective-C source file that also allows us to use C and C++ code in the same file. The function stubs are all standard C-style functions, but we can still make use of Objective-C classes and features within them.</p><p>On iOS, we use an Objective-C class called <code class="literal">CMMotionManager</code> <a id="id1439" class="indexterm"/>to gain access to gyroscope data, so we first need to let our code know about this class by changing the list of included files as follows:</p><div><pre class="programlisting">#include &lt;CoreMotion/CoreMotion.h&gt;
#include "Gyroscope_internal.h"</pre></div><p>We'll also declare a global pointer to a <code class="literal">CMMotionManager</code> instance that we will use throughout the rest of our code. Add the following line after the include files:</p><div><pre class="programlisting">CMMotionManager* gpMotionManager = nil;</pre></div><p>We'll need to allocate an instance of this class before we can access the gyroscope. Luckily, the EDK build script has generated a function called <code class="literal">GyroscopeInit_platform</code> that is automatically called for us when we use the extension in our project, so this will make a good place to allocate a new <code class="literal">CMMotionManager</code> instance, as shown in the following code:</p><div><pre class="programlisting">s3eResult GyroscopeInit_platform()
{
  gpMotionManager = [[CMMotionManager alloc] init];
  
  return S3E_RESULT_SUCCESS;
}</pre></div><p>We also need to<a id="id1440" class="indexterm"/> free the instance when our application is terminated and once again the EDK build script has come to our rescue with the function <code class="literal">GyroscopeTerminate_platform</code>. We need to modify this function so that it stops the gyroscope, if it is still active, and then releases the <code class="literal">CMMotionManager</code> instance. Here's the completed function:</p><div><pre class="programlisting">void GyroscopeTerminate_platform()
{
  GyroscopeStop_platform();
  [gpMotionManager release];
}</pre></div><p>The rest of the implementation is actually surprisingly easy, as the <code class="literal">CMMotionManager</code> class works in a very similar manner to the API we have chosen for the extension. We'll start with checking to see if gyroscope hardware is available. The <code class="literal">GyroscopeSupported_platform</code> function looks like this:</p><div><pre class="programlisting">bool GyroscopeSupported_platform()
{
    return gpMotionManager.gyroAvailable;
}</pre></div><p>Starting and stopping the gyroscope hardware is also little more than calling a method of the <code class="literal">CMMotionManager</code> class. For safety we wrap these calls with further checks to make sure the gyroscope is available and not already started or stopped.</p><div><pre class="programlisting">void GyroscopeStart_platform()
{
  if (gpMotionManager.gyroAvailable &amp;&amp; !gpMotionManager.gyroActive)
  {
    [gpMotionManager startGyroUpdates];
  }
}

void GyroscopeStop_platform()
{
  if (gpMotionManager.gyroAvailable &amp;&amp; gpMotionManager.gyroActive)
  {
    [gpMotionManager stopGyroUpdates];
  }
}</pre></div><p>The only thing left to <a id="id1441" class="indexterm"/>do is get hold of the current gyroscope input values. The <code class="literal">CMMotionManager</code> class <a id="id1442" class="indexterm"/>contains a property called <code class="literal">gyroData</code> of class <code class="literal">CMGyroData</code>, which in turn contains a <code class="literal">CMRotationRate</code> property<a id="id1443" class="indexterm"/> called, funnily enough, <code class="literal">rotationRate</code> that holds the current gyroscope data.</p><p>The following code shows the implementation for getting hold of the gyroscope data for the x axis. How to obtain the y and z axes values should be fairly obvious from this!</p><div><pre class="programlisting">float GyroscopeGetX_platform()
{
  CMGyroData* lpGyroData = [gpMotionManager gyroData];
  if (lpGyroData)
  {
    CMRotationRate lpRotRate = [lpGyroData rotationRate];
    return lpRotRate.x;
  }
  else
  {
    return 0.0f;
  }
}</pre></div><p>There is one final thing we have to do before we can build the extension, and that is to tell the EDK build tools that we need to include the iOS SDK framework <code class="literal">CoreMotion</code>, as this contains the code for the<a id="id1444" class="indexterm"/> <code class="literal">CMMotionManager</code> class.</p><p>To add a framework to our extensions, we must edit the<a id="id1445" class="indexterm"/> <code class="literal">Gyroscope.mkf</code> file. Look for the <code class="literal">deployments</code> section for iOS towards the bottom of the file (Marmalade refers to it as the "iphone platform" for legacy reasons) and add the following line to it:</p><div><pre class="programlisting">iphone-link-opts="-framework CoreMotion"</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec111"/>Building an iOS extension</h3></div></div></div><p>So far, all of the <a id="id1446" class="indexterm"/>previous steps for creating an iOS extension can be done equally well on Windows or Mac, but this final step absolutely requires us to use a Mac.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>We need to ensure the Mac has access to the entire <code class="literal">Gyroscope</code> directory. How you achieve this is up to you, but a good way is to share the <code class="literal">Gyroscope</code> directory out on your development Windows PC and then access this share on the Mac. This way the code is built on the Mac but all the compiled files are already in the correct place on your Windows development machine.</p></div></div><p>To build the extension you first need to open a Mac terminal window. Make the <code class="literal">Gyroscope</code> directory<a id="id1447" class="indexterm"/> the current directory in the terminal window and then enter the following command line:</p><div><pre class="programlisting">mkb Gyroscope_iphone.mkb –arm</pre></div><p>This will build the <a id="id1448" class="indexterm"/>extension and our work on the Mac is done. Simple, but kind of annoying that we only needed to execute one command, isn't it?</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec63"/>Using the Gyroscope extension</h1></div></div></div><p>We've now seen how to <a id="id1449" class="indexterm"/>create and build extension modules for Windows, Android, and iOS, but how do we make use of them in our Marmalade projects?</p><p>It's actually surprisingly easy. All we have to do is reference our extension in the project MKB file's <code class="literal">subprojects</code> section (the easiest way to do this is to provide a relative path to the <code class="literal">Gyroscope</code> directory from the main project directory), just as we would with any normal code module, and then include the auto-generated <code class="literal">Gyroscope.h</code> header file so we can call the extension functions.</p><p>The only thing to bear in mind is that because an extension may not have been created for every platform we wish to target, we must make sure the extension is available for use before we call any of its functions. This is easily done by using the <code class="literal">GyroscopeAvailable</code> function <a id="id1450" class="indexterm"/>that is automatically generated for us by the EDK build scripts. If this function returns <code class="literal">S3E_TRUE</code>, the extension is available for use. If it returns <code class="literal">S3E_FALSE</code>, any call to an extension function will fire an assert but will otherwise do nothing.</p><p>There are also no special steps required for building or deploying our application, even on Android, where any code written in Java needs to be supplied in a JAR file. The deployment tool will automatically add any required extension files to the install package without us having to do a thing.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec64"/>Example code</h1></div></div></div><p>The following sections detail the code samples that accompany this chapter.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec152"/>The Gyroscope project</h2></div></div></div><p>This project contains the <a id="id1451" class="indexterm"/>complete source code for the Gyroscope extension developed throughout the course of this chapter. Compiled versions of the extension have also been included so you can build the other example projects for this chapter without having to first build the extension itself.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec153"/>The GyroTest project</h2></div></div></div><p>The GyroTest project<a id="id1452" class="indexterm"/> is a simple example that makes use of the Gyroscope extension. It demonstrates how to include the Gyroscope extension into a project, how to check if the extension is available, and then how to call the extension function if it is available.</p><p>The sample will be displayed on screen whether or not gyroscope support is available. If it is, the raw gyroscope values will also be displayed on screen.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec154"/>The Skiing project</h2></div></div></div><p>Our final update to the <a id="id1453" class="indexterm"/>Skiing project sees it make use of the Gyroscope extension developed in this chapter as another possible control method.</p><p>As with the other input methods in the game, a class called <a id="id1454" class="indexterm"/> <code class="literal">GyroscopeManager</code> has been created, which wraps up the Gyroscope extension. This then keeps all use of the extension functions in a single source file, which makes it easier to update should we ever change the API of the extension in any way.</p><p>No matter how still the device is, even if left lying on a stable surface, the gyroscope values will always have a certain amount of jitter. The <code class="literal">GyroscopeManager</code> class deals with this by maintaining a filtered version of the gyroscope inputs that are used to control the skier in the game.</p><p>In every update of the main game loop, a new filtered value for each gyroscope axis is calculated by adding a percentage of the difference between the current filtered value and the new raw value for each axis to the current filtered value. This results in the smaller effects of jitter mostly being ignored without losing the larger intentional gyroscope inputs from the player.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec65"/>Summary</h1></div></div></div><p>In this chapter we've looked at how to use the Extensions Development Kit to extend the functionality of Marmalade. As you can see, it is relatively easy to create an extension that can make use of the APIs available on each of the platforms currently supported by the EDK.</p><p>The Gyroscope extension is a good example of supporting a hardware feature that hasn't yet been exposed in the main Marmalade SDK, but extensions can also come in extremely handy if you want to use any third party libraries that may have been created directly for a particular platform using its native SDK.</p><p>As this book draws to a close, you should now have a good grasp of the power of the Marmalade SDK and will hopefully be jumping at the opportunity of developing a game and launching it on a number of extremely popular platforms. Happy coding and best of luck writing the next big gaming phenomenon!</p></div></body></html>