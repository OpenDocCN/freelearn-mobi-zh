<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Detecting Touchscreen Gestures"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Detecting Touchscreen Gestures</h1></div></div></div><p>Until now, the apps we created have used <code class="literal">OnClickListeners</code> to detect user input. However, Android handsets are capable of handling sophisticated touchscreen gestures. These inputs are picked up with an <code class="literal">OnTouchListener</code> and then managed with a <code class="literal">GestureDetector</code>. These detectors and their own listeners are capable of recognizing several of the simplest and most<a id="id186" class="indexterm"/> commonly used gestures, such as <span class="strong"><strong>long presses</strong></span>, <span class="strong"><strong>double-taps</strong></span>, and <span class="strong"><strong>flings</strong></span>. At the heart of all touchscreen events is the <code class="literal">MotionEvent</code> class, which <a id="id187" class="indexterm"/>handles the individual elements of a gesture, such<a id="id188" class="indexterm"/> as when and where a finger is placed or removed from the screen or view. This class provides numerous classes for querying these events <a id="id189" class="indexterm"/>and, thus, for constructing custom gestures of our own.</p><p>To see how to implement gestures in our Ancient Britain app, we will add a feature that allows the user to view a small gallery of images within the same <code class="literal">ImageView</code> by swiping the view.</p><p>In this chapter, we will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add a <code class="literal">GestureDetector</code> to a view</li><li class="listitem" style="list-style-type: disc">Add an <code class="literal">OnTouchListener</code> and an <code class="literal">OnGestureListener</code></li><li class="listitem" style="list-style-type: disc">Detect and refine fling gestures</li><li class="listitem" style="list-style-type: disc">Use the DDMS Logcat to observe the <code class="literal">MotionEvent</code> class</li><li class="listitem" style="list-style-type: disc">Edit the Logcat filter configuration</li><li class="listitem" style="list-style-type: disc">Simplify code with a <code class="literal">SimpleOnGestureListener</code></li><li class="listitem" style="list-style-type: disc">Add a <code class="literal">GestureDetector</code> to an Activity</li><li class="listitem" style="list-style-type: disc">Edit the Manifest to control launch behavior</li><li class="listitem" style="list-style-type: disc">Hide UI elements</li><li class="listitem" style="list-style-type: disc">Create a splash screen</li><li class="listitem" style="list-style-type: disc">Lock screen orientation</li></ul></div><div class="section" title="Adding a GestureDetector to a view"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Adding a GestureDetector to a view</h1></div></div></div><p>Together, <code class="literal">view.GestureDetector</code> and <code class="literal">view.View.OnTouchListener</code> are all that are required to<a id="id190" class="indexterm"/> provide our <code class="literal">ImageView</code> with gesture functionality. The listener contains an <code class="literal">onTouch()</code> callback that relays each <code class="literal">MotionEvent</code> to the detector. We are going to program the large <code class="literal">ImageView</code> so that it can display a small gallery of related pictures that can be accessed by swiping left or right on the image.</p><p>There are two steps to this task as, before we implement our gesture detector, we need to provide the data for it to work on.</p><div class="section" title="Adding the gallery data"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Adding the gallery data</h2></div></div></div><p>As this<a id="id191" class="indexterm"/> app is for demonstration and learning purposes, and so we can progress as quickly as possible, we will only provide extra images for one or two of the ancient sites in the project. Here is how it's done:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the Ancient Britain project.</li><li class="listitem">Open the <code class="literal">MainData.java</code> file.</li><li class="listitem">Add the following arrays:<div class="informalexample"><pre class="programlisting">static Integer[] hengeArray = {R.drawable.henge_large, R.drawable.henge_2, R.drawable.henge_3, R.drawable.henge_4};
static Integer[] horseArray = {};
static Integer[] wallArray = {R.drawable.wall_large, R.drawable.wall_2};
static Integer[] skaraArray = {};
static Integer[] towerArray = {};

static Integer[][] galleryArray = {hengeArray, horseArray, wallArray, skaraArray, towerArray};</pre></div></li><li class="listitem">Either download the project files from the Packt website or find four of your own images (around 640 x 480 px). Name them <code class="literal">henge_2</code>, <code class="literal">henge_3</code>, <code class="literal">henge_4,</code> and <code class="literal">wall_2</code> and place them in your <code class="literal">res/drawable</code> directory.</li></ol></div><p>This is all very straightforward, and the code that will accompany it allows you to have individual arrays of any length. This is all we need to add to our gallery data. Now, we need to code our <code class="literal">GestureDetector</code> and <code class="literal">OnTouchListener</code>.</p></div><div class="section" title="Adding the GestureDetector"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec24"/>Adding the GestureDetector</h2></div></div></div><p>Along <a id="id192" class="indexterm"/>with the <code class="literal">OnTouchListener</code> that we will define for our <code class="literal">ImageView</code>, the GestureDetector has its own listeners. Here we will use <code class="literal">GestureDetector.OnGestureListener</code> to detect a fling gesture and collect the <code class="literal">MotionEvent</code> that describe it.</p><p>Follow these steps to program your <code class="literal">ImageView</code> to respond to fling gestures:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">DetailActivity.java</code> file.</li><li class="listitem">Declare the following class fields:<div class="informalexample"><pre class="programlisting">private static final int MIN_DISTANCE = 150;
private static final int OFF_PATH = 100;
private static final int VELOCITY_THRESHOLD = 75;
private GestureDetector detector;
View.OnTouchListener listener;
private int ImageIndex;</pre></div></li><li class="listitem">In the <code class="literal">onCreate()</code> method assigns both the <code class="literal">detector</code> and <code class="literal">listener</code> like this:<div class="informalexample"><pre class="programlisting">detector = new GestureDetector(this, new GalleryGestureDetector());
listener = new View.OnTouchListener() {

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return detector.onTouchEvent(event);
    }
};</pre></div></li><li class="listitem">Beneath this, add the following line:<div class="informalexample"><pre class="programlisting">ImageIndex = 0;</pre></div></li><li class="listitem">Beneath the line <code class="literal">detailImage = (ImageView) findViewById(R.id.detail_image);</code>, add the following line:<div class="informalexample"><pre class="programlisting">detailImage.setOnTouchListener(listener);</pre></div></li><li class="listitem">Create the following inner class:<div class="informalexample"><pre class="programlisting">class GalleryGestureDetector implements GestureDetector.OnGestureListener { }</pre></div></li><li class="listitem">Before dealing with the errors this generates, add the following field to the class:<div class="informalexample"><pre class="programlisting">private int item;
{
    item = MainActivity.currentItem;
}</pre></div></li><li class="listitem">Click anywhere on the line registering the error and press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span>. Then select <span class="strong"><strong>Implement Methods</strong></span>, making sure that you have the <span class="strong"><strong>Copy JavaDoc</strong></span> and <span class="strong"><strong>Insert @Override</strong></span> boxes checked.<div class="mediaobject"><img src="graphics/B04321_05_01.jpg" alt="Adding the GestureDetector"/></div></li><li class="listitem">Complete<a id="id193" class="indexterm"/> the <code class="literal">onDown()</code> method like this:<div class="informalexample"><pre class="programlisting">@Override
public boolean onDown(MotionEvent e) {
    return true;
}</pre></div></li><li class="listitem">Fill in the <code class="literal">onShowPress()</code> method:<div class="informalexample"><pre class="programlisting">@Override
public void onShowPress(MotionEvent e) {
    detailImage.setElevation(4);
}</pre></div></li><li class="listitem">Then fill in the <code class="literal">onFling()</code> method:<div class="informalexample"><pre class="programlisting">@Override
public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) {
  if (Math.abs(event1.getY() - event2.getY()) &gt; OFF_PATH)
    return false;

  if (MainData.galleryArray[item].length != 0) {
    // Swipe left
    if (event1.getX() - event2.getX() &gt; MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; VELOCITY_THRESHOLD) {
        ImageIndex++;
        if (ImageIndex == MainData.galleryArray[item].length) ImageIndex = 0;
          detailImage.setImageResource(MainData.galleryArray[item][ImageIndex]);
    } else {
      // Swipe right
      if (event2.getX() - event1.getX() &gt; MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; VELOCITY_THRESHOLD) {
        ImageIndex--;
        if (ImageIndex &lt; 0) ImageIndex = MainData.galleryArray[item].length - 1;
        detailImage.setImageResource(MainData.galleryArray[item][ImageIndex]);
    }
  }
  }
  detailImage.setElevation(0);
    return true;
}</pre></div></li><li class="listitem">Test the project on an emulator or handset.</li></ol></div><p>The process<a id="id194" class="indexterm"/> of gesture detection in the preceding code begins when the <code class="literal">OnTouchListener</code> listener's <code class="literal">onTouch()</code> method is called. It then passes that <code class="literal">MotionEvent</code> to our gesture detector class, <code class="literal">GalleryGestureDetector</code>, which monitors motion events, sometimes stringing them together and timing them until one of the recognized gestures is detected. At this point, we can enter our own code to control how our app responds as we did here with the <code class="literal">onDown()</code>, <code class="literal">onShowPress()</code>, and <code class="literal">onFling()</code> callbacks. It is worth taking a quick look at these methods in turn.</p><p>It may seem, at the first glance, that the <code class="literal">onDown()</code> method is redundant; after all, it's the fling gesture that we are trying to catch. In fact, overriding the <code class="literal">onDown()</code> method and returning <code class="literal">true</code> from it is essential in all gesture detections as all the gestures begin with an <code class="literal">onDown()</code> event.</p><p>The purpose of the <code class="literal">onShowPress()</code> method may also appear unclear as it seems to do a little more than <code class="literal">onDown()</code>. As the <span class="strong"><strong>JavaDoc</strong></span> states, this method is handy for adding some form of feedback to the user, acknowledging that their touch has been received. The Material Design guidelines strongly recommend such feedback and here we have raised the view's elevation slightly.</p><p>Without including our own code, the <code class="literal">onFling()</code> method will recognize almost any movement across the bounding view that ends in the user's finger being raised, regardless of direction <a id="id195" class="indexterm"/>or speed. We do not want very small or very slow motions to result in action; furthermore, we want to be able to differentiate between vertical and horizontal movement as well as left and right swipes. The <code class="literal">MIN_DISTANCE</code> and <code class="literal">OFF_PATH</code> constants are in pixels and <code class="literal">VELOCITY_THRESHOLD</code> is in pixels per second. These values will need tweaking according to the target device and personal preference. The first MotionEvent argument in <code class="literal">onFling()</code> refers to the preceding <code class="literal">onDown()</code> event and, like any <code class="literal">MotionEvent</code>, its coordinates are available through its <code class="literal">getX()</code> and <code class="literal">getY()</code> methods.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The MotionEvent class contains dozens of useful classes for querying various event properties—for example, <code class="literal">getDownTime()</code>, which returns the time in milliseconds since the current <code class="literal">onDown()</code> event.</p></div></div><p>In this example, we used <code class="literal">GestureDetector.OnGestureListener</code> to capture our gesture. However, the GestureDetector has three such nested classes, the other two being <code class="literal">SimpleOnGestureListener</code> and <code class="literal">OnDoubleTapListener</code>. <code class="literal">SimpleOnGestureListener</code> provides a more convenient way to detect gestures as we only need to implement those methods that relate to the gestures we are interested in capturing. We will shortly edit our Activity so that it implements the <code class="literal">SimpleOnGestureListener</code> instead, allowing us to tidy our code and remove the four callbacks that we do not need. The reason for taking this detour, rather than applying the simple listener to begin with, was to get to see all of the gestures available to us through a gesture listener and demonstrate how useful JavaDoc comments can be, particularly if we are new to the framework. For example, take a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/B04321_05_02.jpg" alt="Adding the GestureDetector"/></div><p>Another very handy tool is the <span class="strong"><strong>Dalvik Debug Monitor Server</strong></span> (<span class="strong"><strong>DDMS</strong></span>), which allows us to see what is going on inside our apps while they are running. The workings of our gesture<a id="id196" class="indexterm"/> listener are a good<a id="id197" class="indexterm"/> place to do this as most of its methods operate invisibly. </p></div><div class="section" title="Viewing gesture activity with DDMS"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec25"/>Viewing gesture activity with DDMS</h2></div></div></div><p>To view<a id="id198" class="indexterm"/> the workings<a id="id199" class="indexterm"/> of our <code class="literal">OnGestureListener</code> with DDMS, we need to first create a tag to identify our messages and then a filter to view them. The following steps demonstrate how to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">DetailActivity.java</code> file.</li><li class="listitem">Declare the following constant:<div class="informalexample"><pre class="programlisting">private static final String DEBUG_TAG = "tag";</pre></div></li><li class="listitem">Add the following line inside the <code class="literal">onDown()</code> method:<div class="informalexample"><pre class="programlisting">Log.d(DEBUG_TAG, "onDown");</pre></div></li><li class="listitem">Add the line <code class="literal">Log.d(DEBUG_TAG, "onShowPress");</code> to the <code class="literal">onShowPress()</code> method and do the same for each of our <code class="literal">OnGestureDetector</code> methods.</li><li class="listitem">Add the following lines to the appropriate clauses in <code class="literal">onFling()</code>:<div class="informalexample"><pre class="programlisting">Log.d(DEBUG_TAG, "left");
Log.d(DEBUG_TAG, "right");</pre></div><p>Open the <span class="strong"><strong>Android DDMS</strong></span> pane from the <span class="strong"><strong>Android</strong></span> tab at the bottom of the window or by pressing <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>6</em></span>.</p><div class="mediaobject"><img src="graphics/B04321_05_03.jpg" alt="Viewing gesture activity with DDMS"/></div></li><li class="listitem">If <span class="strong"><strong>logcat</strong></span> is not visible, it can be opened with the icon to the right of the top-right drop-down menu.</li><li class="listitem">Click <a id="id200" class="indexterm"/>on <a id="id201" class="indexterm"/>this drop-down menu and select<span class="strong"><strong> Edit Filter Configuration</strong></span>.</li><li class="listitem">Complete the dialog as shown in the following screenshot:<div class="mediaobject"><img src="graphics/B04321_05_04.jpg" alt="Viewing gesture activity with DDMS"/></div></li><li class="listitem">You can now run the project on a handset or emulator and view, in the Logcat, which gestures are being triggered and how. Your output should resemble the one here:<div class="informalexample"><pre class="programlisting">02-17 14:39:00.990    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onDown
02-17 14:39:01.039    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onSingleTapUp
02-17 14:39:03.503    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onDown
02-17 14:39:03.601    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onShowPress
02-17 14:39:04.101    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onLongPress
02-17 14:39:10.484    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onDown
02-17 14:39:10.541    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onScroll
02-17 14:39:11.091    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onScroll
02-17 14:39:11.232    1430-1430/com.example.kyle.ancientbritain D/tag﹕ onFling
02-17 14:39:11.680    1430-1430/com.example.kyle.ancientbritain D/tag﹕ right</pre></div></li></ol></div><p>
<span class="strong"><strong>DDMS</strong></span> is an<a id="id202" class="indexterm"/> invaluable<a id="id203" class="indexterm"/> tool when it comes to debugging our apps and seeing what is going on beneath the hood. Once <a id="id204" class="indexterm"/>a <span class="strong"><strong>Log Tag</strong></span> has been defined in the code, we can then create <a id="id205" class="indexterm"/>a <span class="strong"><strong>filter</strong></span> for it so that we see only the messages we are interested in. The <code class="literal">Log</code> class contains several methods to report information based on its level of importance. We used <code class="literal">Log.d</code>, which stands for <span class="emphasis"><em>debug</em></span>. All these methods work with the same two parameters: <code class="literal">Log.[method](String tag, String message)</code>. The full list of these methods is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Log.v</code>: Verbose</li><li class="listitem" style="list-style-type: disc"><code class="literal">Log.d</code>: Debug</li><li class="listitem" style="list-style-type: disc"><code class="literal">Log.i</code>: Information</li><li class="listitem" style="list-style-type: disc"><code class="literal">Log.w</code>: Warning</li><li class="listitem" style="list-style-type: disc"><code class="literal">Log.e</code>: Error</li><li class="listitem" style="list-style-type: disc"><code class="literal">Log.wtf</code>: Unexpected error</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>It is worth noting that most debug messages will be ignored during the packaging for distribution except for the verbose messages; thus, it is essential to remove them before your final build.</p></div></div><p>Having seen a little more of the inner workings of our gesture detector and listener, we can now strip our code of unused methods by implementing <code class="literal">GestureDetector.SimpleOnGestureListener</code>.</p></div><div class="section" title="Implementing a SimpleOnGestureListener"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Implementing a SimpleOnGestureListener</h2></div></div></div><p>It is very<a id="id206" class="indexterm"/> simple to convert our gesture detector from one class of listener to another. All we <a id="id207" class="indexterm"/>need to do is change the class declaration and delete the unwanted methods. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">DetailActivity</code> file.</li><li class="listitem">Change the class declaration for our gesture detector class to the following:<div class="informalexample"><pre class="programlisting">class GalleryGestureDetector extends GestureDetector.SimpleOnGestureListener {</pre></div></li><li class="listitem">Delete the <code class="literal">onShowPress()</code>, <code class="literal">onSingleTapUp()</code>, <code class="literal">onScroll()</code>, and <code class="literal">onLongPress()</code> methods.</li></ol></div><p>This<a id="id208" class="indexterm"/> is all you need to <a id="id209" class="indexterm"/>do to switch to the <code class="literal">SimpleOnGestureListener</code>. We have now successfully constructed and edited a gesture detector to allow the user to browse a series of images.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>You will have noticed that there is no <code class="literal">onDoubleTap()</code> method in the gesture listener. Double-taps can, in fact, be handled with the third <code class="literal">GestureDetector</code> listener, <code class="literal">OnDoubleTapListener</code>, which operates in a very similar way to the other two. However, Google, in its UI guidelines, recommends that a long press should be used instead, whenever possible.</p></div></div><p>Before moving on to multitouch events, we will take a look at how to attach a <code class="literal">GestureDetector</code> listener to an entire Activity by adding a splash screen to our project. In the process, we will also see how to create a Full-Screen Activity and how to edit the <code class="literal">Maniftest</code> file so that our app launches with the splash screen.</p></div></div></div>
<div class="section" title="Adding a GestureDetector to an Activity"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Adding a GestureDetector to an Activity</h1></div></div></div><p>The method we have employed so far allows us to attach a <code class="literal">GestureDetector</code> listener to any view or views and this, of course, applies to <code class="literal">ViewGroups</code> such as <code class="literal">Layouts</code>. There are times when we may want to detect gestures to be applied to the whole screen. For this purpose, we <a id="id210" class="indexterm"/>will create a splash screen that can be dismissed with a long press.</p><p>There are two things we need to do before implementing the gesture detector: creating a layout and editing the Manifest file so that the app launches with our splash screen.</p><div class="section" title="Designing the splash screen layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Designing the splash screen layout</h2></div></div></div><p>The main<a id="id211" class="indexterm"/> difference between<a id="id212" class="indexterm"/> processing gestures for a whole Activity and an individual widget, is that we do not need an <code class="literal">OnTouchListener</code> as we can override the Activity's own <code class="literal">onTouchEvent()</code>. Here is how it is done:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new Blank Activity from the Project Explorer context menu called <code class="literal">SplashActivity.java</code>.</li><li class="listitem">The Activity wizard should have created an associated XML layout called <code class="literal">activity_splash.xml</code>. Open this and view it using the <span class="strong"><strong>Text</strong></span> tab.</li><li class="listitem">Remove <a id="id213" class="indexterm"/>all the <a id="id214" class="indexterm"/>padding properties from the root layout so that it looks similar to this:<div class="informalexample"><pre class="programlisting">&lt;RelativeLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.kyle.ancientbritain.SplashActivity"&gt;</pre></div><p>Here we will need an image to act as the background for our splash screen. If you have not downloaded the project files from the Packt website, find an image, roughly of the size and aspect of your target device's screen, upload it to the project drawable folder, and call it <code class="literal">splash</code>. The file I used is 480 x 800 px.</p><p>:</p><div class="mediaobject"><img src="graphics/B04321_05_05.jpg" alt="Designing the splash screen layout"/></div><p>
</p></li><li class="listitem">Remove the <code class="literal">TextView</code> that the wizard placed inside the layout and replace it with this <code class="literal">ImageView</code>:<div class="informalexample"><pre class="programlisting">&lt;ImageView
    android:id="@+id/splash_image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@drawable/splash"/&gt;</pre></div></li><li class="listitem">Create <a id="id215" class="indexterm"/>a <code class="literal">TextView</code> beneath this, such as the following:<div class="informalexample"><pre class="programlisting">&lt;TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true"
    android:layout_centerHorizontal="true"
    android:layout_marginBottom="40dp"
    android:gravity="center_horizontal"
    android:textAppearance="?android:attr/textAppearanceLarge"
    android:textColor="#fffcfcbd"/&gt;</pre></div></li><li class="listitem">Add<a id="id216" class="indexterm"/> the following text property:<div class="informalexample"><pre class="programlisting">android:text="Welcome to &lt;b&gt;Ancient Britain&lt;/b&gt;\npress and hold\nanywhere on the screen\nto start"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>To save time adding string resources to the <code class="literal">strings.xml</code> file, enter a hardcoded string such as the preceding one and heed the warning from the editor to have the string extracted for you like this:</p><div class="mediaobject"><img src="graphics/B04321_05_06.jpg" alt="Designing the splash screen layout"/></div></div></div></li></ol></div><p>There is nothing in this layout that we have not encountered before. We removed all the padding so that our splash image will fill the layout; however, you will see from the preview that this does not appear to be the case. We will deal with this next in our Java code, but we need to edit our <span class="strong"><strong>Manifest</strong></span> first so that the app gets launched with our <code class="literal">SplashActivity</code>.</p></div><div class="section" title="Editing the Manifest"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Editing the Manifest</h2></div></div></div><p>It is very simple to configure the <code class="literal">AndroidManifest</code> file so that an app will get launched with <a id="id217" class="indexterm"/>whichever Activity we choose; the way it does so is with an intent. While we are editing the Manifest, we will also<a id="id218" class="indexterm"/> configure the display to fill the screen. Simply follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">res/values-v21/styles.xml</code> file and add the following style:<div class="informalexample"><pre class="programlisting">&lt;style name="SplashTheme" parent="android:Theme.Material.NoActionBar.Fullscreen"&gt;
&lt;/style&gt;</pre></div></li><li class="listitem">Open the <code class="literal">AndroidManifest.xml</code> file.</li><li class="listitem">Cut-and-paste the <code class="literal">&lt;intent-filter&gt;</code> element from <code class="literal">MainActivity</code> to <code class="literal">SplashActivity</code>.</li><li class="listitem">Include the following properties so that the entire <code class="literal">&lt;activity&gt;</code> node looks similar to this:<div class="informalexample"><pre class="programlisting">&lt;activity
    android:name=".SplashActivity"
    android:theme="@style/SplashTheme"
    android:screenOrientation="portrait"
    android:configChanges="orientation|screenSize"
    android:label="Old UK" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</pre></div></li></ol></div><p>We have encountered <span class="strong"><strong>themes</strong></span> and <span class="strong"><strong>styles</strong></span> before and, here, we took advantage of a built-in theme designed<a id="id219" class="indexterm"/> for <span class="strong"><strong>full screen activities</strong></span>. In many cases, we might have designed a landscape layout here but, as is often the case with splash screens, we locked the orientation with the <code class="literal">android:screenOrientation</code> property. </p><p>The <code class="literal">android:configChanges</code> line is not actually needed here, but is included as it is useful to know about it. Configuring any attribute such as this prevents the system from automatically reloading the Activity whenever the device is rotated or the screen size changed. Instead of the Activity restarting, the <code class="literal">onConfigurationChanged()</code> method is called. This was not needed here as the screen size and orientation were taken care of in the previous lines of code and this line was only included as a point of interest.</p><p>Finally, we changed the value of <code class="literal">android:label</code>. You may have noticed that, depending on the screen size of the device you are using, the name of our app is not displayed in full on the home screen or apps drawer. In such cases, when you want to use a shortened name for your app, it can be inserted here.</p><p>With <a id="id220" class="indexterm"/>everything else in place, we<a id="id221" class="indexterm"/> can get on with adding our gesture detector. This is not dissimilar to the way we did this before but, this time, we will apply the detector to the whole screen and will be listening for a long press, rather than a fling.</p></div><div class="section" title="Adding the GestureDetector"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Adding the GestureDetector</h2></div></div></div><p>Along with implementing a gesture detector for the entire Activity here, we will also take the final <a id="id222" class="indexterm"/>step in configuring our splash screen so that the image fills the screen, but maintains its aspect ratio. Follow these steps to complete the app splash screen. </p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">SplashActivity</code> file.</li><li class="listitem">Declare a <code class="literal">GestureDetector</code> as we did in the earlier exercise:<div class="informalexample"><pre class="programlisting">private GestureDetector detector;</pre></div></li><li class="listitem">In the <code class="literal">onCreate()</code> method, assign and configure our splash image and gesture detector like this:<div class="informalexample"><pre class="programlisting">ImageView imageView = (ImageView) findViewById(R.id.splash_image);
imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);

detector = new GestureDetector(this, new SplashListener());</pre></div></li><li class="listitem">Now, override the Activity's <code class="literal">onTouchEvent()</code> like this:<div class="informalexample"><pre class="programlisting">@Override
public boolean onTouchEvent(MotionEvent event) {
    this.detector.onTouchEvent(event);
    return super.onTouchEvent(event);
}</pre></div></li><li class="listitem">Create the following <code class="literal">SimpleOnGestureListener</code> class:<div class="informalexample"><pre class="programlisting">private class SplashListener extends GestureDetector.SimpleOnGestureListener {

    @Override
    public boolean onDown(MotionEvent e) {
        return true;
    }

    @Override
    public void onLongPress(MotionEvent e) {
        startActivity(new Intent(getApplicationContext(), MainActivity.class));
    }
}</pre></div></li><li class="listitem">Build and run the app on your phone or an emulator.</li></ol></div><p>The way<a id="id223" class="indexterm"/> a gesture detector is implemented across an entire Activity should be familiar by this point, as should the capturing of the long press event. The <code class="literal">ImageView.setScaleType(ImageView.ScaleType)</code> method is essential here; it is a very useful method in general. The <code class="literal">CENTER_CROP</code> constant scales the image to fill the view while maintaining the aspect ratio, cropping the edges when necessary.</p><div class="mediaobject"><img src="graphics/B04321_05_07.jpg" alt="Adding the GestureDetector"/></div><p>There are several similar <code class="literal">ScaleTypes</code>, such as <code class="literal">CENTER_INSIDE</code>, which scales the image to the maximum size possible without cropping it, and <code class="literal">CENTER</code>, which does not scale the image at all. The beauty of <code class="literal">CENTER_CROP</code> is that it means that we don't have to design a separate image for every possible aspect ratio on the numerous devices our apps will end up running on. Provided that we make allowances for very wide or very narrow screens by not including essential information too close to the edges, we only need to provide a handful of images of varying pixel densities to maintain the image quality on large, high-resolution devices.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>The scale type of <code class="literal">ImageView</code> can be set from within XML with <code class="literal">android:scaleType="centerCrop"</code>, for example.</p></div></div><p>You<a id="id224" class="indexterm"/> may have wondered why we did not use the built-in <span class="strong"><strong>Full-Screen Activity</strong></span> from the wizard; we could easily have done so. The template <a id="id225" class="indexterm"/>code the wizard creates for a Full-Screen Activity provides far more features than we needed for this exercise. Nevertheless, the template is worth taking a look at, especially if you want a fullscreen that brings the status bar and other components into view when the user interacts with the Activity.</p><p>That brings us to the end of this chapter. Not only have we seen how to make our apps interact with touch events and gestures, but also how to send debug messages to the IDE and make a Full-Screen Activity.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>We began this chapter by adding a <code class="literal">GestureDetector</code> to our project. We then edited it so that we could filter out meaningful touch events (swipe right and left, in this case). We went on to see how the <code class="literal">SimpleOnGestureListener</code> can save us a lot of time when we are only interested in catching a subset of the recognized gestures. We also saw how to use DDMS to pass debug messages during runtime and how, through a combination of XML and Java, the status and action bars can be hidden and the entire screen be filled with a single view or view group.</p><p>Next, we will explore how our apps can communicate with the user through the various forms of notification the framework provides. We will also see how to allow the user to add their own data to the app and configure some settings.</p></div></body></html>