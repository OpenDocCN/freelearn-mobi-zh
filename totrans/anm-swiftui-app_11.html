<html><head></head><body>
<div id="_idContainer161">
<h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-149"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.2.1">Animating an Elevator</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to the elevator project! </span><span class="koboSpan" id="kobo.3.2">In this one, we’re going to create a working elevator, complete with sounds, floor lights, a button, and even some images of people inside. </span><span class="koboSpan" id="kobo.3.3">We will control the elevator using timers that are available from the Swift timer class, as we have done in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">previous projects.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">To bring these elements together, we’ll create a data model using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.7.1"> protocol. </span><span class="koboSpan" id="kobo.7.2">Apple recommends making a data model as the place to store and process the data that the application uses. </span><span class="koboSpan" id="kobo.7.3">The data model is also separate from the app’s user interface, where the views are created. </span><span class="koboSpan" id="kobo.7.4">The reason to keep data and the UI separate is that this paradigm fosters modularity and testability. </span><span class="koboSpan" id="kobo.7.5">It’s easier to find bugs in your logic when the data is not mixed in with UI code. </span><span class="koboSpan" id="kobo.7.6">Once we have the data model set up, we can then publish that data anywhere in the app using publishing wrappers, as we will </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">see later.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Setting up a project and adding a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">Binding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1"> variable</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Assembling the elevator using images and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1"> view</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Putting people inside </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the elevator</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Creating a data model and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.21.1">ObservableObject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.22.1"> protocol</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Adding the data </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">model functions</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Adding the background, a button, and animating </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the doors</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Adding floor </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">indicator lights</span></span></li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">You can download the resources and finished project on </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.34.1">Setting up the project and adding a Binding variable</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Okay, let’s get started! </span><span class="koboSpan" id="kobo.35.2">As </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.36.1">always, we’ll create a new Xcode project (I’m going to call </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">mine </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Elevator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Next, in the GitHub repo, take </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.41.1">all the images from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">Chapter 11</span></strong></span><span class="koboSpan" id="kobo.43.1"> folder and drop them into the Asset Catalog. </span><span class="koboSpan" id="kobo.43.2">These images include </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">doorDrame</span></strong><span class="koboSpan" id="kobo.45.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">leftDoor</span></strong><span class="koboSpan" id="kobo.47.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">rightDoor</span></strong><span class="koboSpan" id="kobo.49.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">inside</span></strong><span class="koboSpan" id="kobo.51.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">man</span></strong><span class="koboSpan" id="kobo.53.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">man2</span></strong><span class="koboSpan" id="kobo.55.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">man3</span></strong><span class="koboSpan" id="kobo.57.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">man4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Then, drop the audio files – </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">doorsOpenClose</span></strong><span class="koboSpan" id="kobo.63.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">elevatorChime</span></strong><span class="koboSpan" id="kobo.65.1"> – into the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">Project Navigator.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Next, we’re going to need a</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.68.1"> new file where we can assemble the elevator and add the people, so create a new SwiftUI View file and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">ElevatorAndPeopleView</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">We only need one variable in this file, which will be the Binding variable. </span><span class="koboSpan" id="kobo.70.3">Let’s add it at the top, inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">ElevatorAndPeopleView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.72.1"> struct:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
    @Binding var doorsOpened: Bool</span></pre>
<p><span class="koboSpan" id="kobo.74.1">This variable will control the elevator doors opening </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">and closing.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Previews</span></strong><span class="koboSpan" id="kobo.78.1"> so that the code will build without errors. </span><span class="koboSpan" id="kobo.78.2">At the bottom of the file, alter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">Previews</span></strong><span class="koboSpan" id="kobo.80.1"> struct so that it looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
struct ElevatorAndPeopleView_Previews: PreviewProvider {
    static var previews: some View {
        ElevatorAndPeopleView(doorsOpened: 
          .constant(false), moveMouth: .constant(false))
    } </span></pre>
<p><span class="koboSpan" id="kobo.83.1">The code adds a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">false</span></strong><span class="koboSpan" id="kobo.85.1"> to both binding properties, and the project once again builds cleanly. </span></p>
<p><span class="koboSpan" id="kobo.86.1">We can now move on to building out </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the elevator.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.88.1">Assembling the elevator using images and the GeometryReader view</span></h1>
<p><span class="koboSpan" id="kobo.89.1">The next step is to use </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.90.1">some of the images from the Assets catalog and make an elevator. </span></p>
<p><span class="koboSpan" id="kobo.91.1">We’ll start by adding the inside part of the elevator, which we’ll do by adding the following code inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">body</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
 ZStack {
 GeometryReader { geo in
                }
        }</span></pre>
<p><span class="koboSpan" id="kobo.95.1">First, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">ZStack</span></strong><span class="koboSpan" id="kobo.97.1"> to hold all the views that will follow, and a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1"> view.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.102.1"> view is a container view that defines its content as a function of its own size and coordinate space. </span><span class="koboSpan" id="kobo.102.2">It’s a little bit like the other containers that we have used, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">VStack</span></strong><span class="koboSpan" id="kobo.104.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">HStack</span></strong><span class="koboSpan" id="kobo.106.1">, but the difference is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.108.1"> has more flexibility because of its proxy parameter, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">geo</span></strong><span class="koboSpan" id="kobo.110.1"> constant (which you can name whatever you want). </span></p>
<p><span class="koboSpan" id="kobo.111.1">This proxy will contain information about the container’s size and coordinate space, and we can pass that information to the child views inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.113.1">, which helps us precisely size and position its children relative to the container. </span><span class="koboSpan" id="kobo.113.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.115.1"> view also makes the views within it line up perfectly on all iPhone and iPad devices, whatever </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">their size.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">We’re going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.119.1"> to size and position all the parts of the elevator, as well as the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">people inside.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Next, let’s add the code that creates the elevator’s interior within </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">’s body:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
//MARK: - INSIDE ELEVATOR SCENE
    Image("inside").resizable()
      .frame(maxWidth: geo.size.width,
      maxHeight: geo.size.height)</span></pre>
<p><span class="koboSpan" id="kobo.125.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Image</span></strong><span class="koboSpan" id="kobo.127.1"> initializer adds the image called </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">inside</span></strong><span class="koboSpan" id="kobo.129.1"> to the scene, and then uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">frame</span></strong><span class="koboSpan" id="kobo.131.1"> modifier to set the size of this image to the maximum width and maximum height of the screen. </span><span class="koboSpan" id="kobo.131.2">It sets this </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.132.1">size using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">geo</span></strong><span class="koboSpan" id="kobo.134.1"> proxy constant we created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.136.1"> view. </span></p>
<p><span class="koboSpan" id="kobo.137.1">The previews now display the inside of </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">the elevator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<span class="koboSpan" id="kobo.139.1"><img alt="Figure 11.1: The inside of the elevator " src="image/B18674_11_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.140.1">Figure 11.1: The inside of the elevator</span></p>
<p><span class="koboSpan" id="kobo.141.1">Let’s continue assembling the elevator by adding doors next. </span><span class="koboSpan" id="kobo.141.2">The doors will have animations attached to them so that they slide open and close, and then later, we will add timers to them </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.142.1">so that they can operate automatically after an initial button press. </span><span class="koboSpan" id="kobo.142.2">So, continuing inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.144.1"> view, add this code for </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">the doors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
  //MARK: - ADD THE DOORS
  HStack {
      Image("leftDoor").resizable()
          .frame(maxWidth: geo.size.width)
          .offset(x: doorsOpened ? </span><span class="koboSpan" id="kobo.146.2">-geo.size.width / 2 : 4)
      Image("rightDoor").resizable()
          .frame(maxWidth: geo.size.width)
          .offset(x: doorsOpened ? </span><span class="koboSpan" id="kobo.146.3">geo.size.width / 2 : -4)
              }</span></pre>
<p><span class="koboSpan" id="kobo.147.1">We put the doors in </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">HStack</span></strong><span class="koboSpan" id="kobo.149.1"> because they need to be positioned side by side. </span><span class="koboSpan" id="kobo.149.2">The doors are sized using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">frame</span></strong><span class="koboSpan" id="kobo.151.1"> modifier and </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">geo</span></strong><span class="koboSpan" id="kobo.153.1"> proxy constant, just as we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">inside</span></strong><span class="koboSpan" id="kobo.155.1"> elevator image. </span><span class="koboSpan" id="kobo.155.2">Both doors also get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">offset</span></strong><span class="koboSpan" id="kobo.157.1"> modifier tacked on to them, which will position them on opposite sides of the screen, opening them up fully. </span></p>
<p><span class="koboSpan" id="kobo.158.1">The process to open and close the doors is handled by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">geo</span></strong><span class="koboSpan" id="kobo.160.1"> proxy constant. </span><span class="koboSpan" id="kobo.160.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.162.1"> property becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">true</span></strong><span class="koboSpan" id="kobo.164.1"> for the left door, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">geo</span></strong><span class="koboSpan" id="kobo.166.1"> proxy constant will move the door on the </span><em class="italic"><span class="koboSpan" id="kobo.167.1">x</span></em><span class="koboSpan" id="kobo.168.1">-axis, to the left and off the screen. </span><span class="koboSpan" id="kobo.168.2">The amount that the door moves is the width of the door divided by 2. </span><span class="koboSpan" id="kobo.168.3">The reason why the left door moves to the left and not the right is that we prefix the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">geo</span></strong><span class="koboSpan" id="kobo.170.1"> constant with a negative sign. </span><span class="koboSpan" id="kobo.170.2">When a negative value is used and an object is being offset on the </span><em class="italic"><span class="koboSpan" id="kobo.171.1">x</span></em><span class="koboSpan" id="kobo.172.1">-axis, that object will move to the left, whereas a positive value will move the object to </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the right.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.176.1"> property becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">false</span></strong><span class="koboSpan" id="kobo.178.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">offset</span></strong><span class="koboSpan" id="kobo.180.1"> modifier reverses the animation and the left </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">door closes.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">For the right door, we do the same thing, except a positive value is used for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">geo</span></strong><span class="koboSpan" id="kobo.184.1"> constant, which moves the door to the right along the </span><em class="italic"><span class="koboSpan" id="kobo.185.1">X</span></em><span class="koboSpan" id="kobo.186.1"> axis to open it. </span><span class="koboSpan" id="kobo.186.2">The values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">4</span></strong><span class="koboSpan" id="kobo.188.1"> and -</span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">4</span></strong><span class="koboSpan" id="kobo.190.1"> that are used for both doors are included to help keep the two doors snug with each other when they are in the </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">closed position.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">So far, this is what the scene looks like in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">ElevatorAndPeopleView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer155">
<span class="koboSpan" id="kobo.195.1"><img alt="Figure 11.2: The elevator doors " src="image/B18674_11_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.196.1">Figure 11.2: The elevator doors</span></p>
<p><span class="koboSpan" id="kobo.197.1">We have the elevator’s interior and doors </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.198.1">placed together, and we have the animation mechanism to operate the doors, but we won’t see any motion happening until we call this file inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">ContentView</span></strong><span class="koboSpan" id="kobo.200.1">, and we still have some more assembly </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">to do.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">Let’s put a frame around the outside of the elevator so that it will look like the actual elevator, and provide a place to add the elevator’s button. </span><span class="koboSpan" id="kobo.202.2">Add the following code just after the closing bracket of </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">HStack</span></strong><span class="koboSpan" id="kobo.204.1">, still within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
      Image("doorFrame").resizable()
          .frame(maxWidth: geo.size.width, maxHeight:
            geo.size.height)</span></pre>
<p><span class="koboSpan" id="kobo.208.1">Here, we are adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">doorFrame</span></strong><span class="koboSpan" id="kobo.210.1"> image to the scene, and as we want the frame to go around the entire elevator, we used the same code that we used for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">inside</span></strong><span class="koboSpan" id="kobo.212.1"> image – we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">geo</span></strong><span class="koboSpan" id="kobo.214.1"> proxy </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.215.1">constant again, and by setting the image at the maximum width and height, the door frame creates a nice border around the elevator doors. </span><span class="koboSpan" id="kobo.215.2">This is the result </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">so far:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer156">
<span class="koboSpan" id="kobo.217.1"><img alt="Figure 11.3: The elevator frame " src="image/B18674_11_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.218.1">Figure 11.3: The elevator frame</span></p>
<p><span class="koboSpan" id="kobo.219.1">Now, let’s add the animation code that will open and close the doors, and control the speed and delay of the doors when activated later in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">ContentView</span></strong><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">Its only one line of code, and it can be placed right after the closing bracket of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1"> view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
.animation(Animation.easeInOut.speed(0.09).delay(0.3),
  value: doorsOpened)</span></pre>
<p><span class="koboSpan" id="kobo.225.1">Here, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">animation</span></strong><span class="koboSpan" id="kobo.227.1"> modifier. </span><span class="koboSpan" id="kobo.227.2">Then, we pass in a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">0.09</span></strong><span class="koboSpan" id="kobo.229.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">speed</span></strong><span class="koboSpan" id="kobo.231.1"> function, which will control how fast the doors open and close. </span><span class="koboSpan" id="kobo.231.2">There’s also a slight </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">delay</span></strong><span class="koboSpan" id="kobo.233.1"> added of </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">0.3</span></strong><span class="koboSpan" id="kobo.235.1"> seconds, which will delay the door opening and closing just enough to keep things in sync with the floor lights, which we will add soon. </span></p>
<p><span class="koboSpan" id="kobo.236.1">We’re getting close to finishing using this file – the only parts left to add are the people images. </span><span class="koboSpan" id="kobo.236.2">Of course, you can</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.237.1"> put the people code into a separate file if you prefer, but since there isn’t a lot of code in this file, it will be fine to continue to work here. </span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.238.1">Putting people inside the elevator</span></h1>
<p><span class="koboSpan" id="kobo.239.1">We’ll be adding four</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.240.1"> characters into our elevator, Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">manOne</span></strong><span class="koboSpan" id="kobo.242.1"> image – add the following code right after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">frame</span></strong><span class="koboSpan" id="kobo.244.1"> modifier near the top of the file, inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1"> view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
  //MARK: - ADD THE PEOPLE
      Image("manOne")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width - 200, maxHeight:
          geo.size.height - 300)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: 0, y: 250)</span></pre>
<p><span class="koboSpan" id="kobo.248.1">What we are doing here is bringing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">manOne</span></strong><span class="koboSpan" id="kobo.250.1"> image into the scene and then adding the correct aspect ratio to the image. </span><span class="koboSpan" id="kobo.250.2">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">frame</span></strong><span class="koboSpan" id="kobo.252.1"> modifier to set the size for the image, but what’s different this time is that we use the proxy constant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.254.1"> to set the size dynamically; when the width and height of an image are set this way, the scene will proportionally scale up or down on all Apple devices to fit the various </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">screen sizes.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">I’m trimming off 200 and 300 points for the width and height values so that the image will fit nicely inside the elevator. </span><span class="koboSpan" id="kobo.256.2">Once we have the images sized and positioned the way we want, they will scale dynamically when they appear on different devices, so we do need to size and position </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">them initially.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">We will then add some </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">shadow</span></strong><span class="koboSpan" id="kobo.260.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">30</span></strong><span class="koboSpan" id="kobo.262.1"> points around the image on the </span><em class="italic"><span class="koboSpan" id="kobo.263.1">X</span></em><span class="koboSpan" id="kobo.264.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.265.1">Y</span></em><span class="koboSpan" id="kobo.266.1"> axes, which gives a nice depth of field for the man when placed inside the shiny metal elevator. </span><span class="koboSpan" id="kobo.266.2">And finally, we </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.267.1">offset the image on the </span><em class="italic"><span class="koboSpan" id="kobo.268.1">Y</span></em><span class="koboSpan" id="kobo.269.1"> axis so that the feet are on the floor of </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the elevator.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">This is how </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">manOne</span></strong><span class="koboSpan" id="kobo.273.1"> looks in </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">our elevator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<span class="koboSpan" id="kobo.275.1"><img alt="Figure 11.4: The first man " src="image/B18674_11_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">Figure 11.4: The first man</span></p>
<p><span class="koboSpan" id="kobo.277.1">Since we don’t have the animation hooked up yet, to open the door and see inside the elevator while we continue to work, you can simply comment out the door code, and the door images </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">will disappear.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">The code for the three remaining people is similar to what we’ve just added, so I’m going to add the other three</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.280.1"> images directly under the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">previous code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
      Image("manTwo")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width, maxHeight:
          geo.size.height - 290)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: 40, y: 230)
        .rotation3DEffect(Angle(degrees: 20), axis: (x: 0,
          y: -1, z: 0))
                
      Image("manThree")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width - 100, maxHeight:
          geo.size.height - 250)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: 130, y: 255)
                
      Image("manFour")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width - 0, maxHeight:
          geo.size.height - 280)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: -80, y: 265)</span></pre>
<p><span class="koboSpan" id="kobo.283.1">The code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">manTwo</span></strong><span class="koboSpan" id="kobo.285.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">manThree</span></strong><span class="koboSpan" id="kobo.287.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">manFour</span></strong><span class="koboSpan" id="kobo.289.1"> images are largely the same as the code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">manOne</span></strong><span class="koboSpan" id="kobo.291.1"> image, just with slightly different values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">frame</span></strong><span class="koboSpan" id="kobo.293.1"> modifier, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">offset</span></strong><span class="koboSpan" id="kobo.295.1"> modifier, and their positions in the elevator. </span></p>
<p><span class="koboSpan" id="kobo.296.1">Regarding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">manTwo</span></strong><span class="koboSpan" id="kobo.298.1"> code, I’m adding a rotation effect to this image because I want to turn this image a little bit toward the left, as he appears to be talking, and it looks a little bit better if we position him in the direction of the person on his right. </span><span class="koboSpan" id="kobo.298.2">This is accomplished with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">rotation3DEffect</span></strong><span class="koboSpan" id="kobo.300.1"> modifier; simply turning him </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">20</span></strong><span class="koboSpan" id="kobo.302.1"> degrees on the </span><em class="italic"><span class="koboSpan" id="kobo.303.1">Y</span></em><span class="koboSpan" id="kobo.304.1"> axis is enough</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.305.1"> to point him in the right direction of the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">other image.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Here is our elevator full </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">of people:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer158">
<span class="koboSpan" id="kobo.309.1"><img alt="Figure 11.5: The rest of the people " src="image/B18674_11_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">Figure 11.5: The rest of the people</span></p>
<p><span class="koboSpan" id="kobo.311.1">And that finishes off this file. </span><span class="koboSpan" id="kobo.311.2">We can now move on to creating the data model file and adding the necessary functions for the timers and </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">sound effects.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.313.1">Creating a data model and using the ObservableObject protocol</span></h1>
<p><span class="koboSpan" id="kobo.314.1">Let’s create a new file – although</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.315.1"> this time, choose the </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">Swift</span></strong><span class="koboSpan" id="kobo.317.1"> template file rather</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.318.1"> than the </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">SwiftUI View</span></strong><span class="koboSpan" id="kobo.320.1"> template – and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">DataModel</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">In this</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.323.1"> file, we will put the data that we can access from </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">ContentView</span></strong><span class="koboSpan" id="kobo.325.1"> later, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.327.1"> protocol. </span></p>
<p><span class="koboSpan" id="kobo.328.1">To use this protocol, we first need to import the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">SwiftUI framework:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
import SwiftUI</span></pre>
<p><span class="koboSpan" id="kobo.331.1">Next, we need a class to hold all the data, and we also need to make the class conform to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.333.1"> protocol, so let’s add that now. </span><span class="koboSpan" id="kobo.333.2">You can name the class anything you want, but many developers like to name the class the same name as the file it is in, so we will do the same, naming the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">class </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">DataModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
class DataModel: ObservableObject {
                                 }</span></pre>
<p><span class="koboSpan" id="kobo.338.1">Let’s understand what </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ObservableObject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1"> does.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">In previous projects, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">@State</span></strong><span class="koboSpan" id="kobo.344.1"> property to pass data to the views and display them to the user, but this is limited because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">@State</span></strong><span class="koboSpan" id="kobo.346.1"> property wrapper can only store values that control the states of a single view; we can’t make </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">@State</span></strong><span class="koboSpan" id="kobo.348.1"> properties and pass them around to other structs, as they work in only one struct. </span></p>
<p><span class="koboSpan" id="kobo.349.1">We also used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">@Binding</span></strong><span class="koboSpan" id="kobo.351.1"> property wrapper, which helped to re-establish the connection to other views or structs with a bidirectional link that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">@State</span></strong><span class="koboSpan" id="kobo.353.1"> property could not provide. </span><span class="koboSpan" id="kobo.353.2">However, this would not work globally to hold and pass data to all files in </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">So, what we need now is an object that can globally control all the app’s data and its states and update the views accordingly when there are any changes to the properties, either by user input or changes made by other means, such as downloads from a server or </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the web.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">This is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.359.1"> protocol </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">comes in.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.363.1"> protocol defines three distinct property wrappers: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.364.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">@StateObject</span></strong><span class="koboSpan" id="kobo.366.1"> property wrapper that listens for changes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.368.1"> and receives the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">new values</span></span></li>
<li><span class="koboSpan" id="kobo.370.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">@ObservedObject</span></strong><span class="koboSpan" id="kobo.372.1"> property wrapper that listens for changes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">@StateObject</span></strong><span class="koboSpan" id="kobo.374.1"> property and receives those </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">new values</span></span></li>
<li><span class="koboSpan" id="kobo.376.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">@Published</span></strong><span class="koboSpan" id="kobo.378.1"> property wrapper that reports all the changes to the system and publishes those changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">vi</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.380.1">ew app-wide</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.381.1">The advantage of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.383.1"> over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">@State</span></strong><span class="koboSpan" id="kobo.385.1"> property wrapper is, again, that we can </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.386.1">update more than one view with any changes, and the state can be checked from views anywhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Now, that’s a lot to take in, but it will become clearer as we build out the data model. </span><span class="koboSpan" id="kobo.388.2">We already have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">DataModel</span></strong><span class="koboSpan" id="kobo.390.1"> class created, and it conforms to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.392.1"> protocol – that’s the first step. </span><span class="koboSpan" id="kobo.392.2">Next, we want to declare the properties we need, prefixing</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.393.1"> them with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">@Published</span></strong><span class="koboSpan" id="kobo.395.1"> property wrapper so that they will hold the various data and states and be published to the views when needed. </span><span class="koboSpan" id="kobo.395.2">Let’s do that now by adding the following properties inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">DataModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
    @Published var doorsOpened = false
    @Published var floor1 = false
    @Published var floor2 = false
    @Published var goingUp = false
    @Published var doorOpenTimer: Timer? </span><span class="koboSpan" id="kobo.398.2">= nil
    @Published var chimesTimer: Timer? </span><span class="koboSpan" id="kobo.398.3">= nil
    @Published var doorSoundTimer: Timer? </span><span class="koboSpan" id="kobo.398.4">= nil</span></pre>
<p><span class="koboSpan" id="kobo.399.1">There are several properties here that hopefully are self-explanatory. </span><span class="koboSpan" id="kobo.399.2">The four Booleans will be used to let us know when the doors of the elevator are opened, whether floor 1 or floor 2 is the active</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.400.1"> floor, and whether the elevator is going up or going down. </span><span class="koboSpan" id="kobo.400.2">The timers will control the timing of the doors</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.401.1"> opening and closing, as well as when to play the floor chimes and when to play the door opening and </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">closing sounds.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">With the properties listed, we next need a way to access them from other parts of the app. </span><span class="koboSpan" id="kobo.403.2">This is done by going up the hierarchy to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Root</span></strong><span class="koboSpan" id="kobo.405.1"> view and injecting an instance of the data model there – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Root</span></strong><span class="koboSpan" id="kobo.407.1"> view is the entry point of the app, the point from which the app </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">starts up.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Let’s go into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">App.swift</span></strong><span class="koboSpan" id="kobo.411.1"> file in the Project navigator and create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">DataModel</span></strong><span class="koboSpan" id="kobo.413.1"> class there inside the struct, sending a reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">ContentView</span></strong><span class="koboSpan" id="kobo.415.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
@main
struct Elevator: App {
    @StateObject private var appData = DataModel()
        var body: some Scene {
        WindowGroup {
            ContentView(appData: appData)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.418.1">As I mentioned, this file is the entry point for our app, as denoted by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">@main</span></strong><span class="koboSpan" id="kobo.420.1"> wrapper at the top, and it creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">Root</span></strong><span class="koboSpan" id="kobo.422.1"> view window and takes care of creating all the objects we need for the app to start up. </span><span class="koboSpan" id="kobo.422.2">Since this file is at the top of the hierarchy, it’s the perfect place to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">DataModel</span></strong><span class="koboSpan" id="kobo.424.1"> instance and pass it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">Root</span></strong><span class="koboSpan" id="kobo.426.1"> view, </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">ContentView</span></strong><span class="koboSpan" id="kobo.428.1">, so it can be </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">available app-wide.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">DataModel</span></strong><span class="koboSpan" id="kobo.432.1"> instance is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">appData</span></strong><span class="koboSpan" id="kobo.434.1">, and it gets prefixed with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">@StateObject</span></strong><span class="koboSpan" id="kobo.436.1"> property wrapper – this wrapper will listen for changes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">@ObservableObject</span></strong><span class="koboSpan" id="kobo.438.1"> and receive any </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">new values.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">@StateObject</span></strong><span class="koboSpan" id="kobo.442.1"> property wrapper that we called </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">appData</span></strong><span class="koboSpan" id="kobo.444.1"> is injected into </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">ContentView</span></strong><span class="koboSpan" id="kobo.446.1"> by passing it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">ContentView</span></strong><span class="koboSpan" id="kobo.448.1"> initializer to, again, make the data in the data model available throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">Now, to complete the connection from </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.451.1">our data here, and from any view in the project, all we have to do is include an </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">@ObservedObject</span></strong><span class="koboSpan" id="kobo.453.1"> property inside every view that we want to have a connection to this</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.454.1"> model. </span><span class="koboSpan" id="kobo.454.2">The job of </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">@ObservedObject</span></strong><span class="koboSpan" id="kobo.456.1"> is to listen for changes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">@StateObject</span></strong><span class="koboSpan" id="kobo.458.1"> property and receive those new values so that it can update </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the views.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">Let’s now go into </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">ContentView</span></strong><span class="koboSpan" id="kobo.462.1"> and add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">@ObservedObject</span></strong><span class="koboSpan" id="kobo.464.1"> property to complete the bidirectional binding between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">AppData</span></strong><span class="koboSpan" id="kobo.466.1"> class, which holds all the data, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">ContentView</span></strong><span class="koboSpan" id="kobo.468.1">, which is in charge of displaying all of that data on a screen to a user. </span><span class="koboSpan" id="kobo.468.2">Add the following property to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">ContentView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> struct:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
struct ContentView: View {
    @ObservedObject var appData: DataModel
               •••••••
}</span></pre>
<p><span class="koboSpan" id="kobo.472.1">Now, we have an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">DataModel</span></strong><span class="koboSpan" id="kobo.474.1">, which will monitor all the data for us; if there are any changes to the data, </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">ObservedObject</span></strong><span class="koboSpan" id="kobo.476.1"> will know about it and update the </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">views accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">Also, if we create more files and need to access the data model from those new files, all we have to do is create another instance of the data model and use it in those files too, like we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">appData</span></strong><span class="koboSpan" id="kobo.480.1"> instance here, and they will have the same access and be updated with any changes </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">that occur.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">We have the instance of the data model ready to be used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">ContentView</span></strong><span class="koboSpan" id="kobo.484.1">, but now we need to add some functions that will take care of setting different timers, which will trigger the doors to open and close, trigger the floor number lights, and also trigger the sound effects at the right moments. </span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.485.1">Adding the data model functions</span></h1>
<p><span class="koboSpan" id="kobo.486.1">In this section, we will create</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.487.1"> five functions, and each one oversees a </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">specific task:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.489.1">A function to open and close </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the doors</span></span></li>
<li><span class="koboSpan" id="kobo.491.1">A function to play the chimes bell sound that signifies the elevator has reached </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">its destination</span></span></li>
<li><span class="koboSpan" id="kobo.493.1">A function to play the door opening and </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">closing sounds</span></span></li>
<li><span class="koboSpan" id="kobo.495.1">A function to light up the floor </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">indicator lights</span></span></li>
<li><span class="koboSpan" id="kobo.497.1">A function to stop all </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">the timers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.499.1">Let’s start by creating the function that will open and close </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the doors.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.501.1">Adding the doorOpenTimer function</span></h2>
<p><span class="koboSpan" id="kobo.502.1">Come back into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">DataModel</span></strong><span class="koboSpan" id="kobo.504.1"> class, and directly </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.505.1">underneath the last variable, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">following function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
func openDoors() {
    doorOpenTimer = Timer.scheduledTimer(withTimeInterval:
      8, repeats: false) { _ in
        self.doorsOpened.toggle()
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.508.1">This function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">openDoors</span></strong><span class="koboSpan" id="kobo.510.1">, and what this does is set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">doorsOpenTimer</span></strong><span class="koboSpan" id="kobo.512.1"> object to a value specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">scheduledTimer</span></strong><span class="koboSpan" id="kobo.514.1"> method. </span><span class="koboSpan" id="kobo.514.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">scheduledTimer</span></strong><span class="koboSpan" id="kobo.516.1"> method will execute the code in its block after a certain amount of time has elapsed – in this case, 8 seconds. </span></p>
<p><span class="koboSpan" id="kobo.517.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">scheduledTimerWithInterval</span></strong><span class="koboSpan" id="kobo.519.1"> function also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">repeats</span></strong><span class="koboSpan" id="kobo.521.1"> parameter, which lets you repeat the triggering of the code in its body. </span><span class="koboSpan" id="kobo.521.2">In the code, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">repeats</span></strong><span class="koboSpan" id="kobo.523.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">false</span></strong><span class="koboSpan" id="kobo.525.1">, as we only want the code in its body to be triggered when the elevator button </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">is pressed.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">The code that it will trigger will involve toggling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.529.1"> property to its opposite value. </span><span class="koboSpan" id="kobo.529.2">We’re going </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.530.1">to add a button to the elevator, and we will call this function when that button is pressed. </span><span class="koboSpan" id="kobo.530.2">When it’s pressed, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.532.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">true</span></strong><span class="koboSpan" id="kobo.534.1">, it will be toggled to </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">false</span></strong><span class="koboSpan" id="kobo.536.1">, and vice versa, thus opening and closing the doors </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">as needed.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.538.1">Adding the playChimeSound function</span></h2>
<p><span class="koboSpan" id="kobo.539.1">Let’s create another function that will trigger</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.540.1"> the chimes sound effect; this sound signifies the elevator has reached its destination and will play just before the doors open. </span><span class="koboSpan" id="kobo.540.2">Add the following function, directly underneath the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">previous one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
func playChimeSound() {
    chimesTimer = Timer.scheduledTimer(withTimeInterval:
      5.5, repeats: false) { _ in
       playSound(sound: "elevatorChime", type: "m4a")
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.543.1">This function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">playChimeSound</span></strong><span class="koboSpan" id="kobo.545.1">, and it is like the previous function we </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">just added.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">When the function is called, it sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">chimesTimer</span></strong><span class="koboSpan" id="kobo.549.1"> property to a value specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">scheduledTimer</span></strong><span class="koboSpan" id="kobo.551.1"> method, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">5.5</span></strong><span class="koboSpan" id="kobo.553.1"> seconds. </span><span class="koboSpan" id="kobo.553.2">After 5.5 seconds have elapsed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">scheduledTimer</span></strong><span class="koboSpan" id="kobo.555.1"> method will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">playSound</span></strong><span class="koboSpan" id="kobo.557.1"> function within </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">its body.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">playSound</span></strong><span class="koboSpan" id="kobo.561.1"> function has two parameters – one for the name of the sound file that we imported into the project, and the other for the file’s extension type. </span><span class="koboSpan" id="kobo.561.2">However, we haven’t created this function yet, so we will get </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">an error!</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">To fix this, we need to create a separate Swift file, which we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">PlaySound</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">Then, add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">this file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
import Foundation
import AVFoundation
var audioPlayer: AVAudioPlayer?
</span><span class="koboSpan" id="kobo.567.2">func playSound(sound: String, type: String) {
    if let path = Bundle.main.path(forResource: sound,
      ofType: type) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf:
            URL(fileURLWithPath: path))
            audioPlayer?.play()
        } catch {
            print("ERROR: Could not find and play the sound
              file!")
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.568.1">As we’ve done in previous projects, we imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">AVFoundation</span></strong><span class="koboSpan" id="kobo.570.1"> framework to have access to the audio classes and methods we need. </span><span class="koboSpan" id="kobo.570.2">Next, we created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">audio player</span></strong><span class="koboSpan" id="kobo.572.1"> instance and then added the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">playSound</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.574.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">You should be familiar with how </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.576.1">this function works; all we need to do is call this function in any file in which we need to have sound playing, passing the name of the sound file into its </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">sound</span></strong><span class="koboSpan" id="kobo.578.1"> parameter and its extension type into its </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">type</span></strong><span class="koboSpan" id="kobo.580.1"> parameter. </span><span class="koboSpan" id="kobo.580.2">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">playChimeSound</span></strong><span class="koboSpan" id="kobo.582.1"> function should </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">play error-free.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">Now, let’s head back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">DataModel</span></strong><span class="koboSpan" id="kobo.586.1"> class and continue to add the rest of the functions that </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">we need.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.588.1">Adding the playDoorOpenCloseSound function</span></h2>
<p><span class="koboSpan" id="kobo.589.1">When an elevator door opens and</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.590.1"> closes, it makes a distinctive sound, similar to a mechanical whooshing sound. </span><span class="koboSpan" id="kobo.590.2">We want to add that sound to the project, and we’ll need a function that can trigger it at the right moment. </span><span class="koboSpan" id="kobo.590.3">Let’s do that right after the </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">previous function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">
func playDoorOpenCloseSound(interval: TimeInterval) {
        doorSoundTimer = Timer.scheduledTimer(withTimeInterval:           interval, repeats: false) { _ in
            playSound(sound: "doorsOpenClose", type: "m4a")
        }
    }</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">playDoorOpenCloseSound</span></strong><span class="koboSpan" id="kobo.594.1"> is a function in which we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">doorSoundTimer</span></strong><span class="koboSpan" id="kobo.596.1"> property to a value specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">scheduledTimer</span></strong><span class="koboSpan" id="kobo.598.1"> method, and the value it will use for the interval parameter will be passed into this function when it gets called in </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">ContentView</span></strong><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">When this function is called, it triggers the code in its body after the interval time has passed, and in its body is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">playSound</span></strong><span class="koboSpan" id="kobo.602.1"> function, as we have seen before, which will play the doors’ opening and </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">closing sounds.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.604.1">Adding the floorNumbers function</span></h2>
<p><span class="koboSpan" id="kobo.605.1">Up until this point, the functions that we’ve </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.606.1">created have been simple and straightforward, with only one or two lines of code each. </span><span class="koboSpan" id="kobo.606.2">But to have the floor indicator lights working correctly, we need to add some more complexity and</span><a id="_idTextAnchor165"/><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.607.1"> a little bit </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">of logic.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">The objective of this next function is to have the appropriate floor light activate when the elevator reaches its intended floor, and deactivate when the elevator leaves that floor, as a real working elevator would do. </span><span class="koboSpan" id="kobo.609.2">So, let’s add the following function underneath the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">previous one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
func floorNumbers() {
        ///light up floor 1 as soon as the button is
          pressed, making sure floor 2 is not lit first
        if !floor2 {
            floor1.toggle()
        }
        ///check if the doors are opened, if not, open the
          doors and play the chime sound
        if !doorsOpened {
            openDoors()
            playChimeSound()
            
        ///going up - wait 4 seconds and turn on the floor
          2 light, and turn off the floor 1 light
            if goingUp {
              withAnimation(Animation.default.delay(4.0)) {
                    floor2 = true
                    floor1 = false
                }
    ///once at the top, and the button is pressed again to 
      go down, wait five seconds then turn off the floor 2 
      light and turn on the floor 1 light
              withAnimation(Animation.default.delay(5.0)) {
                    floor1 = true
                    floor2 = false
                    playDoorOpenCloseSound(interval: 8.5)
                }
            } else if !goingUp {
              withAnimation(Animation.default.delay(5.0)) {
                    floor1 = true
                    floor2 = false
                    playDoorOpenCloseSound(interval: 8.5)
                }
              withAnimation(Animation.default.delay(5.0)) {
                    floor2 = true
                    floor1 = false
                }
            }
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.612.1">The function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">floorNumbers</span></strong><span class="koboSpan" id="kobo.614.1">, and it starts off by checking various properties to see whether they are </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">true</span></strong><span class="koboSpan" id="kobo.616.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">false</span></strong><span class="koboSpan" id="kobo.618.1">. </span></p>
<p><span class="koboSpan" id="kobo.619.1">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">if</span></strong><span class="koboSpan" id="kobo.621.1"> statement in the function checks to see whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">floor2</span></strong><span class="koboSpan" id="kobo.623.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">false</span></strong><span class="koboSpan" id="kobo.625.1"> – if it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">false</span></strong><span class="koboSpan" id="kobo.627.1">, then we want to toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">floor1</span></strong><span class="koboSpan" id="kobo.629.1"> property to its opposite value. </span><span class="koboSpan" id="kobo.629.2">We always want to make sure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">floor1</span></strong><span class="koboSpan" id="kobo.631.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">floor2</span></strong><span class="koboSpan" id="kobo.633.1"> variables have values that are opposite each other, as they represent the different floors that the elevator goes to. </span></p>
<p><span class="koboSpan" id="kobo.634.1">After that first </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">if</span></strong><span class="koboSpan" id="kobo.636.1"> statement, there is </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.637.1">another </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">if</span></strong><span class="koboSpan" id="kobo.639.1"> statement. </span><span class="koboSpan" id="kobo.639.2">This one checks to see whether the doors are open; if they are not open, then the code will open the doors and play the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">chimes sound.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">Then, inside that </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">if</span></strong><span class="koboSpan" id="kobo.643.1"> statement is another </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">if</span></strong><span class="koboSpan" id="kobo.645.1"> statement, which makes this a nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">if</span></strong><span class="koboSpan" id="kobo.647.1"> statement. </span><span class="koboSpan" id="kobo.647.2">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">if</span></strong><span class="koboSpan" id="kobo.649.1"> statement will not run the code in its body if the variable it is checking is </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">false</span></strong><span class="koboSpan" id="kobo.651.1">; it will just move to the next line of code in the file. </span><span class="koboSpan" id="kobo.651.2">This one is checking to see whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">goingUp</span></strong><span class="koboSpan" id="kobo.653.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">true</span></strong><span class="koboSpan" id="kobo.655.1">; if it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">true</span></strong><span class="koboSpan" id="kobo.657.1">, let’s make </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">floor2</span></strong><span class="koboSpan" id="kobo.659.1"> true and </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">floor1</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.661.1">false</span></strong><span class="koboSpan" id="kobo.662.1"> because we want to light up </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">floor2</span></strong><span class="koboSpan" id="kobo.664.1">. </span></p>
<p><span class="koboSpan" id="kobo.665.1">This code is all being triggered in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">withAnimation</span></strong><span class="koboSpan" id="kobo.667.1"> function, after a delay of </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">4</span></strong><span class="koboSpan" id="kobo.669.1"> seconds. </span><span class="koboSpan" id="kobo.669.2">That’s the amount of time to wait before turning on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">floor2</span></strong><span class="koboSpan" id="kobo.671.1"> light and turning off the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">floor1</span></strong><span class="koboSpan" id="kobo.673.1"> light. </span><span class="koboSpan" id="kobo.673.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">withAnimation</span></strong><span class="koboSpan" id="kobo.675.1"> function is going to add a default animation, which is just a fade-in/fade-out animation that looks good when turning on and off lights – in our case, the elevator </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">floor lights.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">When the elevator reaches the top floor and the button is pressed again to go down, the elevator waits </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">5</span></strong><span class="koboSpan" id="kobo.679.1"> seconds, and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">floor1</span></strong><span class="koboSpan" id="kobo.681.1"> light turns on and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">floor2</span></strong><span class="koboSpan" id="kobo.683.1"> light turns off because the elevator is on its way down. </span><span class="koboSpan" id="kobo.683.2">Also, we’re going to trigger the open and close door sounds after </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">8.5</span></strong><span class="koboSpan" id="kobo.685.1"> seconds, which is enough time for the elevator to reach the bottom floor, at which </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.686.1">point the sound needs to be playing. </span><span class="koboSpan" id="kobo.686.2">Again, we’re doing this in the body of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">withAnimation</span></strong><span class="koboSpan" id="kobo.688.1"> function, so it adds a default fade animation to the lights being turned on </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">and off.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">Next, we need to use similar code for when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">goingUp</span></strong><span class="koboSpan" id="kobo.692.1"> variable is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">true</span></strong><span class="koboSpan" id="kobo.694.1">, so both states, </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">true</span></strong><span class="koboSpan" id="kobo.696.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">false</span></strong><span class="koboSpan" id="kobo.698.1">, will operate the lights and sounds correctly. </span><span class="koboSpan" id="kobo.698.2">We do that in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">else if</span></strong><span class="koboSpan" id="kobo.700.1"> statement. </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">else if</span></strong><span class="koboSpan" id="kobo.702.1"> offers another alternative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">if</span></strong><span class="koboSpan" id="kobo.704.1"> statement that proceeds it, should that </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">if</span></strong><span class="koboSpan" id="kobo.706.1"> statement be </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">false</span></strong><span class="koboSpan" id="kobo.708.1">. </span><span class="koboSpan" id="kobo.708.2">So here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">else if</span></strong><span class="koboSpan" id="kobo.710.1"> checks whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">goingUp</span></strong><span class="koboSpan" id="kobo.712.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">false</span></strong><span class="koboSpan" id="kobo.714.1">; if so, the code turns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">floor1</span></strong><span class="koboSpan" id="kobo.716.1"> light on after 5 seconds because the elevator is heading down, turns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">floor2</span></strong><span class="koboSpan" id="kobo.718.1"> light off, and then plays the door opening and closing sounds. </span><span class="koboSpan" id="kobo.718.2">Otherwise, after 5 seconds, it will do the opposite, turning </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">floor2</span></strong><span class="koboSpan" id="kobo.720.1"> back on and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">floor1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1"> off.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">This is the logic now in place that is used to operate the timers and trigger the appropriate sounds at the right moment, by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">if</span></strong><span class="koboSpan" id="kobo.725.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">else if</span></strong><span class="koboSpan" id="kobo.727.1"> statements. </span><span class="koboSpan" id="kobo.727.2">Now, the thing with timers is that when a few of them are created, they can overlap with each other and cause unintended consequences in the app, so we need to stop them before creating </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">new ones.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.729.1">Adding the stopTimer function</span></h2>
<p><span class="koboSpan" id="kobo.730.1">We do have a lot of timers firing at various</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.731.1"> times in the app, and some of these timers can overlap with each other in the background and cause unintended side effects in the app. </span><span class="koboSpan" id="kobo.731.2">We need to stop any timer that has served its purpose so that there are no problems. </span><span class="koboSpan" id="kobo.731.3">New ones will be created when needed, but they all should be stopped after the completion of their tasks. </span></p>
<p><span class="koboSpan" id="kobo.732.1">So, let’s handle the deactivation of all the timers in a separate function. </span><span class="koboSpan" id="kobo.732.2">Add the following final function to </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.734.1">
 func stopTimer() {
        doorOpenTimer?.invalidate()
        doorOpenTimer = nil
        chimesTimer?.invalidate()
        chimesTimer = nil
        doorSoundTimer?.invalidate()
        doorSoundTimer = nil
    }</span></pre>
<p><span class="koboSpan" id="kobo.735.1">This function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">stopTimer</span></strong><span class="koboSpan" id="kobo.737.1">, and it invalidates all the timers that were created and sets them </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">nil</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Invalidating a timer effectively stops the timer from ever firing again and requests its removal from its run loop. </span><span class="koboSpan" id="kobo.741.2">Setting an object to </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">nil</span></strong><span class="koboSpan" id="kobo.743.1"> is equivalent to a variable being set to zero; it makes sure that it is completely stopped. </span><span class="koboSpan" id="kobo.743.2">We will call this method inside the elevator button press and </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.744.1">make it the first method to be called, thus removing any timers that might still </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">be going.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">DataModel</span></strong><span class="koboSpan" id="kobo.748.1"> is complete with all the functions and properties set up to be used anywhere in the app; we’re going to use them in </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">ContentView</span></strong><span class="koboSpan" id="kobo.750.1">. </span><span class="koboSpan" id="kobo.750.2">Let’s head over there and start to put things together so that we can start to see </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">some results.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.752.1">Adding the background, a button, and animating the doors</span></h1>
<p><span class="koboSpan" id="kobo.753.1">Let’s continue and start to fill out </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">ContentView</span></strong><span class="koboSpan" id="kobo.755.1"> so that we can see the elevator, and then we can </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">animate things.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">First, we will add </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.758.1">a black background to the whole scene. </span><span class="koboSpan" id="kobo.758.2">To do this, add a constant at the top just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">appData</span></strong><span class="koboSpan" id="kobo.760.1"> variable to hold </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">some color:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.762.1">
let backgroundColor = Color(UIColor.black)</span></pre>
<p><span class="koboSpan" id="kobo.763.1">Next, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">body</span></strong><span class="koboSpan" id="kobo.765.1"> property, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">ZStack</span></strong><span class="koboSpan" id="kobo.767.1"> and call our </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">backgroundColor</span></strong><span class="koboSpan" id="kobo.769.1"> constant, setting the color for </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">the screen:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.771.1">
var body: some View {
        ZStack {
            backgroundColor.edgesIgnoringSafeArea(.all)
               }</span></pre>
<p><span class="koboSpan" id="kobo.772.1">Now, we will need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">ElevatorAndPeople</span></strong><span class="koboSpan" id="kobo.774.1"> view so that we can make it visible in this file. </span><span class="koboSpan" id="kobo.774.2">Add the following code, still working inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">ZStack</span></strong><span class="koboSpan" id="kobo.776.1">, and in fact, all subsequent code we add into this file will be within </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">this </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">ZStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.780.1">
          //MARK: - ADD THE PEOPLEANDELEVATOR VIEW
            ElevatorAndPeopleView(doorsOpened: 
              $appData.doorsOpened)</span></pre>
<p><span class="koboSpan" id="kobo.781.1">As we’ve seen before, to show another view in </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">ContentView</span></strong><span class="koboSpan" id="kobo.783.1">, we simply call it here inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">body</span></strong><span class="koboSpan" id="kobo.785.1"> property and pass in the binding variable that we created to access the model class. </span><span class="koboSpan" id="kobo.785.2">Remember that </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.786.1">we use the dollar sign to access binding variables, which tells the system that we are bidirectionally connecting to </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">another view.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">Note that we can access our data by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">appData</span></strong><span class="koboSpan" id="kobo.790.1"> observed object, and by typing a dot, we can then choose any of the properties or functions within the model file. </span><span class="koboSpan" id="kobo.790.2">Here, I’m choosing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.792.1"> property, and we will be toggling that on in </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">a button.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">And speaking of buttons, let’s add the</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.795.1"> elevator button right now; we’ll put it on the left side of the elevator frame, and when pressed, the doors will open and close. </span><span class="koboSpan" id="kobo.795.2">Add the following code under the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">previous line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
//MARK: - ELEVATOR BUTTON
    GeometryReader { geo in
      Button(action: {
           appData.doorsOpened.toggle()
        }) {
           ///if the doors are opened, make the button 
             white, otherwise make it black
            Circle().frame(width: 10, height: 10)
              .foregroundColor(appData.doorsOpened ? </span><span class="koboSpan" id="kobo.797.2">.white 
              : .black)
                .overlay(Circle().stroke(Color.red,
                  lineWidth: 1))
                .padding(5)
                .background(Color.black)
                .cornerRadius(30)
        }.position(x: (geo.size.width / 33), y:
          (geo.size.height / 2))</span></pre>
<p><span class="koboSpan" id="kobo.798.1">This code starts off by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.800.1">. </span><span class="koboSpan" id="kobo.800.2">As we have seen, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.802.1"> will align the views so that they fit perfectly in the scene, and they will resize correctly on other size devices by accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">geo</span></strong><span class="koboSpan" id="kobo.804.1"> constant inside the closure. </span></p>
<p><span class="koboSpan" id="kobo.805.1">We then create a button</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.806.1"> inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.808.1"> – the button will run all the code in its body when pressed. </span><span class="koboSpan" id="kobo.808.2">We want to check out how the doors work first, so I added the code to toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.810.1"> property when the button </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">is pressed.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">Let’s look at what else we’re doing here with the button code by looking at the button closure, where the styling is being done. </span><span class="koboSpan" id="kobo.812.2">The code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">Circle</span></strong><span class="koboSpan" id="kobo.814.1"> view to create a circle shape for the button. </span><span class="koboSpan" id="kobo.814.2">I gave it a dimension of 10 x 10 and then added several modifiers to help with </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">the styling:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.816.1">First, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">foregroundColor</span></strong><span class="koboSpan" id="kobo.818.1"> modifier for the circle, which is either going to be white when the doors are open, or black when they are closed. </span><span class="koboSpan" id="kobo.818.2">This is achieved by accessing our model’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">ObservedObject</span></strong><span class="koboSpan" id="kobo.820.1"> instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">appData</span></strong><span class="koboSpan" id="kobo.822.1">, and calling up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">doorsOpened</span></strong><span class="koboSpan" id="kobo.824.1"> property from </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">the model.</span></span></li>
<li><span class="koboSpan" id="kobo.826.1">The next modifier is </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">overlay</span></strong><span class="koboSpan" id="kobo.828.1">, where we pass in another </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Circle</span></strong><span class="koboSpan" id="kobo.830.1"> view. </span><span class="koboSpan" id="kobo.830.2">Then, by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">stroke</span></strong><span class="koboSpan" id="kobo.832.1"> modifier, it turns it into a stroked circle (and not a filled circle). </span><span class="koboSpan" id="kobo.832.2">The color of the stroke is set to red and has a line width of </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">1</span></strong><span class="koboSpan" id="kobo.834.1"> point. </span><span class="koboSpan" id="kobo.834.2">This stroke will look like a small red ring within the button, as you sometimes see in an actual </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">elevator button.</span></span></li>
<li><span class="koboSpan" id="kobo.836.1">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">padding</span></strong><span class="koboSpan" id="kobo.838.1"> modifier, with a value of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.840.1"> points.</span></span></li>
<li><span class="koboSpan" id="kobo.841.1">Then, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">background</span></strong><span class="koboSpan" id="kobo.843.1"> color modifier, positioned underneath the </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">red ring.</span></span></li>
<li><span class="koboSpan" id="kobo.845.1">Finally, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">cornerRadius</span></strong><span class="koboSpan" id="kobo.847.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">30</span></strong><span class="koboSpan" id="kobo.849.1"> is added to the black background color view, as that is by default a rectangle and we need a </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">rounded shape.</span></span></li>
<li><span class="koboSpan" id="kobo.851.1">Now, all we have to do is position the button exactly where it needs to be on the elevator frame, and we can do that with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">position</span></strong><span class="koboSpan" id="kobo.853.1"> modifier, passing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">geo</span></strong><span class="koboSpan" id="kobo.855.1"> proxy constant, which has the precise size of an iPhone’s screen. </span><span class="koboSpan" id="kobo.855.2">Here, the code locates the button on the X axis by using the width of the button, and divides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.857.1"> (the width of the iPhone screen) by 33; this value will move the button exactly to the left portion of the elevator frame. </span><span class="koboSpan" id="kobo.857.2">Now that we have the </span><em class="italic"><span class="koboSpan" id="kobo.858.1">X</span></em><span class="koboSpan" id="kobo.859.1"> location for the button, we need the </span><em class="italic"><span class="koboSpan" id="kobo.860.1">Y</span></em><span class="koboSpan" id="kobo.861.1"> location. </span><span class="koboSpan" id="kobo.861.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">geo</span></strong><span class="koboSpan" id="kobo.863.1"> constant again, and dividing </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">height</span></strong><span class="koboSpan" id="kobo.865.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">2</span></strong><span class="koboSpan" id="kobo.867.1">, we can place</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.868.1"> the button in the middle of the frame for the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.869.1">Y</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.870.1"> axis.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.871.1">And with that, the button is complete. </span><span class="koboSpan" id="kobo.871.2">Let’s try out the animation that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">so far:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer159">
<span class="koboSpan" id="kobo.873.1"><img alt="Figure 11.6: The opening doors and button " src="image/B18674_11_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.874.1">Figure 11.6: The opening doors and button</span></p>
<p><span class="koboSpan" id="kobo.875.1">Press the button and you should see the doors open; if you press the button again, the doors will close. </span><span class="koboSpan" id="kobo.875.2">And</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.876.1"> the doors work perfectly, opening and closing at a nice pace, and the button changes color when the doors </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">are open.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">Let’s continue and add floor indicator lights to </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">the elevator.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.880.1">Adding floor indicator lights</span></h1>
<p><span class="koboSpan" id="kobo.881.1">As we know, elevators have lights, usually at the top of the frame, to let people know what floor the elevator is on at </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.882.1">any time. </span><span class="koboSpan" id="kobo.882.2">Let’s simulate that by adding the lights that represent both floors of the elevator, one and two. </span><span class="koboSpan" id="kobo.882.3">Add the following code directly after the previous line of code we have </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">just written:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.884.1">
//MARK: - ADD THE FLOOR LIGHTS
  HStack {
      Image(systemName: "1.circle")
          .foregroundColor(appData.floor1 ? </span><span class="koboSpan" id="kobo.884.2">.red : .black)
          .opacity(appData.floor1 ? </span><span class="koboSpan" id="kobo.884.3">1 : 0.3)
      Image(systemName: "2.circle")
          .foregroundColor(appData.floor2 ? </span><span class="koboSpan" id="kobo.884.4">.red : .black)
          .opacity(appData.floor2 ? </span><span class="koboSpan" id="kobo.884.5">1 : 0.3)
  }.position(x: (geo.size.width / 2), y: (geo.size.height *
    0.02) + 2)
      .font(.system(size: 25))</span></pre>
<p><span class="koboSpan" id="kobo.885.1">We start off with </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">HStack</span></strong><span class="koboSpan" id="kobo.887.1"> so that we can put two circle images side by side. </span><span class="koboSpan" id="kobo.887.2">These are system images, and they have specific names of </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">1.circle</span></strong><span class="koboSpan" id="kobo.889.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">2.circle</span></strong><span class="koboSpan" id="kobo.891.1">. </span><span class="koboSpan" id="kobo.891.2">The first circle represents the first floor, and the second circle represents the </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">second floor.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">The color of the first circle light will depend on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">floor1</span></strong><span class="koboSpan" id="kobo.895.1"> variable – if it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">true</span></strong><span class="koboSpan" id="kobo.897.1">, it will make the color red; otherwise, if it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">false</span></strong><span class="koboSpan" id="kobo.899.1">, it will turn it black. </span><span class="koboSpan" id="kobo.899.2">The opacity of this circle will also depend on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">floor1</span></strong><span class="koboSpan" id="kobo.901.1"> variable – again, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">true</span></strong><span class="koboSpan" id="kobo.903.1">, the circle will have a fully opaque look; otherwise, we will make the opacity </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">.3</span></strong><span class="koboSpan" id="kobo.905.1">. </span><span class="koboSpan" id="kobo.905.2">We use the same code for </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">both circles.</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">Then, by putting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">position</span></strong><span class="koboSpan" id="kobo.909.1"> modifier at the end of </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">HStack</span></strong><span class="koboSpan" id="kobo.911.1">, we can position both circles directly at the top of the frame and keep the position in place by, again, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">geo</span></strong><span class="koboSpan" id="kobo.913.1"> proxy. </span><span class="koboSpan" id="kobo.913.2">Finally, we will use a font size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">25</span></strong><span class="koboSpan" id="kobo.915.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">floor numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">That completes the floor </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">indicator lights.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">Finally, all we need to</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.920.1"> do is to call the rest of our functions inside the button body, so that when the button is pressed, all the lights and sounds will work on timers. </span><span class="koboSpan" id="kobo.920.2">So, add the following code to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">the project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
 //MARK: - ELEVATOR BUTTON
    GeometryReader { geo in
        Button(action: {
             appData.stopTimer()
            appData.playDoorOpenCloseSound(interval: 0.5)
              appData.doorsOpened.toggle()
            appData.goingUp.toggle()
              appData.floorNumbers()
        }) {</span></pre>
<p><span class="koboSpan" id="kobo.923.1">The code accesses the model functions using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">appData</span></strong><span class="koboSpan" id="kobo.925.1"> instance and runs each one when the button </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">is pressed.</span></span></p>
<p><span class="koboSpan" id="kobo.927.1">Now, run the project and you’ll see that when the button is pressed, the doors will open and you’ll see the people inside. </span><span class="koboSpan" id="kobo.927.2">Also, notice that the button changes color and the indicator for the floor lights up, along with chimes and the sounds of doors opening. </span><span class="koboSpan" id="kobo.927.3">When the elevator is moving between floors, the doors, lights, and sounds will work on their own, at the </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">right times.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.929.1"><img alt="Figure 11.7: The completed project " src="image/B18674_11_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.930.1">Figure 11.7: The completed project</span></p>
<p><span class="koboSpan" id="kobo.931.1">It’s a nice animation, and it </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.932.1">really simulates the timing of an actual elevator </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">very well.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.934.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.935.1">We have now completed our elevator project. </span><span class="koboSpan" id="kobo.935.2">Let’s look at what we </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">have done.</span></span></p>
<p><span class="koboSpan" id="kobo.937.1">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.939.1"> and the proxy constant to add images to the project and position them where needed, which will resize all the images in the project dynamically, based on the device that displays them, whether iPhones </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">or iPads.</span></span></p>
<p><span class="koboSpan" id="kobo.941.1">We created </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">DataModel</span></strong><span class="koboSpan" id="kobo.943.1"> to store all the app’s data and functions, and we accessed all that data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">ObservableObject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.946.1"> protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.947.1">We used timers to trigger door and light animations at different moments in the scene, making the animations happen on their own. </span><span class="koboSpan" id="kobo.947.2">We also added and styled a button to change color, when pressed, and we made floor lights turn on and off </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">with timers.</span></span></p>
<p><span class="koboSpan" id="kobo.949.1">The skills learned here can be useful and applied to other projects. </span><span class="koboSpan" id="kobo.949.2">For example, if you were putting together a game app that has several levels, maybe you could incorporate an elevator scene into the game to take the user to another level after they have completed a certain skill, or to search </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">for power-ups.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">How about a challenge? </span><span class="koboSpan" id="kobo.951.2">To take the project further, see whether you can add more floors to the scene. </span><span class="koboSpan" id="kobo.951.3">Or how about animating the people inside the elevator using the same techniques we used with the girl on the swing project? </span><span class="koboSpan" id="kobo.951.4">Cut up the images and make different parts move in different ways – for example, you could cut up the second man’s mouth so it looks like he’s talking when the doors open. </span><span class="koboSpan" id="kobo.951.5">You could also animate the legs so that they shuffle a little bit inside the elevator, or animate their bodies so that they sway a little,</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.952.1"> basically simulating </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">human motion.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">In the next chapter, we’ll start putting together a language-learning game and animate various aspects of the UI to make the game fluid and interesting. </span><span class="koboSpan" id="kobo.954.2">We’ll also make the game work across three different languages – English, Spanish, and Italian – so that it can appeal to a broad range of language learners. </span></p>
</div>
<div>
<div class="Content" id="_idContainer162">
</div>
</div>
</body></html>