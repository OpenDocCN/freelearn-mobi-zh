<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor152"/>11</h1>
<h1 id="_idParaDest-149"><a id="_idTextAnchor153"/>Animating an Elevator</h1>
<p>Welcome to the elevator project! In this one, we’re going to create a working elevator, complete with sounds, floor lights, a button, and even some images of people inside. We will control the elevator using timers that are available from the Swift timer class, as we have done in previous projects.</p>
<p>To bring these elements together, we’ll create a data model using the <code>@ObservableObject</code> protocol. Apple recommends making a data model as the place to store and process the data that the application uses. The data model is also separate from the app’s user interface, where the views are created. The reason to keep data and the UI separate is that this paradigm fosters modularity and testability. It’s easier to find bugs in your logic when the data is not mixed in with UI code. Once we have the data model set up, we can then publish that data anywhere in the app using publishing wrappers, as we will see later.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Setting up a project and adding a <code>Binding</code> variable</li>
<li>Assembling the elevator using images and the <code>GeometryReader</code> view</li>
<li>Putting people inside the elevator</li>
<li>Creating a data model and using the <code>@</code><code>ObservableObject</code> protocol</li>
<li>Adding the data model functions</li>
<li>Adding the background, a button, and animating the doors</li>
<li>Adding floor indicator lights</li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor154"/>Technical requirements</h1>
<p>You can download the resources and finished project on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/>Setting up the project and adding a Binding variable</h1>
<p>Okay, let’s get started! As <a id="_idIndexMarker614"/>always, we’ll create a new Xcode project (I’m going to call mine <code>Elevator</code>).</p>
<p>Next, in the GitHub repo, take <a id="_idIndexMarker615"/>all the images from the <code>Chapter 11</code> folder and drop them into the Asset Catalog. These images include <code>doorDrame</code>, <code>leftDoor</code>, <code>rightDoor</code>, <code>inside</code>, <code>man</code>, <code>man2</code>, <code>man3</code>, and <code>man4</code>.</p>
<p>Then, drop the audio files – <code>doorsOpenClose</code> and <code>elevatorChime</code> – into the Project Navigator.</p>
<p>Next, we’re going to need a<a id="_idIndexMarker616"/> new file where we can assemble the elevator and add the people, so create a new SwiftUI View file and call it <code>ElevatorAndPeopleView</code>. We only need one variable in this file, which will be the Binding variable. Let’s add it at the top, inside the <code>ElevatorAndPeopleView</code> struct:</p>
<pre class="source-code">
    @Binding var doorsOpened: Bool</pre>
<p>This variable will control the elevator doors opening and closing.</p>
<p>Let’s update the <code>Previews</code> so that the code will build without errors. At the bottom of the file, alter the <code>Previews</code> struct so that it looks like the following:</p>
<pre class="source-code">
struct ElevatorAndPeopleView_Previews: PreviewProvider {
    static var previews: some View {
        ElevatorAndPeopleView(doorsOpened: 
          .constant(false), moveMouth: .constant(false))
    } </pre>
<p>The code adds a value of <code>false</code> to both binding properties, and the project once again builds cleanly. </p>
<p>We can now move on to building out the elevator.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor156"/>Assembling the elevator using images and the GeometryReader view</h1>
<p>The next step is to use <a id="_idIndexMarker617"/>some of the images from the Assets catalog and make an elevator. </p>
<p>We’ll start by adding the inside part of the elevator, which we’ll do by adding the following code inside the <code>body</code> property:</p>
<pre class="source-code">
 ZStack {
 GeometryReader { geo in
                }
        }</pre>
<p>First, we have <code>ZStack</code> to hold all the views that will follow, and a <code>GeometryReader</code> view.</p>
<p>The <code>GeometryReader</code> view is a container view that defines its content as a function of its own size and coordinate space. It’s a little bit like the other containers that we have used, such as <code>VStack</code> or <code>HStack</code>, but the difference is that <code>GeometryReader</code> has more flexibility because of its proxy parameter, the <code>geo</code> constant (which you can name whatever you want). </p>
<p>This proxy will contain information about the container’s size and coordinate space, and we can pass that information to the child views inside <code>GeometryReader</code>, which helps us precisely size and position its children relative to the container. The <code>GeometryReader</code> view also makes the views within it line up perfectly on all iPhone and iPad devices, whatever their size.</p>
<p>We’re going to use <code>GeometryReader</code> to size and position all the parts of the elevator, as well as the people inside.</p>
<p>Next, let’s add the code that creates the elevator’s interior within <code>GeometryReader</code>’s body:</p>
<pre class="source-code">
//MARK: - INSIDE ELEVATOR SCENE
    Image("inside").resizable()
      .frame(maxWidth: geo.size.width,
      maxHeight: geo.size.height)</pre>
<p>The <code>Image</code> initializer adds the image called <code>inside</code> to the scene, and then uses the <code>frame</code> modifier to set the size of this image to the maximum width and maximum height of the screen. It sets this <a id="_idIndexMarker618"/>size using the <code>geo</code> proxy constant we created with the <code>GeometryReader</code> view. </p>
<p>The previews now display the inside of the elevator:</p>
<div><div><img alt="Figure 11.1: The inside of the elevator " src="img/B18674_11_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: The inside of the elevator</p>
<p>Let’s continue assembling the elevator by adding doors next. The doors will have animations attached to them so that they slide open and close, and then later, we will add timers to them <a id="_idIndexMarker619"/>so that they can operate automatically after an initial button press. So, continuing inside the <code>GeometryReader</code> view, add this code for the doors:</p>
<pre class="source-code">
  //MARK: - ADD THE DOORS
  HStack {
      Image("leftDoor").resizable()
          .frame(maxWidth: geo.size.width)
          .offset(x: doorsOpened ? -geo.size.width / 2 : 4)
      Image("rightDoor").resizable()
          .frame(maxWidth: geo.size.width)
          .offset(x: doorsOpened ? geo.size.width / 2 : -4)
              }</pre>
<p>We put the doors in <code>HStack</code> because they need to be positioned side by side. The doors are sized using the <code>frame</code> modifier and <code>geo</code> proxy constant, just as we did with the <code>inside</code> elevator image. Both doors also get the <code>offset</code> modifier tacked on to them, which will position them on opposite sides of the screen, opening them up fully. </p>
<p>The process to open and close the doors is handled by the <code>geo</code> proxy constant. When the <code>doorsOpened</code> property becomes <code>true</code> for the left door, the <code>geo</code> proxy constant will move the door on the <em class="italic">x</em>-axis, to the left and off the screen. The amount that the door moves is the width of the door divided by 2. The reason why the left door moves to the left and not the right is that we prefix the <code>geo</code> constant with a negative sign. When a negative value is used and an object is being offset on the <em class="italic">x</em>-axis, that object will move to the left, whereas a positive value will move the object to the right.</p>
<p>When the <code>doorsOpened</code> property becomes <code>false</code>, the <code>offset</code> modifier reverses the animation and the left door closes.</p>
<p>For the right door, we do the same thing, except a positive value is used for the <code>geo</code> constant, which moves the door to the right along the <em class="italic">X</em> axis to open it. The values of <code>4</code> and -<code>4</code> that are used for both doors are included to help keep the two doors snug with each other when they are in the closed position.</p>
<p>So far, this is what the scene looks like in the <code>ElevatorAndPeopleView</code> file:</p>
<div><div><img alt="Figure 11.2: The elevator doors " src="img/B18674_11_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: The elevator doors</p>
<p>We have the elevator’s interior and doors <a id="_idIndexMarker620"/>placed together, and we have the animation mechanism to operate the doors, but we won’t see any motion happening until we call this file inside <code>ContentView</code>, and we still have some more assembly to do.</p>
<p>Let’s put a frame around the outside of the elevator so that it will look like the actual elevator, and provide a place to add the elevator’s button. Add the following code just after the closing bracket of <code>HStack</code>, still within the <code>GeometryReader</code> view:</p>
<pre class="source-code">
      Image("doorFrame").resizable()
          .frame(maxWidth: geo.size.width, maxHeight:
            geo.size.height)</pre>
<p>Here, we are adding the <code>doorFrame</code> image to the scene, and as we want the frame to go around the entire elevator, we used the same code that we used for the <code>inside</code> image – we used the <code>geo</code> proxy <a id="_idIndexMarker621"/>constant again, and by setting the image at the maximum width and height, the door frame creates a nice border around the elevator doors. This is the result so far:</p>
<div><div><img alt="Figure 11.3: The elevator frame " src="img/B18674_11_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: The elevator frame</p>
<p>Now, let’s add the animation code that will open and close the doors, and control the speed and delay of the doors when activated later in the <code>ContentView</code>. Its only one line of code, and it can be placed right after the closing bracket of the <code>GeometryReader</code> view:</p>
<pre class="source-code">
.animation(Animation.easeInOut.speed(0.09).delay(0.3),
  value: doorsOpened)</pre>
<p>Here, we use the <code>animation</code> modifier. Then, we pass in a value of <code>0.09</code> for the <code>speed</code> function, which will control how fast the doors open and close. There’s also a slight <code>delay</code> added of <code>0.3</code> seconds, which will delay the door opening and closing just enough to keep things in sync with the floor lights, which we will add soon. </p>
<p>We’re getting close to finishing using this file – the only parts left to add are the people images. Of course, you can<a id="_idIndexMarker622"/> put the people code into a separate file if you prefer, but since there isn’t a lot of code in this file, it will be fine to continue to work here. </p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/>Putting people inside the elevator</h1>
<p>We’ll be adding four<a id="_idIndexMarker623"/> characters into our elevator, Let’s start with the <code>manOne</code> image – add the following code right after the <code>frame</code> modifier near the top of the file, inside the <code>GeometryReader</code> view:</p>
<pre class="source-code">
  //MARK: - ADD THE PEOPLE
      Image("manOne")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width - 200, maxHeight:
          geo.size.height - 300)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: 0, y: 250)</pre>
<p>What we are doing here is bringing the <code>manOne</code> image into the scene and then adding the correct aspect ratio to the image. Next, we use the <code>frame</code> modifier to set the size for the image, but what’s different this time is that we use the proxy constant of <code>GeometryReader</code> to set the size dynamically; when the width and height of an image are set this way, the scene will proportionally scale up or down on all Apple devices to fit the various screen sizes.</p>
<p>I’m trimming off 200 and 300 points for the width and height values so that the image will fit nicely inside the elevator. Once we have the images sized and positioned the way we want, they will scale dynamically when they appear on different devices, so we do need to size and position them initially.</p>
<p>We will then add some <code>shadow</code> with <code>30</code> points around the image on the <em class="italic">X</em> and <em class="italic">Y</em> axes, which gives a nice depth of field for the man when placed inside the shiny metal elevator. And finally, we <a id="_idIndexMarker624"/>offset the image on the <em class="italic">Y</em> axis so that the feet are on the floor of the elevator.</p>
<p>This is how <code>manOne</code> looks in our elevator:</p>
<div><div><img alt="Figure 11.4: The first man " src="img/B18674_11_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: The first man</p>
<p>Since we don’t have the animation hooked up yet, to open the door and see inside the elevator while we continue to work, you can simply comment out the door code, and the door images will disappear.</p>
<p>The code for the three remaining people is similar to what we’ve just added, so I’m going to add the other three<a id="_idIndexMarker625"/> images directly under the previous code:</p>
<pre class="source-code">
      Image("manTwo")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width, maxHeight:
          geo.size.height - 290)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: 40, y: 230)
        .rotation3DEffect(Angle(degrees: 20), axis: (x: 0,
          y: -1, z: 0))
                
      Image("manThree")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width - 100, maxHeight:
          geo.size.height - 250)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: 130, y: 255)
                
      Image("manFour")
        .resizable().aspectRatio(contentMode: .fit)
        .frame(maxWidth: geo.size.width - 0, maxHeight:
          geo.size.height - 280)
        .shadow(color: .black, radius: 30, x: 5, y: 5)
        .offset(x: -80, y: 265)</pre>
<p>The code for the <code>manTwo</code>, <code>manThree</code>, and <code>manFour</code> images are largely the same as the code for the <code>manOne</code> image, just with slightly different values for the <code>frame</code> modifier, the <code>offset</code> modifier, and their positions in the elevator. </p>
<p>Regarding the <code>manTwo</code> code, I’m adding a rotation effect to this image because I want to turn this image a little bit toward the left, as he appears to be talking, and it looks a little bit better if we position him in the direction of the person on his right. This is accomplished with the <code>rotation3DEffect</code> modifier; simply turning him <code>20</code> degrees on the <em class="italic">Y</em> axis is enough<a id="_idIndexMarker626"/> to point him in the right direction of the other image.</p>
<p>Here is our elevator full of people:</p>
<div><div><img alt="Figure 11.5: The rest of the people " src="img/B18674_11_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: The rest of the people</p>
<p>And that finishes off this file. We can now move on to creating the data model file and adding the necessary functions for the timers and sound effects.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor158"/>Creating a data model and using the ObservableObject protocol</h1>
<p>Let’s create a new file – although<a id="_idIndexMarker627"/> this time, choose the <code>DataModel</code>. In this<a id="_idIndexMarker629"/> file, we will put the data that we can access from <code>ContentView</code> later, using the <code>@ObservableObject</code> protocol. </p>
<p>To use this protocol, we first need to import the SwiftUI framework:</p>
<pre class="source-code">
import SwiftUI</pre>
<p>Next, we need a class to hold all the data, and we also need to make the class conform to the <code>@ObservableObject</code> protocol, so let’s add that now. You can name the class anything you want, but many developers like to name the class the same name as the file it is in, so we will do the same, naming the class <code>DataModel</code>:</p>
<pre class="source-code">
class DataModel: ObservableObject {
                                 }</pre>
<p>Let’s understand what <code>@</code><code>ObservableObject</code> does.</p>
<p>In previous projects, we used the <code>@State</code> property to pass data to the views and display them to the user, but this is limited because the <code>@State</code> property wrapper can only store values that control the states of a single view; we can’t make <code>@State</code> properties and pass them around to other structs, as they work in only one struct. </p>
<p>We also used the <code>@Binding</code> property wrapper, which helped to re-establish the connection to other views or structs with a bidirectional link that the <code>@State</code> property could not provide. However, this would not work globally to hold and pass data to all files in the app.</p>
<p>So, what we need now is an object that can globally control all the app’s data and its states and update the views accordingly when there are any changes to the properties, either by user input or changes made by other means, such as downloads from a server or the web.</p>
<p>This is where the <code>@ObservableObject</code> protocol comes in.</p>
<p>The <code>@ObservableObject</code> protocol defines three distinct property wrappers: </p>
<ul>
<li>An <code>@StateObject</code> property wrapper that listens for changes in <code>@ObservableObject</code> and receives the new values</li>
<li>An <code>@ObservedObject</code> property wrapper that listens for changes in the <code>@StateObject</code> property and receives those new values</li>
<li>An <code>@Published</code> property wrapper that reports all the changes to the system and publishes those changes to the vi<a id="_idTextAnchor159"/>ew app-wide</li>
</ul>
<p>The advantage of using <code>@ObservableObject</code> over the <code>@State</code> property wrapper is, again, that we can <a id="_idIndexMarker630"/>update more than one view with any changes, and the state can be checked from views anywhere in the app.</p>
<p>Now, that’s a lot to take in, but it will become clearer as we build out the data model. We already have the <code>DataModel</code> class created, and it conforms to the <code>@ObservableObject</code> protocol – that’s the first step. Next, we want to declare the properties we need, prefixing<a id="_idIndexMarker631"/> them with the <code>@Published</code> property wrapper so that they will hold the various data and states and be published to the views when needed. Let’s do that now by adding the following properties inside the <code>DataModel</code> class:</p>
<pre class="source-code">
    @Published var doorsOpened = false
    @Published var floor1 = false
    @Published var floor2 = false
    @Published var goingUp = false
    @Published var doorOpenTimer: Timer? = nil
    @Published var chimesTimer: Timer? = nil
    @Published var doorSoundTimer: Timer? = nil</pre>
<p>There are several properties here that hopefully are self-explanatory. The four Booleans will be used to let us know when the doors of the elevator are opened, whether floor 1 or floor 2 is the active<a id="_idIndexMarker632"/> floor, and whether the elevator is going up or going down. The timers will control the timing of the doors<a id="_idIndexMarker633"/> opening and closing, as well as when to play the floor chimes and when to play the door opening and closing sounds.</p>
<p>With the properties listed, we next need a way to access them from other parts of the app. This is done by going up the hierarchy to the <code>Root</code> view and injecting an instance of the data model there – the <code>Root</code> view is the entry point of the app, the point from which the app starts up.</p>
<p>Let’s go into the <code>App.swift</code> file in the Project navigator and create an instance of the <code>DataModel</code> class there inside the struct, sending a reference to <code>ContentView</code>, like this:</p>
<pre class="source-code">
@main
struct Elevator: App {
    @StateObject private var appData = DataModel()
        var body: some Scene {
        WindowGroup {
            ContentView(appData: appData)
        }
    }
}</pre>
<p>As I mentioned, this file is the entry point for our app, as denoted by the <code>@main</code> wrapper at the top, and it creates the <code>Root</code> view window and takes care of creating all the objects we need for the app to start up. Since this file is at the top of the hierarchy, it’s the perfect place to create the <code>DataModel</code> instance and pass it into the <code>Root</code> view, <code>ContentView</code>, so it can be available app-wide.</p>
<p>The <code>DataModel</code> instance is called <code>appData</code>, and it gets prefixed with the <code>@StateObject</code> property wrapper – this wrapper will listen for changes in <code>@ObservableObject</code> and receive any new values.</p>
<p>Next, the <code>@StateObject</code> property wrapper that we called <code>appData</code> is injected into <code>ContentView</code> by passing it into the <code>ContentView</code> initializer to, again, make the data in the data model available throughout the app.</p>
<p>Now, to complete the connection from <a id="_idIndexMarker634"/>our data here, and from any view in the project, all we have to do is include an <code>@ObservedObject</code> property inside every view that we want to have a connection to this<a id="_idIndexMarker635"/> model. The job of <code>@ObservedObject</code> is to listen for changes in the <code>@StateObject</code> property and receive those new values so that it can update the views.</p>
<p>Let’s now go into <code>ContentView</code> and add an <code>@ObservedObject</code> property to complete the bidirectional binding between the <code>AppData</code> class, which holds all the data, and <code>ContentView</code>, which is in charge of displaying all of that data on a screen to a user. Add the following property to the <code>ContentView</code> struct:</p>
<pre class="source-code">
struct ContentView: View {
    @ObservedObject var appData: DataModel
               •••••••
}</pre>
<p>Now, we have an instance of <code>DataModel</code>, which will monitor all the data for us; if there are any changes to the data, <code>ObservedObject</code> will know about it and update the views accordingly.</p>
<p>Also, if we create more files and need to access the data model from those new files, all we have to do is create another instance of the data model and use it in those files too, like we did with the <code>appData</code> instance here, and they will have the same access and be updated with any changes that occur.</p>
<p>We have the instance of the data model ready to be used in <code>ContentView</code>, but now we need to add some functions that will take care of setting different timers, which will trigger the doors to open and close, trigger the floor number lights, and also trigger the sound effects at the right moments. </p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor160"/>Adding the data model functions</h1>
<p>In this section, we will create<a id="_idIndexMarker636"/> five functions, and each one oversees a specific task:</p>
<ul>
<li>A function to open and close the doors</li>
<li>A function to play the chimes bell sound that signifies the elevator has reached its destination</li>
<li>A function to play the door opening and closing sounds</li>
<li>A function to light up the floor indicator lights</li>
<li>A function to stop all the timers</li>
</ul>
<p>Let’s start by creating the function that will open and close the doors.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor161"/>Adding the doorOpenTimer function</h2>
<p>Come back into the <code>DataModel</code> class, and directly <a id="_idIndexMarker637"/>underneath the last variable, add the following function:</p>
<pre class="source-code">
func openDoors() {
    doorOpenTimer = Timer.scheduledTimer(withTimeInterval:
      8, repeats: false) { _ in
        self.doorsOpened.toggle()
        }
    }</pre>
<p>This function is called <code>openDoors</code>, and what this does is set the <code>doorsOpenTimer</code> object to a value specified by the <code>scheduledTimer</code> method. The <code>scheduledTimer</code> method will execute the code in its block after a certain amount of time has elapsed – in this case, 8 seconds. </p>
<p>The <code>scheduledTimerWithInterval</code> function also has a <code>repeats</code> parameter, which lets you repeat the triggering of the code in its body. In the code, we set the <code>repeats</code> parameter to <code>false</code>, as we only want the code in its body to be triggered when the elevator button is pressed.</p>
<p>The code that it will trigger will involve toggling the <code>doorsOpened</code> property to its opposite value. We’re going <a id="_idIndexMarker638"/>to add a button to the elevator, and we will call this function when that button is pressed. When it’s pressed, if the <code>doorsOpened</code> property is <code>true</code>, it will be toggled to <code>false</code>, and vice versa, thus opening and closing the doors as needed.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor162"/>Adding the playChimeSound function</h2>
<p>Let’s create another function that will trigger<a id="_idIndexMarker639"/> the chimes sound effect; this sound signifies the elevator has reached its destination and will play just before the doors open. Add the following function, directly underneath the previous one:</p>
<pre class="source-code">
func playChimeSound() {
    chimesTimer = Timer.scheduledTimer(withTimeInterval:
      5.5, repeats: false) { _ in
       playSound(sound: "elevatorChime", type: "m4a")
      }
    }</pre>
<p>This function is called <code>playChimeSound</code>, and it is like the previous function we just added.</p>
<p>When the function is called, it sets the <code>chimesTimer</code> property to a value specified by the <code>scheduledTimer</code> method, which is <code>5.5</code> seconds. After 5.5 seconds have elapsed, the <code>scheduledTimer</code> method will call the <code>playSound</code> function within its body.</p>
<p>The <code>playSound</code> function has two parameters – one for the name of the sound file that we imported into the project, and the other for the file’s extension type. However, we haven’t created this function yet, so we will get an error!</p>
<p>To fix this, we need to create a separate Swift file, which we will call <code>PlaySound</code>. Then, add the following code to this file:</p>
<pre class="source-code">
import Foundation
import AVFoundation
var audioPlayer: AVAudioPlayer?
func playSound(sound: String, type: String) {
    if let path = Bundle.main.path(forResource: sound,
      ofType: type) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf:
            URL(fileURLWithPath: path))
            audioPlayer?.play()
        } catch {
            print("ERROR: Could not find and play the sound
              file!")
        }
    }
}</pre>
<p>As we’ve done in previous projects, we imported the <code>AVFoundation</code> framework to have access to the audio classes and methods we need. Next, we created an <code>audio player</code> instance and then added the <code>playSound</code> function.</p>
<p>You should be familiar with how <a id="_idIndexMarker640"/>this function works; all we need to do is call this function in any file in which we need to have sound playing, passing the name of the sound file into its <code>sound</code> parameter and its extension type into its <code>type</code> parameter. Now, the <code>playChimeSound</code> function should play error-free.</p>
<p>Now, let’s head back to the <code>DataModel</code> class and continue to add the rest of the functions that we need.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor163"/>Adding the playDoorOpenCloseSound function</h2>
<p>When an elevator door opens and<a id="_idIndexMarker641"/> closes, it makes a distinctive sound, similar to a mechanical whooshing sound. We want to add that sound to the project, and we’ll need a function that can trigger it at the right moment. Let’s do that right after the previous function:</p>
<pre class="source-code">
func playDoorOpenCloseSound(interval: TimeInterval) {
        doorSoundTimer = Timer.scheduledTimer(withTimeInterval:           interval, repeats: false) { _ in
            playSound(sound: "doorsOpenClose", type: "m4a")
        }
    }</pre>
<p><code>playDoorOpenCloseSound</code> is a function in which we set the <code>doorSoundTimer</code> property to a value specified by the <code>scheduledTimer</code> method, and the value it will use for the interval parameter will be passed into this function when it gets called in <code>ContentView</code>. When this function is called, it triggers the code in its body after the interval time has passed, and in its body is the <code>playSound</code> function, as we have seen before, which will play the doors’ opening and closing sounds.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor164"/>Adding the floorNumbers function</h2>
<p>Up until this point, the functions that we’ve <a id="_idIndexMarker642"/>created have been simple and straightforward, with only one or two lines of code each. But to have the floor indicator lights working correctly, we need to add some more complexity and<a id="_idTextAnchor165"/><a id="_idTextAnchor166"/> a little bit of logic.</p>
<p>The objective of this next function is to have the appropriate floor light activate when the elevator reaches its intended floor, and deactivate when the elevator leaves that floor, as a real working elevator would do. So, let’s add the following function underneath the previous one:</p>
<pre class="source-code">
func floorNumbers() {
        ///light up floor 1 as soon as the button is
          pressed, making sure floor 2 is not lit first
        if !floor2 {
            floor1.toggle()
        }
        ///check if the doors are opened, if not, open the
          doors and play the chime sound
        if !doorsOpened {
            openDoors()
            playChimeSound()
            
        ///going up - wait 4 seconds and turn on the floor
          2 light, and turn off the floor 1 light
            if goingUp {
              withAnimation(Animation.default.delay(4.0)) {
                    floor2 = true
                    floor1 = false
                }
    ///once at the top, and the button is pressed again to 
      go down, wait five seconds then turn off the floor 2 
      light and turn on the floor 1 light
              withAnimation(Animation.default.delay(5.0)) {
                    floor1 = true
                    floor2 = false
                    playDoorOpenCloseSound(interval: 8.5)
                }
            } else if !goingUp {
              withAnimation(Animation.default.delay(5.0)) {
                    floor1 = true
                    floor2 = false
                    playDoorOpenCloseSound(interval: 8.5)
                }
              withAnimation(Animation.default.delay(5.0)) {
                    floor2 = true
                    floor1 = false
                }
            }
        }
    }</pre>
<p>The function is called <code>floorNumbers</code>, and it starts off by checking various properties to see whether they are <code>true</code> or <code>false</code>. </p>
<p>The first <code>if</code> statement in the function checks to see whether the <code>floor2</code> property is <code>false</code> – if it is <code>false</code>, then we want to toggle the <code>floor1</code> property to its opposite value. We always want to make sure that the <code>floor1</code> and <code>floor2</code> variables have values that are opposite each other, as they represent the different floors that the elevator goes to. </p>
<p>After that first <code>if</code> statement, there is <a id="_idIndexMarker643"/>another <code>if</code> statement. This one checks to see whether the doors are open; if they are not open, then the code will open the doors and play the chimes sound.</p>
<p>Then, inside that <code>if</code> statement is another <code>if</code> statement, which makes this a nested <code>if</code> statement. An <code>if</code> statement will not run the code in its body if the variable it is checking is <code>false</code>; it will just move to the next line of code in the file. This one is checking to see whether the <code>goingUp</code> property is <code>true</code>; if it is <code>true</code>, let’s make <code>floor2</code> true and <code>floor1</code> <code>false</code> because we want to light up <code>floor2</code>. </p>
<p>This code is all being triggered in the <code>withAnimation</code> function, after a delay of <code>4</code> seconds. That’s the amount of time to wait before turning on the <code>floor2</code> light and turning off the <code>floor1</code> light. The <code>withAnimation</code> function is going to add a default animation, which is just a fade-in/fade-out animation that looks good when turning on and off lights – in our case, the elevator floor lights.</p>
<p>When the elevator reaches the top floor and the button is pressed again to go down, the elevator waits <code>5</code> seconds, and then the <code>floor1</code> light turns on and the <code>floor2</code> light turns off because the elevator is on its way down. Also, we’re going to trigger the open and close door sounds after <code>8.5</code> seconds, which is enough time for the elevator to reach the bottom floor, at which <a id="_idIndexMarker644"/>point the sound needs to be playing. Again, we’re doing this in the body of the <code>withAnimation</code> function, so it adds a default fade animation to the lights being turned on and off.</p>
<p>Next, we need to use similar code for when the <code>goingUp</code> variable is not <code>true</code>, so both states, <code>true</code> and <code>false</code>, will operate the lights and sounds correctly. We do that in an <code>else if</code> statement. <code>else if</code> offers another alternative to the <code>if</code> statement that proceeds it, should that <code>if</code> statement be <code>false</code>. So here, <code>else if</code> checks whether <code>goingUp</code> is <code>false</code>; if so, the code turns the <code>floor1</code> light on after 5 seconds because the elevator is heading down, turns the <code>floor2</code> light off, and then plays the door opening and closing sounds. Otherwise, after 5 seconds, it will do the opposite, turning <code>floor2</code> back on and <code>floor1</code> off.</p>
<p>This is the logic now in place that is used to operate the timers and trigger the appropriate sounds at the right moment, by using <code>if</code> and <code>else if</code> statements. Now, the thing with timers is that when a few of them are created, they can overlap with each other and cause unintended consequences in the app, so we need to stop them before creating new ones.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor167"/>Adding the stopTimer function</h2>
<p>We do have a lot of timers firing at various<a id="_idIndexMarker645"/> times in the app, and some of these timers can overlap with each other in the background and cause unintended side effects in the app. We need to stop any timer that has served its purpose so that there are no problems. New ones will be created when needed, but they all should be stopped after the completion of their tasks. </p>
<p>So, let’s handle the deactivation of all the timers in a separate function. Add the following final function to the file:</p>
<pre class="source-code">
 func stopTimer() {
        doorOpenTimer?.invalidate()
        doorOpenTimer = nil
        chimesTimer?.invalidate()
        chimesTimer = nil
        doorSoundTimer?.invalidate()
        doorSoundTimer = nil
    }</pre>
<p>This function is called <code>stopTimer</code>, and it invalidates all the timers that were created and sets them to <code>nil</code>.</p>
<p>Invalidating a timer effectively stops the timer from ever firing again and requests its removal from its run loop. Setting an object to <code>nil</code> is equivalent to a variable being set to zero; it makes sure that it is completely stopped. We will call this method inside the elevator button press and <a id="_idIndexMarker646"/>make it the first method to be called, thus removing any timers that might still be going.</p>
<p>Now, <code>DataModel</code> is complete with all the functions and properties set up to be used anywhere in the app; we’re going to use them in <code>ContentView</code>. Let’s head over there and start to put things together so that we can start to see some results.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor168"/>Adding the background, a button, and animating the doors</h1>
<p>Let’s continue and start to fill out <code>ContentView</code> so that we can see the elevator, and then we can animate things.</p>
<p>First, we will add <a id="_idIndexMarker647"/>a black background to the whole scene. To do this, add a constant at the top just after the <code>appData</code> variable to hold some color:</p>
<pre class="source-code">
let backgroundColor = Color(UIColor.black)</pre>
<p>Next, inside the <code>body</code> property, let’s add <code>ZStack</code> and call our <code>backgroundColor</code> constant, setting the color for the screen:</p>
<pre class="source-code">
var body: some View {
        ZStack {
            backgroundColor.edgesIgnoringSafeArea(.all)
               }</pre>
<p>Now, we will need to call the <code>ElevatorAndPeople</code> view so that we can make it visible in this file. Add the following code, still working inside <code>ZStack</code>, and in fact, all subsequent code we add into this file will be within this <code>ZStack</code>:</p>
<pre class="source-code">
          //MARK: - ADD THE PEOPLEANDELEVATOR VIEW
            ElevatorAndPeopleView(doorsOpened: 
              $appData.doorsOpened)</pre>
<p>As we’ve seen before, to show another view in <code>ContentView</code>, we simply call it here inside the <code>body</code> property and pass in the binding variable that we created to access the model class. Remember that <a id="_idIndexMarker648"/>we use the dollar sign to access binding variables, which tells the system that we are bidirectionally connecting to another view.</p>
<p>Note that we can access our data by using the <code>appData</code> observed object, and by typing a dot, we can then choose any of the properties or functions within the model file. Here, I’m choosing the <code>doorsOpened</code> property, and we will be toggling that on in a button.</p>
<p>And speaking of buttons, let’s add the<a id="_idIndexMarker649"/> elevator button right now; we’ll put it on the left side of the elevator frame, and when pressed, the doors will open and close. Add the following code under the previous line:</p>
<pre class="source-code">
//MARK: - ELEVATOR BUTTON
    GeometryReader { geo in
      Button(action: {
           appData.doorsOpened.toggle()
        }) {
           ///if the doors are opened, make the button 
             white, otherwise make it black
            Circle().frame(width: 10, height: 10)
              .foregroundColor(appData.doorsOpened ? .white 
              : .black)
                .overlay(Circle().stroke(Color.red,
                  lineWidth: 1))
                .padding(5)
                .background(Color.black)
                .cornerRadius(30)
        }.position(x: (geo.size.width / 33), y:
          (geo.size.height / 2))</pre>
<p>This code starts off by using <code>GeometryReader</code>. As we have seen, using <code>GeometryReader</code> will align the views so that they fit perfectly in the scene, and they will resize correctly on other size devices by accessing the <code>geo</code> constant inside the closure. </p>
<p>We then create a button<a id="_idIndexMarker650"/> inside <code>GeometryReader</code> – the button will run all the code in its body when pressed. We want to check out how the doors work first, so I added the code to toggle the <code>doorsOpened</code> property when the button is pressed.</p>
<p>Let’s look at what else we’re doing here with the button code by looking at the button closure, where the styling is being done. The code uses the <code>Circle</code> view to create a circle shape for the button. I gave it a dimension of 10 x 10 and then added several modifiers to help with the styling:</p>
<ul>
<li>First, we use the <code>foregroundColor</code> modifier for the circle, which is either going to be white when the doors are open, or black when they are closed. This is achieved by accessing our model’s <code>ObservedObject</code> instance, <code>appData</code>, and calling up the <code>doorsOpened</code> property from the model.</li>
<li>The next modifier is <code>overlay</code>, where we pass in another <code>Circle</code> view. Then, by adding the <code>stroke</code> modifier, it turns it into a stroked circle (and not a filled circle). The color of the stroke is set to red and has a line width of <code>1</code> point. This stroke will look like a small red ring within the button, as you sometimes see in an actual elevator button.</li>
<li>Then, we use the <code>padding</code> modifier, with a value of <code>5</code> points.</li>
<li>Then, we use a <code>background</code> color modifier, positioned underneath the red ring.</li>
<li>Finally, a <code>cornerRadius</code> value of <code>30</code> is added to the black background color view, as that is by default a rectangle and we need a rounded shape.</li>
<li>Now, all we have to do is position the button exactly where it needs to be on the elevator frame, and we can do that with the <code>position</code> modifier, passing in the <code>geo</code> proxy constant, which has the precise size of an iPhone’s screen. Here, the code locates the button on the X axis by using the width of the button, and divides the <code>GeometryReader</code> (the width of the iPhone screen) by 33; this value will move the button exactly to the left portion of the elevator frame. Now that we have the <em class="italic">X</em> location for the button, we need the <em class="italic">Y</em> location. Using the <code>geo</code> constant again, and dividing <code>height</code> by <code>2</code>, we can place<a id="_idIndexMarker651"/> the button in the middle of the frame for the <em class="italic">Y</em> axis.</li>
</ul>
<p>And with that, the button is complete. Let’s try out the animation that we have so far:</p>
<div><div><img alt="Figure 11.6: The opening doors and button " src="img/B18674_11_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: The opening doors and button</p>
<p>Press the button and you should see the doors open; if you press the button again, the doors will close. And<a id="_idIndexMarker652"/> the doors work perfectly, opening and closing at a nice pace, and the button changes color when the doors are open.</p>
<p>Let’s continue and add floor indicator lights to the elevator.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor169"/>Adding floor indicator lights</h1>
<p>As we know, elevators have lights, usually at the top of the frame, to let people know what floor the elevator is on at <a id="_idIndexMarker653"/>any time. Let’s simulate that by adding the lights that represent both floors of the elevator, one and two. Add the following code directly after the previous line of code we have just written:</p>
<pre class="source-code">
//MARK: - ADD THE FLOOR LIGHTS
  HStack {
      Image(systemName: "1.circle")
          .foregroundColor(appData.floor1 ? .red : .black)
          .opacity(appData.floor1 ? 1 : 0.3)
      Image(systemName: "2.circle")
          .foregroundColor(appData.floor2 ? .red : .black)
          .opacity(appData.floor2 ? 1 : 0.3)
  }.position(x: (geo.size.width / 2), y: (geo.size.height *
    0.02) + 2)
      .font(.system(size: 25))</pre>
<p>We start off with <code>HStack</code> so that we can put two circle images side by side. These are system images, and they have specific names of <code>1.circle</code> and <code>2.circle</code>. The first circle represents the first floor, and the second circle represents the second floor.</p>
<p>The color of the first circle light will depend on the <code>floor1</code> variable – if it’s <code>true</code>, it will make the color red; otherwise, if it’s <code>false</code>, it will turn it black. The opacity of this circle will also depend on the <code>floor1</code> variable – again, if <code>true</code>, the circle will have a fully opaque look; otherwise, we will make the opacity <code>.3</code>. We use the same code for both circles.</p>
<p>Then, by putting the <code>position</code> modifier at the end of <code>HStack</code>, we can position both circles directly at the top of the frame and keep the position in place by, again, using the <code>geo</code> proxy. Finally, we will use a font size of <code>25</code> for the floor numbers.</p>
<p>That completes the floor indicator lights.</p>
<p>Finally, all we need to<a id="_idIndexMarker654"/> do is to call the rest of our functions inside the button body, so that when the button is pressed, all the lights and sounds will work on timers. So, add the following code to complete the project:</p>
<pre class="source-code">
 //MARK: - ELEVATOR BUTTON
    GeometryReader { geo in
        Button(action: {
             appData.stopTimer()
            appData.playDoorOpenCloseSound(interval: 0.5)
              appData.doorsOpened.toggle()
            appData.goingUp.toggle()
              appData.floorNumbers()
        }) {</pre>
<p>The code accesses the model functions using the <code>appData</code> instance and runs each one when the button is pressed.</p>
<p>Now, run the project and you’ll see that when the button is pressed, the doors will open and you’ll see the people inside. Also, notice that the button changes color and the indicator for the floor lights up, along with chimes and the sounds of doors opening. When the elevator is moving between floors, the doors, lights, and sounds will work on their own, at the right times.</p>
<div><div><img alt="Figure 11.7: The completed project " src="img/B18674_11_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: The completed project</p>
<p>It’s a nice animation, and it <a id="_idIndexMarker655"/>really simulates the timing of an actual elevator very well.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor170"/>Summary</h1>
<p>We have now completed our elevator project. Let’s look at what we have done.</p>
<p>We used <code>GeometryReader</code> and the proxy constant to add images to the project and position them where needed, which will resize all the images in the project dynamically, based on the device that displays them, whether iPhones or iPads.</p>
<p>We created <code>DataModel</code> to store all the app’s data and functions, and we accessed all that data using the <code>@</code><code>ObservableObject</code> protocol.</p>
<p>We used timers to trigger door and light animations at different moments in the scene, making the animations happen on their own. We also added and styled a button to change color, when pressed, and we made floor lights turn on and off with timers.</p>
<p>The skills learned here can be useful and applied to other projects. For example, if you were putting together a game app that has several levels, maybe you could incorporate an elevator scene into the game to take the user to another level after they have completed a certain skill, or to search for power-ups.</p>
<p>How about a challenge? To take the project further, see whether you can add more floors to the scene. Or how about animating the people inside the elevator using the same techniques we used with the girl on the swing project? Cut up the images and make different parts move in different ways – for example, you could cut up the second man’s mouth so it looks like he’s talking when the doors open. You could also animate the legs so that they shuffle a little bit inside the elevator, or animate their bodies so that they sway a little,<a id="_idTextAnchor171"/> basically simulating human motion.</p>
<p>In the next chapter, we’ll start putting together a language-learning game and animate various aspects of the UI to make the game fluid and interesting. We’ll also make the game work across three different languages – English, Spanish, and Italian – so that it can appeal to a broad range of language learners. </p>
</div>
<div><div></div>
</div>
</body></html>