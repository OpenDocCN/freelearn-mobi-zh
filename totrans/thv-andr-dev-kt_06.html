<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"/>4</h1>
<h1 id="_idParaDest-89" class="calibre5"><a id="_idTextAnchor090" class="calibre6 pcalibre1 pcalibre"/>Building the Packtagram UI</h1>
<p class="calibre3">As we leave the exciting world of chat applications behind, it’s time to take on another interesting challenge – social networking. Social networking apps have seen an exponential rise in popularity over the last decade, becoming integral to our daily lives. These platforms have changed the way we communicate, share, and interact with each other on a global scale. Among them, Instagram stands out with its simplicity, its emphasis on visuals, and its engaging features, such as its newsfeed and stories.</p>
<p class="calibre3">The next few chapters are dedicated to the process of creating an Instagram-like social networking application while leveraging Android’s powerful features and capabilities. We will call it Packtagram!</p>
<p class="calibre3">To start this journey, we’ll begin by setting up a solid foundation and structuring our project. The structure of an Android application has a significant impact on the ease of development and the application’s scalability over time. This chapter will cover various aspects of project structuring, such as defining the file hierarchy, segregating modules, and choosing the right architecture pattern for our needs.</p>
<p class="calibre3">Once our project structure is robust and scalable, we’ll transition into the realm of UI development. In the case of Instagram, the primary components that catch our attention are its newsfeed and stories. We’ll dive into the process of implementing these critical features, focusing on their user-friendly interfaces and seamless navigation flow.</p>
<p class="calibre3">After the UI, we’ll move on to the heart of any dynamic application: data retrieval. We’ll learn how to interact with servers to fetch data, focusing on the newsfeed.</p>
<p class="calibre3">In the final part of this chapter, we will venture into the world of data caching. Social media apps often involve a large amount of data transfer, and to provide a seamless and efficient user experience, effective data management strategies, including caching, are necessary. We will explore how to store stories and news items locally, thus reducing network calls and improving the app’s performance.</p>
<p class="calibre3">This chapter will cover the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Setting up Packtagram’s modules and dependencies</li>
<li class="calibre14">Creating the stories screen</li>
<li class="calibre14">Creating the newsfeed screen and its components</li>
<li class="calibre14">Using Retrofit and Moshi to retrieve newsfeed information</li>
<li class="calibre14">Implementing pagination to the newsfeed</li>
</ul>
<h1 id="_idParaDest-90" class="calibre5"><a id="_idTextAnchor091" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">As in the previous chapter, you will need to have Android Studio (or another editor of your preference) installed.</p>
<p class="calibre3">We are going to start a new project in this chapter, so it isn’t necessary to download the changes that you made in the previous chapter.</p>
<p class="calibre3">Nonetheless, you can have the complete code that we are going to build through this chapter in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-4" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-4</a>.</p>
<h1 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor092" class="calibre6 pcalibre1 pcalibre"/>Setting up Packtagram’s modules and dependencies</h1>
<p class="calibre3">To set up our app<a id="_idIndexMarker383" class="calibre6 pcalibre1 pcalibre"/> structure, we are going to create a new project. We could do this by following the same instructions that we covered in <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a>, but we are going to introduce a variation here: our Gradle files will be written in Kotlin, and we will also use version catalogs.</p>
<h2 id="_idParaDest-92" class="calibre7"><a id="_idTextAnchor093" class="calibre6 pcalibre1 pcalibre"/>Setting up a version catalog</h2>
<p class="calibre3">A <strong class="bold">version catalog</strong> is a <a id="_idIndexMarker384" class="calibre6 pcalibre1 pcalibre"/>feature that <a id="_idIndexMarker385" class="calibre6 pcalibre1 pcalibre"/>was introduced in Gradle 7.0 to centralize the declaration of dependencies in a project. This feature provides an organized way to manage dependencies, making it easier to control and update the different versions of libraries across different modules of a project.</p>
<p class="calibre3">With a version catalog, you define all the dependencies and their versions in a <code>libs.versions.toml</code>. This file resides in the Gradle folder of your project.</p>
<p class="calibre3">A version catalog offers several benefits:</p>
<ul class="calibre15">
<li class="calibre14">It simplifies dependency management by providing a single place to define and update the dependencies</li>
<li class="calibre14">It minimizes errors caused by discrepancies in dependency versions across modules</li>
<li class="calibre14">It improves the readability of build scripts by removing the need to declare each dependency individually as the declaration is centralized in a unique file</li>
</ul>
<p class="calibre3">To use version <a id="_idIndexMarker387" class="calibre6 pcalibre1 pcalibre"/>catalogs, in <a id="_idIndexMarker388" class="calibre6 pcalibre1 pcalibre"/>Android Studio, fill out the details for a new project, including <strong class="bold">Name</strong> – here, I chose <strong class="bold">Packtagram</strong>. For the <strong class="bold">Build configuration language</strong> field, select <strong class="bold">Kotlin </strong><strong class="bold">DSL (build.gradle.kts)</strong>:</p>
<div><div><img alt="Figure 4.1: Creating a new project in Android Studio Jellyfish (2023.3.1)" src="img/B19443_04_001.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1: Creating a new project in Android Studio Jellyfish (2023.3.1)</p>
<p class="calibre3">With this option, Android Studio will automatically create the file needed to specify the versions. This file <a id="_idIndexMarker389" class="calibre6 pcalibre1 pcalibre"/>is called <code>libs.versions.toml</code> and its default content will look like this:</p>
<pre class="source-code">
[versions]
agp = "8.1.0-beta01"
org-jetbrains-kotlin-android = "1.8.10"
core-ktx = "1.9.0"
...
[libraries]
core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "core-ktx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
...
[plugins]
com-android-application = { id = "com.android.application", version.ref = "agp" }
org-jetbrains-kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "org-jetbrains-kotlin-android" }
[bundles]</pre> <p class="calibre3">As shown<a id="_idIndexMarker390" class="calibre6 pcalibre1 pcalibre"/> in <a id="_idIndexMarker391" class="calibre6 pcalibre1 pcalibre"/>the following code (and in the <code>libs.version.toml</code> file generated by Android Studio in your project), the file is composed of several sections:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">versions</strong>: This section contains the versions of the dependencies that will be used in your project. You simply assign a reference name to each version number. This is useful to centralize versioning, particularly when the same version of a library is used in multiple places.</li>
<li class="calibre14"><strong class="source-inline1">libraries</strong>: In this block, you define your actual dependencies by assigning them an alias and linking them to the correct version defined in the <strong class="source-inline1">versions</strong> block. This alias can then be used throughout your project to refer to the dependency.</li>
<li class="calibre14"><strong class="source-inline1">bundles</strong>: Bundles are groups of dependencies that are commonly used together. By creating a bundle, you can include multiple dependencies in your build scripts with a single alias. This can simplify your build scripts and make them easier to read and manage.</li>
<li class="calibre14"><strong class="source-inline1">plugins</strong>: This section is where Gradle plugins that are used in the project are defined. Similar to libraries, each plugin is given an alias and linked to a version number from the <strong class="source-inline1">versions</strong> block. This feature makes managing plugins as straightforward as managing other dependencies.</li>
</ul>
<p class="calibre3">Now, if we open the <code>gradle.build.kts</code> file of our app module, we’ll see how the version catalog<a id="_idIndexMarker392" class="calibre6 pcalibre1 pcalibre"/> declarations are <a id="_idIndexMarker393" class="calibre6 pcalibre1 pcalibre"/>used. For example, here, we can see how the plugins are now applied:</p>
<pre class="source-code">
plugins {
    alias(libs.plugins.com.android.application)
    alias(libs.plugins.org.jetbrains.kotlin.android)
}</pre> <p class="calibre3">The term <code>alias</code> is used here to refer to a predefined plugin dependency that has been specified in the <code>libs.versions.toml</code> file.</p>
<p class="calibre3">Here, we can see how the dependencies are declared:</p>
<pre class="source-code">
dependencies {
    implementation(libs.core.ktx)
    implementation(libs.lifecycle.runtime.ktx)
    implementation(libs.activity.compose)
    implementation(platform(libs.compose.bom))
    implementation(libs.ui)
    implementation(libs.ui.graphics)
    implementation(libs.ui.tooling.preview)
    implementation(libs.material3)
    ...
}</pre> <p class="calibre3">As you can see, every dependency is referred to by the name we have given them in the version catalog file (<code>libs.versions.toml</code>). It is now easier to have all the project dependencies synchronized and included in the modules.</p>
<p class="calibre3">Talking about modules, it’s time we also structure our app using modularization. We already learned <a id="_idIndexMarker394" class="calibre6 pcalibre1 pcalibre"/>about the<a id="_idIndexMarker395" class="calibre6 pcalibre1 pcalibre"/> different strategies to modularize our app in <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a>, so this is a good time to review that information.</p>
<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor094" class="calibre6 pcalibre1 pcalibre"/>Modularizing our app</h2>
<p class="calibre3">In this case, we will <a id="_idIndexMarker396" class="calibre6 pcalibre1 pcalibre"/>segment Packtagram into several feature modules, each encapsulating distinct functionalities:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Newsfeed module</strong>: The <a id="_idIndexMarker397" class="calibre6 pcalibre1 pcalibre"/>newsfeed module is dedicated to the main feed and is where users see and interact with posts from those they follow. We’ll isolate this functionality because it’s the core user experience and likely the first screen users will see. This module will need to handle rendering posts, managing likes and comments, and refreshing the feed.</li>
<li class="calibre14"><strong class="bold">Stories module</strong>: We’ll separate the stories functionality into its own module because it’s a distinct user experience that requires specific UI elements and data handling. The stories module needs to manage how different user stories are rendered, track the view status, and manage story creation.</li>
<li class="calibre14"><strong class="bold">Profile module</strong>: User profiles are a central part of the Instagram experience, so we’ll house this functionality in the profile module. This module will handle displaying user information, managing posts specific to a user, and editing profile details.</li>
<li class="calibre14"><strong class="bold">Search module</strong>: Search functionality is complex enough to justify its own module. This module will deal with user queries, display search results, and manage interactions with search results.</li>
<li class="calibre14"><strong class="bold">Messaging module</strong>: Direct messaging is a separate feature in Instagram, so we’ll also isolate it in a dedicated module. This module will manage creating and displaying chats, sending and receiving messages, and notifications of new messages.</li>
<li class="calibre14"><strong class="bold">Core module</strong>: This module will contain shared utilities, network interfaces, and other common components used across the application. This prevents code duplication and provides <a id="_idIndexMarker398" class="calibre6 pcalibre1 pcalibre"/>a central point for managing shared resources.</li>
</ul>
<p class="calibre3">By choosing this modularization strategy, we’ve effectively separated our app into logical components <a id="_idIndexMarker399" class="calibre6 pcalibre1 pcalibre"/>that can be developed, tested, and debugged independently. This also aligns well with the idea<a id="_idIndexMarker400" class="calibre6 pcalibre1 pcalibre"/> of <strong class="bold">separation of concerns</strong>, ensuring that each part of our app has a clear, singular purpose. In the following sections, we’ll explore each of these modules in detail, building the functionalities one by one, culminating in our completed social networking app.</p>
<p class="calibre3">So, let’s create the modules while following the same instructions provided in <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a>. Our module structure will look like this:</p>
<div><div><img alt="Figure 4.2: The modules structure for Packtagram" src="img/B19443_04_002.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2: The modules structure for Packtagram</p>
<p class="calibre3">As we can see, we should have a module called <code>:app</code> (already created when creating the project), a module called <code>:core</code> for the core functionality, and a module called :<code>feature</code> that contains all of the feature modules (<code>:messaging</code>, <code>:newsfeed</code>, <code>:profile</code>, <code>:search</code>, and <code>:stories</code>).</p>
<p class="calibre3">As part of this project, we will focus on the <code>newsfeed</code> and <code>stories</code> modules (we already know how to create messaging functionality as that was covered in the last three chapters, so we don’t need to cover that again).</p>
<p class="calibre3">In the case of the feature modules, we will structure them internally using the same approach we <a id="_idIndexMarker401" class="calibre6 pcalibre1 pcalibre"/>already followed in the WhatsPackt project: organizing the code and dependencies in layers. For example, we could structure the <code>:newsfeed</code> module like so:</p>
<div><div><img alt="Figure 4.3: Internal structure for the feature modules" src="img/B19443_04_003.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3: Internal structure for the feature modules</p>
<p class="calibre3">Here, we can see that we have created four internal packages:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">data</strong>: This is where we will place the logic for the data layer, including the components needed to retrieve the information from the backend and the data sources</li>
<li class="calibre14"><strong class="source-inline1">di</strong>: This is where we will place the logic needed to define the dependency injection instructions</li>
<li class="calibre14"><strong class="source-inline1">domain</strong>: This is where we will place the domain logic, including the repositories and use cases</li>
<li class="calibre14"><strong class="source-inline1">ui</strong>: This is where we will place all the logic related to the user interface, including ViewModels, composables, and other Android View components</li>
</ul>
<p class="calibre3">We will implement the necessary components that will be part of the modules in this and the following chapters.</p>
<p class="calibre3">As part of our module structure, we’ve included an internal module specifically for dependency injection. Previously, in our WhatsPackt project, we used the Dagger Hilt framework for<a id="_idIndexMarker402" class="calibre6 pcalibre1 pcalibre"/> dependency injection. However, in this project, we will take a different approach by using Koin.</p>
<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor095" class="calibre6 pcalibre1 pcalibre"/>Getting to know Koin</h2>
<p class="calibre3">Koin was <a id="_idIndexMarker403" class="calibre6 pcalibre1 pcalibre"/>mentioned<a id="_idIndexMarker404" class="calibre6 pcalibre1 pcalibre"/> briefly in <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a>, but let’s learn about its main features here:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Simplicity</strong>: It offers<a id="_idIndexMarker405" class="calibre6 pcalibre1 pcalibre"/> an easy setup process and is easy to learn</li>
<li class="calibre14"><strong class="bold">Efficiency</strong>: It is lightweight as it doesn’t rely on reflection</li>
<li class="calibre14"><strong class="bold">Kotlin-centric</strong>: Designed specifically for Kotlin, it leverages Kotlin-specific features such as extension<a id="_idIndexMarker406" class="calibre6 pcalibre1 pcalibre"/> functions, <strong class="bold">domain-specific languages</strong> (<strong class="bold">DSLs</strong>), and property delegation</li>
<li class="calibre14"><strong class="bold">Scope management</strong>: It has a clear way to manage the life cycle of injected instances</li>
<li class="calibre14"><strong class="bold">Integration</strong>: It provides seamless integration with popular frameworks, such as ViewModel, Coroutines, and others</li>
<li class="calibre14"><strong class="bold">Testing</strong>: It includes tools to simplify testing by allowing dependencies to be mocked or overridden</li>
<li class="calibre14"><strong class="bold">DSL configuration</strong>: Koin uses a more readable and concise form of configuration</li>
</ul>
<p class="calibre3">Let’s prepare <a id="_idIndexMarker407" class="calibre6 pcalibre1 pcalibre"/>Koin for this project so that we can use it in the following sections and chapters.</p>
<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor096" class="calibre6 pcalibre1 pcalibre"/>Setting up Koin</h2>
<p class="calibre3">To start <a id="_idIndexMarker408" class="calibre6 pcalibre1 pcalibre"/>setting <a id="_idIndexMarker409" class="calibre6 pcalibre1 pcalibre"/>up Koin, we need to add the necessary dependency to our version catalog. To do that, you will add the necessary Koin dependencies to the <code>libs.versions.toml</code> file. Be sure to use the latest version of Koin and replace <code>latest-version</code> with the actual version number:</p>
<pre class="source-code">
[versions]
...
koin = "latest-version"
[libraries]
...
koin-core = { group = "io.insert-koin", name = "koin-core", version.ref = "koin" }
koin-android = { group = "io.insert-koin", name = "koin-android", version.ref = "koin" }
koin-androidx-navigation = { group = "io.insert-koin", name = "koin-androidx-navigation", version.ref = "koin" }
koin-androidx-compose = { group = "io.insert-koin", name = "koin-androidx-compose", version.ref = "koin" }
koin-test = { group = "io.insert-koin", name = "koin-test", version.ref = "koin" }
koin-test-junit4 = { group = "io.insert-koin", name = "koin-test-junit4", version.ref = "koin" }</pre> <p class="calibre3">As we can see, we <a id="_idIndexMarker410" class="calibre6 pcalibre1 pcalibre"/>have added the <code>koin</code> version in the <code>versions</code> block and the packages we might need in the <code>libraries</code> block.</p>
<p class="calibre3">Now, we need to add the dependencies to our module’s Gradle files. To do this, add the following lines to the dependency Lambda:</p>
<pre class="source-code">
dependencies {
   …
    implementation(libs.koin.core)
    implementation(libs.koin.android)
    implementation(libs.koin.androidx.compose)
    implementation(libs.koin.androidx.navigation)
    ...
}</pre> <p class="calibre3">Adding these <a id="_idIndexMarker411" class="calibre6 pcalibre1 pcalibre"/>dependencies will allow us to use Koin in our modules. As a start, you should add them to the <code>:app</code>, <code>:feature:newsfeed</code>, and <code>:feature:stories</code> modules, which are the modules we are going to work with in this and the following two chapters.</p>
<p class="calibre3">Next, we need to create our <code>Application</code> class. Koin is typically initialized in your <code>Application</code> class. As we don’t have one already, we will create one as part of the <code>:app</code> module and<a id="_idIndexMarker412" class="calibre6 pcalibre1 pcalibre"/> add the following code:</p>
<pre class="source-code">
class PacktagramApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidLogger()
            androidContext(this@PacktagramApplication)
            modules(appModule)
        }
    }
}</pre> <p class="calibre3">In the <code>startKoin</code> block, we’ve specified that we want to use the Android logger (<code>androidLogger()</code>). The <code>androidLogger()</code> function is a part of Koin’s API and configures Koin to use Android’s native logging mechanism. Essentially, it enables Koin to print logs to Logcat.</p>
<p class="calibre3">When you initialize Koin with <code>androidLogger()</code>, you will be able to see important information about Koin’s behavior and operations in Logcat while debugging your application. This includes details such as which dependencies are being created, if any errors occur during the creation of a dependency, the life cycle of scopes, and more.</p>
<p class="calibre3">After that, we provided the Android context (<code>androidContext(this@MyApplication)</code>) to the framework in case we need it to create any of our dependencies.</p>
<p class="calibre3">The next line is <code>modules(appModule)</code>. This function is where you’ll list the modules that contain your <a id="_idIndexMarker413" class="calibre6 pcalibre1 pcalibre"/>project’s dependencies <a id="_idIndexMarker414" class="calibre6 pcalibre1 pcalibre"/>and the instructions to provide them. To start, we will only have <code>appModule</code>, which we can create like so:</p>
<pre class="source-code">
import org.koin.dsl.module
val appModule = module {
...
}</pre> <p class="calibre3">Inside the <code>module</code> block, we should define our dependencies once we start building them. Here’s an example:</p>
<pre class="source-code">
val exampleModule = module {
    single { MyDataSource(get()) }
    single { MyRepository(get()) }
    factory { MyUseCase(get()) }
    viewModel { MyViewModel(get()) }
}</pre> <p class="calibre3">The <code>module</code> function in Koin is used to define a module where you specify how to create your various dependencies. Inside a module, you can use functions such as <code>single</code>, <code>factory</code>, and <code>viewModel</code> to create instances of your dependencies.</p>
<p class="calibre3">Here’s a breakdown of these functions:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">single</strong>: This function creates a singleton object of the specified type. Once this object is created, the same instance will be provided every time this type of object is needed. For example, <strong class="source-inline1">single { MyDataSource(get()) }</strong> defines how to create a single instance of <strong class="source-inline1">MyDataSource</strong>. The <strong class="source-inline1">get()</strong> function inside the curly braces is a Koin function that fetches any required dependencies for creating the <strong class="source-inline1">MyDataSource</strong> instance.</li>
<li class="calibre14"><strong class="source-inline1">factory</strong>: This function is used when you want to create a new instance every time the dependency is needed, instead of reusing the same instance. For instance, <strong class="source-inline1">factory { MyUseCase(get()) }</strong> creates a new <strong class="source-inline1">MyUseCase</strong> object every<a id="_idIndexMarker415" class="calibre6 pcalibre1 pcalibre"/> time a <strong class="source-inline1">MyUseCase</strong> instance is requested.</li>
<li class="calibre14"><strong class="source-inline1">viewModel</strong>: This function is used to create instances of <strong class="source-inline1">ViewModel</strong> classes. It works like <strong class="source-inline1">single</strong> but is specialized for Android’s <strong class="source-inline1">ViewModel</strong> instances. All <strong class="source-inline1">ViewModel</strong> instances are tied to an activity or fragment life cycle and can survive configuration changes, such as screen rotation. For instance, <strong class="source-inline1">viewModel { MyViewModel(get()) }</strong> defines how to create an instance of <strong class="source-inline1">MyViewModel</strong>.</li>
<li class="calibre14"><strong class="source-inline1">bind</strong>: This function is used alongside <strong class="source-inline1">single</strong>, <strong class="source-inline1">factory</strong>, or <strong class="source-inline1">scoped</strong> to provide additional interfaces this class can fulfill. For example, if the <strong class="source-inline1">MyImplementation</strong> class implements <strong class="source-inline1">MyInterface</strong>, you could enter the following:<pre class="source-code">
single { MyImplementation() } bind MyInterface::class</pre><p class="calibre3">The <code>get()</code> function that you can see in the definitions is a Koin function that automatically fetches the required dependencies. For example, if <code>MyDataSource</code> has a dependency on a <code>MyApi</code> instance, then <code>get()</code> will fetch that <code>MyApi</code> instance, provided that it has been defined somewhere in the Koin modules.</p></li> </ul>
<p class="calibre3">Returning to our project, we are going to leave the <code>appModule</code> empty for now – we will complete it<a id="_idIndexMarker416" class="calibre6 pcalibre1 pcalibre"/> once we start creating new<a id="_idIndexMarker417" class="calibre6 pcalibre1 pcalibre"/> components.</p>
<p class="calibre3">Talking of components, let’s start with the UI we need to show the stories screen.</p>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor097" class="calibre6 pcalibre1 pcalibre"/>Creating the stories screen</h1>
<p class="calibre3">In this section, we’ll focus <a id="_idIndexMarker418" class="calibre6 pcalibre1 pcalibre"/>on developing a feature for creating<a id="_idIndexMarker419" class="calibre6 pcalibre1 pcalibre"/> and editing new stories within our stories feature. We’ll begin by writing a <code>StoryEditorScreen</code> composable, along with its corresponding <code>ViewModel</code>, aptly named <code>StoryEditorViewModel</code>. Although this <code>ViewModel</code> will initially have limited functionality, we’ll expand upon it in subsequent chapters.</p>
<p class="calibre3">Let’s start creating our <code>ViewModel</code>, as follows:</p>
<pre class="source-code">
class StoryEditorViewModel: ViewModel() {
    private val _isEditing = MutableStateFlow(true)
    val isEditing: StateFlow&lt;Boolean&gt; = _isEditing
}</pre> <p class="calibre3">In the preceding code, we are declaring <code>StoryEditorViewModel</code> and adding a property that will indicate if our screen is in edit mode or not. Edit mode will be used when the user has taken a photo or a video and wants to add more components to it.</p>
<p class="calibre3">Now, we need to take care of the dependency injection of this <code>ViewModel</code> as it must be accessible from the screen we are about to create. We can create <code>storyModule</code> in<code>:feature:story</code> to be able to provide it, as follows:</p>
<pre class="source-code">
val storyModule = module {
    viewModel&lt;StoryEditorViewModel&gt;()
}</pre> <p class="calibre3">Here, we <a id="_idIndexMarker420" class="calibre6 pcalibre1 pcalibre"/>are just<a id="_idIndexMarker421" class="calibre6 pcalibre1 pcalibre"/> telling Koin that it needs to provide <code>StoryEditorViewModel</code> where it is needed.</p>
<p class="calibre3">We also need to add this new module to the <code>PacktagramApplication</code> Koin initialization:</p>
<pre class="source-code">
class PacktagramApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidLogger()
            androidContext(this@PacktagramApplication)
            modules(appModule, storyModule)
        }
    }
}</pre> <p class="calibre3">In the <code>modules(appModule, storyModule)</code> line, we have included <code>storyModule</code> to provide all the dependencies that we’ll need in the stories feature.</p>
<p class="calibre3">Now, we are ready to start with the Jetpack Compose magic and create <code>StoryEditorScreen</code>. This screen will have <code>viewModel</code> as a dependency and handle <code>TopAppBar</code> and a new composable, <code>StoryContent</code>, that will hold the main functionality of the<a id="_idIndexMarker422" class="calibre6 pcalibre1 pcalibre"/> story <a id="_idIndexMarker423" class="calibre6 pcalibre1 pcalibre"/>creation and edition. We can create <code>StoryEditorScreen</code> as follows:</p>
<pre class="source-code">
@Preview
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun StoryEditorScreen(
    viewModel: StoryEditorViewModel = koinViewModel()
) {
    val isEditing = viewModel.isEditing.collectAsState()
    Column(modifier = Modifier.fillMaxSize()) {
        if (isEditing.value) {
            TopAppBar(title = { Text(text = "Create Story") })
        }
        StoryContent(isEditing.value)
    }
}</pre> <p class="calibre3">As we can see, the <code>StoryEditorScreen</code> composable receives <code>StoryEditorViewModel</code> as a parameter, which provides data and functionality for this screen. This <code>ViewModel</code> is provided by Koin, using the <code>koinViewModel</code> function.</p>
<p class="calibre3">Next, <code>isEditing</code> is a state derived from the <code>isEditing</code> state flow of <code>ViewModel</code>. This state will represent whether the user is in the process of editing a story or not. The <code>collectAsState()</code> function collects the latest value from the state flow and represents it as a state in Compose. Whenever the <code>isEditing</code> state flow emits a new value, the UI will recompose to reflect the new state.</p>
<p class="calibre3">Inside <code>StoryEditorScreen</code>, there’s a <code>Column</code> composable that takes up the maximum size of the screen. A <code>Column</code> composable allows us to arrange its children vertically. Inside this <code>Column</code>, there’s a condition to check the <code>isEditing</code> state. If <code>isEditing</code> is true, <code>TopAppBar</code> will be shown with <code>TopAppBar</code> is a composable that represents a Material Design App Bar and is generally placed at the top of the screen – this App Bar will only be shown when the user is in the editing state.</p>
<p class="calibre3">The <code>StoryContent</code> composable is then included in <code>Column</code>, outside of the condition for <code>isEditing</code>. This means that <code>StoryContent</code> will always be shown, regardless of whether the user is in editing mode or not. The <code>isEditing</code> state is passed to <code>StoryContent</code> to inform it of the current editing status. Let’s work on this composable now.</p>
<p class="calibre3">This composable<a id="_idIndexMarker424" class="calibre6 pcalibre1 pcalibre"/> should have a background that <a id="_idIndexMarker425" class="calibre6 pcalibre1 pcalibre"/>will be the image or the video the user wants to include in the story and will take all the space on the screen. By doing this, the options on the screen will be different, depending on whether we’re capturing the media or editing it. Here’s the code for this composable:</p>
<pre class="source-code">
@Composable
fun StoryContent(
    isEditing: Boolean = false,
    modifier: Modifier = Modifier
) {
    Box(modifier = Modifier.fillMaxSize().padding(20.dp)) {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .wrapContentHeight()
        ) {
            Button(
                onClick = { /*Handle back*/},
                modifier =
                    Modifier.align(Alignment.TopStart)
            ) {
                Image(
                    painter = painterResource(id =
                        R.drawable.ic_arrow_back),
                    contentDescription = "Back button")
            }
            if (isEditing) {
                Button(
                    onClick =
                        { /* Handle create caption */ },
                    modifier =
                        Modifier.align(Alignment.TopEnd)
                ) {
                    Image(
                        painter = painterResource(id =
                            R.drawable.ic_caption),
                        contentDescription = "Create label"
                    )
                }
            }
    }
        Image(
            painter = painterResource(id =
                R.drawable.ic_default_image),
            modifier = Modifier.fillMaxSize(),
            contentDescription = "Default image"
        )
        Row(
            modifier = Modifier
                .wrapContentHeight()
                .align(Alignment.BottomCenter)
        ) {
            if (isEditing) {
                Button(
                    onClick =
                        { /* Handle create caption */ }
                ) {
                    Text(stringResource(id =
                        R.string.share_story))
                }
            } else {
                OutlinedButton(
                    onClick =
                        { /* Handle take a photo */ },
                    modifier= Modifier.size(50.dp),
                    shape = CircleShape,
                    border= BorderStroke(4.dp,
                        MaterialTheme.colorScheme.primary),
                    contentPadding = PaddingValues(0.dp),
                    colors =
                       ButtonDefaults.outlinedButtonColors(
                       contentColor =
                       MaterialTheme.colorScheme.primary)
                ) {
                }
            }
        }
    }
}</pre> <p class="calibre3">Let’s break down this code:</p>
<ul class="calibre15">
<li class="calibre14">The outermost <strong class="source-inline1">Box</strong> is the main container, which takes up the maximum size of its parent<a id="_idIndexMarker426" class="calibre6 pcalibre1 pcalibre"/> and <a id="_idIndexMarker427" class="calibre6 pcalibre1 pcalibre"/>adds a padding of <strong class="source-inline1">20.dp</strong>.</li>
<li class="calibre14">The first child of <strong class="source-inline1">Box</strong> is another <strong class="source-inline1">Box</strong> that is set to take up the full width and wrap the content height.</li>
<li class="calibre14">Inside this <strong class="source-inline1">Box</strong>, there is a <strong class="source-inline1">Button</strong> component aligned to the top-start corner of its parent <strong class="source-inline1">Box</strong>. This button is used to handle a back navigation action. Inside this button is an <strong class="source-inline1">Image</strong> component with an arrow icon.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">The terms “start” and “end” are used for layout positioning to ensure better support for both <strong class="bold">left-to-right</strong> (<strong class="bold">LTR</strong>) and <strong class="bold">right-to-left</strong> (<strong class="bold">RTL</strong>) languages. When you use the “start” and “end” attributes <a id="_idIndexMarker428" class="calibre6 pcalibre1 pcalibre"/>in your<a id="_idIndexMarker429" class="calibre6 pcalibre1 pcalibre"/> layout, Android automatically adjusts the orientation based on the text direction of the current locale. In LTR languages such as English, “start” maps to “left” and “end” maps to “right,” while in RTL languages such as Arabic, “start” maps to “right” and “end” maps to “left.” This approach simplifies the process of localizing your app for multiple languages and text directions.</p>
<ul class="calibre15">
<li class="calibre14">If the <strong class="source-inline1">isEditing</strong> flag is true, an additional <strong class="source-inline1">Button</strong> is added to <strong class="source-inline1">Box</strong>. This button, which is aligned to the top end (the right, in LTR layouts) of its parent <strong class="source-inline1">Box</strong>, allows users to create a caption for their story. The button uses an image of a caption icon to communicate its function.</li>
<li class="calibre14">The next child of the outermost <strong class="source-inline1">Box</strong> is <strong class="source-inline1">Image</strong>, which displays a default image. This <strong class="source-inline1">Image</strong> takes up the maximum size of <strong class="source-inline1">Box</strong>, signifying that this image will be the main focus of this screen.</li>
<li class="calibre14">The last child of the outermost <strong class="source-inline1">Box</strong> is a Row that’s aligned to the bottom center of <strong class="source-inline1">Box</strong>. This <strong class="source-inline1">Row</strong> contains two different buttons that are displayed conditionally, based on the <strong class="source-inline1">isEditing</strong> flag.</li>
<li class="calibre14">If <strong class="source-inline1">isEditing</strong> is false, <strong class="source-inline1">OutlinedButton</strong> is shown. This button, styled to look like a <a id="_idIndexMarker430" class="calibre6 pcalibre1 pcalibre"/>circular<a id="_idIndexMarker431" class="calibre6 pcalibre1 pcalibre"/> button with a border, allows the user to take a photo. Note that the actual implementation for taking a photo is not included in the provided code and should be handled in the <strong class="source-inline1">onClick</strong> function.</li>
<li class="calibre14">If <strong class="source-inline1">isEditing</strong> is true, a <strong class="source-inline1">Button</strong> component appears instead. This button, labeled <strong class="bold">Share Story</strong>, is intended to allow the user to share the created story. As you can see, it is using <strong class="source-inline1">stringResource</strong> with a key of <strong class="source-inline1">R.string.share_story</strong>, so we should add it to <strong class="source-inline1">string.xml</strong>. Again, the actual implementation of the share functionality should be handled in the <strong class="source-inline1">onClick</strong> function.</li>
</ul>
<p class="calibre3">With the previous code, when the screen is in editing mode, it should look like this:</p>
<div><div><img alt="Figure 4.4: The story screen in edit mode" src="img/B19443_04_004.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4: The story screen in edit mode</p>
<p class="calibre3">Otherwise, when it is not<a id="_idIndexMarker432" class="calibre6 pcalibre1 pcalibre"/> in <a id="_idIndexMarker433" class="calibre6 pcalibre1 pcalibre"/>editing mode, it will look like this:</p>
<div><div><img alt="Figure 4.5: The story screen when it is not in edit mode" src="img/B19443_04_005.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5: The story screen when it is not in edit mode</p>
<p class="calibre3">As we can see, it is easy and intuitive to add or remove composables conditionally from a view.</p>
<p class="calibre3">With that, we’ve<a id="_idIndexMarker434" class="calibre6 pcalibre1 pcalibre"/> finished <a id="_idIndexMarker435" class="calibre6 pcalibre1 pcalibre"/>the story screen, until we add more functionality in the next chapters to capture photos and video. Let’s continue with the newsfeed user interface.</p>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"/>Creating the newsfeed screen and its components</h1>
<p class="calibre3">The newsfeed is<a id="_idIndexMarker436" class="calibre6 pcalibre1 pcalibre"/> the main screen of our Packtagram <a id="_idIndexMarker437" class="calibre6 pcalibre1 pcalibre"/>app and is where the user will see the latest posts from their friends. It is structured using several components:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Title bar</strong>: This is where the user can access the messaging feature</li>
<li class="calibre14"><strong class="bold">List of posts</strong>: The list of posts shown in our app</li>
<li class="calibre14"><strong class="bold">Bottom bar</strong>: This is used to navigate to different sections in the app</li>
</ul>
<p class="calibre3">We are going to start structuring our newsfeed screen by creating a <code>MainScreen</code> composable. Here, we will define the user interface for the main view in our Packtagram app.</p>
<p class="calibre3">This <code>MainScreen</code> composable will have a <code>Scaffold</code> composable as its main component. Here, we will define the title bar and the bottom bar with the different options for navigation:</p>
<pre class="source-code">
@Composable
fun MainScreen(
    modifier: Modifier = Modifier,
){
    val tabs = generateTabs()
    val selectedIndex = remember { mutableStateOf(0) }
    val pagerState = rememberPagerState(initialPage = 0)</pre> <p class="calibre3">Here, we are starting with the composable declaration and the properties we need to handle the tabs that we are going to use in the <code>bottomBar</code> navigation.</p>
<p class="calibre3">Now, it’s time to add the <code>Scaffold</code> composable. This is where we will add the <code>title</code> and <code>bottomBar</code>. Let’s start with the <code>title</code>:</p>
<pre class="source-code">
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(stringResource(R.string.app_name))
                },
                actions = {
                    IconButton(onClick =
                    { /* Menu action */ }) {
                        Icon(Icons.Rounded.Send,
                        contentDescription = "Messages")
                    }
                }
            )
        },</pre> <p class="calibre3">With that, we have<a id="_idIndexMarker438" class="calibre6 pcalibre1 pcalibre"/> created<a id="_idIndexMarker439" class="calibre6 pcalibre1 pcalibre"/> the <code>Scaffold</code> composable and added <code>TopAppBar</code>. We used this in <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a>, but it is important to remember that a container is generally used to hold the title of the screen and any actions relevant to the screen’s context. Here, <code>TopAppBar</code> takes in two important lambdas:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">title</strong>: This is where you define the title of the App Bar. In this case, it’s displaying a <strong class="source-inline1">Text</strong> composable that fetches a string resource – that is, the name of the app (Packtagram).</li>
<li class="calibre14"><strong class="source-inline1">actions</strong>: This is where we define the actions that will appear on the right-hand side of the App Bar. Actions are typically represented with icons and are used to perform functions relevant to the current screen. In this case, there’s a single <strong class="source-inline1">IconButton</strong> with an envelope icon (which, when clicked, would navigate the user to the messaging screen).</li>
</ul>
<p class="calibre3">The next step is to add the <code>BottomBar</code>:</p>
<pre class="source-code">
        bottomBar = {
            TabRow(selectedTabIndex = selectedIndex.value)
            {
                tabs.forEachIndexed { index, _ -&gt;
                    Tab(
                        icon = { Icon(tabs[index].icon,
                            contentDescription = null) },
                        selected = index ==
                            selectedIndex.value,
                        onClick = {
                            selectedIndex.value = index
                        }
                    )
                }
            }
        },</pre> <p class="calibre3">Here, <code>BottomBar</code> is usually <a id="_idIndexMarker440" class="calibre6 pcalibre1 pcalibre"/>where <a id="_idIndexMarker441" class="calibre6 pcalibre1 pcalibre"/>navigation controls for the app are placed. In this case, <code>TabRow</code> is used, which is a container for <code>Tab</code> composables. The main Lambda of <code>TabRow</code> is used to generate the <code>Tab</code> elements. It iterates through each <code>TabItem</code> in tabs (which is a list of <code>TabItem</code> objects generated by <code>generateTabs()</code>), and for each one, it creates a <code>Tab</code> element. The <code>Tab</code> element is provided with an icon from <code>TabItem</code>, regardless of whether it’s selected (based on if its index matches <code>selectedIndex.value</code>), and an <code>onClick</code> function that sets <code>selectedIndex.value</code> to the index of the clicked <code>Tab</code>.</p>
<p class="calibre3">Now, we need to add <a id="_idIndexMarker442" class="calibre6 pcalibre1 pcalibre"/>the<a id="_idIndexMarker443" class="calibre6 pcalibre1 pcalibre"/> content to the <code>Scaffold</code> composable:</p>
<pre class="source-code">
        content = { innerPadding -&gt;
            HorizontalPager(
                modifier = Modifier.padding(innerPadding),
                pageCount = tabs.size,
                state = pagerState
            ) { index -&gt;
                when (index) {
                    0 -&gt; {
                        NewsFeed()
                    }
                    1 -&gt; {
                        //Search
                    }
                    2-&gt; {
                        // New publication
                    }
                    3-&gt; {
                        // Reels
                    }
                    4-&gt; {
                        // Profile
                    }
                }
            }
            LaunchedEffect(selectedIndex.value) {
                pagerState.animateScrollToPage(
                selectedIndex.value)
            }
        },
    )
}</pre> <p class="calibre3">The <code>content</code> section is where the main content of your app goes. In this case, the content is a <code>HorizontalPager</code> composable with pages corresponding to the tabs in the bottom bar.</p>
<p class="calibre3">The main Lambda in <code>HorizontalPager</code> is used to generate each page. The content of the page is determined by the index provided to the Lambda: when <code>index</code> is <code>0</code>, <code>NewsFeed()</code> is displayed, and placeholders are left for the rest of the navigation options.</p>
<p class="calibre3">There’s another Lambda inside the <code>content</code> section: the <code>LaunchedEffect</code> block. This is essentially a side effect that is performed when <code>selectedIndex.value</code> changes. In this case, it<a id="_idIndexMarker444" class="calibre6 pcalibre1 pcalibre"/> triggers<a id="_idIndexMarker445" class="calibre6 pcalibre1 pcalibre"/> an animation that scrolls <code>HorizontalPager</code> to the page that corresponds to the selected index.</p>
<p class="calibre3">Now that <code>MainScreen</code> is ready, we can work on the <code>NewsFeed</code> list.</p>
</div>


<div><h2 id="_idParaDest-98" class="calibre7"><a id="_idTextAnchor099" class="calibre6 pcalibre1 pcalibre"/>Creating the NewsFeed list</h2>
<p class="calibre3">First, we need to<a id="_idIndexMarker446" class="calibre6 pcalibre1 pcalibre"/> create the <code>ViewModel</code> class <a id="_idIndexMarker447" class="calibre6 pcalibre1 pcalibre"/>that we are going to use in our <code>NewsFeed</code> composable. We will call it <code>NewsFeedViewModel</code> and add the following code:</p>
<pre class="source-code">
class NewsFeedViewModel : ViewModel() {
    private val _posts =
        MutableStateFlow&lt;List&lt;Post&gt;&gt;(emptyList())
    val posts: StateFlow&lt;List&lt;Post&gt;&gt; get() = _posts
}</pre> <p class="calibre3">Here, we are initializing <code>NewsFeedViewModel</code>. For now, we will only have a public property. We’ll use this to gather information so that we can render the posts in the user interface.</p>
<p class="calibre3">Now, it is time to handle the dependency injection for this <code>NewsFeedViewModel</code>. We are creating a dependency injection module per app module. So, in this case, since we are working on the newsfeed module, we will create a new dependency injection module to provide <code>NewsFeedViewModel</code>:</p>
<pre class="source-code">
val newsFeedModule = module {
    viewModel&lt;NewsFeedViewModel&gt;()
}</pre> <p class="calibre3">Then, we will <a id="_idIndexMarker448" class="calibre6 pcalibre1 pcalibre"/>add it to the modules<a id="_idIndexMarker449" class="calibre6 pcalibre1 pcalibre"/> list in <code>PacktagramApplication</code>:</p>
<pre class="source-code">
class PacktagramApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
...
            modules(
                appModule,
                storyModule,
                <strong class="bold1">newsFeedModule</strong>
            )
        }
    }
}</pre> <p class="calibre3">Here, we’ve added <code>newsFeedModule</code> to the already existing modules list in <code>PacktagramApplication</code>.</p>
<p class="calibre3">Now, we need to create the <code>NewsFeed</code> composable, which will include the list of posts:</p>
<pre class="source-code">
@Composable
fun NewsFeed(
    modifier: Modifier = Modifier,
    viewModel: NewsFeedViewModel = koinViewModel()
) {
    LazyColumn{
        itemsIndexed(viewModel.posts){ _, post -&gt;
            PostItem(post = post)
        }
    }
}</pre> <p class="calibre3">Here, we can use <code>LazyColumn</code> to render the list of posts. As we can see, we will need a <code>PostItem</code> composable to <a id="_idIndexMarker450" class="calibre6 pcalibre1 pcalibre"/>draw <a id="_idIndexMarker451" class="calibre6 pcalibre1 pcalibre"/>every list item. We will build this in the following section.</p>
<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor100" class="calibre6 pcalibre1 pcalibre"/>Creating the PostItem composable</h2>
<p class="calibre3">Our <code>PostItem</code> composable <a id="_idIndexMarker452" class="calibre6 pcalibre1 pcalibre"/>will <a id="_idIndexMarker453" class="calibre6 pcalibre1 pcalibre"/>include all the components needed to render a post. We will need the following:</p>
<ul class="calibre15">
<li class="calibre14">A title bar with the picture and name of the author</li>
<li class="calibre14">The media content (a picture initially but this could also be a video)</li>
<li class="calibre14">An action bar with several actions (like, share, and so on)</li>
<li class="calibre14">A label with the likes count</li>
<li class="calibre14">A caption written by the author</li>
<li class="calibre14">The timestamp of the post’s publication</li>
</ul>
<p class="calibre3">Following those requirements, this is what our <code>PostItem</code> composable will look like:</p>
<pre class="source-code">
@Composable
fun PostItem(
    post: Post
){
    Column{
        Spacer(modifier = Modifier.height(2.dp))
        TitleBar(post = post)
        MediaContent(post = post)
        ActionsBar()
        LikesCount(post = post)
        Caption(post = post)
        Spacer(modifier = Modifier.height(2.dp))
        CommentsCount(post = post)
        Spacer(modifier = Modifier.height(4.dp))
        TimeStamp(post = post)
        Spacer(modifier = Modifier.height(10.dp))
    }
}</pre> <p class="calibre3">As you can see, it is very readable and almost self-explanatory. We will create a <code>Column</code> composable <a id="_idIndexMarker454" class="calibre6 pcalibre1 pcalibre"/>and place <a id="_idIndexMarker455" class="calibre6 pcalibre1 pcalibre"/>every one of the composables we need vertically, leaving some spaces between as needed.</p>
<p class="calibre3">Now, let’s create the composables we’ll need. We will start in order, with <code>TitleBar</code>:</p>
<pre class="source-code">
@Composable
fun TitleBar(
    modifier: Modifier = Modifier,
    post: Post
){
    Row(
        modifier = modifier
            .fillMaxWidth()
            .height(56.dp)
        ,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Spacer(modifier = modifier.width(5.dp))
        Image(
            modifier = modifier
                .size(40.dp)
                .weight(1f),
            painter = painterResource(id =
                post.user.image),
            contentDescription =
                "User ${post.user.name} avatar"
        )
        Text(
            text = post.user.name,
            modifier = modifier
                .weight(8f)
                .padding(start = 10.dp),
            fontWeight = FontWeight.Bold
        )
        IconButton(onClick = { /* Menu options */}) {
            Icon(
                Icons.Outlined.MoreVert,
                "More options"
            )
        }
    }
}</pre> <p class="calibre3">The base for this composable will be a <code>Row</code> composable as it will arrange its children in a horizontal sequence. The <code>verticalAlignment</code> parameter is set to <code>Alignment.CenterVertically</code> to align the items in the row vertically in the center.</p>
<p class="calibre3">Here’s a description of <a id="_idIndexMarker456" class="calibre6 pcalibre1 pcalibre"/>the children <a id="_idIndexMarker457" class="calibre6 pcalibre1 pcalibre"/>composables that were used:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Spacer</strong>: This is used to provide some space on the interface. Here, it provides a width of <strong class="source-inline1">5.dp</strong> at the start of the row.</li>
<li class="calibre14"><strong class="source-inline1">Image</strong>: This is an image composable that is being used to display the user’s profile picture. The image source is taken from the <strong class="source-inline1">Post</strong> object that was passed in.</li>
<li class="calibre14"><strong class="source-inline1">Text</strong>: This displays the user’s name and takes the name from the <strong class="source-inline1">Post</strong> object that was passed in. The <strong class="source-inline1">fontWeight</strong> parameter is set to <strong class="source-inline1">FontWeight.Bold</strong> to make the text bold.</li>
<li class="calibre14"><strong class="source-inline1">IconButton</strong>: This is a button with an icon. The <strong class="source-inline1">onClick</strong> parameter is a Lambda function that gets called when the button is clicked. In this case, the function is empty, but this is where you would put code to handle the button press. The <strong class="source-inline1">Icon</strong> element inside is used to display the <strong class="source-inline1">more-options</strong> icon.</li>
</ul>
<p class="calibre3">Now that <code>TitleBar</code> is ready, it’s time for the <code>MediaContent</code> composable, which will display the content that the user has posted:</p>
<pre class="source-code">
@Composable
fun MediaContent (
    modifier: Modifier = Modifier,
    post: Post
){
    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(300.dp),
        contentAlignment = Alignment.Center,
        ) {
        Image(
            modifier = Modifier
                .fillMaxSize(),
            painter = rememberImagePainter(post.image),
            contentDescription = null
        )
    }
}</pre> <p class="calibre3">The preceding code generates<a id="_idIndexMarker458" class="calibre6 pcalibre1 pcalibre"/> a box <a id="_idIndexMarker459" class="calibre6 pcalibre1 pcalibre"/>that contains an image as this composable is used to display the main image content of a post. These are the main components:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Box</strong>: This is a layout composable that stacks its children. In this case, it’s used to hold an <strong class="source-inline1">Image</strong> component. The <strong class="source-inline1">contentAlignment</strong> parameter is set to <strong class="source-inline1">Alignment.Center</strong> to center the image in the box and has a modifier applied to it to fill the maximum width and to set a height of <strong class="source-inline1">300.dp</strong>.</li>
<li class="calibre14"><strong class="source-inline1">Image</strong>: This is an <strong class="source-inline1">Image</strong> composable that’s used to display an image. The image source is taken from the <strong class="source-inline1">Post</strong> object passed in. The modifier is used to ensure the image fills the maximum size of the <strong class="source-inline1">Box</strong> composable. Here, <strong class="source-inline1">rememberImagePainter</strong> is used to load and display the image from a source (such as a URL or a local file), and it’s remembered across recompositions.</li>
</ul>
<p class="calibre3">Now that we’ve completed the <code>MediaContent</code> composable, we will consider <code>ActionsBar</code>, which <a id="_idIndexMarker460" class="calibre6 pcalibre1 pcalibre"/>will provide <a id="_idIndexMarker461" class="calibre6 pcalibre1 pcalibre"/>the instructions to render the action buttons:</p>
<pre class="source-code">
@Composable
fun ActionsBar(
    modifier: Modifier = Modifier,
){
    Column(
        modifier = modifier
            .fillMaxWidth()
            .height(40.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
    ) {
        Row(
            modifier = modifier
                .fillMaxSize()
        ) {
            Row(
                modifier = modifier
                    .fillMaxHeight()
                    .weight(1f)
                ,
                verticalAlignment =
                    Alignment.CenterVertically,
            ) {
                IconButton(onClick = { }) {
                    Icon(
                        imageVector =
                            Icons.Outlined.Favorite,
                        contentDescription = "like",
                        modifier = modifier
                    )
                }
                IconButton(onClick = { }) {
                    Icon(
                        imageVector = Icons.Outlined.Edit,
                        contentDescription = "comment",
                        modifier = modifier
                    )
                }
                IconButton(onClick = { }) {
                    Icon(
                        imageVector = Icons.Outlined.Share,
                        contentDescription = "share",
                        modifier = modifier
                    )
                }
                Row(
                    modifier = modifier
                        .fillMaxHeight()
                        .weight(1f)
                ) {
                }
                Row(
                    modifier = modifier
                        .fillMaxHeight()
                        .weight(1f),
                    verticalAlignment =
                        Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.End
                ) {
                    IconButton(onClick = { }) {
                        Icon(
                            imageVector =
                                Icons.Outlined.Star,
                            contentDescription =
                                "bookmark",
                            )
                    }
                }
            }
        }
    }
}</pre> <p class="calibre3">The preceding code generates a UI that represents the action buttons under a post, similar to those on Instagram where you can like, comment, share, and bookmark a post. Here’s what each part of the function does:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Column</strong>: This creates a column in which you can place other UI elements vertically. The <strong class="source-inline1">horizontalAlignment</strong> parameter is set to <strong class="source-inline1">Alignment.CenterHorizontally</strong>, which centers the elements horizontally in the column.</li>
<li class="calibre14"><strong class="source-inline1">Row</strong>: This creates a row in which other UI elements can be placed horizontally. It fills the maximum size of the parent, which is <strong class="source-inline1">Column</strong>.</li>
<li class="calibre14">The first group of three <strong class="source-inline1">IconButton</strong> composables are in a <strong class="source-inline1">Row</strong> composable and <a id="_idIndexMarker462" class="calibre6 pcalibre1 pcalibre"/>are for<a id="_idIndexMarker463" class="calibre6 pcalibre1 pcalibre"/> the <strong class="source-inline1">Like</strong>, <strong class="source-inline1">Comment</strong>, and <strong class="source-inline1">Share</strong> actions. Each <strong class="source-inline1">IconButton</strong> takes a Lambda for the <strong class="source-inline1">onClick</strong> event, which currently does nothing.</li>
<li class="calibre14">There are then two additional <strong class="source-inline1">Row</strong> composables, both with <strong class="source-inline1">fillMaxHeight().weight(1f)</strong>, that appear to be placeholders, perhaps for adding additional icons in the future.</li>
<li class="calibre14">The final <strong class="source-inline1">Row</strong> composable has an <strong class="source-inline1">IconButton</strong> composable for the <strong class="source-inline1">Bookmark</strong> action. It has <strong class="source-inline1">verticalAlignment</strong> set to <strong class="source-inline1">Alignment.CenterVertically</strong> and <strong class="source-inline1">horizontalArrangement</strong> set to <strong class="source-inline1">Arrangement.End</strong> to position the icon in the center vertically and at the end (right-hand side in LTR layouts) of the available space horizontally.</li>
<li class="calibre14"><strong class="source-inline1">Icon</strong>: Each <strong class="source-inline1">Icon</strong> displays an image and has a <strong class="source-inline1">contentDescription</strong> composable for accessibility purposes. The <strong class="source-inline1">modifier</strong> parameter can be used to adjust the layout or other visual properties of the icon.</li>
</ul>
<p class="calibre3">Having configured the <code>ActionsBar</code> composable to provide a flexible UI layout featuring a range of interactive buttons, our next focus will be the likes count. It’s very straightforward to implement:</p>
<pre class="source-code">
@Composable
fun LikesCount(
    modifier: Modifier = Modifier,
    post: Post
){
    Row(
        modifier = modifier
            .fillMaxWidth()
            .height(30.dp)
            .padding(horizontal = 10.dp)
        ,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = post.likesCount.toString().plus(
                «likes"),
            fontWeight = FontWeight.Bold,
            fontSize = 16.sp
        )
    }
}</pre> <p class="calibre3">The <code>LikesCount</code> function<a id="_idIndexMarker464" class="calibre6 pcalibre1 pcalibre"/> is a <code>Composable</code> function that creates a row to display the number of likes that a post has received. Here’s what each part of the function does:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Row</strong>: This creates a row in which other UI elements can be placed horizontally. It uses the provided modifier to fill the maximum width of the parent container, setting its height to <strong class="source-inline1">30.dp</strong> and adding a padding of <strong class="source-inline1">10.dp</strong> horizontally. The <strong class="source-inline1">verticalAlignment</strong> parameter is set to <strong class="source-inline1">Alignment.CenterVertically</strong>, which centers the elements vertically in the row.</li>
<li class="calibre14"><strong class="source-inline1">Text</strong>: This creates a text element that displays the number of likes that the post has received. It gets the <strong class="source-inline1">likesCount</strong> field from the <strong class="source-inline1">Post</strong> object, converts it into a string, and appends the word <strong class="bold">likes</strong> to the end. It also sets the font weight to bold and the font size to <strong class="source-inline1">16.sp</strong>.</li>
</ul>
<p class="calibre3">The next composable<a id="_idIndexMarker465" class="calibre6 pcalibre1 pcalibre"/> is the<a id="_idIndexMarker466" class="calibre6 pcalibre1 pcalibre"/> caption, which is the text that the user adds to the post:</p>
<pre class="source-code">
@Composable
fun Caption(
    modifier: Modifier = Modifier,
    post: Post
){
    Row(
        modifier = modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .padding(horizontal = 10.dp)
        ,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = buildAnnotatedString {
                val boldStyle = SpanStyle(
                    fontWeight = Bold,
                    fontSize = 14.sp
                )
                val normalStyle = SpanStyle(
                    fontWeight = FontWeight.Normal,
                    fontSize = 14.sp
                )
                pushStyle(boldStyle)
                append(post.user.name)
                append(" ")
                if (post.caption.isNotEmpty()){
                    pushStyle(normalStyle)
                    append(post.caption)
                }
            }
        )
    }
}</pre> <p class="calibre3">Here’s what each part <a id="_idIndexMarker467" class="calibre6 pcalibre1 pcalibre"/>of the<a id="_idIndexMarker468" class="calibre6 pcalibre1 pcalibre"/> function does:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Row</strong>: This creates a row in which other UI elements can be placed horizontally. It uses the provided modifier to fill the maximum width of the parent container, wrap its height to its content, and add a padding of <strong class="source-inline1">10.dp</strong> horizontally. The <strong class="source-inline1">verticalAlignment</strong> parameter is set to <strong class="source-inline1">Alignment.CenterVertically</strong>, which centers the elements vertically in the row.</li>
<li class="calibre14"><strong class="source-inline1">Text</strong>: This creates a text element that displays the caption of the post, preceded by the user’s name. The <strong class="source-inline1">buildAnnotatedString</strong> function is used to build a string with different text styles for different parts. Thanks to that, the user’s name is styled with a bold font weight, and the caption is styled with a normal font weight.</li>
</ul>
<p class="calibre3">Upon completing the <code>Caption</code> composable, let’s tackle the <code>CommentsCount</code> composable:</p>
<pre class="source-code">
@Composable
fun CommentsCount(
    modifier: Modifier = Modifier,
    post: Post
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .padding(horizontal = 10.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = stringResource(R.string.comment_count,
                post.commentsCount),
            fontWeight = FontWeight.Normal,
            fontSize = 14.sp
        )
    }
}</pre> <p class="calibre3">The <code>CommentsCount</code> composable <a id="_idIndexMarker469" class="calibre6 pcalibre1 pcalibre"/>creates <a id="_idIndexMarker470" class="calibre6 pcalibre1 pcalibre"/>a layout to display the number of comments on a post. Here’s what each part of the function does:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Row</strong>: This creates a row in which other UI elements can be placed horizontally. It uses the provided modifier to fill the maximum width of the parent container, wrap its height to its content, and add a padding of <strong class="source-inline1">10.dp</strong> horizontally. The <strong class="source-inline1">verticalAlignment</strong> parameter is set to <strong class="source-inline1">Alignment.CenterVertically</strong>, which centers the elements vertically in the row.</li>
<li class="calibre14"><strong class="source-inline1">Text</strong>: This creates a text element that displays the number of comments. The <strong class="source-inline1">stringResource</strong> function is used to get a string resource, which is a format string that takes a number and inserts it into the correct place to form a string that says <strong class="bold">Read 3 comments</strong>. The string format is then filled in with the number of comments from the <strong class="source-inline1">Post</strong> object.</li>
</ul>
<p class="calibre3">Now that we’ve finished<a id="_idIndexMarker471" class="calibre6 pcalibre1 pcalibre"/> implementing the <code>CommentsCount</code> composable, we will create the <code>TimeStamp</code> composable:</p>
<pre class="source-code">
fun TimeStamp(
    modifier: Modifier = Modifier,
    post: Post
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .padding(horizontal = 10.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = "${post.timeStamp} hours ago ",
            fontSize = 10.sp,
            fontWeight = FontWeight.Light
        )
    }
}</pre> <p class="calibre3">The <code>TimeStamp</code> function is a composable that creates a layout to display the timestamp of a post. Here’s what each part of the function does:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Row</strong>: This creates a row in which other UI elements can be placed horizontally. It uses the provided <strong class="source-inline1">Modifier</strong> value to fill the maximum width of the parent container, wrap<a id="_idIndexMarker472" class="calibre6 pcalibre1 pcalibre"/> its height to<a id="_idIndexMarker473" class="calibre6 pcalibre1 pcalibre"/> its content, and add a padding of <strong class="source-inline1">10.dp</strong> horizontally. The <strong class="source-inline1">verticalAlignment</strong> parameter is set to <strong class="source-inline1">Alignment.CenterVertically</strong>, centering the elements vertically in the row.</li>
<li class="calibre14"><strong class="source-inline1">Text</strong>: This creates a text element that displays the timestamp. The <strong class="source-inline1">text</strong> parameter of this function is set to a string that includes the <strong class="source-inline1">timeStamp</strong> attribute from the <strong class="source-inline1">Post</strong> object. The <strong class="source-inline1">fontSize</strong> and <strong class="source-inline1">fontWeight</strong> parameters set the size and weight of the font to <strong class="source-inline1">10.sp</strong> and <strong class="source-inline1">FontWeight.Light</strong>, respectively.</li>
</ul>
<p class="calibre3">With this composable, we have finished the <code>Post</code> composable components. If we do a preview with fake data, we’ll see the following screen:</p>
<div><div><img alt="Figure 4.6: Newsfeed screen" src="img/B19443_04_006.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6: Newsfeed screen</p>
<p class="calibre3">Now, it is time <a id="_idIndexMarker474" class="calibre6 pcalibre1 pcalibre"/>to implement<a id="_idIndexMarker475" class="calibre6 pcalibre1 pcalibre"/> a way to populate the information needed from the backend.</p>
<h1 id="_idParaDest-100" class="calibre5"><a id="_idTextAnchor101" class="calibre6 pcalibre1 pcalibre"/>Using Retrofit and Moshi to retrieve newsfeed information</h1>
<p class="calibre3">In this section, we’re <a id="_idIndexMarker476" class="calibre6 pcalibre1 pcalibre"/>going to <a id="_idIndexMarker477" class="calibre6 pcalibre1 pcalibre"/>prepare our app so that it can retrieve the newsfeed information from the backend. To do that, we’ll need to create an HTTP client that handles the calls to the backend services. Since we used <code>ktor</code> in our first project, we are going to take a different approach for this one<a id="_idIndexMarker478" class="calibre6 pcalibre1 pcalibre"/> and use <strong class="bold">Retrofit</strong>.</p>
<p class="calibre3">Retrofit is a type-safe HTTP client for Android and Java (which is completely compatible with Kotlin). Retrofit makes it easy to connect to a REST web service by translating the API into Kotlin or Java interfaces. Here are some of its main features:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Easy to use</strong>: Retrofit <a id="_idIndexMarker479" class="calibre6 pcalibre1 pcalibre"/>turns your HTTP API into a Kotlin or Java interface. All you have to do is define the API’s URL and method (<strong class="source-inline1">GET</strong>, <strong class="source-inline1">POST</strong>, and so on) using annotations. Retrofit will automatically convert the HTTP responses into data objects.</li>
<li class="calibre14"><strong class="bold">Type conversion</strong>: By default, Retrofit can only deserialize HTTP bodies into OkHttp’s <strong class="source-inline1">ResponseBody</strong> type and it can only accept its <strong class="source-inline1">RequestBody</strong> type for <strong class="source-inline1">@Body</strong>. Converters can be added to support other types. For example, a JSON converter can be used to convert the API’s responses into Kotlin or Java objects automatically.</li>
<li class="calibre14"><strong class="bold">HTTP methods annotations</strong>: You can use annotations to describe HTTP methods such as <strong class="source-inline1">GET</strong>, <strong class="source-inline1">POST</strong>, <strong class="source-inline1">DELETE</strong>, <strong class="source-inline1">UPDATE</strong>, and others. You can also use other annotations, such as <strong class="source-inline1">Headers</strong>, <strong class="source-inline1">Body</strong>, <strong class="source-inline1">Field</strong>, <strong class="source-inline1">Path</strong>, and more, to make your request exactly as needed.</li>
<li class="calibre14"><strong class="bold">URL parameter replacement and query parameter support</strong>: Add parameters to your request with annotations. For example, you can add a path parameter by setting the specific value in the URL, or you can add a query parameter at the end of the URL.</li>
<li class="calibre14"><strong class="bold">Synchronous and asynchronous calls</strong>: Retrofit supports both synchronous (blocking) calls and asynchronous (non-blocking) calls. For Android, asynchronous calls are more important as network operations on the main thread are discouraged.</li>
<li class="calibre14"><strong class="bold">Support for coroutines and RxJava</strong>: Retrofit provides out-of-the-box support for coroutines and RxJava. This makes it easy to use with these popular libraries for handling asynchronous operations.</li>
<li class="calibre14"><strong class="bold">Interceptors</strong>: Retrofit also allows you to use OkHttp’s interceptors. You can add headers to every <a id="_idIndexMarker480" class="calibre6 pcalibre1 pcalibre"/>request or log the request and response data for debugging purposes.</li>
</ul>
<p class="calibre3">We also need to use a converter to parse the backend responses into objects. We will use <strong class="bold">Moshi</strong> (<a href="https://github.com/square/moshi" class="calibre6 pcalibre1 pcalibre">https://github.com/square/moshi</a>) for <a id="_idIndexMarker481" class="calibre6 pcalibre1 pcalibre"/>that. Moshi is a modern JSON library for Android and Java, also built by Square. It aims to be easy to use and efficient, and its design is<a id="_idIndexMarker482" class="calibre6 pcalibre1 pcalibre"/> inspired <a id="_idIndexMarker483" class="calibre6 pcalibre1 pcalibre"/>by the well-regarded Gson library, but it seeks to improve upon several design aspects. Here are some of its main features:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Easy to use</strong>: Moshi <a id="_idIndexMarker484" class="calibre6 pcalibre1 pcalibre"/>provides simple <strong class="source-inline1">toJson()</strong> and <strong class="source-inline1">fromJson()</strong> methods to convert Java and Kotlin objects into JSON and vice versa.</li>
<li class="calibre14"><strong class="bold">Built-in and custom converters</strong>: Moshi has built-in support for converting many common types and can encode any object graph of these. For other classes, you can write custom <a id="_idIndexMarker485" class="calibre6 pcalibre1 pcalibre"/>converters, called <strong class="bold">adapters</strong>, that define how these types are converted to and from JSON.</li>
<li class="calibre14"><strong class="bold">Kotlin support</strong>: Moshi supports Kotlin and provides the <strong class="source-inline1">moshi-kotlin-codegen</strong> module, which leverages annotation processing to generate adapters for your Kotlin classes automatically.</li>
<li class="calibre14"><strong class="bold">Null safety</strong>: Moshi handles <strong class="source-inline1">null</strong> values in the JSON input and can be configured to allow or disallow <strong class="source-inline1">null</strong> values in your Java or Kotlin objects.</li>
<li class="calibre14"><strong class="bold">Annotation-based</strong>: Much like Retrofit, Moshi uses annotations to denote special behavior for certain fields (for example, custom names and transient values).</li>
<li class="calibre14"><strong class="bold">Fault-tolerant</strong>: Moshi is fault-tolerant and will not fail the entire operation if it encounters unknown properties or incompatible types in the JSON data. This can be beneficial when dealing with APIs that may occasionally change.</li>
<li class="calibre14"><strong class="bold">Efficient</strong>: Moshi is designed to be efficient in its operation, minimizing object allocation and garbage <a id="_idIndexMarker486" class="calibre6 pcalibre1 pcalibre"/>collection overhead.</li>
</ul>
<p class="calibre3">Now that we know <a id="_idIndexMarker487" class="calibre6 pcalibre1 pcalibre"/>the advantages<a id="_idIndexMarker488" class="calibre6 pcalibre1 pcalibre"/> of using Retrofit with Moshi, let’s start integrating them into our project.</p>
<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre1 pcalibre"/>Adding the Retrofit and Moshi dependencies</h2>
<p class="calibre3">To use both the <a id="_idIndexMarker489" class="calibre6 pcalibre1 pcalibre"/>Retrofit and Moshi libraries, we need to configure their dependencies. First, we will add them to the versions catalog file:</p>
<pre class="source-code">
[versions]
...
retrofit = "2.9.0"
moshi = "1.12.0"
coroutines = "1.5.1"
moshi-converter = "0.8.0"
...
[libraries]
...
retrofit = { group = "com.squareup.retrofit2", name = "retrofit", version.ref="retrofit"}
retrofitMoshiConverter = { group = "com.squareup.retrofit2", name = "converter-moshi", version.ref="retrofit"}
moshi = { group = "com.squareup.moshi", name = "moshi", version.ref = "moshi" }
moshiKotlin = { group = "com.squareup.moshi", name = "moshi-kotlin", version.ref = "moshi" }
moshiKotlinCodegen = { group = "com.squareup.moshi", name = "moshi-kotlin-codegen", version.ref = "moshi" }
moshiKotlinCodegen = { group = "com.squareup.retrofit2", name = "retrofit-kotlinx-serialization-converter", version.ref = "moshi-converter" }
coroutinesCore = {  group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-core", version.ref = "coroutines" }
coroutinesAndroid = {  group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-android", version.ref = "coroutines" }
[plugins]
...
kotlin-kapt = { id = "org.jetbrains.kotlin.kapt", version.ref = "org-jetbrains-kotlin-android" }</pre> <p class="calibre3">Then, we will include<a id="_idIndexMarker490" class="calibre6 pcalibre1 pcalibre"/> the dependencies in our module’s <code>build.gradle.kts</code> file, making them available to use in our module:</p>
<pre class="source-code">
dependencies {
    implementation(libs.retrofit)
    implementation(libs.retrofitMoshiConverter)
    implementation(libs.moshiConverter)
    implementation(libs.moshi)
    implementation(libs.moshiKotlin)
    kapt(libs.moshiKotlinCodegen)
    implementation(libs.coroutinesCore)
    implementation(libs.coroutinesAndroid)
...
}</pre> <p class="calibre3">After adding these dependencies, we should be ready to work with both libraries. Let’s start creating our<a id="_idIndexMarker491" class="calibre6 pcalibre1 pcalibre"/> data source so that we can obtain the data for the newsfeed.</p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor103" class="calibre6 pcalibre1 pcalibre"/>Creating the data source for the newsfeed</h2>
<p class="calibre3">At this point, we’re ready<a id="_idIndexMarker492" class="calibre6 pcalibre1 pcalibre"/> to create<a id="_idIndexMarker493" class="calibre6 pcalibre1 pcalibre"/> our data source. We will do this in the <code>:feature:newsfeed</code> module. First, we need to create an interface to define our API endpoints using Retrofit. We can use <code>@GET</code>, <code>@POST</code>, and others to define what kind of HTTP request we want to make:</p>
<pre class="source-code">
interface NewsFeedService {
    @GET("feed")
    suspend fun getNewsFeed(): List&lt;PostApiData&gt;
}</pre> <p class="calibre3">This is an interface for the Retrofit library that’s used to turn the HTTP API into a Kotlin interface. It also defines an endpoint for your API:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">interface NewsFeedService</strong>: This is declaring a new interface named <strong class="source-inline1">NewsFeedService</strong>.</li>
<li class="calibre14"><strong class="source-inline1">@GET("feed")</strong>: This is an annotation that describes an HTTP GET request. The <strong class="source-inline1">"feed"</strong> parameter is the endpoint where the request will be sent. So, the full URL for this request would be something like <a href="https://packtagram.com/feed" class="calibre6 pcalibre1 pcalibre">https://packtagram.com/feed</a> if the base URL of your Retrofit client is <a href="https://packtagram.com/" class="calibre6 pcalibre1 pcalibre">https://packtagram.com/</a>.</li>
<li class="calibre14"><strong class="source-inline1">suspend fun getNewsFeed(): List&lt;PostApiData&gt;</strong>: This is declaring a function named <strong class="source-inline1">getNewsFeed</strong> that is expected to return a list of <strong class="source-inline1">Post</strong> objects. The <strong class="source-inline1">suspend</strong> keyword means that this function is a suspending function, which is a type of function that can be paused and resumed at a later time. This will be called later from a coroutine.</li>
</ul>
<p class="calibre3">So, to put it all together, when <code>getFeed</code> is called, it will make a <code>GET</code> request to the <a href="https://packtagram.com/feed" class="calibre6 pcalibre1 pcalibre">https://packtagram.com/feed</a> URL and expect to receive a JSON array of <code>PostApiData</code> objects, which are then parsed into a list of <code>Post</code> objects in your Kotlin code.</p>
<p class="calibre3">To see an example of a JSON file that contains the expected fields, check out <a href="https://api.mockfly.dev/mocks/09e4e43e-7992-4dd7-b99f-e168667a240e/feed" class="calibre6 pcalibre1 pcalibre">https://api.mockfly.dev/mocks/09e4e43e-7992-4dd7-b99f-e168667a240e/feed</a>.</p>
<p class="calibre3">Now, we need to <a id="_idIndexMarker494" class="calibre6 pcalibre1 pcalibre"/>generate a <a id="_idIndexMarker495" class="calibre6 pcalibre1 pcalibre"/>client from this interface. For that, we will use the Retrofit builder:</p>
<pre class="source-code">
object RetrofitInstance {
    private const val BASE_URL = "https://packtagram.com/"
    fun getNewsFeedApi(): NewsFeedService = run {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(
                MoshiConverterFactory.create())
            .build()
            .create(NewsFeedService::class.java)
    }
}</pre> <p class="calibre3">Here, we are creating a function called <code>getNewsFeedApi()</code> that will build the <code>NewsFeedService</code> client. For that, we need a <code>BASE_URL</code> function that we can hardcode in this same file. The recommendation is to store this information in a configuration file so that we can easily change it if we need to have different <code>buildTypes</code> of the app, for example.</p>
<p class="calibre3">We are also adding the Moshi converter using the <code>.addConverterFactory</code><strong class="source-inline">
(MoshiConverterFactory.create())</strong> function. This will allow Retrofit to deserialize the backend responses using Moshi.</p>
<p class="calibre3">Now, we need to create <code>NewsFeedRemoteDataSource</code>:</p>
<pre class="source-code">
class NewsFeedRemoteDataSource(private val api:
NewsFeedService) {
    suspend fun getNewsFeed(): List&lt;PostApiData&gt; {
        return api.getNewsFeed()
    }
}</pre> <p class="calibre3">As we can see, we have created a <code>NewsFeedRemoteDataSource</code> composable. Here, we will have one function, <code>getNewsFeed(</code>). This function will call <code>NewsFeedService</code> to obtain the newsfeed.</p>
<p class="calibre3">Now, let’s<a id="_idIndexMarker496" class="calibre6 pcalibre1 pcalibre"/> create<a id="_idIndexMarker497" class="calibre6 pcalibre1 pcalibre"/> the repository for this newsfeed.</p>
<h2 id="_idParaDest-103" class="calibre7"><a id="_idTextAnchor104" class="calibre6 pcalibre1 pcalibre"/>Creating the repository</h2>
<p class="calibre3">The next step is to <a id="_idIndexMarker498" class="calibre6 pcalibre1 pcalibre"/>define<a id="_idIndexMarker499" class="calibre6 pcalibre1 pcalibre"/> the repository that will orchestrate the information gathering and storage using the different data sources (for now, we only have one, <code>NewsFeedRemoteDataSource</code>). It will also map the information into the new layer: the domain layer.</p>
<p class="calibre3">First, we’ll define its interface as part of the domain layer:</p>
<pre class="source-code">
interface NewsFeedRepository {
    suspend fun getNewsFeed():List&lt;Post&gt;
}</pre> <p class="calibre3">Second, we’ll implement its functionality as part of the data layer:</p>
<pre class="source-code">
class NewsFeedRepositoryImpl(
    private val remoteDataSource: NewsFeedRemoteDataSource
): NewsFeedRepository {
    override suspend fun getNewsFeed(): List&lt;Post&gt; {
        return remoteDataSource
            .getNewsFeed()
            .map { it.toDomain() }
    }
}</pre> <p class="calibre3">As we can see, for now, it will only have a <code>getNewsFeed()</code> function that will obtain a list of <code>Post</code>. objects It will obtain the newsfeed from the remote<a id="_idIndexMarker500" class="calibre6 pcalibre1 pcalibre"/> data source and map the <code>PostApiData</code> objects <a id="_idIndexMarker501" class="calibre6 pcalibre1 pcalibre"/>into <code>Post</code> objects.</p>
<p class="calibre3">Now, let’s create the use case to obtain this data.</p>
<h2 id="_idParaDest-104" class="calibre7"><a id="_idTextAnchor105" class="calibre6 pcalibre1 pcalibre"/>Creating the GetTheNewsFeedUseCase</h2>
<p class="calibre3">As we<a id="_idIndexMarker502" class="calibre6 pcalibre1 pcalibre"/> progress <a id="_idIndexMarker503" class="calibre6 pcalibre1 pcalibre"/>through the layers, the next step will be to create the use cases needed. In this case, we will create a use case to obtain the newsfeed – that is, <code>GetTheNewsFeedUseCase</code>:</p>
<pre class="source-code">
class GetTheNewsFeedUseCase(
    private val repository: NewsFeedRepository
) {
    suspend operator fun invoke(): List&lt;Post&gt; {
        return repository.getNewsFeed()
    }
}</pre> <p class="calibre3">Here, we are using <code>repository</code> to get the newsfeed in the <code>invoke</code> function.</p>
<p class="calibre3">Before continuing, we need to create the data classes that we will be using in the data and domain layers. In the case of the domain layer, we will create the <code>Post</code> data class:</p>
<pre class="source-code">
data class Post(
    val id: String,
    val user: UserData,
    val imageUrl: String,
    val caption: String,
    val likesCount: Int,
    val commentsCount: Int,
    val timeStamp: Long
) {
    data class UserData(
        val id: String,
        val name: String,
        val imageUrl: String
    )
}</pre> <p class="calibre3">Here, we are declaring all the fields that we need for the <code>Post</code> object in the domain layer.</p>
<p class="calibre3">In the case of the<a id="_idIndexMarker504" class="calibre6 pcalibre1 pcalibre"/> data<a id="_idIndexMarker505" class="calibre6 pcalibre1 pcalibre"/> layer, we will create the <code>PostApiData</code> data class and mapping functions that we’ll need to map to the domain object:</p>
<pre class="source-code">
data class PostApiData(
    @Json(name = "id")
    val id: String,
    @Json(name = "author")
    val user: UserApiData,
    @Json(name = "image_url")
    val imageUrl: String,
    @Json(name = "caption")
    val caption: String,
    @Json(name = "likes_count")
    val likesCount: Int,
    @Json(name = "comments_count")
    val commentsCount: Int,
    @Json(name = "timestamp")
    val timeStamp: Long
) {
    data class UserApiData(
        @Json(name = "id")
        val id: String,
        @Json(name = "name")
        val name: String,
        @Json(name = "image_url")
        val imageUrl: String
    ) {
        fun toDomain(): Post.UserData {
            return Post.UserData(
                id = id,
                name = name,
                imageUrl = imageUrl
            )
        }
    }
    fun toDomain(): Post {
        return Post(
            id = id,
            user = user.toDomain(),
            imageUrl = imageUrl,
            caption = caption,
            likesCount = likesCount,
            commentsCount = commentsCount,
            timeStamp = timeStamp
        )
    }
}</pre> <p class="calibre3">Here, we should include the fields that the response from the backend will return to our app. Note<a id="_idIndexMarker506" class="calibre6 pcalibre1 pcalibre"/> that <a id="_idIndexMarker507" class="calibre6 pcalibre1 pcalibre"/>we are using the <code>@Json(name = "")</code> annotation in the properties to specify the name of the field in the JSON that the backend will return.</p>
<p class="calibre3">Before jumping to consume the use case in <code>ViewModel</code>, we have to sort out the dependency injection for all the components we have just created. We will do so in <code>newsFeedModule</code>:</p>
<pre class="source-code">
val newsFeedModule = module {
    single { RetrofitInstance.getNewsFeedApi() }
    single { NewsFeedRemoteDataSource(get()) }
    single&lt;NewsFeedRepository&gt; {
        NewsFeedRepositoryImpl(get()) }
    factory { GetTheNewsFeedUseCase(get()) }
    viewModel&lt;NewsFeedViewModel&gt;()
}</pre> <p class="calibre3">Now, it is <a id="_idIndexMarker508" class="calibre6 pcalibre1 pcalibre"/>time <a id="_idIndexMarker509" class="calibre6 pcalibre1 pcalibre"/>to integrate this use case into <code>NewsFeedViewModel</code>.</p>
<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor106" class="calibre6 pcalibre1 pcalibre"/>Integrating the use case into our ViewModel</h2>
<p class="calibre3">For the <a id="_idIndexMarker510" class="calibre6 pcalibre1 pcalibre"/>ViewModel, we <a id="_idIndexMarker511" class="calibre6 pcalibre1 pcalibre"/>will need to create a new function to obtain the posts. We will call it <code>loadPosts()</code>:</p>
<pre class="source-code">
    init {
        loadPosts()
    }
    private fun loadPosts() {
        viewModelScope.launch {
            val newPosts = getTheNewsFeedUseCase()
            _posts.value = newPosts
        }
    }</pre> <p class="calibre3">Here, we are loading the posts as soon as the app shows the view and the ViewModel is created.</p>
<p class="calibre3">The changes to the <code>posts</code> property are already being consumed by our <code>NewsFeed</code> composable, so it will update the UI when it receives any posts.</p>
<p class="calibre3">We could also add some error handling here, but as we already worked on that topic in the first project, we will leave it here.</p>
<p class="calibre3">Now, it wouldn’t be realistic (and performant) to load all the existing posts initially. As we did with the messaging project, we’ll need to paginate so that we can obtain the posts gradually, following<a id="_idIndexMarker512" class="calibre6 pcalibre1 pcalibre"/> the <a id="_idIndexMarker513" class="calibre6 pcalibre1 pcalibre"/>user scroll. We will see how in the next section.</p>
<h1 id="_idParaDest-106" class="calibre5"><a id="_idTextAnchor107" class="calibre6 pcalibre1 pcalibre"/>Implementing pagination in the newsfeed</h1>
<p class="calibre3">To implement <a id="_idIndexMarker514" class="calibre6 pcalibre1 pcalibre"/>pagination in our app, we<a id="_idIndexMarker515" class="calibre6 pcalibre1 pcalibre"/> will start by modifying the Retrofit service. Typically you’re required to add parameters to your API endpoint that control the “page” of data you’re requesting. For instance, we might have a <code>pageNumber</code> parameter and a <code>pageSize</code> parameter (though this will depend on the design of your backend endpoints).</p>
<p class="calibre3">First, let’s adjust <code>NewsFeedService</code> so that it includes the two parameters we just mentioned:</p>
<pre class="source-code">
interface NewsFeedService {
    @GET("/feed")
    suspend fun getNewsFeed(
        @Query("pageNumber") pageNumber: Int,
        @Query("pageSize") pageSize: Int
    ): List&lt;PostApiData&gt;
}</pre> <p class="calibre3">Now, we will need to change the signature of the data source function so that it includes those fields. In the data source, we will change the following function:</p>
<pre class="source-code">
    suspend fun getNewsFeed(pageNumber: Int, pageSize:
    Int): List&lt;PostApiData&gt; {
        return api.getNewsFeed(pageNumber, pageSize)
    }</pre> <p class="calibre3">In the repository, we will handle storing the current page and keeping the desired size of pages (this could also <a id="_idIndexMarker516" class="calibre6 pcalibre1 pcalibre"/>be <a id="_idIndexMarker517" class="calibre6 pcalibre1 pcalibre"/>a constant somewhere):</p>
<pre class="source-code">
class NewsFeedRepositoryImpl(
    private val remoteDataSource:
    NewsFeedRemoteDataSource): NewsFeedRepository
{
    private var currentPage = 0
    private val pageSize = 20 // Or whatever page size we
                                 prefer
    override suspend fun getNewsFeed(): List&lt;Post&gt; {
        return remoteDataSource
            .getNewsFeed(currentPage, pageSize)
            .map { it.toDomain() }
            .also { currentPage++ }
    }
    fun resetPagination() {
        currentPage = 0
    }
}</pre> <p class="calibre3">Here, we are storing the current page so that when we call the data source, we can specify if we want the next one. We have also added a function called <code>resetPagination()</code> that will reset the current page so that we can start again.</p>
<p class="calibre3">Next, we are going to use <code>resetPagination()</code> in <code>UseCase</code> when the user navigates to the top and wants to get the first of the publications:</p>
<pre class="source-code">
    suspend operator fun invoke(fromTheBeginning: Boolean):
    List&lt;Post&gt; {
        if (fromTheBeginning) {
            repository.resetPagination()
        }
        return repository.getNewsFeed()
    }</pre> <p class="calibre3">The next step is <a id="_idIndexMarker518" class="calibre6 pcalibre1 pcalibre"/>to <a id="_idIndexMarker519" class="calibre6 pcalibre1 pcalibre"/>handle when we should load the next page and load the next posts. To do so, we’ll need to modify our <code>NewsFeed</code> composable and <code>NewsFeedViewModel</code>.</p>
<p class="calibre3">First, we are going to implement the <code>NewsFeedViewModel</code> part:</p>
<pre class="source-code">
init {
        loadInitialPosts()
    }
    private fun loadInitialPosts() {
        viewModelScope.launch {
            val newPosts = withContext(dispatcher) {
                getTheNewsFeedUseCase(fromTheBeginning =
                    true)
            }
            _posts.value = newPosts
        }
    }
    fun loadMorePosts() {
        viewModelScope.launch {
            val newPosts = withContext(dispatcher) {
                getTheNewsFeedUseCase(fromTheBeginning =
                    false)
            }
            val updatedPosts = (_posts.value +
                newPosts).takeLast(60)
            _posts.value = updatedPosts
        }
    }</pre> <p class="calibre3">Here, we’ve renamed our initial function <code>loadInitialPosts()</code> so that it indicates that it will load the first posts. Then, we created a new function called <code>loadMorePosts()</code> that will load the new page. It will add it to the existing post list.</p>
<p class="calibre3">Now, we need to <a id="_idIndexMarker520" class="calibre6 pcalibre1 pcalibre"/>make a <a id="_idIndexMarker521" class="calibre6 pcalibre1 pcalibre"/>few modifications to our <code>NewsFeed</code> composable so that it will call the ViewModel when a new page is needed. For that reason, we need to create a <code>LazyListState</code> extension that we will invoke whenever the user reaches the end of the list:</p>
<pre class="source-code">
fun LazyListState.OnBottomReached(
    loadMore : () -&gt; Unit
){
    val shouldLoadMore = remember {
        derivedStateOf {
            val lastItemInView =
                layoutInfo.visibleItemsInfo.lastOrNull()
                    ?: return@derivedStateOf true
            lastItemInView.index ==
                layoutInfo.totalItemsCount - 1
        }
    }
    LaunchedEffect(shouldLoadMore){
        snapshotFlow { shouldLoadMore.value }
            .collect {
                if (it) loadMore()
            }
    }
}</pre> <p class="calibre3">This extension function observes the scrolling state of <code>LazyColumn</code> or <code>LazyRow</code>. When the user has scrolled to the bottom, it calls the provided <code>loadMore</code> function to load more <a id="_idIndexMarker522" class="calibre6 pcalibre1 pcalibre"/>items. This <a id="_idIndexMarker523" class="calibre6 pcalibre1 pcalibre"/>pattern is common in implementing “infinite scrolling” or “pagination,” which is what we are currently implementing.</p>
<p class="calibre3">Now, we need to use it in our <code>LazyColumn</code> layout. For that, we need to remember <code>LazyListState</code> in the <code>NewsFeed</code> composable:</p>
<pre class="source-code">
@Composable
fun NewsFeed(
    modifier: Modifier = Modifier,
    viewModel: NewsFeedViewModel = koinViewModel()
) {
    val posts = viewModel.posts.collectAsState()
    val listState = rememberLazyListState()
    LazyColumn{
        itemsIndexed(posts){ _, post -&gt;
            PostItem(post = post)
        }
    }
    listState.OnBottomReached {
        viewModel.loadMorePosts()
    }
}</pre> <p class="calibre3">With this change, every time our user reaches the bottom of the list, we will call the function to load more posts and get the next page.</p>
<p class="calibre3">Now that<a id="_idIndexMarker524" class="calibre6 pcalibre1 pcalibre"/> we’ve <a id="_idIndexMarker525" class="calibre6 pcalibre1 pcalibre"/>finished our paging implementation, our user experience will be more performant and smoother when navigating the newsfeed.</p>
<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor108" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we primarily focused on structuring and modularizing our Packtagram app while enhancing maintainability. Leveraging Jetpack Compose, we designed the components and screens for some of the features of the interface that we are going to be working on in the next chapters.</p>
<p class="calibre3">Additionally, this chapter delved into the intricacies of connecting the developed UI to the backend, which is pivotal for data management and operation handling. We implemented Retrofit for network operations and Moshi for JSON parsing, bridging the gap between the user interface and the data source. Moreover, we introduced the concept of paging to efficiently manage large datasets. By doing so, we ensured smoother data load, faster response times, and enhanced app performance overall, significantly improving the user’s experience.</p>
<p class="calibre3">In the next chapter, we will dive into the photo functionality of our app. We will use an incredible library called CameraX and take advantage of some of its capabilities. We will also learn how to apply machine learning to our camera preview using ML Kit.</p>
</div>
</body></html>