- en: '*Chapter 3*: Understanding Structural Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers **structural patterns** in **Kotlin**. In general, structural
    patterns deal with relationships between **objects**.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss how to extend the functionality of our objects without producing
    complex class hierarchies. We'll also discuss how to adapt to changes in the future
    or fix some of the design decisions taken in the past, as well as how to reduce
    the memory footprint of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a better understanding of how to compose
    your objects so that they can be simpler to extend and adapt to different types
    of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements for this chapter are the same as the previous chapters—you'll
    need **IntelliJ IDEA** and the **JDK**.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed the **Prototype** design pattern, which
    allows us to create instances of classes with slightly (or not so slightly) different
    data. This raises a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What if we want to create a set of classes that all have slightly different
    behavior?*'
  prefs: []
  type: TYPE_NORMAL
- en: Well, since functions in Kotlin are *first-class citizens* (which we will explain
    in this chapter), you could use the Prototype design pattern to achieve this aim.
    After all, creating a set of classes with slightly different behavior is what
    JavaScript does successfully. But the goal of this chapter is to discuss another
    approach to the same problem. After all, design patterns are all about *approaches*.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the **Decorator** design pattern, we allow the users of our
    code to specify the abilities they want to add.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that we have a rather simple class that registers all of the captains
    in the Star Trek universe along with their vessels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'One day, your captain—sorry, *scrum master*—comes to you with an urgent requirement.
    From now on, every time someone searches for a captain, we must also log this
    into a console. However, there''s a catch to this simple task: you cannot modify
    the `StarTrekRepository` class directly. There are other consumers for this class,
    and they don''t need this logging behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: But before we dive deeper into this problem, let's discuss one peculiarity we
    can observe in our class – that is, a strange operator you can see in the `getCaptain`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The Elvis operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Kotlin*, we learned that Kotlin is not only strongly typed, but it is also a null-safe
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '*What happens if, as in our example, there could be no value stored in a map
    for a particular key?*'
  prefs: []
  type: TYPE_NORMAL
- en: If we're working with a map, one option is to use the `getOrDefault` method
    that maps provide in Kotlin. This might be a viable option in this particular
    case, but it won't work in situations where you might have to deal with a null
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use the `?:`). If you''re wondering about how this operator
    got its name, it does resemble Elvis Presley''s hairstyle somewhat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – If we turn the Elvis operator 90 degrees clockwise, it looks
    a bit like a pompadour hairstyle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17816_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – If we turn the Elvis operator 90 degrees clockwise, it looks a
    bit like a pompadour hairstyle
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the Elvis operator is to provide a default value in case we receive
    a null value. Take another look at the `getCaptain` function to see how this is
    done. The *desugared* form of the same function would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, you can see that this operator saves us a lot of typing.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go back to the task at hand. Since our class and its methods are declared
    open, we can extend the class and override the function we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That was quite easy! Although the name of that class is getting quite long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how we delegate to the implementation in our parent class by using the
    `super` keyword here. However, the next day, your boss (sorry, *scrum-master*)
    comes again and asks for another feature. When adding a captain, we need to check
    that their name is no longer than 15 characters. That may be a problem for some
    Klingons, but you decide to implement it anyway. And, by the way, this feature
    should not be related to the logging feature we developed previously. Sometimes
    we just want the logging, and sometimes we just want the validation. So, here''s
    what our new class will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Another task done.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the next day, another requirement arises: in some cases, we need `StarTrekRepository`
    to have logging enabled and also perform validation at the same time. I guess
    we''ll have to name it `LoggingGetCaptainValidatingAddCaptainStarTrekRepository`
    now.'
  prefs: []
  type: TYPE_NORMAL
- en: Problems like this are surprisingly common, and they are a clear indication
    that a design pattern may help us here.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the Decorator design pattern is to add new behaviors to our objects
    dynamically. In our example, *logging* and *validating* are two behaviors that
    we sometimes want to be applied to our object and sometimes don't want to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by converting our `StarTrekRepository` into an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll implement that interface using the same logic as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, instead of extending our concrete implementation, we''ll implement the
    interface and use a new keyword called `by`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `by` keyword delegates the implementation of an interface to another object.
    That's why the `LoggingGetCaptain` class doesn't have to implement any of the
    functions declared in the interface. They are all implemented by default by another
    object that the instance wraps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the hardest part to understand is the signature. What we need
    from the Decorator design pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to be able to receive the object we're decorating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to keep a reference to the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our decorator is called, we need to be able to decide if we would like
    to change the behavior of the object we're holding or to delegate the call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to extract an interface or have one provided already by the
    (library) author.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we don't use the `super` keyword anymore. If we tried to, it wouldn't
    work, as there is a class that we're implementing now. Instead, we use the reference
    to the `wrapped` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure we understand this pattern, let''s implement our second decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the preceding example and the `ValidatingAddCaptainStarTrekRepository`
    implementation is that we use the `require` function instead of an `if` expression.
    This is often more readable, and it will also throw `IllegalArgumentException`
    if the expression is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line will throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this pattern allows us to *compose behavior*, just as we wanted.
    Now, let's take a short detour and discuss *operator overloading* in Kotlin, as
    this will help us to improve our design pattern even more.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take another look at the interface that was extracted. Here, we are
    describing basic operations on a map that are usually associated with array/map
    access and assignment. In Kotlin, we have some nice syntactic sugar called `DefaultStarTrekRepository`,
    we can see that working with maps is very intuitive in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be useful if we could work with our repository as if it was a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Kotlin, we can actually achieve this behavior quite easily. First, let''s
    change our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've added the `operator` keyword that prefixes the function definition.
    Let's understand what this keyword means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most programming languages support some form of operator overloading. Let''s
    take **Java** as an example and look at the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `+` operator acts differently depending on whether the
    arguments are strings or integers. That is, it can add two numbers, but it can
    also concatenate two strings. You can imagine that the *plus* operation can be
    defined on other types. For example, it makes a lot of sense to concatenate two
    lists using the same operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this code won't compile in Java, and we can't do anything about
    it. That's because operator overloading is a feature reserved to the language
    itself, and not for its users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another extreme, the **Scala** programming language. In Scala,
    any set of characters can be defined as an operator. So, you may encounter code
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin takes a middle ground between these two approaches. It allows you to
    overload certain *well-known* operations, but it limits what can and cannot be
    overloaded. Although this list is limited, it is quite long, so we''ll not write
    it in full here. However, you can find it in the official Kotlin documentation:
    [https://kotlinlang.org/docs/operator-overloading.html](https://kotlinlang.org/docs/operator-overloading.html).'
  prefs: []
  type: TYPE_NORMAL
- en: If you use the `operator` keyword with a function that is unsupported or with
    the wrong set of arguments, you'll get a compilation error. The square brackets
    that we started with in the previous code example are called indexed access operators
    and correlate with the `get(x)` and `set(x, y)` methods we have just defined.
  prefs: []
  type: TYPE_NORMAL
- en: Caveats of the Decorator design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator design pattern is great because it lets us compose objects *on
    the fly*. And using Kotlin's `by` keyword makes it easy to implement. But there
    are still limitations that you need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you cannot see *inside* of the Decorator. This means that there''s no
    way of knowing which specific object it wraps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Although `withLoggingAndValidating` contains `ValidatingAdd` (and it may behave
    like it), it is not an instance of `ValidatingAdd`! Keep that in mind when performing
    casts and type checks.
  prefs: []
  type: TYPE_NORMAL
- en: So, you might wonder where this pattern would be used in the real world. One
    example is the `java.io.*` package, with classes implementing the `Reader` and
    `Writer` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to read a file efficiently, you can use `BufferedReader`,
    which receives another reader as its constructor argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '`FileReader` serves this purpose, as it implements the `Reader` interface.
    So does `BufferedReader` itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to our next design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of the **Adapter** design pattern is to convert one interface
    to another interface. In the physical world, the best example of this idea would
    be an electrical plug adapter or a USB adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine yourself in a hotel room late in the evening, with 7% battery left on
    your phone. Your phone charger was left in the office at the other end of the
    city. You only have an EU plug charger with a Mini USB cable. But your phone uses
    USB-C, as you had to upgrade. You're in New York, so all of your outlets are (of
    course) USB-A. So, what do you do? Oh, it's easy. You look for a Mini USB to USB-C
    adapter in the middle of the night and hope that you have remembered to bring
    your EU to US plug adapter as well. Only 5% battery left – time is running out!
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we understand what adapters are for in the physical world, let's
    see how we can apply the same principle in code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '`USPlug` assumes that power is `Int`. It has `1` as its value if it has power
    and any other value if it doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`EUPlug` treats power as `String`, which is either `TRUE` or `FALSE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'For `UsbMini`, power is an `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for `UsbTypeC`, power is a `Boolean` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to bring the power value from a US power outlet to our cellphone,
    which will be represented by this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by declaring what a US power outlet will look like in our code.
    It will be a function that returns a `USPlug`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter, we discussed two different uses of the `object` keyword.
    In the global scope, it creates a Singleton object. When used together with the
    `companion` keyword inside of a class, it creates a place for defining `static`
    functions. The same keyword can also be used to generate anonymous classes. Anonymous
    classes are classes that are created *on the fly*, usually to implement an interface
    in an ad-hoc manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our charger will be a function that takes `EUPlug` as an input and outputs
    `UsbMini`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s try to combine our `cellPhone`, `charger`, and `usPowerOutlet`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get two different type errors – the Adapter design pattern
    should help us solve these.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting existing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need two types of adapters: one for our power plugs and another one for
    our USB ports.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, you would usually create a pair of classes for this purpose. In Kotlin,
    we can replace these classes with **extension functions**. We already mentioned
    extension functions briefly in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*. Now, it's time to cover them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could adapt the US plug to work with the EU plug by defining the following
    extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword in the context of an extension function refers to the object
    we're extending – just as if we were implementing this method inside of the class
    definition. Again, we use an anonymous class to implement the required interface
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a USB adapter between the Mini USB and USB-C instances in a similar
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can get back online again by combining all those adapters together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we didn't have to create any new classes that implement these
    interfaces. By using Kotlin's extension functions, our code stays short and to
    the point.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter design pattern is more straightforward than the other design patterns,
    and you'll see it used widely. Now, let's discuss some of its real-world uses
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters in the real world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've probably encountered many uses of the Adapter design pattern already.
    These are normally used to adapt between *concepts* and *implementations*. For
    example, let's take the concept of a JVM collection versus the concept of a JVM
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already discussed `listOf()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'A **stream** is a *lazy* collection of elements. You cannot simply pass a collection
    to a function that receives a stream, even though it may make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, collections provide us with the `.stream()` adapter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Many other Kotlin objects have adapter methods that usually start with `to`
    as a prefix. For example, `toTypedArray()` converts a list to an array.
  prefs: []
  type: TYPE_NORMAL
- en: Caveats of using adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Have you ever plugged a 110 V US appliance into a 220 V EU socket through
    an adapter, and fried it totally?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re not careful, that''s something that could also happen to your code.
    The following example uses another adapter, and it also compiles well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: But it never completes because `Stream.generate()` produces an infinite list
    of integers. So, be careful and adopt this design pattern wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Adapter design pattern helps you to work with legacy code, the **Bridge**
    design pattern helps you to avoid abusing inheritance. The way it works is actually
    very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we want to build a system to manage different kinds of troopers
    for the Galactic Empire.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll create multiple implementations for different types of troopers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also stronger versions of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'And there are also scout troopers that can run faster than the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot of classes!
  prefs: []
  type: TYPE_NORMAL
- en: 'One day, our dear designer comes and asks that all stormtroopers should be
    able to shout, and each will have a different phrase. Without thinking twice,
    we add a new function to our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: By doing that, all the classes that implement this interface stop compiling.
    And we have a lot of them. That's a lot of changes that we'll have to make. So,
    we'll just have to suck it up and get to work.
  prefs: []
  type: TYPE_NORMAL
- en: '*Or will we?*'
  prefs: []
  type: TYPE_NORMAL
- en: We go and change the implementations of five different classes, feeling lucky
    that there are only five and not fifty.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the Bridge design pattern is to flatten the class hierarchy
    and have fewer specialized classes in our system. It also helps us to avoid the
    *fragile base class* problem when modifying the superclass introduces subtle bugs
    to classes that inherit from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s try to understand why we have this complex hierarchy and many
    classes. It''s because we have two orthogonal, unrelated properties: *weapon type*
    and *movement speed*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that instead, we wanted to pass those properties to the constructor
    of a class that implements the same interface we have been using all along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties that `StormTrooper` receives should be interfaces, so we can
    choose their implementation later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Notice that these methods return `Meters` and `PointsOfDamage` instead of simply
    returning `Long` and `Int`. This feature is called **type aliasing**. To understand
    how this works, let's take a short detour.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin allows us to provide alternative names for existing types. These are
    called **aliases**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an alias, we use a new keyword: `typealias`. From now on, we can
    use `Meters` instead of plain old `Int` to return from our `move()` method. These
    aren''t new types. The Kotlin compiler will always translate `PointsOfDamage`
    to `Long` during compilation. Using them provides two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The first advantage is *better semantics* (as in our case). We can tell exactly
    what the *meaning* of the value we're returning is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second advantage is being *concise*. Type aliases allow us to hide complex
    generic expressions. We'll expand on this in the following sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go back to our `StormTrooper` class. It's time to provide some implementations
    for the `Weapon` and `Legs` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define the regular damage and speed of `StormTrooper`, using
    imperial units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: These values are very effective since they are known during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `static final` variables in Java, they cannot be placed inside a class.
    You should place them either at the top level of your package or nest them inside
    of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Kotlin has type inference, we can specify the types of our constants
    explicitly and even use type aliases. *How about having* `DEFAULT_TIMEOUT : Seconds
    = 60` *instead of* `DEFAULT_TIMEOUT_SECONDS = 60` *in your code?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can provide some implementations for our interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at how we can move the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to make sure that we can implement the same functionality
    without the complex class hierarchy we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a flat class hierarchy, which is much simpler to extend and also
    to understand. If we need more functionality, such as the shouting ability we
    mentioned earlier, we would add a new interface and a new constructor argument
    for our class.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, this pattern is often used in conjunction with dependency
    injection frameworks. For example, this would allow us to replace an implementation
    that used a real database with a mocked interface. This would make our code easier
    to set up and faster to test.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to composing objects within one another, so it may
    look strange to have a separate section for the **Composite** design pattern.
    As a result, this raises a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shouldn''t this design pattern encompass all of the others?*'
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of the Bridge design pattern, the name may not reflect its true
    uses and benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our `StormTrooper` example from before. Lieutenants of the
    Empire quickly discover that no matter how well equipped, stormtroopers cannot
    hold their ground against the rebels because they are uncoordinated.
  prefs: []
  type: TYPE_NORMAL
- en: To provide better coordination, the Empire decides to introduce the concept
    of a *squad* for the stormtroopers. A squad should contain one or more stormtrooper
    of any kind, and when given commands, it should behave exactly as if it was a
    single unit.
  prefs: []
  type: TYPE_NORMAL
- en: '`Squad`, clearly, consists of a collection of stormtroopers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a couple of them to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our squad act as if it was a single unit, we''ll add two methods to
    it called `move` and `attack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions will repeat any received orders to all of the units they contain.
    At first, the approach seems to be working. However, what happens if we change
    our `Trooper` interface by adding a new function? Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Nothing seems to break, but our `Squad` class stops doing what it was supposed
    to do – that is, act as if it was a single unit. A single unit now has a method
    that our composite class does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent this from happening in the future, let''s see what happens
    if our `Squad` class implements the same interface as the units it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'That change will force us to implement the `retreat` function and mark the
    other two functions with the `override` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll take a short detour to discuss an alternative and more convenient
    approach to this example – one that would allow us to construct the same object
    but result in a composite that is more pleasant to use.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our code did achieve its goals. However, it would be good if instead of passing
    a list of stormtroopers to the constructor (as we do now), we could pass our stormtroopers
    directly, without wrapping them in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: One way to achieve this is to add `Squad` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until now, we were always using the *primary constructor* of the class.
    That''s the constructor declared after the class name. But we can define more
    than one constructor for a class. We can define secondary constructors for a class
    using the `constructor` keyword inside the class body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Unlike Java, there's no need to repeat the class name for each constructor.
    That also means fewer changes are required if you decide to rename the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note how each secondary constructor must call the primary constructor. This
    is similar to using the `super` keyword in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The varargs keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is clearly not the way to go, since we cannot predict how many more elements
    someone might want to pass us. If you come from Java, you have probably thought
    about `Trooper... units`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides us with the `vararg` keyword for the same purpose. By combining
    a secondary constructor with `varargs`, we get the following piece of code, which
    is very nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are able to create a squad with any number of stormtroopers without
    the need to wrap them in a list first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to understand how this works under the hood. The Kotlin compiler
    translates a `vararg` argument to an `Array` of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Arrays in Kotlin have an Adapter method that allows them to be converted to
    a list of the same type. Interestingly, we can use the Adapter design pattern
    to help us implement the Composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting composites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Composite design pattern has another interesting property. Previously,
    we proved that we can create a squad containing multiple stormtroopers. We can
    also create a squad of squads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Now, giving an order to the platoon will work in exactly the same way as giving
    it to a squad. In fact, this pattern allows us to support a tree-like structure
    of arbitrary complexity and to perform operations on all of its nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Composite design pattern may seem a bit incomplete until we reach the next
    chapter, where we will discover its partner: the **Iterator** design pattern.
    When both design patterns are combined, they really shine. If you are still unsure
    how this pattern is useful after completing this section, come back to it after
    you have also learned about the Iterator design pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, the Composite design pattern is widely used in `Group` widget
    in `View` interface in order to be able to act on their behalf.
  prefs: []
  type: TYPE_NORMAL
- en: As long as all the objects in the hierarchy implement the same interface, no
    matter how deep the nesting is, we can ask the top-level object to invoke an action
    on everything beneath it.
  prefs: []
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of *facade* as a term to refer to a design pattern comes directly from
    building architecture. That is, a facade is the face of a building that is normally
    made to look more appealing than the rest of it. In programming, *facades* can
    help to hide the ugly details of an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The **Facade** design pattern itself aims to provide a nicer, simpler way to
    work with a family of classes or interfaces. We previously discussed the idea
    of a family of classes when covering the **Abstract Factory** design pattern.
    The Abstract Factory design pattern focuses on creating related classes, while
    the Facade design pattern focuses on working with them once they have been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this, let''s go back to the example we used for the Abstract
    Factory design pattern. In order to be able to start our server from a configuration
    using our Abstract Factory, we could provide users of our library with a set of
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the given file is `.json` or `.yaml` by trying to parse it with a **JSON**
    parser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we received an error, try parsing it using a **YAML** parser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there were no errors, pass the results to the Abstract Factory to create
    the necessary objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While helpful, following this set of instructions may require quite a bit of
    skill and knowledge. Developers may struggle to find the correct parser, or they
    might ignore any exceptions thrown from a JSON parser in instances where it's
    dealing with a `.yaml` file, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '*What problems are our users facing at the moment?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a configuration, they will need to interact with at least three different
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: A JSON parser (covered in the *Abstract Factory* section in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML Parser (covered in the *Abstract Factory* section in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server Factory (covered in the *Factory Method* section in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, it would be great to have a single function (`startFromConfiguration()`)
    that would take a path to a configuration file, parse it, and then, if there were
    no errors in the process, start our server.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be providing a *facade* to our users to simplify working with a set of
    classes. One way to achieve this goal would be to provide a new class to encapsulate
    all of this logic for us. This is a common tactic in most languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in Kotlin, we have a better option that uses a technique we already
    discussed in this chapter when covering the Adapter design pattern. We can make
    `startFromConfiguration()` an *extension function* on the `Server` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this implementation is exactly the same as in the Adapter design
    pattern. The only difference is the end goal. In the case of the Adapter design
    pattern, the goal is to make an otherwise *unusable* class *usable*. Remember,
    one of the goals of the Kotlin language is to *reuse* as much as possible. For
    the Façade design pattern, the goal is to make a *complex* group of classes *easy
    to use*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on when you read this book, you may not need the `ExperimentalPathApi`
    annotation anymore. This feature was introduced in Kotlin 1.4, and once it is
    stable it will be made an integral part of the language.
  prefs: []
  type: TYPE_NORMAL
- en: We already discussed that in Kotlin, `try` is an *expression* that returns a
    *value*. Here, you can see that we can also return a value from a `catch` block,
    further reducing the need for mutable variables.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's understand what happens in the first two lines of this function.
    `Path` is a rather new API that was introduced in `toFile` is an example of the
    Adapter design pattern that converts between a path and an actual file. Finally,
    the `readLine()` function will attempt to read the entire file into memory, split
    line by line. Consider using the Facade design pattern when working with any code
    base that would benefit from being simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`data` class. But a `data` class is all about state.'
  prefs: []
  type: TYPE_NORMAL
- en: '*So, is the data class related to the Flyweight design pattern at all?*'
  prefs: []
  type: TYPE_NORMAL
- en: To understand this design pattern better, we need to jump back in time some
    twenty years. Back in 1994, when the original *Design Patterns* book was published,
    your regular PC had 4 MB of RAM. During this period, one of the main goals of
    any process was to save that precious RAM, as you could fit only so much into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, some *cellphones* have 8 GB of RAM. Bear that in mind when we discuss
    what the Flyweight design pattern is all about in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, let's see how we can use our resources more efficiently, as
    this is always important!
  prefs: []
  type: TYPE_NORMAL
- en: Being conservative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine we're building a 2D side-scrolling arcade platform game. That is, you
    have your game character, which you control with arrow keys or a gamepad. Your
    character can move left, right, and jump.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're a really small indie company consisting of one developer (who is
    also a graphic designer, product manager, and sales representative), two cats,
    and a canary named Michael, we use only 16 colors in our game. And our character
    is 64 pixels tall and 64 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our character has a lot of enemies, which consist mostly of carnivorous Tanzanian
    snails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s a 2D game, each snail has only two directions of movement: `LEFT`
    and `RIGHT`. We can represent these directions using an `enum` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to draw itself on a screen, each snail will hold a pair of images
    and a direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `File` class comes from `java.io.File`. Remember that
    you can always refer to our GitHub project to see the needed imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the direction, we can get the current sprite that shows us which direction
    the snail is facing and use this to draw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: When any of the enemies move, they basically just slide left or right.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we would like is to have multiple animated sprites to reproduce the snail''s
    movements in each direction. We can generate a list of such sprites for each snail
    enemy using a `List` generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialize a list of eight elements, passing a `block` function as
    a constructor. The benefit of this approach is that we can apply complex logic
    during the creation of a collection while still keeping it effectively immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each element, we decide what image to get:'
  prefs: []
  type: TYPE_NORMAL
- en: Positions `0` and `1` are for still images, facing left and right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positions `2` through `4` are for moving left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positions `5` through `7` are for moving right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some math now. Each snail is represented by a 64 x 64 image. Assuming
    each color takes up exactly one byte, the single images will take up 4 KB of RAM
    in the memory. Since we have eight images for a snail, we need 32 KB of RAM for
    each one, which allows us to fit only 32 snails into 1 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to have thousands of these dangerous and extremely fast creatures
    on screen and to be able to run our game on a 10-year-old phone, we clearly need
    a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Saving memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*What''s the problem we have with all of our snails?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'They''re actually quite fat, heavyweight snails. We would like to put them
    on a diet. Each snail stores eight images within its *snaily* body. But these
    images are actually the same for each snail. This raises a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What if we extract those sprites into a Singleton object or a Factory Method
    and then only reference them from each instance?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: This way, our `getCurrentSprite` function could stay the same, and we'll only
    consume 256 KB of memory, no matter how many snails we generate. We could generate
    millions of them without affecting the footprint of our program.
  prefs: []
  type: TYPE_NORMAL
- en: And this is exactly the idea behind the Flyweight design pattern. That is, limit
    the number of heavyweight objects (in our case, the image files) by sharing them
    between the lightweight objects (in our case, the snails).
  prefs: []
  type: TYPE_NORMAL
- en: Caveats of the Flyweight design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should take extra care about the immutability of the data we pass. If, for
    example, we used `var` instead of `val` in our Singleton, it could be disastrous
    for our code. The same goes for mutable data structures. We wouldn't want someone
    removing an image, replacing it, or clearing the list of images altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Kotlin makes handling these cases rather easy. Just make sure to always
    use values instead of variables in your extrinsic state, and remember to use immutable
    data structures, which cannot be altered after they have been created.
  prefs: []
  type: TYPE_NORMAL
- en: You can debate the usefulness of this pattern in this era of plentiful memory.
    However, as we have already said, the tools in the toolbox don't take up much
    space, and having another design pattern under your belt may still prove useful.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like the Decorator design pattern, the **Proxy** design pattern extends
    an object's functionality. However, unlike a decorator, which always does what
    it's told, having a proxy may mean that when asked to do something, the object
    does something totally different.
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed **Creational Patterns** in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*, we already touched on the idea of *expensive*
    objects. For example, an object that accesses network resources or takes a lot
    of time to create.
  prefs: []
  type: TYPE_NORMAL
- en: We at the *Funny Cat App* provide our users with funny cat images on a daily
    basis. On our homepage and mobile application, each user sees a lot of pictures
    of funny cats. When they click or touch any of those images, it expands to its
    full-screen glory.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching cat images over the network is very expensive, and it consumes a lot
    of memory, especially if those are images of cats that tend to indulge in a second
    dessert after dinner. What we want to do is fetch the full-sized image only once
    at the time it is requested. And if it is requested multiple times, we want to
    be able to show it to family or friends. In short, we don't want to have to fetch
    it every time.
  prefs: []
  type: TYPE_NORMAL
- en: There's no way to avoid loading the image once. But when it's being accessed
    for the second time, we would like to avoid going over the network again and instead
    return the result that was cached in memory. That's the idea of the **Proxy**
    design pattern; instead of the expected behavior of going over the network each
    time, we're being a bit lazy and returning the result that we already prepared.
  prefs: []
  type: TYPE_NORMAL
- en: It's a bit like going into a cheap diner, ordering a hamburger, and getting
    it after only two minutes, but cold. Well, that's because someone else hated onions
    and returned it to the kitchen a while ago. True story.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds like it would require a lot of logic. But as you''ve probably guessed
    (especially after meeting the Decorator design pattern), Kotlin can perform miracles
    by reducing the amount of boilerplate code you need to write to achieve your goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we've seen the `by` keyword in a different context – that is, when
    delegating the implementation of an interface to another class (as discussed in
    *The Decorator design pattern* section of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, in this case, we use the `by` keyword to delegate the
    initialization of a field to happen later. We use a function called `lazy`, which
    is one of the `image` property, it will execute our code block and save its results
    into the `image` property. The following invocations of that property will simply
    return its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the Proxy design pattern is divided into three sub-patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual proxy**: Lazily caches the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote proxy**: Issues a call to the remote resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection or access control proxy**: Denies access to unauthorized parties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can regard our previous example as either a virtual proxy or a combination
    of the virtual and remote types of proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder what happens if two threads try to initialize the image at the
    same time. By default, the `lazy()` function is synchronized. Only one thread
    will win, and others will wait until the image is ready.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't mind two threads executing the lazy block (for example, if it's
    not that expensive), you can use `lazy(LazyThreadSafetyMode.PUBLICATION)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: If performance is absolutely critical for you and you're absolutely sure that
    two threads won't ever execute the same block simultaneously, you can use `LazyThreadSafetyMode.NONE`,
    which is not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying and delegation is a very useful approach for many complex problems,
    and we'll explore this in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how structural design patterns can help us
    to create more flexible code that can adapt to changes with ease, sometimes even
    at runtime. We've covered how we can add functionality to an existing class with
    the Decorator design pattern, and we've explored how *operator overloading* can
    allow us to provide more intuitive syntax to common operations.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to adapt one interface to another interface using extension
    methods, and we also learned how to create anonymous objects to implement an interface
    only once. Next, we discussed how to simplify class hierarchies using the Bridge
    design pattern. You should now know how to create a shortcut for a type name with
    `typealias` and also how to define efficient constants with `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we looked at the Composite design pattern, and we considered how
    it could help you to design a system that needs to treat groups of objects and
    regular objects in the same way. We also learned about secondary constructors
    and how a function can receive an *arbitrary number of arguments* when using the
    `vararg` keyword. We learned how the Facade design pattern helps us to simplify
    working with complex systems by exposing a simple interface, while the Flyweight
    design pattern allows us to reduce the memory footprint of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've covered how delegating to another class works in Kotlin, implementing
    the same interface and using the `by` keyword in the Proxy design pattern and
    demonstrating its use with a `lazy` delegate. With these design patterns, you
    should be able to structure your system in a much more extensible and maintainable
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll discuss the third family of classic design patterns:
    behavioral patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What differences are there between the implementations of the Decorator and
    Proxy design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main goal of the Flyweight design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the Facade and Adapter design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
