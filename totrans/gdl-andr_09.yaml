- en: Chapter 9. Advanced Build Customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how Gradle works, how to create your own tasks and plugins,
    how to run tests, and how to set up continuous integration, you can almost call
    yourself a Gradle expert. This chapter contains a few tips and tricks that we
    have not mentioned in the previous chapters that make it easier to build, develop,
    and deploy Android projects using Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the APK file size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring Lint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ant from Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced app deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start out by looking at how we can reduce the size of the build output
    and why that is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the APK file size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The size of APK files has been increasing dramatically in the last few years.
    There are several causes for this—more libraries have become available to Android
    developers, more densities have been added, and apps are getting more functionality
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to keep APKs as small as possible. Not only because there
    is a 50 MB limit on APK files in Google Play, but a smaller APK also means that
    users can download and install an app faster, and it keeps the memory footprint
    down.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at a few properties in the Gradle build configuration
    file that we can manipulate to shrink APK files.
  prefs: []
  type: TYPE_NORMAL
- en: ProGuard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ProGuard** is a Java tool that can not only shrink, but also optimize, obfuscate,
    and preverify your code at compile time. It goes through all the code paths in
    your app to find code that is not used and deletes it. ProGuard also renames your
    classes and fields. This process keeps the footprint of the app down, and makes
    the code more difficult to reverse engineer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android plugin for Gradle has a Boolean property called `minifyEnabled`
    on the build type that you need to set to true to enable ProGuard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you set `minifyEnabled` to `true`, the `proguardRelease` task is executed
    and invokes ProGuard during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good idea to retest your entire application after enabling ProGuard,
    because it might remove some code that you still need. This is an issue that has
    made lots of developers weary of ProGuard. To solve this problem, you can define
    ProGuard rules to exclude certain classes from getting removed or obfuscated.
    The `proguardFiles` property is used to define the files that contain ProGuard
    rules. For example, to keep a class, you can add a simple rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getDefaultProguardFile('proguard-android.txt')` method fetches the default
    ProGuard settings from a file called `proguard-android.txt`, which comes with
    the Android SDK in the `tools/proguard` folder. The `proguard-rules.pro` file
    gets added to new Android modules by default by Android Studio, so you can simply
    add rules specific to the module in that file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ProGuard rules are different for each app or library you build, so we will
    not go into too much detail in this book. If you want to know more about ProGuard
    and ProGuard rules, check the official Android ProGuard documentation at [http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html).
  prefs: []
  type: TYPE_NORMAL
- en: Besides shrinking the Java code, it is also a good idea to shrink the used resources.
  prefs: []
  type: TYPE_NORMAL
- en: Shrinking resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle and the Android plugin for Gradle can get rid of all unused resources
    at build time, when the app is being packaged. This can be useful if you have
    old resources that you forgot to remove. Another use case is when you import a
    library that has lots of resources, but you only use a small subset of them. You
    can fix this by enabling resource shrinking. There are two ways to go about shrinking
    resources, automatic or manual.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic shrinking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way is to configure the `shrinkResources` property on your build.
    If you set this property to `true`, the Android build tools will automatically
    try to determine which resources are not used, and not include them in the APK.
  prefs: []
  type: TYPE_NORMAL
- en: There is one requirement for using this feature, though you have to enable ProGuard
    as well. This is due to the way the resource shrinking works, as the Android build
    tools cannot figure out which resources are unused until the code that references
    these resources has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how to configure automatic resource shrinking on
    a certain build type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see exactly how much smaller your APK becomes after enabling
    automatic resource shrinking, you can run the `shrinkReleaseResources` task. This
    task prints out how much it has reduced the package in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get a detailed overview of the resources that are stripped from the
    APK, by adding the `--info` flag to your build command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you use this flag, Gradle prints out a lot of extra information about the
    build process, including every resource it does not include in the final build
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem with automatic resource shrinking is that it might remove too many
    resources. Especially resources that are used dynamically might be accidentally
    stripped out. To prevent this, you can define exceptions in a file called `keep.xml`
    that you place in `res/raw/`. A simple `keep.xml` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `keep.xml` file itself will also be stripped out of the final result.
  prefs: []
  type: TYPE_NORMAL
- en: Manual shrinking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A less drastic way to strip out resources is to get rid of certain language
    files or images for certain densities. Some libraries, such as Google Play Services,
    include a lot of languages. If your app only supports one or two languages, it
    does not make sense to include all the language files from these libraries in
    the final APK. You can use the `resConfigs` property to configure the resources
    you want to keep, and then the rest will be thrown out.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep only English, Danish, and Dutch strings, you can use `resConfigs`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do this for density buckets as well, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is even possible to combine languages and densities. In fact, every type
    of resource can be restricted using this property.
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a hard time setting up ProGuard, or you just want to get rid
    of resources for languages or densities your app does not support, then using
    `resConfigs` is a good way to get started with resource shrinking.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of Android developers that start using Gradle complain about the prolonged
    compilation time. Builds can take longer than they do with Ant, because Gradle
    has three phases in the build lifecycle that it goes through every time you execute
    a task. This makes the whole process very configurable, but also quite slow. Luckily,
    there are several ways to speed up Gradle builds.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to tweak the speed of a Gradle build is to change some of the default
    settings. We already mentioned in parallel build execution in [Chapter 5](ch05.html
    "Chapter 5. Managing Multimodule Builds"), *Managing Multimodule Builds*, but
    there are a few more settings that you can adjust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to recap, you can enable parallel builds by setting a property in a `gradle.properties`
    file that is placed in the root of a project. All you need to do is add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another easy win is to enable the Gradle daemon, which starts a background
    process when you run a build the first time. Any subsequent builds will then reuse
    that background process, thus cutting out the startup cost. The process is kept
    alive as long as you use Gradle, and is terminated after three hours of idle time.
    Using the daemon is particularly useful when you use Gradle several times in a
    short time span. You can enable the daemon in the `gradle.properties` file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Android Studio, the Gradle daemon is enabled by default. This means that
    after the first build from inside the IDE, the next builds are a bit faster. If
    you build from the command-line interface; however, the Gradle daemon is disabled,
    unless you enable it in the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To speed up the compilation itself, you can tweak parameters on the Java Virtual
    Machine (JVM). There is a Gradle property called `jvmargs` that enables you to
    set different values for the memory allocation pool for the JVM. The two parameters
    that have a direct influence on your build speed are `Xms` and `Xmx`. The `Xms`
    parameter is used to set the initial amount of memory to be used, while the `Xmx`
    parameter is used to set a maximum. You can manually set these values in the `gradle.properties`
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You need to set the desired amount and a unit, which can be k for kilobytes,
    m for megabytes, and g for gigabytes. By default, the maximum memory allocation
    (`Xmx`) is set to 256 MB, and the starting memory allocation (`Xms`) is not set
    at all. The optimal settings depend on the capabilities of your computer.
  prefs: []
  type: TYPE_NORMAL
- en: The last property you can configure to influence build speed is `org.gradle.configureondemand`.
    This property is particularly useful if you have complex projects with several
    modules, as it tries to limit the time spent in the configuration phase, by skipping
    modules that are not required for the task that is being executed. If you set
    this property to `true`, Gradle will try to figure out which modules have configuration
    changes and which ones do not, before it runs the configuration phase. This is
    a feature that will not be very useful if you only have an Android app and a library
    in your project. If you have a lot of modules that are loosely coupled, though,
    this feature can save you a lot of build time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**System-wide Gradle properties**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to apply these properties system-wide to all your Gradle-based projects,
    you can create a `gradle.properties` file in the `.gradle` folder in your home
    directory. On Microsoft Windows, the full path to this directory is `%UserProfile%\.gradle`,
    on Linux and Mac OS X it is `~/.gradle`. It is a good practice to set these properties
    in your home directory, rather than on the project level. The reason for this
    is that you usually want to keep memory consumption down on build servers, and
    the build time is of less importance.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Gradle properties you can change to speed up the compilation process are
    also configurable in the Android Studio settings. To find the compiler settings,
    open the **Settings** dialog, and then navigate to **Build, Execution, Deployment**
    | **Compiler**. On that screen, you can find settings for parallel builds, JVM
    options, configure on demand, and so on. These settings only show up for Gradle-based
    Android modules. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Studio](img/B01061_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring these settings from Android Studio is easier than configuring them
    manually in the build configuration file, and the settings dialog makes it easy
    to find properties that influence the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to find out which parts of the build are slowing the process down,
    you can profile the entire build process. You can do this by adding the `--profile`
    flag whenever you execute a Gradle task. When you provide this flag, Gradle creates
    a profiling report, which can tell you which parts of the build process are the
    most time consuming. Once you know where the bottlenecks are, you can make the
    necessary changes. The report is saved as an HTML file in your module in `build/reports/profile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the report generated after executing the build task on a multimodule
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling](img/B01061_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The profiling report shows an overview of the time spent in each phase while
    executing the task. Below that summary is an overview of how much time Gradle
    spent on the configuration phase for each module. There are two more sections
    in the report that are not shown in the screenshot. The **Dependency Resolution**
    section shows how long it took to resolve dependencies, per module. Lastly, the
    **Task Execution** section contains an extremely detailed task execution overview.
    This overview has the timing for every single task, ordered by execution time
    from high to low.
  prefs: []
  type: TYPE_NORMAL
- en: Jack and Jill
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are willing to use experimental tools, you can enable Jack and Jill to
    speed up builds. **Jack** (**Java Android Compiler Kit**) is a new Android build
    toolchain that compiles Java source code directly to the Android Dalvik executable
    (dex) format. It has its own `.jack` library format and takes care of packaging
    and shrinking as well. **Jill** (**Jack Intermediate Library Linker**) is a tool
    that can convert `.aar` and `.jar` files to `.jack` libraries. These tools are
    still quite experimental, but they were made to improve build times and to simplify
    the Android build process. It is not recommended to start using Jack and Jill
    for production versions of your projects, but they are made available so that
    you can try them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use Jack and Jill, you need to use build tools version 21.1.1
    or higher, and the Android plugin for Gradle version 1.0.0 or higher. Enabling
    Jack and Jill is as easy as setting one property in the `defaultConfig` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also enable Jack and Jill on a certain build type or product flavor.
    This way, you can continue using the regular build toolchain, and have an experimental
    build on the side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you set `useJack` to `true`, minification and obfuscation will not
    go through ProGuard anymore, but you can still use the ProGuard rules syntax to
    specify certain rules and exceptions. Use the same `proguardFiles` method that
    we mentioned before, when talking about ProGuard.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring Lint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you execute a release build with Gradle, a Lint check will be performed
    on your code. Lint is a static code analysis tool that flags potential bugs in
    your layouts and Java code. In some cases, it might even block the build process.
    If you have not used Lint on your project before, and you want to migrate to Gradle,
    Lint might come up with a lot of errors. To at least make the build work, you
    can configure Gradle to ignore Lint errors and prevent them from aborting the
    build, by disabling `abortOnError`. This should only be a temporary solution,
    because ignoring Lint errors can result in issues like missing translations, which
    can cause the app to crash. To prevent Lint from blocking the build process, disable
    `abortOnError` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Temporarily disabling the Lint abort can make it easier to migrate an existing
    Ant build process to Gradle. Another way to make the transition smoother is to
    execute Ant tasks directly from Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ant from Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have invested a lot of time in setting up a build with Ant, the switch
    to Gradle might sound scary. In that case, Gradle cannot only execute Ant tasks,
    it can also expand them. This means you can migrate from Ant to Gradle in smaller
    steps, instead of spending several days on converting your entire build configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle uses Groovy's **AntBuilder** for the Ant integration. The AntBuilder
    enables you to execute any standard Ant task, your own custom Ant tasks, and entire
    Ant builds. It also makes it possible to define Ant properties in your Gradle
    build configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Running Ant tasks from Gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running a standard Ant task from Gradle is straightforward. You just need to
    prepend the task name with `ant.` and everything works out of the box. For example,
    to create an archive, you can use this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The task is defined in Gradle, but makes use of two Ant tasks, `echo` and `zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course you should always consider the Gradle alternatives for the standard
    Ant tasks. To create an archive like in the previous example, you can define a
    Gradle task that can handle this for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The task for the Gradle-based archive is more concise and easy to understand.
    Because it does not need to go through the AntBuilder, it is also slightly faster
    than using the Ant tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Importing an entire Ant script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have created an Ant script to build your app, you can import the whole
    build configuration, using `ant.importBuild`. All Ant targets are then automatically
    converted to Gradle tasks that you can access by their original name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the following Ant build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can import this build file into your Gradle build like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will expose the hello task to your Gradle build, so you can execute it
    like a regular Gradle task, and it will print out `Hello, Ant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the Ant task is converted to a Gradle task, you can also extend it
    using the `doFirst` and `doLast` blocks, or the `<<` shortcut. For example, you
    can print another line to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the `hello` task now, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also depend on tasks imported from Ant, just like you usually would.
    For example, if you want to create a new task that depends on the hello task,
    you can simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `dependsOn` makes sure the `hello` task gets triggered when executing
    the `hi` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to, you can even make an Ant task depend on a Gradle task. To accomplish
    this, you need to add the `depends` attribute to the task in the `build.xml` file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a big Ant build file, and you want to make sure none of the task
    names overlap, you can rename all the Ant tasks on import, using this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you decide to rename all the Ant tasks, keep in mind that if you have an
    Ant task that depends on a Gradle task, then that Gradle task needs to be prefixed
    as well. Otherwise, Gradle will not be able to find it and throw an `UnknownTaskException`.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle and Ant cannot only share tasks, but you can also define properties
    in Gradle that can be used in your Ant build files. Consider this Ant target,
    which prints out a property called `version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define the version property in the Gradle build configuration by prepending
    the property name with `ant.`, just like with tasks. This is the shortest way
    to define an Ant property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Groovy hides a lot of the implementation here. If you write the property definition
    in full, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the `version` task will do exactly what you would expect, namely
    printing out `1.0` to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Having deep Ant integration in Gradle makes it a lot easier to transition from
    Ant-based builds to Gradle, and you can do it at a pace that you are comfortable
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced app deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Creating Build Variants"), *Creating Build
    Variants*, we looked at several ways to create multiple versions of the same app,
    using build types and product flavors. However, in some cases, it might be easier
    to use a more specific technique, such as APK splits.
  prefs: []
  type: TYPE_NORMAL
- en: Split APK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Build variants can be seen as separate entities, that can each have their own
    code, resources, and manifest file. APK splits, on the other hand, only impact
    the packaging of an app. The compilation, shrinking, obfuscation, and so on are
    still shared. This mechanism allows you to split APKs based on either density
    or **application binary interface** (**ABI**).
  prefs: []
  type: TYPE_NORMAL
- en: You can configure splits by defining a `splits` block inside the `android` configuration
    block. To configure density splits, create a `density` block inside the `splits`
    block. If you want to set up ABI splits, use an `abi` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you enable density splits, Gradle creates a separate APK for each density.
    You can manually exclude certain densities if you do not need them, to speed up
    the build process. This example shows how to enable density splits and exclude
    devices with low density:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you only support a few densities, you can use `include` to create a whitelist
    of densities. To use include, you first need to use the `reset()` property, which
    resets the list of included densities to an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: The `compatibleScreens` property in the preceding snippet is optional, and injects
    a matching node in the manifest file. The configuration in the example is for
    an app that supports normal to extra large screens, excluding devices with small
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting APKs based on the ABI works in the same way, and all of the properties
    are the same as the properties for density splits, except for `compatibleScreens`.
    ABI splits have nothing to do with screen size, so there is no property called
    `compatibleScreens`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing a build after configuring the density splits is that
    Gradle now creates one universal APK and several density-specific APKs. This means
    you will end up with a collection of APKs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is one caveat to using APK splits, though. If you want to push multiple
    APKs to Google Play, you will need to make sure every APK has a different version
    code. This means that each split should have a unique version code. Luckily, by
    now you are able to do this in Gradle by looking at the `applicationVariants`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet comes straight from the Android plugin for Gradle documentation,
    and shows how to generate different version codes for each APK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This little snippet checks which ABI is used on a build variant, and then applies
    a multiplier to the version code to make sure each variant has a unique version
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you know how to reduce the size of your build outputs,
    and how to speed up builds by configuring Gradle and the JVM. Big migration projects
    should not frighten you anymore. You also learned some tricks that make development
    and deployment easier.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, you have reached the end of the book! Now that you know the possibilities
    of Gradle, you can tweak and customize the build processes of your Android projects
    to the point where you will not need to do any manual work, except for executing
    tasks. You can configure build variants, manage dependencies, and configure multimodule
    projects. The Gradle DSL makes sense to you because you understand Groovy syntax,
    and you are comfortable with hooking into the Android plugin. You can even create
    tasks or plugins and share them, to help others automate their builds. All you
    need to do now is to apply your new skills!
  prefs: []
  type: TYPE_NORMAL
