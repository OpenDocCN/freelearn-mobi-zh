<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. One Piece at a Time – Types, Scopes, and Projects</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Building Blocks – Variables, Collections, and Flow Control">Chapter 2</a>, <em>Building Blocks – Variables, Collections, and Flow Control</em>, we developed a very simple program that helped organize a party. Even though we separated parts of the code in a logical way, everything was written in a single file and our functions were all lumped together. As projects grow in complexity, this way of organizing code is not sustainable. In the same way we use functions to separate out logical components in our code at scale, we also need to be able to separate out the logical components of our functions and data. To do this, we can define code in different files and we can also create our own types that contain custom data and functionality. These types are commonly referred to as <a class="indexterm" id="id86"/>
<strong>objects</strong>, as a part of the programming technique called <a class="indexterm" id="id87"/>
<strong>object-oriented programming</strong>. In this chapter we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Structs</li><li class="listitem" style="list-style-type: disc">Classes and inheritance</li><li class="listitem" style="list-style-type: disc">Enumerations</li><li class="listitem" style="list-style-type: disc">Projects</li><li class="listitem" style="list-style-type: disc">Extensions</li><li class="listitem" style="list-style-type: disc">Scope</li><li class="listitem" style="list-style-type: disc">Access control</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Structs</h1></div></div></div><p>The most basic way <a class="indexterm" id="id88"/>that we can group together data and functionality into a logical unit or object is to define something called a <a class="indexterm" id="id89"/>
<strong>structure</strong>. Essentially, a structure is a named collection of data and functions. Actually, we have already seen several different structures because all of the types such as string, array, and dictionary that we have seen so far are structures. Now we will learn how to create our own.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Types versus instances</h2></div></div></div><p>Let's jump<a class="indexterm" id="id90"/> straight into defining our first structure to represent a contact:</p><div><pre class="programlisting">struct Contact {
    var firstName: String = "First"
    var lastName: String = "Last"
}</pre></div><p>Here we have created a structure by using the <code class="literal">struct</code> keyword followed by a name and curly brackets (<code class="literal">{}</code>) with code inside them. Just like with a function, everything about a structure is defined inside its curly brackets. However, code in a structure is not run directly, it is all part of defining what the structure is. Think of a structure as a specification for future behavior instead of code to be run, in the same way that blueprints are the specification for building a house.</p><p>Here, we have defined two variables for the first and last name. This code does not create any actual variables nor does it remember any data. As with a function, this code is not truly used until another piece of code uses it. Just like with a string, we have to define a new variable or constant of this type. However, in the past we have always used literals like <code class="literal">Sarah</code> or <code class="literal">10</code>. With our own structures, we will have to <em>initialize</em> our own <em>instances</em>, which is just like building a house based on the specifications.</p><p>An instance is a specific incarnation of a type. This could be when we create a <code class="literal">String</code> variable and assign it the value <code class="literal">Sarah</code>. We have created an instance of a <code class="literal">String</code> variable that has the value <code class="literal">Sarah</code>. The string itself is not a piece of data; it simply defines the nature of instances of String that actually contain data.</p><p>Initializing is the formal name for creating a new instance. We initialize a new <code class="literal">Contact</code> like this:</p><div><pre class="programlisting">let someone = Contact()</pre></div><p>You may have noticed that this looks a lot like calling a function and that is because it is very similar. Every type must have at least one special function called an <a class="indexterm" id="id91"/>
<strong>initializer</strong>. As the name implies, this is a function that initializes a new instance of the type. All initializers are named after their type and they may or may not have parameters, just like a function. In our case, we have not provided any parameters so the first and last names will be left with the default values that we provided in our specification: <code class="literal">First</code> and <code class="literal">Last</code>.</p><p>You can see this in a playground by clicking on the plus sign next to <strong>Contact</strong> to the right of that line. This inserts a result pane after the line where it displays the value of <code class="literal">firstName</code> and <code class="literal">lastName</code>. We have just initialized our first custom type!</p><p>If we <a class="indexterm" id="id92"/>define a second contact structure that does not provide default values, it changes how we call the initializer. Since there are no default values, we must provide the values when initializing it:</p><div><pre class="programlisting">struct Contact2 {
    var firstName: String
    var lastName: String
}

let someone2 = Contact2(firstName: "Sarah", lastName: "Smith")</pre></div><p>Again, this looks just like calling a function that happens to be named after the type that we defined. Now, <code class="literal">someone2</code> is an instance of <code class="literal">Contact2</code> with <code class="literal">firstName</code> equal to <code class="literal">Sarah</code> and <code class="literal">lastName</code> equal to <code class="literal">Smith</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Properties</h2></div></div></div><p>The <a class="indexterm" id="id93"/>two variables, <code class="literal">firstName</code> and <code class="literal">lastName</code>, are called <a class="indexterm" id="id94"/>
<strong>member variables</strong> and, if we change them to be constants, they are then called <a class="indexterm" id="id95"/>
<strong>member constants</strong>. This is because they are pieces of information associated with a specific instance of the type. You can access member constants and variables on any instance of a structure:</p><div><pre class="programlisting">print("\(someone.firstName) \(someone.lastName)")</pre></div><p>This is in contrast to a <a class="indexterm" id="id96"/>
<strong>static constant</strong>. We could add a static constant to our type by adding the following line to its definition:</p><div><pre class="programlisting">struct Contact {
    static let UnitedStatesPhonePrefix = "+1" // "First Last"
}</pre></div><p>Note the <code class="literal">static</code> keyword before the constant declaration. A static constant is accessed directly from the type and is independent of any instance:</p><div><pre class="programlisting">print(Contact.UnitedStatesPhonePrefix) // "+1"</pre></div><p>Note that we will be adding code to existing code every so often like this. If you are following along in a playground, you should have added the <code class="literal">static let</code> line to the existing <code class="literal">Contact</code> structure.</p><p>Member and static constants and variables all fall under the category of <a class="indexterm" id="id97"/>
<strong>properties</strong>. A property is simply a piece of information associated with an instance or a type. This helps reinforce the idea that every type is an object. A ball, for example, is an object that has many properties including its radius, color, and elasticity. We can represent a ball in code in an object-oriented way by creating a ball structure that has each of those properties:</p><div><pre class="programlisting">struct Ball {
    var radius: Double
    var color: String
    var elasticity: Double
}</pre></div><p>Note that<a class="indexterm" id="id98"/> this <code class="literal">Ball</code> type does not define default values for its properties. If default values are not provided in the declaration, they are required when initializing an instance of the type. This means that an empty initializer is not available for that type. If you try to use one, you will get an error:</p><div><pre class="programlisting">Ball() // Missing argument for parameter 'radius' in call</pre></div><p>Just like with normal variables and constants, all properties must have a value once initialized.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Member and static methods</h2></div></div></div><p>Just as you can <a class="indexterm" id="id99"/>define constants and variables within a structure, you can also define <a class="indexterm" id="id100"/>
<strong>member</strong> and static functions. These functions are referred to as <strong>methods</strong> to distinguish them from global functions that are not associated with any type. You declare member methods in a similar way to functions but you do so inside the type declaration, as shown:</p><div><pre class="programlisting">struct Contact {
    var firstName: String = "First"
    var lastName: String = "Last"

    func printFullName() {
        print("\(self.firstName) \(self.lastName)")
    }
}</pre></div><p>Member methods always act on a specific instance of the type they are defined in. To access that instance within the method, you use the <code class="literal">self</code> keyword. <code class="literal">Self</code> acts in a similar way to any other variable in that you can access properties and methods on it. The preceding code prints out the <code class="literal">firstName</code> and <code class="literal">lastName</code> properties. You call this method in the same way we called methods on any other type:</p><div><pre class="programlisting">someone.printFullName()</pre></div><p>Within a normal structure method, <code class="literal">self</code> is constant, which means you can't modify any of its properties. If you tried, you would get an error like this:</p><div><pre class="programlisting">struct Ball {
    var radius: Double
    var color: String
    var elasticity: Double

    func growByAmount(amount: Double) {
        // Error: Left side of mutating operator
        // isn't mutable: 'self' is immutable
        self.radius += amount
    }
}</pre></div><p>In <a class="indexterm" id="id101"/>order for a method to modify <code class="literal">self</code>, it must be declared as a <a class="indexterm" id="id102"/>
<strong>mutating method</strong> using the <code class="literal">mutating</code> keyword:</p><div><pre class="programlisting">mutating func growByAmount(amount: Double) {
    self.radius += amount
}</pre></div><p>We can define static properties that apply to the type itself but we can also define <a class="indexterm" id="id103"/>
<strong>static methods</strong> that operate on the type by using the <code class="literal">static</code> keyword. We can add a static method to our <code class="literal">Contact</code> structure that prints the available phone prefixes, as shown here:</p><div><pre class="programlisting">struct Contact {
    static let UnitedStatesPhonePrefix = "+1"

    static func printAvailablePhonePrefixes() {
        print(self.UnitedStatesPhonePrefix)
    }
}

Contact.printAvailablePhonePrefixes() // "+1"</pre></div><p>In a static method, <code class="literal">self</code> refers to the type instead of an instance of the type. In the preceding code, we have used the <code class="literal">UnitedStatesPhonePrefix</code> static property through <code class="literal">self</code> instead of writing out the type name.</p><p>In both static and instance methods, Swift allows you to access properties without using <code class="literal">self,</code> for brevity. <code class="literal">self</code> is simply implied:</p><div><pre class="programlisting">func printFullName() {
    print("\(firstName) \(lastName)")
}

static func printAvailablePhonePrefixes() {
    print(UnitedStatesPhonePrefix)
}</pre></div><p>However, if you create a variable in the method with the same name, you will have to use <code class="literal">self</code> to distinguish which one you want:</p><div><pre class="programlisting">func printFirstName() {
    let firstName = "Fake"
    print("\(self.firstName) \(firstName)") // "First Fake"
}</pre></div><p>I <a class="indexterm" id="id104"/>recommend avoiding this feature of Swift. I want to make you aware of it so you are not confused when looking at other people's code but I feel that always using <code class="literal">self</code> greatly increases the readability of your code. <code class="literal">self</code> makes it instantly clear that the variable is attached to the instance instead of only defined in the function. You could also create bugs if you add code that creates a variable that hides a member variable. For example, you would create a bug if you introduced the <code class="literal">firstName</code> variable to the <code class="literal">printFullName</code> method in the preceding code without realizing you were using <code class="literal">firstName</code> to access the member variable later in the code. Instead of accessing the member variable, the later code would start to only access the local variable.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Computed properties</h2></div></div></div><p>So far, it <a class="indexterm" id="id105"/>seems that properties are used to store information and methods are used to perform calculations. While this is generally true, Swift has a feature called <a class="indexterm" id="id106"/>
<strong>computed properties</strong>. These are properties that are calculated every time they are accessed. To do this, you define a property and then provide a method called a <a class="indexterm" id="id107"/>
<strong>getter</strong> that returns the calculated value, as shown:</p><div><pre class="programlisting">struct Ball {
    var radius: Double
    var diameter: Double {
        get {
            return self.radius * 2
        }
    }
}

var ball = Ball(radius: 2)
print(ball.diameter) // 4.0</pre></div><p>This is a great way to avoid storing data that could potentially conflict with other data. If, instead, <code class="literal">diameter</code> were just another property, it would be possible for it to be different to the <code class="literal">radius</code>. Every time you changed the radius you would have to remember to change the diameter. Using a computed property eliminates this concern.</p><p>You can even provide a second function called a <a class="indexterm" id="id108"/>
<strong>setter</strong> that allows you to assign a value to this property like normal properties:</p><div><pre class="programlisting">var diameter: Double {
    get {
        return self.radius * 2
    }
    set {
        self.radius = diameter / 2
    }
}

var ball = Ball(radius: 2)
ball.diameter = 16
print(ball.radius) // 8.0</pre></div><p>If you provide a setter then you must also explicitly provide a getter. If you don't, Swift allows you to leave out the <code class="literal">get</code> syntax:</p><div><pre class="programlisting">var volume: Double {
    return self.radius * self.radius * self.radius * 4/3 * 4.13
}</pre></div><p>This <a class="indexterm" id="id109"/>provides a nice concise way of defining read-only computed properties.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Reacting to property changes</h2></div></div></div><p>It is pretty common<a class="indexterm" id="id110"/> to need to perform an action whenever a property is changed. One way to achieve this is to define a computed property with a setter that performs the necessary action. However, Swift provides a better way of doing this. You can define a <code class="literal">willSet</code> function or a <code class="literal">didSet</code> function on any stored property. <code class="literal">WillSet</code> is called just <em>before</em> the property is changed and it is provided with a variable <code class="literal">newValue</code>. <code class="literal">didSet</code> is called just <em>after</em> the property is changed and it is provided with a variable <code class="literal">oldValue</code>, as you can see here:</p><div><pre class="programlisting">var radius: Double {
    willSet {
        print("changing from \(self.radius) to \(newValue)")
    }
    didSet {
        print("changed from \(oldValue) to \(self.radius)")
    }
}</pre></div><p>Be careful to avoid creating an infinite loop when using <code class="literal">didSet</code> and <code class="literal">willSet</code> with multiple properties. For example, if you tried to use this technique to keep <code class="literal">diameter</code> and <code class="literal">radius</code> synchronized instead of using a computed property, it would look like this:</p><div><pre class="programlisting">struct Ball {
    var radius: Double {
        didSet {
            self.diameter = self.radius * 2
        }
    }
    var diameter: Double {
        didSet {
            self.radius = self.diameter /  2
        }
    }
}</pre></div><p>In this <a class="indexterm" id="id111"/>scenario, if you set the <code class="literal">radius</code>, it triggers a change on the <code class="literal">diameter</code> which triggers another change on the <code class="literal">radius</code> and that then continues on forever.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Subscripts</h2></div></div></div><p>You may <a class="indexterm" id="id112"/>also have realized that there is another way that we have interacted with a structure in the past. We have used square brackets (<code class="literal">[]</code>) with both arrays and dictionaries to access elements. These are called <a class="indexterm" id="id113"/>
<strong>subscripts</strong> and we can use them on our custom types as well. The syntax for them is similar to the computed properties that we saw before except that you define it more like a method with parameters and a return type, as you can see here:</p><div><pre class="programlisting">struct MovieAssignment {
    var movies: [String:String]

    subscript(invitee: String) -&gt; String? {
        get {
            return self.movies[invitee]
        }

        set {
            self.movies[invitee] = newValue
        }
    }
}</pre></div><p>You declare the arguments you want to use as the parameters to the subscript method in the square brackets. The return type for the subscript function is the type that will be returned when used to access a value. It is also the type for any value you assign to the subscript:</p><div><pre class="programlisting">var assignment = MovieAssignment(movies: [:])
assignment["Sarah"] = "Modern Family"
print(assignment["Sarah"]) // "Modern Family"</pre></div><p>You may have noticed a question mark (<code class="literal">?</code>) in the return type. This is called an <a class="indexterm" id="id114"/>
<strong>optional</strong> and we will discuss this more in the next chapter. For now, you only need to know that this is the type that is returned when accessing a dictionary by key because a value does not exist for every possible key.</p><p>Just like<a class="indexterm" id="id115"/> with computed properties, you can define a subscript as read-only without using the <code class="literal">get</code> syntax:</p><div><pre class="programlisting">struct MovieAssignment {
    var movies: [String:String]

    subscript(invitee: String) -&gt; String? {
        return self.movies[invitee]
    }
}</pre></div><p><code class="literal">subscript</code> can have as many arguments as you want if you add additional parameters to the <code class="literal">subscript</code> declaration. You would then separate each parameter with a comma in the square brackets when using the subscript, as shown:</p><div><pre class="programlisting">struct MovieAssignment {
    subscript(param1: String, param2: Int) -&gt; Int {
        return 0
    }
}

print(assignment["Sarah", 2])</pre></div><p>Subscripts are a good way to shorten your code but you should always be careful to avoid sacrificing clarity for brevity. Writing clear code is a balance between being too wordy and not wordy enough. If your code is too short, it will be hard to understand because meanings will become ambiguous. It is much better to have a method called <code class="literal">movieForInvitee:</code> rather than using a subscript. However, if all of your code is too long, there will be too much noise around and you will lose clarity in that way. Use subscripts sparingly and only when they would appear intuitive to another programmer based on the type of structure you are creating.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Custom initialization</h2></div></div></div><p>If you <a class="indexterm" id="id116"/>are not satisfied with the default initializers provided to you, you can define your own. This is done using the <code class="literal">init</code> keyword, as shown:</p><div><pre class="programlisting">init(contact: Contact) {
    self.firstName = contact.firstName
    self.lastName = contact.lastName
}</pre></div><p>Just like with a method, an initializer can take any number of parameters including none at all. However, initializers have other restrictions. One rule is that every member variable and constant must have a value by the end of the initializer. If we were to omit a value for <code class="literal">lastName</code> in our initializer, we would get an error like this:</p><div><pre class="programlisting">struct Contact4 {
    var firstName: String
    var lastName: String

    init(contact: Contact4) {
        self.firstName = contact.firstName
    }// Error: Return from initializer without
     // initializing all stored properties
}</pre></div><p>Note that this code did not provide default values for <code class="literal">firstName</code> and <code class="literal">lastName</code>. If we add that back, we no longer get an error because a value is then provided:</p><div><pre class="programlisting">struct Contact4 {
    var firstName: String
    var lastName: String = "Last"

    init(contact: Contact4) {
        self.firstName = contact.firstName
    }
}</pre></div><p>Once you provide your own initializer, Swift no longer provides any default initializers. In the preceding example, <code class="literal">Contact</code> can no longer be initialized with the <code class="literal">firstName</code> and <code class="literal">lastName</code> parameters. If we want both, we have to add our own version of that initializer, as shown:</p><div><pre class="programlisting">struct Contact3 {
    var firstName: String
    var lastName: String

    init(contact: Contact3) {
        self.firstName = contact.firstName
        self.lastName = contact.lastName
    }

    init(firstName: String, lastName: String) {
        self.firstName = firstName
        self.lastName = lastName
    }
}
var sarah = Contact3(firstName: "Sarah", lastName: "Smith")
var sarahCopy = Contact3(contact: sarah)
var other = Contact3(firstName: "First", lastName: "Last")</pre></div><p>Another option for setting up the initial values in an initializer is to call a different initializer:</p><div><pre class="programlisting">init(contact: Contact4) {
    self.init(
        firstName: sarah.firstName,
        lastName: sarah.lastName
    )
}</pre></div><p>This is a <a class="indexterm" id="id117"/>great tool for reducing duplicate code in multiple initializers. However, when using this, there is an extra rule that you must follow. You cannot access <code class="literal">self</code> before calling the other initializer:</p><div><pre class="programlisting">init(contact: Contact4) {
    self.print()
    // Use of 'self' in delegating initializer
    // before self.init is called
    self.init(
        firstName: contact.firstName,
        lastName: contact.lastName
     )
}</pre></div><p>This is a great example of why the requirement exists. If we were to call <code class="literal">print</code> before calling the other initializer, <code class="literal">firstName</code> and <code class="literal">lastName</code> would not have a value. What would be printed in that case? Instead, you can only access <code class="literal">self</code> after calling the other initializer, like this:</p><div><pre class="programlisting">init(contact: Contact4) {
    self.init(
        firstName: contact.firstName,
        lastName: contact.lastName
    )
    self.print()
}</pre></div><p>This guarantees that all the properties have a valid value before any method is called.</p><p>You may have noticed that initializers follow a different pattern for parameter naming. By default, initializers require a label for all parameters. However, remember that this is only the default behavior. You can change the behavior by either providing an internal and external name or by using an underscore (<code class="literal">_</code>) as the external name.</p><p>Structures are an incredibly powerful tool in programming. They are an important way that we, as programmers, can abstract away more complicated concepts. As we discussed in <a class="link" href="ch02.html" title="Chapter 2. Building Blocks – Variables, Collections, and Flow Control">Chapter 2</a>, <em>Building Blocks – Variables, Collections, and Flow Control</em>, this is the way we get better at using computers. Other people can provide these abstractions to us for concepts that we don't understand yet or in circumstances where it isn't worth our time to start from scratch. We can also use these abstractions for ourselves so that we can better understand the high-level logic going on in our app. This <a class="indexterm" id="id118"/>will greatly increase the reliability of our code. Structures make our code more understandable both for other people and for ourselves in the future.</p><p>However, structures are limited in one important way, they don't provide a good way to express parent-child relationships between types. For example, a dog and a cat are both animals and share a lot of properties and actions. It would be great if we only had to implement the common attributes once. We could then split those types into different species. For this, Swift has a different system of types called <strong>classes</strong>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Classes</h1></div></div></div><p>A class<a class="indexterm" id="id119"/> can do everything that a structure can do except that a class can use something called <a class="indexterm" id="id120"/>
<strong>inheritance</strong>. A class can inherit the functionality from another class and then extend or customize its behavior. Let's jump right into some code.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Inheriting from another class</h2></div></div></div><p>Firstly, let's<a class="indexterm" id="id121"/> define a class called <code class="literal">Building</code> that we can inherit from later:</p><div><pre class="programlisting">class Building {
    let squareFootage: Int

    init(squareFootage: Int) {
        self.squareFootage = squareFootage
    }
}
var aBuilding = Building(squareFootage: 1000)</pre></div><p>Predictably, a class is defined using the <code class="literal">class</code> keyword instead of <code class="literal">struct</code>. Otherwise, a class looks extremely similar to a structure. However, we can also see one difference. With a structure, the initializer we created before would not be necessary because it would have <a class="indexterm" id="id122"/>been created for us. With classes, initializers are not automatically created unless all of the properties have default values.</p><p>Now let's look at how to inherit from this building class:</p><div><pre class="programlisting">class House: Building {
    let numberOfBedrooms: Int
    let numberOfBathrooms: Double

    init(
        squareFootage: Int,
        numberOfBedrooms: Int,
        numberOfBathrooms: Double
        )
    {
        self.numberOfBedrooms = numberOfBedrooms
        self.numberOfBathrooms = numberOfBathrooms

        super.init(squareFootage: squareFootage)
    }
}</pre></div><p>Here, we have created a new class called <code class="literal">House</code> that inherits from our <code class="literal">Building</code> class. This is denoted by the colon (<code class="literal">:</code>) followed by <code class="literal">Building</code> in the class declaration. Formally, we would say that <code class="literal">House</code> is a <a class="indexterm" id="id123"/>
<strong>subclass</strong> of <code class="literal">Building</code> and <code class="literal">Building</code> is a <a class="indexterm" id="id124"/>
<strong>superclass</strong> of <code class="literal">House</code>.</p><p>If we initialize a variable of the type <code class="literal">House</code>, we can then access both the properties of <code class="literal">House</code> and those of <code class="literal">Building</code>, as shown:</p><div><pre class="programlisting">var aHouse = House(
    squareFootage: 800,
    numberOfBedrooms: 2,
    numberOfBathrooms: 1
)
print(aHouse.squareFootage)
print(aHouse.numberOfBedrooms)</pre></div><p>This is the beginning of what makes classes powerful. If we need to define ten different types of buildings, we don't have to add a separate <code class="literal">squareFootage</code> property to each one. This is true for properties as well as methods.</p><p>Beyond a simple <em>superclass</em> and <em>subclass</em> relationship, we can define an entire hierarchy of classes with subclasses of subclasses of subclasses, and so on. It is often helpful to think of a class hierarchy as an upside down tree:</p><div><img alt="Inheriting from another class" src="img/B05103_03_01.jpg"/></div><p>The trunk of <a class="indexterm" id="id125"/>the tree is the topmost superclass and each subclass is a separate branch off of that. The topmost superclass is commonly referred to as the base class as it forms the foundation for all the other classes.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Initialization</h2></div></div></div><p>Because<a class="indexterm" id="id126"/> of the hierarchical nature of classes, the rules for their initializers <a class="indexterm" id="id127"/>are more complex. The following additional rules are applied:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All initializers in a subclass must call the initializer of its superclass</li><li class="listitem" style="list-style-type: disc">All properties of a subclass must be initialized before calling the superclass initializer</li></ul></div><p>The second rule enables us to use <code class="literal">self</code> before calling the initializer. However, you cannot use <code class="literal">self</code> for any reason other than to initialize its properties.</p><p>You may have noticed the use of the keyword <code class="literal">super</code> in our <code class="literal">house</code> initializer. <code class="literal">super</code> is used to reference the current instance as if it were its superclass. This is how we call the superclass initializer. We will see more uses of <code class="literal">super</code> when we explore inheritance further later in the chapter.</p><p>Inheritance also creates four types of initializers shown here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overriding initializer</li><li class="listitem" style="list-style-type: disc">Required initializer</li><li class="listitem" style="list-style-type: disc">Designated initializer</li><li class="listitem" style="list-style-type: disc">Convenience initializer</li></ul></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Overriding initializer</h3></div></div></div><p>An <a class="indexterm" id="id128"/>
<strong>overriding initializer</strong> <a class="indexterm" id="id129"/>is used to replace the initializer in a superclass:</p><div><pre class="programlisting">class House: Building {
    let numberOfBedrooms: Int
    let numberOfBathrooms: Double

    override init(squareFootage: Int) {
        self.numberOfBedrooms = 0
        self.numberOfBathrooms = 0
        super.init(squareFootage: squareFootage)
    }
}</pre></div><p>An initializer that takes only <code class="literal">squareFootage</code> as a parameter already exists in <code class="literal">Building</code>. This initializer replaces that initializer so if you try to initialize <code class="literal">House</code> using only <code class="literal">squareFootage</code>, this initializer will be called. It will then call the <code class="literal">Building</code> version of the initializer because we asked it to with the <code class="literal">super.init</code> call.</p><p>This ability is especially important if you want to initialize subclasses using their superclass initializer. By default, if you don't specify a new initializer in a subclass, it inherits all of the initializers from its superclass. However, as soon as you declare an initializer in a subclass, it hides all of the superclass initializers. By using an overriding initializer, you can expose the superclass version of the initializer again.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Required initializer</h3></div></div></div><p>A <a class="indexterm" id="id130"/>
<strong>required initializer</strong> is<a class="indexterm" id="id131"/> a type of initializer for superclasses. If you mark an initializer as required, it forces all of the subclasses to also define that initializer. For example, we could make the <code class="literal">Building</code> initializer required, as shown:</p><div><pre class="programlisting">class Building {
    let squareFootage: Int

    required init(squareFootage: Int) {
        self.squareFootage = squareFootage
    }
}</pre></div><p>Then, if we implemented our own initializer in <code class="literal">House</code>, we would get an error like this:</p><div><pre class="programlisting">class House: Building {
    let numberOfBedrooms: Int
    let numberOfBathrooms: Double

    init(
        squareFootage: Int,
        numberOfBedrooms: Int,
        numberOfBathrooms: Double
        )
    {
        self.numberOfBedrooms = numberOfBedrooms
        self.numberOfBathrooms = numberOfBathrooms

        super.init(squareFootage: squareFootage)
    }

    // 'required' initializer 'init(squareFootage:)' must be
    // provided by subclass of 'Building'
}</pre></div><p>This time, when <a class="indexterm" id="id132"/>declaring this initializer, we repeat<a class="indexterm" id="id133"/> the <code class="literal">required</code> keyword instead of using <code class="literal">override</code>:</p><div><pre class="programlisting">required init(squareFootage: Int) {
    self.numberOfBedrooms = 0
    self.numberOfBathrooms = 0
    super.init(squareFootage: squareFootage)
}</pre></div><p>This is an important tool when your superclass has multiple initializers that do different things. For example, you could have one initializer that creates an instance of your class from a data file and another one that sets its properties from code. Essentially, you have two paths for initialization and you can use the required initializers to make sure that all subclasses take both paths into account. A subclass should still be able to be initialized from both a file and in code. Marking both of the superclass initializers as required makes sure that this is the case.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Designated and convenience initializers</h3></div></div></div><p>To <a class="indexterm" id="id134"/>discuss <a class="indexterm" id="id135"/>
<strong>designated initializers, </strong>we first have to talk about <a class="indexterm" id="id136"/>
<strong>convenience initializers</strong>. The normal initializer that we started with is really called a designated initializer. This means that they are core ways to initialize the class. You can also create convenience initializers which, as the name suggests, are there for convenience and are not a core way to initialize the class.</p><p>All <a class="indexterm" id="id137"/>convenience initializers must call a designated initializer and they do not have the ability to manually initialize properties like a designated initializer does. For example, we can define a convenience initializer on our <code class="literal">Building</code> class that takes another building and makes a copy:</p><div><pre class="programlisting">class Building {
    // ...

    convenience init(otherBuilding: Building) {
        self.init(squareFootage: otherBuilding.squareFootage)
    }
}
var aBuilding = Building(squareFootage: 1000)
var defaultBuilding = Building(otherBuilding: aBuilding)</pre></div><p>Now, as a <a class="indexterm" id="id138"/>convenience, you can create a new building using the properties from an existing building. The other rule about convenience initializers is that they cannot be used by a subclass. If you try to do that, you will get an error like this:</p><div><pre class="programlisting">class House: Building {

    // ...

    init() {
        self.numberOfBedrooms = 0
        self.numberOfBathrooms = 0
        super.init() // Missing argument for parameter 'squareFootage' in call
    }
}</pre></div><p>This is one <a class="indexterm" id="id139"/>of the main reasons that convenience initializers exist. Ideally, every class should only have one designated initializer. The <a class="indexterm" id="id140"/>fewer designated initializers you have, the easier it is to maintain your class hierarchy. This is because you will often add additional <a class="indexterm" id="id141"/>properties and other things that need to be initialized. Every time you add something like that, you will have to make sure that every designated initializer sets things up properly and consistently. Using a convenience initializer instead of a designated initializer ensures that everything is consistent because it must call a designated initializer that, in turn, is required to set everything up properly. Basically, you want to funnel all of your initialization through as few designated initializers as possible.</p><p>Generally, your designated initializer is the one with the most arguments, possibly with all of the possible arguments. In that way, you can call that from all of your other initializers and mark them as convenience initializers.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Overriding methods and computed properties</h2></div></div></div><p>Just as <a class="indexterm" id="id142"/>with initializers, subclasses can <strong>override</strong> methods and computed properties. However, you have to be more careful with these. The compiler has fewer protections.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Methods</h3></div></div></div><p>Even <a class="indexterm" id="id143"/>though it is possible, there is no requirement that an <strong>overriding method</strong> calls its superclass implementation. For example, let's add clean methods to our <code class="literal">Building</code> and <code class="literal">House</code> classes:</p><div><pre class="programlisting">class Building {
    // ...

    func clean() {
        print(
            "Scrub \(self.squareFootage) square feet of floors"
        )
    }
}

class House: Building {
    // ...

    override func clean() {
        print("Make \(self.numberOfBedrooms) beds")
        print("Clean \(self.numberOfBathrooms) bathrooms")
    }
}</pre></div><p>In our <code class="literal">Building</code> superclass, the only thing that we have to clean is the floors. However, in our <code class="literal">House</code> subclass, we also have to make the beds and clean the bathrooms. As it has been implemented above, when we call <code class="literal">clean</code> on <code class="literal">House</code>, it will not clean the floors because we overrode that behavior with the <code class="literal">clean</code> method on <code class="literal">House</code>. In this case, we also need to have our <code class="literal">Building</code> superclass do any necessary cleaning, so we must call the superclass version, as shown:</p><div><pre class="programlisting">override func clean() {
    super.clean()

    print("Make \(self.numberOfBedrooms) beds")
    print("Clean \(self.numberOfBathrooms) bathrooms")
}</pre></div><p>Now, before doing any cleaning based on the house definition, it will first clean based on the building definition. You can control the order in which things happen by changing the place in which you call the super version.</p><p>This is a great <a class="indexterm" id="id144"/>example of the need to override methods. We can provide common functionality in a superclass that can be extended in each of its subclasses instead of rewriting the same functionality in multiple classes.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Computed properties</h3></div></div></div><p>It is also <a class="indexterm" id="id145"/>useful to override computed properties using the <code class="literal">override</code> keyword again:</p><div><pre class="programlisting">class Building {
    // ...

    var estimatedEnergyCost: Int {
        return squareFootage / 10
    }
}

class House: Building {
    // ...

    override var estimatedEnergyCost: Int {
        return 100 + super.estimatedEnergyCost
    }
}</pre></div><p>In our <code class="literal">Building</code> superclass, we have provided an estimate for energy costs based on $100 per 1000 square feet. That estimate still applies to the house but there are additional costs related to someone else living in the building. We must therefore override the <code class="literal">estimatedEnergyCost</code> computed property to return the <code class="literal">Building</code> calculation plus $100.</p><p>Again, using the super version of an overriding computed property is not required. A subclass could have a completely different implementation disregarding what is implemented in its superclass, or it could make use of its superclass implementation.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Casting</h2></div></div></div><p>We <a class="indexterm" id="id146"/>have <a class="indexterm" id="id147"/>already talked about how classes are great for sharing functionality between a hierarchy of types. Another thing that makes classes powerful is that they allow code to interact with multiple types in a more general way. Any subclass can be used in code that treats it as if it were its superclass. For example, we might want to write a function that calculates the total square footage of an array of buildings. For this function, we don't care what specific type of building it is, we just need to have <a class="indexterm" id="id148"/>access to the <code class="literal">squareFootage</code> property that is defined in the superclass. We can <a class="indexterm" id="id149"/>define our function to take an array of buildings and the actual array can contain <code class="literal">House</code> instances:</p><div><pre class="programlisting">func totalSquareFootageOfBuildings(buildings: [Building]) -&gt; Int {
    var sum = 0
    for building in buildings {
        sum += building.squareFootage
    }
    return sum
}

var buildings = [
    House(squareFootage: 1000),
    Building(squareFootage: 1200),
    House(squareFootage: 900)
]
print(totalSquareFootageOfBuildings(buildings)) // 3100</pre></div><p>Even though this function thinks we are dealing with classes of the type <code class="literal">Building</code>, the program will execute the <code class="literal">House</code> implementation of <code class="literal">squareFootage</code>. If we had also created an office subclass of <code class="literal">Building</code>, instances of that would also be included in the array as well with its own implementation.</p><p>We can also assign an instance of a subclass to a variable that is defined to be one of its superclasses:</p><div><pre class="programlisting">var someBuilding: Building = House(squareFootage: 1000)</pre></div><p>This provides us with an even more powerful abstraction tool than the one we had when using structures. For example, let's consider a hypothetical class hierarchy of images. We might have a base class called <code class="literal">Image</code> with subclasses for the different types of encodings like <code class="literal">JPGImage</code> and <code class="literal">PNGImage</code>. It is great to have the subclasses so that we can cleanly support multiple types of images but, once the image is loaded, we no longer need to be concerned with the type of encoding the image is saved in. Every other class that wants to manipulate or display the image can do so with a well-defined image superclass; the encoding of the image has been abstracted away from the rest of the code. Not only does this create easier to understand code but it also makes maintenance much easier. If we need to add another image encoding like <a class="indexterm" id="id150"/>
<strong>GIF</strong>, we can create another subclass and all the existing manipulation and display code can get GIF support with no changes to that code.</p><p>There are actually two different types of casting. So far, we have only seen the type of casting called <a class="indexterm" id="id151"/>
<strong>upcasting</strong>. Predictably, the other type of casting is called <a class="indexterm" id="id152"/>
<strong>downcasting</strong>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Upcasting</h3></div></div></div><p>What <a class="indexterm" id="id153"/>we have <a class="indexterm" id="id154"/>seen so far is called upcasting because we are going up the class tree that we visualized earlier by treating a subclass as its superclass. Previously, we upcasted by assigning a subclass instance to a variable that was defined as its superclass. We could do the same thing using the <code class="literal">as</code> operator instead, like this:</p><div><pre class="programlisting">var someBuilding2 = House(squareFootage: 1000) as Building</pre></div><p>It is really personal preference as to which you should use.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Downcasting</h3></div></div></div><p>Downcasting <a class="indexterm" id="id155"/>means that we treat a superclass as one of its subclasses.</p><p>While <a class="indexterm" id="id156"/>upcasting can be done implicitly by using it in a function declared to use its superclass or by assigning it to a variable with its superclass type, downcasting must be done explicitly. This is because upcasting cannot fail based on the nature of its inheritance, but downcasting can. You can always treat a subclass as its superclass but you cannot guarantee that a superclass is, in fact, one of its specific subclasses. You can only downcast an instance that is, in fact, an instance of that class or one of its subclasses.</p><p>We can force downcast by using the <code class="literal">as!</code> Operator, like this:</p><div><pre class="programlisting">var house = someBuilding as! House
print(house.numberOfBathrooms)</pre></div><p>The <code class="literal">as!</code> operator has an exclamation point added to it because it is an operation that can fail. The exclamation point serves as a warning and ensures that you realize that it can fail. If the forced downcasting fails, for example, if <code class="literal">someBuilding</code> were not actually <code class="literal">House</code>, the program would crash as so:</p><div><pre class="programlisting">var anotherHouse = aBuilding as! House // Execution was interrupted</pre></div><p>A safer way to perform downcasting is using the <code class="literal">as?</code> operator in a special <code class="literal">if</code> statement called an optional binding. We will discuss this in detail in the next chapter, which concerns optionals but, for now, you can just remember the syntax:</p><div><pre class="programlisting">if let house = someBuilding as? House {
    // someBuilding is of type House
    print(house.numberOfBathrooms)
}
else {
    print("someBuilding is not a house")
}</pre></div><p>This code prints out <code class="literal">numberOfBathrooms</code> in the building only if it is of the type <code class="literal">House</code>. The <code class="literal">House</code> constant is used as a temporary view of <code class="literal">someBuilding</code> with its type explicitly set to <code class="literal">House</code>. With this temporary view, you can access <code class="literal">someBuilding</code> as if it were <code class="literal">House</code> instead of just <code class="literal">Building</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Enumerations</h1></div></div></div><p>So far, we <a class="indexterm" id="id157"/>have covered two of the three types of classification in Swift: structure and class. The third classification is called <strong>enumeration</strong>. Enumerations are used to define a group of related values for an instance. For example, if we want values to represent one of the three primary colors, an enumeration is a great tool.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Basic declaration</h2></div></div></div><p>An<a class="indexterm" id="id158"/> enumeration is made up of <strong>cases</strong> much like a switch and uses the keyword <code class="literal">enum</code> instead of <code class="literal">struct</code> or <code class="literal">class</code>. An enumeration for primary colors should look like this:</p><div><pre class="programlisting">enum PrimaryColor {
    case Red
    case Green
    case Blue
}</pre></div><p>You can then define a variable with this type and assign it one of the cases:</p><div><pre class="programlisting">var color = PrimaryColor.Green</pre></div><p>Note that, to use one of the values, we must use the name of the type followed by a dot (<code class="literal">.</code>) and then the specific case. If the type of the variable can be inferred, you can even leave out the enumeration name and just start with a dot:</p><div><pre class="programlisting">var color = PrimaryColor.Green
color = .Red</pre></div><p>During the assignment to <code class="literal">.Red</code>, the compiler already knows that the <code class="literal">color</code> variable is of the type <code class="literal">PrimaryColor</code> so it doesn't need us to specify that again. This is a great way of making your code more concise but make sure you don't sacrifice legibility. If you leave out the type name, it should still be obvious from the context of the code.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Testing enumeration values</h2></div></div></div><p>Enumeration<a class="indexterm" id="id159"/> instances can be tested for a specific value as with any other type, using the equality operator (<code class="literal">==</code>):</p><div><pre class="programlisting">if color == PrimaryColor.Red {
}
else if color == .Blue {
}</pre></div><p>Note that, in the second <code class="literal">if</code> statement, where <code class="literal">color</code> is checked for if it is blue, the code takes advantage of type inference and doesn't bother specifying <code class="literal">PrimaryColor</code>.</p><p>This <a class="indexterm" id="id160"/>method of comparison is familiar and useful for one or two possible values. However, there is a better way to test an enumeration for different values. Instead of using an <code class="literal">if</code> statement, you can use a switch. This is a logical solution considering that enumerations are made up of cases and switches test for cases:</p><div><pre class="programlisting">switch color {
    case .Red:
        print("color is red")
    case .Green:
        print("color is green")
    case .Blue:
        print("color is blue")
}</pre></div><p>This is great for all the same reasons that switches themselves are great. In fact, switches work even better with enumerations because the possible values for an enumeration are always finite, unlike other basic types. You may remember that switches require that you have a case for every possible value. This means that, if you don't have a test case for every case of the enumeration, the compiler will produce an error. This is usually great protection and that is why I recommend using switches rather than simple <code class="literal">if</code> statements in most circumstances. If you ever add additional cases to an enumeration, it is great to get an error everywhere in your code that doesn't consider that new case so that you make sure you address it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Raw values</h2></div></div></div><p>Enumerations <a class="indexterm" id="id161"/>are great because they provide the ability to store information that is not based on the basic types provided by Swift such as strings, integers, and doubles. There are many abstract concepts like our color example, that are not at all related to a basic type. However, you often want each enumeration case to have a <strong>raw value</strong><a class="indexterm" id="id162"/> that is another type. For example, if we wanted to represent all of the coins in United States currency along with their monetary value, we could make our enumeration have an integer raw value type, like this:</p><div><pre class="programlisting">enum USCoins: Int {
    case Quarter = 25
    case Dime = 10
    case Nickel = 5
    case Penny = 1
}</pre></div><p>The raw <a class="indexterm" id="id163"/>value type is specified in the same way that inheritance is specified with classes and then each case is individually assigned a specific value of that type.</p><p>You can access the raw value of a case at any time by using the <code class="literal">rawValue</code> property:</p><div><pre class="programlisting">print("A Quarter is worth \(USCoins.Quarter.rawValue) cents.")</pre></div><p>Keep in mind that an enumeration can only have raw value types that can be defined with literals like <code class="literal">10</code>, or <code class="literal">String</code>. You cannot define an enumeration with your own custom type as its raw value.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Associated values</h2></div></div></div><p>Raw values <a class="indexterm" id="id164"/>are great for when every case in your enumeration has the same type of value associated with it and its value never changes. However, there are also scenarios where each case has different values associated with it and those values are different for each instance of the enumeration. You may even want a case that has multiple values associated with it. To do this, we use a feature of enumerations called <a class="indexterm" id="id165"/>
<strong>associated values</strong>.</p><p>You can specify zero or several types to be associated separately with each case with associated values. Then, when creating an instance of the enumeration, you can give it any value you want, as shown:</p><div><pre class="programlisting">enum Height {
    case Imperial(feet: Int, inches: Double)
    case Metric(meters: Double)
    case Other(String)
}
var height1 = Height.Imperial(feet: 6, inches: 2)
var height2 = Height.Metric(meters: 1.72)
var height3 = Height.Other("1.9 × 10-16 light years")</pre></div><p>Here, we have defined an enumeration to store a height measurement using various measurement systems. There is a case for the imperial system that uses feet and inches and a case for the metric system that is in just meters. Both of these cases have labels for their associated values which are similar to a tuple. The last case is there to illustrate that you don't have to provide a label if you don't want to. It simply takes a string.</p><p>Comparing and accessing values of enumerations with associated values is a little bit more complex than for regular enumerations. We can no longer use the equality operator (<code class="literal">==</code>). Instead, we must always use a case. Within a case, there are multiple ways that you can handle the associated values. The easiest thing to do is to access the specific associated value. To do that, you can assign it to a temporary variable:</p><div><pre class="programlisting">switch height1 {
    case .Imperial(let feet, var inches):
        print("\(feet)ft \(inches)in")
    case let .Metric(meters):
        print("\(meters) meters")
    case var .Other(text):
        print(text)
}</pre></div><p>In the <a class="indexterm" id="id166"/>imperial case, the preceding code assigned <code class="literal">feet</code> to a temporary constant and <code class="literal">inches</code> to a temporary variable. The names match the labels used for the associated values but that is not necessary. The metric case shows that, if you want all of the temporary values to be constant, you can declare <code class="literal">let</code> before the enumeration case. No matter how many associated values there are, <code class="literal">let</code> only has to be written once instead of once for every value. The other case is the same as the metric case except that it creates a temporary variable instead of a constant.</p><p>If you wanted to create separate cases for conditions on the associated values, you could use the <code class="literal">where</code> syntax that we saw in the previous chapter:</p><div><pre class="programlisting">switch height1 {
    case .Imperial(let feet, var inches) where feet &gt; 1:
        print("\(feet)ft \(inches)in")
    case let .Metric(meters) where meters &gt; 0.3:
        print("\(meters) meters")
    case var .Other(text):
        print(text)
    default:
        print("Too Small")
}</pre></div><p>Note that we had to add a default case because our restrictions on the other cases were no longer exhaustive.</p><p>Lastly, if you don't actually care about the associated value, you can use an underscore (<code class="literal">_</code>) to ignore it, as shown:</p><div><pre class="programlisting">switch height1 {
    case .Imperial(_, _):
        print("Imperial")
    case .Metric(_):
        print("Metric")
    case .Other(_):
        print("Other")
}</pre></div><p>This shows you that, with enumerations, switches have even more power than we saw previously.</p><p>Now that you understand how to use associated values, you might have noticed that they can change the conceptual nature of enumerations. Without associated values, an enumeration represents a list of abstract and constant possible values. An enumeration with associated values is different because two instances with the same case are not necessarily equal; each case could have different associated values. This means that the conceptual <a class="indexterm" id="id167"/>nature of enumerations is really a list of ways to look at a certain type of information. This is not a concrete rule but it is common and it gives you a better idea of the different types of information that can best be represented by enumerations. It will also help you make your own enumerations more understandable. Each case could theoretically represent a completely unrelated concept from the rest of the cases using associated values but that should be a sign that an enumeration may not be the best tool for that particular job.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Methods and properties</h2></div></div></div><p>Enumerations <a class="indexterm" id="id168"/>are actually very similar to structures. As with structures, enumerations can have methods and properties. To improve the <code class="literal">Height</code> enumeration, we could add methods to access the height in any measurement system we wanted. As an example, let's implement a <code class="literal">meters</code> method, as follows:</p><div><pre class="programlisting">enum Distance {
    case Imperial(feet: Int, inches: Double)
    case Metric(meters: Double)

    func meters() -&gt; Double {
        switch self {
            case let .Imperial(feet, inches):
                return Double(feet)*0.3048+inches*0.3048/12
            case let .Metric(meters):
                return meters
        }
    }
}
var distance1 = Distance.Imperial(feet: 6, inches: 2)
distance1.meters() // 1.8796</pre></div><p>In this method, we have switched on <code class="literal">self</code> which tells us which unit of measurement this instance was created with. If it is in meters we can just return that but, if it is in feet and inches, we must do the conversion. As an exercise, I recommend you try to implement a <code class="literal">feetAndInches</code> method that returns a tuple with the two values. The biggest challenge is in handling the mathematical operations using the correct types. You cannot perform operations with mismatching types mathematically. If you need to convert from one number type to another, you can do so by initializing a copy as shown in the code above: <code class="literal">Double(feet)</code>. Unlike the casting that we discussed earlier, this process simply creates a new copy of the <code class="literal">feet</code> variable that is now <code class="literal">Double</code> instead of <code class="literal">Int</code>. This is only possible because the <code class="literal">Double</code> type happens to define an initializer that takes <code class="literal">Int</code>. Most number types can be initialized with any of the other ones.</p><p>You now <a class="indexterm" id="id169"/>have a great overview of all of the different ways in which we can organize Swift code in a single file to make the code more understandable and maintainable. It is now time to discuss how we can separate our code into multiple files to improve it even more.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Projects</h1></div></div></div><p>If we<a class="indexterm" id="id170"/> want to move away from developing with a single file, we need to move away from playgrounds and create our first project. In order to simplify the project, we are going to create a <a class="indexterm" id="id171"/>
<strong>command-line tool</strong>. This is a program without a graphical interface. As an exercise, we will redevelop our example program from <a class="link" href="ch02.html" title="Chapter 2. Building Blocks – Variables, Collections, and Flow Control">Chapter 2</a>, <em>Building Blocks – Variables, Collections, and Flow Control</em> which managed invitees to a party. We will develop an app with a graphical interface in <a class="link" href="ch11.html" title="Chapter 11. A Whole New World – Developing an App">Chapter 11</a>, <em>A Whole New World – Developing an App</em>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Setting up a command-line Xcode project</h2></div></div></div><p>To <a class="indexterm" id="id172"/>create a new command-line tool project, open Xcode and from the menu bar on the top, select <strong>File</strong> | <strong>New</strong> | <strong>Project…</strong>. A window will appear allowing you to select a template for the project. You should choose <strong>Command Line Tool</strong> from the <strong>OS X</strong> | <strong>Application</strong> menu:</p><div><img alt="Setting up a command-line Xcode project" src="img/B05103_03_02.jpg"/></div><p>From<a class="indexterm" id="id173"/> there, click <strong>Next</strong> and then give the project a name like <code class="literal">Learning Swift Command Line</code>. Any <strong>Organization Name</strong> and <strong>Identifier</strong> are fine. Finally, make sure that <strong>Swift</strong> is selected from the <strong>Language</strong> dropdown and click <strong>Next</strong> again. Now, save the project somewhere that you can find later and click <strong>Create</strong>.</p><p>Xcode will then present you with the project development window. Select the <code class="literal">main.swift</code> file on the left and you should see the <code class="literal">Hello, World!</code> code that Xcode has generated for you:</p><div><img alt="Setting up a command-line Xcode project" src="img/B05103_03_03.jpg"/></div><p>This should feel pretty similar to a playground except that we can no longer see the output of the code on the right. In a regular project like this, the code is not run automatically for you. The code will still be analyzed for errors as you write it, but you must run it yourself whenever you want to test it. To run the code, you can click the run button <a class="indexterm" id="id174"/>on the toolbar, which looks like a play button.</p><p>The program will then build and run. Once it does, Xcode shows the console on the bottom where you will see the text <code class="literal">Hello, World!</code> which is the result of running this program. This is the same console as we saw in playgrounds.</p><p>Unlike a playground, we have the Project Navigator along the left. This is where we organize all of the source files that go into making the application work.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Creating and using an external file</h2></div></div></div><p>Now that we have <a class="indexterm" id="id175"/>successfully created our command-line project, let's create our first new file. It is common to create a separate file for each type that you <a class="indexterm" id="id176"/>create. Let's start by creating a file for an <code class="literal">invitee</code> class. We want to add the file to the same file group as the <code class="literal">main.swift</code> file, so click on that group. You can then click on the plus sign (<strong>+</strong>) in the lower left of the window and select <strong>New File</strong>. From that window, select <strong>OS X</strong> | <strong>Source</strong> | <strong>Swift File</strong> and click <strong>Next</strong>:</p><div><img alt="Creating and using an external file" src="img/B05103_03_04.jpg"/></div><p>The new file will be placed in whatever folder was selected before entering the dialog. You can always drag a file around to organize it however you want. A great place for this file is next to <code class="literal">main.swift</code>. Name <a class="indexterm" id="id177"/>your new file <code class="literal">Invitee.swift</code> and click <strong>Create</strong>. Let's add a simple <code class="literal">Invitee</code> structure to this file. We want <code class="literal">Invitee</code> to have a name and to be able to ask them to the party with or without a show:</p><div><pre class="programlisting">// Invitee.swift
struct Invitee {
    let name: String

    func askToBringShowFromGenre(genre: ShowGenre) {
        print("\(self.name), bring a \(genre.name) show")
        print("\(genre.example) is a great \(genre.name)")
    }

    func askToBringThemselves() {
        print("\(self.name), just bring yourself")
    }
}</pre></div><p>This is a very simple type and does not require inheritance, so there is no reason to use a class. Note that inheritance is not the only reason to use a class, as we will see in later chapters but, for now, a structure will work great for us. This code provides simple, well-named methods to print out the two types of invites.</p><p>We are already making use of a structure that we have not created yet called <code class="literal">ShowGenre</code>. We would expect it to have a <code class="literal">name</code> and <code class="literal">example</code> property. Let's implement that structure now. Create another file called <code class="literal">ShowGenre.swift</code> and add the following code to it:</p><div><pre class="programlisting">// ShowGenre.swift
struct ShowGenre {
    let name: String
    let example: String
}</pre></div><p>This is an even simpler structure. This is just a small improvement over using a tuple because it is given a name instead of just properties and it also gives us finer control over what is constant or not. It may seem like a waste to have an entire file for just this but this is great for maintainability in the future. It is easier to find the structure because it is in a well-named file and we may want to add more code to it later.</p><p>An important principle in code design is called <a class="indexterm" id="id178"/>
<strong>separation of concerns</strong>. The idea is that every file and every type should have a clear and well-defined concern. You should avoid having two files or types responsible for the same thing and you want it to be clear why each file and type exists.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Interfacing with code from other files</h2></div></div></div><p>Now that <a class="indexterm" id="id179"/>we have our basic data structures, we can use a smarter container for our list of invitees. This list contains the logic for assigning a random invitee a genre. Let's start by defining the structure with some properties:</p><div><pre class="programlisting">// InviteList.swift
struct InviteList {
    var invited: [Invitee] = []
    var pendingInvitees: [Invitee]

    init(invitees: [Invitee]) {
        srand(UInt32(clock()))
        self.pendingInvitees = invitees
    }
}</pre></div><p>Instead of storing a single list of both invited and pending invitees, we can store them in two separate arrays. This makes selecting a pending invitee much easier. This code also provides a custom initializer, so that all we need to provide from other classes is an invitee list without worrying whether or not it is a list of pending invitees. We could have just used the default initializer but the parameter would then have been named <code class="literal">pendingInvitees</code>. We also seed the random number generator for later use.</p><p>Note that we did not need to provide a value for <code class="literal">invited</code> in our initializer because we gave it the default value of an empty array.</p><p>Note also that we are using our <code class="literal">Invitee</code> structure freely in this code. Swift automatically finds code from other files in the same project and allows you to use it. Interfacing with code from other files is as simple as that.</p><p>Now, let's add a helper function to move an invitee from the <code class="literal">pendingInvitee</code> list to the <code class="literal">invited</code> list:</p><div><pre class="programlisting">// InviteList.swift
struct InviteList {

    // ...

    // Move invitee from pendingInvitees to invited
    //
    // Must be mutating because we are changing the contents of
    // our array properties
    mutating func invitedPendingInviteeAtIndex(index: Int) {
        // Removing an item from an array returns that item
        let invitee = self.pendingInvitees.removeAtIndex(index)
        self.invited.append(invitee)
    }
}</pre></div><p>This makes our other methods cleaner and easier to understand. The first thing we want to allow is the inviting <a class="indexterm" id="id180"/>of a random invitee and then asking them to bring a show from a specific <code class="literal">genre</code>:</p><div><pre class="programlisting">// InviteList.swift
struct InviteList {

    // ...

    // Must be mutating because it calls another mutating method
    mutating func askRandomInviteeToBringGenre(genre: ShowGenre) {
        if self.pendingInvitees.count &gt; 0 {
            let randomIndex = Int(rand()) % self.pendingInvitees.count
            let invitee = self.pendingInvitees[randomIndex]
            invitee.askToBringShowFromGenre(genre)
            self.invitedPendingInviteeAtIndex(randomIndex)
        }
    }
}</pre></div><p>The picking of a random invitee is much cleaner than in our previous implementation. We can create a random number between <code class="literal">0</code> and the number of pending invitees instead of having to keep trying a random invitee until we find one that hasn't been invited yet. However, before we can pick that random number, we have to make sure that the number of pending invitees is greater than zero. If there were no remaining invitees we would have to divide the random number by <code class="literal">0</code> in <code class="literal">Int(rand()) % self.pendingInvitees.count</code>. This would cause a crash. It has the extra benefit of allowing us to handle the scenarios where there are more genres than invitees.</p><p>Lastly, we want to be able to invite everyone else to just bring themselves:</p><div><pre class="programlisting">// InviteList.swift
struct InviteList {

    // ...

    // Must be mutating because it calls another mutating method
    mutating func inviteeRemainingInvitees() {
        while self.pendingInvitees.count &gt; 0 {
            let invitee = self.pendingInvitees[0]
            invitee.askToBringThemselves()
            self.invitedPendingInviteeAtIndex(0)
        }
    }
}</pre></div><p>Here, we have simply repeatedly invited and removed the first pending invitee from the <code class="literal">pendingInvitees</code> array until there are none left.</p><p>We now have all of <a class="indexterm" id="id181"/>our custom types and we can return to the <code class="literal">main.swift</code> file to finish the logic of the program. To switch back, you can just click on the file again in Project Navigator (the list of files on the left). Here, all we want to do is to create our invitee list and a list of genres with example shows. Then, we can loop through our genres and ask our invitee list to do the inviting:</p><div><pre class="programlisting">var inviteeList = InviteList(invitees: [
    Invitee(name: "Sarah"),
    Invitee(name: "Jamison"),
    Invitee(name: "Marcos"),
    Invitee(name: "Roana"),
    Invitee(name: "Neena"),
])

let genres = [
    ShowGenre(name: "Comedy", example: "Modern Family"),
    ShowGenre(name: "Drama", example: "Breaking Bad"),
    ShowGenre(name: "Variety", example: "The Colbert Report"),
]

for genre in genres {
    inviteeList.askRandomInviteeToBringGenre(genre)
}
inviteeList.inviteeRemainingInvitees()</pre></div><p>That is our complete program. You can now run the program by clicking the <strong>Run</strong> button and examine the output. You have just completed your first real Swift project!</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>File organization and navigation</h2></div></div></div><p>As your project <a class="indexterm" id="id182"/>gets larger, it can be cumbersome to have just one single list of files. It helps to organize your files into folders to help differentiate which role <a class="indexterm" id="id183"/>they are playing in your app. In Project Navigator, folders are called groups. You can create a new group by selecting the group you would like to add the new group to, and going to <strong>File</strong> | <strong>New</strong> | <strong>Group</strong>. It isn't terribly important exactly how you group your files; the important thing is that you should be able to come up with a relatively simple system that makes sense. If you are having trouble doing that, you should consider how you could improve the way you are breaking up your code. If you are having trouble categorizing your files, then your code is probably not being broken up in a maintainable way.</p><p>I would recommend <a class="indexterm" id="id184"/>using lots of files and groups to better separate your<a class="indexterm" id="id185"/> code. However, the drawback of that is that Project Navigator can fill up pretty quickly and become hard to navigate around. A great trick in Xcode to navigate to files more quickly is to use the keyboard shortcut <em>Command</em> + <em>Shift</em> + <em>O</em>. This displays the Open Quickly search. Here, you can start to type the name of the file you want to open and Xcode shows you all of the matching files. Use the arrow keys to navigate up and down and press <em>Enter</em> to open the file you want.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Extensions</h1></div></div></div><p>Up until this point, we had <a class="indexterm" id="id186"/>to define our entire custom type in a single file. However, it is sometimes useful to separate out part of our custom types into different files, or even just in the same file. To achieve this, Swift provides a feature called extensions. Extensions allow us to add additional functionality to existing types from anywhere.</p><p>This functionality is limited to additional functions and additional computed properties:</p><div><pre class="programlisting">extension Building {
    var report: String {
        return "This building is \(self.squareFootage) sq ft"
    }

    func isLargerThanOtherBuilding(building: Building) -&gt; Bool {
        return self.squareFootage &gt; building.squareFootage
    }
}</pre></div><p>Note that, to define an extension, we use the <code class="literal">extension</code> keyword, followed by the type that we would like to extend. Extensions can also be used on an existing class, struct, or enumeration, even those defined within Swift like String. Let's add an extension to String that allows us to repeat a string any number of times:</p><div><pre class="programlisting">extension String {
    func repeatNTimes(nTimes: Int) -&gt; String {
        var output = ""
        for _ in 0..&lt;nTimes {
            output += self
        }
        return output
    }
}
"-".repeatNTimes(4) // ----</pre></div><p>This is just one simple idea, but it is often incredibly useful to extend the built-in types.</p><p>Now that we have a <a class="indexterm" id="id187"/>good overview of what tools we have at our disposal for organizing our code, it is time to discuss an important concept in programming called <a class="indexterm" id="id188"/>
<strong>scope</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Scope</h1></div></div></div><p>Scope is all <a class="indexterm" id="id189"/>about which code has access to which other pieces of code. Swift makes it relatively easy to understand because all scope is defined by curly brackets (<code class="literal">{}</code>). Essentially, code in curly brackets can only access other code in the same curly brackets.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>How scope is defined</h2></div></div></div><p>To illustrate <a class="indexterm" id="id190"/>scope, let's look at some simple code:</p><div><pre class="programlisting">var outer = "Hello"
if outer == "Hello" {
    var inner = "World"
    print(outer)
    print(inner)
}
print(outer)
print(inner) // Error: Use of unresolved identifier 'inner'</pre></div><p>As you can see, <code class="literal">outer</code> can be accessed from both in and out of the <code class="literal">if</code> statement. However, since <code class="literal">inner</code> was defined in the curly brackets of the <code class="literal">if</code> statement, it cannot be accessed from outside of them. This is true of structs, classes, loops, functions, and any other structure that involves curly brackets. Everything that is not in curly brackets is considered to be at <a class="indexterm" id="id191"/>
<strong>global scope,</strong> meaning that anything can access it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Nested types</h2></div></div></div><p>Sometimes, it is <a class="indexterm" id="id192"/>useful to control scope yourself. To do this, you can define types within other types:</p><div><pre class="programlisting">class OuterClass {
    struct InnerStruct {
    }
}</pre></div><p>In this scenario, <code class="literal">InnerStruct</code> is only directly visible from within <code class="literal">OuterClass</code>. This, however, provides a special scenario that is not there for other control structures like <code class="literal">if</code> statements and loops. If code at the global scope wanted to access <code class="literal">InnerStruct</code>, it could only do so through <code class="literal">OuterClass</code> which it does have direct access to, as shown:</p><div><pre class="programlisting">var inner = OuterClass.InnerStruct()</pre></div><p>This can be useful<a class="indexterm" id="id193"/> to better segment your code but it is also great for hiding code that is not useful to any code outside other code. As you program in bigger projects, you will start to rely on Xcode's autocomplete feature more and more. In big code bases, autocomplete offers a lot of options, and nesting types into other types is a great way to reduce unnecessary clutter in the autocomplete list.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Access control</h1></div></div></div><p>Swift provides another set of tools that helps to control what code other code has access to called <a class="indexterm" id="id194"/>
<strong>access controls</strong>. All code is actually given three levels of access control:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Private</strong>: Only<a class="indexterm" id="id195"/> accessible from within the same file</li><li class="listitem" style="list-style-type: disc"><strong>Internal</strong>: Only <a class="indexterm" id="id196"/>accessible from within the same module or app</li><li class="listitem" style="list-style-type: disc"><strong>Public</strong>: Accessible <a class="indexterm" id="id197"/>by any code that imports the module</li></ul></div><p>Before we can really discuss this further, you should understand completely what a module is. It is beyond the scope of this book to talk about implementing a module but a module is a collection of code that can be used in other modules and apps. So far, we have used the <code class="literal">Foundation</code> module provided by Apple. A module is anything that you use when using the <code class="literal">import</code> keyword.</p><p>All code, by default, is defined to be at the internal level. That means that any given piece of code in your program can access any piece of code defined in any other file that is also included in your program as long as it follows the scoping rules we have already discussed.</p><p>As described previously, code declared as private is only accessible from the same file. This is an even better way to protect outside code from seeing code you don't want it to see. You can declare any variable or type as private by writing the <code class="literal">private</code> keyword before it, like this:</p><div><pre class="programlisting">private var mySecretString = "Hello World"
private struct MyPrivateStruct {
    private var privateProperty: String
    private func privateMethod() {
    }
}</pre></div><p>Note that access control is independent of the curly bracket scope. It is built on top of it. All of the existing scope rules apply, with access controls acting as an additional filter.</p><p>This is a fantastic way of improving the idea of abstractions. The simpler the outside view of your code, the easier it is to understand and use your abstraction. You should look at every file and every type as a small abstraction. In any abstraction, you want the outside world to have as little knowledge of the inner workings of it as possible. You should always keep in mind how you want your abstraction to be used and hide any code that does not serve that purpose. This is because code becomes harder and harder to understand and maintain as the walls between different parts of the code break down. You will end up with code that resembles a bowl of pasta. In the same way that it can be difficult to find where one noodle starts and ends, code with lots of interdependencies and minimal barriers between code components is very hard to make sense of. An abstraction that provides too much knowledge or access about its internal workings is often called a <a class="indexterm" id="id198"/>
<strong>leaky abstraction</strong>.</p><p>Public code is defined in the same way, except that you would use the <code class="literal">public</code> keyword instead of <code class="literal">private</code>. However, since we will not study designing your own modules, this is not useful to us. It is good to know it exists for future learning but the default <a class="indexterm" id="id199"/>
<strong>internal</strong> access level is enough for our apps.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Summary</h1></div></div></div><p>This was a very dense chapter. We have covered a lot of ground. We have delved deep into defining our own custom types using structures, classes, and enumerations. Structures are great for simple types, while classes are great for types that require a hierarchy of related types. Enumerations provide a way to group related things together and express more abstract concepts through associated values.</p><p>We have also created our first project, which made use of multiple source files improving the maintainability of our code bases, especially at scale. Extensions can be used across and within those files to add additional functionality to existing types, including those not defined by us.</p><p>Finally, we developed a good understanding of what scope is and how we can control it to our advantage, especially with the help of access controls to give us an even more fine grained filter on what code can interact with other code.</p><p>Now that you have made it this far, you are well on your way to becoming a quality Swift programmer. I definitely recommend that you take a breather and experiment with everything that you have learned so far. We have only a few more concepts left to learn until we have all the tools necessary for creating a great app.</p><p>Once you are ready to move on, we can talk about <strong>optionals</strong>, which I have already hinted at. Optionals are somewhat complex but are an integral part of using the Swift language effectively. In the next chapter, we will dive deep into what they are and then how to take advantage of them in the most effective ways possible.</p></div></body></html>