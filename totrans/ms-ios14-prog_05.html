<html><head></head><body>
		<div><h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor141"/>Chapter 5</em>: Immersing Your Users with Animation</h1>
			<p>Your app is starting to look really good now, and we've certainly covered a lot of ground already in this first few chapters, but UIKit has a lot of amazing features we're yet to explore – one of them being animations.</p>
			<p>In this chapter, you are going to learn some advanced techniques with UIKit, Apple's animation framework built right into UIKit. We'll start off with the basics of how the little things can make such a massive difference, and then move forward on to some more advanced techniques with <code>UIViewPropertyAnimator</code> and how it provides more control over your animations than the animations you implemented in previous chapters. You'll also learn about UIKit Dynamics. UIKit Dynamics can be used to make objects react to their surroundings by applying physics. </p>
			<p>Finally, you'll learn how to implement a custom transition when moving from one view controller to the next.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Using <code>UIView.animate</code> and <code>UIViewPropertyAnimator</code> </li>
				<li>Vibrant animations using springs in UIKit Dynamics</li>
				<li>Customizing view controller transitions</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor142"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's AppStore. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for <code>Xcode</code> in the App Store and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor143"/>Using UIView.animate and UIViewPropertyAnimator </h1>
			<p>As I said in the<a id="_idIndexMarker210"/> intro, we've come a<a id="_idIndexMarker211"/> long way so far with our app, but often, it's the little things that we can do that make a massive difference; you just need to take another look at <a href="B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 2</em></a>,<em class="italic"> Working with Dark Mode</em>, to appreciate that.</p>
			<p>In this section, we are going to start by adding some basic animations to our app using the standard practice to achieve a simple yet effective result.</p>
			<p>Once we've done that, we'll look at how we can take this much further by refactoring and improving the maintainability of our code base. So, let's get started as we add our first animation to our app.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor144"/>Creating our first animation</h2>
			<p>In their most basic form, animations are simple and easy to use. Here is an example of a typical animation that could be performed:</p>
			<pre>UIView.animate(withDuration: 0.8) {
    self.cell.familyNameLabel.alpha = 1.0
}</pre>
			<p>So, what does this mean exactly? Well, the <code>UIView.animate</code> function (which itself is a closure) is setting the alpha of our cell property to <code>1.0</code>. If we assume that the alpha for this property was set to <code>0.0</code>, our <code>animate</code> function would, over the duration of <code>0.8</code> seconds, change the alpha from <code>0.0</code> to <code>1.0</code> – thus giving us a simple yet extremely effective fade-in effect!</p>
			<p>Let's put this into <a id="_idIndexMarker212"/>action, continuing <a id="_idIndexMarker213"/>with our project from the previous chapter. Head on over to our <code>DetailsViewController.swift</code> file.</p>
			<p>First, let's set our contact image to have an alpha of <code>0.0</code>. We can achieve this by extending our outlet property to include a <code>didSet</code>. Make the following highlighted changes in the view controller:</p>
			<pre><strong class="bold">@IBOutlet weak var contactImageView: UIImageView! {</strong>
<strong class="bold">    didSet {</strong>
<strong class="bold">        contactImageView.alpha = 0</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre>
			<p>Here, we've simply added a setter and set an additional property on our <code>UIImageView</code> – in this case, we've set the alpha to be <code>0</code>.</p>
			<p>Now, back into the body of our view controller. Add the following to your <code>viewWillAppear()</code> function:</p>
			<pre>UIView.animate(withDuration: 0.8) {
    self.contactImageView.alpha = 1
}</pre>
			<p>Just as we saw in the earlier example, we're simply setting a duration for the animation, and inside the closure, we set the alpha value of our property.</p>
			<p>Go on and run your code in the simulator; you'll see that when <code>DetailsViewController</code> now loads, you'll get a nice little fade-in animation. With just a slight <a id="_idIndexMarker214"/>tweak to<a id="_idIndexMarker215"/> a property and couple of lines of code, your app has made a massive jump forward!</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor145"/>Working with multiple animations</h2>
			<p>Let's take this another <a id="_idIndexMarker216"/>step further now and add a bounce effect to <code>UICollectionViewCell</code> when it's tapped.</p>
			<p>Head on over to our view controller and locate the <code>didSelectItemAt:</code> function. Remember back in <a href="B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Using Lists and Tables</em>, when we identified how we could grab an instance of the currently selected cell, should we want to do anything with it? Well, here's our chance.</p>
			<p>Add the following code to the start of the <code>didSelectItemAt:</code> cell:</p>
			<pre>guard let cell = collectionView.cellForItem(at: indexPath) as? ContactCell else {
    return
}</pre>
			<p>Unlike <code>cellForItem:</code>, where we make use of the <code>re-us</code> identifier in order to recycle the use of our cells, here we care only about the selected instance – this is the cell we want to use and do something with.</p>
			<p>Next, we're going to add a big chunk of "initially" potentially confusing code, so we'll break it down first one step at a time. Just underneath the preceding code, add the following:</p>
			<pre>UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {
    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)
})</pre>
			<p>Here, we're extending the <code>.animate</code> function we saw earlier, but this time you see we've got a parameter for a delay, which we've set to <code>0</code> as we want the animation to start straight away (but I guess it's nice to know that we could delay it if we wanted to).</p>
			<p>Next, we've now got an <code>options</code> parameter, where we can pass in an array of animation options available to use through UIKit. Here, we're going to pass in <code>curveEaseOut</code> (don't worry, we'll cover the different types of animation options later in this chapter).</p>
			<p>Finally, we set the transform of our image view by setting <code>CGAffineTransform</code> to a specific <em class="italic">x</em> and <em class="italic">y</em> scale. By setting a transform on the image, we are effectively scaling the original size based on a new <em class="italic">x</em> and <em class="italic">y</em> value.</p>
			<p>Go ahead, launch the app – what do you see? Hopefully not a great deal – and you'll be wondering why not too. That's because we still have our <code>performSegue</code> call in there that is being called (and performed) before our animation can complete. Comment that out for the moment and try again. With any luck, when you tap on the cell, you should see the contact image shrink in size (or give a de-pressed appearance).</p>
			<p>So, before we worry about bringing back our <code>performSegue</code> call, let's get the animation looking right first. Our new animation block has another trick up its sleeve. Within the closure, we can add a completion handler that will get called as soon as the animation has finished (I know <a id="_idIndexMarker217"/>what you're thinking, but let's finish the animation first).</p>
			<p>Update the code with the following highlighted lines:</p>
			<pre>UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {
    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)
<strong class="bold">}, completion: { finished in</strong>
<strong class="bold">    UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {</strong>
<strong class="bold">        cell.conatctImageView.transform = CGAffineTransform.identity</strong>
<strong class="bold">    })</strong>
})</pre>
			<p>So, all we've done here is extend our completion handler for our initial animate function by adding <code>completion: { finished in</code> and added in another animation function.</p>
			<p>Back inside that closure, we reset the transform on our image view by setting it to <code>CGAffineTransform.identity</code> (a nice easy way to quickly revert any transform to its original state).</p>
			<p>Run the app now in the simulator and all is going well; you should be presented with a really nice bounce effect. Let's add the last piece of the puzzle back in now by again extending our second animate function to have a completion handler, where we will add back in <code>performSegue</code>:</p>
			<pre>UIView.animate(withDuration: 0.1, delay:       0, options: [.curveEaseOut], animations: {
    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)
}, completion: { finished in
    UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseIn], animations: {
        cell.conatctImageView.transform = CGAffineTransform.identity
<strong class="bold">    }, completion: { [weak self] finished in</strong>
<strong class="bold">        self?.performSegue(withIdentifier: "detailViewSegue", sender:self)</strong>
    })
})</pre>
			<p>Run your app again to see your beautiful animation in full bloom, followed by an immediate segue to <code>DetailViewController</code> – where you will be presented with a subtle yet effective fade-in animation of your contact image. Well done, you've done great!</p>
			<p>In this section, we've<a id="_idIndexMarker218"/> learned how to tackle a basic animation in UIKit – we advanced a little, looking at how our basic animation could be extended to perform a little more complex task.</p>
			<p>In the next section, we'll look at how we can simplify this with the use of <code>UIViewPropertyAnimator</code>.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor146"/>Refactoring with UIViewPropertyAnimator</h2>
			<p>So, with some basic animation <a id="_idIndexMarker219"/>under your belt, we can now dive a little deeper into what iOS has to offer. While our previous code was powerful and not that many lines of code, it was in turn quite ugly, with completion handlers inside completion handlers – spaghetti code like that can become a real nightmare to maintain, especially if you need to build out the animation into anything more complex.</p>
			<p>One reason to favor <code>UIViewPropertyAnimator</code> over the implementation you just saw is readability. Let's see what the same bounce animation looks like when it's refactored to use <code>UIViewPropertyAnimator</code>:</p>
			<pre>let downAnimator = UIViewPropertyAnimator(duration: 0.1, curve: .easeOut) {
    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)
}
        
let upAnimator = UIViewPropertyAnimator(duration: 0.1, curve: .easeIn) {
    cell.conatctImageView.transform = CGAffineTransform.identity
}
        
downAnimator.addCompletion { _ in
    upAnimator.startAnimation()
}
        
upAnimator.addCompletion { [weak self] _ in
    self?.performSegue(withIdentifier: "detailViewSegue", sender: self)
}
        
downAnimator.startAnimation()</pre>
			<p>Now, at first glance, you'll<a id="_idIndexMarker220"/> see that there appear to be a lot more lines of code here than previously, and you're not wrong, but it sure does make for better reading and maintainability.</p>
			<p>With the use of <code>UIViewPropertyAnimator</code>, it does exactly as its name describes: it allows you to assign your animation to a property that you can then execute independently within your function. </p>
			<p>The preceding code is no different than a simplified version of the original implementation that we broke down.</p>
			<p>Go ahead and add this to your code and run your app. You'll notice no difference at all to the previous version.</p>
			<p>The example code uses a version of <code>UIViewPropertyAnimator</code> that accepts a timing function to make the final bounce animation livelier. If you look at the sample code, the first argument passed to the <code>UIViewPropertyAnimator</code> initializer is the duration of the animation in seconds. </p>
			<p>The second argument controls the timing function. A timing function describes how an animation should progress over time. For instance, the <code>easeIn</code> option describes how an animation starts off at a slow pace and speeds up over time. </p>
			<p>The following diagram describes some of the most commonly used timing functions:</p>
			<div><div><img src="img/Figure_5.01_B14717.jpg" alt="Figure 5.1 – Curve timing function scales&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Curve timing function scales</p>
			<p>In these graphs, the <em class="italic">horizontal</em> axis represents the animation's progress. For each graph, the animation timeline is described from left to right on the <em class="italic">x</em> axis. The animation's progress is visualized on the <em class="italic">y</em> axis from bottom to top. At the bottom-left point, the animation hasn't started yet. At the right of the graph, the animation is completely done. The vertical axis represents time.</p>
			<p>The final argument<a id="_idIndexMarker221"/> that is passed to the <code>UIViewPropertyAnimator</code> initializer is an optional argument for the animation that you wish to execute. This is quite similar to the <code>UIView.animate</code> way of doing things; the most significant difference is that you can add more animations after creating the animator, meaning that <code>nil</code> can be passed as the argument for the animations and you can add animations you wish to execute at a later time. This is quite powerful because you're even allowed to add new animations to <code>UIViewPropertyAnimator</code> while an animation is running!</p>
			<p>The second section in the sample code you saw earlier adds completion closures to the animators. The completion closures both receive a single argument. The received argument describes at what point in the animation the completion closure was called. This property will usually have a value of <code>.end</code>, which indicates that the animation ended at the end position. </p>
			<p>However, this isn't always true, because you can finish animations halfway through the animation if you desire. You could also reverse an animation, meaning that the completion position would be <code>.start</code>.</p>
			<p>Once the completion closure is added, and the property animators are fully configured, the final step is to start the animation by calling <code>startAnimation()</code> on an animator object. Once<a id="_idIndexMarker222"/> the <code>startAnimation()</code> method is called, the animation begins executing immediately. If needed, you can make the animation start with a delay by calling <code>startAnimation(afterDelay:)</code>.</p>
			<p>Now you've got a better understanding of how <a id="_idTextAnchor147"/><a id="_idTextAnchor148"/><code>UIViewPropertyAnimator</code> works, why don't you try and change over our fade that we added in <code>DetailViewController</code>? For such a simple piece of code like this, <code>UIViewPropertyAnimator</code> is probably a little overkill, but it might be good just for fun. </p>
			<p>In the sample <a id="_idIndexMarker223"/>project, I'll include both scenarios and comment the other out for reference if you get stuck.</p>
			<p>In this section, we took a massive leap into the world of animation in iOS development, learning the basic way to just drop in an animation and how to build out more complex animation with <code>UIViewPropertyAnimator</code> for improved code maintainability.</p>
			<p>In the next section, we'll take a look at how to control an animation.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor149"/>Understanding and controlling animation progress</h1>
			<p>One of the best <a id="_idIndexMarker224"/>features of <code>UIViewPropertyAnimator</code> is that you can use it to create animations that can be interrupted, reversed, or interacted with. Many of the animations you see in iOS are interactive animations – for instance, swiping on a page to go back to the previous page is an interactive transition.</p>
			<p>Swiping between pages on the home screen, opening the control center, or pulling down the notification center are all examples of animations that you manipulate by interacting with them.</p>
			<p>While the concept of interactive animations might sound complicated, <code>UIViewPropertyAnimator</code> makes it quite simple to implement them. </p>
			<p>As an example, you'll see how to implement a drawer on the contact detail page in our app. First, you'll prepare the view, so the drawer is partially visible in the app. Once the view is all set up, you will write the code to perform an interactive show-and-hide animation for the drawer.</p>
			<p>Let's start by heading back over to <code>Main.storyboard</code> and doing the following:</p>
			<ol>
				<li>Add a UIView to our canvas via the object library (make sure this sits on top of the parent UIStackView, not inside it).</li>
				<li>Set up Auto Layout constraints to make sure that the drawer view's width is equal to the main view's width (trialing and leading both set to <code>0</code>).</li>
				<li>Make the view <code>350pt</code> in height.</li>
				<li>Then, set the bottom constraint to <code>-305</code>.</li>
			</ol>
			<p>This should leave the view just visible enough to cover the safe area at the bottom of the screen. Next, we need to add a button to our new view:</p>
			<ol>
				<li value="1">Add the button via the object library.</li>
				<li>Set the top constraint to be <code>8pt</code> from the top of the new view (its parent view).</li>
				<li>Set the leading and trailing to be around <code>16pts</code>.</li>
				<li>Set the label of the button to <code>Toggle</code>.</li>
				<li>Also, set the background to <strong class="bold">System Secondary Background Color</strong>.</li>
			</ol>
			<p>All going well, you should have something like this:</p>
			<div><div><img src="img/Figure_5.02_B14717.jpg" alt="Figure 5.2 – Detail view with image view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Detail view with image view</p>
			<p>Now that we've got<a id="_idIndexMarker225"/> the layout sorted, let's hook up the code we need. Our drawer functionality should implement the following features:</p>
			<ol>
				<li value="1">Toggle the drawer by tapping on the <strong class="bold">Toggle</strong> button.</li>
				<li>Toggle the drawer interactively when swiping on the drawer.</li>
				<li>Allow the user to tap on the <strong class="bold">Toggle</strong> button and then swipe the drawer to manipulate or reverse the animation.</li>
			</ol>
			<p>Behavior such as this is not straightforward; without <code>UIViewPropertyAnimator</code>, you would have to write a lot of complex code, and you'd still be pretty far from your desired results. Let's see what <code>UIViewPropertyAnimator</code> does to make implementing this effect manageable.</p>
			<p>To prepare for the implementation of the drawer, add the following properties to <code>DetailsViewController</code>:</p>
			<pre>@IBOutlet var drawer: UIView!
var isDrawerOpen = false
var drawerPanStart: CGFloat = 0
var animator: UIViewPropertyAnimator?</pre>
			<p>Also, add an extension to <code>DetailsViewController</code> that holds an <code>@IBAction</code> for the tap action. <code>@IBAction</code> is similar to <code>@IBOutlet</code>, but it is used to call a particular method in response to a specific user action. An extension is used, so it's easy to group the <a id="_idIndexMarker226"/>animation code nicely:</p>
			<pre>extension DetailsViewController {
    @IBAction func toggleDrawerTapped() {
    }
}</pre>
			<p>Now, let's connect our outlets:</p>
			<ol>
				<li value="1">Connect our UIView to the <code>IBOutlet</code> we just added in.</li>
				<li>Connect your UIButton to the <code>IBAction</code> we just created in the extension.</li>
			</ol>
			<p>When you drag from the action to the button, a menu appears from which you can select the action for which <code>@IBAction</code> should trigger. To respond to a button tap, choose <strong class="bold">Touch Up Inside</strong> from this menu.</p>
			<p>Finally, add the following lines to the end of <code>viewDidLoad()</code>:</p>
			<pre>let panRecognizer = UIPanGestureRecognizer(target: self, action:#selector(didPanOnDrawer(recognizer:)))
drawer.addGestureRecognizer(panRecognizer)</pre>
			<p>Also, add the following method to the extension you created earlier for <code>@IBAction</code>. This is the method that is called when the user performs a pan gesture on the drawer:</p>
			<pre>@objc func didPanOnDrawer(recognizer: UIPanGestureRecognizer) {
}</pre>
			<p>Now that all of the placeholders are implemented, let's create a simple first version of the open drawer animation. </p>
			<p>When the user taps on the toggle button, the drawer should open or close depending on the drawer's current <a id="_idIndexMarker227"/>state. The following snippet implements such an animation:</p>
			<pre>animator = UIViewPropertyAnimator(duration: 1, curve: .easeOut) { [unowned self] in
    if self.isDrawerOpen {
        self.drawer.transform = CGAffineTransform.identity
    } else {
        self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)
    }
}
        
animator?.addCompletion { [unowned self] _ in 
    self.animator = nil
    self.isDrawerOpen = !(self.drawer.transform == CGAffineTransform.identity)
}
        
animator?.startAnimation()</pre>
			<p>The animation that is passed to the property animator uses the value of <code>isDrawerOpen</code> to determine whether the animation should open or close the drawer. When the drawer is currently open, it should close, and vice versa. </p>
			<p>Once the animation finishes, the <code>isDrawerOpen</code> variable is updated to reflect the new state of the drawer. To determine the current state, the application reads the drawer's current transformation. If the drawer is not transformed, its transformation will equal <code>CGAffineTransform.identity</code> and the drawer is considered closed. Otherwise, the <a id="_idIndexMarker228"/>drawer is considered open. </p>
			<p>Go ahead and build and run your app now to see it in action. You'll see just how well it works.</p>
			<h2 id="_idParaDest-114">Interactions with a pan gesture recogni<a id="_idTextAnchor150"/><a id="_idTextAnchor151"/>zer</h2>
			<p>To allow the user to<a id="_idIndexMarker229"/> interrupt or start the animation by<a id="_idIndexMarker230"/> dragging their finger on the screen, the code must check whether an existing property animator is performing an animation. </p>
			<p>If no animator exists or if the current animator is not running any animations, a new instance of the animator should be created. In all other circumstances, it's possible to make use of the existing animator. </p>
			<p>Let's refactor the animator creation code from <code>toggleDrawerTapped()</code> so that it reuses the animator if possible and creates a new animator if needed.</p>
			<p>Add the following new function, <code>setUpAnimation()</code>, to our extension:</p>
			<pre>private func setUpAnimation() {
        
    guard animator == nil || animator?.isRunning == false else { return }
        
        animator = UIViewPropertyAnimator(duration: 1, curve: .easeOut) { [unowned self] in
        if self.isDrawerOpen {
            self.drawer.transform = CGAffineTransform.identity
        } else {
            self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)
        }
    }
        
    animator?.addCompletion { [unowned self] _ in 
<strong class="bold">        self.animator = nil</strong>
        self.isDrawerOpen = !(self.drawer.transform == CGAffineTransform.identity)
    }
}</pre>
			<p>You'll notice how <a id="_idIndexMarker231"/>we've just lifted the majority of the<a id="_idIndexMarker232"/> code from <code>IBAction</code> – now we'll need to update <code>IBAction</code> to call this new function:</p>
			<pre>@IBAction func toggleDrawerTapped() {
    setUpAnimation()
    animator?.startAnimation()
}</pre>
			<p>Now, add the following implementation for <code>didPanOnDrawer(recognizer: UIPanGestureRecognizer)</code>:</p>
			<pre>switch recognizer.state {
case .began:
    setUpAnimation()
    animator?.pauseAnimation()
    drawerPanStart = animator?.fractionComplete ?? 0
case .changed:
    if self.isDrawerOpen {
        animator?.fractionComplete = (recognizer.translation(in: drawer).y / 305) + drawerPanStart
    } else {
        animator?.fractionComplete = (recognizer.translation(in: drawer).y / -305) + drawerPanStart
    }
default:
    drawerPanStart = 0
    let timing = UICubicTimingParameters(animationCurve: .easeOut)
    animator?.continueAnimation(withTimingParameters: timing, durationFactor: 0)
            
    let isSwipingDown = recognizer.velocity(in: drawer).y &gt; 0
    if isSwipingDown == !isDrawerOpen {
        animator?.isReversed = true
    }
}</pre>
			<p>This method is called for<a id="_idIndexMarker233"/> any change that occurs in the pan gesture<a id="_idIndexMarker234"/> recognizer. When the pan gesture first starts, the animation is configured, and then <code>pauseAnimation()</code> is called on the animator object. </p>
			<p>This allows us to change the animation progress based on the user's pan behavior. Because the user might begin panning in the middle of the animation – for instance, after tapping the toggle button first – the current <code>fractionComplete</code> value is stored in the <code>drawerPanStart</code> variable.</p>
			<p>The value of <code>fractionComplete</code> is a value between <code>0</code> and <code>1</code> and it's decoupled from the time that your animation takes to run. So, imagine that you are using an ease-in and ease-out timing parameter to animate a square from an <em class="italic">x</em> value of <code>0</code> to an <em class="italic">x</em> value of <code>100</code>. The <em class="italic">x</em> value of <code>10</code> is not at <code>10%</code> of the time the animation takes to complete.</p>
			<p>However, <code>fractionComplete</code> will be <code>0.1</code>, which corresponds to the animation being <code>10%</code> complete. This is because <code>UIViewPropertyAnimator</code> converts the timescale for your animation to linear once you pause it. </p>
			<p>Usually, this is the best behavior for an interactive animation. However, you can change this behavior by setting the <code>scrubsLinearly</code> property on your animator to <code>false</code>. If you do this, <code>fractionComplete</code> will take any timing parameters you've applied into account.</p>
			<p>You can try playing <a id="_idIndexMarker235"/>around with this to see what it feels like for<a id="_idIndexMarker236"/> the drawer animation. Once the initial animation is configured and paused, the user can move their finger around. </p>
			<p>When this happens, the <code>fractionComplete</code> property is calculated and set on the animator by taking the distance traveled by the user's finger and dividing it by the total distance required. Next, the progress made by the animation before being interrupted is added to this new value.</p>
			<p>Finally, if the gesture ends, it gets canceled, or anything else, the start position is reset. Also, a timing parameter to use for the rest of the animation is configured and the animation is set up to continue. Bypassing a <code>durationFactor</code> value of <code>0</code>, the animator knows to use whatever time is left for the animation while taking into account its new timing function. </p>
			<p>If the user tapped the toggle button to close the drawer, yet they catch it mid-animation and swipe upward, the animation should finish in the upward direction. The last couple of lines take care of this logic.</p>
			<p>There is no right or wrong way of creating your perfect animation. Have a play around with the various values that feel right for you and your app. In this section, we took everything we learned about animations a step further by looking at how we can control animations via either <a id="_idIndexMarker237"/>an event action such as a UIButton toggle or<a id="_idIndexMarker238"/> via a user gesture interaction.</p>
			<p>In the next section, we'll start to add some real vibrancy to our animation by looking at how we can add some spring and bounce to our app!</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor152"/>Adding vibrancy to animations</h1>
			<p>A lot of animations<a id="_idIndexMarker239"/> on iOS look bouncy and feel natural. For instance, when an object starts moving in the real world, it rarely does so smoothly. Often, something moves because something else applied an initial force to it, causing it to have a certain momentum. Spring animations help you to apply this sort of real-world momentum to your animations.</p>
			<p>Spring animations are usually configured with an initial speed. This speed is the momentum an object should have when it begins moving. All spring animations require damping to be set on them. </p>
			<p>The value of this property specifies how much an object can overflow its target value. A smaller damping value will make your animation feel bouncier because it will float around its end value more drastically.</p>
			<p>The easiest way to explore spring animations is by slightly refactoring the animation you just created for the drawer. </p>
			<p>Instead of using an <code>easeOut</code> animation when a user taps the <code>setUpAnimation()</code>:</p>
			<pre>guard animator == nil || animator?.isRunning == false else {
    return
}
        
let spring: UISpringTimingParameters
if self.isDrawerOpen {
    spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: 10))
} else {
    spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: -10))
}
        
animator = UIViewPropertyAnimator(duration: 1, timingParameters: spring)
        
animator?.addAnimations { [unowned self] in
    if self.isDrawerOpen {
        self.drawer.transform = CGAffineTransform.identity
    } else {
        self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)
    }
}
animator?.addCompletion { [unowned self] _ in self.animator = nil
    self.isDrawerOpen = !(self.drawer.transform == CGAffineTransform.identity)
}</pre>
			<p>When you implement a <a id="_idIndexMarker240"/>spring animation, you use a special initializer for <code>UIViewPropertyAnimator</code>. Since you can't pass animations to this initializer, you must add them by calling <code>addAnimations(_:)</code>. Adding spring animations did not require a considerable code change, but try running the app and tapping on the toggle button. The drawer will now feel more realistic because its animation curve is not as static as it was before.</p>
			<p>Play around with the values for the spring damping and the velocity. If you use some extreme values, you'll get interesting results. Keep in mind that the damping should be a value between <code>0</code> and <code>1</code> and that a value closer to <code>1</code> will make your animation bounce less.</p>
			<p>The animation that is executed by the pan recognizer doesn't feel great at this point. It's very static and doesn't take into account how fast a user is panning on the drawer. </p>
			<p>When the user ends their pan gesture, you can set the sprint timing's <code>initialVelocity</code> value based on the actual pan velocity. This will make the animation feel even more realistic because it will now use the actual pan speed as the initial speed for animation.</p>
			<p>Update the default <a id="_idIndexMarker241"/>case statement with the following code:</p>
			<pre>drawerPanStart = 0
let currentVelocity = recognizer.velocity(in: drawer)
let spring = UISpringTimingParameters(dampingRatio: 0.8,
initialVelocity: CGVector(dx: 0, dy: currentVelocity.y))
            
animator?.continueAnimation(withTimingParameters: spring, durationFactor: 0)
let isSwipingDown = currentVelocity.y &gt; 0
if isSwipingDown == !isDrawerOpen {
    animator?.isReversed = true
}</pre>
			<p>As you've just seen, the use of spring animations can benefit your animations and they are not very hard to add to your apps. While they might not always be the best solution, their ease of implementation makes spring animations a worthy candidate to experiment with to determine whether your animation needs a spring.</p>
			<p>While the animation you have just implemented is pretty lifelike and realistic, your animations might need even more realism. The next section covers UIKit Dynamics, which is a special<a id="_idIndexMarker242"/> method of animating objects that uses a phys<a id="_idTextAnchor153"/>ics engine and can detect collisions between objects.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor154"/>Adding dynamism with UIKit Dynamics</h1>
			<p>Most apps implement<a id="_idIndexMarker243"/> simple animations, such as the ones<a id="_idIndexMarker244"/> you've seen so far in this chapter. However, some animations might need a little more realism – this is what UIKit Dynamics is for. </p>
			<p>With UIKit Dynamics, you can place one or more views in a scene that uses a physics engine to apply certain forces to the views it contains. For instance, you can apply gravity to a particular object, causing it to fall off the screen. You can even have objects bumping into each other, and if you assign a mass to your views, this mass is taken into account when two objects crash into each other. </p>
			<p>When you apply a certain force to an object with very little mass, it will be displaced more than an object with a lot of mass, just like you would expect in the real world.</p>
			<p>For this, we're going to create another little project away from our current app, so we can perform some physics experiments. </p>
			<p>So, let's get started by creating a new project in Xcode:</p>
			<ol>
				<li value="1">Create a new project and call it <code>Dynamics</code>.</li>
				<li>In <code>Main.Storyboard</code>, configure the preview to <strong class="bold">Landscape</strong>.</li>
				<li>Add three UIViews around <code>100 x 100</code> in size (don't worry about constraints for this project).</li>
				<li>Give each UIView a background color (think systems colors from <a href="B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Using Lists and Tables</em>).</li>
			</ol>
			<p>All going well, it should look something like this:</p>
			<div><div><img src="img/Figure_5.03_B14717.jpg" alt="Figure 5.3 – Main storyboard with views&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Main storyboard with views</p>
			<p>Next, add instances of <code>@IBOutlet</code> in <code>ViewController.swift</code> for the views you just added and connect them to the storyboard in the same way you did before. You can name the outlets anything you like, but I'll name mine <code>ball1</code>, <code>ball2</code>, and <code>ball3</code> (more on that later).</p>
			<p>The simplest thing <a id="_idIndexMarker245"/>you can implement at this point is to set <a id="_idIndexMarker246"/>up a scene that contains the three squares and apply some gravity to them. This will cause the squares to fall off the screen because they'll start falling once gravity is applied, and there is no floor to stop the squares from dropping off the screen.</p>
			<p>To set up a scene like the one described here, add the following highlighted code to your <code>ViewController.swift</code> file:</p>
			<pre><strong class="bold">var animator: UIDynamicAnimator?</strong>
    
override func viewDidLoad() {
    super.viewDidLoad()
        
<strong class="bold">    let balls: [UIDynamicItem] = [ball1, ball2, ball3]</strong>
<strong class="bold">    animator = UIDynamicAnimator(referenceView: view)</strong>
<strong class="bold">        </strong>
<strong class="bold">    let gravity = UIGravityBehavior(items: balls)</strong>
<strong class="bold">    animator?.addBehavior(gravity)</strong>
}</pre>
			<p>If you test your app now, you'll notice that your views start falling immediately. Setting up a simple scene such as this is easy with UIKit Dynamics. </p>
			<p>The downside of this simple example is that it's not particularly interesting to look at. Before you add features to make this sample more interesting, let's see what the preceding four lines of code do.</p>
			<p>The views in a dynamic scene must be of the <code>UIDynamicItem</code> type. A UIView can be used as <code>UIDynamicItem</code>, so by adding them to a list that has <code>[UIDynamicItem]</code> works automatically. </p>
			<p>Then, we create <a id="_idIndexMarker247"/>an instance of <code>UIDynamicAnimator</code> and <a id="_idIndexMarker248"/>you tell it the view to which it will apply its physics engine. The last step is to configure and apply a behavior. This example uses <code>UIGravityBehavior</code> but there are several other behaviors you can use in your scenes.</p>
			<p>For instance, you can create <code>UIAttachmentBehavior</code> to attach an item to another item or to some point on the screen. </p>
			<p>The following code implements an attachment behavior for every square on the screen and attaches it to the top of the screen. This will cause the squares to fall for a moment, and then they will bounce and swing a little until they eventually come to a standstill. You can add the following code to <code>viewDidLoad()</code> to implement this:</p>
			<pre>var nextAnchorX = 250
        
for ball in balls {
    let anchorPoint = CGPoint(x: nextAnchorX, y: 0)
    nextAnchorX -= 30
    let attachment = UIAttachmentBehavior(item: ball, attachedToAnchor: anchorPoint)
    attachment.damping = 0.7
    animator?.addBehavior(attachment)
}</pre>
			<p>Every square is set up with a slightly different attachment point in this example. Note that the attachment behavior has a <code>damping</code> property. </p>
			<p>This damping is similar to the damping that is used in spring animations. Try experimenting with the value for <code>attachment.damping</code> to see what it does.</p>
			<p>If you run the app now, you'll notice that every square is attached to an invisible point on the screen that keeps it from falling. Some things are still missing though.</p>
			<p>The squares can now simply cross over each other – how cool would it be if they bumped into<a id="_idIndexMarker249"/> each<a id="_idIndexMarker250"/> other instead?</p>
			<p>To do this, add the following line of code to <code>viewDidLoad()</code>:</p>
			<pre>let collisions = UICollisionBehavior(items: balls)
animator?.addBehavior(collisions)</pre>
			<p>Are you convinced that UIKit Dynamics is cool yet? I thought so; it's amazing how much you can do with just a little bit of code. Let's add some mass to the squares and make them more elastic to see whether this has any effect on how the squares collide.</p>
			<p>Update your <code>for</code> loop with the following code:</p>
			<pre>let dynamicBehavior = UIDynamicItemBehavior()
dynamicBehavior.addItem(ball)
dynamicBehavior.density = CGFloat(arc4random_uniform(3) + 1)
dynamicBehavior.elasticity = 0.8
animator?.addBehavior(dynamicBehavior)</pre>
			<p>The preceding code should augment what you already have in the loop; it shouldn't replace the existing logic. </p>
			<p>By setting <code>density</code> on <code>UIDynamicItemBehavior</code>, the engine can derive the mass of an item. This will change how the physics engine treats the item when it collides with another item.</p>
			<p>Again, this is a perfect time for you to go away and have a play with the behaviors and physics engine that Apple has provided. Now, a swinging square game might not be of interest to anyone – but update each of your ball properties to the following and run again…a lot <a id="_idIndexMarker251"/>more <a id="_idIndexMarker252"/>fun now, right?</p>
			<pre>@IBOutlet weak var ball1: UIView! {
    didSet {
            
    // Make a ball
    ball1.layer.cornerRadius = ball1.frame.size.width/2
    ball1.clipsToBounds = true
            
    // Cool gradient effect!
    let gradient = CAGradientLayer()
    gradient.frame = ball1.bounds
    gradient.colors = [UIColor.systemBlue.cgColor, UIColor.systemTeal.cgColor]
    ball1.layer.insertSublayer(gradient, at: 0)
        
    }
}	</pre>
			<p>In the final section, we will learn everything we need to know about view controller transitions, again another way to really make a difference when moving away from the default <a id="_idIndexMarker253"/>behavior<a id="_idIndexMarker254"/> of our app. </p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor155"/>Customizing view controller transitions</h1>
			<p>Implementing a custom<a id="_idIndexMarker255"/> view controller transition is one of those things that can take a little while to get used to. Implementing custom transitions involves implementing several objects, and it's not always easy to make sense of how this works. This section aims to explain exactly how custom view controller transitions work so that you can add one more powerful tool to your developer toolbox.</p>
			<p>A nicely implemented custom view controller transition will entertain and amaze your users. Making your transitions interactive could even ensure that your users spend some extra time playing around with your app, which is exactly what you want.</p>
			<p>We'll continue by working on our Contacts app we started earlier on. Firstly, you'll learn how you can implement a custom modal transition. Once you've implemented that, you will learn about custom transitions for <code>UINavigationController</code> so that you can show and hide the contact details page with a custom transition. The dismissal of both the modal view controller and the contact detail page will be interactive, so users can swipe to go back to where they came from.</p>
			<p>In this section, you will work through the following steps:</p>
			<ol>
				<li value="1">Implement a custom modal presentation transition.</li>
				<li>Make the transition interactive.</li>
				<li>Implement a custom <code>UINavigationController</code> transition.</li>
			</ol>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor156"/>Implementing a custom modal presentation transition</h2>
			<p>A lot of applications <a id="_idIndexMarker256"/>implement<a id="_idIndexMarker257"/> modally presented view controllers. A modally presented view controller is typically a view controller that is presented on top of the current screen as an overlay. By default, modally presented view controllers animate upward from the bottom of the screen and are often used to present forms or other temporary content to the user. In this section, you'll take a look at the default modal presentation transition and how to customize it to suit your own needs.</p>
			<p>Let's start by creating a brand new View Controller. For this, we'll head back to our Contacts app project where we can add this in here (or feel free to start a brand-new project):</p>
			<ol>
				<li value="1">Create a ne<a id="_idTextAnchor157"/><a id="_idTextAnchor158"/><a id="_idTextAnchor159"/>w <code>TransitionViewController</code> (with a subclass of <code>UIViewController</code>).</li>
				<li>Add a new View Controller to <code>Main.Storyboard</code>.</li>
				<li>Set the object class for that new View Controller to be <code>TransitionViewController</code>.<p>Once you've<a id="_idIndexMarker258"/> done that, we'll add a bar button item to our existing <a id="_idIndexMarker259"/>navigation so that we can present our modal.</p></li>
				<li>Add <code>BarButtonItem</code> from our object library to our navigation bar in <code>rootViewContoller</code> (basically our first view controller).</li>
				<li>Set the button's text to be <code>Show Modal</code> (or whatever you want).</li>
				<li>Now, press <em class="italic">Ctrl</em> and drag the bar button item's connector to the new view controller we just created.</li>
				<li>When presented with options, choose <strong class="bold">Present Modally</strong>.</li>
			</ol>
			<p>All going well, it should look like the following:</p>
			<div><div><img src="img/Figure_5.04_B14717.jpg" alt="Figure 5.4 – Modal action segue&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Modal action segue</p>
			<p>Finally, give our <a id="_idIndexMarker260"/>new<a id="_idIndexMarker261"/> view controller a system orange background color, so it will be easier to see the transition later. </p>
			<p>If you run your app now, you can click on the <strong class="bold">Show Modal</strong> button and you'll see an empty view controller pop up from the bottom. </p>
			<p>Until iOS 13, you had to create an interface in order for the user to dismiss a modal. Now, unless implicitly set, you can just swipe down to dismiss a modal, which is worth bearing in mind when developing apps that go further back than iOS 13.</p>
			<p>Custom view controller transitions use several objects to facilitate the animation. The first object you will look at is <code>transitioningDelegate</code> for <code>UIViewController</code>. The <code>transitioningDelegate</code> property is responsible for providing an animation controller that provides the custom transition.</p>
			<p>The animation controller uses a transitioning context object that provides information about the view controllers that are involved in the transition. Typically, these view controllers will be the current view controller and the view controller that is about to be presented.</p>
			<p>A transitioning flow can be described in the following steps:</p>
			<ol>
				<li value="1">A transition begins. The target view controller is asked for <code>transitioningDelegate</code>.</li>
				<li><code>transitioningDelegate</code> is asked for an animation controller.</li>
				<li>The animation <a id="_idIndexMarker262"/>controller <a id="_idIndexMarker263"/>is asked for the animation duration.</li>
				<li>The animation controller is told to perform the animation.</li>
			</ol>
			<p>When the animation is complete, the animation controller calls <code>completeTransition(_:)</code> on the transitioning context to mark the animation as completed.</p>
			<p>If <em class="italic">step 1</em> or <em class="italic">step 2</em> return <code>nil</code>, or aren't implemented at all, the default animation for the transition is used. The objects involved in a custom transition are displayed in the following diagram:</p>
			<div><div><img src="img/Figure_5.05_B14717.jpg" alt="Figure 5.5 – Animation transition flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Animation transition flow</p>
			<p>Creating a separate object to control the animation is often a good idea because it allows you to reuse <a id="_idIndexMarker264"/>a <a id="_idIndexMarker265"/>transition and it keeps your code nice and clean. The animation controller should be an object that conforms to <code>UIViewControllerAnimatedTransitioning</code>. This object will take care of animating the presented view onto the screen. </p>
			<p>Let's create the animation controller object next:</p>
			<ol>
				<li value="1">Creat<a id="_idTextAnchor160"/><a id="_idTextAnchor161"/>e a new <code>CustomAnimator</code> (using <code>NSObject</code> as a subclass).</li>
				<li>Add the following extension in order to make the class conform to <code>UIViewControllerAnimatedTransitioning</code>:<pre>extension CustomAnimator: UIViewControllerAnimatedTransitioning {
}</pre><p>This makes the new class conform to the protocol that's required to be an animation controller. Xcode will show a build error because you haven't implemented all the methods to conform to <code>UIViewControllerAnimatedTransitioning</code> yet. </p></li>
			</ol>
			<p>Let's go over the methods one by one so that you end up with a full implementation for the animation controller.</p>
			<p>The first method that must be implemented for the animation controller is <code>transitionDuration(using:)</code>. The implementation of this method is shown here:</p>
			<pre>func transitionDuration(using transitionContext:   UIViewControllerContextTransitioning?) -&gt; TimeInterval {
    return 0.6
}</pre>
			<p>This method is used to determine the total transition duration in seconds. In this case, the implementation is simple – the animation should last <em class="italic">0.6</em> seconds.</p>
			<p>The second method that needs to be implemented is <code>animateTransition(using:)</code>. Its purpose is to take care of the actual animation for the custom transition. </p>
			<p>This implementation <a id="_idIndexMarker266"/>will <a id="_idIndexMarker267"/>take the target view controller and its view will be animated from the top of the screen downward to its final position. It will also do a little bit of scaling, and the opacity of the view will be animated; to do this, <code>UIViewPropertyAnimator</code> will be used. </p>
			<p>Add the following implementation to the animator:</p>
			<pre>func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
        
    // 1
    guard let toViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to) else {
        return        
    }
    // 2
    let transitionContainer = transitionContext.containerView
        
    // 3
    var transform = CGAffineTransform.identity
    transform = transform.concatenating(CGAffineTransform(scaleX: 0.6, y: 0.6))
    transform = transform.concatenating(CGAffineTransform(translationX: 0, y: -200))
        
    toViewController.view.transform = transform
    toViewController.view.alpha = 0
        
    // 4
    transitionContainer.addSubview(toViewController.view)
        
    // 5
    let animationTiming = UISpringTimingParameters(dampingRatio: 0.5,
                                                   initialVelocity: CGVector(dx: 1, dy: 0))
        
    let animator = UIViewPropertyAnimator(duration: transitionDuration(using: transitionContext), timingParameters: animationTiming)
        
    animator.addAnimations {
        toViewController.view.transform = CGAffineTransform.identity
        toViewController.view.alpha = 1
    }
        
    // 6
    animator.addCompletion { finished in
        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
    }
        
    // 7
    animator.startAnimation()
        
}</pre>
			<p>A lot is going on in the <a id="_idIndexMarker268"/>preceding <a id="_idIndexMarker269"/>code snippet. Let's go through the code step by step to see what's happening:</p>
			<ol>
				<li value="1">The target view controller is extracted from the transition context. This allows you to use the view controller's view in the animation that you're about to perform.</li>
				<li>Obtain the animation's container view. The container view is a regular UIView and it is intended to contain all the animated views.</li>
				<li>Prepare the target view controller's view for the animation. The view is transformed, so it's off the screen, and transparency is set to make the view completely transparent.</li>
				<li>Once the view is prepared, it is added to the container view.</li>
				<li>The animations are set up and added to a property animator.</li>
				<li>The completion handler for the property animator is configured, so <code>completeTransition(_:)</code> is called on the context. The <code>transitionWasCancelled</code> variable is used to determine whether the animation completed normally.</li>
				<li>Start the <a id="_idIndexMarker270"/>property <a id="_idIndexMarker271"/>animator so that the animations begin.</li>
			</ol>
			<p>Now that the animation controller is complete, the <code>UIViewControllerTransitioningDelegate</code> protocol should be implemented on <code>TransitionViewController</code> so that it can act as its own <code>transitioningDelegate</code>. </p>
			<p>Open the file and add the following code:</p>
			<pre>extension TransitionViewController: UIViewControllerTransitioningDelegate {
    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        return CustomAnimator()
    }
    
    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        return nil
    }
}</pre>
			<p>Now, add the following code to <code>TransitionViewController</code>:</p>
			<pre>    public required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        transitioningDelegate = self
    }</pre>
			<p>This code adds conformance to the <code>UIViewControllerTransitioningDelegate</code> protocol and assigns the view controller as its own transitioning delegate. The <code>animationController(forPresented:presenting:source:)</code> method returns the animation controller you created before. The <code>animationController(forDismissed:)</code> method returns <code>nil</code> for now. </p>
			<p>Go ahead and <a id="_idIndexMarker272"/>test<a id="_idIndexMarker273"/> your custom transition! This is all the code required to create a custom display transition.</p>
			<p>In this chapter, we learned loads about how to fine-tune and polish off our app. Visual effects play such a big part in any application – so learning about animations transitions is an absolute must for any iOS developer.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we took the solid core of our Contacts app and decorated it with animations and vibrancy. We started by learning the basics of animation and how a couple of lines of code could make a massive difference. We then took this a step further and refactored more complex code to make it not only maintainable but also easier to understand.</p>
			<p>UIKit offers much more than just fancy animations. Looking at dynamics, we saw how we could apply physics to even a UIView to give us an app with a truly awesome experience.</p>
			<p>Finally, we looked at transitions, something that is very powerful in iOS development, yet something we take so easily for granted. We created a custom class that allowed us to create our very own modal transition.</p>
			<p>In the next chapter, we're going to delve a little deeper into the Swift programming language and learn all about Swift's type system.</p>
		</div>
	</body></html>