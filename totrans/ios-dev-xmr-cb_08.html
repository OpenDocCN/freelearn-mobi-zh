<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Integrating iOS Features</h1></div></div></div><p>In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Starting phone calls</li><li class="listitem" style="list-style-type: disc">Sending text messages and e-mails</li><li class="listitem" style="list-style-type: disc">Using text messaging in our application</li><li class="listitem" style="list-style-type: disc">Using e-mail messaging in our application</li><li class="listitem" style="list-style-type: disc">Managing the address book</li><li class="listitem" style="list-style-type: disc">Displaying contacts</li><li class="listitem" style="list-style-type: disc">Managing the calendar</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Introduction</h1></div></div></div><p>Mobile devices offer a handful of features to the user. Creating an app that interacts with these features to provide a complete experience to users can surely be considered as an advantage.</p><p>In this chapter, we will discuss some of the most common features of iOS and how to integrate some or all of their functionality into our apps. We will see how to offer the user the ability to make telephone calls and send SMS and e-mails, either using the native platform apps or by integrating the native user interface in our projects. Also, we will discuss the following components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>MFMessageComposeViewController</strong>: This controller is suitable for sending<a id="id475" class="indexterm"/> text (SMS) messages</li><li class="listitem" style="list-style-type: disc"><strong>MFMailComposeViewController</strong>: This controller is used for sending e-mails <a id="id476" class="indexterm"/>with or without attachments</li><li class="listitem" style="list-style-type: disc"><strong>ABAddressBook</strong>: This <a id="id477" class="indexterm"/>class provides us access to the address book database</li><li class="listitem" style="list-style-type: disc"><strong>ABPersonViewController</strong>: This controller displays and/or edits contact information<a id="id478" class="indexterm"/> from the address book</li><li class="listitem" style="list-style-type: disc"><strong>EKEventStore</strong>: This <a id="id479" class="indexterm"/>class is responsible for managing calendar events</li></ul></div><p>Furthermore, we will learn how to read and save contact information, how to display contact details, and interact with the device's calendar.</p><p>Note that some of the examples in this chapter will require a device. For example, the simulator does not contain the <em>Messaging</em> app. To deploy a simulator to a device, you will need to enroll as an iOS Developer through Apple's Developer Portal.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Starting phone calls</h1></div></div></div><p>In this recipe, we <a id="id480" class="indexterm"/>will learn how to invoke the native <em>Phone</em> app to allow the user to place a phone call.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec260"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">PhoneCallApp</code>.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>The native <em>Phone</em> app is not available on the simulator. It is only available on an iPhone device.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec261"/>How to do it...</h2></div></div></div><p>Perform the following steps to allow the user to place phone calls:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a button on the view of <code class="literal">PhoneCallAppViewController</code>.</li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.btnCall.TouchUpInside += (s, e) =&gt; {
  NSUrlurl = new NSUrl("tel:+123456789012");
  if (UIApplication.SharedApplication.CanOpenUrl(url))
  {
    UIApplication.SharedApplication.OpenUrl(url);
  }  else
  {
    Console.WriteLine("Cannot open url: {0}", url.AbsoluteString);
  }
} ;</pre></div></li><li class="listitem">Compile and run the app on the device. Tap the <strong>Call phone number</strong> button<a id="id481" class="indexterm"/> to start the call. The following screenshot shows the <em>Phone</em> app placing a call:<div><img src="img/8924OT_08_01.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec262"/>How it works...</h2></div></div></div><p>Through the <code class="literal">UIApplication.SharedApplication</code> static property, we have access to the app's <code class="literal">UIApplication</code> object. We can use its <code class="literal">OpenUrl</code> method that accepts an <code class="literal">NSUrl</code> variable to initiate a call using the following line of code:</p><div><pre class="programlisting">UIApplication.SharedApplication.OpenUrl(url);</pre></div><p>Because not <a id="id482" class="indexterm"/>all iOS devices support the native <em>Phone</em> app, it would be useful to check for availability first. You can do this using the following code:</p><div><pre class="programlisting">if (UIApplication.SharedApplication.CanOpenUrl(url))</pre></div><p>When the <code class="literal">OpenUrl</code> method is called, the native <em>Phone</em> app will be executed and start calling the number immediately. Note that the <code class="literal">tel:</code> prefix is needed to initiate the call.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec263"/>There's more...</h2></div></div></div><p>Xamarin.iOS also supports the CoreTelephony Framework through the <code class="literal">MonoTouch.CoreTelephony</code> namespace. This is a simple framework that provides information on call state, connection, carrier information, and so on. Note that when a call starts, the native <em>Phone</em> app enters into the foreground, causing the app to be suspended. A simple usage of the CoreTelephony Framework is as follows:</p><div><pre class="programlisting">CTCallCenter callCenter = new CTCallCenter();
callCenter.CallEventHandler = delegate(CTCall call) {
  Console.WriteLine(call.CallState);
} ;</pre></div><p>Note that the handler is assigned with an equals sign (=) instead of the common plus-equals (+=) combination. This is because <code class="literal">CallEventHandler</code> is a property and not an event. When the app enters into the background, events are not distributed to it. The event that occurred last, however, will be distributed when the app returns to the foreground.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec67"/>More information on OpenUrl</h3></div></div></div><p>The <code class="literal">OpenUrl</code> method<a id="id483" class="indexterm"/> can be used to open various native and non-native applications. For example, to open a web page in Safari, just create an <code class="literal">NSUrl</code> object with the link, as follows:</p><div><pre class="programlisting">NSUrl url = new NSUrl("http://www.packtpub.com");</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec264"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Sending text messages and e-mails</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Sending text messages and e-mails</h1></div></div></div><p>In this recipe, we <a id="id484" class="indexterm"/>will learn how to invoke the native <em>Mail</em> and <em>Messaging</em> apps <a id="id485" class="indexterm"/>within our own app.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec265"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">SendTextApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec266"/>How to do it...</h2></div></div></div><p>Perform the following steps to invoke the apps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two buttons on the view of <code class="literal">SendTextAppViewController</code>.</li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.btnSendText.TouchUpInside += (s, e) =&gt; {
  NSUrl textUrl = new NSUrl("sms:+123456789");
  if (UIApplication.SharedApplication.CanOpenUrl(textUrl))
  {
    UIApplication.SharedApplication.OpenUrl(textUrl);
  }  else
  {
    Console.WriteLine("Cannot send text message!");
  }
} ;
this.btnSendEmail.TouchUpInside += (s, e) =&gt; {
  NSUrl emailUrl = new NSUrl("mailto:mail@example.com");
  if (UIApplication.SharedApplication.CanOpenUrl(emailUrl))
  {
    UIApplication.SharedApplication.OpenUrl(emailUrl);
  }  else
  {
    Console.WriteLine("Cannot send email message!");
  }
} ;</pre></div></li><li class="listitem">Compile and run the app on the device. Click on one of the buttons to open the corresponding app.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec267"/>How it works...</h2></div></div></div><p>Once again, using the <code class="literal">OpenUrl</code> method, we can send text or e-mail messages. Just using the <code class="literal">sms:</code> prefix from the preceding example code will open the native text messaging app, as follows:</p><div><pre class="programlisting">UIApplication.SharedApplication.OpenUrl(new NSUrl("sms:+123456789012"));</pre></div><p>Adding a cell phone number after the <code class="literal">sms:</code> prefix will open the native <em>Messaging</em> app, as shown in the following screenshot:</p><div><img src="img/8924OT_08_02.jpg" alt="How it works..."/></div><p>For opening<a id="id486" class="indexterm"/> the native e-mail app, the process is similar. Pass the <code class="literal">mailto:</code> prefix,<a id="id487" class="indexterm"/> as follows:</p><div><pre class="programlisting">UIApplication.SharedApplication.OpenUrl(new NSUrl("mailto:mail@example.com"));</pre></div><p>This opens the edit mail controller, as shown in the following screenshot:</p><div><img src="img/8924OT_08_03.jpg" alt="How it works..."/></div><p>The <code class="literal">mailto:</code> URL scheme supports various parameters for customizing an e-mail message. These parameters allow us to enter the sender address, subject, and message, as follows:</p><div><pre class="programlisting">UIApplication.SharedApplication.OpenUrl("mailto:recipient@example.com?subject=Email%20with%20Xamarin.iOS!&amp;body=This%20is%20the%20message%20body!");</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec268"/>There's more...</h2></div></div></div><p>Although iOS provides access to opening the native <em>Messaging</em> apps, predefining message <a id="id488" class="indexterm"/>content in the case of e-mails is where the control from <a id="id489" class="indexterm"/>inside the app stops. There is no way of actually sending the message through code. It is the user that will decide whether to send the message or not.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec68"/>More information on opening external apps</h3></div></div></div><p>The <code class="literal">OpenUrl</code> method provides an interface for opening external apps. Opening external <a id="id490" class="indexterm"/>apps has one drawback, that is, the app that calls the <code class="literal">OpenUrl</code> method transitions to the background. Up to iOS Version 3.*, this was the only way of messaging through an application. Since iOS Version 4.0, Apple has provided the messaging controllers to the SDK. The following<a id="id491" class="indexterm"/> recipes discuss their usage.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec269"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Starting phone calls</em> and <em>Using text messaging in our application</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Using text messaging in our application</h1></div></div></div><p>In this recipe, we <a id="id492" class="indexterm"/>will learn how to display the text messaging controller inside our app.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec270"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">TextMessageApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec271"/>How to do it...</h2></div></div></div><p>Perform the following steps to display the text messaging controller in our app:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a button on the view of the controller.</li><li class="listitem">Enter the following <code class="literal">using</code> directive in the <code class="literal">TextMessageAppViewController</code> file:<div><pre class="programlisting">using MonoTouch.MessageUI;</pre></div></li><li class="listitem">Implement the <code class="literal">ViewDidLoad</code> method with the following code, changing the recipient number and/or the message body at your discretion:<div><pre class="programlisting">private MFMessageComposeViewController messageController;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.btnSendMessage.TouchUpInside += async (s, e) =&gt; {
<strong>    if (MFMessageComposeViewController.CanSendText)</strong>
    {
      this.messageController = new MFMessageComposeViewController();
      this.messageController.Recipients = new string[] { "+123456789012" };
      this.messageController.Body = "Text from Xamarin.iOS";
      this.messageController.Finished += MessageController_Finished;
      await this.PresentViewControllerAsync(this.messageController, true);
    }  else
    {
      Console.WriteLine("Cannot send text message!");
    }
  } ;
}</pre></div></li><li class="listitem">Add the following method:<div><pre class="programlisting">private async void MessageController_Finished(object sender, MFMessageComposeResultEventArgs e) {
  switch (e.Result) {
  case MessageComposeResult.Sent:
    Console.WriteLine("Message sent!");
    break;
  case MessageComposeResult.Cancelled:
    Console.WriteLine("Message cancelled!");
    break;
  default:
    Console.WriteLine("Message failed!");
    break;
  }
  e.Controller.Finished -= MessageController_Finished;
  await e.Controller.DismissViewControllerAsync(true);
}</pre></div></li><li class="listitem">Compile and run the app on the device. Tap the <strong>Send message</strong> button to open the message controller. Tap the <strong>Send</strong> button to send the message, or on the <strong>Cancel</strong> button to return to the app.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec272"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.MessageUI</code> namespace contains the necessary UI elements that allow us to implement<a id="id493" class="indexterm"/> messaging in an iOS app. For text messaging (SMS), we need the <code class="literal">MFMessageComposeViewController</code> class.</p><p>We need to check for texting availability, because not all devices can send text messages. The <code class="literal">MFMessageComposeViewController</code> class contains a static method named <code class="literal">CanSendText</code>, which returns a boolean value indicating whether we can use this functionality. The important thing in this case is that we check if the functionality of sending text messages is available prior to initializing the controller. This is because when you try to initialize the controller on a device that does not support text messaging or on the simulator, you will get an exception.</p><p>To determine when the user has taken action in the message UI, we subscribe to the <code class="literal">Finished</code> event, as follows:</p><div><pre class="programlisting">this.messageController.Finished += MessageController_Finished;</pre></div><p>Inside the <code class="literal">Finished</code> method, we can provide functionality according to the <code class="literal">MessageComposeResult</code> parameter. It can have one of the following three values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sent: This means the message was sent successfully.</li><li class="listitem" style="list-style-type: disc">Cancelled: This means the user has tapped the <strong>Cancel</strong> button. The message will not be sent.</li><li class="listitem" style="list-style-type: disc">Failed: This means the message sending failed.</li></ul></div><p>The last<a id="id494" class="indexterm"/> thing to do is unsubscribe the event and dismiss the message controller, as follows:</p><div><pre class="programlisting">e.Controller.Finished -= MessageController_Finished;
await e.controller.DismissViewControllerAsync(true);</pre></div><p>After initializing the controller, we can set the recipients and body message to the appropriate properties, as follows:</p><div><pre class="programlisting">this.messageController.Recipients = new string[] { "+123456789012" };
this.messageController.Body = "Text from Xamarin.iOS";</pre></div><p>The <code class="literal">Recipients</code> property accepts a <code class="literal">string</code> array that allows multiple recipient numbers.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec273"/>There's more...</h2></div></div></div><p>The fact that SDK allows the user interface to send text messages does not mean that it is customizable. Just like invoking the native <em>Messaging</em> app, it is the user who will decide whether to send the message or discard it. In fact, after the controller is presented on the screen, any attempts to change the actual object or any of its properties will simply fail. Furthermore, the user can change or delete both the recipients and the message body. The real benefit, though, is that the messaging user interface is displayed within our app instead of running separately.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec69"/>Attachments</h3></div></div></div><p>Starting <a id="id495" class="indexterm"/>with iOS 7, the <code class="literal">MFMessageComposeViewController</code> class supports attachments. We can attach a file to a message through the <code class="literal">AddAttachment</code> method, as follows:</p><div><pre class="programlisting">this.messageController.AddAttachment(new NSUrl("path/to/file"), "A wonderful image");</pre></div><p>The second parameter is the string that will appear as a filename on the UI. If null is passed, the actual filename will appear.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Using e-mail messaging in our application</h1></div></div></div><p>In this recipe, we <a id="id496" class="indexterm"/>will learn how to use the e-mail messaging interface within an application.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec274"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">EmailMessageApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec275"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a button on the view of <code class="literal">EmailMessageAppViewController</code> and the <code class="literal">MonoTouch.MessageUI</code> namespace in the <code class="literal">EmailMessageAppViewController.cs</code> file.</li><li class="listitem">Enter the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.btnSendEmail.TouchUpInside += async (s, e) =&gt; {
  if (MFMailComposeViewController.CanSendMail)
  {
  this.mailController = new MFMailComposeViewController();
  this.mailController.SetToRecipients(new string[] { "recipient@example.com" });
  this.mailController.SetSubject("Email from Xamarin.iOS!");
  this.mailController.SetMessageBody("This is the message body!", false);
  this.mailController.Finished += this.MailController_Finished;
    await this.PresentViewControllerAsync(this.mailController, true);
  }  else
  {
    Console.WriteLine("Cannot send email!");
  }
} ;</pre></div></li><li class="listitem">Add the following method:<div><pre class="programlisting">private async void MailController_Finished (object sender, MFComposeResultEventArgs e)
{
  switch (e.Result)
  {
  case MFMailComposeResult.Sent:
    Console.WriteLine("Email sent!");
  break;
  case MFMailComposeResult.Saved:
    Console.WriteLine("Email saved!");
  break;
  case MFMailComposeResult.Cancelled:
    Console.WriteLine("Email sending cancelled!");
  break;
  case MFMailComposeResult.Failed:
    Console.WriteLine("Email sending failed!");
    if (null != e.Error)
    {
      Console.WriteLine("Error message: {0}", e.Error.LocalizedDescription);
    }
  break;
  }
  e.Controller.Finished -= MailController_Finished;
  await e.Controller.DismissViewControllerAsync(true);
}</pre></div></li><li class="listitem">Compile<a id="id497" class="indexterm"/> and run the app either on the simulator or on the device. Click on the <strong>Send email</strong> button to display the mail user interface.</li></ol></div><p>Send or cancel the message. The app will work on the simulator and behave just like the native <em>Mail</em> app on devices, except for the fact that messages will not actually be sent or saved.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec276"/>How it works...</h2></div></div></div><p>The <code class="literal">MFMailComposeViewController</code> class provides the native mail composing interface. To determine whether the device is capable of sending e-mails, we first check its <code class="literal">CanSendMail</code> property, as follows:</p><div><pre class="programlisting">if (MFMailComposeViewController.CanSendMail)</pre></div><p>Just like we did with the <code class="literal">MFMessageComposeViewController</code> class, we subscribe to the <code class="literal">Finished</code> event of the <code class="literal">MFMailComposeViewController</code> class. We use this event to respond to user actions, without having to implement a <code class="literal">Delegate</code> object. We do this inside the <code class="literal">MailController_Finished</code> method based on the <code class="literal">MFComposeResultEventArgs.Result</code> property, which is of the <code class="literal">MFMailComposeResult</code> type. The possible values of the <code class="literal">MFMailComposeResult</code> enumeration will be one of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sent: This means the e-mail message is queued for sending.</li><li class="listitem" style="list-style-type: disc">Saved: This means the user clicked on the <strong>Cancel</strong> button, and the <strong>Save Draft</strong> option of <a id="id498" class="indexterm"/>the action sheet automatically appears. The following screenshot shows the action sheet that appears when the user clicks on the <strong>Cancel</strong> button:<div><img src="img/8924OT_08_04.jpg" alt="How it works..."/></div></li><li class="listitem" style="list-style-type: disc">Cancelled: This means the user clicked on the <strong>Cancel</strong> button on the controller and selected the <strong>Delete Draft</strong> option on the action sheet.</li><li class="listitem" style="list-style-type: disc">Failed: This means the e-mail message sending failed.</li></ul></div><p>After initializing the object, we can assign a recipient list, subject, and message body through the corresponding set of the <code class="literal">Set</code> prefixed methods, as follows:</p><div><pre class="programlisting">this.mailController.SetToRecipients(new string[] { "recipient@example.com" });
this.mailController.SetSubject("Email from MonoTouch!");
this.mailController.SetMessageBody("This is the message body!", false);</pre></div><p>If the second parameter of the <code class="literal">SetMessageBody</code> message is set to <code class="literal">true</code>, it informs the controller that the message should be treated as HTML.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec277"/>There's more...</h2></div></div></div><p>Apart from simple or HTML formatted text, we can also send attachments. We can do this with the <code class="literal">AddAttachmentData</code> method using the following line of code:</p><div><pre class="programlisting">this.mailController.AddAttachmentData(UIImage.FromFile("image.jpg").AsJPEG(), "image/jpg", "image.jpg");</pre></div><p>The first parameter is of the <code class="literal">NSData</code> type and is the actual content of the attachment. In this case, we attach an image through the <code class="literal">UIImage.AsJPEG()</code> method, which returns the image contents inside an <code class="literal">NSData</code> object. The second parameter represents the <strong>Multipurpose Internet Mail Extensions</strong> (<strong>MIME</strong>) type of the attachment, and the third parameter<a id="id499" class="indexterm"/> represents its filename that will be shown to the user.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec278"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using text messaging in our application</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Managing the address book</h1></div></div></div><p>In this recipe, we will discuss how to access and manage the user's stored contacts in the device's <a id="id500" class="indexterm"/>address book.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec279"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">AddressBookApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec280"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a button on the view of the controller.</li><li class="listitem">Enter the following <code class="literal">using</code> directive in the <code class="literal">AddressBookAppViewController.cs</code> file:<div><pre class="programlisting">using MonoTouch.AddressBook;</pre></div></li><li class="listitem">Override the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.btnReadContacts.TouchUpInside += (s, e) =&gt; {
  ABAuthorizationStatus abStatus = ABAddressBook.GetAuthorizationStatus();
  NSError error;
  ABAddressBook addressBook = ABAddressBook.Create(out error);
  if (abStatus == ABAuthorizationStatus.NotDetermined)
  {
    addressBook.RequestAccess((g, err) =&gt; {
      if (!g)
      {
        Console.WriteLine("User denied address book access!");
      } else
      {
        this.InvokeOnMainThread(() =&gt;this.ReadContacts(addressBook));
      }
    });
  } else if (abStatus == ABAuthorizationStatus.Authorized)
  {
    this.ReadContacts(addressBook);
  } else
  {
    Console.WriteLine("App does not have access to the address book!");
  }
  };
}</pre></div></li><li class="listitem">Add the<a id="id501" class="indexterm"/> following method:<div><pre class="programlisting">private void ReadContacts(ABAddressBook addressBook)
{
  ABPerson[] contacts = addressBook.GetPeople();
  foreach (ABPerson eachPerson in contacts)
  {
    Console.WriteLine("{0} {1}", eachPerson.LastName, eachPerson.FirstName);
  }
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click on the <strong>Get contacts</strong> button and either accept or deny access to the address book. The following screenshot displays the alert that appears when we request access to the address book:<div><img src="img/8924OT_08_05.jpg" alt="How to do it..."/></div></li></ol></div><div><div><h3 class="title"><a id="note47"/>Note</h3><p>The simulator's address book contains some fake contacts that we can work with.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec281"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.AddressBook</code> namespace contains all the classes that allow us to manage the <a id="id502" class="indexterm"/>device's address book. To access the address book, we first need to check if the user has previously granted address book access to our app and instantiate an <code class="literal">ABAddressBook</code> instance, as follows:</p><div><pre class="programlisting">ABAuthorizationStatus abStatus = ABAddressBook.GetAuthorizationStatus();
NSError error;
ABAddressBook addressBook = ABAddressBook.Create(out error);</pre></div><p>If the status is <code class="literal">NotDermined</code>, we call the <code class="literal">RequestAccess</code> method, which accepts an <code class="literal">Action&lt;bool, NSError&gt;</code> delegate, as follows:</p><div><pre class="programlisting">addressBook.RequestAccess((g, err) =&gt; {
      if (!g)
      {
        Console.WriteLine("User denied address book access!");
      } else
      {
<strong>        this.InvokeOnMainThread(() =&gt;this.ReadContacts(addressBook));</strong>
      }
    });</pre></div><p>The <code class="literal">bool</code> parameter <a id="id503" class="indexterm"/>informs us if the user has granted access. If it is <code class="literal">true</code>, we call the <code class="literal">ReadContacts</code> method so that we proceed with reading the address book information we want. Note that we wrap the call of the <code class="literal">ReadContacts</code> method with an <code class="literal">InvokeOnMainThread</code> call, although it is not accessing the UI. This is because the <code class="literal">RequestAccess</code> method is called on a separate thread.</p><div><div><h3 class="title"><a id="note48"/>Note</h3><p>We can access the address book from other threads other than the main one; however, every instance of <code class="literal">ABAddressBook</code> needs to be used on the same thread.</p></div></div><p>Inside the <code class="literal">ReadContacts</code> method, we enumerate the individual contact through the <code class="literal">GetPeople</code> method, as follows:</p><div><pre class="programlisting">ABPerson[] contacts = addressBook.GetPeople();
foreach (ABPerson eachPerson in contacts)
{
  Console.WriteLine("{0} {1}", eachPerson.LastName, eachPerson.FirstName);
}</pre></div><p>The <code class="literal">ABPerson</code> class contains the contact information we want.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec282"/>There's more...</h2></div></div></div><p>To get a contact's stored phone number(s), call the <code class="literal">GetPhones()</code> method, as follows:</p><div><pre class="programlisting">ABMultiValue&lt;string&gt; phones = eachPerson.GetPhones();
Console.WriteLine(phones[0].Value);</pre></div><p>It returns an object of the <code class="literal">ABMultiValue&lt;string&gt;</code> type. <code class="literal">ABMultiValue&lt;T&gt;</code> is a generic collection, especially designed for multiple address book values.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec70"/>Adding a phone number to a contact</h3></div></div></div><p>To add a <a id="id504" class="indexterm"/>phone number to a contact, we can use the <code class="literal">ABPerson</code> class' <code class="literal">SetPhones</code> method. It accepts an <code class="literal">ABMultiValue&lt;string&gt;</code> object as its parameter, but we cannot add new values to the <code class="literal">ABMultiValue</code> objects. We can, however, write values to an <code class="literal">ABMutableMultiValue&lt;T&gt;</code> object, as follows:</p><div><pre class="programlisting">ABMutableMultiValue&lt;string&gt; newPhones = phones.ToMutableMultiValue();</pre></div><p>This line of code creates a new instance of the <code class="literal">ABMutableMultiValue&lt;string&gt;</code> object, which we then use to add the phone number(s) we want, as follows:</p><div><pre class="programlisting">newPhones.Add("+120987654321", ABPersonPhoneLabel.iPhone);
eachPerson.SetPhones(newPhones);
addressBook.Save();</pre></div><p>The second<a id="id505" class="indexterm"/> parameter of the <code class="literal">Add</code> method is the label that the phone number will have when it is saved to the contact. It is important to call the <code class="literal">ABAddressBook.Save()</code> method, or else, the changes will not be saved.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Displaying contacts</h1></div></div></div><p>In this recipe, we <a id="id506" class="indexterm"/>will learn how to use the native address book <a id="id507" class="indexterm"/>user interface to display contact information.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec283"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">DisplayContactApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec284"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a button on the controller.</li><li class="listitem">In the <code class="literal">AppDelegate.cs</code> file, add the <code class="literal">DisplayContactAppViewController</code> to a navigation controller, as follows:<div><pre class="programlisting">window.RootViewController = new UINavigationController(viewController);</pre></div></li><li class="listitem">Add the following namespaces in the <code class="literal">DisplayContactAppViewController.cs</code> file:<div><pre class="programlisting">using MonoTouch.AddressBook;
using MonoTouch.AddressBookUI;</pre></div></li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.btnDisplayContact.TouchUpInside += (sender, e) =&gt; {
  ABAuthorizationStatus status = ABAddressBook.GetAuthorizationStatus();
  NSError error;
  ABAddressBook addressBook = ABAddressBook.Create(out error);
  if (status == ABAuthorizationStatus.NotDetermined)
  {
    addressBook.RequestAccess((g, err) =&gt; {
      if (g)
      {
        this.InvokeOnMainThread(() =&gt;this.DisplayContactCard(addressBook));
      } else
      {
        Console.WriteLine("User denied access to the address book!");
      }
    });
  } else if (status == ABAuthorizationStatus.Authorized)
  {
    this.DisplayContactCard(addressBook);
  } else
  {
    Console.WriteLine("App does not have access to the address book!");
  }
};</pre></div></li><li class="listitem">Add the<a id="id508" class="indexterm"/> following method:<div><pre class="programlisting">private void DisplayContactCard(ABAddressBookaddressBook)
{
  ABPerson[] contacts = addressBook.GetPeople();
  ABPersonViewController personController = new ABPersonViewController();
  personController.DisplayedPerson = contacts[0];
  this.NavigationController.PushViewController(personController, true);
}</pre></div></li><li class="listitem">Compile <a id="id509" class="indexterm"/>and run the application on the simulator. Tap the button to show the contact card screen. The result should be similar to the following screenshot:<div><img src="img/8924OT_08_06.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec285"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.AddressBookUI</code> namespace contains the controllers that the native <em>Contacts</em> app<a id="id510" class="indexterm"/> uses to allow the user to display and manage <a id="id511" class="indexterm"/>contacts. Each contact's details can be viewed with <code class="literal">ABPersonViewController</code>. This controller must be pushed to <code class="literal">UINavigationController</code>, or else it will not display correctly.</p><p>After initializing it, we set the <code class="literal">ABPerson</code> object, which we want to be displayed, to its <code class="literal">DisplayedPerson</code> property, as follows:</p><div><pre class="programlisting">ABPersonViewController personController = new ABPersonViewController();
personController.DisplayedPerson = contacts[0];</pre></div><p>Then, we push it to the navigation controller's stack using the following line of code:</p><div><pre class="programlisting">this.NavigationController.PushViewController(personController, true);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec286"/>There's more...</h2></div></div></div><p>The <code class="literal">ABPersonViewController</code> class can also be used for editing. To do this, set the <code class="literal">AllowsEditing</code> property <a id="id512" class="indexterm"/>to <code class="literal">true</code>, as follows:</p><div><pre class="programlisting">personController.AllowsEditing = true;</pre></div><p>Note that the <a id="id513" class="indexterm"/>changes are saved normally through the <code class="literal">ABPersonViewController</code> class.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec71"/>Other address book controllers</h3></div></div></div><p>The <code class="literal">MonoTouch.AddressBookUI</code> namespace contains all the controllers we need to create our <a id="id514" class="indexterm"/>own custom contacts application, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ABPeoplePickerNavigationController</code>: This is a navigation controller that displays the saved contacts. The user can select a contact from the list.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ABPersonViewController</code>: This is described in the example given in this recipe.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ABNewPersonViewController</code>: This is the controller that creates a new contact.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ABUnknownPersonViewController</code>: This is the controller that is displayed with partial data for creating a new contact. This is similar to the controller that is displayed when we tap on an unknown number in the list of recent calls on the device.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec287"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Managing the address book</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Managing the calendar</h1></div></div></div><p>In this <a id="id515" class="indexterm"/>recipe, we will learn how create an event and save it to the device's calendar database.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec288"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">CalendarEventsApp</code>.</p><p>The app we will be creating will output the calendar events of the next 30 days. Make sure you have some calendar events in that period.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec289"/>How to do it...</h2></div></div></div><p>Let's create an event and save it to the device's calendar database by performing the following<a id="id516" class="indexterm"/> steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a button on the main view of the controller.</li><li class="listitem">Add the <code class="literal">MonoTouch.EventKit</code> namespace in the <code class="literal">CalendarEventAppViewController.cs</code> file.</li><li class="listitem">Enter the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.btnDisplayEvents.TouchUpInside += async (sender, e) =&gt; {
  EKAuthorizationStatus status = EKEventStore.GetAuthorizationStatus(EKEntityType.Event);
  EKEventStore evStore = new EKEventStore();
  if (status == EKAuthorizationStatus.NotDetermined)
  {
    if (await evStore.RequestAccessAsync(EKEntityType.Event))
    {
      this.DisplayEvents(evStore);
    } else
    {
      Console.WriteLine("User denied access to the calendar!");
    }
  } else if (status == EKAuthorizationStatus.Authorized)
  {
    this.DisplayEvents(evStore);
  } else
  {
    Console.WriteLine("App does not have access to the calendar!");
  }
};</pre></div></li><li class="listitem">Add the following method:<div><pre class="programlisting">private void DisplayEvents (EKEventStoreevStore)
{
  NSPredicate evPredicate = 
    evStore.PredicateForEvents(DateTime.Now, DateTime.Now.AddDays(30), evStore.GetCalendars(EKEntityType.Event));
  evStore.EnumerateEvents(evPredicate, delegate(EKEventcalEvent, ref bool stop) {
    if (null != calEvent) {
      stop = false;
      Console.WriteLine("Event title: {0}\nEvent start date: {1}", calEvent.Title, calEvent.StartDate);
    }
  });
}</pre></div></li><li class="listitem">Compile and run the app on the device. Click on the <strong>Display events</strong> button to output the calendar events of the next 30 days in the <strong>Application Output</strong> pad.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec290"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.EventKit</code> namespace is responsible for managing the calendar events. To read the <a id="id517" class="indexterm"/>stored events, we first check if we have access to the calendar and initialize an <code class="literal">EKEventStore</code> object, as follows:</p><div><pre class="programlisting">EKAuthorizationStatus status = EKEventStore.GetAuthorizationStatus(EKEntityType.Event);
  EKEventStore evStore = new EKEventStore();</pre></div><p>If the authorization status is <code class="literal">NotDetermined</code>, we call the <code class="literal">RequestAccessAsync</code> method so that the user is prompted for access, as follows:</p><div><pre class="programlisting">if (await evStore.RequestAccessAsync(EKEntityType.Event))</pre></div><p>If the result is <code class="literal">true</code>, it means that the user has granted calendar access to our app. Now, we call the <code class="literal">DisplayEvents</code> method to read and output the events.</p><p>The <code class="literal">EKEventStore</code> class provides us access to the stored events. To retrieve the calendar events, we need a predicate of the <code class="literal">NSPredicate</code> type. We can create an instance through the <code class="literal">PredicateForEvents</code> method of the <code class="literal">EKEventStore</code> class using the following code snippet:</p><div><pre class="programlisting">NSPredicate evPredicate = 
    evStore.PredicateForEvents(DateTime.Now, DateTime.Now.AddDays(30), evStore.GetCalendars(EKEntityType.Event));</pre></div><p>The first two parameters are of the <code class="literal">NSDate</code> type (which can be implicitly converted to <code class="literal">DateTime</code>) and represent the start and end dates for which to search events. The third parameter is of the <code class="literal">EKCalendar[]</code>type, and is an array of the calendars to search. To search all the available calendars, we pass the return value of the <code class="literal">GetCalendars</code> method.</p><p>Finally, we call the <code class="literal">EnumerateEvents</code> method using the following line of code:</p><div><pre class="programlisting">evStore.EnumerateEvents(evPredicate, delegate(EKEventcalEvent, ref bool stop) {
//...</pre></div><p>We pass the predicate we created earlier to the first parameter. The second parameter is a delegate of the <code class="literal">EKEventSearchCallback</code> type. To read each event's data, we use its <code class="literal">EKEvent</code> object. Note that the process of enumerating calendar events is similar to the one that is used for enumerating assets from the assets library, discussed in the previous chapter. This <a id="id518" class="indexterm"/>means that if the <code class="literal">EKEvent</code> object is not null, we must explicitly set the <code class="literal">stop</code> parameter to <code class="literal">false</code> so that the <code class="literal">EKEventStore</code> class continues enumerating the calendar events.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec291"/>There's more...</h2></div></div></div><p>Except from enumerating events, the <code class="literal">EKEventStore</code> class also allows us to create new events. The following example creates and saves a new calendar event:</p><div><pre class="programlisting">
<strong>EKEvent newEvent = EKEvent.FromStore(evStore);</strong>
newEvent.StartDate = DateTime.Now.AddDays(1);
newEvent.EndDate = DateTime.Now.AddDays(1.1);
newEvent.Title = "Xamarin event!";
<strong>newEvent.Calendar = evStore.DefaultCalendarForNewEvents;</strong>
NSError error = null;
evStore.SaveEvent(newEvent, EKSpan.ThisEvent, out error);</pre></div><p>For creating a new <code class="literal">EKEvent</code> instance, we use the <code class="literal">EKEvent.FromStore</code> static method. We then set the start and end dates, a title, and the calendar to which the event will be stored. Here, we use the default calendar that we can get with the <code class="literal">DefaultCalendarForNewEvents</code> property of <code class="literal">EKEventStore</code>. When we have everything set up, we call the <code class="literal">SaveEvent</code> method to save it.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec72"/>Reminders</h3></div></div></div><p>You may<a id="id519" class="indexterm"/> have noticed the usage of the <code class="literal">EKEntityType</code> enumeration. This defines the entity type we want to have access to. Other than <code class="literal">Event</code>, which refers to the calendar events, we can also use the <code class="literal">Reminder</code> value so that we can work with the tasks the user has in the <em>Reminders</em> app.</p><p>We need to explicitly ask for the <strong>Reminders</strong> permission, even if the user has already granted access to the calendar.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec292"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Managing album items directly</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Multimedia Resources">Chapter 7</a>, <em>Multimedia Resources</em></li></ul></div></div></div></body></html>