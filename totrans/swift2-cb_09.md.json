["```swift\n    #import \"AddressBook.h\"\n    ```", "```swift\n    struct Contact {\n        char name[60];\n        char phone[20];\n        struct date {\n            int day;\n            int month;\n            int year;\n        } birthday;\n    };\n\n    struct ContactList {\n        struct Contact contact;\n        struct ContactList * next;\n    };\n    ```", "```swift\n    struct Contact createContact();\n    void initializeContactList(struct ContactList ** );\n    void insertContact(struct ContactList **, struct Contact);\n    void saveContactList(struct ContactList *, const char *);\n    void destroyContactList(struct ContactList **);\n    ```", "```swift\n    struct Contact createContact(){\n        struct Contact newContact;\n        strcpy(newContact.name, \"\");\n        strcpy(newContact.phone, \"\");\n        newContact.birthday.day = 0;\n        newContact.birthday.month = 0;\n        newContact.birthday.year = 0;\n        return newContact;\n    }\n\n    void initializeContactList(struct ContactList ** contactList ){\n        *contactList = NULL;\n    }\n\n    void insertContact(struct ContactList ** contactList, struct Contact contact){\n        struct ContactList * newContactList = malloc(sizeof(struct ContactList));\n        newContactList->next = *contactList;\n        newContactList->contact = contact;\n        *contactList = newContactList;\n    }\n\n    void saveContactList(struct ContactList * contactList, const char * filename){\n        FILE * file = fopen(filename, \"wb\");\n        if (file) {\n            while (contactList) {\n                fwrite(&contactList->contact, sizeof(struct Contact), 1, file);\n                contactList = contactList->next;\n            }\n            fclose(file);\n        }\n    }\n\n    void destroyContactList(struct ContactList ** contactList){\n        struct ContactList * aux;\n        while ((aux = *contactList)) {\n            *contactList = (*contactList)->next;\n            free(aux);\n        }\n    }\n    ```", "```swift\n    import AddressBook\n    ```", "```swift\n    var list:UnsafeMutablePointer<ContactList> = nil\n    ```", "```swift\n        override func viewDidLoad() {\n            super.viewDidLoad()\n            initializeContactList(&list)\n        }\n    ```", "```swift\n        deinit{\n            destroyContactList(&list)\n        }\n    ```", "```swift\n        @IBAction func fillContacts(sender: UIButton) {\n            let status = ABAddressBookGetAuthorizationStatus()\n\n            switch status {\n            case .Authorized:\n                // When the user has already authorized previously.\n                self.readContacts()\n            case .NotDetermined:\n                // this case happens when it is the first time the user opens the app, so we have to request his permission\n                var ok = false\n                ABAddressBookRequestAccessWithCompletion(nil) {\n                    (granted:Bool, err:CFError!) in\n                    if granted {\n                        self.readContacts()\n                    }\n                }\n            case .Restricted:\n                fallthrough\n            case .Denied:\n                // These cases are when for any reason the app can't access the contacts\n                UIAlertView(title: \"Not authorized\", message: \"This app isn't authorized for reading your contacts\", delegate: nil, cancelButtonTitle: \"OK\").show()\n            }\n        }\n    ```", "```swift\n        private func readContacts(){\n            var err : Unmanaged<CFError>? = nil\n            var myAddressBook: ABAddressBook = ABAddressBookCreateWithOptions(nil, &err).takeRetainedValue()\n            let myContacts = ABAddressBookCopyArrayOfAllPeople(myAddressBook).takeRetainedValue() as NSArray as [ABRecord]\n\n            for aContact in myContacts {\n                var newContactRecord:Contact = createContact();\n\n                // Retrieving name\n                var nameString = ABRecordCopyCompositeName(aContact).takeRetainedValue() as String\n                copyIntoCString(&newContactRecord.name, swiftString:nameString)\n\n                // Retrieving phone\n                var phones:ABMultiValue = ABRecordCopyValue(aContact, kABPersonPhoneProperty).takeRetainedValue() as ABMultiValue\n                if(ABMultiValueGetCount(phones) > 0){\n                    var phoneString = ABMultiValueCopyValueAtIndex(phones, 0).takeRetainedValue() as String\n                    copyIntoCString(&newContactRecord.phone, swiftString:phoneString)\n                }\n                // Retrieving birthday\n                if let date = ABRecordCopyValue(aContact, kABPersonBirthdayProperty).takeRetainedValue() as? NSDate {\n                    var calendar = NSCalendar.currentCalendar().components([.Day, .Month, .Year], fromDate: date)\n                    newContactRecord.birthday.day = Int32(calendar.day)\n                    newContactRecord.birthday.month = Int32(calendar.month)\n                    newContactRecord.birthday.year = Int32(calendar.year)\n                }\n                insertContact(&list, newContactRecord)\n            }\n            UIAlertView(title: nil, message: \"The contacts were loaded\", delegate: nil, cancelButtonTitle: \"OK\").show()\n        }\n    ```", "```swift\n        @IBAction func saveContacts(sender: UIButton) {\n            let documentDir:NSString = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString\n            var filename:NSString = documentDir.stringByAppendingPathComponent(\"contacts.dat\") as NSString\n            saveContactList(list, filename.UTF8String)\n            UIAlertView(title: \"Contacts saved\", message: \"contacts.dat was saved.\", delegate: nil, cancelButtonTitle: \"Ok\").show()\n        }\n    ```", "```swift\n    func copyIntoCString<T>(inout cstring: T, swiftString: String){\n        withUnsafeMutablePointer(&cstring, { (cstr) -> Void in\n            let fullSwinftString = swiftString + String(UnicodeScalar(0))\n            let newCString = fullSwinftString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!\n            newCString.getBytes(cstr, length: sizeofValue(cstring))\n        })\n    }\n    ```", "```swift\n    #include <Chapter 9 BCL/huffman.h>\n    #include <Chapter 9 BCL/lz.h>\n    #include <Chapter 9 BCL/rice.h>\n    #include <Chapter 9 BCL/rle.h>\n    #include <Chapter 9 BCL/shannonfano.h>\n    #include <Chapter 9 BCL/systimer.h>\n    ```", "```swift\n        @IBOutlet weak var textView: UITextView!\n    ```", "```swift\n        @IBAction func huffman(sender: UIButton) {\n            let text = self.textView.text\n            let textIn:UnsafeMutablePointer<UInt8> = UnsafeMutablePointer<UInt8>((text as NSString).UTF8String)\n            let textOut:UnsafeMutablePointer<UInt8> = UnsafeMutablePointer<UInt8>.alloc(countElements(text) * 101 / 100 + 320)\n            let outsize = Huffman_Compress(textIn, textOut, UInt32( countElements(text)))\n            save(\"huffman.dat\", data: textOut, dataSize: Int(outsize))\n        }\n    ```", "```swift\n        @IBAction func lz(sender: UIButton) {\n            let text = self.textView.text\n            let textIn:UnsafeMutablePointer<UInt8> = UnsafeMutablePointer<UInt8>((text as NSString).UTF8String)\n            let textOut:UnsafeMutablePointer<UInt8> = UnsafeMutablePointer<UInt8>.alloc(countElements(text) * 257 / 256 + 1)\n            let outsize = LZ_Compress(textIn, textOut, UInt32( countElements(text)))\n            save(\"lz.dat\", data: textOut, dataSize: Int(outsize))\n        }\n    ```", "```swift\n        private func save(filename: String, data: UnsafePointer<UInt8>, dataSize: Int){\n            let nsData = NSData(bytes: data, length: dataSize)\n            let path = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String + \"/\\(filename)\"\n            NSFileManager.defaultManager().createFileAtPath(path, contents: nsData, attributes: nil)\n        }\n    ```", "```swift\n    #include \"AssemblyCode.h\"\n    ```", "```swift\n    void swap(int * firstnumber, int * secondnumber);\n    ```", "```swift\n    void swap(int * firstnumber, int * secondnumber){\n    #if defined __arm64__ || defined __arm__\n        asm volatile (\n                      \"EOR %[first],%[first], %[second] \\n\\t\"\n                      \"EOR %[second],%[second], %[first] \\n\\t\"\n                      \"EOR %[first],%[first], %[second] \\n\\t\"\n                      : /* outputs */ [first]\"=r\"(*firstnumber), [second]\"=r\"(*secondnumber)\n                      : /* inputs */ [first]\"r\"(*firstnumber), [second]\"r\"(*secondnumber)\n                      );\n    #else\n    #error \"Architecture not allowed\"\n    #endif\n    }\n    ```", "```swift\n        @IBOutlet weak var firstNumberTextField: UITextField!\n        @IBOutlet weak var secondNumberTextField: UITextField!\n    ```", "```swift\n        @IBAction func swapNumbers(sender: UIButton) {\n            var number1 = Int32(Int(self.firstNumberTextField.text!))\n            var number2 = Int32(Int(self.secondNumberTextField.text!))\n            swap(&number1, &number2)\n            self.firstNumberTextField.text = \"\\(number1)\"\n            self.secondNumberTextField.text = \"\\(number2)\"\n        }\n    ```", "```swift\n    #ifdef __cplusplus\n    #include \"pugixml.hpp\"\n    #endif\n    Now we can define this class with the following code.\n    @interface PugiBase : NSObject\n    @property (nonatomic, assign) void * element;\n    -(instancetype) init;\n    @end\n    Once this class interface is defined we can implement it, in this case only the initializer is necessary by setting the property to NULL.\n    @implementation PugiBase\n    -(instancetype) init{\n        self = [super init];\n        if(self){\n            self.element = NULL;\n        }\n        return self;\n    }\n    @end\n    ```", "```swift\n    #import \"PugiBase.h\"\n\n    @interface PugiNodeAttribute : PugiBase\n    -(void) setValue:(NSString *) value;\n    @end\n    ```", "```swift\n    @implementation PugiNodeAttribute\n\n    -(void) setValue:(NSString *) value{\n        if(self.element){\n            reinterpret_cast<pugi::xml_attribute *>(self.element)->set_value([value UTF8String]);\n        }\n    }\n\n    @end\n    ```", "```swift\n    #import \"PugiBase.h\"\n    #import \"PugiNodeAttribute.h\"\n\n    @interface PugiNode : PugiBase\n    -(PugiNode*) appendChild:(NSString *) name;\n    -(PugiNodeAttribute *) appendAttribute:(NSString *) name;\n    @end\n    For the implementation just add this code.\n    #import \"PugiNode.h\"\n    #import \"PugiNodeAttribute.h\"\n\n    @implementation PugiNode\n\n    -(PugiNode*) appendChild:(NSString *) name{\n        if (self.element) {\n            PugiNode * newNode = [PugiNode new];\n            newNode.element = new pugi::xml_node(reinterpret_cast<pugi::xml_node*>(self.element)->append_child([name UTF8String]));\n            return  newNode;\n        }\n        return nil;\n    }\n    -(PugiNodeAttribute *) appendAttribute:(NSString *) name{\n        if (self.element){\n            PugiNodeAttribute * newAttribute = [PugiNodeAttribute new];\n            newAttribute.element = new pugi::xml_attribute(reinterpret_cast<pugi::xml_node*>(self.element)->append_attribute(name.UTF8String));\n            return newAttribute;\n        }\n        return nil;\n    }\n\n    @end\n    ```", "```swift\n    #import \"PugiBase.h\"\n    #import \"PugiNode.h\"\n\n    @interface PugiDocument : PugiBase\n\n    -(instancetype) init;\n    -(PugiNode *) appendChild:(NSString *) name;\n    -(void) saveFile:(NSString *) path;\n\n    @end\n    On the implementation file (PugiDocument.mm) add the following code.\n    @implementation PugiDocument\n\n    -(instancetype) init{\n        self = [super init];\n        if(self){\n            self.element = new pugi::xml_document;\n        }\n        return self;\n    }\n\n    -(PugiNode *) appendChild:(NSString *) name{\n        if(self.element){\n            PugiNode * newNode = [PugiNode new];\n            newNode.element = new pugi::xml_node(reinterpret_cast<pugi::xml_document *>(self.element)->append_child([name UTF8String]));\n            return newNode;\n        }\n        return nil;\n    }\n\n    -(void) saveFile:(NSString *) path{\n        if (self.element) {\n            reinterpret_cast<pugi::xml_document *>(self.element)->save_file(path.UTF8String);\n        }\n    }\n\n    @end\n    ```", "```swift\n    class Task {\n        var description:String\n        var important :Bool\n\n        init(description:String, important: Bool){\n            self.description = description\n            self.important = important\n        }\n    }\n    ```", "```swift\n    #import \"PugiDocument.h\"\n    #import \"PugiNode.h\"\n    #import \"PugiNodeAttribute.h\"\n    ```", "```swift\n        @IBOutlet var taskTextField: UITextField!\n        @IBOutlet var importantSwitch: UISwitch!\n    ```", "```swift\n        var tasks = [Task]()\n    ```", "```swift\n        @IBAction func addTask(sender: AnyObject) {\n            tasks.append(Task(description: taskTextField.text, important: importantSwitch.on))\n            taskTextField.text = \"\"\n            importantSwitch.on = false\n        }\n    ```", "```swift\n        @IBAction func saveXml(sender: AnyObject) {\n            var document = PugiDocument()!\n            var mainNode = document.appendChild(\"tasks\")\n            var path = (NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString).stringByAppendingPathComponent(\"tasks.xml\") as String;\n            for task in tasks {\n                let node = mainNode.appendChild(\"task\")\n                let attributeDescription = node.appendAttribute(\"description\")\n                attributeDescription.setValue(task.description)\n                let attributeImporant = node.appendAttribute(\"important\")\n                attributeImporant.setValue(task.important ? \"yes\" : \"no\")\n            }\n            document.saveFile(path)\n        }\n    ```"]