- en: Chapter 2. Lua Crash Course and the Corona Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Lua 快速入门和 Corona 框架
- en: '**Lua** is the programming language used to develop the Corona SDK. Up until
    now, we have learned how to use the major resources to run the SDK and other development
    tools to create an application for mobile devices. Now that we have dabbled into
    creating a couple of lines of code that make a program work, let''s jump into
    the fundamentals that will give you a better understanding of what Lua is capable
    of.'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Lua** 是开发 Corona SDK 所使用的编程语言。到目前为止，我们已经学习了如何使用主要资源来运行 SDK 和其他开发工具来创建移动设备的应用程序。现在我们已经尝试编写了一些使程序工作的代码行，让我们深入了解
    Lua 的基本功能，这将让您更好地理解 Lua 的能力。'
- en: 'In this chapter, you will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Apply variables to a script
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量应用于脚本
- en: Use data structures to form tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据结构来形成表
- en: Work with display objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与显示对象一起工作
- en: Implement functions using object methods and arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象方法和参数实现函数
- en: Optimize your workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化你的工作流程
- en: So let's get right to it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们直接进入正题。
- en: Lua to the rescue
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua 来帮忙
- en: Lua is the industry standard for game programming. It is similar to JavaScript
    and Flash's ActionScript. Anyone who's done any scripting in these languages will
    make the transition to Lua almost immediately.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是游戏编程的行业标准。它与 JavaScript 和 Flash 的 ActionScript 类似。任何在这些语言中编写过脚本的人都会很快过渡到
    Lua。
- en: Lua has been useful in creating various applications and games. Many game programmers
    have found Lua to be a convenient scripting language due to how easy it is to
    embed, its fast execution, and its small learning curve. It is ubiquitous in World
    of Warcraft. It is also used by Electronic Arts, Rovio, ngmoco, and Tapulous in
    games such as Angry Birds, Tap Tap Revenge, Diner Dash, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 在创建各种应用程序和游戏中非常有用。许多游戏程序员发现 Lua 是一种方便的脚本语言，因为它易于嵌入、执行速度快，学习曲线平缓。它在《魔兽世界》中无处不在。它也被电子艺界、Rovio、ngmoco
    和 Tapulous 等公司用于愤怒的小鸟、Tap Tap Revenge、Diner Dash 等游戏。
- en: For more information on Lua, refer to [http://www.lua.org](http://www.lua.org).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 Lua 的信息，请参阅 [http://www.lua.org](http://www.lua.org)。
- en: Valuable variables
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有价值的变量
- en: Like in many scripting languages, Lua has variables. You can think of it as
    something that stores values. When you apply a value to a variable, you can refer
    to it using the same variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在许多脚本语言中一样，Lua 有变量。您可以将它视为存储值的东西。当您将值应用于变量时，您可以使用相同的变量来引用它。
- en: An application consists of statements and variables. **Statements** provide
    instructions on what operations and computations need to be done. **Variables**
    store the values of these computations. Setting a value into a variable is called
    an **assignment**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序由语句和变量组成。**语句**提供关于需要执行的操作和计算指令。**变量**存储这些计算的结果。将值赋给变量称为**赋值**。
- en: 'Lua uses three kinds of variables: **global, local**, and **table fields**.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 使用三种类型的变量：**全局、局部**和**表字段**。
- en: Global variables
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: A **global variable** can be accessed in every scope and can be modified from
    anywhere. The term scope is used to describe the area in which a set of variables
    live. You don't have to declare a global variable. It is created as soon as you
    assign a value to it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局变量**可以在任何范围内访问，并且可以从任何地方修改。术语范围用于描述一组变量存在的区域。您不必声明全局变量。一旦您给它赋值，它就会创建。'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Local variables
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: A **local variable** is accessed from a local scope and usually called from
    a **function** or block of code. When we create a block, we are creating a scope
    in which variables can live or a list of statements, which are executed sequentially.
    When referencing a variable, Lua must find the variable. Localizing variables
    helps speed up the look-up process and improves the performance of your code.
    By using the local statement, it declares a local variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量**是从局部范围访问的，通常是从**函数**或代码块中调用。当我们创建一个块时，我们正在创建一个变量可以存在或一系列按顺序执行的语句的范围。当引用变量时，Lua
    必须找到该变量。局部化变量有助于加快查找过程并提高代码的性能。通过使用局部语句，它声明了一个局部变量。'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is how to declare a local variable in a block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在块中声明局部变量的方法：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Table fields (properties)
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表字段（属性）
- en: Table fields are elements of the table themselves. Arrays can be indexed with
    numbers and strings or any value pertaining to Lua except nil. You index into
    the array to assign the values to a field using integers. When the index is a
    string, the field is known as a **property**. All properties can be accessed using
    the dot operator (`x.y`) or a string (`x["y"]`) to index into a table. The result
    is the same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表字段是表本身的部分。数组可以用数字、字符串或任何与Lua相关的值（除了nil）来索引。您可以使用整数索引到数组以将值分配给字段。当索引是一个字符串时，该字段被称为**属性**。所有属性都可以使用点操作符（`x.y`）或字符串（`x["y"]`）来索引到表。结果是相同的。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: More information relating to tables will be discussed later in the section called
    *Tables*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更多有关表的信息将在名为*Tables*的部分中讨论。
- en: You may have noticed the additional text on certain lines of code in the preceding
    examples. Those are what you call comments. Comments begin anywhere with a double
    hyphen `--` , except inside a string. They run until the end of the line. Block
    comments are available as well. A common trick to comment out a block is to surround
    it with `--[[`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了前面示例中某些代码行的附加文本。那些就是所谓的注释。注释可以从任何位置开始，使用双破折号`--`，除了字符串内部。它们一直运行到行尾。还有块注释。注释一个块的一个常见技巧是将其包围在`--[[`。
- en: 'Here is how to comment one line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何注释一行：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is a block comment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个块注释：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Assignment conventions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值约定
- en: 'There are rules for variable names. A variable starts with a letter or an underscore.
    It can''t contain anything other than letters, underscores, or digits. It also
    can''t be one of the following words reserved by Lua:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名有一些规则。变量以字母或下划线开头。它不能包含除了字母、下划线或数字之外的其他任何内容。它也不能是Lua保留的以下单词之一：
- en: '`which`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`which`'
- en: '`are`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`are`'
- en: '`and`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`break`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`do`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do`'
- en: '`else`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`'
- en: '`elseif`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elseif`'
- en: '`end`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`'
- en: '`false`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`for`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`function`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`if`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`'
- en: '`in`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`'
- en: '`local`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`'
- en: '`nil`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil`'
- en: '`not`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`or`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`repeat`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`'
- en: '`return`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`then`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`'
- en: '`true`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`until`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until`'
- en: '`while`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`'
- en: 'The following are valid variables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量是有效的：
- en: '`x`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`'
- en: '`X`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`'
- en: '`ABC`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABC`'
- en: '`_abc`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_abc`'
- en: '`test_01`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_01`'
- en: '`myGroup`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myGroup`'
- en: 'The following are invalid variables:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不合法的变量：
- en: '`function`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`my-variable`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-variable`'
- en: '`123`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`123`'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Lua is also a case-sensitive language*. For example, using `else` is a reserved
    word, but *Else* and *ELSE* are two different, valid names.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lua也是一种区分大小写的语言*。例如，使用`else`是一个保留字，但*Else*和*ELSE*是两个不同的、有效的名称。'
- en: Types of values
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值的类型
- en: Lua is a dynamically typed language. There is no defined type in the language.
    Each value carries its own type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Lua是一种动态类型语言。语言中没有定义的类型。每个值都携带自己的类型。
- en: As you have noticed, values can be stored in variables. They can be manipulated
    to give a value of any type. This also allows you to pass arguments to other functions
    and return as results.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，值可以存储在变量中。它们可以被操作以给出任何类型的值。这也允许你将参数传递给其他函数，并作为结果返回。
- en: 'The basic types of values that you''ll deal with are the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将处理的基本值类型如下：
- en: '`nil`—It is the only type whose value is `nil`. Any uninitialized variable
    has `nil` as its value. Like global variables, it is `nil` by default and can
    be assigned `nil` to delete it.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil`——它是唯一一个值是`nil`的类型。任何未初始化的变量都有`nil`作为其值。像全局变量一样，它默认是`nil`，并且可以将`nil`赋给它来删除它。'
- en: '`Boolean`—The Boolean type has two values, `false` and `true`. You will notice
    that conditional expressions consider `false` and `nil` as false and anything
    else as true.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`——布尔类型有两个值，`false`和`true`。你会注意到，条件表达式将`false`和`nil`视为假，将其他任何内容视为真。'
- en: '`Numbers`—Represents real (double-precision floating-point) numbers.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Numbers`——表示实数（双精度浮点数）。'
- en: '`String`—A String is a sequence of characters. 8-bit characters and embedded
    zeros are allowed.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`——字符串是一系列字符。允许8位字符和嵌入的零。'
- en: '`Tables`—A data structure in Lua. It is implemented by an associative array,
    which is an array that can be indexed not only with numbers, but also with strings
    or any other value, except `nil`. (We will discuss more about this in the section
    *Tables* later in this chapter).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tables`——Lua中的数据结构。它通过关联数组实现，这是一种不仅可以使用数字索引，还可以使用字符串或任何其他值（除了`nil`）索引的数组。（我们将在本章后面的*Tables*部分中进一步讨论这一点）。 '
- en: '`Functions`—Known as first-class values of Lua. Typically, functions can be
    stored in variables, passed as arguments to other functions and returned as results.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Functions`——称为Lua的第一类值。通常，函数可以存储在变量中，作为参数传递给其他函数，并作为结果返回。'
- en: Time for action—printing values using blocks
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用块打印值
- en: Let's give it a shot and see how powerful a language Lua is. We're starting
    to get an idea of how variables work and what happens when you assign a value
    to it. What if you have a variable that has multiple values attached to it? How
    does Lua differentiate them? We'll be using the `Corona Terminal` so we can see
    the values outputted in the terminal box. Along the way, you'll pick up other
    programming techniques as you progress through this section. We will also be referring
    to chunks in this exercise. The unit of execution of Lua is called a **chunk**.
    A chunk is a sequence of statements, which are executed sequentially.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试，看看Lua语言有多强大。我们开始了解变量是如何工作的，以及当你给它赋值时会发生什么。如果你有一个具有多个值的变量怎么办？Lua如何区分它们？我们将使用`Corona
    Terminal`，这样我们就可以在终端框中看到输出的值。在这个过程中，你将随着本节的进展学习其他编程技巧。我们还将在这个练习中引用代码块。Lua的执行单元被称为**代码块**。代码块是一系列语句，它们按顺序执行。
- en: If you remember from the previous chapter, we learned how to create our own
    project folder and `main.lua` file for the Hello World application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章的内容，我们学习了如何为Hello World应用程序创建自己的项目文件夹和`main.lua`文件。
- en: Create a new project folder on your desktop and name it `Variables`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的桌面上创建一个新的项目文件夹，并将其命名为`Variables`。
- en: Open up your preferred text editor and save it as `main.lua` in your `Variables`
    project folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的文本编辑器，并将其保存为`Variables`项目文件夹中的`main.lua`。
- en: 'Create the following variables:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下变量：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `while` loop, add the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，添加以下代码：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an `if` statement that will represent another local body:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`if`语句来表示另一个局部体：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save your script.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本。
- en: Launch the `Corona Terminal`. Make sure you see the **Corona SDK** screen and
    a terminal window pop up.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`Corona Terminal`。确保你看到**Corona SDK**屏幕和一个终端窗口弹出。
- en: 'Navigate to your `Variables` project folder and open your `main.lua` file in
    the simulator. You will notice that the device in the simulator is blank, but
    if you look at your terminal window, there are some results from the code printed
    out as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的`Variables`项目文件夹，并在模拟器中打开你的`main.lua`文件。你会注意到模拟器中的设备是空的，但如果你查看你的终端窗口，你会看到一些代码打印出的结果如下：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What just happened?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The first two variables that were created are local outside of each block of
    code. Notice in the beginning of the `while` loop, `i <= x` refers to the variables
    in lines 1 and 2\. The statement `local x = i` inside the `while` loop is only
    local to the `do` body and is not the same as `local x = 10`. The `while` loop
    runs ten times and prints out a value that is incremented by 1 each time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的前两个变量在每个代码块外部都是局部的。注意在`while`循环的开始，`i <= x`指的是第1行和第2行的变量。`while`循环内部的`local
    x = i`语句仅限于`do`体的局部，并且与`local x = 10`不同。`while`循环运行十次，每次递增1打印出一个值。
- en: The `if` statement compares `i < 20`, where `i` equals 1 and uses another `local
    x` that is local to the `then` body. Since the statement is true, `x` equals 20
    and prints out the value of `x + 5` which is 25.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句比较`i < 20`，其中`i`等于1，并使用另一个局部于`then`体的`local x`。由于该语句为真，`x`等于20，并打印出`x
    + 5`的值，即25。'
- en: The very last line, `print(x)` is not attached to any of the blocks of code
    in the `while` loop or the `if` statement. Therefore, it refers to `local x =
    10` and prints out the value of `10` in the terminal window. This may seem confusing,
    but it's important to understand how local and global variables work in Lua.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句`print(x)`没有连接到`while`循环或`if`语句中的任何代码块。因此，它指的是`local x = 10`，并在终端窗口中打印出`10`的值。这可能会让人感到困惑，但了解Lua中局部和全局变量如何工作是很重要的。
- en: Expressions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: An **expression** is something that has a value. It can include numeric constants,
    quoted strings, variable names, unary and binary operations, and function calls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**是具有值的某种东西。它可以包括数值常数、引号字符串、变量名、一元和二元运算以及函数调用。'
- en: Arithmetic operators
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: '`+, -, *, /, %`, and `^` are called **arithmetic operators.**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`+, -, *, /, %`和`^`被称为**算术运算符**。'
- en: 'The following is an example using *Binary arithmetic* operators:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用*二进制算术*运算符的示例：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is an example using the *Modulo* (division remainder) operator:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用*模数*（除法余数）运算符的示例：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is an example using the *Power of* operator:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用*幂*运算符的示例：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Relational operators
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: '**Relational operators** always result in `false` or `true` and ask yes-or-no
    questions.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系运算符**总是返回`false`或`true`，并询问是或否的问题。'
- en: '`<, >, <=, >=, ==`, and `~=` are some of the relational operators.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`<, >, <=, >=, ==`, 和 `~=` 是一些关系运算符。'
- en: The operator `==` tests for equality and the operator `~=` is the negation of
    equality. If the value types are different, then the result is false. Otherwise,
    Lua compares the values to their types. Numbers and strings are compared in the
    usual way. Tables and functions are compared by reference, as long as two such
    values are considered equal only if they are the same object. When a new object
    is created, the new object is different from the previously existing one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `==` 检查相等性，而运算符 `~=` 是相等性的否定。如果值类型不同，则结果为假。否则，Lua 会比较值及其类型。数字和字符串按常规方式比较。表和函数通过引用比较，只要两个这样的值被认为是相等的，只有当它们是同一个对象时。
- en: 'The following are the examples of relational operators. It will display a `Boolean`
    result and can''t be concatenated with a string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关系运算符的示例。它将显示一个 `布尔` 结果，并且不能与字符串连接：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Logical operators
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: The **logical operators** in Lua are `and, or`, and `not`. All logical operators
    consider both `false` and `nil` as false and anything else as true.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的 **逻辑运算符** 是 `and, or`, 和 `not`。所有逻辑运算符都将 `false` 和 `nil` 视为假，将其他任何内容视为真。
- en: The operator `and` returns its first argument if the value is `false` or `nil`;
    otherwise it returns its second argument. The operator `or` returns its first
    argument if the value is different from `nil` and `false`; otherwise, it returns
    its second argument. Both `and` and `or` use short-cut evaluation, which means,
    the second operand is evaluated only when necessary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `and` 如果其值是 `false` 或 `nil`，则返回其第一个参数；否则返回其第二个参数。运算符 `or` 如果其值不同于 `nil`
    和 `false`，则返回其第一个参数；否则返回其第二个参数。`and` 和 `or` 都使用短路评估，这意味着第二个操作数只有在必要时才会被评估。
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The operator `not` always returns `true` or `false:`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `not` 总是返回 `true` 或 `false`：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Concatenation
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: The **string concatenation operator** in Lua is denoted by two dots `...` It
    takes two strings as operands and splices them together. If any of its operands
    are numbers, then they are also converted to a string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的 **字符串连接运算符** 用两个点 `...` 表示。它接受两个字符串作为操作数并将它们拼接在一起。如果其操作数中包含数字，则它们也会被转换为字符串。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Length operator
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度运算符
- en: The **length operator** `#`, measures the length of a string. The length of
    a string is simply the number of characters in it. A character is considered as
    1 byte.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**长度运算符** `#` 测量字符串的长度。字符串的长度简单地是其字符数。一个字符被视为 1 字节。'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Precedence
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级
- en: 'Operator precedence in Lua is as follows, from higher to lower priority:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的运算符优先级如下，从高到低优先级：
- en: '`^`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`'
- en: '`not # -` (unary)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not # -` (一元)'
- en: '`* /`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* /`'
- en: '`+ -`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+ -`'
- en: '`..`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`..`'
- en: '`< > <= >= ~= ==`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< > <= >= ~= ==`'
- en: '`and`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`or`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`'
- en: All binary operators are left associative, except for `^` exponentiation and
    `..` concatenation, which are right associative. You can use parentheses to change
    the precedence of an expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有二元运算符都是左结合的，除了 `^` 幂运算和 `..` 连接，它们是右结合的。您可以使用括号来改变表达式的优先级。
- en: 'In cases where two operands of the same precedence compete for operands, the
    operand belongs to the operator on the left:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个具有相同优先级的操作数竞争操作数的情况下，操作数属于左侧的运算符：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding expression shows both the addition and subtraction operators,
    which have equal precedence. The second element (the number 4) belongs to the
    addition operator, so the expression is evaluated mathematically as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式显示了加法和减法运算符，它们具有相同的优先级。第二个元素（数字 4）属于加法运算符，因此表达式按照以下方式进行数学评估：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s focus on the rules of precedence based on priority. For example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注基于优先级的运算符优先级规则。例如：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An inexperienced programmer might think that the value of the preceding example
    is 90, if it were evaluated from left to right. The correct value is 34 because
    multiplication has a higher precedence over addition, so it is performed first.
    Adding parentheses to the same expression will make it easier to read:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺乏经验的程序员可能会认为前面示例的值是 90，如果从左到右进行评估的话。正确值是 34，因为乘法比加法有更高的优先级，所以它首先执行。在相同的表达式中添加括号会使它更容易阅读：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Strings
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Earlier in this chapter, you saw some code examples using sequences of characters.
    Those sequences of characters are called **strings**. Strings may contain characters
    with any numeric value, including embedded zeros. This also means that binary
    data can be stored in a string.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你看到了一些使用字符序列的代码示例。这些字符序列被称为**字符串**。字符串可以包含任何数值的字符，包括嵌入的零。这也意味着二进制数据可以存储在字符串中。
- en: Quoting strings
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用字符串
- en: 'There are three ways to quote strings: with double quotes, with single quotes
    and with square brackets.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式来引用字符串：使用双引号、使用单引号和使用方括号。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When quoting strings, make sure that only straight up and down quotation characters
    are used in your code or else it will not compile.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用字符串时，确保你的代码中只使用直上直下的引号字符，否则代码将无法编译。
- en: 'Using double quote characters`"` mark the beginning and end of the string.
    For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号`"`标记字符串的开始和结束。例如：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can also quote strings by using the single quote character`'`. Single quotes
    work the same as double quotes except that single-quoted strings can contain a
    double quote.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用单引号`'`来引用字符串。单引号与双引号的作用相同，只是单引号字符串可以包含双引号。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lastly, using a pairs of square brackets will also quote strings. They are used
    mainly for strings when double or single quotes cannot be used. There are not
    many cases that this occurs, but they will do the job.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用一对方括号也可以引用字符串。它们主要用于字符串，当双引号或单引号不能使用时。这种情况很少发生，但它们可以完成这项工作。
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Time for action—getting our hands full of strings
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手实践，让我们充分了解字符串
- en: We're starting to familiarize ourselves with several blocks of code and how
    they interact with each other. Let's see what happens when we add in some expressions
    using strings and how different they are in comparison to just regular strings
    you print out in the terminal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始熟悉几个代码块及其相互之间的交互。让我们看看当我们添加一些使用字符串的表达式时会发生什么，以及它们与在终端中打印的普通字符串相比有何不同。
- en: Create a new project folder on your desktop and name it `Working With Strings`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的桌面创建一个新的项目文件夹，并将其命名为`Working With Strings`。
- en: Make a new `main.lua` file in your text editor and save it in your folder.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中创建一个新的`main.lua`文件，并将其保存在你的文件夹中。
- en: 'Type the following lines (Do not include the line numbers in the code, it is
    only used for line reference):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下行（代码中不要包含行号，它仅用于行参考）：
- en: '[PRE25]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add in the following variables. Notice that it uses the same variable name:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下变量。注意它使用了相同的变量名：
- en: '[PRE26]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's add in more variables with some string values and compare them using different
    operators.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些具有字符串值的变量，并使用不同的运算符进行比较。
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save your script and launch your project in Corona. Observe the results in the
    terminal window.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并在Corona中启动你的项目。在终端窗口中观察结果。
- en: '[PRE28]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What just happened?
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You can see that line 1 is just a plain string with characters printed out.
    In line 2, notice that the number 15 is inside the string and then added to the
    number 1 which is outside the string. Lua provides automatic conversions between
    number and strings at runtime. Numeric operations applied to a string will try
    to convert the string to a number.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，第1行只是一个普通的字符串，其中打印了字符。在第2行中，注意数字15位于字符串内部，然后与字符串外部的数字1相加。Lua在运行时提供数字和字符串之间的自动转换。对字符串应用的数值操作会尝试将字符串转换为数字。
- en: When working with variables, you can use the same one and have them contain
    a string and a number at different times as in lines 3 and 5 ( `myVar = 28` and
    `myVar = "twenty-eight")`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理变量时，你可以使用同一个变量，并在不同时间让它包含字符串和数字，就像第3行和第5行所示（`myVar = 28` 和 `myVar = "twenty-eight"`）。
- en: In the last chunk of code (lines 7-12), we compared different variable names
    using relational operators. First, we printed the strings of `Name1` and `Phone`.
    The next lines following the comparison between `Name1, Name2`, and `Phone`. When
    two strings have the same characters in the exact order, then they are considered
    as the same string and are equal to each other. When you look at `print(Name1
    == Phone)` and `print(Name1 <= Phone)`, the characters do not correlate with each
    other so they return `false`. In `print(Name1 == Name2)`, both variables contain
    the same characters and therefore returns `true.`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的最后一段（第7-12行），我们使用了关系运算符比较不同的变量名。首先，我们打印了`Name1`和`Phone`的字符串。接下来的几行是关于`Name1,
    Name2`和`Phone`之间的比较。当两个字符串具有完全相同的字符顺序时，它们被认为是相同的字符串，彼此相等。当你查看`print(Name1 == Phone)`和`print(Name1
    <= Phone)`时，字符之间没有关联，因此返回`false`。在`print(Name1 == Name2)`中，两个变量包含相同的字符，因此返回`true`。
- en: Have a go hero—pulling some more strings
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——拉一些更多的字符串
- en: 'Strings are pretty simple to work with since they are just sequences of characters.
    Try making your own expressions similar to the preceding example with the following
    modifications:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串处理起来相当简单，因为它们只是字符序列。尝试使用以下修改与前面的示例类似地创建自己的表达式：
- en: Create some variables with numerical values and another set of variables with
    numerical string values. Use relational operators to compare the values and then
    print out the results.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些具有数值的变量和另一组具有数值字符串的变量。使用关系运算符比较值，然后打印出结果。
- en: Use the concatenation operator and combine several strings or numbers together
    and space them out equally. Print out the result in the terminal window.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连接运算符将几个字符串或数字组合在一起，并均匀地间隔它们。在终端窗口中打印出结果。
- en: Tables
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: '**Tables** are the proprietary data structure in Lua. They represent arrays,
    lists, sets, records, graphs, an so on. A table in Lua is similar to an associative
    array. Associative arrays can be indexed with values of any type, not just numbers.
    Tables implement all these structures efficiently. For example, arrays can be
    implemented by indexing tables with integers. Arrays do not have a fixed size,
    but grow as needed. When initializing an array, its size is defined indirectly.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格**是Lua中的专用数据结构。它们代表数组、列表、集合、记录、图等。Lua中的表格类似于关联数组。关联数组可以用任何类型的值索引，而不仅仅是数字。表格有效地实现了所有这些结构。例如，可以通过用整数索引表格来实现数组。数组没有固定的大小，而是根据需要增长。当初始化数组时，其大小是间接定义的。'
- en: 'The following is an example of how tables can be constructed:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何构建表格的示例：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will notice in line 5 that `a["y"]` is indexing the value from line 3\.
    In line 7, `a[b]` uses a new value of variable `b` and indexes the value of 20
    to the string,`"Monday"`. The last line, `c` is different from the previous variables
    and its only value is the string,`"hello"`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在第5行注意到`a["y"]`是从第3行索引的值。在第7行，`a[b]`使用变量`b`的新值，并将20的值索引到字符串`"Monday"`。最后一行，`c`与前面的变量不同，它的唯一值是字符串`"hello"`。
- en: Passing a table as an array
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将表格作为数组传递
- en: Keys of a table can be consecutive integers, starting at 1\. They can be made
    into an array (or a list).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的键可以是连续的整数，从1开始。它们可以被转换成数组（或列表）。
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another way of writing table constructors to build arrays in a faster and convenient
    way that doesn''t require writing out each integer key is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写表格构造函数以更快、更方便地构建数组的方法，而不需要写出每个整数键，如下所示：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Altering contents in a table
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改表格内容
- en: While working with tables, you can modify or remove the values already in it,
    and also add new values to it. This can be accomplished using the assignment statement.
    The following example creates a table with three people and their favorite type
    of drink. You can make an assignment to change one person's drink, add a new person-drink
    pair to the table, and remove an existing person-drink pair.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当与表格一起工作时，你可以修改或删除其中的值，也可以向其中添加新的值。这可以通过赋值语句来完成。以下示例创建了一个包含三个人和他们的最喜欢的饮料类型的表格。你可以通过赋值来更改一个人的饮料，向表格中添加一个新的个人-饮料对，以及删除现有的个人-饮料对。
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`drinks.Jackie = "lemonade"` overwrites the original value of `drinks.Jackie
    = "milk"`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Jackie = "lemonade"`覆盖了`drinks.Jackie = "milk"`的原始值。'
- en: '`drinks.Anne = "water"` adds a new key and value to the table. The value of
    `drinks.Anne` before this line would have been `nil`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Anne = "water"`向表格中添加了一个新的键和值。在这行代码之前，`drinks.Anne`的值将是`nil`。'
- en: '`drinks.Matt = "soda"` stays the same since there were no alterations to it.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Matt = "soda"`保持不变，因为它没有进行任何修改。'
- en: '`drinks.Jim = nil` overwrites the original value of `drinks.Jim = "orange juice"`
    with `nil`. It removes the key `Jim` from the table.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Jim = nil`用`nil`覆盖了`drinks.Jim = "orange juice"`的原始值。它从表中移除了键`Jim`。'
- en: Populating a table
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充表
- en: Ways to populate a table is to start with an empty table and add things to it
    one at a time. We'll be using constructors, which are expressions that create
    and initialize tables. The simplest constructor is the empty constructor, `{}`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 填充表的方法是从一个空表开始，逐个添加内容。我们将使用构造函数，它们是创建和初始化表的表达式。最简单的构造函数是空构造函数，`{}`。
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the result from the terminal:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从终端得到的结果：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example shows that `myNumbers = {}` is an empty table constructor.
    A `for` loop is created and calls `myNumbers[i]` five times starting from the
    number 1\. Each time it is called, it is incremented by 1 and then printed out.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显示`myNumbers = {}`是一个空表构造函数。创建了一个`for`循环，并从数字1开始调用`myNumbers[i]`五次。每次调用时，它增加1，然后打印出来。
- en: Objects
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: Tables and functions are objects. Variables do not actually contain these values,
    only references to them. Tables are also used in what is known as **object-oriented
    programming**. Functions that deal with a particular type of value are part of
    that value. Such a value is called an **object** and its functions are called
    **methods**. In Corona, we'll be focusing more on display objects since they are
    essential for game development.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表和函数是对象。变量实际上并不包含这些值，只包含对它们的引用。表也用于所谓的**面向对象编程**。处理特定类型值的函数是该值的一部分。这样的值被称为**对象**，其函数被称为**方法**。在Corona中，我们将更多地关注显示对象，因为它们对于游戏开发至关重要。
- en: Display objects
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示对象
- en: Anything drawn to the screen is made by **display objects**. In Corona, the
    assets you see displayed in the simulator are instances of display objects. You
    have probably seen shapes, images, and text, which are all forms of display objects.
    When you create these objects, you'll be able to animate them, turn them into
    backgrounds, interact with them using touch events, and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 任何绘制到屏幕上的内容都是由**显示对象**创建的。在Corona中，您在模拟器中看到的显示的资产都是显示对象的实例。您可能已经看到了形状、图像和文本，这些都是显示对象的形式。当您创建这些对象时，您将能够使它们动画化，将它们变成背景，使用触摸事件与它们交互，等等。
- en: Display objects are created by calling a function known as a **factory function**.
    There is a specific kind of factory function for each type of display object.
    For example, `display.newCircle()` creates a vector object.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象是通过调用一个称为**工厂函数**的函数来创建的。每种显示对象都有一个特定的工厂函数。例如，`display.newCircle()`创建一个矢量对象。
- en: Instances of display objects behave similar to Lua tables. This enables you
    to add your own properties to an object as long as they do not conflict with the
    system assigned properties and method names.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象的实例的行为类似于Lua表。这使您可以在不与系统分配的属性和方法名称冲突的情况下向对象添加自己的属性。
- en: Display properties
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示属性
- en: 'The dot operator is used to access properties. Display objects share the following
    properties:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 点操作符用于访问属性。显示对象共享以下属性：
- en: '`object.alpha` is the object''s opacity. A value of `0` is transparent and
    `1.0` is opaque. The default value is `1.0.`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.alpha`是对象的透明度。值为`0`是透明的，`1.0`是不透明的。默认值是`1.0.`'
- en: '`object.height` is in local coordinates.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.height`在本地坐标系中。'
- en: '`object.isVisible` controls whether the object is visible on the screen. `true`
    is visible and `false` is not. The default is `true.`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.isVisible`控制对象是否在屏幕上可见。`true`表示可见，`false`表示不可见。默认值为`true.`'
- en: '`object.isHitTestable` allows an object to continue to receive hit events even
    if it is not visible. If `true`, objects will receive hit events regardless of
    visibility; if `false`, events are only sent to visible objects. Defaults to `false`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.isHitTestable`允许对象即使在不可见的情况下也能继续接收击中事件。如果`true`，对象将接收击中事件，无论其可见性如何；如果`false`，事件仅发送到可见对象。默认值为`false`。'
- en: '`object.parent` is a read-only property that returns the object''s parent.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.parent`是一个只读属性，它返回对象的父对象。'
- en: '`object.rotation` is the current rotation angle (in degrees). Can be a negative
    or positive number. Default is `0.`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.rotation`是当前旋转角度（以度为单位）。可以是负数或正数。默认值为`0.`'
- en: '`object.contentBounds` is a table with properties `xMin, xMax, yMin`, and `yMax`
    in screen coordinates. Generally used to map the object in a group to the screen
    coordinates.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.contentBounds` 是一个包含属性 `xMin, xMax, yMin` 和 `yMax` 的表格，这些属性在屏幕坐标系中。通常用于将组中的对象映射到屏幕坐标系。'
- en: '`object.contentHeight` is the height in screen coordinates.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.contentHeight` 是屏幕坐标系中的高度。'
- en: '`object.contentWidth` is the width in screen coordinates.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.contentWidth` 是屏幕坐标系中的宽度。'
- en: '`object.width` is in local coordinates.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.width` 表示对象在局部坐标系中的宽度。'
- en: '`object.x` specifies the x-position (in local coordinates) of the object relative
    to the parent—the parent''s origin to be precise. It provides the x-position of
    the object''s reference point relative to the parent. Changing the value will
    move the object in the x-direction.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.x` 指定了对象相对于父对象的 x 位置（在局部坐标系中）——更确切地说，是父对象的坐标原点。它提供了对象参考点相对于父对象的 x 位置。更改此值将在
    x 方向上移动对象。'
- en: '`object.xOrigin` specifies the x-position of the object''s origin relative
    to the parent''s origin. It is in the object''s local coordinates. Changing the
    value of this property will move the object in the x-direction.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.xOrigin` 指定了对象原点相对于父原点的 x 位置。它位于对象的局部坐标系中。更改此属性的值将在 x 方向上移动对象。'
- en: '`object.xReference` defines the x-position of the reference point relative
    to the object''s local origin. For most display objects, the value defaults to
    0, meaning the x-position of the origin and the reference point are the same.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.xReference` 定义了参考点相对于对象局部原点的 x 位置。对于大多数显示对象，默认值为 0，意味着原点和参考点的 x 位置相同。'
- en: '`object.xScale` gets or sets the X scaling factor. A value of 0.5 will scale
    the object to 50 percent in the X direction. The scaling occurs around the object''s
    reference point. The default reference point for most display objects is center.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.xScale` 获取或设置 X 缩放因子。值为 0.5 将对象在 X 方向上缩放至 50%。缩放是围绕对象的参考点进行的。大多数显示对象的默认参考点是中心。'
- en: '`object.y` specifies the y-position (in local coordinates) of the object relative
    to the parent—the parent''s origin to be precise.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.y` 指定了对象相对于父对象的 y 位置（在局部坐标系中）——更确切地说，是父对象的坐标原点。'
- en: '`object.yOrigin` specifies the y-position of the object''s origin relative
    to the parent''s origin. It is in the object''s local coordinates. Changing the
    value of this property will move the object in the y-direction.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.yOrigin` 指定了对象原点相对于父原点的 y 位置。它位于对象的局部坐标系中。更改此属性的值将在 y 方向上移动对象。'
- en: '`object.yReference` defines the y-position of the reference point relative
    to the object''s local origin. For most display objects, the value defaults to
    0, meaning the y-position of the origin and the reference point are the same.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.yReference` 定义了参考点相对于对象局部原点的 y 位置。对于大多数显示对象，默认值为 0，意味着原点和参考点的 y 位置相同。'
- en: '`object.yScale` gets or sets the Y scaling factor. A value of 0.5 will scale
    the object to 50 percent in the Y direction. The scaling occurs around the object''s
    reference point. The default reference point for most display objects is center.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.yScale` 获取或设置 Y 缩放因子。值为 0.5 将对象在 Y 方向上缩放至 50%。缩放是围绕对象的参考点进行的。大多数显示对象的默认参考点是中心。'
- en: Object methods
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象方法
- en: Corona can create display objects to store object methods as properties. There
    are two ways this can be done, the dot operator (.) and the colon operator (:).
    Both are valid ways to create object methods.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Corona 可以创建显示对象以将对象方法作为属性存储。这可以通过两种方式完成，点操作符（.）和冒号操作符（:）。两者都是创建对象方法的有效方式。
- en: 'The call to an object method using the dot operator is passed to the object
    if it''s the first argument:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点操作符调用对象方法时，如果它是第一个参数，则传递给对象：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The colon operator method is merely a shortcut with less typing involved to
    create the function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号操作符方法只是一个简写，涉及更少的输入来创建函数：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The display objects share the following methods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象共享以下方法：
- en: '`object:rotate( deltaAngle )` or `object.rotate( object, deltaAngle )`—Effectively
    adds `deltaAngle` (in degrees) to the current rotation property.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:rotate( deltaAngle )` 或 `object.rotate( object, deltaAngle )`——实际上是将
    `deltaAngle`（以度为单位）添加到当前的旋转属性。'
- en: '`object:scale( sx, sy )` or `object.scale(object, sx, sy )`—Effectively multiplies
    `xScale` and `yScale` properties by `sx` and `sy` respectively. If the current
    `xScale` and `yScale` values are 0.5 and `sx` and `sy` are also 0.5, the resulting
    scale will be 0.25 for `xScale` and `yScale`. This scales the object from 50 percent
    of its original size to 25 percent.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:scale( sx, sy )` 或 `object.scale(object, sx, sy )` — 分别将 `xScale` 和
    `yScale` 属性乘以 `sx` 和 `sy`。如果当前的 `xScale` 和 `yScale` 值是 0.5，而 `sx` 和 `sy` 也是 0.5，则结果缩放将是
    `xScale` 和 `yScale` 的 0.25。这将对象从原始大小的 50% 缩放到 25%。'
- en: '`object:setReferencePoint( referencePoint )` or `object.setReferencePoint(
    object, referencePoint )`—Sets the reference point either to the center of the
    object (default) or to one of several convenient points along the bounding box
    of the object. The argument `referencePoint` should be one of the following:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setReferencePoint( referencePoint )` 或 `object.setReferencePoint( object,
    referencePoint )` — 将参考点设置为对象的中心（默认）或对象边界框上的几个方便点之一。参数 `referencePoint` 应该是以下之一：'
- en: '`display.CenterReferencePoint`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.CenterReferencePoint`'
- en: '`display.TopLeftReferencePoint`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.TopLeftReferencePoint`'
- en: '`display.TopCenterReferencePoint`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.TopCenterReferencePoint`'
- en: '`display.TopRightReferencePoint`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.TopRightReferencePoint`'
- en: '`display.CenterRightReferencePoint`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.CenterRightReferencePoint`'
- en: '`display.BottomRightReferencePoint`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.BottomRightReferencePoint`'
- en: '`display.BottomCenterReferencePoint`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.BottomCenterReferencePoint`'
- en: '`display.BottomLeftReferencePoint`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.BottomLeftReferencePoint`'
- en: '`display.CenterLeftReferencePoint`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.CenterLeftReferencePoint`'
- en: '`object:translate( deltaX, deltaY )` or `object.translate( object, deltaX,
    deltaY )`—Effectively adds `deltaX` and `deltaY` to the `x` and `y` properties
    respectively. This will move the object from its current position.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:translate( deltaX, deltaY )` 或 `object.translate( object, deltaX, deltaY
    )` — 分别将 `deltaX` 和 `deltaY` 添加到 `x` 和 `y` 属性。这将移动对象到其当前位置。'
- en: '`object:removeSelf( )` or `object.removeSelf( object )`—Removes the display
    object and frees its memory, assuming there are no other references to it. This
    is equivalent to calling `group:remove(IndexOrChild)` on the same display object,
    but is syntactically simpler. The `removeSelf()` syntax is also supported in other
    cases such as removing physics'' joints in Physics.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:removeSelf( )` 或 `object.removeSelf( object )` — 删除显示对象并释放其内存，假设没有其他引用。这相当于在同一个显示对象上调用
    `group:remove(IndexOrChild)`，但语法更简单。`removeSelf()` 语法也支持其他情况，例如在物理中删除物理关节。'
- en: Images
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片
- en: Many art assets used in Corona applications are sets of images. You will notice
    that bitmap image objects are types of display objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Corona 应用程序中使用的许多艺术资源都是图像集。您会注意到位图图像对象是显示对象的一种类型。
- en: Loading an image
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载图片
- en: By using `display.newImage( filename [, baseDirectory] [, left, top] )`, an
    image object is returned. The image data is loaded from a filename you specified
    to your image and looks in the `system.ResourceDirectory` for that file. The acceptable
    types of image files that are supported are `.png` (PNG-24 or higher only) and
    `.jpg` files. Avoid high `.jpg` compression as it may take longer to load on a
    device. `.png` files have better quality over `.jpg` files and are used to display
    transparent images. `.jpg` files do not save transparent images.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `display.newImage( filename [, baseDirectory] [, left, top] )`，将返回一个图像对象。图像数据从您指定的文件名加载到图像中，并查找
    `system.ResourceDirectory` 中的该文件。支持的图像文件类型是 `.png`（仅 PNG-24 或更高版本）和 `.jpg` 文件。避免使用高
    `.jpg` 压缩，因为它可能在设备上加载时间更长。`.png` 文件比 `.jpg` 文件质量更好，并用于显示透明图像。`.jpg` 文件不保存透明图像。
- en: Image autoscaling
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片自动缩放
- en: The default behavior of `display.newImage()` is to autoscale large images. This
    is to conserve texture memory. However, there are times when you do not want to
    have images autoscaled and there is an optional Boolean flag in the parameter
    list to control this manually.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`display.newImage()` 函数的默认行为是自动缩放大型图片。这是为了节省纹理内存。然而，有时您可能不希望图片自动缩放，参数列表中有一个可选的布尔标志可以手动控制这一点。'
- en: 'To override autoscaling and show the image at its full resolution, use the
    optional `isFullResolution` parameter. By default, it is `false`, but if you specify
    `true`, then the new image is loaded at its full resolution:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖自动缩放并以全分辨率显示图片，请使用可选的 `isFullResolution` 参数。默认情况下，它是 `false`，但如果您指定 `true`，则新图像将以全分辨率加载：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following are the limitations and known issues:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些限制和已知问题：
- en: Indexed PNG image files are not supported.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引 PNG 图像文件不受支持。
- en: Grayscale images are currently not supported; images must be RGB.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前不支持灰度图像；图像必须是 RGB。
- en: Images will still be autoscaled if they are larger than the maximum possible
    texture dimensions of the device. This is usually 1024x1024 (iPhone 3G) or 2048x2048
    (iPhone 3GS and iPad).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图像的大小大于设备的最大纹理尺寸，则图像仍会自动缩放。这通常为 1024x1024（iPhone 3G）或 2048x2048（iPhone 3GS
    和 iPad）。
- en: If you reload the same image multiple times, the subsequent calls to `display.newImage`
    ignores the `isFullResolution` parameter and takes on the value passed the first
    time. In other words, the way you load an image file the first time affects the
    autoscaling setting the next time you load that same file. This is because Corona
    conserves texture memory by automatically re-using a texture that has already
    been loaded. As a result, you can use the same images as many times as you want
    without consuming additional texture memory.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你多次重新加载同一张图片，后续对 `display.newImage` 的调用将忽略 `isFullResolution` 参数，并采用第一次传递的值。换句话说，你第一次加载图像文件的方式会影响下一次加载同一文件时的自动缩放设置。这是因为
    Corona 通过自动重用已加载的纹理来节省纹理内存。因此，你可以多次使用相同的图像而不会消耗额外的纹理内存。
- en: 'More information on Corona SDK''s documentation is located on Ansca''s website:
    [http://www.anscamobile.com](http://www.anscamobile.com).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Corona SDK 文档的更多信息可以在 Ansca 的网站上找到：[http://www.anscamobile.com](http://www.anscamobile.com)。
- en: Time for action—placing images on screen
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动时间——在屏幕上放置图像
- en: We're finally getting into the visually appealing part of this chapter by starting
    to add in display objects using images. We don't have to refer to the terminal
    window for now. So let's focus on the simulator screen. We'll begin by creating
    a background image and some art assets.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于开始添加图像显示对象，使本章的视觉效果变得吸引人。现在我们不需要参考终端窗口。所以让我们专注于模拟器屏幕。我们将首先创建一个背景图像和一些艺术资源。
- en: First off, create a new project folder to your desktop and name it `Display
    Objects`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的桌面上创建一个新的项目文件夹，并将其命名为 `Display Objects`。
- en: In the `Chapter 2 Resources` folder, copy the `glassbg.png` and `moon.png` image
    files into your `Display Objects` project folder. You can download the project
    files accompanying this book from the Packt website.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter 2 Resources` 文件夹中，将 `glassbg.png` 和 `moon.png` 图像文件复制到你的 `Display
    Objects` 项目文件夹中。你可以从 Packt 网站下载本书附带的项目文件。
- en: Launch your text editor and create a new `main.lua` file for your current project.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的文本编辑器，为你的当前项目创建一个新的 `main.lua` 文件。
- en: 'Write out the following lines of code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出以下代码行：
- en: '[PRE38]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The display object for your background variable should contain the filename
    of the background image in your project folder. For example, if the background
    image filename is called `glassbg.png`, then you would display the image as follows:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的背景变量显示对象应包含项目文件夹中背景图像的文件名。例如，如果背景图像的文件名是 `glassbg.png`，则你会按以下方式显示图像：
- en: '[PRE39]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using `image02.x = 160; image02.y = 200` is the same as follows:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `image02.x = 160; image02.y = 200` 与以下方式相同：
- en: '[PRE40]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The semicolon (;) indicates the end of a statement and is optional. It makes
    it easier to separate two or more statements in one line and saves adding extra
    lines to your code.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分号 (;) 表示语句的结束，是可选的。它使得在一行中分隔两个或多个语句变得更容易，并且可以节省在代码中添加额外行的时间。
- en: Save your script and launch your project in the simulator.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并在模拟器中启动你的项目。
- en: Note
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're using Corona SDK on a Mac OSX, the default device is the iPhone. If
    you're using Windows, the default device is the Droid.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Mac OSX 上的 Corona SDK，默认设备是 iPhone。如果你使用的是 Windows，默认设备是 Droid。
- en: You should see a background image and three other display objects that are the
    same as the image shown in as shown in the following screenshot. The display results
    will vary depending on which device you use to simulate.![Time for action—placing
    images on screen](img/1888_02_01.jpg)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到一个背景图像和三个其他与以下截图所示的图像相同的显示对象。显示结果将取决于你用于模拟的设备。![开始行动时间——在屏幕上放置图像](img/1888_02_01.jpg)
- en: The display objects for variables `image01, image02`, and `image03` should contain
    the `moon.png` filename. The filenames in your code are case-sensitive, so make
    sure that you write it exactly how it displays in your project folder.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `image01, image02` 和 `image03` 的显示对象应包含 `moon.png` 文件名。你代码中的文件名是区分大小写的，所以请确保你按照在项目文件夹中显示的格式准确书写。
- en: What just happened?
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Currently, `background` is set to full resolution because we specified `true`
    in the display object. We also have the image centered about its local origin
    since no `top` or `left` coordinates were applied.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`background`设置为全分辨率，因为我们已在显示对象中指定了`true`。我们还使图像围绕其局部原点居中，因为没有应用`top`或`left`坐标。
- en: When you observe the placement of `image01, image02`, and `image03` in the simulator,
    they're practically in line with each other vertically, though the script style
    for `image01` versus `image02/image03` are written differently. This is because
    the coordinates for `image01` are based on `(left, top)` of the display object.
    You can optionally specify that the image's top-left corner be located at the
    coordinate `(left, top)`; if you don't supply both coordinates, the image will
    be centered about its local origin.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器中观察`image01, image02`和`image03`的放置时，它们在垂直方向上实际上是对齐的，尽管`image01`与`image02/image03`的脚本风格书写不同。这是因为`image01`的坐标是基于显示对象的`(left,
    top)`。你可以选择指定图像的左上角位于坐标`(left, top)`；如果你不提供两个坐标，图像将围绕其局部原点居中。
- en: Placement for `image02` and `image03` are specified from their local origin
    of the display object and positioned by local values of x and y properties of
    the device screen. The local origin is at the center of the image; the reference
    point is initialized at this point. Since we didn't apply `(left, top)` values
    to `image02` and `image03`, further access to x or y properties are referred to
    the center of the image.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`image02`和`image03`的放置是从显示对象的局部原点指定的，并通过设备屏幕x和y属性的局部值定位。局部原点是图像的中心；参考点初始化于此点。由于我们没有对`image02`和`image03`应用`(left,
    top)`值，因此进一步访问x或y属性将参照图像的中心。'
- en: Now, you've probably noticed that the output from the iPhone 3G looks fine and
    dandy, but the output from the Droid shows that the display objects are not centered
    and the background image doesn't even fill the entire screen. We see that all
    the objects we specified are there but the scaling is off. That is because each
    iOS and Android device has different screen resolutions. The iPhone 3G has a screen
    resolution of 320 x 480 pixels and the Droid has a screen resolution of 480 x
    854 pixels. What may look fine on one type of device may not look exactly the
    same on a different one. Don't worry, there is a simple solution to fix all that
    by using a `config.lua` file that we will discuss in the next couple of sections.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到iPhone 3G的输出看起来很好，但Droid的输出显示显示对象没有居中，背景图像甚至没有填满整个屏幕。我们看到我们指定的所有对象都在那里，但缩放不正确。这是因为每个iOS和Android设备的屏幕分辨率都不同。iPhone
    3G的屏幕分辨率为320 x 480像素，Droid的屏幕分辨率为480 x 854像素。在一种类型的设备上看起来很好的内容，在另一种设备上可能不会完全相同。不用担心，我们可以通过使用将在下一节讨论的`config.lua`文件来简单地解决这个问题。
- en: Have a go hero—adjusting display object properties
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的操作——调整显示对象属性
- en: 'Now that you know how to add images onto the device screen, try testing out
    the other display properties. Try doing any of the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何将图像添加到设备屏幕上，尝试测试其他显示属性。尝试以下任何一项：
- en: Change all the x and y coordinates of `image01, image02`, and `image03` display
    objects
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`image01, image02`和`image03`显示对象的所有x和y坐标
- en: Choose any display object and change its rotation
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择任何显示对象并更改其旋转
- en: Change the visibility of a single display object
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改单个显示对象的可见性
- en: Refer to the display properties mentioned earlier in this chapter in case you're
    unsure how to do any of the preceding adjustments.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对如何进行前面的调整不确定，请参考本章前面提到的显示属性。
- en: Runtime configuration
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时配置
- en: All project files not only contain a `main.lua` file but other `.lua` and related
    assets as needed for your project. Some Corona projects are configured using a
    `config.lua` file that is compiled into your project and accessed at runtime.
    This allows you to specify dynamic content scaling, dynamic content alignment,
    dynamic image resolution, frame rate control, and anti-aliasing all at the same
    time so that the output on every type of device is displayed similarly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所有项目文件不仅包含一个`main.lua`文件，还包括根据项目需要的其他`.lua`和相关资源。一些Corona项目使用`config.lua`文件进行配置，该文件编译到项目中并在运行时访问。这允许你同时指定动态内容缩放、动态内容对齐、动态图像分辨率、帧率控制和抗锯齿，以便在每种类型的设备上显示的输出相似。
- en: Dynamic content scaling
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内容缩放
- en: You can specify to Corona what the original screen size for your content is.
    Then allow it to scale your app to run on a device that has a different screen
    size to the original.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定 Corona 您的内容的原始屏幕大小。然后允许它缩放您的应用程序以在具有与原始屏幕大小不同的设备上运行。
- en: 'The following values should be used to scale content:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用以下值来缩放内容：
- en: '`width` (number)—Screen resolution width of the original target device (in
    portrait orientation)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width` (数字)—原始目标设备的屏幕分辨率宽度（在纵向方向）'
- en: '`height` (number)—Screen resolution height of the original target device (in
    portrait orientation)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`（数字）—原始目标设备的屏幕分辨率高度（在纵向方向）'
- en: '`scale` (string)—Type of autoscaling from the following:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`（字符串）—以下自动缩放类型之一：'
- en: '`none`—Dynamic content scaling turned off'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`—关闭动态内容缩放'
- en: '`letterbox`—Uniformly scales up content as much as possible'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`letterbox`—尽可能均匀地放大内容'
- en: '`zoomEven`—Scales up content uniformly to fill the screen, while keeping the
    aspect ratio'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoomEven`—均匀放大内容以填充屏幕，同时保持宽高比'
- en: '`zoomStretch`—Scales up content non-uniformly to fill the screen and will stretch
    it vertically or horizontally'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoomStretch`—非均匀地放大内容以填充屏幕，并可能垂直或水平拉伸'
- en: Note
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`zoomStretch` works well with Android device scaling since many of them have
    different screen resolutions.'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`zoomStretch` 与 Android 设备缩放配合良好，因为许多设备具有不同的屏幕分辨率。'
- en: Dynamic content alignment
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内容对齐
- en: Content that is dynamically scaled is already centered by default. You may find
    cases where you don't want the content to be centered. Devices such as the iPhone
    3G and the Droid have completely different screen resolutions. In order for the
    content displayed on the Droid to match the iPhone 3G, the alignment needs to
    be adjusted so the content fills the entire screen without leaving any empty black
    screen space.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 动态缩放的内容默认情况下已经居中。您可能会遇到不需要内容居中的情况。例如，iPhone 3G 和 Droid 这样的设备具有完全不同的屏幕分辨率。为了使
    Droid 上显示的内容与 iPhone 3G 匹配，需要对齐进行调整，以便内容填充整个屏幕，不留任何空白的黑色屏幕空间。
- en: '`xAlign:` A string that specifies the alignment in the x-direction. The following
    values can be used:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`xAlign:` 一个指定 x 方向对齐的字符串。以下值可以使用：'
- en: '`left`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: '`center` (Default)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`（默认）'
- en: '`right`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: '`yAlign:` A string that specifies the alignment in the y-direction. The following
    values can be used:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`yAlign:` 一个指定 y 方向对齐的字符串。以下值可以使用：'
- en: '`top`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`center` (Default)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`（默认）'
- en: '`bottom`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: Dynamic image resolution
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态图像分辨率
- en: Corona allows you to swap in higher-resolution versions of your images to higher-resolution
    devices, without having to change your layout code. This is a case to consider
    if building for multiple devices with different screen resolutions.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Corona 允许您在不更改布局代码的情况下，将更高分辨率的图像版本交换到更高分辨率的设备上。如果您正在为具有不同屏幕分辨率的多个设备构建，这是一个需要考虑的案例。
- en: An example where you want to display high-resolution images is on an iPhone
    4 where the resolution is 640 x 960 pixels. It is double the resolution of the
    earlier iOS devices such as the iPod Touch 2G or the iPhone 3GS which both are
    320 x 480 pixels. Scaling up the content from the iPhone 3GS to fit the iPhone
    4 screen works, but the images will not be as crisp and will look a little fuzzy
    on the device.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要显示高分辨率图像的例子中，比如在分辨率为 640 x 960 像素的 iPhone 4 上。这个分辨率是早期 iOS 设备（如 iPod Touch
    2G 或 iPhone 3GS）的两倍，这些设备的分辨率都是 320 x 480 像素。将 iPhone 3GS 的内容放大以适应 iPhone 4 的屏幕是可行的，但图像将不会那么清晰，设备上看起来会有些模糊。
- en: Images of higher resolution can be swapped in for the iPhone 4 by adding a `@2x`
    suffix to the end of filenames. For example, if your image filename is `myImage.png`
    then your higher resolution filename should be `myImage@2x.png`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在文件名末尾添加 `@2x` 后缀，可以为 iPhone 4 交换更高分辨率的图像。例如，如果您的图像文件名为 `myImage.png`，则更高分辨率的文件名应该是
    `myImage@2x.png`。
- en: 'In your `config.lua` file, a table named `imageSuffix` needs to be added for
    the image naming convention and image resolutions to take effect. The `config.lua`
    file resides in your project folder where all your other `.lua` files and image
    files are stored. Look at the following example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `config.lua` 文件中，需要添加一个名为 `imageSuffix` 的表来使图像命名约定和图像分辨率生效。`config.lua`
    文件位于您的项目文件夹中，其中包含您所有的其他 `.lua` 文件和图像文件。请参考以下示例：
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When calling your display objects, use `display.newImageRect( [parentGroup,]
    filename [, baseDirectory] w, h )` instead of `display.newImage()`. The target
    height and width need to be set to the dimensions of your base image.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用您的显示对象时，请使用 `display.newImageRect( [parentGroup,] filename [, baseDirectory]
    w, h )` 而不是 `display.newImage()`。目标高度和宽度需要设置为您的基图尺寸。
- en: Frame rate control and anti-aliasing
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率控制和抗锯齿
- en: The frame rate is 30 fps (frames per second) by default. FPS refers to the speed
    at which the image is refreshed in games. 30 fps is the standard in mobile games,
    especially for older devices. You can set it to 60 fps when you add in the fps
    key. Using 60 fps makes your app run smoother. You can easily detect a life-like
    fluidity in the motion when it comes to running animations or collision detections.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 默认帧率为30 fps（每秒帧数）。FPS指的是图像在游戏中刷新的速度。30 fps是移动游戏的标准，尤其是对于旧设备。当添加fps键时，您可以将其设置为60
    fps。使用60 fps可以使您的应用程序运行得更平滑。当涉及到运行动画或碰撞检测时，您可以在运动中轻松检测到逼真的流畅性。
- en: Corona uses software anti-aliasing for vector objects. By default, it is turned
    off to improve the performance of the vector objects. You can turn it on by setting
    the `antialias` key to `true`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Corona为矢量对象使用软件抗锯齿。默认情况下，它是关闭的，以提高矢量对象的表现性能。您可以通过将 `antialias` 键设置为 `true` 来开启它。
- en: 'See the following example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE42]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Time for action—scaling display objects on multiple devices
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间——在多个设备上缩放显示对象
- en: In our `Display Objects` project, we left off displaying a background image
    and three similar display objects in the simulator. When running the project on
    different devices, the coordinates and resolution size were most compatible with
    the iPhone only. When building applications for multiple devices across iOS and
    Android platforms, we can configure it using a `config.lua` file that is compiled
    into the project and accessed at runtime. So let's get to it!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Display Objects` 项目中，我们在模拟器中省略了显示背景图像和三个类似的显示对象。当在不同的设备上运行项目时，坐标和分辨率大小与iPhone最为兼容。当在iOS和Android平台的多设备上构建应用程序时，我们可以使用一个编译到项目中并在运行时访问的
    `config.lua` 文件来配置它。所以，让我们开始吧！
- en: 'In your text editor, create a new file and write out the following lines:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的文本编辑器中，创建一个新文件并写下以下行：
- en: '[PRE43]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save your script as `config.lua` in your `Display Objects` project folder.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的脚本保存为 `config.lua` 到您的 `Display Objects` 项目文件夹中。
- en: Mac users, launch your application in Corona under the iPhone device. Once you
    have done so, under the **Corona Simulator** menu bar, select **Window** | **View
    As** | **iPhone 4**. You will notice that the display objects fit perfectly on
    the screen and that there are no empty black spaces showing either.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mac用户，在Corona中模拟iPhone设备运行您的应用程序。一旦完成，在 **Corona Simulator** 菜单栏中，选择 **Window**
    | **View As** | **iPhone 4**。您会注意到显示对象完美地适应屏幕，并且没有显示任何空白的黑色区域。
- en: 'Windows users, launch your application in Corona under the Droid device. You
    will notice that all the content is scaled and aligned properly. Under the **Corona
    Simulator** menu bar, select **Window** | **View As** | **NexusOne**. Observe
    the similarities of content placement to that of the Droid. From left to right:
    iPhone 3G, iPhone 4, Droid, and NexusOne.![Time for action—scaling display objects
    on multiple devices](img/1888_02_02.jpg)'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows用户，在Corona中模拟Droid设备运行您的应用程序。您会注意到所有内容都进行了适当的缩放和对齐。在 **Corona Simulator**
    菜单栏中，选择 **Window** | **View As** | **NexusOne**。观察内容放置与Droid的相似性。从左到右：iPhone 3G、iPhone
    4、Droid和NexusOne。![操作时间——在多个设备上缩放显示对象](img/1888_02_02.jpg)
- en: What just happened?
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have now learned a way to implement easy configuration to display our content
    across a variety of devices on iOS and Android. Content scaling features are useful
    for multiscreen development. If you look at the `config.lua` file we created,
    the content `width = 320` and `height = 480`. This is the resolution size that
    the content is originally authored for. In this case, it is the iPhone 3G. Since
    we used `scale = "letterbox"`, it enabled the content to uniformly scale up as
    much as possible, while still showing all content on the screen.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了一种方法，可以在iOS和Android的多种设备上轻松配置显示我们的内容。内容缩放功能对多屏开发很有用。如果您查看我们创建的 `config.lua`
    文件，内容 `width = 320` 和 `height = 480`。这是内容最初编写的分辨率大小。在这种情况下，是iPhone 3G。由于我们使用了
    `scale = "letterbox"`，它使得内容尽可能均匀地缩放，同时仍然在屏幕上显示所有内容。
- en: We also set `xAlign = "left"` and `yAlign = "top"`. This fills in the empty
    black screen space that shows on the Droid specifically. The content scaling is
    in the center by default so by aligning the content to the left and top of the
    screen the additional screen space will be taken away.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了`xAlign = "left"`和`yAlign = "top"`。这填充了在 Droid 上显示的空白黑色屏幕空间。内容缩放默认在中心，因此通过将内容对齐到屏幕的左上角，将移除额外的屏幕空间。
- en: Dynamic resolution images
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分辨率图像
- en: Earlier, we touched base with dynamic image resolution. iOS devices are a perfect
    example in this case. Corona has the capability to use base images (for devices
    on the 3GS and lower) and double-resolution images (for the iPhone 4 that has
    **retina display)** all within the same project file. Any of your double-resolution
    images can be swapped to your high-end iOS device without having to alter your
    code. This will allow your build to coincide with older devices and let you handle
    more complex multiscreen deployment cases. You will notice that dynamic image
    resolution works in conjunction with dynamic content scaling.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到了动态图像分辨率。iOS 设备是这种情况下的一个完美例子。Corona 具有使用基础图像（用于3GS及以下设备）和双倍分辨率图像（用于具有**视网膜显示屏**的iPhone
    4）的能力，所有这些都在同一个项目文件中。您可以将任何双倍分辨率图像交换到高端 iOS 设备，而无需更改您的代码。这将使您的构建与旧设备保持一致，并让您处理更复杂的多屏幕部署情况。您会注意到动态图像分辨率与动态内容缩放协同工作。
- en: Using the line `display.newImageRect( [parentGroup,] filename [, baseDirectory]
    w, h )` will call out your dynamic resolution images.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下行`display.newImageRect( [parentGroup,] filename [, baseDirectory] w, h )`将调用您的动态分辨率图像。
- en: '`w` refers to the content *width* of the image and `h` refers to the content
    *height* of the image.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`代表图像的内容**宽度**，而`h`代表图像的内容**高度**。'
- en: 'For example:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Remember that the two values represent the base image size, *not* the onscreen
    position of the image. You must define the base size in your code so that Corona
    knows how to render the higher-resolution alternative images. The contents of
    your project folder will be set up similarly as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这两个值代表基础图像大小，**不是**图像在屏幕上的位置。您必须在代码中定义基础大小，以便 Corona 知道如何渲染更高分辨率的替代图像。您的项目文件夹内容将设置如下：
- en: '[PRE45]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When creating your double resolution image, make sure that it is twice the size
    of the base image. It's best when creating your display assets that you start
    with the double resolution image. Corona lets you select your own image naming
    patterns. The `@2x` convention is one example that can be used but you have the
    option of naming suffixes to your personal preference. For now, we'll use the
    `@2x` suffix since it distinguishes the double resolution reference. When you
    create your double resolution image, name it with the `@2x` suffix included. Take
    the same image and resize it to 50 percent of the original size and then use the
    same filename without the `@2x` included.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的双倍分辨率图像时，请确保其大小是基础图像的两倍。在创建显示资源时，最好从双倍分辨率图像开始。Corona 允许您选择自己的图像命名模式。`@2x`约定是一个可以使用的示例，但您可以根据个人喜好选择命名后缀。目前，我们将使用`@2x`后缀，因为它可以区分双倍分辨率参考。当您创建双倍分辨率图像时，请包含`@2x`后缀对其进行命名。将相同的图像调整到原始大小的50%，然后使用不带`@2x`的相同文件名。
- en: 'Other examples on naming suffixes can be:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 命名后缀的其他示例可以是：
- en: '`@2`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@2`'
- en: '`-2`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-2`'
- en: '`-two`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-two`'
- en: 'As mentioned earlier in the chapter, you have to define your image suffix for
    your double-resolution images in the `imageSuffix` table in your `config.lua`
    file. The content scale you set will allow Corona to determine the ratio between
    the current screen and base content dimensions. The following example uses the
    suffix `@2x` to define double-resolution images:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，您必须在`config.lua`文件中的`imageSuffix`表中定义您的双倍分辨率图像的后缀。您设置的内容缩放将允许 Corona
    确定当前屏幕与基础内容尺寸之间的比例。以下示例使用后缀`@2x`来定义双倍分辨率图像：
- en: '[PRE46]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Time for some shapes
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候来一些形状了
- en: 'Another way of creating display objects is using **vector objects**. You can
    use vector objects to create shapes, such as a rectangle, rounded rectangle, and
    circle by using the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 创建显示对象的另一种方法是使用**矢量对象**。您可以使用矢量对象创建形状，例如矩形、圆角矩形和圆形，方法如下：
- en: '`display.newRect( [parentGroup,] left, top, width, height )` creates a rectangle
    using `width` by `height`. Location starts from the top-left corner of the device
    screen using `left` and `top` as your coordinates of placement.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newRect( [parentGroup,] left, top, width, height )`使用`width`乘以`height`创建一个矩形。位置从设备屏幕的左上角开始，使用`left`和`top`作为您的放置坐标。'
- en: '`display.newRoundedRect( [parentGroup,] left, top, width, height, cornerRadius
    )` creates a rounded rectangle using `width` by `height`. Location starts from
    the top-left corner of the device screen using `left` and `top` as your coordinates
    of placement. Rounding off the corners uses `cornerRadius.`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newRoundedRect( [parentGroup,] left, top, width, height, cornerRadius
    )`使用`width`乘以`height`创建一个圆角矩形。位置从设备屏幕的左上角开始，使用`left`和`top`作为您的放置坐标。通过`cornerRadius`进行圆角处理。'
- en: '`display.newCircle( [parentGroup,] xCenter, yCenter, radius )` creates a circle
    using `radius` centered at `xCenter, yCenter`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newCircle( [parentGroup,] xCenter, yCenter, radius )`使用`radius`创建一个以`xCenter,
    yCenter`为中心的圆。'
- en: Applying stroke width, fill color, and stroke color
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用笔触宽度、填充颜色和笔触颜色
- en: All vector objects can be outlined using strokes. You can set the stroke width,
    fill color and stroke color.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 所有矢量对象都可以使用笔触进行轮廓绘制。您可以设置笔触宽度、填充颜色和笔触颜色。
- en: '`object.strokeWidth`—Creates the stroke width in pixels.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.strokeWidth`—以像素为单位创建笔触宽度。'
- en: '`object:setFillColor( r, g, b [, a] )`—Using the `r,g,b` codes between 0 and
    255\. `a` refers to the **alpha**, which is optional and defaulted at 255.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setFillColor( r, g, b [, a] )`—使用介于0到255之间的`r,g,b`代码。`a`表示**透明度**，是可选的，默认为255。'
- en: '`object:setStrokeColor( r, g, b [, a] )`—Using the `r,g,b` codes between 0
    and 255\. `a` refers to the alpha, which is optional and defaulted at 255.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setStrokeColor( r, g, b [, a] )`—使用介于0到255之间的`r,g,b`代码。`a`表示透明度，是可选的，默认为255。'
- en: 'The following is an example of displaying vector objects using strokes:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用笔触显示矢量对象的示例：
- en: '[PRE47]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Applying stroke width, fill color, and stroke color](img/1888_02_03.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![应用笔触宽度、填充颜色和笔触颜色](img/1888_02_03.jpg)'
- en: Text, text, text
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本，文本，文本
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started With Corona SDK"), *Getting
    Started With Corona SDK*, we created the Hello World application using a text
    display object. Let's go in detail on how text is implemented onscreen.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Corona SDK入门")，*使用Corona SDK入门*中，我们使用文本显示对象创建了Hello
    World应用程序。让我们详细了解一下如何在屏幕上实现文本。
- en: '`display.newText( [parentGroup,] string, x, y, font, size )` creates a text
    object using `x` and `y` values. There is no text color by default. In the `font`
    parameter, apply any of the font names in the library. The `size` parameter displays
    the size of the text. Some of the default constants can be used if you don''t
    want to apply a font name:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`display.newText( [parentGroup,] string, x, y, font, size )`使用`x`和`y`值创建一个文本对象。默认情况下没有文本颜色。在`font`参数中，应用库中的任何字体名称。`size`参数显示文本的大小。如果您不想应用字体名称，可以使用一些默认常量：'
- en: '`native.systemFont`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native.systemFont`'
- en: '`native.systemFontBold`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native.systemFontBold`'
- en: Applying color and string value
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用颜色和字符串值
- en: The size, color, and text fields can be set or retrieved in text display objects.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 文本显示对象中的大小、颜色和文本字段可以设置或检索。
- en: '`object.size`—The size of the text'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.size`—文本的大小'
- en: '`object:setTextColor( r, g, b [, a] )`—Using the `r,g,b` codes between 0 and
    255\. `a` refers to the alpha, which is optional and defaulted at 255'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setTextColor( r, g, b [, a] )`—使用介于0到255之间的`r,g,b`代码。`a`表示透明度，是可选的，默认为255'
- en: '`object.text`—Contains the text of the textfield. It allows you to update a
    string value for a test object'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.text`—包含文本字段的文本。它允许您更新测试对象的字符串值'
- en: Functions
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数可以执行一个过程或计算并返回值。我们可以将函数调用作为一个语句，或者我们可以将其用作表达式。我们已经了解到函数可以是变量。一个表可以使用这些变量将它们作为属性存储。
- en: Functions can carry out a procedure or compute and return values. We can make
    a function call as a statement or we can use it as an expression. We have learned
    that functions can be variables. A table can use those variables to store them
    as properties.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以执行一个过程或计算并返回值。我们可以将函数调用作为一个语句，或者我们可以将其用作表达式。我们已经了解到函数可以是变量。一个表可以使用这些变量将它们作为属性存储。
- en: 'Functions are the most important means of abstraction in Lua. One function
    that we have used many times is: `print`. In the following example, the `print`
    function is being told to execute one piece of data—the string,`"My favorite number
    is 8":`'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是Lua中最重要的抽象手段。我们使用过很多次的函数之一是：`print`。在以下示例中，`print`函数被指示执行一个数据片段——字符串`"My
    favorite number is 8"`：
- en: '[PRE48]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Another way of saying this is that `print` is being called with one argument.
    `print` is only one of the many built-in functions that Lua has, but almost any
    program you write will involve you defining your own functions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，`print` 函数被调用时带有一个参数。`print` 是 Lua 所拥有的许多内置函数之一，但您编写的几乎任何程序都将涉及您定义自己的函数。
- en: Defining a function
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'When trying to define a function, you have to give it a name that you can call
    out to when you want to return a value. You then have to create a statement of
    what the value will output and then apply `end` to your function after you have
    finished defining it. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试定义一个函数时，您必须给它一个名称，这样当您想要返回一个值时可以调用它。然后您必须创建一个关于该值将输出的声明，并在完成定义后应用 `end` 到您的函数上。例如：
- en: '[PRE49]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that the function name is `myName` and is used to call out what's inside
    the function definition `print("My name is Jane.")`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数名为 `myName`，并用于调用函数定义 `print("My name is Jane.")` 内部的内容。
- en: 'An alternative to defining a function is as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数的另一种方法是：
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The new `myName` function has one argument using the variable `Name`. The string,`"My
    name is "` is concatenated with `Name` and then a period as the printed result.
    When the function is called, we used three different names as an argument and
    the result is printed with a new customized name for each line.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `myName` 函数使用变量 `Name` 作为参数。字符串 `"My name is "` 与 `Name` 连接，然后加上一个句号作为打印结果。当函数被调用时，我们使用了三个不同的名称作为参数，并且每个行都打印了一个新的自定义名称。
- en: More display functions
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多显示功能
- en: In Corona, you can change the appearance of the status bar on your device. This
    is a one-line setting in your code that takes effect once you launch your application.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Corona 中，您可以更改设备上状态栏的外观。这是您代码中的一行设置，一旦启动应用程序就会生效。
- en: '`display.setStatusBar( mode )`—Hides or changes the appearance of the status
    bar on iOS devices (iPad, iPhone, and iPod Touch) and Android 2.x devices. Android
    3.x devices are not supported.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`display.setStatusBar(mode)`——在 iOS 设备（iPad、iPhone 和 iPod Touch）和 Android 2.x
    设备上隐藏或更改状态栏的外观。Android 3.x 设备不受支持。'
- en: 'The argument mode should be one of the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `mode` 应该是以下之一：
- en: '`display.HiddenStatusBar:` To hide the status bar, you can use the following
    line at the beginning of your code:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.HiddenStatusBar:` 要隐藏状态栏，您可以在代码开头使用以下行：'
- en: '[PRE51]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![More display functions](img/1888_02_04.jpg)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/1888_02_04.jpg)'
- en: '`display.DefaultStatusBar:` To show the default status bar, you can use the
    following line at the beginning of your code:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.DefaultStatusBar:` 要显示默认状态栏，您可以在代码开头使用以下行：'
- en: '[PRE52]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![More display functions](img/1888_02_05.jpg)'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/1888_02_05.jpg)'
- en: '`display.TranslucentStatusBar:` To show the translucent status bar, you can
    use the following line at the beginning of your code:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.TranslucentStatusBar:` 要显示半透明状态栏，您可以在代码开头使用以下行：'
- en: '[PRE53]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![More display functions](img/1888_02_06.jpg)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/1888_02_06.jpg)'
- en: '`display.DarkStatusBar:` To show the dark status bar, you can use the following
    line at the beginning of your code:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.DarkStatusBar:` 要显示深色状态栏，您可以在代码开头使用以下行：'
- en: '[PRE54]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![More display functions](img/1888_02_07.jpg)'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/1888_02_07.jpg)'
- en: Content size properties
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容大小属性
- en: When you want to obtain display information on your device, you can use the
    content size properties to return the values.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想获取设备上的显示信息时，可以使用内容大小属性来返回值。
- en: '`display.contentWidth`—Returns the original width of the content in pixels.
    This will default to the screen width.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.contentWidth`——返回内容的原始宽度（以像素为单位）。默认情况下，这将是屏幕宽度。'
- en: '`display.contentHeight`—Returns the original height of the content in pixels.
    This will default to the screen height.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.contentHeight`——返回内容的原始高度（以像素为单位）。默认情况下，这将是屏幕高度。'
- en: '`display.viewableContentWidth`—A read-only property that contains the width
    of the viewable screen area in pixels, within the coordinate system of the original
    content. Accessing this property will display how the content is viewed, whether
    you''re in portrait or landscape mode. For example:'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.viewableContentWidth`——一个只读属性，包含原始内容坐标系中可查看屏幕区域的宽度（以像素为单位）。访问此属性将显示内容是如何被查看的，无论您是在纵向还是横向模式下。例如：'
- en: '[PRE55]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`display.viewableContentHeight`—A read-only property that contains the height
    of the viewable screen area in pixels within the coordinate system of the original
    content. Accessing this property will display how the content is viewed, whether
    you''re in portrait or landscape mode. For example:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.viewableContentHeight`—一个只读属性，包含在原始内容坐标系中可查看屏幕区域的高度（以像素为单位）。访问此属性将显示内容是如何被查看的，无论您是在纵向还是横向模式。例如：'
- en: '[PRE56]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`display.statusBarHeight`—A read-only property representing the height of the
    status bar in pixels (only valid on iOS devices). For example:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.statusBarHeight`—一个只读属性，表示状态栏的高度（以像素为单位）（仅在iOS设备上有效）。例如：'
- en: '[PRE57]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Optimizing your workflow
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的工作流程
- en: So far, we have touched on the vital basics of programming in Lua and terminology
    used in Corona SDK. Once you start developing interactive applications to sell
    in the App Store or Google Play Store, you need to be aware of your design choices
    and how they affect the performance of your application. This means taking into
    consideration how much memory your mobile device is using to process the application.
    Here are some things to look for if you're just starting out on Corona SDK.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Lua编程和Corona SDK中使用的术语的基本要点。一旦你开始开发用于在App Store或Google Play Store销售的应用程序，你需要意识到你的设计选择以及它们如何影响你应用程序的性能。这意味着要考虑你的移动设备处理应用程序时使用的内存量。以下是一些如果你刚开始使用Corona
    SDK时应该注意的事项。
- en: Using memory efficiently
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效使用内存
- en: In some of our earlier examples, we used global variables in our code. Cases
    like those are an exception since the examples did not contain a high volume of
    functions, loops to call out to or display objects. Once you start building a
    game that is heavily involved with function calls and numerous display objects,
    local variables will increase performance within your application and will be
    placed on the stack so Lua can interface with them faster.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的一些早期示例中，我们在代码中使用了全局变量。这些情况是例外，因为示例中没有包含大量函数、循环调用或显示对象。一旦你开始构建一个与函数调用和众多显示对象高度相关的游戏，局部变量将提高你应用程序的性能，并将放置在栈上，这样Lua可以更快地与之交互。
- en: 'The following code will cause memory leaks:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会导致内存泄漏：
- en: '[PRE58]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding code removes `myImage` from the display hierarchy once it is touched.
    The only problem is that the memory used by `myImage` leaks because the variable
    `myImage` still refers to it. Since `myImage` is a global variable, the display
    object it references will not be freed even though `myImage` does not display
    on the screen.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在触摸后从显示层次结构中移除`myImage`。唯一的问题是`myImage`使用的内存泄漏，因为变量`myImage`仍然引用它。由于`myImage`是一个全局变量，即使`myImage`不在屏幕上显示，它引用的显示对象也不会被释放。
- en: 'Unlike global variables, localizing variables help speed up the look-up process
    for your display object. Also, it only exists within the block or chunk of code
    that it''s defined in. Using a local variable in the following code will remove
    the object completely and free up memory:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局变量不同，局部化变量有助于加快查找显示对象的过程。此外，它只存在于定义它的代码块或代码段中。在以下代码中使用局部变量将完全删除对象并释放内存：
- en: '[PRE59]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Optimizing your display images
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化你的显示图像
- en: It's important to optimize your image file size as much as you can. Using full-screen
    images can impact the performance of your application. They require more time
    to load on a device and consume a lot of texture memory. When a lot of memory
    is consumed in an application, in most cases it'll be forced to quit.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 优化你的图像文件大小非常重要。使用全屏图像可能会影响你应用程序的性能。它们在设备上加载需要更多时间，并且消耗大量的纹理内存。当应用程序消耗大量内存时，在大多数情况下，它将被强制退出。
- en: 'iOS devices vary in available memory, depending which one you have:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备的可用内存因设备而异：
- en: iPhone 3G, iTouch 2G—128 MB RAM
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 3G, iTouch 2G—128 MB RAM
- en: iPhone 3GS, iPad, iTouch 3G/4G—256 MB RAM
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 3GS, iPad, iTouch 3G/4G—256 MB RAM
- en: iPhone 4/4S, iPad 2—512 MB RAM
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 4/4S, iPad 2—512 MB RAM
- en: For example, texture memory on the iPhone 3GS should be kept under 25 MB before
    performance issues start occurring by slowing down your app or even forcing it
    to quit. An iPad 2 would have no problem going further down that boundary since
    it has more memory available.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，iPhone 3GS上的纹理内存应该在性能问题开始出现之前保持在25 MB以下，这些问题可能包括减慢你的应用程序或甚至强制它退出。iPad 2由于有更多的可用内存，可以进一步降低这个界限。
- en: 'Refer to the following link to apply memory warnings for iOS devices: [http://developer.anscamobile.com/reference/index/memorywarning-ios](http://developer.anscamobile.com/reference/index/memorywarning-ios).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 有关为 iOS 设备应用内存警告的信息，请参阅以下链接：[http://developer.anscamobile.com/reference/index/memorywarning-ios](http://developer.anscamobile.com/reference/index/memorywarning-ios)。
- en: For Android devices, there is around a 24 MB memory limit. So it's important
    to be aware of how many display objects you have in your scene and how to manage
    them when they are not needed anymore in your app.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 设备，大约有 24 MB 的内存限制。因此，了解您的场景中有多少显示对象以及如何管理它们在应用程序中不再需要时非常重要。
- en: 'In cases where you no longer need an image to be displayed on screen use the
    following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在您不再需要在屏幕上显示图像的情况下，使用以下代码：
- en: '[PRE60]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you want to remove an image from the scene completely throughout the lifetime
    of your app, include the following line after your `image.parent:remove( image
    )` or `image:removeSelf()` code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在应用程序的生命周期内完全从场景中删除一个图像，请在您的 `image.parent:remove( image )` 或 `image:removeSelf()`
    代码之后包含以下行：
- en: '[PRE61]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Keeping memory usage low within your application will prevent crashes and improve
    performance. For more information on optimization, go to the following URL: [http://developer.anscamobile.com/content/performance-and-optimization](http://developer.anscamobile.com/content/performance-and-optimization).'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中保持低内存使用量可以防止崩溃并提高性能。有关优化的更多信息，请访问以下 URL：[http://developer.anscamobile.com/content/performance-and-optimization](http://developer.anscamobile.com/content/performance-and-optimization)。
- en: Pop quiz—basics of Lua
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——Lua 的基础知识
- en: Which of the following are values?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是值？
- en: a. Numbers
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. 数字
- en: b. nil
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. 空值
- en: c. Strings
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. 字符串
- en: d. All of the above
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 以上所有
- en: Which relational operator is false?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关系运算符是错误的？
- en: a. `print(0 == 0)`
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. `print(0 == 0)`
- en: b. `print(3 >= 2)`
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. `print(3 >= 2)`
- en: c. `print(2 ~= 2)`
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. `print(2 ~= 2)`
- en: d. `print(0 ~= 2)`
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. `print(0 ~= 2)`
- en: What is the correct way to scale an object in the x direction?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确的缩放对象 x 方向的方法是什么？
- en: a. `object.scaleX`
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. `object.scaleX`
- en: b. `object.xscale`
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. `object.xscale`
- en: c. `object.Xscale`
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. `object.Xscale`
- en: d. `object.xScale`
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. `object.xScale`
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed parts of Lua programming that will send you on your way
    to start creating your own apps in Corona. As you continue working with Lua, you'll
    start understanding the terminology better. Eventually you'll find new programming
    solutions that will benefit your development process.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 Lua 编程的某些部分，这将帮助您开始创建自己的 Corona 应用程序。随着您继续使用 Lua，您将更好地理解术语。最终，您会发现新的编程解决方案，这将有助于您的开发过程。
- en: 'The following are some skills you learned so far:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您已经学到的技能：
- en: Creating variables and assigning values to them
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建变量并将值分配给它们
- en: Establishing expressions by using operators
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符建立表达式
- en: How to use the Corona Terminal to output or print results
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Corona 终端输出或打印结果
- en: Use tables to structure lists, arrays, sets, and so on
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表格来构建列表、数组、集合等
- en: Adding display objects in the simulator
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟器中添加显示对象
- en: Configuring your application build to work on different mobile devices
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的应用程序构建以在不同的移动设备上工作
- en: Implementing dynamic resolution images
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现动态分辨率图像
- en: Creating functions to run a block of code
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数以运行代码块
- en: There was definitely a lot to take in in this section. There is still a handful
    of information on Lua that we didn't get to touch base on but you have learned
    enough to get you started. For more information on programming in Lua, you can
    refer to [http://www.lua.org/pil/index.html](http://www.lua.org/pil/index.html)
    or the resources section on the Corona website at [http://www.anscamobile.com/resources/](http://www.anscamobile.com/resources/).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中确实有很多东西要学习。关于 Lua 的信息还有一些我们没有触及，但您已经学到了足够的知识来开始。有关 Lua 编程的更多信息，您可以参考 [http://www.lua.org/pil/index.html](http://www.lua.org/pil/index.html)
    或 Corona 网站上的资源部分 [http://www.anscamobile.com/resources/](http://www.anscamobile.com/resources/)。
- en: In the next chapter, we'll start making our very first game called Breakout!
    You'll get some hands-on experience of creating a game framework in Corona and
    applying all the necessary assets to develop a mobile game. You'll be surprised
    at how fast and simple it is to create one.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始制作我们的第一个游戏，名为 Breakout！您将在 Corona 中创建游戏框架并获得一些实际操作经验，并将所有必要的资源应用到移动游戏开发中。您会对创建一个游戏如此之快和简单感到惊讶。
