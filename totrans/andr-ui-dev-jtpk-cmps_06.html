<html><head></head><body><div><div><h1 id="_idParaDest-61"><a id="_idTextAnchor076"/>Chapter 4: Laying Out UI Elements</h1>
			<p>In the previous chapters, you learned how to build simple UIs. Although they consisted of just a few UI elements, they needed to arrange their buttons, text fields, and sliders in a particular order, direction, or hierarchy. <code>Row()</code>) or vertically (<code>Column()</code>). This chapter explores layouts in greater detail.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor077"/>Using predefined layouts</li>
				<li>Understanding the single measure pass</li>
				<li>Creating custom layouts</li>
			</ul>
			<p>We will start by exploring the predefined layouts of <code>Row()</code>, <code>Column()</code>, and <code>Box()</code>. You will learn how to combine them to create beautiful UIs. Next, I'll introduce you to <code>ConstraintLayout</code>. It places composables that are relative to others on the screen and uses attributes to flatten the UI element hierarchy. This is an alternative to nesting <code>Row()</code>, <code>Column()</code>, and <code>Box()</code>.</p>
			<p>The second main section will explain why the layout system in Jetpack Compose is more performant than the traditional View-based approach. We will once again go under the covers and look at some of the internals of the Compose runtime. This will prepare you for the final main section of this chapter, <em class="italic">Creating custom layouts</em>.</p>
			<p>In this final section, you will learn how to create a custom layout and thus gain precise control over the rendering of its children. This is helpful if the predefined layouts do not offer enough flexibility for a particular use case.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>This chapter showcases three sample apps: </p>
			<ul>
				<li><code>PredefinedLayoutsDemo</code></li>
				<li><code>ConstraintLayoutDemo</code></li>
				<li><code>CustomLayoutDemo</code></li>
			</ul>
			<p>Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, and how to get it. If you want to try the <code>CheckboxWithLabel()</code> composable from the <em class="italic">Combining basic </em><em class="italic">building blocks</em> section, you can use the <em class="italic">Sandbox</em> app project in the top-level directory of this book's GitHub repository at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose</a>. Open its <code>SandboxActivity</code> and copy the composable functions from <code>code_snippets.txt</code>, which is located in the <code>/chapter_04</code> folder.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor079"/>Using predefined layouts</h1>
			<p>When you create a <a id="_idIndexMarker146"/>UI, you must define where its elements appear and how big they are. Jetpack Compose provides a couple of basic layouts, which arrange their content along one main axis. There are three axes to consider:</p>
			<ul>
				<li>Horizontal</li>
				<li>Vertical</li>
				<li>Stacked</li>
			</ul>
			<p>Each axis is represented by a layout. <code>Row()</code> arranges its content horizontally, while <code>Column()</code> does so vertically. <code>Box()</code> and <code>BoxWithConstraints()</code> stack their contents on top of each other. By combining these axis-orientated building blocks, you can create great-looking UIs easily.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor080"/>Combining basic building blocks</h2>
			<p>The following <code>PredefinedLayoutsDemo</code> sample app shows three checkboxes that toggle a red, a<a id="_idIndexMarker147"/> green, and a blue rectangle, respectively. The boxes appear only if the corresponding checkbox is checked:</p>
			<div><div><img src="img/B17505_04_01.jpg" alt="Figure 4.1 – The sample PredefinedLayoutsDemo app&#13;&#10;" width="1376" height="616"/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor081"/></p>
			<p class="figure-caption">Figure 4.1 – The sample PredefinedLayoutsDemo app</p>
			<p>Let's see how <a id="_idIndexMarker148"/>this is done. First, I will show you how to create a checkbox with an accompanying label:</p>
			<pre>@Composable
fun CheckboxWithLabel(label: String, state: MutableState&lt;Boolean&gt;) {
  Row(
    modifier = Modifier.clickable {
      state.value = !state.value
    }, verticalAlignment = Alignment.CenterVertically
  ) {
    Checkbox(
      checked = state.value,
      onCheckedChange = {
        state.value = it
      }
    )
    Text(
      text = label,
      modifier = Modifier.padding(start = 8.dp)
    )
  }
}</pre>
			<p>Jetpack<a id="_idIndexMarker149"/> Compose has a built-in <code>Checkbox()</code>. It receives the current state (<code>checked</code>) and a lambda expression (<code>onCheckedChange</code>), which is invoked when the checkbox is clicked. At the time of writing, you cannot pass a label. However, we can achieve something similar by putting <code>Checkbox()</code> and <code>Text()</code> inside a <code>Row()</code>. We need to make the row clickable because we want to change the state of the checkbox when the text is clicked too. To make the checkbox with a label more visually appealing, we can center <code>Checkbox()</code> and <code>Text()</code> vertically inside the row by setting <code>verticalAlignment</code> to <code>Alignment.CenterVertically</code>.</p>
			<p><code>CheckboxWithLabel()</code> receives a <code>MutableState&lt;Boolean&gt;</code> because other composables need to be recomposed when it changes the value inside <code>onCheckedChange</code>.</p>
			<p>Next, let's see where the state is created:</p>
			<pre>@Composable
fun PredefinedLayoutsDemo() {
  val red = remember { mutableStateOf(true) }
  val green = remember { mutableStateOf(true) }
  val blue = remember { mutableStateOf(true) }
  Column(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp)
  ) {
    …</pre>
			<p><code>PredefinedLayoutsDemo()</code> arranges its content vertically by putting it inside a <code>Column()</code>. The <a id="_idIndexMarker150"/>column fills all the available space (<code>fillMaxSize()</code>) and has a padding of 16 density-independent pixels on all four sides (<code>padding(16.dp)</code>). The three states (<code>red</code>, <code>green</code>, and <code>blue</code>) are passed to <code>CheckboxWithLabel()</code>. Here's what these invocations look like:</p>
			<pre>CheckboxWithLabel(
  label = stringResource(id = R.string.red),
  state = red
)
CheckboxWithLabel(
  label = stringResource(id = R.string.green),
  state = green
)
CheckboxWithLabel(
  label = stringResource(id = R.string.blue),
  state = blue
)</pre>
			<p>They are almost the same, differing only in the state (<code>red</code>, <code>green</code>, and <code>blue</code>) and the label string (<code>R.string.red</code>, <code>R.string.green</code>, or <code>R.string.blue</code>).</p>
			<p>Now, let's find out how the stacked colored boxes are created:</p>
			<pre>Box(
  modifier = Modifier
    .fillMaxSize()
    .padding(top = 16.dp)
) {
  if (red.value) {
    Box(
      modifier = Modifier
        .fillMaxSize()
        .background(Color.Red)
    )
  }
  if (green.value) {
    Box(
      modifier = Modifier
        .fillMaxSize()
        .padding(32.dp)
        .background(Color.Green)
    )
  }
  if (blue.value) {
    Box(
      modifier = Modifier
        .fillMaxSize()
        .padding(64.dp)
        .background(Color.Blue)
    )
  }
}</pre>
			<p>The three colored boxes are put inside another <code>Box()</code>, which fills all the available space. To create a gap between it and the last checkbox, I specified a top padding of 16 density-independent pixels.</p>
			<p>A colored box is only added if its corresponding state is <code>true</code> (for example, <code>if (red.value) { …)</code>. All colored boxes fill the available space. As they will be stacked on top of each other, only the last (top) one will be visible. To fix this, the green and blue boxes receive<a id="_idIndexMarker151"/> paddings that differ in size: the padding for the blue box (the last one) is 64 density-independent pixels, so in the areas of the padding, the green box becomes visible. The green box has a padding of 32 density-independent pixels, so in this area, the first box (the red one) can be seen.</p>
			<p>As you have seen, by combining basic layouts such as <code>Box()</code> and <code>Row()</code>, you can easily create great-looking UIs. In the next section, I will introduce you to an alternative approach where we will define a UI based on constraints.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor082"/>Creating layouts based on constraints</h2>
			<p>Defining UIs<a id="_idIndexMarker152"/> based on constraints has been the most recent preferred approach in Android's traditional <code>View</code> world because older layouts such as <code>RelativeLayout</code> or <code>LinearLayout</code> could impact performance when they're used in large, multiply-nested layouts. <code>ConstraintLayout</code> avoids this by flattening the <code>View</code> hierarchy. As you will see in the <em class="italic">Understanding the single measure pass</em> section, this is no issue for Jetpack Compose. </p>
			<p>However, for more complex layouts in a Compose app, you may still want to limit the nesting of <code>Box()</code>, <code>Row()</code>, and <code>Column()</code> to make your code simpler and clearer. This is where <code>ConstraintLayout()</code> can help.</p>
			<p>The <code>ConstraintLayoutDemo</code> sample app is a reimplementation of <code>PredefinedLayoutsDemo</code> based on <code>ConstraintLayout()</code>. By comparing the two versions, you get a thorough understanding of how this composable function works. To use <code>ConstraintLayout()</code> in your app, you need to add a dependency to your module-level <code>build.gradle</code> file. Please note that the version number shown here is just an example. You can find the latest version at <a href="https://developer.android.com/jetpack/androidx/versions/all-channel">https://developer.android.com/jetpack/androidx/versions/all-channel</a>:</p>
			<pre>implementation "androidx.constraintlayout:constraintlayout-compose:1.0.0-rc02"</pre>
			<p>So, how do <a id="_idIndexMarker153"/>we define a layout based on constraints? Let's find out by examining the reimplementation of <code>CheckboxWithLabel()</code>. It places text next to a checkbox:</p>
			<pre>@Composable
fun CheckboxWithLabel(
  label: String,
  state: MutableState&lt;Boolean&gt;,
  modifier: Modifier = Modifier
) {
  ConstraintLayout(modifier = modifier.clickable {
    state.value = !state.value
  }) {
    val (checkbox, text) = <strong class="bold">createRefs()</strong>
    Checkbox(
      checked = state.value,
      onCheckedChange = {
        state.value = it
      },
      modifier = Modifier.<strong class="bold">constrainAs</strong>(checkbox) {
      }
    )
    Text(
      text = label,
      modifier = Modifier.<strong class="bold">constrainAs</strong>(text) {
        <strong class="bold">start.linkTo(checkbox.end, margin = 8.dp)</strong>
        <strong class="bold">top.linkTo(checkbox.top)</strong>
        <strong class="bold">bottom.linkTo(checkbox.bottom)</strong>
      }
    )
  }
}</pre>
			<p><code>ConstraintLayout()</code> uses a <code>ConstraintLayout()</code> must have a reference associated with it, which is created using <code>createRefs()</code>. Constraints are provided using the <code>constrainAs()</code> modifier. Its lambda expression receives a <code>ConstrainScope</code>. It includes properties such as <code>start</code>, <code>top</code>, and <code>bottom</code>. These are called <code>linkTo()</code>) to the location of another composable.</p>
			<p>Let's look at <code>Text()</code>. Its <code>constrainAs()</code> contains <code>bottom.linkTo(checkbox.bottom)</code>. This means that the bottom of the text is constrained<a id="_idIndexMarker156"/> to the bottom of the checkbox. As the top of the text is linked to the top of the checkbox, the height of the text is equal to the height of the checkbox. The following line means that the start of the text is constrained by the end of the checkbox, with an additional margin of 8 density-independent pixels:</p>
			<pre>start.linkTo(checkbox.end, margin = 8.dp)</pre>
			<p>So, in the direction of reading, the text comes after the checkbox. Next, let's look at <code>ConstraintLayoutDemo()</code>:</p>
			<pre>@Composable
fun ConstraintLayoutDemo() {
  val red = remember { mutableStateOf(true) }
  val green = remember { mutableStateOf(true) }
  val blue = remember { mutableStateOf(true) }
  ConstraintLayout(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp)
  ) {
    val (cbRed, cbGreen, cbBlue, boxRed, boxGreen, boxBlue) =
            <strong class="bold">createRefs()</strong>
    CheckboxWithLabel(
      label = stringResource(id = R.string.red),
      state = red,
      modifier = Modifier.constrainAs(cbRed) {
        <strong class="bold">top.linkTo(parent.top)</strong>
      }
    )
    ...</pre>
			<p>Once we have <a id="_idIndexMarker157"/>created the references that areneeded to define constraints using <code>createRefs()</code>, we add our first <code>CheckboxWithLabel()</code>. Its <code>top</code> is linked to (constrained by) the <code>top</code> of <code>parent</code>, which is <code>ConstraintLayout()</code>. So, the first checkbox with a label is the topmost one. Here's how the second one, which toggles the green box, is invoked:</p>
			<pre>CheckboxWithLabel(
  label = stringResource(id = R.string.green),
  state = green,
  modifier = Modifier.constrainAs(cbGreen) {
    top.linkTo(cbRed.bottom)
  }
)</pre>
			<p>Its top is constrained by the bottom of the first checkbox with a label (which toggles the red box). Finally, here's how we need to constrain the third <code>CheckboxWithLabel()</code>:</p>
			<pre>modifier = Modifier.constrainAs(cbBlue) {
  top.linkTo(cbGreen.bottom)
}</pre>
			<p>To conclude <a id="_idIndexMarker158"/>this section, let me show you how to define the colored boxes. Here's the red one:</p>
			<pre>if (red.value) {
  Box(
    modifier = Modifier
      .background(Color.Red)
      .constrainAs(boxRed) {
        start.linkTo(parent.start)
        end.linkTo(parent.end)
        top.linkTo(cbBlue.bottom, margin = 16.dp)
        bottom.linkTo(parent.bottom)
        width = Dimension.fillToConstraints
        height = Dimension.fillToConstraints
      }
  )
}</pre>
			<p>Both <code>start</code> and <code>end</code> are linked to the corresponding anchors of <code>parent</code> (which is <code>ConstraintLayout()</code>). <code>top</code> is constrained by <code>bottom</code> of the last checkbox, so the red box appears below it. <code>bottom</code> of the red box is constrained by <code>bottom</code> of <code>parent</code>. Please note that currently, we must set <code>width</code> and <code>height</code> to the value that we obtained from <code>Dimension.fillToConstraints</code>. Otherwise, the box won't have the correct size.</p>
			<p>Next, let's look at the constraints of the green box:</p>
			<pre>constrainAs(boxGreen) {
  start.linkTo(parent.start, margin = 32.dp)
  end.linkTo(parent.end, margin = 32.dp)
  top.linkTo(cbBlue.bottom, margin = (<strong class="bold">16</strong> + 32).dp)
  bottom.linkTo(parent.bottom, margin = 32.dp)
  width = Dimension.fillToConstraints
  height = Dimension.fillToConstraints
}</pre>
			<p>This code is <a id="_idIndexMarker159"/>practically the same. One difference is that all the sides receive a <code>margin</code> of 32 density-independent pixels. This is necessary because we want the red box, which is below the green one, to be visible at the locations of the margin. As the red box already has a <code>top</code> margin of 16, we must add this value to the <code>top</code> margin. You may be wondering why I am not linking to <code>boxRed</code> instead. That is because the red box will not be present if its corresponding checkbox is not checked. In this case, the anchor would not be there.</p>
			<p>Here's what the constraints for the blue box will look like:</p>
			<pre>constrainAs(boxBlue) {
  start.linkTo(parent.start, margin = 64.dp)
  end.linkTo(parent.end, margin = 64.dp)
  top.linkTo(cbBlue.bottom, margin = (16 + 64).dp)
  bottom.linkTo(parent.bottom, margin = 64.dp)
  width = Dimension.fillToConstraints
  height = Dimension.fillToConstraints
}</pre>
			<p>The only thing I needed to change is the margin on all four sides because otherwise, the box below (the green one) would not be visible.</p>
			<p>In a nutshell, this is how <code>ConstrainLayout()</code> works:</p>
			<ul>
				<li>You constrain a composable by linking its anchors to other ones</li>
				<li>The linking is based on references. To setup these references, you must call <code>createRefs()</code>.</li>
			</ul>
			<p>The main<a id="_idIndexMarker160"/> advantage of combining <code>Box()</code>, <code>Row()</code>, and <code>Column()</code> is that you flatten your UI element hierarchy. Think of it like this: in <code>PredefinedLayoutsDemo</code>, I needed to stack the colored boxes in a parent <code>Box()</code>. In <code>ConstrainLayoutDemo</code>, the boxes and the three <code>CheckboxWithLabel()</code> share the same parent (a <code>ConstrainLayout()</code>). This reduces the number of composables and makes the code cleaner.</p>
			<p>In the next section, we will once again peek inside the internals of Jetpack Compose. We will learn how the layout process works and why it is more efficient than the traditional View-based approach.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor083"/>Understanding the single measure pass</h1>
			<p>Laying out a UI element hierarchy <a id="_idIndexMarker161"/>means determining the sizes of all the elements and positioning them on the screen based on the layout strategy of their parent. At first, getting the size of, say, some text doesn't sound too complicated. After all, isn't it determined by the font and the text to be output? Here's an example, with two pieces of text laid out in a <code>Column()</code>:</p>
			<pre>@Composable
@Preview
fun ColumnWithTexts() {
  Column {
    Text(
      text = "Android UI development with Jetpack Compose",
      style = MaterialTheme.typography.h3
    )
    Text(
      text = "Hello Compose",
      style = MaterialTheme
          .typography.h5.merge(TextStyle(color = Color.Red))
    )
  }
}</pre>
			<p>If you deploy the preview, you will notice that, in portrait mode, the first text requires more space vertically than in landscape mode. The second text always fits into one line. The size that a composable takes on-screen partially depends on the conditions that have been imposed from <em class="italic">outside</em>. Here, the maximum width of the column (the parent) influences the height<a id="_idIndexMarker162"/> of the first piece of text. Such conditions are <a id="_idIndexMarker163"/>called <code>ConstraintLayout()</code>.</p>
			<p>Once a layout has obtained and measured the size of its content, the layout will position its children (the content). Let's see how this works by looking at the source code of <code>Column()</code>:</p>
			<div><div><img src="img/B17505_04_02.jpg" alt="Figure 4.2 – Source code of Column()&#13;&#10;" width="759" height="294"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Source code of Column()</p>
			<p>The composable is <a id="_idIndexMarker164"/>very short. Besides assigning a value to <code>measurePolicy</code>, it only invokes <code>Layout()</code>, passing <code>content</code>, <code>measurePolicy</code>, and <code>modifier</code>. We briefly looked at the source code of <code>Layout()</code> in the <em class="italic">Emitting UI elements</em> section of <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, to understand what it means to emit UI elements. Now, we'll focus on the layout process. The <code>measurePolicy</code> variable references an implementation of the <code>MeasurePolicy</code> interface. In this case, it's the result of a call to <code>columnMeasurePolicy()</code>.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor084"/>Defining measure policies</h2>
			<p>Depending on<a id="_idIndexMarker165"/> the values of <code>verticalArrangement</code> and <code>horizontalAlignment</code>, the call to <code>columnMeasurePolicy()</code> returns either <code>DefaultColumnMeasurePolicy</code> (a variable) or the result of <code>rowColumnMeasurePolicy()</code>. <code>DefaultColumnMeasurePolicy</code> calls <code>rowColumnMeasurePolicy</code>. Therefore, this function defines the measure policy for any <code>Column()</code>. It returns a <code>MeasurePolicy</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Please remember that you can look at the source code of a policy by pressing the <em class="italic">Ctrl</em> key and clicking on a name, such as <code>columnMeasurePolicy</code>.</p>
			<p><code>MeasurePolicy</code> belongs to the <code>androidx.compose.ui.layout</code> package. It defines how a layout is measured and laid out, so it is the main building block for both predefined (for example, <code>Box()</code>, <code>Row()</code>, and <code>Column()</code>) and custom layouts. Its most important function is <code>measure()</code>, which is an extension function of <code>MeasureScope</code>. This function receives two parameters, <code>List&lt;Measurable&gt;</code> and <code>Constraints</code>. The elements of the list represent the children of the layout. They can be measured using <code>Measurable.measure()</code>. This function returns an instance of <code>Placeable</code>, a representation of the size a child wants to span.</p>
			<p><code>MeasureScope.measure()</code> returns an instance of <code>MeasureResult</code>. This interface defines the following components:</p>
			<ul>
				<li>The size of a layout (<code>width</code>, <code>height</code>)</li>
				<li>Alignment lines (<code>alignmentLines</code>)</li>
				<li>Logic to position the children (<code>placeChildren()</code>)</li>
			</ul>
			<p>You can find an implementation of <code>MeasureResult</code> in the <em class="italic">Creating custom layouts</em> section.</p>
			<p>Alignment lines<a id="_idIndexMarker166"/> define an offset line that can be used by parent layouts to align and position their children. For example, text baselines are alignment lines.</p>
			<p>Depending on the complexity of the UI, a layout may find that its children do not fit nicely in its boundaries. The layout may want to remeasure the children, passing different measurement configurations. Remeasuring children is possible in the Android <code>View</code> system, but this can lead to decreased performance. Therefore, in Jetpack Compose, a layout may measure its content only once. If it tries again, an exception will be thrown.</p>
			<p>A layout can, however, query the <code>MeasurePolicy</code> defines four extension functions of <code>IntrinsicMeasureScope</code>. <code>minIntrinsicWidth()</code> and <code>maxIntrinsicWidth()</code> return the minimum or maximum width of a layout, given a particular height, so that the content of the layout can be painted completely. <code>minIntrinsicHeight()</code> and <code>maxIntrinsicHeight()</code> return the minimum or maximum height of a layout given a particular width so that the content of the layout can be painted completely. To get an idea of how they work, let's briefly look at one of them:</p>
			<div><div><img src="img/B17505_04_03.jpg" alt="Figure 4.3 – Source code of minIntrinsicWidth()&#13;&#10;" width="814" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Source code of minIntrinsicWidth()</p>
			<p><code>IntrinsicMeasureScope.minIntrinsicWidth()</code> receives two parameters: <code>height</code> and a list of children (<code>measurables</code>). The <code>IntrinsicMeasurable</code> interface defines <a id="_idIndexMarker167"/>four functions that obtain the minimum or maximum values for a particular element (<code>minIntrinsicWidth()</code>, <code>maxIntrinsicWidth()</code>, <code>minIntrinsicHeight()</code>, and <code>maxIntrinsicHeight()</code>). Each element of <code>measurables</code> is converted into an instance of <code>DefaultIntrinsicMeasurable</code>. As this class implements the <code>Measurable</code> interface, it provides an implementation of <code>measure()</code>. It returns <code>FixedSizeIntrinsicsPlaceable</code>, which provides the smallest possible width for a given <code>height</code>. The converted children are measured by an instance of <code>IntrinsicsMeasureScope</code>.</p>
			<p>We'll finish looking at the internals of the Compose layout process by turning to <code>Constraints</code>. They are, for example, passed to <code>MeasureScope.measure()</code>. The class belongs to the <code>androidx.compose.ui.unit</code> package. It stores four values: <code>minWidth</code>, <code>minHeight</code>, <code>maxWidth</code>, and <code>maxHeight</code>. They define the minimum and maximum values the children of a layout must honor when measuring themselves. So, their width must be no smaller than <code>minWidth</code> and no larger than <code>maxWidth</code>. Their height must lie within <code>minHeight</code> and <code>maxHeight</code>.</p>
			<p>The companion object defines the <code>Infinity</code> constant. It is used to signal that the constraint should be considered infinite. To create a <code>Constraints</code> instance, you can invoke the top-level <code>Constraints()</code> function.</p>
			<p>This was a lot of information. Before moving on, let's recap what we have learned.</p>
			<ul>
				<li>The <code>Layout()</code> composable receives three parameters: the content, the measure policy, and a modifier.</li>
				<li>The measure policy defines how a layout is measured and laid out.</li>
				<li>The intrinsic size of a layout determines the minimum or maximum dimension for the corresponding input.</li>
			</ul>
			<p>In the traditional<a id="_idIndexMarker168"/> View system, a parent view may call the <code>measure()</code> method more than once on its children (please refer to <a href="https://developer.android.com/guide/topics/ui/how-android-draws">https://developer.android.com/guide/topics/ui/how-android-draws</a> for details). On the other hand, Jetpack Compose requires that children must be measured <em class="italic">exactly once</em> before they are positioned. This results in a more performant measurement.</p>
			<p>In the next section, we will make use of this knowledge by implementing a simple custom layout. It will position its children from left to right and from top to bottom. When one row is filled, the next one will be started below it.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor085"/>Creating custom layouts</h1>
			<p>Sometimes, you may<a id="_idIndexMarker169"/> want to lay children out one after another in a row and start a new row when the current one has been filled. The <code>CustomLayoutDemo</code> sample app, as shown in the following screenshot, shows you how to do this. It creates 43 randomly colored boxes that vary in width and height:</p>
			<div><div><img src="img/B17505_04_04.jpg" alt="Figure 4.4 – Sample CustomLayoutDemo app&#13;&#10;" width="1347" height="622"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Sample CustomLayoutDemo app</p>
			<p>Let's start by<a id="_idIndexMarker170"/> looking at the composable function that creates colored boxes:</p>
			<pre>@Composable
fun ColoredBox() {
  Box(
    modifier = Modifier
      .border(
        width = 2.dp,
        color = Color.Black
      )
      .background(randomColor())
      .width((40 * randomInt123()).dp)
      .height((10 * randomInt123()).dp)
  )
}</pre>
			<p>A colored box consists of a <code>Box()</code> with a black, two density-independent pixels wide border. The <code>width()</code> and <code>height()</code> modifiers set the preferred size of the box. This means that the layout could <a id="_idIndexMarker171"/>override it. For simplicity, my example doesn't. <code>randomInt123()</code> randomly returns either <code>1</code>, <code>2</code>, or <code>3</code>:</p>
			<pre>private fun randomInt123() = Random.nextInt(1, 4)</pre>
			<p><code>randomColor()</code> randomly returns red, green, or blue:</p>
			<pre>private fun randomColor() = when (randomInt123()) {
    1 -&gt; Color.Red
    2 -&gt; Color.Green
    else -&gt; Color.Blue
}</pre>
			<p>Next, I'll show you how the colored boxes are created and set as the content of my custom layout:</p>
			<pre>@Composable
@Preview
fun CustomLayoutDemo() {
    SimpleFlexBox {
        for (i in 0..42) {
            ColoredBox()
        }
    }
}</pre>
			<p><code>SimpleFlexBox()</code> is our custom layout. It is used like any predefined layout. You can even provide a modifier (which has not been done here for simplicity). So, how does the custom layout work? Let's find out:</p>
			<pre>@Composable
fun SimpleFlexBox(
  modifier: Modifier = Modifier,
  content: @Composable () -&gt; Unit
) {
  Layout(
    modifier = modifier,
    content = content,
    measurePolicy = simpleFlexboxMeasurePolicy()
  )
}</pre>
			<p>Custom <a id="_idIndexMarker172"/>layouts should receive at least two parameters – <code>content</code> and a <code>modifier</code> with a default value of <code>Modifier</code>. Additional parameters may influence the behavior of your custom layout. For example, you may want to make the alignment of children configurable. For simplicity, the example does not do so.</p>
			<p>As you know from the previous section, measurement and positioning are defined through a measure policy. I will show you how to implement one in the next section.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor086"/>Implementing a custom measure policy</h2>
			<p>At this point, I have <a id="_idIndexMarker173"/>shown you almost all the code for the custom layout. The only thing that's missing is the measure policy. Let's see how it works:</p>
			<pre>private fun simpleFlexboxMeasurePolicy(): MeasurePolicy =
  MeasurePolicy { measurables, constraints -&gt;
    val placeables = measurables.map { measurable -&gt;
      measurable.measure(constraints)
    }
    layout(
      constraints.maxWidth,
      constraints.maxHeight
    ) {
      var yPos = 0
      var xPos = 0
      var maxY = 0
      placeables.forEach { placeable -&gt;
        if (xPos + placeable.width &gt;
          constraints.maxWidth
        ) {
          xPos = 0
          yPos += maxY
          maxY = 0
        }
        placeable.placeRelative(
          x = xPos,
          y = yPos
        )
        xPos += placeable.width
        if (maxY &lt; placeable.height) {
          maxY = placeable.height
        }
      }
    }
  }</pre>
			<p><code>MeasurePolicy</code> implementations must provide implementations of <code>MeasureScope.measure()</code>. This function returns an instance of the <code>MeasureResult</code> interface. You do not need to implement this on your own. Instead, you must invoke <code>layout()</code>. This function belongs to <code>MeasureScope</code>.</p>
			<p>We pass <a id="_idIndexMarker174"/>the measured size of the layout and a <code>placementBlock</code>, which is an extension function of <code>Placeable.PlacementScope</code>. This means that you can invoke functions such as <code>placeRelative()</code> to position a child in its parent's coordinate system.</p>
			<p>A measure policy receives the content, or children, as <code>List&lt;Measurable&gt;</code>. As you know from the <em class="italic">Understanding the sing<a id="_idTextAnchor087"/>le measure pass</em> section, children must be measured exactly once before they are positioned. We can do this by creating a map of <code>placeables</code>, invoking <code>measure()</code> on each <code>measurable</code>. My example doesn't constrain child views further, instead measuring them with the given constraints.</p>
			<p><code>placementBlock</code> iterates over the <code>placeables</code> map, calculating the location of a placeable by increasing <code>xPos</code> and <code>yPos</code> along the way. Before invoking <code>placeRelative()</code>, the algorithm checks if a placeable completely fits into the current row. If this is not the case, <code>yPos</code> will be increased and <code>xPos</code> will be reset to <code>0</code>. How much <code>yPos</code> will be increased depends on the maximum height of all the placeables in the current row. This value is stored in <code>maxY</code>.</p>
			<p>As you have seen, implementing simple custom layouts is straightforward. Advanced topics such as alignment lines (which help with/are needed for X...) are beyond the scope of this book. You can find more information about them at <a href="https://developer.android.com/jetpack/compose/layouts/alignment-lines">https://developer.android.com/jetpack/compose/layouts/alignment-lines</a>.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor088"/>Summary</h1>
			<p>This chapter explored the predefined layouts of <code>Row()</code>, <code>Column()</code>, and <code>Box()</code>. You learned how to combine them to create beautiful UIs. You were also introduced to <code>ConstraintLayout</code>, which places composables that are relative to others on the screen and flattens the UI element hierarchy.</p>
			<p>The second main section explored why the layout system in Jetpack Compose is more performant than the traditional View-based approach. We looked at some of the internals of the Compose runtime, which prepared us for the final main section of this chapter, <em class="italic">Creating custom layouts</em>, where you learned how to create a custom layout and thus gain precise control over the rendering of its children.</p>
			<p>The next chapter, <em class="italic">Managing the State of Your Composable Functions</em>, will deepen your knowledge of state. We will examine the difference between stateless and stateful composable functions. Also, we will look at advanced use cases such as surviving configuration changes.</p>
		</div>
	</div></body></html>