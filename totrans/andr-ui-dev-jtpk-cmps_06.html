<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer034">
			<h1 id="_idParaDest-61"><a id="_idTextAnchor076"/>Chapter 4: Laying Out UI Elements</h1>
			<p>In the previous chapters, you learned how to build simple UIs. Although they consisted of just a few UI elements, they needed to arrange their buttons, text fields, and sliders in a particular order, direction, or hierarchy. <strong class="bold">Layouts</strong> position and size their content in a way specific to this layout, such as horizontally (<strong class="source-inline">Row()</strong>) or vertically (<strong class="source-inline">Column()</strong>). This chapter explores layouts in greater detail.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor077"/>Using predefined layouts</li>
				<li>Understanding the single measure pass</li>
				<li>Creating custom layouts</li>
			</ul>
			<p>We will start by exploring the predefined layouts of <strong class="source-inline">Row()</strong>, <strong class="source-inline">Column()</strong>, and <strong class="source-inline">Box()</strong>. You will learn how to combine them to create beautiful UIs. Next, I'll introduce you to <strong class="source-inline">ConstraintLayout</strong>. It places composables that are relative to others on the screen and uses attributes to flatten the UI element hierarchy. This is an alternative to nesting <strong class="source-inline">Row()</strong>, <strong class="source-inline">Column()</strong>, and <strong class="source-inline">Box()</strong>.</p>
			<p>The second main section will explain why the layout system in Jetpack Compose is more performant than the traditional View-based approach. We will once again go under the covers and look at some of the internals of the Compose runtime. This will prepare you for the final main section of this chapter, <em class="italic">Creating custom layouts</em>.</p>
			<p>In this final section, you will learn how to create a custom layout and thus gain precise control over the rendering of its children. This is helpful if the predefined layouts do not offer enough flexibility for a particular use case.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>This chapter showcases three sample apps: </p>
			<ul>
				<li><strong class="source-inline">PredefinedLayoutsDemo</strong></li>
				<li><strong class="source-inline">ConstraintLayoutDemo</strong></li>
				<li><strong class="source-inline">CustomLayoutDemo</strong></li>
			</ul>
			<p>Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, and how to get it. If you want to try the <strong class="source-inline">CheckboxWithLabel()</strong> composable from the <em class="italic">Combining basic </em><em class="italic">building blocks</em> section, you can use the <em class="italic">Sandbox</em> app project in the top-level directory of this book's GitHub repository at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose</a>. Open its <strong class="source-inline">SandboxActivity</strong> and copy the composable functions from <strong class="source-inline">code_snippets.txt</strong>, which is located in the <strong class="source-inline">/chapter_04</strong> folder.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor079"/>Using predefined layouts</h1>
			<p>When you create a <a id="_idIndexMarker146"/>UI, you must define where its elements appear and how big they are. Jetpack Compose provides a couple of basic layouts, which arrange their content along one main axis. There are three axes to consider:</p>
			<ul>
				<li>Horizontal</li>
				<li>Vertical</li>
				<li>Stacked</li>
			</ul>
			<p>Each axis is represented by a layout. <strong class="source-inline">Row()</strong> arranges its content horizontally, while <strong class="source-inline">Column()</strong> does so vertically. <strong class="source-inline">Box()</strong> and <strong class="source-inline">BoxWithConstraints()</strong> stack their contents on top of each other. By combining these axis-orientated building blocks, you can create great-looking UIs easily.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor080"/>Combining basic building blocks</h2>
			<p>The following <strong class="source-inline">PredefinedLayoutsDemo</strong> sample app shows three checkboxes that toggle a red, a<a id="_idIndexMarker147"/> green, and a blue rectangle, respectively. The boxes appear only if the corresponding checkbox is checked:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="Images/B17505_04_01.jpg" alt="Figure 4.1 – The sample PredefinedLayoutsDemo app&#13;&#10;" width="1376" height="616"/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor081"/></p>
			<p class="figure-caption">Figure 4.1 – The sample PredefinedLayoutsDemo app</p>
			<p>Let's see how <a id="_idIndexMarker148"/>this is done. First, I will show you how to create a checkbox with an accompanying label:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun CheckboxWithLabel(label: String, state: MutableState&lt;Boolean&gt;) {</p>
			<p class="source-code">  Row(</p>
			<p class="source-code">    modifier = Modifier.clickable {</p>
			<p class="source-code">      state.value = !state.value</p>
			<p class="source-code">    }, verticalAlignment = Alignment.CenterVertically</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Checkbox(</p>
			<p class="source-code">      checked = state.value,</p>
			<p class="source-code">      onCheckedChange = {</p>
			<p class="source-code">        state.value = it</p>
			<p class="source-code">      }</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">      text = label,</p>
			<p class="source-code">      modifier = Modifier.padding(start = 8.dp)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Jetpack<a id="_idIndexMarker149"/> Compose has a built-in <strong class="source-inline">Checkbox()</strong>. It receives the current state (<strong class="source-inline">checked</strong>) and a lambda expression (<strong class="source-inline">onCheckedChange</strong>), which is invoked when the checkbox is clicked. At the time of writing, you cannot pass a label. However, we can achieve something similar by putting <strong class="source-inline">Checkbox()</strong> and <strong class="source-inline">Text()</strong> inside a <strong class="source-inline">Row()</strong>. We need to make the row clickable because we want to change the state of the checkbox when the text is clicked too. To make the checkbox with a label more visually appealing, we can center <strong class="source-inline">Checkbox()</strong> and <strong class="source-inline">Text()</strong> vertically inside the row by setting <strong class="source-inline">verticalAlignment</strong> to <strong class="source-inline">Alignment.CenterVertically</strong>.</p>
			<p><strong class="source-inline">CheckboxWithLabel()</strong> receives a <strong class="source-inline">MutableState&lt;Boolean&gt;</strong> because other composables need to be recomposed when it changes the value inside <strong class="source-inline">onCheckedChange</strong>.</p>
			<p>Next, let's see where the state is created:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun PredefinedLayoutsDemo() {</p>
			<p class="source-code">  val red = remember { mutableStateOf(true) }</p>
			<p class="source-code">  val green = remember { mutableStateOf(true) }</p>
			<p class="source-code">  val blue = remember { mutableStateOf(true) }</p>
			<p class="source-code">  Column(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(16.dp)</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    …</p>
			<p><strong class="source-inline">PredefinedLayoutsDemo()</strong> arranges its content vertically by putting it inside a <strong class="source-inline">Column()</strong>. The <a id="_idIndexMarker150"/>column fills all the available space (<strong class="source-inline">fillMaxSize()</strong>) and has a padding of 16 density-independent pixels on all four sides (<strong class="source-inline">padding(16.dp)</strong>). The three states (<strong class="source-inline">red</strong>, <strong class="source-inline">green</strong>, and <strong class="source-inline">blue</strong>) are passed to <strong class="source-inline">CheckboxWithLabel()</strong>. Here's what these invocations look like:</p>
			<p class="source-code">CheckboxWithLabel(</p>
			<p class="source-code">  label = stringResource(id = R.string.red),</p>
			<p class="source-code">  state = red</p>
			<p class="source-code">)</p>
			<p class="source-code">CheckboxWithLabel(</p>
			<p class="source-code">  label = stringResource(id = R.string.green),</p>
			<p class="source-code">  state = green</p>
			<p class="source-code">)</p>
			<p class="source-code">CheckboxWithLabel(</p>
			<p class="source-code">  label = stringResource(id = R.string.blue),</p>
			<p class="source-code">  state = blue</p>
			<p class="source-code">)</p>
			<p>They are almost the same, differing only in the state (<strong class="source-inline">red</strong>, <strong class="source-inline">green</strong>, and <strong class="source-inline">blue</strong>) and the label string (<strong class="source-inline">R.string.red</strong>, <strong class="source-inline">R.string.green</strong>, or <strong class="source-inline">R.string.blue</strong>).</p>
			<p>Now, let's find out how the stacked colored boxes are created:</p>
			<p class="source-code">Box(</p>
			<p class="source-code">  modifier = Modifier</p>
			<p class="source-code">    .fillMaxSize()</p>
			<p class="source-code">    .padding(top = 16.dp)</p>
			<p class="source-code">) {</p>
			<p class="source-code">  if (red.value) {</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .fillMaxSize()</p>
			<p class="source-code">        .background(Color.Red)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if (green.value) {</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .fillMaxSize()</p>
			<p class="source-code">        .padding(32.dp)</p>
			<p class="source-code">        .background(Color.Green)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if (blue.value) {</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .fillMaxSize()</p>
			<p class="source-code">        .padding(64.dp)</p>
			<p class="source-code">        .background(Color.Blue)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The three colored boxes are put inside another <strong class="source-inline">Box()</strong>, which fills all the available space. To create a gap between it and the last checkbox, I specified a top padding of 16 density-independent pixels.</p>
			<p>A colored box is only added if its corresponding state is <strong class="source-inline">true</strong> (for example, <strong class="source-inline">if (red.value) { …)</strong>. All colored boxes fill the available space. As they will be stacked on top of each other, only the last (top) one will be visible. To fix this, the green and blue boxes receive<a id="_idIndexMarker151"/> paddings that differ in size: the padding for the blue box (the last one) is 64 density-independent pixels, so in the areas of the padding, the green box becomes visible. The green box has a padding of 32 density-independent pixels, so in this area, the first box (the red one) can be seen.</p>
			<p>As you have seen, by combining basic layouts such as <strong class="source-inline">Box()</strong> and <strong class="source-inline">Row()</strong>, you can easily create great-looking UIs. In the next section, I will introduce you to an alternative approach where we will define a UI based on constraints.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor082"/>Creating layouts based on constraints</h2>
			<p>Defining UIs<a id="_idIndexMarker152"/> based on constraints has been the most recent preferred approach in Android's traditional <strong class="source-inline">View</strong> world because older layouts such as <strong class="source-inline">RelativeLayout</strong> or <strong class="source-inline">LinearLayout</strong> could impact performance when they're used in large, multiply-nested layouts. <strong class="source-inline">ConstraintLayout</strong> avoids this by flattening the <strong class="source-inline">View</strong> hierarchy. As you will see in the <em class="italic">Understanding the single measure pass</em> section, this is no issue for Jetpack Compose. </p>
			<p>However, for more complex layouts in a Compose app, you may still want to limit the nesting of <strong class="source-inline">Box()</strong>, <strong class="source-inline">Row()</strong>, and <strong class="source-inline">Column()</strong> to make your code simpler and clearer. This is where <strong class="source-inline">ConstraintLayout()</strong> can help.</p>
			<p>The <strong class="source-inline">ConstraintLayoutDemo</strong> sample app is a reimplementation of <strong class="source-inline">PredefinedLayoutsDemo</strong> based on <strong class="source-inline">ConstraintLayout()</strong>. By comparing the two versions, you get a thorough understanding of how this composable function works. To use <strong class="source-inline">ConstraintLayout()</strong> in your app, you need to add a dependency to your module-level <strong class="source-inline">build.gradle</strong> file. Please note that the version number shown here is just an example. You can find the latest version at <a href="https://developer.android.com/jetpack/androidx/versions/all-channel">https://developer.android.com/jetpack/androidx/versions/all-channel</a>:</p>
			<p class="source-code">implementation "androidx.constraintlayout:constraintlayout-compose:1.0.0-rc02"</p>
			<p>So, how do <a id="_idIndexMarker153"/>we define a layout based on constraints? Let's find out by examining the reimplementation of <strong class="source-inline">CheckboxWithLabel()</strong>. It places text next to a checkbox:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun CheckboxWithLabel(</p>
			<p class="source-code">  label: String,</p>
			<p class="source-code">  state: MutableState&lt;Boolean&gt;,</p>
			<p class="source-code">  modifier: Modifier = Modifier</p>
			<p class="source-code">) {</p>
			<p class="source-code">  ConstraintLayout(modifier = modifier.clickable {</p>
			<p class="source-code">    state.value = !state.value</p>
			<p class="source-code">  }) {</p>
			<p class="source-code">    val (checkbox, text) = <strong class="bold">createRefs()</strong></p>
			<p class="source-code">    Checkbox(</p>
			<p class="source-code">      checked = state.value,</p>
			<p class="source-code">      onCheckedChange = {</p>
			<p class="source-code">        state.value = it</p>
			<p class="source-code">      },</p>
			<p class="source-code">      modifier = Modifier.<strong class="bold">constrainAs</strong>(checkbox) {</p>
			<p class="source-code">      }</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">      text = label,</p>
			<p class="source-code">      modifier = Modifier.<strong class="bold">constrainAs</strong>(text) {</p>
			<p class="source-code">        <strong class="bold">start.linkTo(checkbox.end, margin = 8.dp)</strong></p>
			<p class="source-code">        <strong class="bold">top.linkTo(checkbox.top)</strong></p>
			<p class="source-code">        <strong class="bold">bottom.linkTo(checkbox.bottom)</strong></p>
			<p class="source-code">      }</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">ConstraintLayout()</strong> uses a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) to define the location and size of a UI element relative<a id="_idIndexMarker154"/> to other ones. Therefore, each composable in a <strong class="source-inline">ConstraintLayout()</strong> must have a reference associated with it, which is created using <strong class="source-inline">createRefs()</strong>. Constraints are provided using the <strong class="source-inline">constrainAs()</strong> modifier. Its lambda expression receives a <strong class="source-inline">ConstrainScope</strong>. It includes properties such as <strong class="source-inline">start</strong>, <strong class="source-inline">top</strong>, and <strong class="source-inline">bottom</strong>. These are called <strong class="bold">anchors</strong> because <a id="_idIndexMarker155"/>they define a location that can be linked (using <strong class="source-inline">linkTo()</strong>) to the location of another composable.</p>
			<p>Let's look at <strong class="source-inline">Text()</strong>. Its <strong class="source-inline">constrainAs()</strong> contains <strong class="source-inline">bottom.linkTo(checkbox.bottom)</strong>. This means that the bottom of the text is constrained<a id="_idIndexMarker156"/> to the bottom of the checkbox. As the top of the text is linked to the top of the checkbox, the height of the text is equal to the height of the checkbox. The following line means that the start of the text is constrained by the end of the checkbox, with an additional margin of 8 density-independent pixels:</p>
			<p class="source-code">start.linkTo(checkbox.end, margin = 8.dp)</p>
			<p>So, in the direction of reading, the text comes after the checkbox. Next, let's look at <strong class="source-inline">ConstraintLayoutDemo()</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ConstraintLayoutDemo() {</p>
			<p class="source-code">  val red = remember { mutableStateOf(true) }</p>
			<p class="source-code">  val green = remember { mutableStateOf(true) }</p>
			<p class="source-code">  val blue = remember { mutableStateOf(true) }</p>
			<p class="source-code">  ConstraintLayout(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(16.dp)</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    val (cbRed, cbGreen, cbBlue, boxRed, boxGreen, boxBlue) =</p>
			<p class="source-code">            <strong class="bold">createRefs()</strong></p>
			<p class="source-code">    CheckboxWithLabel(</p>
			<p class="source-code">      label = stringResource(id = R.string.red),</p>
			<p class="source-code">      state = red,</p>
			<p class="source-code">      modifier = Modifier.constrainAs(cbRed) {</p>
			<p class="source-code">        <strong class="bold">top.linkTo(parent.top)</strong></p>
			<p class="source-code">      }</p>
			<p class="source-code">    )</p>
			<p class="source-code">    ...</p>
			<p>Once we have <a id="_idIndexMarker157"/>created the references that areneeded to define constraints using <strong class="source-inline">createRefs()</strong>, we add our first <strong class="source-inline">CheckboxWithLabel()</strong>. Its <strong class="source-inline">top</strong> is linked to (constrained by) the <strong class="source-inline">top</strong> of <strong class="source-inline">parent</strong>, which is <strong class="source-inline">ConstraintLayout()</strong>. So, the first checkbox with a label is the topmost one. Here's how the second one, which toggles the green box, is invoked:</p>
			<p class="source-code">CheckboxWithLabel(</p>
			<p class="source-code">  label = stringResource(id = R.string.green),</p>
			<p class="source-code">  state = green,</p>
			<p class="source-code">  modifier = Modifier.constrainAs(cbGreen) {</p>
			<p class="source-code">    top.linkTo(cbRed.bottom)</p>
			<p class="source-code">  }</p>
			<p class="source-code">)</p>
			<p>Its top is constrained by the bottom of the first checkbox with a label (which toggles the red box). Finally, here's how we need to constrain the third <strong class="source-inline">CheckboxWithLabel()</strong>:</p>
			<p class="source-code">modifier = Modifier.constrainAs(cbBlue) {</p>
			<p class="source-code">  top.linkTo(cbGreen.bottom)</p>
			<p class="source-code">}</p>
			<p>To conclude <a id="_idIndexMarker158"/>this section, let me show you how to define the colored boxes. Here's the red one:</p>
			<p class="source-code">if (red.value) {</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .background(Color.Red)</p>
			<p class="source-code">      .constrainAs(boxRed) {</p>
			<p class="source-code">        start.linkTo(parent.start)</p>
			<p class="source-code">        end.linkTo(parent.end)</p>
			<p class="source-code">        top.linkTo(cbBlue.bottom, margin = 16.dp)</p>
			<p class="source-code">        bottom.linkTo(parent.bottom)</p>
			<p class="source-code">        width = Dimension.fillToConstraints</p>
			<p class="source-code">        height = Dimension.fillToConstraints</p>
			<p class="source-code">      }</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Both <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> are linked to the corresponding anchors of <strong class="source-inline">parent</strong> (which is <strong class="source-inline">ConstraintLayout()</strong>). <strong class="source-inline">top</strong> is constrained by <strong class="source-inline">bottom</strong> of the last checkbox, so the red box appears below it. <strong class="source-inline">bottom</strong> of the red box is constrained by <strong class="source-inline">bottom</strong> of <strong class="source-inline">parent</strong>. Please note that currently, we must set <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> to the value that we obtained from <strong class="source-inline">Dimension.fillToConstraints</strong>. Otherwise, the box won't have the correct size.</p>
			<p>Next, let's look at the constraints of the green box:</p>
			<p class="source-code">constrainAs(boxGreen) {</p>
			<p class="source-code">  start.linkTo(parent.start, margin = 32.dp)</p>
			<p class="source-code">  end.linkTo(parent.end, margin = 32.dp)</p>
			<p class="source-code">  top.linkTo(cbBlue.bottom, margin = (<strong class="bold">16</strong> + 32).dp)</p>
			<p class="source-code">  bottom.linkTo(parent.bottom, margin = 32.dp)</p>
			<p class="source-code">  width = Dimension.fillToConstraints</p>
			<p class="source-code">  height = Dimension.fillToConstraints</p>
			<p class="source-code">}</p>
			<p>This code is <a id="_idIndexMarker159"/>practically the same. One difference is that all the sides receive a <strong class="source-inline">margin</strong> of 32 density-independent pixels. This is necessary because we want the red box, which is below the green one, to be visible at the locations of the margin. As the red box already has a <strong class="source-inline">top</strong> margin of 16, we must add this value to the <strong class="source-inline">top</strong> margin. You may be wondering why I am not linking to <strong class="source-inline">boxRed</strong> instead. That is because the red box will not be present if its corresponding checkbox is not checked. In this case, the anchor would not be there.</p>
			<p>Here's what the constraints for the blue box will look like:</p>
			<p class="source-code">constrainAs(boxBlue) {</p>
			<p class="source-code">  start.linkTo(parent.start, margin = 64.dp)</p>
			<p class="source-code">  end.linkTo(parent.end, margin = 64.dp)</p>
			<p class="source-code">  top.linkTo(cbBlue.bottom, margin = (16 + 64).dp)</p>
			<p class="source-code">  bottom.linkTo(parent.bottom, margin = 64.dp)</p>
			<p class="source-code">  width = Dimension.fillToConstraints</p>
			<p class="source-code">  height = Dimension.fillToConstraints</p>
			<p class="source-code">}</p>
			<p>The only thing I needed to change is the margin on all four sides because otherwise, the box below (the green one) would not be visible.</p>
			<p>In a nutshell, this is how <strong class="source-inline">ConstrainLayout()</strong> works:</p>
			<ul>
				<li>You constrain a composable by linking its anchors to other ones</li>
				<li>The linking is based on references. To setup these references, you must call <strong class="source-inline">createRefs()</strong>.</li>
			</ul>
			<p>The main<a id="_idIndexMarker160"/> advantage of combining <strong class="source-inline">Box()</strong>, <strong class="source-inline">Row()</strong>, and <strong class="source-inline">Column()</strong> is that you flatten your UI element hierarchy. Think of it like this: in <strong class="source-inline">PredefinedLayoutsDemo</strong>, I needed to stack the colored boxes in a parent <strong class="source-inline">Box()</strong>. In <strong class="source-inline">ConstrainLayoutDemo</strong>, the boxes and the three <strong class="source-inline">CheckboxWithLabel()</strong> share the same parent (a <strong class="source-inline">ConstrainLayout()</strong>). This reduces the number of composables and makes the code cleaner.</p>
			<p>In the next section, we will once again peek inside the internals of Jetpack Compose. We will learn how the layout process works and why it is more efficient than the traditional View-based approach.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor083"/>Understanding the single measure pass</h1>
			<p>Laying out a UI element hierarchy <a id="_idIndexMarker161"/>means determining the sizes of all the elements and positioning them on the screen based on the layout strategy of their parent. At first, getting the size of, say, some text doesn't sound too complicated. After all, isn't it determined by the font and the text to be output? Here's an example, with two pieces of text laid out in a <strong class="source-inline">Column()</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun ColumnWithTexts() {</p>
			<p class="source-code">  Column {</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">      text = "Android UI development with Jetpack Compose",</p>
			<p class="source-code">      style = MaterialTheme.typography.h3</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">      text = "Hello Compose",</p>
			<p class="source-code">      style = MaterialTheme</p>
			<p class="source-code">          .typography.h5.merge(TextStyle(color = Color.Red))</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>If you deploy the preview, you will notice that, in portrait mode, the first text requires more space vertically than in landscape mode. The second text always fits into one line. The size that a composable takes on-screen partially depends on the conditions that have been imposed from <em class="italic">outside</em>. Here, the maximum width of the column (the parent) influences the height<a id="_idIndexMarker162"/> of the first piece of text. Such conditions are <a id="_idIndexMarker163"/>called <strong class="bold">constraints</strong>. You will see them in action in the <em class="italic">Creating custom layouts</em> section. Please note that they are not the same as the constraints you use in <strong class="source-inline">ConstraintLayout()</strong>.</p>
			<p>Once a layout has obtained and measured the size of its content, the layout will position its children (the content). Let's see how this works by looking at the source code of <strong class="source-inline">Column()</strong>:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="Images/B17505_04_02.jpg" alt="Figure 4.2 – Source code of Column()&#13;&#10;" width="759" height="294"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Source code of Column()</p>
			<p>The composable is <a id="_idIndexMarker164"/>very short. Besides assigning a value to <strong class="source-inline">measurePolicy</strong>, it only invokes <strong class="source-inline">Layout()</strong>, passing <strong class="source-inline">content</strong>, <strong class="source-inline">measurePolicy</strong>, and <strong class="source-inline">modifier</strong>. We briefly looked at the source code of <strong class="source-inline">Layout()</strong> in the <em class="italic">Emitting UI elements</em> section of <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, to understand what it means to emit UI elements. Now, we'll focus on the layout process. The <strong class="source-inline">measurePolicy</strong> variable references an implementation of the <strong class="source-inline">MeasurePolicy</strong> interface. In this case, it's the result of a call to <strong class="source-inline">columnMeasurePolicy()</strong>.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor084"/>Defining measure policies</h2>
			<p>Depending on<a id="_idIndexMarker165"/> the values of <strong class="source-inline">verticalArrangement</strong> and <strong class="source-inline">horizontalAlignment</strong>, the call to <strong class="source-inline">columnMeasurePolicy()</strong> returns either <strong class="source-inline">DefaultColumnMeasurePolicy</strong> (a variable) or the result of <strong class="source-inline">rowColumnMeasurePolicy()</strong>. <strong class="source-inline">DefaultColumnMeasurePolicy</strong> calls <strong class="source-inline">rowColumnMeasurePolicy</strong>. Therefore, this function defines the measure policy for any <strong class="source-inline">Column()</strong>. It returns a <strong class="source-inline">MeasurePolicy</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Please remember that you can look at the source code of a policy by pressing the <em class="italic">Ctrl</em> key and clicking on a name, such as <strong class="source-inline">columnMeasurePolicy</strong>.</p>
			<p><strong class="source-inline">MeasurePolicy</strong> belongs to the <strong class="source-inline">androidx.compose.ui.layout</strong> package. It defines how a layout is measured and laid out, so it is the main building block for both predefined (for example, <strong class="source-inline">Box()</strong>, <strong class="source-inline">Row()</strong>, and <strong class="source-inline">Column()</strong>) and custom layouts. Its most important function is <strong class="source-inline">measure()</strong>, which is an extension function of <strong class="source-inline">MeasureScope</strong>. This function receives two parameters, <strong class="source-inline">List&lt;Measurable&gt;</strong> and <strong class="source-inline">Constraints</strong>. The elements of the list represent the children of the layout. They can be measured using <strong class="source-inline">Measurable.measure()</strong>. This function returns an instance of <strong class="source-inline">Placeable</strong>, a representation of the size a child wants to span.</p>
			<p><strong class="source-inline">MeasureScope.measure()</strong> returns an instance of <strong class="source-inline">MeasureResult</strong>. This interface defines the following components:</p>
			<ul>
				<li>The size of a layout (<strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>)</li>
				<li>Alignment lines (<strong class="source-inline">alignmentLines</strong>)</li>
				<li>Logic to position the children (<strong class="source-inline">placeChildren()</strong>)</li>
			</ul>
			<p>You can find an implementation of <strong class="source-inline">MeasureResult</strong> in the <em class="italic">Creating custom layouts</em> section.</p>
			<p>Alignment lines<a id="_idIndexMarker166"/> define an offset line that can be used by parent layouts to align and position their children. For example, text baselines are alignment lines.</p>
			<p>Depending on the complexity of the UI, a layout may find that its children do not fit nicely in its boundaries. The layout may want to remeasure the children, passing different measurement configurations. Remeasuring children is possible in the Android <strong class="source-inline">View</strong> system, but this can lead to decreased performance. Therefore, in Jetpack Compose, a layout may measure its content only once. If it tries again, an exception will be thrown.</p>
			<p>A layout can, however, query the <strong class="bold">intrinsic size</strong> of its children and use it for sizing and positioning. <strong class="source-inline">MeasurePolicy</strong> defines four extension functions of <strong class="source-inline">IntrinsicMeasureScope</strong>. <strong class="source-inline">minIntrinsicWidth()</strong> and <strong class="source-inline">maxIntrinsicWidth()</strong> return the minimum or maximum width of a layout, given a particular height, so that the content of the layout can be painted completely. <strong class="source-inline">minIntrinsicHeight()</strong> and <strong class="source-inline">maxIntrinsicHeight()</strong> return the minimum or maximum height of a layout given a particular width so that the content of the layout can be painted completely. To get an idea of how they work, let's briefly look at one of them:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="Images/B17505_04_03.jpg" alt="Figure 4.3 – Source code of minIntrinsicWidth()&#13;&#10;" width="814" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Source code of minIntrinsicWidth()</p>
			<p><strong class="source-inline">IntrinsicMeasureScope.minIntrinsicWidth()</strong> receives two parameters: <strong class="source-inline">height</strong> and a list of children (<strong class="source-inline">measurables</strong>). The <strong class="source-inline">IntrinsicMeasurable</strong> interface defines <a id="_idIndexMarker167"/>four functions that obtain the minimum or maximum values for a particular element (<strong class="source-inline">minIntrinsicWidth()</strong>, <strong class="source-inline">maxIntrinsicWidth()</strong>, <strong class="source-inline">minIntrinsicHeight()</strong>, and <strong class="source-inline">maxIntrinsicHeight()</strong>). Each element of <strong class="source-inline">measurables</strong> is converted into an instance of <strong class="source-inline">DefaultIntrinsicMeasurable</strong>. As this class implements the <strong class="source-inline">Measurable</strong> interface, it provides an implementation of <strong class="source-inline">measure()</strong>. It returns <strong class="source-inline">FixedSizeIntrinsicsPlaceable</strong>, which provides the smallest possible width for a given <strong class="source-inline">height</strong>. The converted children are measured by an instance of <strong class="source-inline">IntrinsicsMeasureScope</strong>.</p>
			<p>We'll finish looking at the internals of the Compose layout process by turning to <strong class="source-inline">Constraints</strong>. They are, for example, passed to <strong class="source-inline">MeasureScope.measure()</strong>. The class belongs to the <strong class="source-inline">androidx.compose.ui.unit</strong> package. It stores four values: <strong class="source-inline">minWidth</strong>, <strong class="source-inline">minHeight</strong>, <strong class="source-inline">maxWidth</strong>, and <strong class="source-inline">maxHeight</strong>. They define the minimum and maximum values the children of a layout must honor when measuring themselves. So, their width must be no smaller than <strong class="source-inline">minWidth</strong> and no larger than <strong class="source-inline">maxWidth</strong>. Their height must lie within <strong class="source-inline">minHeight</strong> and <strong class="source-inline">maxHeight</strong>.</p>
			<p>The companion object defines the <strong class="source-inline">Infinity</strong> constant. It is used to signal that the constraint should be considered infinite. To create a <strong class="source-inline">Constraints</strong> instance, you can invoke the top-level <strong class="source-inline">Constraints()</strong> function.</p>
			<p>This was a lot of information. Before moving on, let's recap what we have learned.</p>
			<ul>
				<li>The <strong class="source-inline">Layout()</strong> composable receives three parameters: the content, the measure policy, and a modifier.</li>
				<li>The measure policy defines how a layout is measured and laid out.</li>
				<li>The intrinsic size of a layout determines the minimum or maximum dimension for the corresponding input.</li>
			</ul>
			<p>In the traditional<a id="_idIndexMarker168"/> View system, a parent view may call the <strong class="source-inline">measure()</strong> method more than once on its children (please refer to <a href="https://developer.android.com/guide/topics/ui/how-android-draws">https://developer.android.com/guide/topics/ui/how-android-draws</a> for details). On the other hand, Jetpack Compose requires that children must be measured <em class="italic">exactly once</em> before they are positioned. This results in a more performant measurement.</p>
			<p>In the next section, we will make use of this knowledge by implementing a simple custom layout. It will position its children from left to right and from top to bottom. When one row is filled, the next one will be started below it.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor085"/>Creating custom layouts</h1>
			<p>Sometimes, you may<a id="_idIndexMarker169"/> want to lay children out one after another in a row and start a new row when the current one has been filled. The <strong class="source-inline">CustomLayoutDemo</strong> sample app, as shown in the following screenshot, shows you how to do this. It creates 43 randomly colored boxes that vary in width and height:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/B17505_04_04.jpg" alt="Figure 4.4 – Sample CustomLayoutDemo app&#13;&#10;" width="1347" height="622"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Sample CustomLayoutDemo app</p>
			<p>Let's start by<a id="_idIndexMarker170"/> looking at the composable function that creates colored boxes:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ColoredBox() {</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .border(</p>
			<p class="source-code">        width = 2.dp,</p>
			<p class="source-code">        color = Color.Black</p>
			<p class="source-code">      )</p>
			<p class="source-code">      .background(randomColor())</p>
			<p class="source-code">      .width((40 * randomInt123()).dp)</p>
			<p class="source-code">      .height((10 * randomInt123()).dp)</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>A colored box consists of a <strong class="source-inline">Box()</strong> with a black, two density-independent pixels wide border. The <strong class="source-inline">width()</strong> and <strong class="source-inline">height()</strong> modifiers set the preferred size of the box. This means that the layout could <a id="_idIndexMarker171"/>override it. For simplicity, my example doesn't. <strong class="source-inline">randomInt123()</strong> randomly returns either <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, or <strong class="source-inline">3</strong>:</p>
			<p class="source-code">private fun randomInt123() = Random.nextInt(1, 4)</p>
			<p><strong class="source-inline">randomColor()</strong> randomly returns red, green, or blue:</p>
			<p class="source-code">private fun randomColor() = when (randomInt123()) {</p>
			<p class="source-code">    1 -&gt; Color.Red</p>
			<p class="source-code">    2 -&gt; Color.Green</p>
			<p class="source-code">    else -&gt; Color.Blue</p>
			<p class="source-code">}</p>
			<p>Next, I'll show you how the colored boxes are created and set as the content of my custom layout:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun CustomLayoutDemo() {</p>
			<p class="source-code">    SimpleFlexBox {</p>
			<p class="source-code">        for (i in 0..42) {</p>
			<p class="source-code">            ColoredBox()</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">SimpleFlexBox()</strong> is our custom layout. It is used like any predefined layout. You can even provide a modifier (which has not been done here for simplicity). So, how does the custom layout work? Let's find out:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun SimpleFlexBox(</p>
			<p class="source-code">  modifier: Modifier = Modifier,</p>
			<p class="source-code">  content: @Composable () -&gt; Unit</p>
			<p class="source-code">) {</p>
			<p class="source-code">  Layout(</p>
			<p class="source-code">    modifier = modifier,</p>
			<p class="source-code">    content = content,</p>
			<p class="source-code">    measurePolicy = simpleFlexboxMeasurePolicy()</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Custom <a id="_idIndexMarker172"/>layouts should receive at least two parameters – <strong class="source-inline">content</strong> and a <strong class="source-inline">modifier</strong> with a default value of <strong class="source-inline">Modifier</strong>. Additional parameters may influence the behavior of your custom layout. For example, you may want to make the alignment of children configurable. For simplicity, the example does not do so.</p>
			<p>As you know from the previous section, measurement and positioning are defined through a measure policy. I will show you how to implement one in the next section.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor086"/>Implementing a custom measure policy</h2>
			<p>At this point, I have <a id="_idIndexMarker173"/>shown you almost all the code for the custom layout. The only thing that's missing is the measure policy. Let's see how it works:</p>
			<p class="source-code">private fun simpleFlexboxMeasurePolicy(): MeasurePolicy =</p>
			<p class="source-code">  MeasurePolicy { measurables, constraints -&gt;</p>
			<p class="source-code">    val placeables = measurables.map { measurable -&gt;</p>
			<p class="source-code">      measurable.measure(constraints)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    layout(</p>
			<p class="source-code">      constraints.maxWidth,</p>
			<p class="source-code">      constraints.maxHeight</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">      var yPos = 0</p>
			<p class="source-code">      var xPos = 0</p>
			<p class="source-code">      var maxY = 0</p>
			<p class="source-code">      placeables.forEach { placeable -&gt;</p>
			<p class="source-code">        if (xPos + placeable.width &gt;</p>
			<p class="source-code">          constraints.maxWidth</p>
			<p class="source-code">        ) {</p>
			<p class="source-code">          xPos = 0</p>
			<p class="source-code">          yPos += maxY</p>
			<p class="source-code">          maxY = 0</p>
			<p class="source-code">        }</p>
			<p class="source-code">        placeable.placeRelative(</p>
			<p class="source-code">          x = xPos,</p>
			<p class="source-code">          y = yPos</p>
			<p class="source-code">        )</p>
			<p class="source-code">        xPos += placeable.width</p>
			<p class="source-code">        if (maxY &lt; placeable.height) {</p>
			<p class="source-code">          maxY = placeable.height</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p><strong class="source-inline">MeasurePolicy</strong> implementations must provide implementations of <strong class="source-inline">MeasureScope.measure()</strong>. This function returns an instance of the <strong class="source-inline">MeasureResult</strong> interface. You do not need to implement this on your own. Instead, you must invoke <strong class="source-inline">layout()</strong>. This function belongs to <strong class="source-inline">MeasureScope</strong>.</p>
			<p>We pass <a id="_idIndexMarker174"/>the measured size of the layout and a <strong class="source-inline">placementBlock</strong>, which is an extension function of <strong class="source-inline">Placeable.PlacementScope</strong>. This means that you can invoke functions such as <strong class="source-inline">placeRelative()</strong> to position a child in its parent's coordinate system.</p>
			<p>A measure policy receives the content, or children, as <strong class="source-inline">List&lt;Measurable&gt;</strong>. As you know from the <em class="italic">Understanding the sing<a id="_idTextAnchor087"/>le measure pass</em> section, children must be measured exactly once before they are positioned. We can do this by creating a map of <strong class="source-inline">placeables</strong>, invoking <strong class="source-inline">measure()</strong> on each <strong class="source-inline">measurable</strong>. My example doesn't constrain child views further, instead measuring them with the given constraints.</p>
			<p><strong class="source-inline">placementBlock</strong> iterates over the <strong class="source-inline">placeables</strong> map, calculating the location of a placeable by increasing <strong class="source-inline">xPos</strong> and <strong class="source-inline">yPos</strong> along the way. Before invoking <strong class="source-inline">placeRelative()</strong>, the algorithm checks if a placeable completely fits into the current row. If this is not the case, <strong class="source-inline">yPos</strong> will be increased and <strong class="source-inline">xPos</strong> will be reset to <strong class="source-inline">0</strong>. How much <strong class="source-inline">yPos</strong> will be increased depends on the maximum height of all the placeables in the current row. This value is stored in <strong class="source-inline">maxY</strong>.</p>
			<p>As you have seen, implementing simple custom layouts is straightforward. Advanced topics such as alignment lines (which help with/are needed for X...) are beyond the scope of this book. You can find more information about them at <a href="https://developer.android.com/jetpack/compose/layouts/alignment-lines">https://developer.android.com/jetpack/compose/layouts/alignment-lines</a>.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor088"/>Summary</h1>
			<p>This chapter explored the predefined layouts of <strong class="source-inline">Row()</strong>, <strong class="source-inline">Column()</strong>, and <strong class="source-inline">Box()</strong>. You learned how to combine them to create beautiful UIs. You were also introduced to <strong class="source-inline">ConstraintLayout</strong>, which places composables that are relative to others on the screen and flattens the UI element hierarchy.</p>
			<p>The second main section explored why the layout system in Jetpack Compose is more performant than the traditional View-based approach. We looked at some of the internals of the Compose runtime, which prepared us for the final main section of this chapter, <em class="italic">Creating custom layouts</em>, where you learned how to create a custom layout and thus gain precise control over the rendering of its children.</p>
			<p>The next chapter, <em class="italic">Managing the State of Your Composable Functions</em>, will deepen your knowledge of state. We will examine the difference between stateless and stateful composable functions. Also, we will look at advanced use cases such as surviving configuration changes.</p>
		</div>
	</div></body></html>