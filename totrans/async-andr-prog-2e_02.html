<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Performing Work with Looper, Handler, and HandlerThread"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Performing Work with Looper, Handler, and HandlerThread</h1></div></div></div><p>In the previous chapter, you were introduced to the most basic concurrent issues that a developer might face while developing a responsive and concurrent Android application. As the most interactable items run on the main thread, it is crucial to coordinate the backgrounds code to handle the work without any UI stuttering that compromises the user experience.</p><p>In this chapter, we will meet some of most fundamental constructs used on Android systems to perform tasks and schedule on a main thread or an ordinary background thread created by the developer to perform and schedule tasks long-running operations.</p><p>We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding Looper</li><li class="listitem" style="list-style-type: disc">Understanding Handler</li><li class="listitem" style="list-style-type: disc">Sending work to Looper</li><li class="listitem" style="list-style-type: disc">Scheduling work with post</li><li class="listitem" style="list-style-type: disc">Using Handler to defer work</li><li class="listitem" style="list-style-type: disc">Leaking implicit references</li><li class="listitem" style="list-style-type: disc">Leaking explicit references</li><li class="listitem" style="list-style-type: disc">Updating the UI with Handler</li><li class="listitem" style="list-style-type: disc">Canceling pending messages</li><li class="listitem" style="list-style-type: disc">Multithreading with Handler and HandlerThread</li><li class="listitem" style="list-style-type: disc">Applications of Handler and HandlerThread</li></ul></div><div class="section" title="Understanding Looper"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Understanding Looper</h1></div></div></div><p>Before we <a id="id81" class="indexterm"/>can understand <code class="literal">Looper</code>, we need to understand where it gets its name from.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>A loop is a group of instructions that are repeated continually until a termination condition is met.</p></div></div><p>Following this definition, Android's <code class="literal">Looper</code> executes on a thread that has a <code class="literal">MessageQueue</code>, executes a continuous loop waiting for work, and blocks when there is no work pending. When work is submitted to its queue, it dispatches it to the target <code class="literal">Handler</code> defined explicitly on the <code class="literal">Message</code> object.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>A message is a notification object containing a description and arbitrary data object that can be sent to a Handler.</p></div></div><p>The Looper on Android is an implementation of a common UI programming concept known as an event loop. Later, at the end of this processing sequence, the <code class="literal">Handler</code> will process the <code class="literal">Message</code> and execute your domain logic in order to solve an application user problem.</p><p>The <code class="literal">Looper</code> sequence on <a id="id82" class="indexterm"/>Android follows these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Wait until a Message is retrieved from its MessageQueue</li><li class="listitem">If logging is enabled, print dispatch information</li><li class="listitem">Dispatch the message to the target Handler</li><li class="listitem">Recycle the Message</li><li class="listitem">Go to step 1</li></ol></div><p>As mentioned on the previous chapter, the main thread implicitly creates its own <code class="literal">Looper</code> to sequentially process all that is needed to keep the application running and to manage the interaction between the application components.</p><p>To access the main thread's Looper you want access to the main thread's <code class="literal">Looper</code> instance, use the static method <code class="literal">getMainLooper()</code>:</p><div class="informalexample"><pre class="programlisting">Looper mainLooper = Looper.getMainLooper();</pre></div><p>To set up our own <code class="literal">Looper</code> thread, we need to invoke two static methods of <code class="literal">Looper</code>—<code class="literal">prepare</code> and <code class="literal">loop</code>—from within the thread, and they will handle the continuous loop. Here is a simple example:</p><div class="informalexample"><pre class="programlisting">class SimpleLooper extends Thread {

       public void run() {
        // Attach a Looper to the current Thread
           Looper.prepare();
        // Start the message processing
           Looper.loop();
       }
}</pre></div><p>In the snippet, when the <code class="literal">SimpleLopper</code> object is created and started by invoking the <code class="literal">start()</code> method, a new thread is created in the current application process, and <code class="literal">run()</code> is automatically called inside the new thread. When the <code class="literal">run()</code> method is called, we attach a <code class="literal">Looper</code> to the<a id="id83" class="indexterm"/> current thread when we invoke the static <code class="literal">Looper.prepare()</code> method. Following that, we start processing messages when <code class="literal">loop()</code> is called. The <code class="literal">prepare()</code> method is responsible for initializing the <code class="literal">MessageQueue</code> and attaching the queue as a <code class="literal">ThreadLocal</code> parameter to the current thread.</p><p>When <code class="literal">loop()</code> is invoked, the <code class="literal">run()</code> method will block until the looper is interrupted to process new messages be added to the queue.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>
<code class="literal">Looper.prepare()</code> must only be called once from within the same thread; otherwise, a <code class="literal">RuntimeException</code> will to be thrown that says only one looper may be created per thread.</p></div></div><p>When we want to stop the continuous <code class="literal">Looper</code> execution, we can either invoke its member function <code class="literal">quit()</code> to stop it without processing the remaining messages in its queue or <code class="literal">quitSafely()</code> to process the remaining work on the queue and stop.</p><div class="section" title="Understanding Handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Understanding Handler</h2></div></div></div><p>Together with <code class="literal">Looper</code>, the <code class="literal">Handler</code> class is fundamental to the infrastructure of Android apps. It underpins everything<a id="id84" class="indexterm"/> that the main thread does—including the invocation of the <code class="literal">Activity</code> lifecycle methods.</p><p>While <code class="literal">Looper</code> takes care of dispatching work on its message-loop thread, <code class="literal">Handler</code> serves two purposes: providing an interface to submit messages to its <code class="literal">Looper</code> queue, and implementing the callback for processing those messages when they are dispatched by the <code class="literal">Looper</code>.</p><p>It is also import to know that each <code class="literal">Handler</code> is bound to a single <code class="literal">Looper</code> and, by extension, to one thread and its looper <code class="literal">MessageQueue</code>.</p><p>To bind to the <code class="literal">Looper</code> of the current thread, we need to instantiate it over the default <code class="literal">Handler()</code> constructor <a id="id85" class="indexterm"/>after we initialize the <code class="literal">Looper </code>by calling the <code class="literal">prepare</code> method. Since we create our handler inside our <code class="literal">SimpleLooper</code> thread over the default constructor <code class="literal">Handler()</code>, <code class="literal">myHandler</code> will be attached to the current thread's <code class="literal">Looper</code> instead of the main thread's <code class="literal">Looper</code>:</p><div class="informalexample"><pre class="programlisting">public class SimpleLooper extends Thread{

    private Handler myHandler;

    @Override
    public void run() {
        Looper.prepare();
        myHandler  =  new MyHandler();
        Looper.loop();
    }
   
    public Handler getHandler(){
        return myHandler;
    }
}</pre></div><p>Apart from providing an interface to submit work to <code class="literal">Looper</code> threads, <code class="literal">Handler</code> also defines the code that process the messages submitted. In the following code, the <code class="literal">MyHandler</code> class overrides the superclass' (<code class="literal">Handler</code>)<code class="literal"> handleMessage</code> member method to define our message-handling code:</p><div class="informalexample"><pre class="programlisting">public class MyHandler extends Handler {

    @Override
    public void handleMessage(Message msg) {
        // Add here your message handling
       // processing
    }
}</pre></div><p>Once started, the <code class="literal">Looper</code> thread will wait inside <code class="literal">Looper.loop()</code> for messages to be added to its queue.</p><p>When another thread adds a <code class="literal">Message</code> to the queue using the <code class="literal">submit</code> method, the waiting thread will then dispatch the<a id="id86" class="indexterm"/> message to our target <code class="literal">MyHandler</code> by invoking the handler's <code class="literal">handleMessage()</code> method.</p><p>With the <code class="literal">Handler</code> object reference in hand, we are able to able to send messages to the <code class="literal">Handler</code> from any thread, and as a consequence, it is always dispatched to the <code class="literal">Looper</code> thread and handled by the correct <code class="literal">Handler</code>, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/Image_B05062_02_01.jpg" alt="Understanding Handler"/><div class="caption"><p>Figure 2.1: Posting work to other Threads</p></div></div><p>We already saw that we can create our own <code class="literal">Looper</code> threads, but as detailed and mentioned before, the main thread is in also a <code class="literal">Looper</code> thread. To make it more clear, we are going to create a <code class="literal">StackTraceHandler</code> that prints the stack trace of the current thread:</p><div class="informalexample"><pre class="programlisting">public class StackTraceHandler extends Handler {

    @Override
    public void handleMessage(Message msg) {
       // Prints the Stack Trace on the Android Log
       Thread.currentThread().dumpStack();
    }
}</pre></div><p>Since the activity's <code class="literal">onCreate()</code> function runs on the main thread, we will create an instance of our handler that implicitly calls the handler's super constructor, which binds the handler to the current thread's <code class="literal">Looper</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>If the current thread does not have a Looper and we try to create a handler over the super constructor, a runtime exception with the message <span class="strong"><strong>Can't create handler inside thread that has not called Looper.prepare()</strong></span> is thrown.</p></div></div><p>With the <code class="literal">Handler</code> instance<a id="id87" class="indexterm"/> created, we retrieve a message from its recycled messages pool by calling the handler's <code class="literal">obtainMessage</code>, and we post an empty message to the main thread's <code class="literal">Looper</code>. The messages obtained by <code class="literal">obtainMessage</code> are cached and will also set the handler as the destination's <code class="literal">Handler</code> object:</p><div class="informalexample"><pre class="programlisting">public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ...
    Handler handler = new StackTraceHandler();
    Message msg = handler.obtainMessage();
    handler.sendMessage(msg);
}</pre></div><p>As mentioned before, when our <code class="literal">handleMessage()</code> gets dispatched it prints active stack frames at the time of the <code class="literal">handleMessage()</code> execution, as we can see in the following stack trace:</p><div class="informalexample"><pre class="programlisting">.....StackTraceHandler.handleMessage(StackTraceHandler.java:18)
android.os.Handler.dispatchMessage(Handler.java:99)
android.os.Looper.loop(Looper.java:137)
<span class="strong"><strong>android.app.ActivityThread.main(ActivityThread.java:4424)</strong></span>
java.lang.reflect.Method.invokeNative(Native Method)
java.lang.reflect.Method.invoke(Method.java:511)</pre></div><p>That's right, <code class="literal">handleMesage()</code> is running<a id="id88" class="indexterm"/> in the <code class="literal">dispatchMessage()</code> call invoked by the main <code class="literal">Looper</code>, and it is dispatched to the main thread's line of execution.</p></div><div class="section" title="Sending work to a Looper"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Sending work to a Looper</h2></div></div></div><p>Previously, the <code class="literal">StackTraceHandler</code> was implicitly bound to the current main thread's <code class="literal">Looper</code>, so to make it flexible, let's take<a id="id89" class="indexterm"/> the next step and make it attachable to any <code class="literal">Looper</code>.</p><p>In the following code, we are going to override the default <code class="literal">Handler</code> constructor and define a constructor that accepts the <code class="literal">Looper</code> that is going to the queue, and we will then process and dispatch the message:</p><div class="informalexample"><pre class="programlisting">public class StackTraceHandler extends Handler {

    StackTraceHandler(Looper looper){
        super(looper);
    }</pre></div><p>Our new constructor basically attaches the Handler to the <code class="literal">Looper</code> passed as an argument, making the <code class="literal">StackTraceHandler</code> attachable to any <code class="literal">Looper</code> instead of the current thread's<code class="literal"> Looper</code>.</p><p>Our <code class="literal">SimpleLooper</code> was also extended to provide a <code class="literal">getter</code> method to retrieve the <code class="literal">Looper</code> object associated with its thread:</p><div class="informalexample"><pre class="programlisting">public class SimpleLooper extends Thread{
    // start condition
    boolean started = false;
    Object startMonitor =  new Object();
    Looper threadLooper = null;

    @Override
    public void run() {
        Looper.prepare();
        threadLooper = Looper.myLooper();
        synchronized (startMonitor){
            started = true;
            startMonitor.notifyAll();
        }
        Looper.loop();
    }

    Looper getLooper(){
        return threadLooper;
    }
    // Threads could wait here for the Looper start
    void waitforStart(){
         synchronized (startMonitor){
             while (!started){
                 try {
                    startMonitor.wait(10);
                 } catch (InterruptedException e) {
                    ...
                 }
             }
          }
     }</pre></div><p>Now, from the main<a id="id90" class="indexterm"/> thread, we start the <code class="literal">SimpleLooper</code> and its own thread, and when it starts up, we get the <code class="literal">Looper</code> instance to bind our <code class="literal">Handler</code> to the <code class="literal">SimpleLooper</code> thread and <code class="literal">Looper</code>:</p><div class="informalexample"><pre class="programlisting">SimpleLooper looper = new SimpleLooper();
looper.start();
looper.waitforStart();
Handler handler = new StackTraceHandler(looper.getLooper());</pre></div><p>Now, we are going to send the message, as we did in the previous example, from the activity's <code class="literal">onCreate()</code> callback, which runs in the main thread:</p><div class="informalexample"><pre class="programlisting">Message msg = handler.obtainMessage();
handler.sendMessage(msg);</pre></div><p>As we can see in the following stack trace, the thread stack frame at the bottom points to <code class="literal">SimpleLooper.run()</code>, and at the top of the stack trace, we have our <code class="literal">Handler</code> callback, <code class="literal">StackTraceHandler.handleMessage</code>:</p><div class="informalexample"><pre class="programlisting">at...activity.StackTraceHandler.handleMessage(StackTraceHandler.java:18)
at android.os.Handler.dispatchMessage(Handler.java:99)
at android.os.Looper.loop(Looper.java:137)
at ...activity.SimpleLooper.run(SimpleLooper.java:23)</pre></div><p>The interesting thing to realize here is that we can send messages from the main thread to the background thread managed by <code class="literal">SimpleLooper</code> (or even from the background thread to the main thread) and, in doing so, hand over work from background threads to the main thread—for example, to <a id="id91" class="indexterm"/>have it update the user interface with the results of background processing.</p></div><div class="section" title="Scheduling work with post"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Scheduling work with post</h2></div></div></div><p>As we discussed in the previous <a id="id92" class="indexterm"/>paragraph, we can submit work to the main or background thread by passing a reference to a <code class="literal">Looper</code> instance into the <code class="literal">Handler</code> constructor.</p><p>Exactly what we mean by work can be described by the subclasses of <code class="literal">java.lang.Runnable</code> or instances of <code class="literal">android.os.Message</code>. We can post runnables to a <code class="literal">Handler</code> instance or send messages to it, and it will add them to the <code class="literal">MessageQueue</code> belonging to the associated <code class="literal">Looper</code> instance.</p><p>We can post work to a <code class="literal">Handler</code> quite easily, for example, by creating an anonymous inner runnable:</p><div class="informalexample"><pre class="programlisting">final TextView myTextView = (TextView) findViewById(R.id.myTv);
// Get the main thread Looper by calling the Context
// function getMainLooper
Handler handler = new Handler(getMainLooper());

handler.post(new Runnable(){
    public void run() {
        String result = processSomething();
        myTextView.setText(result);
    }
});</pre></div><p>The <code class="literal">Looper</code> instance to which the <code class="literal">Handler</code> is bound works its way through the queue, executing each <code class="literal">Runnable</code> as soon as possible. Posting with the <code class="literal">post</code> method simply adds a new <code class="literal">Runnable</code> at the end of the queue.</p><p>If we want our runnable to take priority over anything currently in the queue, we can post it to the front of the queue, ahead of existing work:</p><div class="informalexample"><pre class="programlisting">handler.postAtFrontOfQueue(new Runnable(){
public void run() {
      ...
   }
});</pre></div><p>In a single-threaded app, it might seem as if there isn't a whole lot to be gained from posting work to the main thread like this, but breaking things down into small tasks that can be interleaved and potentially reordered is very useful for maintaining responsiveness.</p><p>Moreover, with the<a id="id93" class="indexterm"/> encapsulation of work into more fine-grained units of work, we encourage the reuse of components, improve the testability of the code, and increase the aptitude for work composition:</p><div class="mediaobject"><img src="graphics/Image_B05062_02_02.jpg" alt="Scheduling work with post"/><div class="caption"><p>Figure 2.2: Runnable composition</p></div></div></div><div class="section" title="Using Handler to defer work"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Using Handler to defer work</h2></div></div></div><p>When we use the normal <code class="literal">post</code> work function, the work is processed as soon as all the previous units of work are <a id="id94" class="indexterm"/>processed on the <code class="literal">Looper</code>—but what happens if we want to schedule some work in 10 seconds' time?</p><p>Using <code class="literal">Thread.sleep</code> to block the main thread for 10 seconds would mean that we are holding up the main thread from doing other work, and we are guaranteed to get an ANR dialog. The alternative is to use the handler functions that supply us with deferring functionality:</p><div class="informalexample"><pre class="programlisting">public class MyRunnable implements Runnable {

    @Override
    public void run() {
        // do some work
    }
};
// Defer work in the main Thread
// by 10 seconds time
   handler.postDelayed(new MyRunnable(), TimeUnit.SECONDS.toMillis(10));</pre></div><p>We can still post additional work for execution in the meantime, and our delayed <code class="literal">Runnable</code> instance will execute after the specified delay. Note that we're using the <code class="literal">TimeUnit</code> class from the <code class="literal">java.lang.concurrent</code> package to convert seconds to milliseconds.</p><p>A further scheduling <a id="id95" class="indexterm"/>option for posted work is <code class="literal">postAtTime</code>, which schedules <code class="literal">Runnable</code> to execute at a particular time relative to the system uptime (how long it has been since the system booted):</p><div class="informalexample"><pre class="programlisting">// Work to be run at a specific time
handler.postAtTime(new MyRunnable(),
                   SystemClock. uptimeMillis() +
                   TimeUnit.SECONDS.toMillis(10));</pre></div><p>Since <code class="literal">postAtTime()</code> is implemented in terms of an offset from the <code class="literal">SystemClock</code> uptime, the scheduling could suffer from some delay issues, especially if the device has recently fallen in some deep-sleep states. Taking this into account, and when timing accuracy is required, it is usually better to use <code class="literal">handler.postDelayed</code> to defer work.</p></div><div class="section" title="Leaking implicit references"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Leaking implicit references</h2></div></div></div><p>Deferring work with <code class="literal">Handler</code> and anonymous or nonstatic nested classes requires care in order to avoid potential resource leakage. In these cases, the object submitted to the handler usually creates a reference to the class where it was defined or created. Since the Looper message queue <a id="id96" class="indexterm"/>will keep the <code class="literal">Runnable</code> object alive until the scheduled time, an indirect reference to the original Android component could prevent an entire component and its objects from being garbage-collected.</p><p>Let's look at this issue with the following examples:</p><div class="informalexample"><pre class="programlisting">public class MyActivity extends Activity {
  // non-static inner class
  public class MyRunnable implements Runnable {

   @Override
   public void run() {
     // do some work
   }
  }
   

  @Override
  public void onCreate(Bundle savedInstanceState) {
        ...
    // Post Inner class instance Runnable
    handler.postDelayed(new MyRunnable(),
                         TimeUnit.MINUTES.toMillis(10));
   
    // Post an Anonymous class instance
    handler.postDelayed(new Runnable() {
     @Override
     public void run() {
     // do some work
     }
    }, TimeUnit.MINUTES.toMillis(20));
    ...
    }
   }</pre></div><p>Both objects, the <code class="literal">MyRunnable</code> object created over his default constructor and the anonymous <code class="literal">Runnable</code> class <a id="id97" class="indexterm"/>created on the second <code class="literal">handler.postDelayed</code>, hold a reference to the <code class="literal">Activity</code> object.</p><p>By declaring an anonymous inner <code class="literal">Runnable</code> inside an activity, we have made an implicit reference to that containing <code class="literal">Activity</code> instance. We've then posted the <code class="literal">Runnable</code> to a handler and told it to execute in 10 minutes' time.</p><p>If the activity finishes before the 10 minutes are up, it cannot yet be garbage-collected because the implicit reference in our runnable means that the activity is still reachable by live objects.</p><p>So, although it makes for a concise example, it is not a good idea in practice to post non-static Runnables onto the main thread's <code class="literal">Handler</code> queue (especially with <code class="literal">postDelayed</code> or <code class="literal">postAtTime</code>) unless we're very careful to clean up after ourselves all the references to the inactive Activities.</p><p>If the <code class="literal">MyActivity</code> object is not garbage-collected in 10 minutes, a memory leak with all the activity views and resources will increase your memory consumption until you reach the maximum heap space per application available. Worse, if you create several instances of this activity when the user navigates through the application, the application will run out of memory in a snap.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The heap size limit available per application varies from device to device. When an application reaches this limit, the system will throw an <code class="literal">OutOfMemoryError</code>.</p></div></div><p>One way to minimize this problem is to use static nested classes or top-level classes in their own files (direct member of a package) to remove the reference to the original <code class="literal">Activity</code> object when<a id="id98" class="indexterm"/> we create a deferred <code class="literal">Runnable</code> work task. This means that references must be explicit, which makes them easier to spot and nullify:</p><div class="informalexample"><pre class="programlisting">public class MyActivity extends Activity {
    // static inner class
    public static class MyRunnable implements Runnable {</pre></div></div><div class="section" title="Leaking explicit references"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Leaking explicit references</h2></div></div></div><p>If we are to interact with the user interface, we'll at least need a reference to an object in the <code class="literal">View</code> hierarchy, which <a id="id99" class="indexterm"/>we might pass into our static or top-level runnable's constructor:</p><div class="informalexample"><pre class="programlisting">static class MyRunnable implements Runnable {
       private View view;
       public MyRunnable(View view) {
           this.view = view;
       }
       public void run() {
           // ... do something with the view.
       }
}</pre></div><p>However, by keeping a strong reference to the <code class="literal">View</code>, we are again subject to potential memory leaks if our <code class="literal">Runnable</code> outlives the <code class="literal">View</code>; for example, if some other part of our code removes this <code class="literal">View</code> from the display before our <code class="literal">Runnable</code> executes.</p><p>One solution to this is to use a weak reference and check for <code class="literal">null</code> before using the referenced <code class="literal">View</code>:</p><div class="informalexample"><pre class="programlisting">static class MyRunnable implements Runnable {
   
    private WeakReference&lt;View&gt; view;
  
 public MyRunnable(View view) {
   this.view = new WeakReference&lt;View&gt;(view);
 }
 public void run() {
  View v = view.get(); // might return null
  if (v != null) {
    // ... do something with the view.
    }
  }
}</pre></div><p>If you haven't used <code class="literal">WeakReference</code> before, what it gives us is a way to refer to an object only for as long as some other live object has a stronger reference to it (for example, a normal property reference).</p><p>When all strong references are garbage-collected, our <code class="literal">WeakReference</code> will also lose its reference to the <code class="literal">View</code>, <code class="literal">get()</code> will return <code class="literal">null</code>, and the <code class="literal">View</code> will be garbage-collected.</p><p>This fixes the resource leakage<a id="id100" class="indexterm"/> problem, but we must always check for <code class="literal">null</code> before using the returned object in order to avoid potential <code class="literal">NullPointerException</code> instances.</p><p>If we're sending messages to our <code class="literal">Handler</code> and expecting it to update the user interface, it will also need a reference to the view hierarchy. A nice way to manage this is to attach and detach the <code class="literal">Handler</code> from <code class="literal">onResume</code> and <code class="literal">onPause</code>:</p><div class="informalexample"><pre class="programlisting">private static class MyHandler extends Handler {
    private TextView view;
    public void attach(TextView view) {
        this.view = view;
    }
    public void detach() {
        view = null;
    }
    @Override
    public void handleMessage(Message msg) {
      // handle message
    }
}

@Override
protected void onResume() {
  super.onResume();
  myHandler.attach(myTextView);
}

@Override
  protected void onPause() {
    super.onPause();
    myHandler.detach();
}</pre></div></div><div class="section" title="Updating the UI with Handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Updating the UI with Handler</h2></div></div></div><p>Since we instantiated our handler in the <a id="id101" class="indexterm"/>main thread, all work submitted to it executes on the main thread. This means that we must not submit long-running operations to this particular handler, but we can safely interact with the user interface:</p><div class="informalexample"><pre class="programlisting">handler.post(new Runnable(){
  public void run() {
    TextView text = (TextView) findViewById(R.id.text);
    text.setText("updated on the UI thread");
  }
});</pre></div><p>This applies regardless of which thread posts the <code class="literal">Runnable</code>, which makes <code class="literal">Handler</code> an ideal way to send the results of work performed by other threads to the main thread:</p><div class="informalexample"><pre class="programlisting">public void onCreate(Bundle savedInstanceState) {
    ...
    // Handler bound to the main Thread
    final Handler handler = new Handler();
   
    // Creates an assync line of execution
    Thread thread = new Thread() {
        public void run() {
            final String result = searchSynomym("build");
            handler.post(new Runnable() {
                public void run() {
                    TextView text = (TextView)
                          findViewById(R.id.text);
                    text.setText(result);
                }
            });
        }
    };
    // Start the background thread with a lower priority
    thread.setPriority(Thread.MIN_PRIORITY);
    thread.start();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>If you start your own threads for background work, make sure to set the priority to <code class="literal">Thread.MIN_PRIORITY</code> to avoid starving the main thread of CPU time. The system CPU scheduler will give more CPU cycle times to threads with higher priority.</p></div></div><p>
<code class="literal">Handler</code> is so<a id="id102" class="indexterm"/> fundamental that its API is integrated right into the <code class="literal">View</code> class's member functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">View.post(Runnable)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">View.postDelayed(action,delayMillis)</code>.</li></ul></div><p>So, we can rewrite the previous example as follows:</p><div class="informalexample"><pre class="programlisting">final TextView text = (TextView) findViewById(R.id.text);
Thread thread = new Thread(){
  public void run(){
   final String result = searchSynonym("build"); 
   // Using the view post capabilities             
   text.post(new Runnable(){
     public void run() {
       text.setText(result);
       }
      });
    }
   };
thread.setPriority(Thread.MIN_PRIORITY);
thread.start();</pre></div><p>When writing code in an <code class="literal">Activity</code> class, there is an alternative way to submit a <code class="literal">Runnable</code> on the main thread using the <code class="literal">runOnUiThread(Runnable)</code> method of <code class="literal">Activity</code>, as explained in the previous chapter. If the current thread is the UI thread, then the action is executed immediately. If the current thread is not the UI thread, the action is posted to the event queue of the main UI thread.</p></div><div class="section" title="Canceling a pending Runnable"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Canceling a pending Runnable</h2></div></div></div><p>During your <a id="id103" class="indexterm"/>application execution, you could have a situation where you want to cancel a posted <code class="literal">Runnable</code>, for instance, when you submit a deferred task on your activity's <code class="literal">onCreate()</code> and you want to cancel it when you are executing <code class="literal">onDestroy()</code> because the activity is going to be destroyed. The <code class="literal">Handler</code> function <code class="literal">removeCallbacks()</code> can cancel a pending operation by removing a posted <code class="literal">Runnable</code> task from the queue of work:</p><div class="informalexample"><pre class="programlisting">final Runnable runnable = new Runnable(){
  public void run() {
    // ... do some work
  }
};
handler.postDelayed(runnable, TimeUnit.SECONDS.toMillis(10));
Button cancel = (Button) findViewById(R.id.cancel);
cancel.setOnClickListener(new OnClickListener(){
  public void onClick(View v) {
  handler.removeCallbacks(runnable);
 }
});</pre></div><p>Notice that in order to be able to specify what to remove, we must keep a reference to the <code class="literal">Runnable</code> instance, and that cancelation applies only to pending tasks—it does not attempt to stop a <code class="literal">Runnable</code> that is already mid-execution.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Keep in mind that if you post the same object more than one time, <code class="literal">removeCallbacks()</code> will remove all the non-running entries that reference that object.</p></div></div></div><div class="section" title="Scheduling work with send"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Scheduling work with send</h2></div></div></div><p>When we post a <code class="literal">Runnable</code>, we can—as seen in the previous examples—define the work at the local or member scope with an anonymous <code class="literal">Runnable</code>. As such, the <code class="literal">Handler</code> does not know in advance what kind of work it might be asked to perform.</p><p>If we often need to<a id="id104" class="indexterm"/> perform the same work from different scopes, we could define a static or top-level <code class="literal">Runnable</code> class that we can instantiate from anywhere in our application's lifecycle.</p><p>Alternatively, we can turn the approach on its head by sending messages to a <code class="literal">Handler</code> and defining the <code class="literal">Handler</code> to react appropriately to different messages.</p><p>Taking a simple example, let's say we want our <code class="literal">Handler</code> to display <code class="literal">hello</code> or <code class="literal">goodbye</code>, depending on the type of message it receives. To do that, we'll extend <code class="literal">Handler</code> and override its <code class="literal">handleMessage()</code> method:</p><div class="informalexample"><pre class="programlisting">public static class SpeakHandler extends Handler {

    public static final int SAY_HELLO = 0;
    public static final int SAY_BYE = 1;

    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case SAY_HELLO:
                sayWord("hello");
                break;
            case SAY_BYE:
                sayWord("goodbye");
                break;
            default:
                super.handleMessage(msg);
        }
    }
    private void sayWord(String word) {
        // Say word
    }
}</pre></div><p>Here, we've implemented the <code class="literal">handleMessage()</code> method to expect messages with two different <code class="literal">what</code> values and react accordingly. Apart from the <code class="literal">what</code> property, which is used to identify what the <a id="id105" class="indexterm"/>message is about, the message object provides three extra integer fields, <code class="literal">arg</code>, <code class="literal">arg2</code>, and <code class="literal">obj</code>, which can be used to identify and specify your message.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>If you look carefully at the <code class="literal">Speak</code> handler class example explained earlier, you'll notice that we defined it as a static class. Subclasses of <code class="literal">Handler</code> should always be declared as top-level or static inner classes to avoid inadvertent memory leaks!</p></div></div><p>To bind an instance of our <code class="literal">Handler</code> to the main thread, we simply instantiate it from any method that runs on the main thread, such as the <code class="literal">Activity onCreate()</code> callback:</p><div class="informalexample"><pre class="programlisting">private Handler handler;
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    handler = new SpeakHandler();
    ...
}</pre></div><p>Remember that we can send messages to this <code class="literal">Handler</code> from any thread, and they will be processed by the main thread. We send messages to our <code class="literal">Handler</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">  handler.sendEmptyMessage(SpeakHandler.SAY_HELLO);
  ...
  handler.sendEmptyMessage(SpeakHandler.SAY_BYE);</pre></div><p>When we post a <a id="id106" class="indexterm"/>message over the previous method, the <code class="literal">Handler</code> will create a message for us, fill in the message's <code class="literal">what</code> property with the integer passed in, and post the message to the handler's<code class="literal"> Looper</code> queue. This construct could be extremely useful when we need to send basic commands to a handler, although when we need more complex messages, we need to use other message properties, such as <code class="literal">arg1</code>, <code class="literal">arg2</code>, and <code class="literal">obj</code>, to carry more information about our request.</p><p>As messages may carry an object payload as the context for the execution of a message, let's extend our example to allow our <code class="literal">Handler</code> to say any word that the message sender wants:</p><div class="informalexample"><pre class="programlisting">public static class SpeakHandler extends Handler {
    public static final int SAY_HELLO = 0;
    public static final int SAY_BYE = 1;
    public static final int SAY_WORD = 2;
    @Override
    public void handleMessage(Message msg) {
       switch(msg.what) {
           case SAY_HELLO:
               sayWord("hello"); break;
           case SAY_BYE:
               sayWord("goodbye"); break;
           case SAY_WORD:
                //  Get an Object
               sayWord((String)msg.obj); break;
           default:
               super.handleMessage(msg);
        }
    }
    private void sayWord(String word) { ... }
}</pre></div><p>Within our <code class="literal">handleMessage</code> method, we can access the payload of the message directly by accessing the public <code class="literal">obj</code> property. The <code class="literal">Message</code> payload can be set easily via alternative static <code class="literal">obtain</code> methods:</p><div class="informalexample"><pre class="programlisting">Message msg =  Message.obtain(handler,
               SpeakHandler.SAY_WORD, "Welcome!");
handler.sendMessage(msg);</pre></div><p>In the previous example, we basically create a message that the <code class="literal">what</code> property is <code class="literal">SAY_WORD</code> and the <code class="literal">obj</code> property is <code class="literal">Welcome!</code>.</p><p>While it should be quite clear what this code is doing, you might be wondering why we didn't create a new instance of <code class="literal">Message</code> by invoking its constructor and instead invoked its static method, <code class="literal">obtain</code>.</p><p>The reason is efficiency. Messages are used only briefly—we instantiate, dispatch, handle, and then <a id="id107" class="indexterm"/>discard them. So, if we create new instances each time, we are creating work for the garbage collector.</p><p>Garbage collection is expensive, and the Android platform goes out of its way to minimize object allocation whenever it can. While we can instantiate a new <code class="literal">Message</code> object if we wish, the recommended approach is to obtain one that reuses <code class="literal">Message</code> instances from a pool and cuts down on garbage collection overhead. By reducing the memory footprint, fewer objects are recycled, leading to faster and less frequent garbage collection.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>In cases where you can build your messages over low-cost integer arguments, you should use them instead of complex arguments such as <code class="literal">obj</code> or <code class="literal">data</code>, which always create extra work for the GC.</p></div></div><p>Just as we can schedule runnables with variants of the <code class="literal">post</code> method, we can schedule messages with variants of <code class="literal">send</code>:</p><div class="informalexample"><pre class="programlisting">handler.sendMessageAtFrontOfQueue(msg);
handler.sendMessageAtTime(msg, time);
handler.sendMessageDelayed(msg, delay);</pre></div><p>There are also empty-message variants for convenience, when we don't have a payload:</p><div class="informalexample"><pre class="programlisting">handler.sendEmptyMessageAtTime(what, time);
handler.sendEmptyMessageDelayed(what, delay);</pre></div></div><div class="section" title="Cancelling pending messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Cancelling pending messages</h2></div></div></div><p>Canceling sent<a id="id108" class="indexterm"/> messages is also possible and actually easier than canceling posted runnables because we don't have to keep a reference to the messages that we might want to cancel—instead, we can just cancel messages by their <code class="literal">what</code> values or by the <code class="literal">what</code> value and object reference:</p><div class="informalexample"><pre class="programlisting">String myWord = "Do it now!";
handler.removeMessages(SpeakHandler.SAY_BYE);
handler.removeMessages(SpeakHandler.SAY_WORD, myWord);</pre></div><p>Note that just as with posted runnables, message cancellation only removes pending operations from the queue—it does not attempt to stop an operation already being executed.</p><p>Besides the canceling functionality, the handler also provides functions to verify whether there are any pending messages in the queue. With the handler object in hand, we can query the handler by the message's <code class="literal">what</code> value, <code class="literal">hasMessages(what)</code>, and by the <code class="literal">hasMethods(what,object)</code> message object value. Let's put some examples together with our previous examples:</p><div class="informalexample"><pre class="programlisting">handler.hasMessages(SpeakHandler.SAY_BYE)
handler.hasMessages(SpeakHandler.SAY_WORD, myWord)</pre></div><p>The first example will verify whether there is any message whose <code class="literal">what</code> code is <code class="literal">SAY_BYE</code>, and the second will verify whether there is any message whose <code class="literal">what</code> code is <code class="literal">SAY_WORD</code> and whose object points to the same reference as <code class="literal">myWord</code>.</p><p>It is really important to remember that the <code class="literal">removeMessages</code> and <code class="literal">hasMessages</code> methods with an object argument will search the queue, comparing the object by the  <code class="literal">==</code> reference comparison and not a comparison of object values such as <code class="literal">(equals())</code>. Here is a simple example to explain the situation:</p><div class="informalexample"><pre class="programlisting">String stringRef1 = new String("Welcome!");
String stringRef2 = new String("Welcome Home!");
Message msg1 =  Message.obtain(handler,
                    SpeakHandler.SAY_WORD,stringRef1);
Message msg2 =  Message.obtain(handler,
                    SpeakHandler.SAY_WORD, stringRef2);

// Enqueue the messages to be processed later
handler.sendMessageDelayed(msg1,600000);
handler.sendMessageDelayed(msg2,600000);

// try to remove the messages
handler.removeMessages(SpeakHandler.SAY_WORD,
                       stringRef1);
handler.removeMessages(SpeakHandler.SAY_WORD,
                       new String("Welcome Home!"));
// Create a Print Writer to Process StandardOutput
PrintWriterPrinter out =
     new PrintWriterPrinter(new PrintWriter(System.out,true));
 
// Dump the Looper State
handler.getLooper().dump(out,"&gt;&gt; Looper Dump ");</pre></div><p>As explained before, the second <code class="literal">remove</code> invocation will not remove the message added previously, because<a id="id109" class="indexterm"/> the <code class="literal">stringRef1</code> reference is different from the new reference passed in, despite the string content being the same.</p><p>Here is the output from the looper dump, with the message that was not canceled successfully:</p><div class="informalexample"><pre class="programlisting">&gt;&gt; Looper Dump Looper (main, tid 1) {a15844a}
&gt;&gt; Looper Dump Message 0: { when=+10m0s0ms
        what=2       
        obj=Welcome Home! target=...SpeakHandler }
&gt;&gt; Looper Dump (Total messages: 1,
        polling=false, quitting=false)</pre></div></div><div class="section" title="Composition versus inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Composition versus inheritance</h2></div></div></div><p>So far, we've subclassed <code class="literal">Handler</code> to override its <code class="literal">handleMessage</code> method, but that isn't our only option. We <a id="id110" class="indexterm"/>can favor composition over inheritance by passing an instance of <code class="literal">Handler.Callback</code> during handler construction:</p><div class="informalexample"><pre class="programlisting">boolean handleMessage(Message msg)</pre></div><p>Let's suppose we want to extend our speaker without changing the original <code class="literal">Handler</code>, and we want to add new actions over a <code class="literal">Handler.Callback</code> class:</p><div class="informalexample"><pre class="programlisting">public class Speaker implements Handler.Callback {
 
    public static final int SAY_WELCOME = 2;
    public static final int SAY_YES = 3;
    public static final int SAY_NO = 4;
   
    @Override
    public boolean handleMessage(Message msg) {
        switch(msg.what) {
            case SAY_WELCOME:
                sayWord("welcome"); break;
            case SAY_YES:
                sayWord("yes"); break;
            case SAY_NO:
                sayWord("no"); break;
            default:
                return false;
        }
        return true;
    }
    private void sayWord(String word) {  }
}</pre></div><p>Notice that the signature of <code class="literal">handleMessage</code> is slightly different here—we must return a <code class="literal">boolean</code> value indicating<a id="id111" class="indexterm"/> whether or not the <code class="literal">Message</code> was handled. To create a <code class="literal">Handler</code> that uses our extension, we simply pass the <code class="literal">Handler.Callback</code> implementation during handler construction:</p><div class="informalexample"><pre class="programlisting">Handler handler = new SpeakHandler(new Speaker());</pre></div><p>If we return <code class="literal">false</code> from the <code class="literal">handleMessage</code> method of our callback, the Handler will invoke its own <code class="literal">handleMessage</code> method, so we could choose to use a combination of inheritance and composition to implement the default behavior in a <code class="literal">Handler</code> subclass and then mix in special behavior by passing in an instance of <code class="literal">Handler.Callback</code>.</p><p>In the aforementioned code, we use the composition to process the <code class="literal">SAY_HELLO</code> message and the inheritance to process the <code class="literal">SAY_YES</code> message:</p><div class="informalexample"><pre class="programlisting">// will be handled by SpeakHandler Handler
handler.sendEmptyMessage(SAY_HELLO);
// will be handled by Speaker Handler.Callback
handler.sendEmptyMessage(SAY_YES);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>
<span class="strong"><strong>Inheritance</strong></span> should only be <a id="id112" class="indexterm"/>used when the relationship between a subclass and the superclass is permanent<a id="id113" class="indexterm"/> and strong and can't be decoupled. On the other hand, <span class="strong"><strong>composition</strong></span> offers more flexibility<a id="id114" class="indexterm"/> for enhancements and testing.</p></div></div></div><div class="section" title="Multithreading with Handler and ThreadHandler"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Multithreading with Handler and ThreadHandler</h2></div></div></div><p>In a typical Android <a id="id115" class="indexterm"/>asynchronous application, the UI thread hands over long computing operations to a background thread, which in turn executes the task and posts back the results to the main thread.</p><p>So far, we have just used the <code class="literal">Handler</code> to send messages to the main thread, so the next natural step is to design a<a id="id116" class="indexterm"/> multithreaded scenario where the <code class="literal">interthread</code> communication is managed by the <code class="literal">Handler</code> construct.</p><p>Let's extend our previous examples and create a weather forecast retriever.</p><p>Imagine this scenario: when we click on a UI button, the main thread will ask for our background thread to retrieve the weather forecast and, when the weather forecast response is received, the background thread will ask the main thread to present the weather forecast received.</p><p>We will start by creating the <code class="literal">WeatherRetriever</code> that is responsible for receiving the weather forecast requests and then retrieve the forecast sentence and post back the result to the <code class="literal">mainHandler</code> object.</p><p>During the scenario assembly, the <code class="literal">WeatherRetriever</code> handler is attached to a background <code class="literal">Looper </code>over the first constructor argument in order to execute in a separate line of execution away from the main thread. The second constructor argument is used to set the handler to post the results.</p><p>On the <code class="literal">handleMessage</code> method, the handler is able to process the current day's forecast message requests (<code class="literal">GET_TODAY_FORECAST</code>) or the next day's requests (<code class="literal">GET_TOMORROW_FORECAST</code>), eventually calling the long-computing <code class="literal">getForecast()</code> operation.</p><p>The long-computing <code class="literal">getForecast()</code> could block the thread execution for a long time, but this is not a problem anymore, since we are going to run it in a background thread with lower priority, which does not block the UI from being rendered in time, and hence prevents an ANR error from occurring and makes the application more responsive to user interactions:</p><div class="informalexample"><pre class="programlisting">public class WeatherRetriever extends Handler {

    private final Handler mainHandler;

    public static final int GET_TODAY_FORECAST = 1;

    public WeatherRetriever(Looper looper,Handler mainHandler){
        super(looper);
        this.mainHandler = mainHandler;
    }    
    // Long Computing Operation 
    String getForecast(){ ... }

    @Override
    public void handleMessage(Message msg) {
        switch(msg.what) {
            case GET_TODAY_FORECAST:
                ...
                final String sentence = getForecast();
                Message resultMsg =
                    mainHandler.obtainMessage(
                        WeatherPresenter.TODAY_FORECAST,sentence);
                this.mainHandler.sendMessage(resultMsg);
                break;
        }
    }
};</pre></div><p>Secondly, we will build the <code class="literal">WeatherPresenter</code>, which will handle the forecast results coming from the <a id="id117" class="indexterm"/>background operation, presenting it to the user on<a id="id118" class="indexterm"/> the main thread:</p><div class="informalexample"><pre class="programlisting">public class WeatherPresenter extends Handler {
  public static final int TODAY_FORECAST = 1;

  @Override
  public void handleMessage(Message msg) {
    switch(msg.what) {
    case TODAY_FORECAST:
      readTodayWeather((String) msg.obj); break;
      ...
    }
  }
  private void readTodayWeather(String word) {
   // Present the weather forecast on the UI
   ...
 }
};</pre></div><p>We described one<a id="id119" class="indexterm"/> way of setting up a <code class="literal">Looper</code> thread with the <code class="literal">SimpleLooper</code> class, detailed earlier in this chapter, but there's an easier way, using a class provided by the SDK for exactly this purpose: <code class="literal">android.os.HandlerThread</code>.</p><p>When we create a <code class="literal">HandlerThread</code>, we specify two things: a name for the thread, which can be helpful when <a id="id120" class="indexterm"/>debugging, and its priority, which must be selected from the set of static values in the <code class="literal">android.os.Process</code> class:</p><div class="informalexample"><pre class="programlisting">HandlerThread thread = new HandlerThread("background",    Process.THREAD_PRIORITY_BACKGROUND);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Thread priorities in Android are mapped into Linux nice levels, which govern how often a thread gets to run. A niceness of <code class="literal">−20</code> is the highest priority, and <code class="literal">19</code> is the lowest priority. The default nice level is <code class="literal">0</code>. In addition to prioritization, Android limits CPU resources using Linux cgroups. Threads that are of background priority are moved into the <code class="literal">bg_non_interactive</code> cgroup, which is limited to 5 percent of available CPU if threads in other groups are busy.</p><p>Adding <code class="literal">THREAD_PRIORITY_MORE_FAVORABLE</code> to <code class="literal">THREAD_PRIORITY_BACKGROUND</code> when configuring your <code class="literal">HandlerThread</code> moves the thread into the default cgroup, but always consider whether it is really necessary—it often isn't!</p></div></div><p>In the the next table, the mapping from Android thread priority to Linux nice levels is detailed; however, the use of nice levels lower than <span class="strong"><strong>-2</strong></span> in regular applications is not recommended:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Java priority</p>
</th><th style="text-align: left" valign="bottom">
<p>Thread priority</p>
</th><th style="text-align: left" valign="bottom">
<p>Nice level</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_URGENT_AUDIO</p>
</td><td style="text-align: left" valign="top">
<p>-19</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_AUDIO</p>
</td><td style="text-align: left" valign="top">
<p>-16</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MAX_PRIORITY</p>
</td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_URGENT_DISPLAY</p>
</td><td style="text-align: left" valign="top">
<p>-8</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_DISPLAY</p>
</td><td style="text-align: left" valign="top">
<p>-4</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_FOREGROUND</p>
</td><td style="text-align: left" valign="top">
<p>-2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>NORM_PRIORITY</p>
</td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_DEFAULT</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_BACKGROUND</p>
</td><td style="text-align: left" valign="top">
<p>10</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MIN_PRIORITY</p>
</td><td style="text-align: left" valign="top">
<p>THREAD_PRIORITY_LOWEST</p>
</td><td style="text-align: left" valign="top">
<p>19</p>
</td></tr></tbody></table></div><p>
<code class="literal">HandlerThread</code> extends <code class="literal">java.lang.Thread</code>, and we must start it with <code class="literal">start()</code>before it actually begins processing its queue:</p><div class="informalexample"><pre class="programlisting">thread.start();</pre></div><p>Now, from an <code class="literal">Activity</code> callback, we are going to detail how to lift up our scenario, building all the<a id="id121" class="indexterm"/> instances and objects required to<a id="id122" class="indexterm"/> submit and process requests:</p><div class="informalexample"><pre class="programlisting">// Background Thread    
private HandlerThread thread;

protected void onCreate(Bundle savedInstanceState) {
   ...
   WeatherPresenter presHandler = new WeatherPresenter();
  
   // Creates a Thread with a looper attached
   handlerThread = new HandlerThread("background",
             Process.THREAD_PRIORITY_BACKGROUND);
   // start The Thread and waits for work
   handlerThread.start();

   // Creates the Handler to submit requests
   final WeatherRetriever retHandler =
       new WeatherRetriever(handlerThread.getLooper(),presHandler);</pre></div><p>As we saw previously, the retriever handler is using the <code class="literal">HandlerThread's Looper</code> instead of the main thread's <code class="literal">Looper</code>, so it processes the forecast requests on a background thread, allowing us to run long-computing operations on the <code class="literal">WeatherRetriever</code>.</p><p>With a <code class="literal">WeatherRetriever</code> object (<code class="literal">retHandler</code>) reference in our hands, we are able to enqueue a new forecast<a id="id123" class="indexterm"/> request to the background thread by sending a message with the <code class="literal">WeatherRetriever</code> handler. In the next example, we listen for taps on the UI's <code class="literal">today</code> button in order to initiate a forecast request:</p><div class="informalexample"><pre class="programlisting">todayBut.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View v) {     
    retHandler.sendEmptyMessage(WeatherRetriever.
                                GET_TODAY_FORECAST);
  }
}</pre></div><p>When the forecast is processed by the background thread on the <code class="literal">WeatherRetriever </code>callback, a message is dispatched to the main <code class="literal">Looper</code> through the <code class="literal">WeatherPresenter</code> reference, and <code class="literal">readTodayWeather(String)</code> is invoked on the main thread in order to present the<a id="id124" class="indexterm"/> forecast to the user.</p><p>As you can see in the following trace output, the forecast retriever runs on the low-priority background thread with TID <code class="literal">120</code>, and the forecast result is presented on the main UI thread, which has a TID of <code class="literal">1</code>:</p><div class="informalexample"><pre class="programlisting">I/MTHandler(17666): Retrieving Today Forecast at Thread[background,120]
I/MTHandler(17666): Presenting Today Forecast at Thread[main,1]</pre></div><p>If we create a <code class="literal">HandlerThread</code> to do background work for a specific <code class="literal">Activity</code>, we will want to tie the <code class="literal">HandlerThread</code> instance's life cycle closely to that of the activity's to prevent resource leaks.</p><p>A <code class="literal">HandlerThread</code> can be shut down by invoking <code class="literal">quit()</code>, which will stop the <code class="literal">HandlerThread</code> from processing any more work from its queue. A <code class="literal">quitSafely</code> method was added at API level 18, which causes the <code class="literal">HandlerThread</code> to process all remaining tasks before shutting down. Once a <code class="literal">HandlerThread</code> has been told to shut down, it will not accept any further tasks:</p><div class="informalexample"><pre class="programlisting">protected void onPause() {
  super.onPause();
  if (( handlerThread != null) &amp;&amp; (isFinishing()))
    handlerThread.quit();
}</pre></div><div class="section" title="Looper message dispatching debugging"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Looper message dispatching debugging</h3></div></div></div><p>When you want to follow the <a id="id125" class="indexterm"/>dispatching and processing of your messages, it could be handy to print a message in the Android logs when any of your messages <a id="id126" class="indexterm"/>get routed by the <code class="literal">Looper</code> and when the handler finishes the processing. The <code class="literal">Looper</code> object supplies us with a method to set a printer facility for the message-dispatching debugging, so, from our <code class="literal">HandlerThread</code>, we are able to set it and enable the extra logging required to follow our requests:</p><div class="informalexample"><pre class="programlisting">    ...
// Creates a Print writer to standard output
PrintWriterPrinter out= new PrintWriterPrinter(
   new PrintWriter(System.out,true)
);
handlerThread.getLooper().setMessageLogging(out);
    ...
reqHandler.sendEmptyMessageDelayed (
    WeatherRetriever.GET_TODAY_FORECAST,
    10000
);</pre></div><p>Here is an example of debugging messages printed when our forecast request gets processed by the <code class="literal">Looper</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt;&gt;&gt; Dispatching to Handler (…WeatherRetriever) {a15844a} null: 1
&lt;&lt;&lt;&lt;&lt; Finished to Handler (...WeatherRetriever) {a15844a} null</pre></div><p>The format for the dispatching debug message is <code class="literal">(&lt;Target_Handler&gt;) {Callback_Obj} : &lt;what&gt;</code>.</p><p>In our simple example, we print the messages for the process's standard output stream (<code class="literal">java.io.OutputStream</code>), but in more advanced cases, we can print to any kind of <code class="literal">OutputStream</code> subclass (file, network, and so on).</p></div></div><div class="section" title="Sending messages versus posting runnables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Sending messages versus posting runnables</h2></div></div></div><p>It is<a id="id127" class="indexterm"/> worth spending a few moments to consider the difference between posting runnables and sending messages.</p><p>The runtime difference mostly comes down to efficiency. Creating new instances of <code class="literal">Runnable</code> each time we want our handler to do something adds garbage-collection overhead, while sending messages reuses <code class="literal">Message</code> instances, which are sourced from an application-wide pool.</p><p>For prototyping and <a id="id128" class="indexterm"/>small one-offs, posting runnables is quick and easy, while the advantages of sending messages tend to grow with the size of the application.</p><p>It should be said that message-sending is more <span class="emphasis"><em>the Android way</em></span> and is used throughout the platform to keep garbage to a minimum and apps running smoothly.</p></div><div class="section" title="Applications of Handler and HandlerThread"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Applications of Handler and HandlerThread</h2></div></div></div><p>The <code class="literal">Handler</code> class is<a id="id129" class="indexterm"/> incredibly versatile, which makes its range of applications very broad.</p><p>So far, we've looked at <code class="literal">Handler</code> and <code class="literal">HandlerThread</code> in the context of the <code class="literal">Activity</code> lifecycle, which constrains the sort of applications where this construct might be used—ideally, we do not want to <a id="id130" class="indexterm"/>perform long-running operations (more than a second or so) at all in this context.</p><p>With that constraint in mind, good candidate uses include performing calculations, string processing, reading and writing small files on the file system, and reading or writing to local databases using a background <code class="literal">HandlerThread</code>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we learned how to use <code class="literal">Handler</code> to queue work for the main thread and how to use <code class="literal">Looper</code> to build up a queueing infrastructure for our own <code class="literal">Thread</code>.</p><p>We saw the different ways in which we can define work with <code class="literal">Handler</code>: arbitrary work defined at the call site with <code class="literal">Runnable</code> or predefined work implemented in the <code class="literal">Handler</code> itself and triggered by message-sending.</p><p>In the meantime, we learned how to defer work properly without leaking memory on the way.</p><p>We learned how to use <code class="literal">Handler</code> in a multithreaded application to pass work and results back and forth between cooperating threads, performing blocking operations on an ordinary background thread and communicating the results back to the main thread to update the user interface.</p><p>In the next chapter, we'll start to build responsive applications by applying the <code class="literal">AsyncTask</code> instance to execute work in the background using pools of threads and returning progress updates and results to the main thread.</p></div></body></html>