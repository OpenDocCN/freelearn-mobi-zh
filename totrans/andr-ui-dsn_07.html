<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Building a Prototype</h1></div></div></div><p>After doing much of the initial design work in the previous chapters, it's now time to move past designing and into the early stages of developing. And the first development task is to create a digital prototype.</p><p>After creating multiple wireframes and paper prototypes, you may be itching to start some <em>real</em> development work, but digital prototyping is a <em>crucial</em> step in the design process.</p><p>Despite all the time and effort you've already invested in your design, at this point it's still just a plan. Digital prototyping is where you put this plan to the test to see whether it works in the real world. Also, digital prototyping is just plain fun as it allows you to go from no code to a working version of your app in no time at all.</p><p>By the end of this chapter, you'll have developed a working digital prototype of your app. You'll have also finalized your design by planning the finer details of your app, which means starting to think about graphic design.</p><div><div><h3 class="title"><a id="note62"/>Note</h3><p>As it's the recommended development environment for Android, this chapter focuses on creating digital prototypes using Android Studio. If you don't have Android Studio  installed, you can grab it from <a class="ulink" href="http://developer.android.com/sdk">http://developer.android.com/sdk</a>.</p><p>If you prefer to use a different IDE, such as Eclipse, then the steps involved in creating a digital prototype will be similar, so you will still be able to follow along in the IDE of your choice.</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Creating a prototype in Android Studio</h1></div></div></div><p>Conveniently, one of the best tools for creating Android prototypes is something you probably already have installed—Android Studio.</p><p>This IDE features an advanced layout editor that's ideal for rapidly creating digital prototypes. This layout editor automatically opens whenever you open any XML layout resource file in Android Studio.</p><p>
</p><div><img src="img/B05061_7_1.jpg" alt="Creating a prototype in Android Studio"/></div><p>
</p><p>The quickest way of creating a digital prototype is to select the editor's <strong>Design</strong> tab (where the cursor is positioned in the previous screenshot). A new area will open displaying a <strong>canvas</strong> preview of your app's layout, plus a <strong>Palette</strong> containing lots of ready-made UI elements called <strong>widgets</strong>. You can quickly create a prototype by dragging widgets from the <strong>Palette</strong> and dropping them onto the canvas.</p><div><div><h3 class="title"><a id="note63"/>Note</h3><p>When creating prototypes (and Android apps in general), you should use the default widgets unless you have a very good reason not to. Not only do these ready-made widgets make your life as a developer easier, but most Android users will already be familiar with them. So they'll instantly know how to interact with at least some elements of your app's UI.</p></div></div><p>If you need to make more specific changes to your app's layout, you can access its underlying XML by selecting the <strong>Text</strong> tab, making your tweaks at the code level, and then nipping back to the <strong>Design</strong> tab to see these changes rendered on the canvas. Using this approach, you'll have a working prototype in no time, which you can then test on your own Android device or in an emulator.</p><p>Creating prototypes in Android Studio is also a great way of testing how your design looks and functions across a range of different screen configurations. If you simply happen to have multiple Android devices lying around, you can install your prototype on all of them, but most Android developers test their project across difference devices by creating multiple <strong>Android Virtual Devices</strong> (<strong>AVDs</strong>).</p><div><div><h3 class="title"><a id="note64"/>Note</h3><p>We'll explore deploying and testing your digital prototypes in more detail in the next chapter.</p></div></div><p>You can also get a quick preview of your prototype across different devices using Android Studio's built-in <strong>Preview</strong> pane. To access this pane, make sure the <strong>Text</strong> tab is selected, and then click on the <strong>Preview</strong> tab along the left-hand side of the screen (where the cursor is positioned in the following screenshot):</p><p>
</p><div><img src="img/B05061_7_2.jpg" alt="Creating a prototype in Android Studio"/></div><p>
</p><p>With this tab open, you'll see a preview of your app as it appears on a single Android device. To check how your layout will appear on a different Android device, click on the name of the currently selected device (where the cursor is positioned in the following screenshot), and then choose a new device from the drop-down menu. You can even preview your UI across multiple devices at once by selecting <strong>Preview all screen sizes</strong> from the drop-down menu:</p><p>
</p><div><img src="img/B05061_7_3.jpg" alt="Creating a prototype in Android Studio"/></div><p>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Creating your first prototype</h2></div></div></div><p>You can start by prototyping any screen in your app, but I find that it makes sense to start with the first screen users see when they launch your app. In our recipe app example, this is the home screen, so this is the first screen I'm going to prototype.</p><p>Referring back to my wireframe, I can see that the home screen should include a welcome message and photos from some of the recipes featured in the app. I also want to include a menu, so users can easily navigate to the app's most important screens. Specifically, I want this menu to include a link to the search screen, the user's recipe scrapbook, and all the different recipe categories.</p><p>Since this menu needs to include quite a few options, I'm going to use a navigation drawer. A navigation drawer is an effective solution here, as it's scrollable and can be neatly tucked out of the way when it's no longer needed.</p><div><div><h3 class="title"><a id="note65"/>Note</h3><p>If you're not familiar with the concept of navigation drawers, then you may want to look at Android's Material Design guidelines, which has a whole section dedicated to navigation drawers 
<a class="ulink" href="https://www.google.com/design/spec/patterns/navigation-drawer.html">https://www.google.com/design/spec/patterns/navigation-drawer.html</a>
.</p></div></div><p>Boot up Android Studio and create a new project. Choose whatever settings make the most sense for your particular project, but if you're following along with this example, then select the <strong>Navigation Drawer</strong> template. As you might already have guessed from the name, this template has a built-in navigation drawer, which will make creating your home screen digital prototype much easier.</p><p>Click on <strong>Finish</strong> to go ahead and create your project. By default, this project already includes quite a bit of code and resources. My mission is to modify all this automatically generated code to match my home screen wireframe. Let's start with the most straightforward task: creating the screen's welcome message and adding our images.</p><p>Open the project's <code class="literal">content_main.xml</code> file and make sure it's using <code class="literal">RelativeLayout</code> as the parent container. Then, select the <strong>Design</strong> tab and drag one <code class="literal">TextView</code> and two <code class="literal">ImageView</code> widgets from the <strong>Palette</strong>, and drop them onto your canvas.</p><p>Next, populate these widgets with text and images. Create a string resource that contains the welcome text of your choice. Find two images you want to use and add them to your project's <code class="literal">drawable</code> folder (in my project, I'm using <code class="literal">mushroomtoast.jpeg</code> and <code class="literal">sundayroast.jpeg</code>). Update <code class="literal">TextView</code> to display the string resource, and update <code class="literal">ImageViews</code> to display your chosen images.</p><div><div><h3 class="title"><a id="tip66"/>Tip</h3><p>
<strong>Digital prototyping: Don't waste your time!</strong></p><p>A this point, you may be tempted to invest lots of time positioning your <code class="literal">ImageView</code> and <code class="literal">TextView</code> objects so that they look <em>exactly</em> as they should in your finished app. However, be wary of spending too much time perfecting your prototypes.</p><p>The key thing to remember is that the purpose of digital prototyping isn't to create an early version of your project but to test the <em>theory</em> of your project's design. If you spend too much time getting your digital prototypes perfect, then you might as well have started creating the first version of your app!</p><p>Your digital prototype may end up highlighting some underlying problems with your design, which means you'll need to go back and make some changes to your wireframes or even redo them completely. If this happens, then at least you can console yourself with the knowledge that it's better to uncover problems with your design at this early stage, rather than <em>after</em> you've actually started building your app. Digital prototyping is a powerful and time-saving tool in your early detection arsenal—but <em>only</em> if you don't invest lots of time in perfecting your prototypes.</p><p>Don't fall into the trap of worrying about the finer details; instead, aim to create your prototypes as quickly as possible. This usually means creating screens that are only a rough representation of how the finished screen will look, and that typically has little or no functionality.</p></div></div><p>Here is the XML for my home screen prototype. Since this is only a prototype, I haven't invested too much time in aligning each UI element:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;RelativeLayout  &#13;
   &#13;
   &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &#13;
  android:paddingBottom="@dimen/activity_vertical_margin" &#13;
  android:paddingLeft="@dimen/activity_horizontal_margin" &#13;
  android:paddingRight="@dimen/activity_horizontal_margin" &#13;
  android:paddingTop="@dimen/activity_vertical_margin" &#13;
  app:layout_behavior="@string/appbar_scrolling_view_behavior" &#13;
  tools:context="com.example.jessica.myapplication.MainActivity" &#13;
  tools:showIn="@layout/app_bar_main"&gt; &#13;
 &#13;
  &lt;ImageView &#13;
      android:layout_width="175dp" &#13;
      android:layout_height="225dp" &#13;
      android:id="@+id/imageView2" &#13;
      android:src="img/mushroomtoast" &#13;
      android:layout_below="@+id/textView2" &#13;
      android:layout_toEndOf="@+id/textView2" /&gt; &#13;
 &#13;
  &lt;ImageView &#13;
      android:layout_width="175dp" &#13;
      android:layout_height="225dp" &#13;
      android:id="@+id/imageView3" &#13;
      android:src="img/sundayroast" &#13;
      android:layout_below="@+id/imageView2" &#13;
      android:layout_alignStart="@+id/imageView2" /&gt; &#13;
 &#13;
  &lt;TextView &#13;
      android:paddingTop="10dp" &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" &#13;
      android:textSize="40sp" &#13;
      android:text="@string/welcome!" &#13;
      android:id="@+id/textView2" &#13;
      android:layout_alignParentTop="true" &#13;
      android:layout_alignParentStart="true" /&gt; &#13;
 &#13;
&lt;/RelativeLayout&gt; &#13;
</pre><p>Check how this looks on your emulator or Android device:</p><p>
</p><div><img src="img/B05061_7_4.jpg" alt="Creating your first prototype"/></div><p>
</p><p>The next task is more complex: adding our own menu items to the navigation drawer.</p><p>You'll find all the navigation drawer code in the project's <code class="literal">res/menu/activity_main_drawer.xml</code> file. There's already quite a bit of code in <code class="literal">activity_main_drawer.xml</code>, but this code nicely illustrates how to add items to the navigation drawer, so rather than simply deleting it, let's use it as our template.</p><p>Currently, the <code class="literal">activity_main_drawer.xml</code> file looks like this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;menu &gt; &#13;
 &#13;
  &lt;group  &#13;
 &#13;
//This is an optional, invisible container that groups related &lt;items&gt; together in the navigation drawer// &#13;
 &#13;
android:checkableBehavior="single"&gt; &#13;
 &#13;
//This is another optional element that defines the checkable behavior for either individual menu items (via the android:checkable attribute in an &lt;item&gt; element) or for an entire group, via android:checkableBehavior in a &lt;group&gt; element. In this example, we're marking all &lt;items&gt; in this &lt;group&gt; as checkable. The "single" value means that the user can only select one item at a time, within this group. The other potential values are "none" (the user can't check any items in the group) or "all" (the user can select multiple items in this group at any one time)// &#13;
 &#13;
    &lt;item &#13;
 &#13;
//Creates a new menu item// &#13;
 &#13;
          android:id="@+id/nav_camera" &#13;
 &#13;
//Assigns the menu item a unique resource ID so the app recognizes when the user selects this item in the menu// &#13;
 &#13;
          android:icon="@drawable/ic_menu_camera" &#13;
 &#13;
//Defines what drawable to use as this item's icon// &#13;
 &#13;
          android: /&gt; &#13;
 &#13;
//The text you want to display in the navigation drawer// &#13;
 &#13;
      &lt;item &#13;
     ............ &#13;
     ............ &#13;
     ............ &#13;
 &#13;
  &lt;/group&gt; &#13;
 &#13;
//This is the end of this particular group//  &#13;
 &#13;
  &lt;item android:&gt; &#13;
      &lt;menu&gt; &#13;
 &#13;
//This is the start of a new group// &#13;
 &#13;
     ............ &#13;
     ............ &#13;
     ............ &#13;
 &#13;
      &lt;/menu&gt; &#13;
  &lt;/item&gt; &#13;
 &#13;
&lt;/menu&gt; &#13;
</pre><p>As already mentioned, the menu items I want to add are the scrapbook, the search screen, and the different recipe categories. The first task is deciding what icons I want to use for each of these menu items.</p><p>Wherever possible, you should use the system icons as most users will already be familiar with them, and will therefore know what they mean. You'll find the entire list of Material Design system icons at 
<a class="ulink" href="https://design.google.com/icons/">https://design.google.com/icons/</a>
.</p><p>From this long list of icons, I'm going to use the standard Search icon, so download this image and drop it into your project's <code class="literal">drawable</code> folder. Finding icons for all the other items isn't quite as straightforward, but since this is just a prototype, I'm going to use some placeholder icons for now. I have decided to use the Description icon as it kind of looks like a notebook (or a scrapbook), and I'm also going to use the knife-and-fork local dining icon for each of the recipe categories.</p><p>Once all these images are safely tucked away in the <code class="literal">drawable</code> folder, it's time to add a few new entries to the navigation drawer code:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;menu &gt; &#13;
 &#13;
  &lt;group android:checkableBehavior="single"&gt; &#13;
      &lt;item &#13;
          android:id="@+id/breakfast" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
      &lt;item &#13;
          android:id="@+id/lunch" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
      &lt;item &#13;
          android:id="@+id/dinners" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
      &lt;item &#13;
          android:id="@+id/healthy" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
      &lt;item &#13;
          android:id="@+id/lightmeals" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
      &lt;item &#13;
          android:id="@+id/vegan" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
      &lt;item &#13;
          android:id="@+id/budget" &#13;
          android:icon="@drawable/ic_local_dining" &#13;
          android: /&gt; &#13;
 &#13;
  &lt;/group&gt; &#13;
 &#13;
  &lt;item &#13;
      android:id="@+id/scrapbook" &#13;
      android:icon="@drawable/ic_scrapbook" &#13;
      android: /&gt; &#13;
  &lt;item &#13;
      android:id="@+id/search" &#13;
      android:icon="@drawable/ic_search" &#13;
      android: /&gt; &#13;
     ............ &#13;
     ............ &#13;
     ............ &#13;
 &#13;
&lt;/menu&gt; &#13;
</pre><p>And that's it! Run the finished prototype on your Android device or emulator, but this time, be sure to open the navigation drawer by dragging it on the screen. You will see some new additions to this drawer:</p><p>
</p><div><img src="img/B05061_7_5.jpg" alt="Creating your first prototype"/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Creating your second prototype</h2></div></div></div><p>Wireframing gives you a clearer picture of your UI, but sometimes even wireframes can't effectively illustrate how <em>every</em> version of a certain screen will look. This is the case with our app's search results screen, as this screen will vary depending on what the user has searched for. So, how do we create a single prototype that effectively represents our search results screen?</p><p>The answer is to create a flexible prototype layout, and feed it some fake data. This fake data should accurately represent the complete range of real-life content this screen will ultimately have to display. You should go out of your way to find the most awkward examples of your app's content, so you can really put your design to the test. In our recipe app example, this means using recipes that have unusually long or short titles.</p><p>To create a prototype of the tricky search results screen, I'm going to create <code class="literal">ListView</code>, and then I will create the arrays of sample recipe titles and images, which I'll feed to <code class="literal">ListView</code>. The <code class="literal">ListView</code> will then display these arrays in my layout as though they're real search results.</p><p>Once you've created your first prototype, you can either add more screens to this project or create each subsequent prototype as a separate project. Personally, I feel like the latter is the most straightforward option, so I'm going to create my search results prototype as a new project—this time using a blank template.</p><p>If you also decide to prototype each screen as a separate project, then make sure you give each project a different package name, so you can install and test them all on the same Android device.</p><p>Referring back to my wireframes, I can see that the search results screen needs to include a list of recipe titles and accompanying images along with a header. Let's start with the most straightforward task: creating the header. Open your project's <code class="literal">strings.xml</code> file and create a string that'll provide the search screen's header text:</p><pre class="programlisting">&lt;string name="sResults"&gt;Search Results...&lt;/string&gt;) &#13;
</pre><p>Open the <code class="literal">activity_main.xml</code> file and make sure its parent container is a vertical <code class="literal">LinearLayout</code>. Create a <code class="literal">TextView</code> and set it to display the <code class="literal">sResults</code> string.</p><p>Next it's time to tackle the part of the wireframe that makes this screen more difficult to prototype: the search results. As already mentioned, I'm going to create a <code class="literal">ListView</code> and feed it some fake data, so the first step is adding the <code class="literal">ListView</code> to our layout resource file:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;LinearLayout  &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &#13;
  android:orientation="vertical" &gt; &#13;
 &#13;
  &lt;TextView &#13;
      android:id="@+id/textview" &#13;
      android:text="@string/sResults" &#13;
      android:textSize="30dp" &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:paddingTop="10dp" &#13;
      android:paddingLeft="10dp"/&gt; &#13;
 &#13;
  &lt;ListView &#13;
      android:id="@+id/listview" &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="match_parent" &#13;
      /&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><div><div><h3 class="title"><a id="tip67"/>Tip</h3><p>
<strong>ListViews, adapters, and list items</strong></p><p>A <code class="literal">ListView</code> is a view group that displays items as a vertical, scrollable list. Users can select any item in the list by giving it a tap, which makes <code class="literal">ListViews</code> perfect for displaying our search results, as eventually we want the user to be able to open a recipe by tapping its title.</p><p>To see an example of a <code class="literal">ListView</code> in action, grab your Android device and take a look at the stock <strong>Contacts</strong> app. It contains a scrollable list of all your contacts; you can tap any item in the list to see more information about that particular contact. Sound familiar?</p><p>Once you've identified one <code class="literal">ListView</code>, you'll start noticing them <em>everywhere</em>. Flick through a few of the apps installed on your device, and chances are you'll be surprised by just how often you come across <code class="literal">ListViews</code>.</p><p><code class="literal">ListViews</code> are made up of <em>list items</em>. Each list item is displayed as a row in the <code class="literal">ListView</code>, and these items have their own layout that you define in a separate XML file. You can create a simple layout for your list items, or you can also create more complex list items that feature multiple pieces of text and several images arranged in a <code class="literal">RelativeLayout</code>.</p><p>The final piece of the puzzle is an adapter that acts as a bridge between the <code class="literal">ListView</code> and its underlying data. The adapter pulls content from a specified source, such as an array, and adapts this content into views. The adapter then takes each view and places it inside the <code class="literal">ListView</code> as an individual row.</p><p>In this chapter, I'm going to be using <code class="literal">SimpleAdapter</code>, which is a type of adapter that maps static data to views defined in an XML file. This is a pretty straightforward adapter, but it does have one catch: <code class="literal">SimpleAdapter</code> require an <code class="literal">ArrayList</code> of <code class="literal">Maps</code> in order to define each row in the <code class="literal">ListView</code>.</p><p>If you want to learn more about <code class="literal">ListViews</code> and the different kinds of adapters, the best place to go is the official Android docs: <a class="ulink" href="http://developer.android.com/guide/topics/ui/layout/listview.html">http://developer.android.com/guide/topics/ui/layout/listview.html</a>.</p></div></div><p>Let's define the layout of the individual items/rows that'll appear in our <code class="literal">ListView</code>. Create a new layout resource file called <code class="literal">simple_list_layout.xml</code>, and then create <code class="literal">TextView</code> and <code class="literal">ImageView</code> that will eventually hold the recipe titles and accompanying images:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;LinearLayout  &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &#13;
  android:orientation="horizontal"  &gt; &#13;
 &#13;
  &lt;ImageView &#13;
      android:id="@+id/images" &#13;
      android:layout_width="250dp" &#13;
      android:layout_height="150dp" &#13;
      android:paddingTop="10dp" &#13;
      android:paddingRight="5dp" &#13;
      android:paddingBottom="10dp"  /&gt; &#13;
 &#13;
      &lt;TextView &#13;
          android:id="@+id/recipe" &#13;
          android:layout_width="wrap_content" &#13;
          android:layout_height="wrap_content" &#13;
          android:textSize="20dp" &#13;
          android:paddingRight="10dp"/&gt; &#13;
 &#13;
  &lt;/LinearLayout&gt; &#13;
</pre><p>Next, add all the images for your fake search results. I'm adding the following to my project's <code class="literal">drawable</code> folder:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">blueberrypancake.jpg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">brownies.jpg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">calamari.jpg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">chilli.jpg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">fryup.jpg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">kashmiricurry.jpeg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">pie.jpeg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">redberrypancake.jpeg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">scallops.jpeg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">surfandturf.jpg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sweetandsourprawns.jpeg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tuna.jpeg</code></li></ul></div><p>I'm going to add all these images plus the corresponding recipe titles to separate arrays. Then, I'm going to feed these arrays to the <code class="literal">ListView</code> via an adapter.</p><div><div><h3 class="title"><a id="note68"/>Note</h3><p>This is much more complex than the first prototype, so to speed things up I'm writing this code as quickly as possible, forsaking a bit of efficiency and optimization along the way.</p></div></div><p>Open your project's <code class="literal">MainActivity.java</code> and add the following:</p><pre class="programlisting">package com.example.jessica.myapplication; &#13;
 &#13;
import java.util.ArrayList; &#13;
import java.util.HashMap; &#13;
import java.util.List; &#13;
 &#13;
import android.app.Activity; &#13;
import android.widget.ListView; &#13;
import android.os.Bundle; &#13;
import android.widget.SimpleAdapter; &#13;
 &#13;
public class MainActivity extends Activity { &#13;
 &#13;
    String[] recipes = new String[] { &#13;
 &#13;
//Create a recipes array// &#13;
 &#13;
          "Easy veggie chilli", &#13;
          "Deep fried calamari with garlic and lemon mayo", &#13;
          "Best-ever chocolate brownies", &#13;
          "Everyday fish pie with cheesy sauce", &#13;
          "Seared tuna with stir-fried veggies", &#13;
          "American style blueberry pancakes with strawberry and banana", &#13;
          "Full English fry up", &#13;
          "Kashmiri curry", &#13;
          "Red berry pancakes with cream", &#13;
          "Sticky sweet and sour prawns", &#13;
          "Surf and turf for two" &#13;
  }; &#13;
 &#13;
//Add all the preceding titles to the recipes array//  &#13;
 &#13;
  int[] images = new int[]{ &#13;
 &#13;
//Create an images array//  &#13;
 &#13;
          R.drawable.chilli, &#13;
          R.drawable.calamari, &#13;
          R.drawable.brownies, &#13;
          R.drawable.pie, &#13;
          R.drawable.tuna, &#13;
          R.drawable.blueberrypancake, &#13;
          R.drawable.fryup, &#13;
          R.drawable.kashmiricurry, &#13;
          R.drawable.redberrypancake, &#13;
          R.drawable.sweetandsourprawns, &#13;
          R.drawable.surfandturf &#13;
  }; &#13;
 &#13;
//Add all the preceding image files to the images array//  &#13;
 &#13;
  @Override &#13;
  public void onCreate(Bundle savedInstanceState) { &#13;
      super.onCreate(savedInstanceState); &#13;
      setContentView(R.layout.activity_main); &#13;
 &#13;
      List&lt;HashMap&lt;String,String&gt;&gt; aList = new&#13;
      ArrayList&lt;HashMap&lt;String,String&gt;&gt;(); &#13;
 &#13;
//Create an array list, called aList//  &#13;
 &#13;
      for(int i=0;i&lt;10;i++){ &#13;
          HashMap&lt;String, String&gt; myMap = new&#13;
          HashMap&lt;String,String&gt;(); &#13;
          myMap.put("recipe", recipes[i]); &#13;
          myMap.put("images", Integer.toString(images[i]) ); &#13;
          aList.add(myMap); &#13;
      } &#13;
 &#13;
//Add recipes and images to aList//  &#13;
 &#13;
      String[] from = { "images","recipe", }; &#13;
 &#13;
      int[] to = { R.id.images,R.id.recipe}; &#13;
 &#13;
//Use the ImageView and TextView from simple_list_layout.xm// &#13;
 &#13;
      SimpleAdapter adapter = new&#13;
      SimpleAdapter(getBaseContext(), aList,&#13;
      R.layout.simple_list_layout, from, to); &#13;
 &#13;
//Create a new SimpleAdapter and feed it three parameters. The first parameter is the context reference (getBaseContext); the second is the collection of data we want to display (aList), and the third is the layout we want to use for each row (simple_layout_list.xml)// &#13;
 &#13;
      ListView listView = ( ListView )&#13;
      findViewById(R.id.listview); &#13;
 &#13;
//Get the ListView object// &#13;
 &#13;
       listView.setAdapter(adapter); &#13;
 &#13;
//Assign the adapter to the ListView object// &#13;
 &#13;
  } &#13;
} &#13;
</pre><p>Attach your Android device to your computer or boot up the emulator and take a look at the results:</p><p>
</p><div><img src="img/B05061_7_6.jpg" alt="Creating your second prototype"/></div><p>
</p><p>Spend some time interacting with your prototype and testing it across different screen configurations, whether that's via Android Studio's preview function or by creating multiple AVDs.</p><p>Now you have two working prototypes; ask yourself whether there's any way you can improve these prototypes. In particular, be on the lookout for any opportunities to split your UI into fragments that you can then combine into multipane layouts that adapt to different screen configurations.</p><p>If your digital prototypes spark any new ideas, then grab a piece of paper and try wireframing these ideas. If these new paper-and-pencil wireframes have potential, then ideally you should put them through the same vigorous digital wireframing, paper prototyping, and usability testing stages that we covered in the previous chapter. At the very least, you should create a digital prototype of your new designs, and spend some time testing these prototypes—again—across as many different screen configurations as possible.</p><p>This may feel like taking a step backward, but this is all invaluable for ensuring that your design really is the best it possibly can be; and if it improves your app, then it's time well spent. If you release the first version of your app when you suspect you could have improved the underlying design, you're not going to have a good time—and neither are your users.</p><p>Also, that old cliché is right—you don't get a second chance to make a first impression. Your average user is going to be far more excited by an amazing app that seems to come out of nowhere, rather than version 2.0 of an app they tried ages ago but weren't too keen on.</p><p>Even if you explore your ideas and then discard them in favor of your original design, at least you'll be confident that you really are releasing the best possible version of your app. Basically, if your digital prototypes have stirred up any new ideas, then now's the time to explore them.</p><div><div><h3 class="title"><a id="note69"/>Note</h3><p>If you do create a new series of wireframes and prototypes, it's always good to get a second opinion, so you may want to consider performing another round of user testing—especially if you find yourself torn between two different design directions for your app.</p></div></div><p>Once you have a set of digital prototypes that you're 100% happy with, it's time to finalize these designs.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Finalizing your design</h2></div></div></div><p>At this point, you should have a firm grasp of the fundamentals of your app's design, including what UI elements should appear on each screen, where they'll appear on the screen, and the navigation patterns that you want to use. However, we still haven't put much thought into the finer details of our app's look and feel. What kind of font are you going to use for the headings? What color should the buttons be? Will there be any background music or sound effects? And how is your app going to use Material Design properties such as elevation and shadow?</p><p>Here are some of the things you need to consider when finalizing your design.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec53"/>Visuals</h3></div></div></div><p>This is the finer point of how your UI elements will look. Although you should try and use Android's standard widgets wherever possible, there's still lots of scope for putting your own twist on standard elements such as buttons and menus, particularly in terms of the color palette you use, plus Material Design elements such as elevation and shadow.</p><p>The ratio of your visual content is also important; should your screen feature lots of images and animation, or should it be more text heavy? As always, make sure you're designing something that'll appeal to your specific target audience. An app that features lots of images and a bright and bold palette might be appropriate for a fun app that's targeting a younger audience, but it's probably not so appropriate for an app that helps busy professionals balance their finances.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec54"/>Background music and sound effects</h3></div></div></div><p>Sound is a powerful way of setting the mood, evoking an emotional response, and giving your users an immediate feeling of what they can expect from your app.</p><p>However, don't feel like you have to include sound in your app; there's nothing wrong with silence, and in some situations, a completely silent app is preferable, especially if people are likely to use your app in situations where noise could be annoying or inappropriate.</p><p>If you do include some form of sound, always consider how integral sound should be to the user being able to successfully interact with your app. As a general rule, your app should be usable regardless of whether users have their volume turned way up, way down, or if they're in a location where they can't hear your app clearly, such as in a busy bar or restaurant.</p><p>The only exceptions are apps that fundamentally rely on sound, such as music streaming apps, an app that gives the user driving directions, or some gaming apps. In these instances, you can be confident that no one will expect to be able to use your app without turning up the volume on their device.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec55"/>Your text</h3></div></div></div><p>Text is your most direct method of communicating with your users. When crafting your text, you need to consider its content along with its visual appearance.</p><p>Your text's appearance has a massive impact on how easily your users can read and understand what that text is saying, but appearance can also send your users subtle messages about the text. For example, you can use <code class="literal">textSize</code> to communicate how important each piece of text is and what category it falls into, such as whether it's a heading, a caption, or a block of code.</p><p>To create text styles that really speaks to your users, you can use the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Text size</strong>: You should decide the size of all your app's major <em>types</em> of text early in the design process and <em>not</em> on a screen-by-screen basis. By limiting yourself to a selection of predefined sizes and using them consistently, your users will quickly learn what each <code class="literal">textSize</code> means. They can then use this information to decipher each new screen they encounter in your app, since they'll instantly know which text is the subheading, the body text, and so on, based on its size. You specify the font size with the <code class="literal">android:textSize</code> attribute, for example, <code class="literal">android:textSize="10sp."</code>. The most common method of setting <code class="literal">textSize</code> in advance is to use themes and styles, which we'll discuss later in this chapter.</li><li class="listitem" style="list-style-type: disc"><strong>Text style</strong>: Android supports bold, italic, and underlined effects, but make sure you use them sparingly. If you use these effects too often, you're adding lots of visual clutter that can make your text difficult to read, plus you'll end up diminishing the effect's impact. You apply bold, italic, underlined, and <code class="literal">bold|italic</code> effects using the <code class="literal">android:textStyle</code> attribute, for example, <code class="literal">android:textStyle="bold."</code>. The underlining text is a bit trickier, as you'll need to create a string resource and apply underlining to the text inside that resource, for example, <code class="literal">&lt;string name="main_title"&gt;&lt;u&gt;This text is underlined&lt;/u&gt;This text isn't&lt;/string&gt;</code>. Then, reference this resource from your project's layout resource file (<code class="literal">android:text="@string/main_title"</code>), and the text will appear underlined in your UI.</li><li class="listitem" style="list-style-type: disc"><strong>Capitalization</strong>: Like bold, italic, and underlined effects, you should use capitalization sparingly so you don't reduce its impact. You should also avoid using all capitals, as the all-caps text is commonly interpreted as shouting, plus it's much harder for your users to read.</li></ul></div><p>The next thing you need to worry about is what your perfectly styled text is actually saying.</p><p>Think of text as your app's voice. This voice should align with your app's overall design. If your design is colorful and upbeat with cheerful music, then your text should be equally friendly. If your design is a bit more edgy, then you may want to give your text more attitude.</p><p>Just don't get carried away! Most of the time, it won't make sense to go to extremes with your text, and you should opt for a plain and neutral tone instead. Remember that the tone and content of your text should reflect the rest of your app's design. So, if your UI is streamlined with a focus on getting the job done, then chances are you'll want your text to be equally to the point.</p><p>If in doubt, play it safe with a neutral tone.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec56"/>Your app's personality</h3></div></div></div><p>I've left this one until last as it's a bit of a vague concept that incorporates a little bit of everything we've discussed so far.</p><p>Your app's <em>personality</em> is a combination of lots of different design elements, from visuals, through to background music and the tone of your text.</p><p>If your app is going to make a clear and distinct impression on your users, then all these different aspects need to align. If these design elements aren't consistent, then chances are that you're going to leave your users with the uneasy feeling that something is a little <em>off</em> about your app.</p><p>Imagine you created an app that uses a neutral, pretty pastel palette; is packed full of cutesy graphics and ends every line of cheerful, upbeat text with at least three exclamation points—but the background music is trash metal!</p><p>Take a critical look at all the design decisions you've just made so far. Do they all come together to form a cohesive whole? Or does one (or more) elements stick out like the proverbial sore thumb?</p><div><div><h3 class="title"><a id="tip70"/>Tip</h3><p>
<strong>Rules are made to be broken!</strong></p><p>Although most of the time you <em>will</em> want all your design aspects to align, occasionally you may decide to throw the user a curveball in the form of an element that intentionally clashes with the rest of your app. This technique can create some very powerful effects; for example, you might combine cheerful colors and enthusiastic text with unsettling music to create a creepy and unnerving experience, or you may want to combine cutesy graphics with dry and sarcastic text to get your users laughing.</p><p>If you do decide to break the rules, just make sure you have a clear idea of what you're trying to achieve and how you're trying to achieve it, as it's easy to get this technique wrong!</p></div></div><p>If you're struggling to decide what your app's overall personality should be, then think about what'll appeal the most to your target audience.</p><p>As always, if you're struggling for inspiration, head over to the Google Play store and hunt down a few apps that are similar to your project or that target the same audience.</p><p>Since we want our recipe app to appeal to students, I'm going to visit the Play store and search for apps that include the word <code class="literal">student</code>. Instantly, I see a whole bunch of timetable and agenda apps, forums that specifically target university students, and homework planners. In this scenario, I'd download a few of the most highly-rated apps, and then spend some time flicking through them to get a feel for their personality. I'd also probably download a few 5 star-rated recipe apps and give them the same treatment before combining all my findings and using them to influence the look and feel of my own recipe app.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Creating themes and styles</h1></div></div></div><p>Now that you've made some decisions regarding the finer details of your UI, it's time to think about how you might implement them. This is where themes and styles come in useful, as they're one of the quickest and easiest ways of implementing design decisions consistently across your views, activities, and even your entire application.</p><p>Once you've made these design decisions, it's a good idea to create styles and perhaps even a theme to help you implement your designs easily and consistently.</p><p>Styles and themes are essentially the same thing: a collection of properties. These properties can be anything from the color of your text, to the size of an <code class="literal">ImageView</code>, or even the <code class="literal">"wrap_content"</code> attribute. The difference isn't how you create this collection of properties, but how you <em>apply</em> them to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Styles are the groups of properties that control what a view looks like; for example, you might apply a style to a <code class="literal">TextView</code> to specify the size and color of all the text within it.</li><li class="listitem" style="list-style-type: disc">Themes are groups of properties that you apply to an activity or even an entire application. When you apply a theme to an activity, every view inside the activity will use any property that applies to it. If you apply a theme to an app, <em>every</em> view throughout that app will use all the applicable properties from this theme. You'll typically extend another theme rather than create one from scratch.</li></ul></div><p>Styles and themes do take a bit of prep work, so why should you go to the effort of creating themes and styles, when you could just apply properties to views directly? There are a few reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>It's efficient</strong>: If you're going to use the same collection of attributes multiple times throughout an app, then defining these properties in advance makes applying them <em>much</em> easier—as easy as typing <code class="literal">style="@style/captionFont"</code> in fact.</li><li class="listitem" style="list-style-type: disc"><strong>It's consistent</strong>: Defining a collection of attributes as a style or theme helps create a consistent look and feel across your app. And as we've already discussed, users <em>love</em> consistency.</li><li class="listitem" style="list-style-type: disc"><strong>It's flexible</strong>: Design changes are pretty much a fact of life, so you should expect to be tweaking your app's visuals throughout the entire development process. Themes and styles provide a central place where you can make changes once and have them appear instantly across your app. Decided that your headings should be 10dp larger? Easy, just increase the <code class="literal">android:textSize</code> attribute in your <code class="literal">style="@style/heading"</code>.</li></ul></div><div><div><h3 class="title"><a id="note71"/>Note</h3><p>Remember when we were talking about the <code class="literal">textSize</code> attribute and how using only a small selection of text sizes can help users decode your UI? This rule also applies to styles. If you use a limited number of styles, your users will quickly pick up what these styles mean, and then use this information to help them decipher new screens. To get the most out of styles (and, to a lesser extent, themes) pay attention to that old cliché: less is more.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Defining styles</h2></div></div></div><p>To create a style (or series of styles), you need to create a <code class="literal">styles.xml</code> file in your project's <code class="literal">res/values</code> folder, if it doesn't contain this file already.</p><p>You can then create styles using the following format:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
 &#13;
//&lt;Resources&gt; must always be the root node of your styles.xml file // &#13;
 &#13;
   &lt;style name="FooterFont" parent="@android:style/FooterText"&gt; &#13;
 &#13;
//Create a new style and assign it a name. In this example, I'm using FooterFont// &#13;
 &#13;
       &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &#13;
 &#13;
//Add each property to your style using the &lt;item&gt; element//  &#13;
 &#13;
       &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &#13;
 &#13;
//The value of each &lt;item&gt; can be a string, a color, a reference to another resource, or another valid value. You'll find a few examples of possible &lt;item&gt; elements below// &#13;
 &#13;
      &lt;item name="android:layout_width"&gt;wrap_content&lt;/item&gt; &#13;
       &lt;item name="android:textColor"&gt;#ffff0000&lt;/item&gt; &#13;
      &lt;item name="android:textSize"&gt;12sp&lt;/item&gt; &#13;
       &lt;item name="android:typeface"&gt;sans_serif&lt;/item&gt; &#13;
 &#13;
   &lt;/style&gt; &#13;
 &#13;
//End of the FooterFont style// &#13;
 &#13;
&lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt; &#13;
 &#13;
//Start of a new CodeFont style// &#13;
 &#13;
     ............ &#13;
     ............ &#13;
     ............ &#13;
 &#13;
//This is where you'd define the CodeFont attributes// &#13;
 &#13;
   &lt;/style&gt; &#13;
 &#13;
//End of the CodeFont style// &#13;
 &#13;
&lt;/resources&gt; &#13;
</pre><p>Okay, so this may look like a lot of work, but bear in mind that you wouldn't create a style to use just once. Typically, you'll define a style in advance, and then use it multiple times throughout your project. Plus once you've defined a style, you can use inheritance to create variations of this style (which we'll explore in more detail later in this chapter).</p><div><div><h3 class="title"><a id="tip72"/>Tip</h3><p>
<strong>What's in a name?</strong></p><p>Put some thought into what you call each style, as a style's name can communicate valuable information about its purpose and relationship with other styles.</p><p>For the best results, always name your styles based on their purpose rather than their appearance, as this might change as you refine your UI.</p><p>As an example, <code class="literal">CaptionStyle</code> is a good name but <code class="literal">ItalicsLightCaption</code> isn't, as your UI might evolve to a point where light, italicized text no longer fits with the rest of your UI. At this point, you have two options. You can continue using this inconsistent style name, which is potentially confusing, especially if you're collaborating on this project with others.</p><p>Alternatively, you'll need to open <code class="literal">styles.xml</code>, and give your style a new name, but you'd then also need to manually change every reference to this style throughout your project. As you can see, neither of these are ideal solutions!</p></div></div><p>Once you've created your style, applying it to a view is straightforward; just open an XML layout resource file and use the <code class="literal">@style</code> attribute, followed by the name of the style you want to apply:</p><pre class="programlisting">&lt;TextView &#13;
   style="@style/CodeFont" &#13;
   android:text="@string/helloworld" /&gt; &#13;
</pre><p>Not all views accept the same style attributes; for example, an <code class="literal">ImageView</code> won't accept an <code class="literal">android:textAlignment</code>. The official Android docs is the best place to check what properties a particular view supports, specifically the view's corresponding class reference where you'll find a table of supported XML attributes. For example, if you were creating a text style, then you might want to take a look at the <code class="literal">TextView</code> class reference (<a class="ulink" href="http://developer.android.com/reference/android/widget/TextView.html">http://developer.android.com/reference/android/widget/TextView.html</a>). Also, bear in mind that some views extend other views, so if you were creating a style to apply to <code class="literal">EditText</code>, it'd be worth taking a look at the <code class="literal">TextView</code> class reference too, as <code class="literal">EditText</code> extends the <code class="literal">TextView</code> class.</p><p>Sometimes, you'll inadvertently apply incompatible properties to a view, particularly when you're applying a style to an entire activity, or when you're applying a theme. So, what happens then? The answer is <em>not much</em>. A view will only accept properties that it supports, and it'll ignore the rest.</p><div><div><h3 class="title"><a id="note73"/>Note</h3><p>When you apply a style to a view, this style is applied to that view only. If you apply a style to <code class="literal">ViewGroup</code>, the child view elements won't inherit the style's properties. If you want to apply a style to multiple views at once, then you should apply the style as a theme instead.</p></div></div><p>Some style properties are not supported by any view, and you can only apply them as a theme to an activity or across an entire app. For example, properties that hide the application title won't have any impact when applied to a single view. These attributes are easy to spot as they all begin with <code class="literal">window</code>, such as <code class="literal">windowNotTitle</code>, <code class="literal">windowTitleSize</code>, and <code class="literal">windowNoDisplay</code>. You'll find the complete list at the <code class="literal">R.attr</code> reference that's available as part of the official Android docs at <a class="ulink" href="http://developer.android.com/reference/android/R.attr.html">http://developer.android.com/reference/android/R.attr.html</a>.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec57"/>Inheritance</h3></div></div></div><p>You can quickly and easily create variations on existing styles by using them as <strong>parent styles</strong> and inheriting their attributes.</p><p>Use the <code class="literal">&lt;parent&gt;</code> attribute to specify the style you want to inherit from. You can then add properties and change the existing properties by overriding them with new values. You can inherit from the styles that you've created yourself or from the styles that are built into the Android platform, such as the following:</p><pre class="programlisting">&lt;style name="MyAppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &#13;
 &#13;
//Creates a new style/theme called MyAppTheme that inherits from the Theme.AppCompat.Light.DarkActionBar platform theme. MyAppTheme will inherit all the characteristics of its parent//  &#13;
 &#13;
  &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &#13;
 &#13;
  &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &#13;
  &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &#13;
 &#13;
//Define whatever properties you want to add or change. Here, I'm overriding the parent theme's colorPrimary, colorPrimaryDark and colorAccent values with values I've defined in my project's colors.xml file//  &#13;
 &#13;
&lt;/style&gt; &#13;
</pre><p>If you want to inherit from the styles that you've defined yourself, you don't have to use the <code class="literal">&lt;parent&gt;</code> attribute. However, it's generally considered best practice to prefix the name of the parent style to the name of your new style, and separate the two with a full stop.</p><p>Imagine I wanted to create a new style that inherits from a custom <code class="literal">FooterText</code> style which I created earlier, but that increases the <code class="literal">textsize</code> from 12sp to 20sp. I'd do this with the following code:</p><pre class="programlisting">   &lt;style name="FooterText.Large"&gt; &#13;
 &#13;
//Notice there's no parent attribute in the &lt;style&gt; tag. Instead, I'm using the name of the original style (FooterText), and affixing the name of the new style (Large)//  &#13;
 &#13;
           &lt;item name="android:textSize"&gt;20sp&lt;/item&gt; &#13;
   &lt;/style&gt; &#13;
</pre><p>You reference this inherited style in exactly the same way as any other style; in this instance that's <code class="literal">style="@style/FooterText.Large"</code>.</p><p>You can continue inheriting like this as many times as you like; just keep chaining these style names together with full stops. There's nothing stopping you from creating <code class="literal">FooterText.Large.Blue</code>, <code class="literal">FooterText.Large.Italic</code>, <code class="literal">FooterText.Large.Blue.Bold</code>, and so on.</p><p>However, to make it easier to remember all your style names correctly and help distinguish between styles, it's a good idea not to get carried away! After all, <code class="literal">FooterText.Large.Blue.Bold.Underlined.Monospace</code> isn't the easiest thing to remember.</p><div><div><h3 class="title"><a id="note74"/>Note</h3><p>Inheriting properties by chaining style names together only works for styles you create yourself. If you want to inherit from Android's built-in styles, you need to use the parent attribute.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Working with themes</h2></div></div></div><p>At this point you may be wondering why we've spent so much time focusing on styles without really discussing themes. This is because you define a theme in exactly the same way you define a style. You could take any of the styles we've defined above, and apply them as a theme.</p><p>To apply a theme, open your project's <code class="literal">Manifest.xml</code> and add the <code class="literal">android:theme </code>attribute to either of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The &lt;application&gt; tag</strong>: If you want to apply a theme across your entire app, find the <code class="literal">&lt;application&gt;</code> tag and add the <code class="literal">android:theme</code> attribute, plus your style name, for example, <code class="literal">&lt;application android:theme="@style/FooterFont"&gt;</code></li><li class="listitem" style="list-style-type: disc"><strong>The &lt;activity&gt; tag</strong>: To apply your theme to a specific activity, add <code class="literal">android:theme</code> to the relevant <code class="literal">&lt;activity&gt;</code> tag</li></ul></div><p>When you apply a theme, every view within the activity or across the app will use all the theme properties that it can support. If you apply <code class="literal">FooterFont</code> to an activity, all <code class="literal">TextViews</code> (and views that extend <code class="literal">TextView</code>) within that activity will use this collection of properties. If you apply <code class="literal">FooterFont</code> across your app, all <code class="literal">TextViews</code> and views that extend <code class="literal">TextView</code> will assume these properties, but any view that <em>doesn't</em> support the <code class="literal">FooterFont</code> properties will simply ignore them. And if a view supports some of the <code class="literal">FooterFont</code> properties and not others, it'll apply the supported properties and ignore the rest.</p><p>To save you time and effort, the Android platform includes many predefined themes that you can use, including a selection of Material themes. You'll find a list of all the available styles in the <strong>R</strong>.style section  of the official Android docs (<a class="ulink" href="http://developer.android.com/reference/android/R.style.html">http://developer.android.com/reference/android/R.style.html</a>). To use any of the platform styles and themes, replace all the underscores in the style name with a period, so <code class="literal">Theme_Dialog</code> becomes <code class="literal">"@android:style/Theme.Dialog"</code>.</p><p>If you want to customize a built-in theme, you should use the theme as the <code class="literal">&lt;parent&gt;</code> tag of your own custom theme, and then add your own properties or override the existing properties, as follows:</p><pre class="programlisting">&lt;style name="MyTheme" parent="android:Theme.Light"&gt; &#13;
 &#13;
//Create a new style called MyTheme, that inherits from the android:Theme.Light platform theme// &#13;
 &#13;
   &lt;item&#13;
 name="android:windowBackground"&gt;@color/custom_theme_color&lt;/item&gt; &#13;
 &#13;
//This is where you add your own attributes, or override existing attributes//  &#13;
 &#13;
   &lt;item name="android:colorBackground"&gt;@color/custom_theme_color&lt;/item&gt; &#13;
 &#13;
&lt;/style&gt; &#13;
</pre><p>The final step is updating your project's <code class="literal">Manifest</code> to use your new theme. So, if you wanted to use <code class="literal">MyTheme</code> in a specific activity, you'd write the following:</p><pre class="programlisting">&lt;activity android:theme="@style/CustomTheme"&gt; &#13;
</pre><p>To use <code class="literal">MyTheme</code> across your entire application, you'd write the following:</p><pre class="programlisting">&lt;application android:theme="@style/CustomTheme"&gt; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Get ready for errors!</h1></div></div></div><p>In a perfect world, users will only ever interact with your app under ideal conditions. If your app pulls content from the Internet, people will only ever open your app when they have a lightning-fast connection to the World Wide Web. Your app will never have to deal with interruptions such as pesky incoming calls or SMS messages, and your users will certainly <em>never</em> enter their username or password incorrectly.</p><p>Sadly, this isn't the way the real world works. Your users will make mistakes, run out of storage space, lose their Internet connection, and get phone calls when they're midway through the final boss battle in your RPG app. Your app must be able to handle all these less-than-ideal conditions and errors.</p><p>It may seem strange to plan for errors, but unfortunately errors happen to the best of us. Not only should your app be able to handle errors when they do occur, but it should handle them <em>gracefully</em>.</p><p>In the final section of this chapter, we'll look at how to design your app so that it can handle whatever the real world throws at it.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>User input errors</h2></div></div></div><p>User input errors are where users enter incorrect information or leave a field blank. The most common places where user errors occur are forms such as login screens or payment screens.</p><p>Assuming that you clearly communicated what information the user needed to enter, technically these errors aren't your fault, but you should still design your app to be able to cope with these kinds of error.</p><p>When user errors occur, your app should clearly communicate what's happened and give the user enough information to be able to fix the problem. Simply displaying a popup that says <em>Error</em> isn't going to cut it.</p><p>Ideally, your error messages will include an action that helps the user fix the error. In our popup example, once the user has dismissed the popup, our app could automatically select the <code class="literal">EditText</code> where the user had entered the incorrect information, ready for them to start typing.</p><p>You should only offer actions that you can actually support, so if the error is caused by the user running out of storage space, then offering them a <strong>Try Again</strong> button isn't going to solve the problem. If you can't help the user resolve an error, it's far better to explain to them what the error is, what's caused it, and how they can fix it, rather than offering an empty gesture that's probably going to leave them feeling even more frustrated.</p><p>When your app does encounter user error, it should try to preserve as much user-entered information as possible. So, if a user fills in a form but then enter their password incorrectly, your app should preserve their username, address, and any other fields they've filled in correctly, while highlighting the fact that they've entered the wrong password.</p><p>However, while you handle user input errors, don't overlook the importance of good design. If your app is going to fail, then it might as well fail in style! A well-designed error message should feel like a natural extension of your app. In our popup example, we could edit the popup so its colors better complement our app's overall color scheme, or we could change the font or include a custom sound effect that reflects our app's personality.</p><p>Even though I've used a popup message as an example, you should always look for ways to make your error messages as unobtrusive as possible, and popups aren't particularly subtle. More unobtrusive methods include underlining, highlighting, automatically selecting a field where the user has entered something incorrectly, reloading the screen with the addition of some text explaining the error that's occurred, or taking the user back to the screen where they have entered the wrong info.</p><p>Although user input is one of the most common causes of errors, there are other errors and less-than-ideal conditions that your app needs to be able to handle. These include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Lack of connectivity</strong>: If the user is offline and tries to access a feature that requires the Internet or network access, you should display an unobtrusive message explaining that they need an Internet connection in order to complete this action.</li><li class="listitem" style="list-style-type: disc"><strong>Incompatible state</strong>: These errors occur when the user attempts to run conflicting operations, such as trying to send a message via an online messaging app when they're offline. When these errors occur, your app should display a message explaining the error and ideally provide the user with an easy way of changing their current state.</li><li class="listitem" style="list-style-type: disc"><strong>Missing permissions</strong>: If the user selects an action that requires a certain permission, your app should notify the user and give them the option of granting that permission. If the user denies this permission request, you should disable all related features, so the user doesn't keep trying to access features that your app can't currently support. You should also give the user an easy way of granting previously denied permissions, just in case they change their mind. If certain permissions are essential for your app, you should request them in advance. We'll look at permissions in much more detail in <a class="link" href="ch10.html" title="Chapter 10. Best Practices and Securing Your Application">Chapter 10</a>, <em>Best Practices and Securing Your Application</em>.</li><li class="listitem" style="list-style-type: disc"><strong>Empty states: </strong>These occur when your app can't display regular content; for example, a <code class="literal">ListView</code> that contains no search results. You should design your app to be able to deal with missing content, although the best way to handle the situation will vary depending on the context and the type of content that's missing. In our search results example, you could create a <strong>No results found</strong> screen, or the app could automatically widen the search query and display content that's the best possible match. For example, if the user searches for <code class="literal">burito</code>, your app could display all recipes that include the word <code class="literal">burrito</code> instead of displaying nothing.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you do decide to take a best-possible-match approach, then you should signal that this content isn't an exact match. In our search results example, we might display a message along the lines of <strong>"We couldn't find any results for burito, did you mean burrito?"</strong></li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Content unavailable:</strong> This is subtly different to empty states as it involves content that should appear in your app but for some reason isn't available. For example, perhaps your UI includes images or videos that need to be downloaded from the Internet, but the user is currently offline. If your app includes this kind of content, you should create placeholders that'll appear in your layout when the content is unavailable. If you don't, then there's the risk that your layout will suddenly jump about as the missing content becomes available and is inserted into the layout, something you may have encountered before when browsing slow-to-load webpages on your mobile device. Creating placeholders also ensures that your layout retains its intended structure even when some of its content is missing.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, you learned how to quickly create digital prototypes based on your wireframes. Although you created paper prototypes previously, digital prototyping is particularly useful for testing how your screen designs will look and function on a real Android device and across different screen configurations.</p><p>The most important thing to take away from this chapter is that wireframes are a way of planning how your screens will look and function in <em>theory</em>, but digital prototypes are how you put that theory to the test. Sometimes, you may find that the theory doesn't work in practice and that you need to make some changes to your wireframes or even redo them completely, but that's okay—discovering problems with your design is all part of creating the best possible version of your app.</p><p>Now that you've finalized your design, in the next chapter we'll take a closer look at how you can ensure this newly finalized design translates correctly across as many different Android devices as possible.</p></div></body></html>