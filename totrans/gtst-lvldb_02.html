<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Installing LevelDB and Building for iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Installing LevelDB and Building for iOS</h1></div></div></div><p>The basics of getting LevelDB downloaded and unpacked are the same as in the beginning of <a class="link" href="ch01.html" title="Chapter 1. Downloading LevelDB and Building with OS X">Chapter 1</a>, <span class="emphasis"><em>Downloading LevelDB and Building with OS X</em></span>, but we will be rebuilding the library and need to vary the build steps a bit for iOS. Building for iOS is referred to as <a id="id24" class="indexterm"/>
<span class="strong"><strong>cross-compilation </strong></span>as the code being generated is for a different processor architecture from that running the compiler.</p><div class="section" title="Building the static LevelDB library for iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>Building the static LevelDB library for iOS</h1></div></div></div><p>To start with, we are going to <a id="id25" class="indexterm"/>rebuild the <code class="literal">libleveldb.a</code> file. <a id="id26" class="indexterm"/>This time, we are building without snappy and building for multiple architectures: the 32 bit x86 for the simulator and armv6 and armv7 for iOS devices. We'll finish by renaming it for iOS.</p><p>First up, remove snappy compression in a terminal in your snappy directory: </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make uninstall</strong></span>
<span class="strong"><strong> ( cd '/usr/local/share/doc/snappy' &amp;&amp; rm -f ChangeLog COPYING INSTALL NEWS README format_description.txt framing_format.txt )</strong></span>
<span class="strong"><strong> ( cd '/usr/local/include' &amp;&amp; rm -f snappy.h snappy-sinksource.h snappy-stubs-public.h snappy-c.h )</strong></span>
<span class="strong"><strong> /bin/sh ./libtool   --mode=uninstall rm -f '/usr/local/lib/libsnappy.la'</strong></span>
<span class="strong"><strong>libtool: uninstall: rm -f /usr/local/lib/libsnappy.la /usr/local/lib/libsnappy.1.dylib /usr/local/lib/libsnappy.dylib /usr/local/lib/libsnappy.a</strong></span>
</pre></div><p>Now change the directory back to your LevelDB source and clean, then try making for iOS. If you are using LevelDB 1.10, this will fail due to a bug in the makefile:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make clean</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>$ CXXFLAGS="-std=c++11 -stdlib=libc++" make PLATFORM=IOS</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>make: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/c++: No such file or directory</strong></span>
<span class="strong"><strong>make: *** [db/builder.o] Error 1</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The bug that occurs in LevelDB 1.10 is fixed in LevelDB 1.14.0</p></div></div><p>The makefile included with LevelDB v1.10 has a bug (logged as issue 177 <a class="ulink" href="https://code.google.com/p/leveldb/issues/detail?id=177">https://code.google.com/p/leveldb/issues/detail?id=177</a>), because the command-line compilers moved after Xcode 4.3. Apple moved these several times and so different vintages of open source projects run into this problem. You can grab the associated <code class="literal">MakefileASD</code> from the <a id="id27" class="indexterm"/>Packt Publishing website or edit a copy of makefile as described:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open makefile in a text <a id="id28" class="indexterm"/>editor and go down to the end where there is a section starting with:<div class="informalexample"><pre class="programlisting">ifeq ($(PLATFORM), IOS)
# For iOS, create universal object files</pre></div></li><li class="listitem">You need to change the two lines starting with:<div class="informalexample"><pre class="programlisting">$(DEVICEROOT)/usr/bin/$(C</pre></div></li><li class="listitem">And just remove the <code class="literal">$(DEVICEROOT)/usr/bin/</code> so they start with <code class="literal">$(CC)</code> and <code class="literal">$(CXX)</code>.</li><li class="listitem">Assuming you save this file as <code class="literal">MakefileASD</code>, you can repeat the make:<div class="informalexample"><pre class="programlisting">$ CXXFLAGS="-std=c++11 -stdlib=libc++" make –f MakefileASD PLATFORM=IOS
$ mv libleveldb.a /usr/local/lib/libleveldb_IOS.a</pre></div></li></ol></div><p>This generates and then copies the static library <code class="literal">libleveldb_IOS.a</code> with the standard C++11 libc++ library, instead of the default, so it matches a default Xcode project. If you look at the log, you will see the <a id="id29" class="indexterm"/>
<code class="literal">lipo</code> command is used to combine binaries of different processor type. You can also use <code class="literal">lipo</code> to check a library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lipo -info /usr/local/lib/libleveldb_IOS.a</strong></span>
<span class="strong"><strong>Architectures in the fat file: libleveldb_IOS.a are: armv6 armv7 i386</strong></span>
</pre></div><p>Lipo can inspect or operate on either individual object files or compiled libraries.</p><div class="section" title="Creating a minimal iOS Testbed"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Creating a minimal iOS Testbed</h2></div></div></div><p>To start with, we're <a id="id30" class="indexterm"/>going to create the simplest iOS program possible that can run and show feedback on the device. It will just display an alert to indicate we have made a database.</p><p>If you're keeping things together with a <a id="id31" class="indexterm"/>workspace, as recommended in an earlier chapter, open up that workspace in Xcode.</p><p>Now navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project…</strong></span> which presents a template chooser. Choose an iOS application in the left panel and click on <span class="strong"><strong>Empty Application</strong></span> in the icons provided, then click on <span class="strong"><strong>Next</strong></span>. Leave the <span class="strong"><strong>Use Automatic Reference Counting</strong></span> checkbox checked and uncheck <span class="strong"><strong>Include Unit Tests</strong></span>. Make sure you specify the <span class="strong"><strong>Product Name</strong></span> and <span class="strong"><strong>Company Identifier</strong></span>. You will see as you type in those entries that the Bundle Identifier is being generated from them, for example, <code class="literal">Packt.LevelDB-iOS-Sample02</code>.</p><p>Click in the project navigator to <a id="id32" class="indexterm"/>select the <span class="strong"><strong>AppDelegate</strong></span> (for example, <code class="literal">GSwLDBAppDelegate.m</code>) source. This is the only program source we're going to customize for this test.</p><p>For a simple test like this we <a id="id33" class="indexterm"/>just need to customize the method <code class="literal">application: didFinishLaunchingWithOptions</code> which initially contains:</p><div class="informalexample"><pre class="programlisting">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.window = [[UIWindow alloc] 
    initWithFrame:[[UIScreen mainScreen] bounds]];
  self.window.backgroundColor = [UIColor whiteColor];
  [self.window makeKeyAndVisible];
  return YES;
}</pre></div><p>Before the <code class="literal">return</code> <a id="id34" class="indexterm"/>statement, add the lines:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">  </code>UIAlertView* helloWorldAlert = [[UIAlertView alloc]
    initWithTitle:@"Getting Started with LevelDB"
    message:@"Hello, LevelDB World!"
    delegate:nil
    cancelButtonTitle:@"OK" 
    otherButtonTitles:nil];
  [helloWorldAlert show];
  return YES;</pre></div><p>Choose one of the <span class="strong"><strong>Simulator</strong></span> schemes from the pop-up near the <span class="strong"><strong>Run</strong></span> button. And click on <span class="strong"><strong>Run</strong></span> to compile and see the app <a id="id35" class="indexterm"/>run and show the little alert.</p></div><div class="section" title="Adding LevelDB to the iOS Testbed"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Adding LevelDB to the iOS Testbed</h2></div></div></div><p>We basically repeat the steps done for the OS X project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add the include paths to find <a id="id36" class="indexterm"/>the LevelDB headers, <code class="literal">/usr/local/include</code>, into the <span class="strong"><strong>User Header Search Paths</strong></span></li><li class="listitem" style="list-style-type: disc">Add the library <code class="literal">/usr/local/lib/libleveldb_IOS.a</code> into the <span class="strong"><strong>Link Binary With Libraries</strong></span> panel</li><li class="listitem" style="list-style-type: disc">Add <code class="literal">/usr/local/lib</code> to <a id="id37" class="indexterm"/>the <span class="strong"><strong>Library Search Paths</strong></span></li></ul></div><p>To include some C++ code into our Objective-C file we need to tell the compiler to treat it as Objective-C++ which is done by changing the file extension from <code class="literal">.m</code> to <code class="literal">.mm</code>. Click on the filename in the project navigator and hit <span class="emphasis"><em>Enter</em></span> to be able to edit the name.</p><p>Now you can add the <code class="literal">#include</code> statements as we did in <code class="literal">Sample01</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;cassert&gt;
#include "leveldb/db.h"</pre></div><p>Add the same database statements as we did in OS X, so the entire method looks like the following code:</p><div class="informalexample"><pre class="programlisting">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame:[
     [UIScreen mainScreen] bounds]];
    // Override point for customization after application launch.
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    leveldb::Status status = leveldb::DB::Open(
    options, "/tmp/testdbios", &amp;db);
    assert(status.ok());

    UIAlertView* helloWorldAlert = [[UIAlertView alloc]
      initWithTitle:@"Getting Started with LevelDB"
      message:@"Hello, LevelDB World!"
      delegate:nil
      cancelButtonTitle:@"OK" otherButtonTitles:nil];
    [helloWorldAlert show];
    delete db;    
    return YES;
}</pre></div><p>You can again click on <span class="strong"><strong>Run</strong></span> and see <a id="id38" class="indexterm"/>that this runs within the simulator. After it runs, go and have a look in the directory <code class="literal">/tmp/testdbios</code> and you will see your files created there. However, this works only because the simulator is running with full access to your OS X filesystem. You can't create files in <a id="id39" class="indexterm"/>arbitrary directories in this way on an iOS device.</p><p>Plug in a registered iOS device and change the <span class="strong"><strong>Scheme</strong></span> to point to that device so you can run on the device. Now run the application. You will see the application appear but not the expected alert. The <a id="id40" class="indexterm"/>Xcode <span class="strong"><strong>Output</strong></span> window shows an error message like:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Assertion failed: (status.ok()), function -[GSwLDBAppDelegate application:didFinishLaunchingWithOptions:], file /Users/andydent/dev/learning/leveldb_OSX/LevelDB_IOS_Sample02/LevelDB_IOS_Sample02/GSwLDBAppDelegate.mm, line 27.</strong></span>
</pre></div><p>This is because the app can't access the path <code class="literal">/tmp</code>. The iOS filesystem is guarded with a <span class="strong"><strong>sandbox</strong></span> for every application and within that are some directories with different significance to the OS. Some are caches that can be flushed without your application being told if space runs low. Some are synchronized to iCloud.</p><p>For now, we will put our data into the standard cache area <code class="literal">NSCachesDirectory</code> (which currently maps to <code class="literal">Library/Caches</code>). This is for temporary data and may be flushed.</p><p>Add the following helper method <a id="id41" class="indexterm"/>earlier in your <code class="literal">GSwLDBAppDelegate.mm</code> source file:</p><div class="informalexample"><pre class="programlisting">- (NSString*)pathForCachedDir:(NSString*)dirname {
  staticNSString* cachePath = nil;
  if (cachePath == nil) {  // save path first time per-runNSArray* paths =
      NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask, YES);
    cachePath = [paths objectAtIndex:0];
    BOOL isDir = NO;
    NSError *error;if (! [[NSFileManagerdefaultManager] 
      fileExistsAtPath:cachePath isDirectory:&amp;isDir] &amp;&amp; 
      isDir == NO) { // create cache – first run on this device[[NSFileManagerdefaultManager] 
          createDirectoryAtPath:cachePath
          withIntermediateDirectories:NO
          attributes:nilerror:&amp;error];}  }
  return [cachePath stringByAppendingPathComponent:dirname];
}</pre></div><p>Now fix our database opening code, replacing the line:</p><div class="informalexample"><pre class="programlisting">leveldb::Status status = leveldb::DB::Open(options, 
    "/tmp/testdbios", &amp;db);</pre></div><p>With these two lines, which use our helper to find the cache directory:</p><div class="informalexample"><pre class="programlisting">NSString* tempPath = [self pathForCachedDir:
   @"testdbios"];
leveldb::Status status = leveldb::DB::Open(options, 
  [tempPath UTF8String], &amp;db);</pre></div><p>Running on the device now will work and show the alert. Running on the simulator still works but is putting the file in a <a id="id42" class="indexterm"/>location that will vary. If you put a breakpoint on the <a id="id43" class="indexterm"/>last line you can see the value of <code class="literal">tempPath</code> in the debugger on a device, which will appear as:</p><div class="informalexample"><pre class="programlisting">/var/mobile/Applications/37742F10-B3D6-4945-A4CA-5F7764D4E33A/Library/Caches/testdbios </pre></div><p>But in the simulator, it's an absolute path on your desktop, like:</p><div class="informalexample"><pre class="programlisting">/Users/andydent/Library/Application Support/iPhone Simulator/6.1/Applications/1017B648-DA52-4909-A1B2-18343722686A/Library/Caches/testdbios</pre></div><p>In this path, the simulator type varies and the next directory down is the iOS version, then eventually the library directory from which it's the same as on a device.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Summary</h1></div></div></div><p>Once again we built the LevelDB static library and learned how to choose a different standard C++ library to match Xcode's defaults. Creating a trivial iOS application, we were able to link it with a LevelDB library suitable for both simulator and iOS devices. We then saw how that runs in the simulator compared to the sandboxed filesystem of a device.</p></div></body></html>