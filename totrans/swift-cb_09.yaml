- en: Performance and Responsiveness in Swift
  prefs: []
  type: TYPE_NORMAL
- en: We have covered a lot of ground in the previous chapters, and we have a lot
    of Swift tools in our tool belt. Now it's time to delve into more advanced topics,
    looking at how certain Swift types are implemented, how they can be used, and
    what their performance characteristics are. We will also look at how we can perform
    asynchronous tasks using **Grand Central Dispatch** (**GCD**) through the Dispatch
    framework and the higher-level operations in the Foundation framework that are
    also built on GCD.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the multithreaded environment available on all Apple platforms,
    as well as the performance profile of the Swift constructs you use, is vital to
    building a fast and responsive app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Value and reference semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Dispatch queues for concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent queues and dispatch groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the operation class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3bn2l2O](https://bit.ly/3bn2l2O)'
  prefs: []
  type: TYPE_NORMAL
- en: Value and reference semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw back in Chapter 1, *Swift Building Blocks*, that certain Swift types
    behave differently from others, specifically regarding ownership and the mutation
    of properties. We even defined this difference, saying that classes are *reference*
    types, while structs and enums are *value* types. In this recipe, we will examine
    why these types behave differently and the performance implications this entails.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the model for an app that allows a user to schedule events that
    they do every day and reminds them when these events should occur.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to decide how we will model our daily event. The key to this decision
    is whether we want our event to have reference semantics or value semantics. We
    discussed the differences between the two in [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*, but let's re-examine the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '*Value* types are simple data structures that you can think of as just bundles
    of data. Swift makes these types more useful by allowing them to have methods,
    but any change or *mutation* of the underlying data results in a whole new bundle
    of data. In contrast, *reference* types are more complex data structures that
    have an identity outside of their component properties. Therefore, a change in
    the component properties will be available via any references to the object.'
  prefs: []
  type: TYPE_NORMAL
- en: A value type's simple composition has the advantage of being very cheap on resources
    to create and maintain. However, this simplicity comes at the expense of dynamic
    dispatch, which enables sub-classing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given this distinction, what behavior do we want for our daily event? If we
    change the name of our event, should we expect anything that has a reference to
    it to also see that change? That sounds like the behavior we want, so our daily
    event should be a reference type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check that this gives us the behavior we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We want to be reminded of our event every day at a certain time, but for our
    purpose, `Date` in `Foundation` is a bit of an overkill, since it contains both
    date and time information, and we only need to maintain time information. Let's
    create something to represent the time, irrespective of the date. What behavior
    is most appropriate for our time model? Should it have reference semantics or
    type semantics?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try both and see which seems to most accurately model the situation
    we are after:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create time as a class, with reference semantics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how this will behave when its properties are changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we change the properties of an instance of `ClockTime`, it has the unintended
    consequence of changing all references to that same instance of `ClockTime`. Since
    reference semantics aren't a perfect fit for `ClockTime`, let's change it to a
    value type and see whether that is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two options for value types in Swift; we can model `ClockTime`
    as a `struct` or an `enum`. Enums are great for modeling concepts that have a
    small number of finite values. While there are a finite number of minutes in a
    day, it''s not a small number, and we might want to do math calculations on the
    hours and minutes in `ClockTime`, so a `struct` is more appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this changes the behavior when we change the properties of a
    `ClockTime` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With `ClockTime` as a value type, changing a property of a `ClockTime` instance
    results in a new instance, so the change doesn't have the unintended consequences
    that we saw when it was a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let's consider some of the dynamic features that we will give up by
    making `ClockTime` a value type. Will we ever want to subclass `ClockTime`? This
    doesn't seem likely, and it is right to characterize `ClockTime` as a simple bundle
    of data. So, in this scenario, modeling `ClockTime` as a value type is the right
    decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the model, we will add a `ClockTime` property to the `DailyEvent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already covered how value types differ from reference types. Now, let's
    examine why they behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'When storing new instances of a type in memory, Swift has two different data
    structures that it can use for storage: the **Stack** and the **Heap**. These
    structures are common to many programming languages. Value types are stored on
    the **Stack**, and reference types are stored on the **Heap****.** Understanding
    how data is stored in these structures, even at the superficial level that we
    will cover, will help us to understand why value types and reference types have
    differing behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: The stack can be thought of as sequential blocks of data. An instance of a type
    may be represented by multiple blocks of data, and an instance can be referenced
    using the memory position of its first piece of data. A **Stack Pointer**, which
    is a reference to the memory position at the end of the stack, is maintained.
    New instances are always added to the end of the stack, and then the stack pointer's
    position is updated to the new end of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through adding a value type instance using a simplified diagram of
    the stack. Before anything is added, the stack pointer is at the top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3981653-ae39-4677-87e0-ec80787be9e2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Representation of the stack and stack pointer
  prefs: []
  type: TYPE_NORMAL
- en: 'A `ClockTime` struct for 07:00 is added to the stack. This takes up three blocks,
    and the stack pointer moves to the next empty block on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa8bb748-2db5-48e2-82e3-06b4eacb04f2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Stack pointer after adding a ClockTime struct for 7:00
  prefs: []
  type: TYPE_NORMAL
- en: 'Another `ClockTime` struct for 09:30 is added to the stack. This has a size
    of four blocks, and the stack pointer moves to the next empty block on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91818305-f75d-4005-b9ba-3637859a4a6a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Stack pointer after adding a ClockTime struct for 9:30
  prefs: []
  type: TYPE_NORMAL
- en: 'Once data is placed on the stack, it is immutable. To see why this is an important
    restriction, let''s try and change our first `ClockTime` instance on the stack.
    The simplicity and efficiency of the stack is predicated on the fact that it is
    a continuous block of memory. If we try and change any data already on the stack,
    it may take up more space, which will cause data in the subsequent blocks to be
    overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad6256b-de25-4ba5-8cef-a21b203ba00f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Changing the first ClockTime instance on the stack
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, any change to a `struct` results in a new, changed version of the
    `struct` appended at the end of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s mutate a `ClockTime` instance and see how that looks in our simplified
    stack representation by taking it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a `ClockTime` struct for 9:00 assigned to the variable named `event1Time`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following diagram for a visual representation of how this may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0ac446d-b30a-44ed-bfa7-9f7304a5fe25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Assigning the event1Time variable to a ClockTime struct for 09:00
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `event1Time` is also assigned to a new variable, called `event2Time`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/171561e4-439a-48ae-b392-ed8dccf7ed6b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Assigning the value of event1Time to event2Time
  prefs: []
  type: TYPE_NORMAL
- en: 'When we mutate `event2Time`, changing the minute value to `30`, a new `ClockTime`
    instance with the changed minute value is placed at the end of the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5a7b80e6-e41f-41bd-a1f7-69b005a4543f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The new ClockTime instance placed at the end of the stack
  prefs: []
  type: TYPE_NORMAL
- en: The `event2Time` variable now points to this new stack position, while `event1Time`
    continues to point to the stack position of the original `ClockTime` struct for
    09:00.
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding examples show, the stack is a very simple and efficient data
    structure, and its properties explain the behavior we see when we use value types
    such as `struct` and `enums`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, reference types, such as class objects, are stored on the heap,
    which enables more dynamic and complex behavior at the expense of efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'An accurate look at heap allocations is beyond the scope of this book, but
    let''s take a very simplified look at how a reference type instance is stored
    on the **Heap**. The heap is not a continuous chain of blocks, but an area of
    memory that can be free or already allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699c254b-0e9e-4cda-a47e-b0642d70f6a8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Representation of the heap
  prefs: []
  type: TYPE_NORMAL
- en: 'When a class is allocated to the heap, it must search through the heap to find
    a set of free blocks appropriate for its size. The reference type instance may
    include references to other reference types or value types by storing their stack
    positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b397d89e-dcc4-4bfd-b03a-1e23c1898178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Allocation of a class in the heap
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple variables can hold references to the same instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58e4a2b8-89de-4e90-9d73-1b0db7cbd05c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Multiple variables holding references to the same instances
  prefs: []
  type: TYPE_NORMAL
- en: 'When reference types are modified, they aren''t copied. Instead, extra space
    must be found to accommodate the extra information. All references to the instance
    have the changed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf8452ee-3324-439e-a907-4244a9233cee.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Modifying reference types
  prefs: []
  type: TYPE_NORMAL
- en: This recipe describes the difference between reference semantics and value semantics,
    and hopefully illustrates that these behaviors arise from the way in which they
    are stored in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Both have their uses, and it's important to choose the right type when building
    your model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Swift blog**: Value and reference types: [http://swiftbook.link/blog/type-semantics](http://swiftbook.link/blog/type-semantics)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple Developer Videos (developer account needed)**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'WWDC 2016 - Protocol and Value-Oriented Programming in UIKit Apps: [https://developer.apple.com/videos/play/wwdc2016/419](https://developer.apple.com/videos/play/wwdc2016/419)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Dispatch queues for concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We live in a multicore computing world. Multicore processors are found in everything,
    from our laptops and mobile phones to our watches. With these multiple cores comes
    the ability to work in parallel. These concurrent streams of work are known as
    *threads*, and programming in a multithreaded way enables your code to make the
    best use of the processor's cores. Deciding how and when to create new threads
    and manage the available resources are complex tasks, so Apple has built a framework
    to do the hard work for us. It is called *Grand Central Dispatch*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grand Central Dispatch** (**GCD**) handles the thread maintenance and monitors
    the available resources while providing a simple, queue-based interface for getting
    concurrent work done. With the open-sourcing of Swift, Apple also open-sourced
    GCD in the form of `libdispatch`, since Swift does not yet have built-in concurrency
    features.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore some of the features of `libdispatch`, also
    known as the Dispatch framework, and see how we can use concurrency to build apps
    that are efficient and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how we can improve the responsiveness of an app using GCD, so first,
    we need to start with an app that requires some improvement. Go to [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups).
    Here, you will find the repository of an app that takes a collection of photos
    and turns them into a PDF photo book. You can download the app source files directly
    from GitHub or by using `git`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you build and run the app, you will see a collection of sample images, with
    the ability to add more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dbb1d24-5525-4173-9c7c-10b3bbe95ec1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Sample images
  prefs: []
  type: TYPE_NORMAL
- en: When you tap on Generate Photo Book, the app will take the photos you have chosen,
    resize them to the same size, and save them as a multi-page PDF that can then
    be exported or shared. Depending on how many photos are included and the performance
    of the device, this process can take a little time to complete. During this time,
    the whole interface is unresponsive; for example, you can't scroll through the
    pictures.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine why the app is unresponsive during photo book generation and
    how we can fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `PhotoBookCreator` project and navigate to `PhotoCollectionViewController.swift`.
    In this file, you will find the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we call three functions that can take quite a long time to complete.
    We take the output of one function and feed it into the next function, and the
    result is a URL for our photo book, which we then launch with some UI to preview
    and export.
  prefs: []
  type: TYPE_NORMAL
- en: This work to resize and crop the photos, and then generate the photo book, is
    taking place in the same queue where UI touch events are processed, the main queue,
    which is why our UI is unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To free up the main queue for UI events, we can create our own private queue,
    which we can use to execute our long-running functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By calling the `async` method on our `DispatchQueue` and providing a block of
    code, we are scheduling that block to be executed. GCD will execute that block
    when resources are available. Now, our long-running code isn't blocking the main
    queue, so our UI will remain responsive; however, if you were to run the app with
    just this change, you would get some very odd behavior when the app tried to show
    the preview view controller.
  prefs: []
  type: TYPE_NORMAL
- en: We just discussed the fact that UI touch events are delivered to the main queue,
    which is why we wanted to avoid blocking it; however, `UIKit` expects *all* UI
    events to happen on the main queue. Since we are currently creating and presenting
    the preview view controller from our private queue, we are defying this `UIKit`
    expectation, which can produce a number of bugs, including UI elements that never
    appear, or appear long after they were presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we need to ensure that when we are ready to present
    our UI, we do that operation on the main queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run the app, you will find that you can generate a photo book while
    still being able to interact with the UI; for instance, being able to scroll the
    table view.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GCD uses queues to manage blocks of work in a multithreaded environment. Queues
    operate on a **first in first out** (**FIFO**) policy. When GCD determines that
    resources are available, it will take the next block from the queue and execute
    it. Once the block has finished executing, it will be removed from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e89ccaf5-a5e4-44f1-b15f-6d0e8d94b819.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – FIFO policy
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of `DispatchQueue`: *serial* and *concurrent*. With the
    simplest form of a queue, a serial queue, GCD will only execute one block at a
    time from the top of the queue. When each block finishes executing, it is removed
    from the queue, and each block moves up one position.'
  prefs: []
  type: TYPE_NORMAL
- en: The main queue, which processes all UI events, is an example of a serial queue,
    and this explains why performing a long-running operation on the main queue will
    cause your UI to become unresponsive. While your long-running operation is executing,
    nothing else on the main queue will be executed until the long-running operation
    has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the second type of queue, a concurrent queue, GCD will execute as many
    blocks on different threads as resources allow. The next block to execute will
    be the block closest to the top of the stack that isn''t already executing, and
    blocks are removed from the stack when finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82170dbe-0af1-4bbb-89c3-1d883a108df9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Execution when the second type of queue is added
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent queues can be really useful when you have numerous operations that
    are independent of each other. We will look into concurrent queues further in
    the *Concurrent queues and dispatch groups* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GitHub repository for `libdispatch`: [https://github.com/apple/swift-corelibs-libdispatch](https://github.com/apple/swift-corelibs-libdispatch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation for dispatch queues: [http://swiftbook.link/docs/dispatchqueue](http://swiftbook.link/docs/dispatchqueue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent queues and dispatch groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked into using a private serial queue to keep
    our app responsive by moving long-running operations off the main queue. In this
    recipe, we will break our operations down into smaller, independent blocks and
    place them on a concurrent queue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to build on the app we improved in the last recipe, which is an
    app that will produce a PDF photo book from a collection of photos. You can get
    the code for this app at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
    and choose the `PhotobookCreator_DispatchGroups` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in XCode and navigate to the `PhotoCollectionViewController.swift`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw in the last recipe how dispatch queues operate on a FIFO policy. GCD
    will execute a block from the top of the queue and remove it from the queue when
    it has finished executing. The number of blocks that GCD will allow to execute
    at the same time will depend on the type of queue being used. *Serial* queues
    will only have one block of code being executed at any time; other blocks in the
    queues will have to wait until the block at the top of the queue has finished
    executing. However, for a *concurrent* queue, GCD will concurrently execute as
    many blocks as there are resources available. We can make more efficient use of
    a concurrent queue by breaking down the work into smaller, independent blocks,
    allowing them to be executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the current implementation of the `generatePhotoBook` method.
    The only thing that has changed since the last recipe is that we now present the
    preview UI within a completion that is passed to the `generatePhotoBook` method.
    This simplifies the method and prevents us from needing to weakly capture `self`
    within the `async` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The work we are doing is in one block of code that we place on a queue. Let's
    see whether we can break this down into smaller, independent pieces of work that
    can be executed concurrently. We can't perform the scale and crop operations concurrently,
    as they will be operating on the same `UIImage` objects, and we will not get the
    intended result if the image is cropped before it's scaled.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can apply the scale and crop operation to each photo separately
    and perform that operation concurrently on the other photos. Once each photo has
    been scaled and cropped, we can use the processed images to generate the photo
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/737635fd-c762-486f-ac2c-9e117e86421c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Serial approach and concurrent approach
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the work up in this way may not make the overall operation faster,
    as there is an overhead to each block of work. The efficiency improvement of dividing
    the work into concurrent blocks will depend on the operation involved, and how
    many concurrent operations can run.
  prefs: []
  type: TYPE_NORMAL
- en: We now have blocks of work that can run concurrently, but we have given ourselves
    a new problem; how do we coordinate all these concurrent pieces of work so that
    we know they are all completed and we can start generating the photo book? Here,
    GCD can help us. We can use a `DispatchGroup` to coordinate our operations on
    each of the images and be notified when they are all completed.
  prefs: []
  type: TYPE_NORMAL
- en: A dispatch group is like a turnstile at a stadium. Every time someone enters
    the stadium, they pass through the turnstile, and one extra person is counted
    as being in the stadium, and at the end of the day, as people leave the stadium
    and pass through the turnstile, the number of people in the stadium decreases.
    Once there is no one left in the stadium, the lights can be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a dispatch group to coordinate the work of our photo book creator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a dispatch group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we start a blockwork to resize a photo, we will enter the group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the work is finished, we will leave the group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will ask the group to notify us when the last resize operation
    has finished and left the group. Then, we can take the processed files and generate
    the photo book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at our `generatePhotoBook` method, now using a concurrent
    queue and dispatch groups:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dispatch queues are serial by default, so to create a concurrent queue instead,
    we pass the `.concurrent` attribute when it is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we loop through all the photos, we set up anything that isn''t specific
    to each photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This includes creating the `DispatchGroup`, which we will use to coordinate
    the work. Since our photo resizing will now be happening concurrently, we need
    a place to collect the photos once they have been processed. We can use a Swift
    array for this; however, a Swift array is a value type, so we can't use it from
    within multiple blocks, as each block will be taking a copy of the array, not
    the original array itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this with a Swift array, we would need to make the `processedPhotos`
    array property on the view controller, which would mean we would have to weakly
    capture self in the blocks that we would need to unwrap. A simpler way to solve
    this problem is to use a collection that has reference semantics; the `Foundation`
    framework provides that in the form of `NSArray` and `NSMutableArray`. As we saw
    earlier in this chapter, it''s important to understand the semantics of the construct
    being used and pick the right tool for the right job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For each photo, we enter the group and place the resize work on the concurrent
    queue. We can use the same scale and crop methods that we used previously, just
    passing an array containing one photo. Once the work is completed, we'll replace
    the original photo with the processed photo in the array and leave the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once every block has left the group, this `notify` block will execute. We retrieve
    the processed photos and use them to generate the photo book. Finally, we ensure
    that the completion handler is executed on the main queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you build and run the app, you can still generate a photo book and the UI
    is still responsive, and now GCD can make the best use of the available resources
    to generate our photo book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Documentation relating to dispatch queues: [http://swiftbook.link/docs/dispatchqueue](http://swiftbook.link/docs/dispatchqueue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation relating to dispatch groups: [http://swiftbook.link/docs/dispatchgroup](http://swiftbook.link/docs/dispatchgroup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the operation class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter so far, we have taken our long-running operations and scheduled
    them as blocks of code, called **closures**, on dispatch queues. This has made
    it really easy to move long-running code off of the main queue, but if we intend
    to reuse this long-running code, pass it around, track its state, and generally
    deal with it in an object-orientated way, a closure is not ideal.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, the `Foundation` framework provides an object, `Operation`, that
    allows us to wrap up our block of work within an encapsulated object.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take the photo book app we used throughout this chapter
    and convert our long-running blocks to an `Operation` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to build on the app we improved in the last recipe, which is an
    app that will produce a PDF photo book from a collection of photos. You can get
    the code for this app at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
    and choose the `PhotobookCreator_StartOperations` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Open the folder and navigate to the `PhotoCollectionViewController.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s recap how we broke the work down into independent parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/062bde1e-59e3-47eb-be26-9d081791e091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Concurrent Approach blocks
  prefs: []
  type: TYPE_NORMAL
- en: 'We can turn each of these blocks of work into separate operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an operation to scale and crop each photo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define an operation by sub-classing the `Operation` class, so in the project,
    create a new Swift file and call it `PhotoResizeOperation.swift`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the simplest `Operation` implementation, we only need to override one method,
    `main()`, so let''s copy and paste the relevant code from our `generatePhotobook`
    method. This `main()` method will be executed when the operation starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Copying and pasting the code is not enough, as there are a number of dependencies
    that were previously being captured by the block. Now we have to explicitly provide
    these dependencies to the operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have converted our resize block to an operation. We now need to do the same
    for the block that generates the photo book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We pass the dependencies into the operation, just like in `PhotoResizeOperation`.
    The output of this operation is a URL for the resulting photo book. We expose
    that as a property on the operation so that it can be retrieved outside the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our blocks of work converted to operations, let''s switch over to `PhotoCollectionViewController.swift`
    and update our `generatePhotoBook` method to use this new operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s walk through the changes step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where we were previously using a `DispatchQueue` to manage the execution of
    our blocks, operations are now managed with an `OperationQueue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The method signature in the following code and the dependencies we need to
    generate upfront remain the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the operation to generate the photo book, passing in the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the operation will be executed last, we create it first so that we
    can make it dependent on the resize operations we are about to create. An operation
    does not execute immediately upon creation. It will only execute when the `start()`
    method of `Operation` is called, which can be called manually, or, if an `Operation`
    is placed on an `OperationQueue`, it will be called by the queue as appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, as you can see from the preceding code, we loop through the number of photos
    that we intend to process and create a resize operation for each, passing in the
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: With our move to use `Operation`, one thing we have lost is the use of `DispatchGroup`,
    which we used to ensure that we only generated the photo book once all the photo
    resize blocks had completed. We can, however, achieve the same goals using operation
    dependencies. An operation can be declared as dependent on a set of other operations,
    so it will not begin executing until the operations it depends on have finished.
    To ensure that the `generateBookOp` operation, which we just created, only executes
    when all the `PhotoResizeOperation` operations are complete, we add each of them
    as a dependency of `generateBookOp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this done, we can place each `PhotoResizeOperation` on the `OperationQueue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Operation` has a `completionBlock` property; any block set here will be executed
    once the operation has completed. We can use this to fire our completion handler
    on the main queue. Since we need to provide the completion handler with the URL
    to the photo book created by `generateBookOp`, we can retrieve this from within
    the block, as we know that the operation will be finished and the URL will be
    there. However, we need to be careful. We are providing a closure to `generateBookOp`,
    which will be retained, and we are using, and therefore capturing and retaining,
    the `generateBookOp` operation in the same block. This will lead to a retain cycle,
    and `generateBookOp` will never get released from memory. To avoid this retain
    cycle, we specify that we want to weakly capture `generateBookOp` in the block
    we provide, using the `[weak generateBookOp]` capture list. This won''t increment
    the retain count, preventing the retain cycle from happening.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like `DispatchQueue`, `OperationQueue` has an available property that
    provides a reference to the main queue, upon which the UI events are processed.
    Also, `OperationQueue` has a convenience method that will take a block of code,
    wrap it in an `Operation`, and add it to the queue. We use this to ensure that
    the completion handler is executed on the main queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As the final step, we put the `generateBookOp` operation on the processing queue.
    It's important that we do this as the last step because, once placed on the queue,
    the operation may be executed immediately, but we don't want it executed immediately.
    We only want `generateBookOp` executed once all the resize operations are complete,
    and if we placed the operation on the queue before setting up the dependencies,
    this could happen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have transitioned our app over to using `Operation`, let's build
    and then run and verify that everything works just as it did before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users of our photo book app currently do not have the ability to cancel the
    generation of a photo book once the process has started, so let''s add that functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will examine our two operations and look for opportunities to check the
    `isCancelled` property and exit early. Switch to `PhotoResizeOperation.swift`
    and add `isCancelled` checks to the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Before each piece of long-running work, we check the `isCancelled` property,
    and if it is `true`, we return early, which will finish the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same in `GeneratePhotoBookOperation.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need to add some UI that allows the user to cancel the photo book
    generation once it is in progress. This is an exercise for the reader, or you
    can switch to the `end-operations` branch to see how I have implemented it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the user chooses to cancel generating a photo book, we can call the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will fire the `cancel()` method on all the operations in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an app with a cancelable, long-running operation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does `OperationQueue` know when to start an operation and when to remove
    it from the queue? It knows by monitoring the operation''s state. The `Operation`
    class goes through a number of state transformations during its life cycle. The
    following diagram describes how these state transformations occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/225f9e07-2d51-4a5c-8cf6-89d829dc3212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Operation life cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about the operation''s state is exposed through a number of Boolean
    properties on `Operation`, and the operation queue uses the properties to know
    when to perform certain actions on the operations. Let''s look at these properties
    one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An operation will return `true` for `isReady` when all its dependencies are
    finished. If it doesn''t have any dependencies, it will always return `true`.
    The queue will only start executing an operation if `isReady` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once `start` is called on an operation, either manually or by a queue, `isExecuting`
    will return `true`, and when the operation has finished executing, `isExecuting`
    will revert to returning `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since operations remain on the queue until they have finished, the queue uses
    the `isExecuting` property to ensure that it doesn''t call `start` on an operation
    that has already started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the operation has finished doing whatever processing is required, `isFinished`
    should return `true`. When `isFinished` starts to return `true`, it will be removed
    from the queue, and the queue will no longer maintain a reference to the operation.
    For the simplest implementation of `Operation`, as we implemented earlier, `isFinished`
    returns `true` automatically when the `main()` method has finished executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Operations can be canceled by calling the `cancel()` method on the operation.
    Once called, the `isCancelled` property will return true. This can be used to
    exit early from a long-running operation, but it is up to you to check the `isCancelled`
    method and interrupt any long-running code if it returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Documentation relating to the `Operation` class: [http://swiftbook.link/docs/operation](http://swiftbook.link/docs/operation)'
  prefs: []
  type: TYPE_NORMAL
