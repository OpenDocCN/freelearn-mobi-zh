- en: Chapter 2. Testing on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have introduced the reasons and the basic concepts behind testing,
    it's time to put them into practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this second chapter, we are covering:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing and JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android Test project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be creating a simple Android **main** project and its companion **test**
    project. The main project will be almost empty and will just highlight testing
    components.
  prefs: []
  type: TYPE_NORMAL
- en: From my personal experience, I suggest that this chapter is useful for new developers
    with no Android Testing experience. If you have some experience with Android Projects
    and have been using testing techniques for them, you might read this chapter as
    a revision or reaffirmation of the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Though not mandatory, best practices dictate that tests should live in a separate
    correlated project. This feature is now supported by the Android ADP plugin, but
    this has not always been the case. Some time ago I published an article ([http://dtmilano.blogspot.com/2008/11/android-testing-on-android-platf.html](http://dtmilano.blogspot.com/2008/11/android-testing-on-android-platf.html))
    describing a method for manually maintaining two correlated projects—a main project
    and a test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of this decision may not be immediately evident, but among them
    we can count:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing code is easily stripped out from a production build as it is not included
    in the main project and thus not in the APK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease the way of running the tests in the emulator through the Instrumentation
    option in Dev Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With large projects, deploying the main package and the tests takes less time
    if they are separated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encourages code reusability in similar projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had an overview of JUnit in the previous chapter, so no introduction is needed
    here. It is worth mentioning that the JUnit testing framework is the default option
    for Android testing projects and it is supported by Eclipse, the Android ADT plugin,
    and by Ant as well, in case you are not developing with an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: So you are free to choose the best alternative for every case.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the following examples will be based on Eclipse because is the most
    common option. So, let's open Eclipse and start with no preamble.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Android main project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new Android project. This is done from Eclipse menu **File**
    | **New** | **Project..**. | **Android** | **Android Project**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular case, we are using the following values for the required
    component names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project name: | **MyFirstProject** |'
  prefs: []
  type: TYPE_TB
- en: '| Build Target: | **Android 2.3.1** |'
  prefs: []
  type: TYPE_TB
- en: '| Application name: | **My First Project** |'
  prefs: []
  type: TYPE_TB
- en: '| Package name: | **com.example.aatg.myfirstproject** |'
  prefs: []
  type: TYPE_TB
- en: '| Create Activity: | **MyFirstProjectActivity** |'
  prefs: []
  type: TYPE_TB
- en: '| Min SDK Version: | **9** |'
  prefs: []
  type: TYPE_TB
- en: 'This is what your project creation dialog will look like after entering these
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Android main project](img/3500_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Android test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Press the **Next** button and the Android Test Project creation dialog will
    be displayed. Note that some values have been already picked according to the
    corresponding values selected in the main project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, to create a Test project for an existing Android project you
    can select the main project and then **Android Tools | Create Test Project**.
    Under *Test Target* select the name of the existing project and the required values
    will be filled in automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This image shows the Android Test Project creation dialog after entering the
    corresponding values. All the values have been already entered for us and we should
    only have to click **Finish:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Android test project](img/3500_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Package explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having created both projects, our Package explorer should look like the
    next image. We can note the existence of the two correlated projects, each with
    an independent set of components and project properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Package explorer](img/3500_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the basic infrastructure set up, it's time for us to start
    adding some tests.
  prefs: []
  type: TYPE_NORMAL
- en: There's nothing to test right now, but as we are setting up the fundamentals
    of Test Driven Development discipline we are adding a dummy test just to get acquainted
    with the technique.
  prefs: []
  type: TYPE_NORMAL
- en: The `src` folder on `MyFirstProjectTest` project is the perfect place to add
    the tests. It is not mandatory but a good practice. The package should be the
    same as the corresponding package of the component being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we are not concentrating on the tests but on the concepts and placement
    of those tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described before, we are creating our test cases in the `src` folder of the
    Test project.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we are creating a unit test using JUnit TestCase. Eclipse
    provides a wizard to help us **(File | New... | Junit Test Case)**.
  prefs: []
  type: TYPE_NORMAL
- en: We are selecting the main project's Activity as the class under test; however
    this is not relevant in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the values that we should enter when we create the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Junit: | **Junit 3** |'
  prefs: []
  type: TYPE_TB
- en: '| Source folder: | **MyFirstProjectTest/src** |'
  prefs: []
  type: TYPE_TB
- en: '| Package: | **com.example.aatg.myfirstproject.test** |'
  prefs: []
  type: TYPE_TB
- en: '| Name: | **MyFirstProjectTests** |'
  prefs: []
  type: TYPE_TB
- en: '| Superclass: | **junit.framework.TestCase** |'
  prefs: []
  type: TYPE_TB
- en: '| Which method stubs would you like to create? | **setUp(), tearDown(), constructor**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Class under test: | **com.example.aatg.myfirstproject.MyFirstProjectActivity**
    |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking we could have left the **setUp(), tearDown()**, and **constructor**
    options unselected and this basic test we are creating would not be affected,
    but here we are describing the most general practices and we will find in many
    real life scenarios that these methods are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering all the required values our JUnit test case creation dialog
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a test case](img/3500_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The basic infrastructure for our tests is in place; what is left is adding a
    dummy test to verify that everything is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eclipse also provides a way of creating stubs for the test methods. After pressing
    **Next >** the following dialog is presented where you can choose the methods
    under tests you want to generate the stubs for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a test case](img/3500_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These stub methods may be useful in some cases but you have to consider that
    testing should be behavior driven rather than method driven.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a test case template, so the next step is to start completing it
    to suit our needs. To do it, open the recently created case class and add the
    test `testSomething()`. As a best practice, add the tests at the end of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This test will always fail, presenting the message: **Not implemented yet**.
    In order to do this we are using the `fail` method from the `junit.framework.Assert`
    class that fails the test with the given message.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The no-argument constructor is needed to run a specific test from the command
    line as explained later using `am instrumentation`.
  prefs: []
  type: TYPE_NORMAL
- en: Special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table describes the special methods found in our test case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setUp` | Sets up the fixture. For example, opens a network connection or
    creates global objects that may be needed by the tests. This method is called
    before a test is executed.In this case we are only invoking the super method.See
    [Chapter 1](ch01.html "Chapter 1. Getting Started with Testing"), *Getting Started
    with Testing* for details. |'
  prefs: []
  type: TYPE_TB
- en: '| `tearDown` | Tears down the fixture. For example, close a network connection.
    This method is called after a test is executed.In this case we are only invoking
    the super method.See [Chapter 1](ch01.html "Chapter 1. Getting Started with Testing"),
    *Getting Started with Testing* for details. |'
  prefs: []
  type: TYPE_TB
- en: '| `testSomething` | A simple test. In order to be discovered by JUnit 3 using
    reflection, test methods should start with the word `test`.The rest of the method
    name should clearly identify the feature under test. |'
  prefs: []
  type: TYPE_TB
- en: Test annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking carefully at the test definition you may find that we decorated the
    test using `@MediumTest` annotation. This is a way to organize or categorize our
    tests and run them separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other annotations that can be used by the tests, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@SmallTest` | Marks a test that should run as part of the small tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `@MediumTest` | Marks a test that should run as part of the medium tests.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@LargeTest` | Marks a test that should run as part of the large tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Smoke` | Marks a test that should run as part of the smoke tests. The `android.test.suitebuilder.SmokeTestSuiteBuilder`
    will run all tests with this annotation. |'
  prefs: []
  type: TYPE_TB
- en: '| `@FlakyTest` | Use this annotation on `InstrumentationTestCase` class'' test
    methods. When this is present, the test method is re-executed if the test fails.
    The total number of executions is specified by the tolerance and defaults to 1\.
    This is useful for tests that may fail due to an external condition that could
    vary with time.For example, to specify a tolerance of 4, you would annotate your
    test with: `@FlakyTest(tolerance=4)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@UIThreadTest` | Use this annotation on `InstrumentationTestCase` class''
    test methods. When this is present, the test method is executed on the application''s
    main thread (or UI thread).Because instrumentation methods may not be used when
    this annotation is present there are other techniques if, for example, you need
    to modify the UI and get access to the instrumentation within the same test.In
    those cases you can resort to the `Activity.runOnUIThread` method allowing to
    create any `Runnable` and run it in the UI thread from within your test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `@Suppress` | Use this annotation on test classes or test methods that should
    not be included in a test suite.This annotation can be used at the class level,
    where none of the methods in that class are included in the test suite, or at
    the method level to exclude just a single method or set of methods. |'
  prefs: []
  type: TYPE_TB
- en: Now that we have the tests in place, it's time to run them, and that's what
    we are going to do next.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways of running our tests, and we will analyze them here.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, as was mentioned in the previous section about annotations, tests
    can be grouped or categorized and run together, depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Running all tests from Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is perhaps the simplest method if you have adopted Eclipse as your development
    environment. This will run all the tests in the package.
  prefs: []
  type: TYPE_NORMAL
- en: Select the test project and then **Run As | Android Junit Test**.
  prefs: []
  type: TYPE_NORMAL
- en: If a suitable device or emulator is not found, one will be started automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Then the tests are run and the results presented inside the Eclipse DDMS perspective,
    which you may need to change to manually.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running all tests from Eclipse](img/3500_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A more detailed view of the results and the messages produced during their
    execution can also be obtained in the LogCat view within the Eclipse DDMS perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running all tests from Eclipse](img/3500_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running a single test case from Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an option to run a single test case from Eclipse, should you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Select the test project and then **Run As | Run Configurations**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create a new configuration and under *Test*, use the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Run a single test: | **checked** |'
  prefs: []
  type: TYPE_TB
- en: '| Project: | **MyFirstProjectTest** |'
  prefs: []
  type: TYPE_TB
- en: '| Test class: | **com.example.aatg.myfirstproject.test.MyFirstProjectTests**
    |'
  prefs: []
  type: TYPE_TB
- en: When you run as usual, only this test will be executed. In our case, we have
    only one test, so the result will be similar to the screenshot presented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a shortcut for this that you can use from within the Eclipse editor.
    Selecting the method name you can press *Shift+Alt+X T* or right-click on it and
    then choosing **Run As | JUnit Test**.
  prefs: []
  type: TYPE_NORMAL
- en: Running from the emulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default system image used by the emulator has the *Dev Tools* application
    installed, providing several handy tools and settings. Among these tools, we can
    find a rather long list as is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running from the emulator](img/3500_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are interested in **Instrumentation** now, which is the way to run our tests.
    This application lists all of the packages installed that define the `instrumentation`
    tag in their `AndroidManifest.xml`. By default, packages are listed using the
    default instrumentation which normally is `android.test.InstrumentationTestRunner`
    which is a problem to identify if you have more than one package list. To solve
    this problem you can set an optional label in the manifest, under the Instrumentation
    tab, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running from the emulator](img/3500_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this is done and the Instrumentation list is re-displayed, our package
    will be listed under this new label and we can run the tests by selecting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running from the emulator](img/3500_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the tests are run in this way, the results can be seen through **LogCat**
    as described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see how, as mentioned previously, if you don't set the optional Label
    more than one instrumentation appears under the same default label `android.test.InstrumentationTestRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, tests can be run from the command line too. This is useful if you want
    to automate or script the process.
  prefs: []
  type: TYPE_NORMAL
- en: To run the tests we are using the `am instrument` command (strictly speaking
    the `am` command and `instrument` subcommand) which allows us to run instrumentations
    specifying the package name and some other options.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder what `am` stands for. It is short for **Activity Manager**, a
    main component of the internal Android infrastructure that is started by the **System
    Server** at the beginning of the boot process and is responsible for managing
    Activities and their life cycle. Additionally, as we can see here, it is also
    responsible for Activity instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general usage of the `am instrument` command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This table summarizes the most common options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Print raw results. Useful to collect raw performance data. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e <NAME> <VALUE>` | Set arguments by name. We will examine its usage shortly.This
    is a generic option argument that allows us to set`<name, value>` pairs. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p <FILE>` | Write profiling data to an external file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-w` | Wait for instrumentation to finish before exiting. Normally used in
    commands, although not mandatory it''s very handy, as otherwise you will not be
    able to see the test''s results. |'
  prefs: []
  type: TYPE_TB
- en: To invoke the `am` command we will be using the `adb shell` command or, if you
    already have a shell running on an emulator or device, you can issue the `am`
    command directly at the shell command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Running all tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This command line will run all tests with the exception of performance tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running tests from a specific test case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run all the tests in a specific test case, you may use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running a specific test by name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Additionally we have the alternative of specifying which test we want to run
    in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This test cannot be run in this way unless we have a no-argument constructor
    in our test case — that is the reason we added it before.
  prefs: []
  type: TYPE_NORMAL
- en: Running specific tests by category
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned before, tests can be grouped into different categories using
    annotations *(Test Annotations)* and you can run all tests in this category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options can be added to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-e unit true` | Run all unit tests. These are tests that are not derived
    from `InstrumentationTestCase` (and are not performance tests). |'
  prefs: []
  type: TYPE_TB
- en: '| `-e func true` | Run all functional tests. These are tests that are derived
    from `InstrumentationTestCase`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e perf true` | Include performance tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e size {small &#124; medium &#124; large}` | Run small, medium, or large
    tests depending on the annotations added to the tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e annotation <annotation-name>` | Run tests annotated with this annotation.
    This option is mutually exclusive with the size option. |'
  prefs: []
  type: TYPE_TB
- en: In our example, we annotated the test method `testSomething()` with `@SmallTest`.
    So this test is considered to be in that category and thus run, eventually with
    other tests belonging to that same category, when we specify `small` as the test
    size.
  prefs: []
  type: TYPE_NORMAL
- en: This command line will run all the tests annotated with `@SmallTest:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom annotation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In case you decide to sort the tests by a different criterion than their size,
    a custom annotation can be created and then specified in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's say we want to arrange them according to their importance,
    so we create an annotation `@VeryImportantTest`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Following this, we can create another test and annotate it with `@VeryImportantTest`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we mentioned before, we can include this annotation in the `am instrument`
    command line to run only the annotated tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running performance tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be reviewing performance test details in [Chapter 9](ch09.html "Chapter 9. Performance
    Testing and Profiling"), *Performance Testing* but here we will introduce the
    available options to the `am instrument` command.
  prefs: []
  type: TYPE_NORMAL
- en: To include performance tests on your test run you should add this command line
    option
  prefs: []
  type: TYPE_NORMAL
- en: '| `-e perf true` | Include performance tests. |'
  prefs: []
  type: TYPE_TB
- en: Dry run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you may need to know only what tests will be run instead of actually
    running them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the option you need to add to your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-e log true` | Display the tests to be run instead of running them. |'
  prefs: []
  type: TYPE_TB
- en: This is useful if you are writing scripts or perhaps building other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your tests might have bugs too; you should assume that. In that case usual debugging
    techniques apply, for example adding messages through LogCat.
  prefs: []
  type: TYPE_NORMAL
- en: If a more sophisticated debugging technique is needed you should attach the
    debugger to the test runner. In order to do so, there are two main alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: The first is easy — not leaving the convenience of Eclipse and not having to
    remember hard-to-memorize command-line options. In the latest version of the Android
    ADT plugin, the option **Debug As| Android JUnit Test** was added. Thus you can
    set a breakpoint in your tests and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To toggle a breakpoint you can select the desired line in the editor and then
    use the menu option **Run | Toggle Line Breakpoint**. Alternatively you can slightly
    alter the code of your tests to wait for the debugger connection. But don''t worry,
    this change is extremely simple. Add the following snippet to the constructor
    or any other test you want to debug. The place where you add it is not really
    relevant as the debugger would stop at breakpoints anyway. In this case, we decided
    to add `Debug.waitForDebugger()` to the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you run the tests as usual, using **Run As | Android JUnit Test**, you
    will probably be asked to change the perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging tests](img/3500_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once it is done, you will be in a standard debugging perspective and session.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally if you can't or don't want to alter your tests' code, you can set
    breakpoints in it and pass the following option to `am instrument`.
  prefs: []
  type: TYPE_NORMAL
- en: '| `-e debug true` | Attach to debugger. |'
  prefs: []
  type: TYPE_TB
- en: Once your tests have been started, the test runner will wait for your debugger
    to attach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute this command line to debug the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see this line while waiting at the first breakpoint reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will continue and exit normally once the debug was attached and your debugging
    session will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Other command-line options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `am instrument` command accepts other`<name, value>` pairs beside the previously
    mentioned ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| package | Fully qualified package name of one or several packages in the
    test application.Multiple values are separated by commas (,). |'
  prefs: []
  type: TYPE_TB
- en: '| class | A fully qualified test case class to be executed by the test runner.Optionally
    this could include the test method name separated from the class name by a hash
    (`#`). |'
  prefs: []
  type: TYPE_TB
- en: '| coverage | TrueRuns the EMMA code coverage and writes output to a file that
    can also be specified.We will dig into details about supporting EMMA code coverage
    for our tests in [Chapter 10](ch10.html "Chapter 10. Alternative Testing Tactics"),
    *Alternative Testing Tactics.* |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reviewed the main techniques and tools behind testing in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what we have covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Created our first Android test project as a companion for a sample Android project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Followed the best practice of always creating our companion test project even
    if initially you may think it's not needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a simple test class to test the Activity in the project. We haven't
    added any useful test cases yet but adding those simple ones was intended to validate
    all of our infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also ran this simple test from Eclipse and from the command line to understand
    the alternatives we have. In this process, we mentioned the Activity Manager and
    its command line incarnation `am`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzed the most used command lines and explained their options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a custom annotation to sort our tests and demonstrated its usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the tests and interpreting the results let us know how well our application
    is behaving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will start analyzing the mentioned techniques, frameworks,
    and tools in much greater detail and provide examples of their usage.
  prefs: []
  type: TYPE_NORMAL
