<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;Advanced Features"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Advanced Features</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reproducing the page curl effect</li><li class="listitem" style="list-style-type: disc">Integrating content sharing</li><li class="listitem" style="list-style-type: disc">Implementing custom transitions</li><li class="listitem" style="list-style-type: disc">Using physics in UI elements</li><li class="listitem" style="list-style-type: disc">Implementing the text-to-speech feature</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec121"/>Introduction</h1></div></div></div><p>In this chapter, we will explore only some of the huge variety of advanced features that the iOS platform has to offer.</p><p>Specifically, we will create a project that displays content separated into pages, which the user can navigate through like in a normal book, with the help of the newly introduced <code class="literal">UIPageViewController</code> class.</p><p>We will then discuss integrating content-sharing features and providing share/post functionality in our app with the help of <code class="literal">UIActivityViewController</code>. For the user interface, we will <a id="id777" class="indexterm"/>explore some basic aspects of <span class="strong"><strong>UIKit Dynamics</strong></span> that allows rich animations for a better user experience. We will also learn how to provide custom transitions between view controllers.</p><p>In the last recipe of this chapter, we will work with the new text-to-speech feature and create an app that speaks, with the help of the <code class="literal">AVSpeechSynthesizer</code> class!</p></div></div>
<div class="section" title="Reproducing the page curl effect"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec122"/>Reproducing the page curl effect</h1></div></div></div><p>In this recipe, we <a id="id778" class="indexterm"/>will create an app that displays content like that of a book with the help of the <code class="literal">UIPageViewController</code> class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec488"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">BookApp</code>. Add another controller to the project and name it <code class="literal">Page</code>. Configure the appearance of the <code class="literal">Page</code> controller<a id="id779" class="indexterm"/> however you like. In the source code for this recipe, the contains a <code class="literal">UIImageView</code> and a <code class="literal">UILabel</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec489"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Enter the following code in the <code class="literal">BookAppViewController</code> class:<div class="informalexample"><pre class="programlisting">private UIPageViewController pageViewController;
private int pageCount = 3;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  Page firstPage = new Page(0);
  this.pageViewController = new UIPageViewController(UIPageViewControllerTransitionStyle.PageCurl, UIPageViewControllerNavigationOrientation.Horizontal, UIPageViewControllerSpineLocation.Min);
  this.pageViewController.SetViewControllers(new UIViewController[] { firstPage }, UIPageViewControllerNavigationDirection.Forward, false, s =&gt; { });
  this.pageViewController.GetNextViewController = this.GetNextViewController;
  this.pageViewController.GetPreviousViewController = this.GetPreviousViewController;
  this.pageViewController.View.Frame = this.View.Bounds;
  this.View.AddSubview(this.pageViewController.View);
}

private UIViewController GetNextViewController(UIPageViewController pageController, UIViewController referenceViewController)
{

  Page currentPageController = referenceViewController as Page;

  if (currentPageController.PageIndex &gt;= (this.pageCount - 1))
  {

    return null;

  }  else
  {	
    int nextPageIndex = currentPageController.PageIndex + 1;
    return new Page(nextPageIndex);

  }
}

private UIViewController GetPreviousViewController(UIPageViewController pageController, UIViewController referenceViewController)
{

  Page currentPageController = referenceViewController as Page;
  if (currentPageController.PageIndex &lt;= 0)
  {
    return null;
  }  else
  {

    int previousPageIndex = currentPageController.PageIndex - 1;

    return new Page(previousPageIndex);

  }
}</pre></div></li><li class="listitem">Add a<a id="id780" class="indexterm"/> property to the <code class="literal">Page</code> class and change its constructor, as shown in the following code:<div class="informalexample"><pre class="programlisting">public Page (int pageIndex) : base ("Page", null)
{
  this.PageIndex = pageIndex;
}

public int PageIndex
{
  get;
  private set;
}</pre></div></li><li class="listitem">Finally, configure the content that will be displayed in <code class="literal">Page</code>, in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.imgView.Image = UIImage.FromFile(string.Format("images/{0}.jpg", this.PageIndex + 1));
  this.lblPageNumber.Text = string.Format("Page {0}", this.PageIndex + 1);</pre></div></li><li class="listitem">Compile<a id="id781" class="indexterm"/> and run the app on the simulator. Click-and-drag the cursor on the simulator's screen area to change the page. The result should look similar to the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_15_01.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec490"/>How it works...</h2></div></div></div><p>The <code class="literal">UIPageViewController</code> class introduced with iOS 5 was a desired component by many developers. It allows us to navigate through content with the effect of a real book, like in Apple's<span class="emphasis"><em> iBooks </em></span>app.</p><p>We initialize it with the following line:</p><div class="informalexample"><pre class="programlisting">this.pageViewController = new UIPageViewController(UIPageViewControllerTransitionStyle.PageCurl, UIPageViewControllerNavigationOrientation.Horizontal, UIPageViewControllerSpineLocation.Min);</pre></div><p>The first parameter of the constructor determines the type of the effect. The only available<a id="id782" class="indexterm"/> value right now is <code class="literal">PageCurl</code>. The second parameter determines the orientation of the effect. The <code class="literal">Horizontal</code> parameter is the value for the effect similar to a book, while <code class="literal">Vertical</code> is the value for the effect similar to a notebook, where the pages are bound at the top. The third parameter determines the position of the bind of the book. The <code class="literal">Min</code> parameter declares that the bind is on one edge of the screen (in this case, on the left-hand side).</p><p>After initializing the page controller, we need to set its first page by calling its <code class="literal">SetViewControllers</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.pageViewController.SetViewControllers(new UIViewController[] { firstPage }, UIPageViewControllerNavigationDirection.Forward, 
  false, s =&gt; { });</pre></div><p>The method's first parameter is an array of <code class="literal">UIViewController</code> objects. We can set either one or two controllers for this parameter, depending on the device's orientation. For example, if the app supports landscape orientation, we might want to show two pages at the same time. The second parameter basically determines the navigation direction of the included pages. The <code class="literal">Forward</code> parameter means the next page will be loaded if we swipe from right to left on the screen, while <code class="literal">Reverse</code> means the previous page will be loaded for the same swipe. The last parameter is of delegate type <code class="literal">UICompletionHandler</code> and represents the handler to be executed after the controllers have been added. In this example, we do not need it, so we just pass an empty lambda.</p><p>Next, we need to provide the data source for the rest of the pages of our "book." Once again, Xamarin simplifies things for us by providing two very helpful properties for us to use: <code class="literal">GetNextViewController</code> and <code class="literal">GetPreviousViewController</code>. These properties merely represent the callback methods we would have to override if we were creating a delegate object for the page controller. Apart from their names, the signatures of these two methods are identical, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">UIViewController GetNextViewController(UIPageViewController pageController, UIViewController referenceViewController);
UIViewController GetPreviousViewController(UIPageViewController pageController, UIViewController referenceViewController);</pre></div><p>The first parameter gives us the page controller, while the second parameter gives us the controller that is currently displayed on screen when the method is called.</p><p>In the implementation of these methods, we simply have to return the controller that should be loaded after or before the current one. If we do not want the effect to be activated, we <a id="id783" class="indexterm"/>just return <code class="literal">null</code>.</p><p>Last but not least, we set the size of the page controller's view and add it to a superview so it will be displayed, using the following code:</p><div class="informalexample"><pre class="programlisting">this.pageViewController.View.Frame = this.View.Bounds;
  this.View.AddSubview(this.pageViewController.View);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec491"/>There's more...</h2></div></div></div><p>If we would like our app to support landscape orientation, we would first have to implement the <code class="literal">ShouldAutoRotate</code> and <code class="literal">GetSupportedInterfaceOrientations</code> methods in the <code class="literal">BookAppViewController</code> class. Secondly, we would have to provide two view controllers to the <code class="literal">SetViewControllers</code> method of the <code class="literal">UIPageViewController</code> class.</p><div class="section" title="Double-sided pages"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec118"/>Double-sided pages</h3></div></div></div><p>As you might have noticed in the previous screenshot of this recipe, when we turn a page, its content is<a id="id784" class="indexterm"/> displayed in reverse on the page's back, like when we see through a page in real books. We have the option of creating double-sided pages by setting the <code class="literal">UIPageViewController.DoubleSided</code> property to <code class="literal">true</code>.</p></div></div></div>
<div class="section" title="Integrating content sharing"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec123"/>Integrating content sharing</h1></div></div></div><p>In this recipe, we will add the content-sharing functionality in an app. The app will be able to<a id="id785" class="indexterm"/> share content through social networks, e-mail, SMS, or <span class="strong"><strong>AirDrop</strong></span>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec492"/>Getting ready</h2></div></div></div><p>Create a<a id="id786" class="indexterm"/> new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">ContentShareApp</code>. The app will work on the simulator, but more sharing targets will be available on an actual device.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec493"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a button to the controller.</li><li class="listitem">Add the <a id="id787" class="indexterm"/>following code in the <code class="literal">ContentShareAppViewController</code> class:<div class="informalexample"><pre class="programlisting">private UIActivityViewController shareController;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.btnShare.TouchUpInside += async (sender, e) =&gt; {
    NSString link = new NSString("http://software.tavlikos.com");
    this.shareController = new UIActivityViewController(new NSObject[] {
      link
    }, null);
    this.shareController.CompletionHandler = this.ActivityCompleted;

    await this.PresentViewControllerAsync(this.shareController, true);
  };
}
private void ActivityCompleted(NSString activityType, bool completed)
{
  Console.WriteLine("Activity type: {0}", activityType);
  Console.WriteLine("Completion: {0}", completed);
}</pre></div></li><li class="listitem">Compile and run the app on a device. Tap the <span class="strong"><strong>Share link</strong></span> button, and a screen similar to the following screenshot will appear:<div class="mediaobject"><img src="graphics/8924OT_15_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec494"/>How it works...</h2></div></div></div><p>The <code class="literal">UIActivityViewController</code> class is responsible for displaying the available sharing options, depending<a id="id788" class="indexterm"/> on the availability of these options on each device.</p><p>To initialize an instance of <code class="literal">UIActivityViewController</code>, we pass the following two arguments:</p><div class="informalexample"><pre class="programlisting">this.shareController = new UIActivityViewController(new NSObject[] {
  link
}, null);</pre></div><p>The first parameter is an array of <code class="literal">NSObject</code> objects. In this example, we just pass one object of the <code class="literal">NSString</code> type. This object is a URL. The second parameter is an array of <code class="literal">UIActivity</code> objects. In this example, we pass <code class="literal">null</code>. The <code class="literal">UIActivity</code> class is meant to be subclassed so we can add our own custom activity "providers" to <code class="literal">UIActivityViewController</code>, with our own icon and functionality.</p><p>We then<a id="id789" class="indexterm"/> set the callback that will be called when the user completes the action, using the following code:</p><div class="informalexample"><pre class="programlisting">this.shareController.CompletionHandler = this.ActivityCompleted;
//..
private void ActivityCompleted(NSString activityType, bool completed)
{
  Console.WriteLine("Activity type: {0}", activityType);
  Console.WriteLine("Completion: {0}", completed);
}</pre></div><p>Through the callback, we get an <code class="literal">NSString</code> representation of the type of activity and a bool indicating whether the user actually completed (<code class="literal">true</code>) or cancelled (<code class="literal">false</code>) the activity. Note that this parameter will be <code class="literal">false</code>, whether the user tapped the cancelled button on <code class="literal">UIActivityViewController</code> or actually cancelled the action later through the corresponding screen (for example, tapping the <span class="strong"><strong>Cancel</strong></span> button in the mail-composition screen).</p><p>After we have set up <code class="literal">UIActivityViewController</code>, we present it modally using the following code:</p><div class="informalexample"><pre class="programlisting">await this.PresentViewControllerAsync(this.shareController, true);</pre></div><p>The controller will be automatically dismissed whether the user has completed the action or cancelled it.</p><p>When we tap one of the available options, the corresponding screen will appear. The following screenshot shows the Facebook-share screen:</p><div class="mediaobject"><img src="graphics/8924OT_15_03.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec495"/>There's more...</h2></div></div></div><p>We can <a id="id790" class="indexterm"/>exclude activities we do not want to display through the <code class="literal">ExcludeActivityTypes</code> property. For example, to remove the mail activity from the options, we set the following array of <code class="literal">NSString</code> objects to the property:</p><div class="informalexample"><pre class="programlisting">this.shareController.ExcludeActivityTypes = new NSString[] { "com.apple.UIKit.activity.Mail" };</pre></div></div></div>
<div class="section" title="Implementing custom transitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec124"/>Implementing custom transitions</h1></div></div></div><p>In this<a id="id791" class="indexterm"/> recipe, we will create an app <a id="id792" class="indexterm"/>that displays a view controller modally but with our own custom-animated transition.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec496"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">CustomTransitionApp</code>. Add another view controller to the project and name it <code class="literal">ModalController</code>. Finally, we will need a button on each of these controllers.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec497"/>How to do it...</h2></div></div></div><p>Perform<a id="id793" class="indexterm"/> the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add <a id="id794" class="indexterm"/>the following classes to the project:<div class="informalexample"><pre class="programlisting">public class MyTransitionAnimator : UIViewControllerAnimatedTransitioning
{
  public bool IsPresenting { get; set; }
  public override double TransitionDuration (IUIViewControllerContextTransitioning transitionContext) {
    return 1;
  }
  public override void AnimateTransition (IUIViewControllerContextTransitioning transitionContext) {
    if (this.IsPresenting) {
      UIView containerView = transitionContext.ContainerView;
      UIViewController toViewController = transitionContext.GetViewControllerForKey(UITransitionContext.ToViewControllerKey);
      containerView.AddSubview(toViewController.View);
      RectangleF frame = toViewController.View.Frame;
      toViewController.View.Frame = RectangleF.Empty;
      UIView.Animate(this.TransitionDuration(transitionContext), () =&gt; toViewController.View.Frame = new RectangleF (20f, 20f, frame.Width - 40f, frame.Height - 40f), () =&gt; transitionContext.CompleteTransition (true));
    } else {
      UIViewController fromViewController = transitionContext.GetViewControllerForKey(UITransitionContext.FromViewControllerKey);
      RectangleF frame = fromViewController.View.Frame;
      frame = RectangleF.Empty;
      UIView.Animate(this.TransitionDuration(transitionContext), () =&gt; fromViewController.View.Frame = frame, () =&gt; transitionContext.CompleteTransition (true));
    }
  }
}
public class MyTransitionDelegate : UIViewControllerTransitioningDelegate
{
  private MyTransitionAnimator animator;
  public override IUIViewControllerAnimatedTransitioning PresentingController (UIViewController presented, UIViewController presenting, UIViewController source)
  {

    this.animator = new MyTransitionAnimator();
    this.animator.IsPresenting = true;
    return this.animator;
  }
  public override IUIViewControllerAnimatedTransitioning GetAnimationControllerForDismissedController (UIViewController dismissed) {
    this.animator.IsPresenting = false;
    return this.animator;
  }
}</pre></div></li><li class="listitem">Add the<a id="id795" class="indexterm"/> following <a id="id796" class="indexterm"/>code in the <code class="literal">ViewDidLoad</code> method of <code class="literal">CustomTransitionAppViewController</code>:<div class="informalexample"><pre class="programlisting">this.btnPresent.TouchUpInside += async (sender, e) =&gt; {
  ModalController modalController = new ModalController();
  modalController.ModalPresentationStyle = UIModalPresentationStyle.Custom;
  modalController.TransitioningDelegate = new MyTransitionDelegate();
  await this.PresentViewControllerAsync(modalController, true);
};</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap the button and watch the modal controller being presented smoothly from the top-left corner. The result should be similar to the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_15_04.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec498"/>How it works...</h2></div></div></div><p>To <a id="id797" class="indexterm"/>create our custom transition, we <a id="id798" class="indexterm"/>need to create two objects. </p><p>The first object is a subclass of <code class="literal">UIViewControllerAnimatedTransitioning</code> as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">public class MyTransitionAnimator : UIViewControllerAnimatedTransitioning</pre></div><p>This class contains two methods that we need: <code class="literal">TransitionDuration</code>, which specifies the duration of the animated transition, and <code class="literal">AnimateTransition</code>, where the actual animation takes place.</p><p>Inside the <code class="literal">AnimateTransition</code> method, we get a <code class="literal">IUIViewControllerContextTransitioning</code> object, which is responsible for the whole process. The animation will take place on a <code class="literal">UIView</code> that the object creates for this purpose. This <code class="literal">UIView</code> object is accessed through the transition context object's <code class="literal">ContainerView</code> property, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">UIView containerView = transitionContext.ContainerView;</pre></div><p>Through the transition context object, we can also get the controllers that take part in the transitioning. To get the target controller, we call the <code class="literal">GetViewControllerForKey</code> method, passing to it <code class="literal">UITransitionContext.ToViewControllerKey</code>, using the following <a id="id799" class="indexterm"/>code:</p><div class="informalexample"><pre class="programlisting">UIViewController toViewController = transitionContext.GetViewControllerForKey(UITransitionContext.ToViewControllerKey);</pre></div><p>After we <a id="id800" class="indexterm"/>get the objects we need, we add the target controller's view to the transition context's view and change its frame with the <code class="literal">UIView.Animate</code> method. When all animations are executed, we need to call the <code class="literal">CompleteTransition</code> method on the transition context, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">containerView.AddSubview(toViewController.View);
//..
UIView.Animate(this.TransitionDuration(transitionContext), () =&gt; toViewController.View.Frame = new RectangleF(20f, 20f, frame.Width, frame.Height), () =&gt; transitionContext.CompleteTransition(true));</pre></div><p>The second object is a subclass of <code class="literal">UIViewControllerTransitioningDelegate</code>. The declaration of the class is shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">public class MyTransitionDelegate : UIViewControllerTransitioningDelegate</pre></div><p>Inside the <code class="literal">MyTransitionDelegate</code> subclass, we override the <code class="literal">PresentingController</code> method and return an instance of <code class="literal">MyTransitionAnimator</code> that we created earlier, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.animator = new MyTransitionAnimator();
this.animator.IsPresenting = true;
return this.animator;</pre></div><p>The <code class="literal">IsPresenting</code> property of <code class="literal">MyTransitionAnimator</code> is used as a flag so the animator will know if the transition is for presenting a controller or dismissing it. We set it to <code class="literal">false</code> inside the <code class="literal">GetAnimationControllerForDismissedController</code> method from which we return the same <code class="literal">MyTransitionAnimator</code> instance, using the following code:</p><div class="informalexample"><pre class="programlisting">this.animator.IsPresenting = false;
return this.animator;</pre></div><p>It is clear that one method will be called when the controller is to be presented and the other is to be dismissed.</p><p>Finally, to enable everything, we set the <code class="literal">ModalPresentationStyle</code> property to <code class="literal">UIModalPresentationStyle.Custom</code>, and a new instance of <code class="literal">MyTransitioningDelegate</code> to the <code class="literal">TransitioningDelegate</code> property of the controller that will be presented, using the following code:</p><div class="informalexample"><pre class="programlisting">modalController.ModalPresentationStyle = UIModalPresentationStyle.Custom;
modalController.TransitioningDelegate = new MyTransitionDelegate();</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec499"/>There's more...</h2></div></div></div><p>Custom <a id="id801" class="indexterm"/>transitions are not limited to <a id="id802" class="indexterm"/>modal controllers. We can use custom transitions for pushing controllers into the navigation stack of a navigation controller or completely create our own navigation stack.</p><div class="section" title="Transitioning between child controllers"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec119"/>Transitioning between child controllers</h3></div></div></div><p>The <code class="literal">UIViewController</code> class contains the <code class="literal">Transition</code> method that allows us to transition<a id="id803" class="indexterm"/> from one child controller to another, inside the parent controller.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note61"/>Note</h3><p>Child controllers are controllers whose views are part of the hierarchy of a third controller's view. This controller is the parent controller.</p></div></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec500"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Animating views</em></span> recipe in <a class="link" href="ch11.html" title="Chapter 11. Graphics and Animation">Chapter 11</a>, <span class="emphasis"><em>Graphics and Animation</em></span></li></ul></div></div></div>
<div class="section" title="Using physics in UI elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec125"/>Using physics in UI elements</h1></div></div></div><p>In this recipe, we will use UIKit Dynamics to add the properties of physics to an image view. The<a id="id804" class="indexterm"/> image view will drop from its initial <a id="id805" class="indexterm"/>position to the bottom of the screen, simulating the effect of an object dropping on the floor.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec501"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">ViewPhysicsApp</code>. Add <code class="literal">UIImageView</code> and two buttons to the controller. We will also need an image to show in the image view.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec502"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following fields in the <code class="literal">ViewPhysicsAppViewController</code> class:<div class="informalexample"><pre class="programlisting">private RectangleF imageRect;
private UIDynamicAnimator animator;</pre></div></li><li class="listitem">Add <a id="id806" class="indexterm"/>the following code in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.View.InsertSubviewBelow(this.imgView, this.btnReset);
this.imageRect = this.imgView.Frame;
this.imgView.Image = UIImage.FromFile("1.jpg");
this.animator = new UIDynamicAnimator(this.View);</pre></div></li><li class="listitem">Next, in<a id="id807" class="indexterm"/> the <code class="literal">ViewDidLoad</code> method again, add the following button handlers:<div class="informalexample"><pre class="programlisting">this.btnDrop.TouchUpInside += (sender, e) =&gt; {
  UIGravityBehavior gravity = new UIGravityBehavior(this.imgView);
  UICollisionBehavior collision = new UICollisionBehavior(this.imgView);
  collision.TranslatesReferenceBoundsIntoBoundary = true;
  this.animator.AddBehaviors(gravity, collision);
};
this.btnReset.TouchUpInside += (sender, e) =&gt; {
  this.animator.RemoveAllBehaviors();
  this.imgView.Frame = this.imageRect;
};</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap the <span class="strong"><strong>Drop!</strong></span> button and watch the image view drop to the bottom of the screen. Tap the <span class="strong"><strong>Reset</strong></span> button to reset it back to its original position. The following screenshot shows the app in its initial state and after the <span class="strong"><strong>Drop!</strong></span> button is tapped:<div class="mediaobject"><img src="graphics/8924OT_15_05.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec503"/>How it works...</h2></div></div></div><p>UIKit Dynamics offers a variety of objects that allow us to add the properties of physics to UIKit objects.</p><p>The first<a id="id808" class="indexterm"/> thing we need to do is to initialize<a id="id809" class="indexterm"/> a <code class="literal">UIDynamicAnimator</code> object. This class provides the context in which all the physics animations will take place. We pass the controller's view, which automatically makes it our 2D "physics world," using the following line of code:</p><div class="informalexample"><pre class="programlisting">this.animator = new UIDynamicAnimator(this.View);</pre></div><p>After we have created the dynamic animator, we need to add some behavior to it. Inside the <code class="literal">btnDrop</code> handler, we first make sure the image view will be affected by gravity by creating a <code class="literal">UIGravityBehavior</code> instance, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">UIGravityBehavior gravity = new UIGravityBehavior(this.imgView);</pre></div><p>If we leave it as it is, the image view will just drop below the bottom boundary of the screen. So, we also need a collision behavior, which we can add using the following code:</p><div class="informalexample"><pre class="programlisting">UICollisionBehavior collision = new UICollisionBehavior(this.imgView);
collision.TranslatesReferenceBoundsIntoBoundary = true;</pre></div><p>Note that the collision also needs a boundary to collide with, or it will have the same effect if it was not there. In this case, we use the boundary of our animator object, as indicated in the preceding highlighted code.</p><p>Now that <a id="id810" class="indexterm"/>we have our behavior set up, we add <a id="id811" class="indexterm"/>them to our animator to put everything into motion, using the following code:</p><div class="informalexample"><pre class="programlisting">this.animator.AddBehaviors(gravity, collision);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec504"/>There's more...</h2></div></div></div><p>We can also modify how the image view will bounce when it hits the ground. Try adding the following code below the <code class="literal">UICollisionBehavior</code> initialization line:</p><div class="informalexample"><pre class="programlisting">UIDynamicItemBehavior dynBehavior = new UIDynamicItemBehavior(this.imgView);
dynBehavior.Density = 1f;
dynBehavior.Elasticity = 0.7f;
dynBehavior.Friction = 1f;</pre></div><p>Of course, don't forget to add the new behavior to the animator, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">this.animator.AddBehaviors(gravity, collision, dynBehavior);</pre></div><p>If you run the app and tap the <span class="strong"><strong>Drop!</strong></span> button, the image will bounce more when it hits the ground!</p><div class="section" title="UIKit Dynamics usage"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec120"/>UIKit Dynamics usage</h3></div></div></div><p>UIKit Dynamics <a id="id812" class="indexterm"/>was designed to provide simple 2D physics to <code class="literal">UIView</code> objects or to every object that implements the Objective-C <code class="literal">UIDynamicItem</code> protocol (<code class="literal">IUIDynamicItem</code> interface in C#). It was not designed to develop games with <code class="literal">UIView</code> objects. For <a id="id813" class="indexterm"/>this purpose, we have the <span class="strong"><strong>SpriteKit framework</strong></span>, which is available through the <code class="literal">MonoTouch.SpriteKit</code> namespace. This is outside the scope of this book.</p></div></div></div>
<div class="section" title="Implementing the text-to-speech feature"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec126"/>Implementing the text-to-speech feature</h1></div></div></div><p>In this <a id="id814" class="indexterm"/>recipe, we <a id="id815" class="indexterm"/>will learn to work with <code class="literal">AVSpeechSynthesizer</code>, the class that provides the <span class="strong"><strong>Text-To-Speech</strong></span> (<span class="strong"><strong>TTS</strong></span>) functionality for many different languages.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec505"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">SpeechApp</code>. Add a <code class="literal">UITextField</code> and a button to the controller.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec506"/>How to do it…</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">MonoTouch.AVFoundation</code> namespace in the <code class="literal">SpeechAppViewController.cs</code> file, using the following code:<div class="informalexample"><pre class="programlisting">using MonoTouch.AVFoundation;</pre></div></li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.txtEntry.ShouldReturn = (textField) =&gt; textField.ResignFirstResponder();
this.btnSpeak.TouchUpInside += (sender, e) =&gt; {
  AVSpeechSynthesizer synth = new AVSpeechSynthesizer();
  AVSpeechUtterance utterance = new AVSpeechUtterance(this.txtEntry.Text);
  utterance.Rate = 0.3f;
  utterance.Voice = AVSpeechSynthesisVoice.FromLanguage("en-US");
  synth.SpeakUtterance(utterance);
};</pre></div></li><li class="listitem">Compile and run the app on the simulator. Type some text in English in the text field and tap the <span class="strong"><strong>Speak</strong></span> button. Listen while your app speaks!</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec507"/>How it works…</h2></div></div></div><p>The <code class="literal">AVSpeechSynthesizer</code> class was introduced with iOS 7. It provides very simple and practical <a id="id816" class="indexterm"/>TTS functionality.</p><p>After initializing an instance of the class, we create an <code class="literal">AVSpeechUtterance</code> object, passing it to the text we want it to process, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">AVSpeechSynthesizer synth = new AVSpeechSynthesizer();
AVSpeechUtterance utterance = new AVSpeechUtterance(this.txtEntry.Text);</pre></div><p>We then set the rate of the speech and assign a voice to the utterance, using the following code:</p><div class="informalexample"><pre class="programlisting">utterance.Rate = 0.3f;
utterance.Voice = AVSpeechSynthesisVoice.FromLanguage("en-US");</pre></div><p>The rate adjusts the speed at which the text will be spoken. You can test various speeds to suit your needs.</p><p>The voice is an instance of <code class="literal">AVSpeechSynthesisVoice</code>. To initialize it, we call the <code class="literal">FromLanguage</code> static method, passing the BCP-47 language code. Unfortunately, there is only one type of voice for each available language, and we have no control over it.</p><p>Finally, to<a id="id817" class="indexterm"/> start the speech, we call the <code class="literal">SpeakUtterance</code> method to the synthesizer, passing the utterance object to it using the following code:</p><div class="informalexample"><pre class="programlisting">synth.SpeakUtterance(utterance);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note62"/>Note</h3><p>We can call the <code class="literal">SpeakUtterance</code> method multiple subsequent times, passing a different utterance object each time. The speech synthesizer will queue each utterance and play it in sequence.</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec508"/>There's more...</h2></div></div></div><p>We can enumerate the available language codes that the speech synthesizer supports by enumerating the return value of the <code class="literal">AVSpeechSynthesisVoice.GetSpeechVoices()</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">foreach (AVSpeechSynthesisVoice eachVoice in AVSpeechSynthesisVoice.GetSpeechVoices()) {
  Console.WriteLine(eachVoice.Description);
}</pre></div><div class="section" title="Adjusting the utterance"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec121"/>Adjusting the utterance</h3></div></div></div><p>We can <a id="id818" class="indexterm"/>make more adjustments to how the speech will be performed through the following properties of the <code class="literal">AVSpeechUtterance</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PitchMultiplier</code>: This is the pitch of the utterance. It is a float whose values are in the range of <code class="literal">0.5</code> and <code class="literal">2</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PostUtteranceDelay</code>, <code class="literal">PreUtteranceDelay</code>: This is the amount of time to wait after (post) and/or before (pre) each utterance is spoken, in seconds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Volume</code>: This is the audio volume of the speech. It is in the range of <code class="literal">0.0</code> (silent) to <code class="literal">1.0</code> (loudest).</li></ul></div></div></div></div></body></html>