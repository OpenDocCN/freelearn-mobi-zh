["```swift\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n\n        // Configure the view.\n        SKView * skView = (SKView *)self.view;\n        skView.showsFPS = YES;\n        skView.showsNodeCount = YES;\n\n        // Create and configure the scene.\n        SKScene * scene = [GameScene sceneWithSize:skView.bounds.size];\n        scene.scaleMode = SKSceneScaleModeAspectFill;\n\n        // Present the scene.\n        [skView presentScene:scene];\n    }\n    ```", "```swift\n    -(id)initWithSize:(CGSize)size {  \n    if (self = [super initWithSize:size]) {\n        self.backgroundColor = [SKColor colorWithRed:0.15 green:0.15 blue:0.3 alpha:1.0];  \n    }\n    }\n    ```", "```swift\n    + (Player*) playerObject {\n        // Create a new critter, and give it a name\n        Player* obj = [Player spriteNodeWithColor:[SKColor whiteColor] size:CGSizeMake(30, 30)];\n        obj.name = @\"GamePlayer\";\n        return obj;\n    }\n\n    - (void) update:(float)deltaTime {\n\n    }\n    ```", "```swift\n    + (Player*) playerObject;\n    - (void) update:(float)deltaTime;\n    ```", "```swift\n    - (Player *)createPlayer\n    {\n        Player *plyr = [Player playerObject];\n        [self addChild:plyr];\n\n        return plyr;\n    }\n    ```", "```swift\n    Player *newPlayer = [self createPlayer];\n    newPlayer.position = [touch locationInNode:self];\n    ```", "```swift\n    typedef enum : NSUInteger {\n        Seek,\n        Arrive,\n        Flee,\n        Wander,\n        Evade\n    } SteeringBehaviorType;\n    ```", "```swift\n    @property (assign) SteeringBehaviorType behaviourType;\n    @property (assign) CGPoint target;\n    ```", "```swift\n    - (void) seek:(CGPoint )target deltaTime:(float)deltaTime {\n\n        // Work out the direction to this position\n        GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);\n        GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);\n\n        GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);\n\n        // Reduce this vector to be the same length as our movement speed\n        offset = GLKVector2Normalize(offset);\n        offset = GLKVector2MultiplyScalar(offset, 10);\n\n      [self.physicsBody applyForce:CGVectorMake(offset.x, offset.y)];\n    }\n    ```", "```swift\n    if (self.behaviourType == Seek) {\n      [self seek:self.target deltaTime:deltaTime];\n    }\n    ```", "```swift\n    @implementation GameScene {\n        float lastTime;\n        Player * newplayer;\n        SteeringBehaviorType behaviourType;\n    }\n    ```", "```swift\n    self.physicsWorld.gravity = CGVectorMake(0, 0);\n\n    newplayer = [self createPlayer];\n    newplayer.position = CGPointMake(size.width/2, size.height/2);\n\n    behaviourType = Seek;\n    newplayer.behaviourType = behaviourType;\n\n    if (behaviourType == Seek) {\n        newplayer.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:CGSizeMake(30, 30)];\n        newplayer.physicsBody.friction = 1.0f;\n        newplayer.physicsBody.linearDamping = 1.0f;\n    }\n    ```", "```swift\n    for (UITouch *touch in touches) {\n        CGPoint location = [touch locationInNode:self];\n        NSLog(@\"%@\", NSStringFromCGPoint(location));\n\n        newplayer.target = location;\n    }\n    ```", "```swift\n    -(void)update:(CFTimeInterval)currentTime {\n       /* Called before each frame is rendered */\n\n        if (!CGPointEqualToPoint(newplayer.target, CGPointZero)) {\n            float deltaTime = currentTime - lastTime;\n            [newplayer update:deltaTime];\n            lastTime = currentTime;\n        }\n    }\n    ```", "```swift\nVector desiredVelocity = player.locationVector - targetVector;\ndesiredVelocity.normalize;\ndesiredVelocity *= player.maxSpeed;\nreturn (desiredVelocity â€“ agent.locationVector);\n```", "```swift\n    - (void) flee:(CGPoint )target deltaTime:(float)deltaTime {\n\n        // Work out the direction to this position\n        GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);\n        GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);\n\n        GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);\n\n        // Reduce this vector to be the same length as our movement speed\n        offset = GLKVector2Normalize(offset);\n        offset = GLKVector2MultiplyScalar(offset, -10);\n\n        [self.physicsBody applyForce:CGVectorMake(offset.x, offset.y)];\n    }\n    ```", "```swift\n    if (self.behaviourType == Flee) {\n        [self flee:self.target deltaTime:deltaTime];\n    }\n    ```", "```swift\n    behaviourType = Seek;\n    ```", "```swift\n    behaviourType = Flee;\n    ```", "```swift\n    if (behaviourType == Seek)\n    ```", "```swift\n    if (behaviourType == Seek || behaviourType == Flee)\n    ```", "```swift\n    - (void) arrive:(CGPoint )target deltaTime:(float)deltaTime {\n\n        // Work out the direction to this position\n        GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);\n        GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);\n\n        GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);\n\n        // Reduce this vector to be the same length as our movement speed\n        offset = GLKVector2Normalize(offset);\n        offset = GLKVector2MultiplyScalar(offset, 5);\n\n        // Add this to our current position\n        CGPoint newPosition = self.position;\n        newPosition.x += offset.x;\n        newPosition.y += offset.y;\n\n        self.position = newPosition;\n    }\n    ```", "```swift\n    if (self.behaviourType == Arrive) {\n        int boxWidth = 20;\n\n        CGRect targetRect = CGRectMake(self.target.x - boxWidth, self.target.y - boxWidth, boxWidth*2, boxWidth*2);\n\n        if (!CGRectContainsPoint(targetRect, self.position)) {\n            [self arrive:self.target deltaTime:deltaTime];\n        }\n    }\n    ```", "```swift\n    behaviourType = Flee;\n    ```", "```swift\n    behaviourType = Arrive;\n    ```", "```swift\n    - (void) evade:(CGPoint )target deltaTime:(float)deltaTime {\n\n        GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);\n        GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);\n\n        GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);\n\n        // Reduce this vector to be the same length as our movement speed\n        offset = GLKVector2Normalize(offset);\n\n        // Note the minus sign - we're multiplying by the inverse of our movement speed,\n        // which means we're moving away from it\n        offset = GLKVector2MultiplyScalar(offset, -5);\n\n        // Add this to our current position\n        CGPoint newPosition = self.position;\n        newPosition.x += offset.x;\n        newPosition.y += offset.y;\n\n        self.position = newPosition;\n    }\n    ```", "```swift\n    if (self.behaviourType == Evade) {\n\n        int boxWidth = 100;\n\n        CGRect targetRect = CGRectMake(self.target.x - boxWidth, self.target.y - boxWidth, boxWidth*2, boxWidth*2);\n\n        if (CGRectContainsPoint(targetRect, self.position)) {\n\n            [self evade:self.target deltaTime:deltaTime];\n        }\n    }\n    ```", "```swift\n    behaviourType = Arrive;\n    ```", "```swift\n    behaviourType = Evade;\n    ```", "```swift\nGet targetVector\nwhile (true) {\n  Seek (targetVector);\n  get anotherTargetVector;\n}\n```", "```swift\n    int myRandom() {\n        return (arc4random() % 2 ? 1 : -1);\n    }\n\n    - (void)wanderWithDeltaTime:(float)deltaTime\n    {\n        int boxWidth = 20;\n\n        CGRect targetRect = CGRectMake(self.target.x - boxWidth, self.target.y - boxWidth, boxWidth*2, boxWidth*2);\n        if (!CGRectContainsPoint(targetRect, self.position)) {\n\n            [self seek:self.target deltaTime:deltaTime];\n\n        } else {\n            int offsetX = self.scene.size.width;\n            int offsetY = self.scene.size.height;\n\n            self.target = CGPointMake(arc4random() % offsetX, arc4random() % offsetY);\n        }\n    }\n    ```", "```swift\n    if (self.behaviourType == Wander) {\n        [self wanderWithDeltaTime:deltaTime];\n    }\n    ```", "```swift\n    behaviourType = Evade;\n    ```", "```swift\n    behaviourType = Wander; \n    ```", "```swift\n    if (behaviourType == Wander) {\n        newplayer.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:CGSizeMake(30, 30)];\n        SKPhysicsBody* borderBody = [SKPhysicsBody bodyWithEdgeLoopFromRect:self.frame];\n        self.physicsBody = borderBody;\n        self.physicsBody.friction = 0.0f;\n        newplayer.physicsBody.friction = 1.0f;\n        newplayer.physicsBody.linearDamping = 1.0f;\n    }\n    ```", "```swift\n    Front_Feeler = player->Get velocity; // vector\n    Front_Feeler = Front_Feeler.normalize(); // vector\n    ```", "```swift\n    Front_Feeler =  Front_Feeler *  FeelerLength; // vector\n    Front_Feeler =  Front_Feeler + player->location;\n    ```", "```swift\n    Front_Feeler = player->Get velocity; // vector\n    Front_Feeler = Front_Feeler.normalize(); // vector\n\n    Left_Feeler = player->Get velocity; // vector\n    Left_Feeler = Left_Feeler.normalize(); // vector\n\n    Right_Feeler = player->Get velocity; // vector\n    Right_Feeler = Right_Feeler.normalize(); // vector\n\n    This will project the feeler in front of the player.\n    Front_Feeler =  Front_Feeler *  FeelerLength; // vector\n    Front_Feeler =  Front_Feeler + player->location; \n\n    Left_Feeler =  Left_Feeler *  FeelerLength; // vector\n    Left_Feeler =  Left_Feeler + player->location; \n    Left_Feeler->x = Left_Feeler -> x - player-> width;\n\n    Right_Feeler =  Right_Feeler *  FeelerLength; // vector\n    Right_Feeler =  Right_Feeler + player->location; \n    Right_Feeler->x = Right_Feeler -> x + player-> width;\n    ```"]