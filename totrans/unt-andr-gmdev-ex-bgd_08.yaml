- en: Chapter 8. Special Effects – Sound and Particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we took a short break from our Space Fighter game
    to learn about physics and 2D games in Unity. We created a clone of Angry Birds.
    The birds utilized physics to fly through the air and destroy the pigs and their
    structures. We utilized parallax scrolling to make a pleasing background effect.
    We also created a level selection screen to load the game''s various scenes from.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we return to the Space Fighter game. We are going to add
    many special effects that will round out the game experience. We start by learning
    about the controls that Unity provides when working with audio. We move on to
    add some background music to the game and warning sounds when anything gets too
    close. Next, we learn about particle systems, creating engine trails for our ship.
    Finally, we combine the effects of the chapter to create bullet blasts and explosions.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing audio clips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing SFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding 2D and 3D SFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open up your Space Fighter project and we will get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other assets, the Unity team has worked hard to make working with audio
    easy and pain-free. Unity is capable of importing and utilizing a broad range
    of audio formats, allowing you to keep your files in a format that you can edit
    in another program.
  prefs: []
  type: TYPE_NORMAL
- en: Import settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Audio clips have a small assortment of important settings. They let you easily
    control the type and compression of files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Import settings](img/2014OT_08_01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the settings that we have to work with while importing audio
    clips:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Format**: This controls whether the file is included in the **Native**
    format or is **Compressed** in the final game. **Native**, though larger in file
    size, is best for short sound effects because they can be loaded and played quickly.
    **Compressed** is better for longer sounds and music. They will have a smaller
    footprint in the final build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D Sound**: This checkbox controls whether the file will be played in 2D
    or 3D. 2D sounds will be played at a constant volume no matter where the player
    is located—perfect for background music and voice overs. 3D sounds will be adjusted
    in volume based on their distance from the player—excellent for explosions and
    gun shots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force to mono**: This checkbox will cause Unity to change a stereo file to
    a mono file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load type**: This controls how the file is loaded when the game is being
    played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load into memory**: This loads a **Native** file directly to the memory to
    be played.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream from disc**: This streams the audio as it is playing, such as streaming
    music or video from the Web.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decompress on load**: This removes compression on the file when it is first
    needed. The overhead for this option makes it a very poor choice for large files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressed in memory**: This only decompresses the file as it is being played.
    When it is just being held in memory, the file remains compressed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware decoding**: This is only used for iOS devices to reduce processing
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gapless looping**: This adjusts the compression method to remove the small
    pop of silence that some methods can introduce to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression**: This is the amount of data per second to compress the file
    to, resulting in a smaller-sized file. It is best to find a value that minimizes
    the file size while losing the least amount of quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio Listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to actually hear anything in the game, every scene needs an **Audio
    Listener** component in it. By default, the `Main Camera` object (included first
    in any new scene) and any new camera you might create has an **Audio Listener**
    component attached. There can only be one **Audio Listener** component in your
    scene at a time. If there is more than one, or you try to play a sound when there
    isn't one, Unity will fill your console log with complaints. The **Audio Listener**
    component also gives the precise position for any 3D sound effects to key off.
  prefs: []
  type: TYPE_NORMAL
- en: Audio Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Audio Source** component is like a speaker and controls the settings for
    playing any sound effect. If the clip is 3D, the position of this object to the
    **Audio Listener** component and the mode chosen determine the volume of the clip.
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio Source](img/2014OT_08_02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the various settings for an **Audio Source** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Clip**: This is the sound file that this **Audio Source** component
    will play by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mute**: This is a quick way to toggle the volume of the playing sound on
    and off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bypass Effects**: This allows one to toggle any special filters applied to
    this **Audio Source** component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play On Awake**: This will cause the **Audio Clip** to immediately start
    playing when the scene loads or the object is spawned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop**: This will cause the playing clip to repeat as it is played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: This dictates the relative importance of the files being played.
    **0** is most important and best for music, while **256** is least important.
    Depending on the system, only so many sounds can be played at once. The list of
    files to be played starts with the most important and ends when this limit is
    reached, excluding those with the lowest values if there are more sounds than
    the limit would allow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: This decides how loud the clip will be played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitch**: This scales the playback speed of the clip.![Audio Source](img/2014OT_08_03.png.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D Sound Settings**: This contains the group of settings specific to the
    playing of 3D audio clips. The **Volume**, **Pan**, and **Spread** options can
    be adjusted using the graph at the end of the group. This allows one to create
    more dynamic transitions as the player approaches an **Audio Source** component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doppler Level**: This decides how much of the doppler effect to apply to
    moving sounds.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume Rolloff**: This controls how the volume fades with distance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logarithmic Rolloff**: This is a sudden and rapid falloff of the sound at
    a short distance from the source''s center.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Linear Rolloff**: This is an even falloff with distance, the loudest being
    at the **Min Distance** value and the quietest at the **Max Distance** value.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Custom Rolloff**: This allows you to create a custom falloff by adjusting
    the graph at the end of the group. It is also automatically chosen when the graph
    is adjusted.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If the **Audio Listener** component is closer than the **Min Distance** value,
    the audio will be played at the current volume level. Outside this distance, the
    sound will fall off according to the **Rolloff Mode**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pan Level**: This is the percentage of the 3D effects to be applied to this
    **Audio Source** component. This affects things such as the falloff and doppler
    effects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spread**: This adjusts the amount of area in speaker space that the sound
    covers. It becomes more important when working with more than one or two speakers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond the **Max Distance** value, the sound will stop transitioning based on
    the graph at the bottom of the group.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2D Sound Settings**: This groups the settings that are specific to 2D audio
    clips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pan 2D**: This adjusts how evenly the sound comes out of each speaker, weighing
    it towards the left or right speaker'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding background music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know about the available audio settings, it is time to put that
    knowledge into action. We will start by adding some background music. This will
    have to be a 2D sound effect so we can hear it comfortably no matter where the
    **Audio Source** component is. We will also create a short script to fade in the
    music to reduce the suddenness with which sound effects bombard the player.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding background music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with a single script to control our background music.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a new script and naming it `FadeIn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script begins with three variables. The first is the goal volume that the
    script has to reach. The second is the number of seconds the transition will take.
    The last is the time when the transition began.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we make use of the `Awake` function. It begins by looking at the `audio`
    variable, which is automatically supplied by Unity, to check for an attached **Audio
    Source** component. If one cannot be found, the `gameObject` is destroyed and
    the function is exited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Awake` function ends by setting its volume to `0` and playing it if it
    isn't already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To cause the transition over time, we use the `Update` function. It will first
    check to see whether the `fadeStartTime` variable is below zero and set it to
    the current time if it is. This allows us to avoid the hiccup that can be caused
    by the initialization of a scene starting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function next checks to see if the transition's time has ended. If it has,
    the **Audio Source** component's volume is set to `maxVolume` and the script is
    destroyed to free resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the current progress is calculated by finding the amount of time that
    has passed since the fade started and dividing it by the length of the transition.
    The resulting percentage of progress is multiplied by the value of `maxVolume`
    and applied to the **Audio Source** component's volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in Unity, we need to create a new empty `GameObject` and name it `Background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To this object, add our `FadeIn` script and an **Audio Source** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not already, create an `Audio` folder in your **Project** panel
    and import the four sound files included in **Starting Assets** for the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Background` sound file and uncheck the **3D Sound** checkbox in
    the import settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your `Background` object in the **Hierarchy** window and drag the `Background`
    sound to the **Audio Clip** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the **Play On Awake** and **Loop** checkboxes are checked on the **Audio
    Source** component. The **Volume** option also needs to be set to **0**, all to
    make the file play throughout the game but make no noise when starting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added background music to our game. In order for the sound to be constant
    and not directional, we utilized the music as 2D sound. We also created a script
    to fade the music in when the game starts. This eases the transition into the
    game for the player, preventing a sudden onslaught of sound.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – setting some mood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Background music adds a lot to a game's experience. A horror scene is not nearly
    as scary without some scary music. Bosses are much less intimidating without their
    daunting music. Look for some good background music for your other games. Something
    light and cheery would work nicely for Angry Birds, while a piece that is more
    industrial and fast-paced would keep hearts racing through the Tank Battle game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an alarm system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand 3D audio effects, we are going to create an alarm system. As objects
    approach the ship, the alarm will increase in volume. The 3D effect will indicate
    the direction to the object relative to the ship. This gives the player the needed
    feedback when they can't see everything around them. There are several ways this
    effect can be achieved, but this one will demonstrate our ability to adjust the
    **Audio Source** component over time.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – warning the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A single script attached to our objects in space will warn the player as the
    objects approach.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new script and name it `Alarm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with a single variable. It will hold the distance value at
    which the sound will start to fade in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we create the `Update` function. It starts by checking for an **Audio
    Source** component and exiting the function early if there isn't one. The `audio`
    variable holds the reference to the attached **Audio Source** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function continues by calculating the distance to the player. Because the
    player never moves, we can just use the position's distance to the origin to make
    it simpler. We also use `sqrMagnitude`, which is the square of the length of the
    vector, because it is significantly faster to calculate. If the object is outside
    the range, the volume is set to `0` and the function is exited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we calculate the new volume by dividing the distance by the square
    of `warningDist` value and subtracting the result from one. This will result in
    a rounded curve as it approaches maximum volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to add the script to the relevant objects. To both the enemy ship
    and asteroid prefabs, add the `Alarm` script and an **Audio Source** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Audio Clip** value, select the `Alarm` clip. Also, make sure both
    the **Play On Awake** and **Loop** checkboxes are checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we don't want the alarm to overpower other sounds in our game, so set
    the **Priority** option to **192**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep it from making any noise when the object is spawned, set the **Volume**
    option to **0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for the script to fully control the **Audio Source** component's volume,
    expand the **3D Sound Settings** component. Select **Linear Rolloff** for **Volume
    Rolloff** and **495** for the **Min Distance** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a script to warn the player when objects get too close. As they approach
    the player, the volume on their audio source is increased. As they move away from
    the player, the volume is reduced. By utilizing 3D audio clips, we can direct
    the player as to where the approaching object is coming from.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – differentiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is great that we can tell when objects are coming too close, but we can't
    tell what it is until we see it. Find some alternate alarm sounds. For each type
    of object that the player has to contend with, give it a different sound. This
    way, the player will know whether they need to start pulling some tricky maneuvers
    to dodge bullets or they are entering an asteroid field and need to fly carefully
    to avoid a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle systems add much to the final look of a game. They can take the form
    of fire, magic waves, rain, or the great many other effects you can dream up.
    They are often hard to create well, but are well worth the effort. Keep in mind,
    especially when working with the mobile platform, that less is more. Larger particles
    are more effective than a great amount of particles. If your particle system ever
    contains thousands of particles in a small space or is duplicated on itself to
    increase the effect, you need to rethink the design and find a more efficient
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Particle system settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every particle system contains a large variety of components, each with its
    own settings. Most of the available settings have the option to be **Constant**,
    **Curve**, **Random** **Between Two Constants**, and **Random Between Two Curves**.
    **Constant** will be a specific value. **Curve** will be a set value that changes
    along the curve over time. The two random settings select a random value between
    the respective value types. It may seem confusing at first but, as we work through
    them, they will become more understandable.
  prefs: []
  type: TYPE_NORMAL
- en: As you will be able to see in the images and descriptions that follow, we will
    work through and gain an understanding of each piece of a particle system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see in the following screenshot, we will work through and gain
    an understanding of each piece of a particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first portion, the **Initial** module, of the particle system holds all
    the settings used by every emitter in Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Duration**: This is how long the emitter lasts. A looping system will repeat
    after this amount of time. A non-looping system will stop emitting after this
    length of time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Looping**: This checkbox dictates whether or not the system loops.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prewarm**: This checkbox, if checked, will start a looping system as if it
    has already had a chance to loop for a while. This is useful in the case of torches
    that should already be lit, not start when the player enters the room.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Delay**: This will stop the particle system from emitting for the given
    number of seconds when it is initially triggered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Lifetime**: This is the number of seconds an individual particle begins
    with.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Speed**: This is how fast a particle will initially move when spawned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Size**: This dictates how large a particle is when spawned. It is always
    better to use larger particles rather than more particles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Rotation**: This will rotate the emitted particles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Color**: This is the color tint of the particles when spawned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gravity Multiplier**: This gives the particles a greater or lesser amount
    of the gravity effect.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inherit Velocity**: This will cause particles to gain a portion of their
    transform''s momentum if it is moving.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulation Space**: This determines whether the particles will stay with
    the game object as it is moved (that is, local) or will remain where they are
    in the world.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play On Awake**: This checkbox, if checked, will cause the emitter to start
    emitting as soon as it is spawned or the scene starts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Particles**: This limits the total number of particles that this system
    supports at a single time. This value only comes into play if the rate particles
    are emitted or their life span is great enough to overbalance their rate of destruction.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_05.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Emission** module controls how fast the particles are emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rate**: If set to **Time**, this is the number of particles per second that
    are created. If set to **Distance**, this is the number of particles per unit
    of distance the system travels as it moves.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bursts**: This is only used when the **Rate** option is set to **Time**.
    It allows you to set points in the system''s timeline when a specific number of
    particles will be emitted.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_06.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Shape** module controls how the system emits particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shape**: This dictates what form the emission point will take. Each option
    comes with a few more value fields that determine its size.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sphere**: This is the point from which particles are emitted in all directions.
    **Radius** determines the size of the sphere. **Emit from Shell** dictates whether
    the particles are emitted from the surface of the sphere or inside the volume.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hemisphere**: This is, as the name suggests, half of a sphere. **Radius**
    and **Emit from Shell** work the same here as they do for **Sphere**.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cone**: This emits particles in one direction. **Angle** determines whether
    the shape is closer to a cone or cylinder. **Radius** dictates the size of the
    emission point of the shape. **Emit From** will determine where the particles
    are emitted from. **Base** emits from the base disc of the shape. **Base Shell**
    emits from the base of the cone, but around the surface of the shape. **Volume**
    will emit from anywhere inside the shape and **Volume Shell** emits from the surface
    of the shape.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Box**: This emits particles from a cube-type shape. **Box X**, **Box Y**,
    and **Box Z** determine the size of the box.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesh**: This allows you to select a model to use as an emission point. All
    of the particles for the system will be emitted from the surface of the **Mesh**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random Direction**: This determines whether a particle''s direction is determined
    by the surface normal of the shape chosen, or if it is chosen at random.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_07.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Velocity over Lifetime** module allows you to control the momentum of
    the particles after they have been spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**X**, **Y**, and **Z**: These define the number of units per second along
    each axis of the particle''s momentum'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Space**: This dictates whether the velocity is applied locally to the system''s
    transform, or relative to the world'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_08.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Limit Velocity over Lifetime** module dampens a particle's movement if
    it exceeds the specified value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Separate Axis**: This allows you to define a value unique to each axis and
    whether that value is local or relative to the world'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: This is how fast the particle has to be moving before the damp is
    applied'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dampen**: This is the percentage of speed to cut the particle by. It is a
    value between zero and one'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_09.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Force over Lifetime** module adds a constant amount of movement to each
    particle over the course of its life.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**X**, **Y**, and **Z**: These define how much force to apply along each axis'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Space**: This dictates whether the force is applied local to the system''s
    transform or in the world space'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If **X**, **Y**, and **Z** are random values, **Randomize** will cause the amount
    of force to apply to be randomly picked each frame, resulting in a statistical
    averaging of the random values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_10.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Color over Lifetime** module allows you to define a series of colors for
    the particle to transition through after it has been spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Color by Speed** module causes the particle to transition through the
    defined range of colors as its speed changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Color**: This is the set of colors to transition through'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Range**: This defines how fast the particle must be going to be at
    the minimum and maximum ends of the **Color** range'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_11.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Size over Lifetime** module changes the size of the particle over the
    course of its life.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Size by Speed** module adjusts the size of each particle based on how
    fast it is going.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Size**: This is the adjustment that the particles transition through'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Range**: This defines the min and max values for each of the **Size**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_12.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Rotation over Lifetime** module rotates particles over time after they
    have been spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Rotation by Speed** module rotates particles more as they go faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Angular Velocity**: This is the number of rotations to apply'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Range**: This is the min and max range for the **Angular Velocity**
    value if it is not set to **Constant**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_13.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **External Forces** module multiplies the effect of Wind Zone objects. Wind
    Zones simulate the effects of wind on particle systems and Unity's trees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Collision** module allows particles to collide and interact with the physical
    game world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If set to **Planes**, you are able to define a number of flat surfaces for the
    particles to collide with. This is faster to process than World collisions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Planes**: This is a list of transforms that define the surfaces to collide
    with. Particles will only collide with the local, positive y side of the transform.
    Any particles on the other side of the point will be destroyed.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Visualization**: This gives you the option to view the planes as a **Solid**
    surface or a **Grid** surface.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Scale Plane**: This adjusts the size of the **Visualization** option. It
    does not affect the actual size of the surface to collide with.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Particle Radius**: This is used to define the size of the sphere used to
    calculate the particle''s collision with the planes.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If set to **World**, the particles will collide with every collider in your
    scene. This can become a lot for the processor to handle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collides With**: This defines a list of layers that will be collided with.
    Only colliders on layers that are checked in this list will be used for the collision
    calculation.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Collision Quality**: This defines how precise the collision calculations
    are for this particle system. **High** will calculate precisely for every single
    particle. **Medium** will use an approximation and a limited number of new calculations
    each frame. **Low** just calculates less often than **Medium**.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If **Collision Quality** is set to **Medium** or **Low**, **Voxel Size** dictates
    how precise the system estimates the points of collision.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dampen**: This removes the defined fraction amount of speed from the particle
    when it collides with a surface.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounce**: This allows the particle to maintain the defined fraction of its
    speed, specifically along the normal of the surface that was hit.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifetime Loss**: This is the percentage of life. When the particle collides,
    this percentage of life is removed from the particle. When the particle''s life
    drops to zero over time, or through collision, it is removed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If, after collision, the particle's speed is below the **Min Kill Speed** value,
    it is destroyed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **Send Collision Messages** checkbox is checked, scripts attached to
    the particle system and the object that was collided with will be alerted every
    frame that the collision took place. Only one message is sent per frame, not per
    particle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_14.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Sub Emitters** module allows additional particle systems to be spawned
    at points in the life of each particle of this system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any particle systems in the **Birth** list will be spawned and follow the particle
    when it is first created. This could be used to create a fireball or smoke trail.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Collision** list spawns particle systems when the particle hits something.
    This could be used for rain drop splashes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Death** list spawns particles when the particle is destroyed. It could
    be used to spawn the firework explosion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_15.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Texture Sheet Animation** module causes the particle to flip through a
    number of particles over the course of its life. The texture used is defined in
    the **Renderer** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tiles**: This defines the number of rows and columns in the sheet. This will
    determine the total number of frames available.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation**: This gives you the options of **Whole Sheet** and **Single Row**.
    If set to **Single Row**, the row used can either be chosen at random or specified
    using the **Random Row** checkbox and **Row** value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame over Time**: This defines how the particle transitions between frames.
    If set to **Constant**, the system will only use a single frame.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycles**: This is the number of times the particle will loop through the
    animation over the course of its life.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/2014OT_08_16.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Renderer** module dictates how the particle is drawn on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Render Mode**: This defines which method a particle should use to orient
    itself in the game world.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Billboard**: This will always face directly at the camera.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stretched Billboard**: This will face particles at the camera, but stretch
    them based on the speed of the camera, the particle''s speed, or by a specific
    value.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Horizontal Billboard**: This is flat on the XZ plane of the game world.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Vertical Billboard**: This will always face the player, but will always stay
    straight along the y axis.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If set to **Mesh**, you can define a model to be used as a particle rather than
    a flat plane.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Normal Direction**: This is used for the lighting and shading of the particles
    by adjusting the normal of each plane. A value of **1** points the normals directly
    at the camera while a value of **0** points them towards the center of the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material**: This defines the material used to render the particles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sort Mode**: This dictates what order the particles should be drawn in, by
    distance or age.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting Fudge**: This causes particle systems to be drawn earlier than normal.
    The higher the value, the earlier it will be drawn on the screen. This affects
    whether the system appears in front of or behind other particle systems or partially
    transparent objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cast Shadows**: This determines if the particles will block light.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Shadows**: This determines if the particles are affected by the shadows
    cast by other objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Particle Size**: This is the total amount of screen space a single particle
    is allowed to fill. No matter what the real size of the particle is, it will never
    fill more than this space of the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating engine trails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enforce the player's impression that their ship is moving, we need to create
    some trails for the ship's engines. This exhaust will trail out as if the ship
    is moving even though it is not. By making the particle systems part of the group
    of objects that make up the ship, the engine trails will move and leave particles
    as one would expect them to.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding engine trails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Engine trails can easily be added and controlled with the use of only a particle
    system.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to create a new particle system. Do this by going to
    the top of the Unity Editor and navigating to **GameObject** | **Create Other**
    | **Particle System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new particle system to `EngineTrail`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First we look at the **Initial** module. We need the **Looping** and **Prewarm**
    checkboxes checked. This will keep the ship looking as if it is moving throughout
    the game and remove the build up the system would otherwise need to create the
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to control the distance the particles travel. Do this by setting
    the **Start Lifetime** option to **3** and the **Start Speed** option to **1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep the particles sized and positioned properly in space, we need to set
    the **Start Size** option to **0.8** and choose **World** for **Simulation Space**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we move on to the **Shape** module. We want the particles to fly straight
    out from the engines. So we use a value of **0** for the **Angle** option and
    **0.2** for the **Radius** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exhaust tends to fade in color and dissipate in density over time. To achieve
    this effect, activate the **Color over Lifetime** and **Size over Lifetime** modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Color** option, set the **Alpha** option to **0** at the beginning
    of the gradient and **255** a short way in. As to colors, select a vibrant blue
    at the beginning, transitioning to white, and then gray at the end.![Time for
    action – adding engine trails](img/2014OT_08_17.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Size** option, select a linear slope that is maximum at the beginning
    and minimum at the end. This is most easily done by clicking on the curve, to
    the right of the **Size** label, and selecting the third option from the bottom
    of the **Particle System Curves** window at the bottom of the **Inspector** window.![Time
    for action – adding engine trails](img/2014OT_08_18.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in the **Scene** window, duplicate the `EngineTrail` object three times
    and position them behind the engines of the ship. Be sure to rotate them so the
    particles are emitted away from the ship.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, make all of them children of the player's ship. If this step is skipped,
    they will not follow the ship as it moves.![Time for action – adding engine trails](img/2014OT_08_19.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We put into practice what we learned about particle systems to create trails
    for our space ship's engines. Because they are children of the ship and simulate
    in world space, they move with the ship and trail off as one would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more trails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The enemy ships have engines too. Try adding trails to the enemy ships. Be careful
    about picking the local or world space to simulate in. Because the ships move
    to make it look like the player is moving, simulating in world space could have
    some unusual side effects.
  prefs: []
  type: TYPE_NORMAL
- en: If you gave the player a turbo boost effect earlier, it is time to add some
    extra effects to it now. Try changing the length of the trails when the player
    is boosting. Perhaps the ship taps into a special type of fuel when it boosts.
    If it burns a different color, then the trails would have to be a different color,
    or series of colors, when the player is boosting.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we learned about audio effects and particle systems on their own. They
    each can add a lot to the scene, setting the mood and giving that touch of polish
    that sets a game apart. But there are many effects that cannot stand on their
    own as one or the other. Explosions, for example, are simply not that impressive
    unless you have both the visual and auditory effects.
  prefs: []
  type: TYPE_NORMAL
- en: Explosions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is so much more satisfying to destroy enemies when they explode. It takes
    both a particle effect and the sound effect to make a proper explosion. We will
    start by creating an explosion prefab. Then we will update the player's shooting
    to spawn the explosion when asteroids and enemy ships are destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding explosions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A single particle system and script will allow us to create some nice explosions
    that can be used everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: We first need some new textures to make the explosion look like fire. Luckily,
    Unity provides a multitude of basic particle textures. To include them in your
    project, go to the top of the Unity Editor and navigate to **Assets** | **Import
    Package** | **Particles**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resulting window, select **Import** and wait for Unity to finish importing
    them. This package is a great resource, including both textures and complete particle
    systems. However, all of the particle systems included use the old system that
    will be phased out of Unity over the next few versions. Despite this, we can still
    make full use of the included materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `particleSystem` object and name it `Explosion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, in the **Initial** module, we need to make the effect last for a short
    time. Set the **Duration** to **0.5** and the **Start Lifetime** option to **1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep the particles close together, use a value of **0.5** for the **Start
    Speed** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are done with this system, it will not loop. However, it is easier to
    see what we are working with if we let it loop for now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we need more particles, so go to the **Emission** module. Set the **Rate**
    option to **120** to generate the proper amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An explosion is generally round, so we need to adjust the **Shape** module next.
    Select **Sphere** for the **Shape** setting and set the **Radius** option to **0.5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now for the **Color over Lifetime** module. An explosion is bright at the beginning
    and fades to brown, followed by black as it burns. For the **Color** option, start
    with an army green color, followed by faded yellow, then medium brown, and finally
    black at the end. Also, cause **Alpha** to fade in at the beginning and out at
    the end. This keeps the particles from popping in and out of existence.![Time
    for action – adding explosions](img/2014OT_08_20.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need a fire material for our particles. For the **Material** setting
    in the **Renderer** module, select the **Fire Smoke** material. It can also be
    found in your **Project** window by going to **Standard Assets** | **Particles**
    | **Sources** | **Materials**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we are satisfied with the look of the system, make sure the **Play On Awake**
    checkbox is checked and the **Looping** checkbox is not checked in the **Initial**
    module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with the asteroids and enemy ships, the explosion needs to move around our
    player as they move. It also needs to destroy itself when it is done emitting.
    So, create a new script and name it `Explosion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script is short and only includes two functions. The first function, `Update`,
    checks to see if the `particleSystem` object is missing or has finished playing.
    If either is true, the `gameObject` is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second function, `LateUpdate`, simply uses the `PlayerShip.Rotate` function,
    which we created in [Chapter 6](ch06.html "Chapter 6. Specialties of the Mobile
    Device – Touch and Tilt"), *Specialities of the Mobile Device – Touch and Tilt*,
    to move the explosion for the player's movement. This is the same way we move
    the asteroids and enemy ships around as the player moves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity and add the script to the `Explosion` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add an **Audio Source** component to the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this component, we need the **Play On Awake** checkbox checked. Also select
    **Linear Rolloff** for the **Volume Rolloff** mode and **10** for the **Min Distance**,
    both found under **3D Sound Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And, of course, select the **Explosion** sound effect for the source's audio
    clip. These settings will cause the sound to play as soon as the explosion is
    spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To complete the explosion's creation, turn the object into a prefab and delete
    the instance from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to update the `TouchShoot` script to utilize the explosion. Open
    it now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the beginning, we add a variable to hold a reference to the explosion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the line where we make use of the `Physics.Raycast` function and before
    we destroy the shot object, add this line. If there is a reference to the explosion,
    it uses the `Instantiate` function to spawn a new instance of the explosion and
    sets its position and rotation to that of the object that was shot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in Unity, find the instance of the `TouchShoot` script component on the
    player's ship. Add the reference to the `Explosion` prefab in the new **Explosion**
    slot.![Time for action – adding explosions](img/2014OT_08_21.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an explosion. Unity provides us with a slew of particle textures
    with which we can create a multitude of effects. There are also a few particle
    systems already created, including an explosion. However, that explosion uses
    the old system and will not be included in Unity for much longer. We also updated
    our enemy ships and asteroids so they spawn the explosions when they are destroyed
    by the player.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more types of explosions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One explosion is alright, but it is odd that the asteroids explode in the same
    manner as the ships. Different gases, fuels, and rock compositions all burn in
    different colors and with varying amounts of vigor. Create some more explosions
    for the different objects flying around your space. Change the colors and size
    to suit what is exploding. Also, explore other sound effects that provide differing
    auditory clues as to what is exploding. Finally, try to create a multi-explosion
    system. Perhaps the shots from the player cause the first explosion, and a chain
    reaction causes explosions in the weapon hold and engine compartment. To achieve
    this, take a look at using subemitters, or spawn a couple of different particle
    systems around the ship when it is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating laser blasts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to destroy objects and see them explode is great. It gives the player
    a reward for performing a simple action. However, when one fires a gun of any
    sort, you expect a reaction from it, whether or not anything is hit. To that end,
    we are going to create a muzzle-flash-type effect for the player's ship. Every
    time they tap the screen to fire, some particle systems will flash and a sound
    effect will play.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding laser blasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A muzzle flash generally consists of two parts. The first is a straight blast,
    forward along the barrel. The second is a fan around the base of the first.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, create a new `particleSystem` object and rename it as `LineBlast`;
    we will now proceed to make the first part.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The flash does not last for very long, so find the **Duration** option in the
    **Initial** module and set it to **0.1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to set the **Start Lifetime** option to **0.1** so the particles
    do not stay on screen for very long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The flash does not move away from the muzzle, so set the **Start Speed** option
    to **1**, keeping the particles close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The particles need to be sized to correspond with the size of our ship's muzzle.
    Set the **Start Size** option to **0.2** to keep them small.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is no fun if our laser blasts are just white, so change the **Start Color**
    value to an appropriate color for your lasers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last up for the **Initial** module is to uncheck the **Play On Awake** checkbox,
    keeping the system from triggering immediately when loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need to adjust the **Emission** module. The flash occurs in a burst,
    so set the **Rate** option to **0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the burst, click on the **+** sign to the right of the **Bursts** list.
    A value of **5** will work well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we adjust the **Shape** module to emit the particles along a straight line.
    To this end, set the **Angle** option to **0** and the **Radius** option to **0.01**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to adjust the **Renderer** module. To stretch out the particles,
    change the **Render Mode** option to **Stretched Billboard** and set the **Length
    Scale** option to **-4.5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we are satisfied with the way this system looks, uncheck the **Looping**
    checkbox in the **Initial** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create the second `particleSystem` object and rename it as `SpreadBlast`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These particles should last for as long as those of the first system. So, in
    the **Initial** module, set the **Duration** option to **0.1**, **Start Lifetime**
    to **0.1**, **Start Speed** to **1**, **Start Size** to **0.2**, and uncheck **Play
    On Awake**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make these particles distinct from the line, set the **Start Color** value
    to a slightly darker color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Emission** module, set the **Rate** option to **0** and add the
    **Bursts** option with a **Particles** value of **30**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Shape** module, set the **Angle** option to **60** and the **Radius**
    option to **0.01**. This causes the particles to fan out when spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Renderer** module, set the **Render Mode** option to **Stretched Billboard**
    and the **Length Scale** option to **-3**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, once we are satisfied with the look of the system, again uncheck the
    **Looping** checkbox in the **Initial** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we put the particle systems in place, we need to create a script. Create
    a new one and name it `LaserBlast`. This script will trigger the particle systems
    and the audio clip to play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with a single variable. This variable holds the list of systems
    to be triggered when the script is told to fire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next we have the only function in the script, `Fire`. It starts by making sure
    there is an **Audio Source** component on the same `GameObject`. If it is present,
    `PlayOneShot` is called using the source's clip. This function plays the passed
    file once without blocking the playing of other clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function continues by looping through the list of particle systems and using
    `Play` to trigger them if they exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to update the `TouchShoot` script. It needs to call the `Fire`
    function on the `LaserBlast` script when the player touches the screen. To that
    end, we first add the `lasers` variable to hold the list of objects that need
    to be triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To the beginning of the `Update` function, we add the `didFire boolean` value.
    It will keep the lasers from being triggered more than once per frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We next set the Boolean to true after the `if` statement where we check to see
    if the touch's phase value is found to be equal to `TouchPhase.Began`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end of the `Update` function, if the `didFire boolean` is true, the `Fire`
    function that we will be writing shortly is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Last up for the script, we add the `Fire` function. This function simply loops
    through the `lasers` array and calls their `Fire` function if they exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have all of the pieces, we need to put them together. Start by creating
    a new empty `GameObject` and naming it `LaserBlast`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, make the `LineBlast` and `SpreadBlast` particle systems children of this
    new object. Be sure to set their positions and rotations to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our `LaserBlast` script to the object of the same name and add the two particle
    systems to the **Particles** list on the script component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add an **Audio Source** component to the object. Select the **Laser**
    sound effect for the **Audio Clip** value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally for this object, expand the **3D Sound Settings** group and select **Linear
    Rolloff** for the **Volume Rolloff** value; otherwise, we will not be able to
    hear it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the laser blast in front of the muzzles of the player's ship. Duplicate
    it as needed to cover all the points. Also, make sure their local z axis points
    forward along the muzzles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, make all of your `LaserBlast` objects children of the player's ship so
    they keep moving with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add the objects to the **Lasers** list on the `TouchShoot` script component.![Time
    for action – adding laser blasts](img/2014OT_08_22.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created laser blasts for the player. Every time the player touches the screen,
    they are triggered. This way the player can tell that they are shooting even if
    they fail to hit anything. It is a quick and short effect, but adds a lot to the
    final experience.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more types of lasers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player can shoot lasers, now the enemy needs to too. Add some laser blasts
    to the enemy ships. Also, it is time to replace their sphere bullets with something
    better. Create a plasma ball to replace the sphere bullets. A smaller, looping
    version of the explosion could work for the ball. An appropriately colored version
    of the engine trails could work for the ball's trail as it flies towards the player.
    It might also be a good idea to add the alarms to the bullets. This way the player
    knows when they are about to be blasted out of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about special effects in Unity, specifically audio
    and particle systems. We started with understanding how Unity handles audio files.
    By adding background music and an alarm system, we put what was learned into practice.
    We moved on to understanding particle systems, and created engine trails for our
    player's ship. Finally, we put the two skill sets together and created explosions
    and laser blasts. Particle systems and audio effects add a lot to the final polish
    and look of a game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we complete our experience together by taking a look at
    optimization in Unity. We will take a look at the tools provided for tracking
    performance. We will also create our own tool to track specific parts of script
    performance. We will also create our own tool to track specific parts of script
    performance. We will explore asset compression and other points that we can change
    to minimize the application footprint. Finally, key points will be discussed for
    minimizing lag.
  prefs: []
  type: TYPE_NORMAL
