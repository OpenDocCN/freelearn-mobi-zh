<html><head></head><body>
        

                            
                    <h1 class="header-title">Spring Modules for Android</h1>
                
            
            
                
<p>This chapter will cover the modules and features that support Spring for Android and use REST in Android as a client. There are some modules that help request and retrieve REST APIs. They also provide security, such as <em>basic authentication</em> and <em>OAuth2</em>. Because of these securities, the resources of the server are secured and are therefore difficult to hack. Even a client needs to be granted permission from the owner to use the resources from the protected server. The modules also incorporate a strong OAuth-based authorization client and implementations for mainstream social websites, such as Google, Twitter, Facebook, and so on.</p>
<p>This chapter covers the following topics: </p>
<ul>
<li>The <kbd>RestTemplate</kbd> module.</li>
<li class="h3">The Gradle and Maven repository</li>
<li class="h3"><kbd>RestTemplate</kbd> module</li>
<li>Retrofit</li>
<li>Creating an Android app</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The Android SDK is required to develop Android applications. The developers used Eclipse and the Android plugin to develop Android applications at the beginning of the Android development. But later, Google announced that Android Studio is the official tool for Android application development. It has all the vital modules, such as Gradle, Maven, Android SDK, NDK, Java JDK, and so on, so we don't have to utilize the Terminal command line. In <a href="bfdcd6b3-5a5a-4fc7-af79-67e780f46ccb.xhtml" target="_blank">Chapter 1</a>, <em>About the Environment</em>, we demonstrated how to download and create a sample Android application using Android Studio.</p>
<p>The source code with an example for this chapter is available on GitHub at the following link: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter04">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter04</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">REST client module</h1>
                
            
            
                
<p><strong>Representational State Transfer</strong> (<strong>REST</strong>) is designed to take advantage of the existing protocols. The consistent systems of REST are often called <strong>RESTful systems</strong>. It can be used over almost every protocol, but it normally takes advantage of HTTP during the use of web APIs. It makes it simpler for systems to speak with one another. These systems are portrayed by how they are stateless and separate the concerns of the client and server. We will go in depth into what these terms mean and why they are advantageous qualities for services on the web.</p>
<p>A RESTful web service is responded to with a payload formatted in either HTML, XML, JSON, or some other format. The response can affirm that a change has been made to the requested response, and the reaction can give hypertext links that are related to other resources, or a bundle of resources. At the point in which HTTP is utilized, as is normal, the tasks that are accessible are <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, and other predefined HTTP functions.</p>
<p>To use Spring for Android, you can use different HTTP libraries. Spring has suggested using <kbd>RestTemplate</kbd> for Android. This is now outdated and may not be supported for the newer Android version. However, now, you can find some libraries that are easier and more powerful, with lots of features. You can use a different HTTP library, such as  one of the following:</p>
<ul>
<li><kbd>RestTemplate</kbd></li>
<li>Retrofit</li>
<li>Volley</li>
</ul>
<p>We will explore the use of all of these libraries in this chapter. In our upcoming chapters, we will use Retrofit because it's easier, updated, robust, and requires less code to be written. However, you can use any of them in your projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The RestTemplate module</h1>
                
            
            
                
<p><kbd>RestTemplate</kbd> is a robust and Java-based REST client. In Android application development, we can use the <kbd>RestTemplate</kbd> module, which will provide a template to request and retrieve a REST API. <kbd>RestTemplate</kbd> is Spring's core class for synchronous client-side HTTP access. It's intended to disentangle correspondence with HTTP servers and authorize RESTful standards.</p>
<p><kbd>RestTemplate</kbd> is the main class for synchronous RESTful HTTP requests. A native Android HTTP client library is used to retrieve requests. The default <strong><kbd>ClientHttpRequestFactory</kbd>, </strong>which is utilized when you make another <kbd>RestTemplate</kbd> example, varies depending on the adaptation of Android on which your application is running.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle and Maven repository</h1>
                
            
            
                
<p>To develop an Android application, we have to implement or compile a few dependencies. Android officially supports Gradle to implement or compile dependencies. Android also supports Maven, so if you want to use Maven, then you need to modify <kbd>pom.xml</kbd>.</p>
<p>You can check the latest version of the dependency at <a href="https://mvnrepository.com/artifact/org.springframework.android/spring-android-core">https://mvnrepository.com/artifact/org.springframework.android/spring-android-core </a>for implementing <kbd>spring-android-core</kbd>, which has the core modules for Android.</p>
<p> You can check the latest version of the dependency at <a href="https://mvnrepository.com/artifact/org.springframework.android/spring-android-rest-template">https://mvnrepository.com/artifact/org.springframework.android/spring-android-rest-template </a>for implementing <kbd>spring-android-rest-template</kbd>, which has the all modules for <kbd>RestTemplate</kbd>.</p>
<p>Now, we will look at the use of Gradle and Maven for the Android project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle</h1>
                
            
            
                
<p>Gradle is a build system that's used to build Android bundles (APK files) by overseeing conditions and giving custom build logic. It is a JVM-based form framework, meaning that you can compose your own content in Java, which Android Studio makes use of.</p>
<p class="mce-root">In Android Studio, Gradle is a custom form apparatus that's used to fabricate Android bundles (APK files) by overseeing dependencies and giving custom form rationale. An APK file (Android application bundle) is an extraordinarily formatted compressed file that contains bytecode, resources (pictures, UI, XML, and so on), and manifest files.</p>
<p>The dependency command of how to implement these dependencies is shown in the following code:</p>
<pre>dependencies {<br/>    // https://mvnrepository.com/artifact/org.springframework.android/spring-android-rest-template<br/><strong>     implementation 'org.springframework.android:spring-android-rest-template:2.0.0.M3'<br/><br/></strong>// https://mvnrepository.com/artifact/org.springframework.android/spring-android-core<br/><strong>    implementation 'org.springframework.android:spring-android-core:2.0.0.M3'</strong><br/>}<br/><br/>repositories {<br/>    maven {<br/>        url 'https://repo.spring.io/libs-snapshot'<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Maven</h1>
                
            
            
                
<p>The Android Maven module is used to build applications for the Android OS and assemble libraries. These are to be used to create the <strong>Android Archive Library</strong> (<strong>AAR</strong>) and the inheritance APKLIB format, thus utilizing Apache Maven.</p>
<p class="CDPAlignLeft CDPAlign">Here is a code sample of how to add a dependency of Android in <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependencies&gt;<br/>    &lt;!-- https://mvnrepository.com/artifact/org.springframework.android/spring-android-rest-template --&gt;<br/><strong>    &lt;dependency&gt;</strong><br/><strong>        &lt;groupId&gt;org.springframework.android&lt;/groupId&gt;</strong><br/><strong>        &lt;artifactId&gt;spring-android-rest-template&lt;/artifactId&gt;</strong><br/><strong>        &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt;</strong><br/><strong>    &lt;/dependency&gt;<br/><br/></strong>&lt;!-- https://mvnrepository.com/artifact/org.springframework.android/spring-android-core --&gt;<br/><strong>     &lt;dependency&gt;<br/>         &lt;groupId&gt;org.springframework.android&lt;/groupId&gt;<br/>         &lt;artifactId&gt;spring-android-core&lt;/artifactId&gt;<br/>         &lt;version&gt;1.0.1.RELEASE&lt;/version&gt;<br/>     &lt;/dependency&gt;</strong><br/>&lt;/dependencies&gt;<br/>&lt;repositories&gt;<br/>    &lt;repository&gt;<br/>        &lt;id&gt;spring-snapshots&lt;/id&gt;<br/>        &lt;name&gt;Spring Snapshots&lt;/name&gt;<br/>        &lt;url&gt;https://repo.spring.io/libs-snapshot&lt;/url&gt;<br/>        &lt;snapshots&gt;<br/>            &lt;enabled&gt;true&lt;/enabled&gt;<br/>        &lt;/snapshots&gt;<br/>    &lt;/repository&gt;<br/>&lt;/repositories&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">RestTemplate constructors</h1>
                
            
            
                
<p>The four <kbd>RestTemplate</kbd> constructors are listed in the following code:</p>
<pre>RestTemplate();<br/>RestTemplate(<strong>boolean includeDefaultConverters</strong>);<br/>RestTemplate(<strong>ClientHttpRequestFactory requestFactory</strong>);<br/>RestTemplate(<strong>boolean includeDefaultConverters, ClientHttpRequestFactory requestFactory</strong>);</pre>
<p>This constructor has no parameter, by default. If you want to use a default set of message converters with another <kbd>RestTemplate</kbd> example, you can pass <kbd>TRUE</kbd> as a parameter. If you want to use another <kbd>ClientHttpRequestFactory</kbd>, then you need to pass it as a parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RestTemplate functions</h1>
                
            
            
                
<p><kbd>RestTemplate</kbd> gives a larger amount of functions. It has six primary HTTP functions, which makes it simple to conjure numerous RESTful services and authorize REST best practices. <kbd>RestTemplate</kbd>'s strategy name pursues a naming tradition; the initial segment demonstrates what the HTTP strategy is and the second part shows what will be returned. There is an interface called <kbd>ResponseErrorHandler</kbd> in  <kbd>RestTemplate</kbd> which is used to determine whether a particular response has an error or not. Here are the descriptions of the six HTTP functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP GET</h1>
                
            
            
                
<p>HTTP characterizes an arrangement of request functions to demonstrate the coveted activity to be performed for a given resource. The <kbd>GET</kbd> function requests a description of the predetermined resource and requests that utilizing <kbd>GET</kbd> should just retrieve data. <kbd>GET</kbd> is a standout among the most well-known HTTP functions.</p>
<p>Here are the common functions of HTTP <kbd>GET</kbd>:</p>
<pre><strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; getForObject(url: String, responseType: Class&lt;T&gt;, vararg urlVariables: Any): T<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; getForObject(url: String, responseType: Class&lt;T&gt;, urlVariables: Map&lt;String, *&gt;): T<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; getForObject(url: URI, responseType: Class&lt;T&gt;): T<br/><br/>fun &lt;T&gt; getForEntity(url: String, responseType: Class&lt;T&gt;, vararg urlVariables: Any): ResponseEntity&lt;T&gt;<br/><br/>fun &lt;T&gt; getForEntity(url: String, responseType: Class&lt;T&gt;, urlVariables: Map&lt;String, *&gt;): ResponseEntity&lt;T&gt;<br/><br/>
<strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; getForEntity(url: URI, responseType: Class&lt;T&gt;): ResponseEntity&lt;T&gt;</pre>
<p>Here is an example of how to call these functions:</p>
<pre><br/>val restTemplate = RestTemplate()<br/><br/>val baseUrl: String ?= "YOUR_URL" // API URL as String<br/>val response = restTemplate.getForEntity(baseUrl, String::class.java)<br/><br/>val uri = URI(baseUrl) // API URL as URL format<br/>val responseURI = restTemplate.getForEntity(uri, String::class.java)Auth Module</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP POST</h1>
                
            
            
                
<p>HTTP <kbd>POST</kbd> requests that the asset at the URI accomplishes something with the given substance. <kbd>POST</kbd> is often utilized to make another substance; however, it can likewise be utilized to refresh an element.</p>
<p>Here are the common functions of HTTP <kbd>POST</kbd>:</p>
<pre><strong>@Throws(RestClientException::class)</strong><br/>fun postForLocation(url: String, request: Any, vararg urlVariables: Any): URI<br/><br/>fun postForLocation(url: String, request: Any, urlVariables: Map&lt;String, *&gt;): URI<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun postForLocation(url: URI, request: Any): URI<br/><br/>fun &lt;T&gt; postForObject(url: String, request: Any, responseType: Class&lt;T&gt;, vararg uriVariables: Any): T<br/><br/>fun &lt;T&gt; postForObject(url: String, request: Any, responseType: Class&lt;T&gt;, uriVariables: Map&lt;String, *&gt;): T<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; postForObject(url: URI, request: Any, responseType: Class&lt;T&gt;): T<br/><br/>fun &lt;T&gt; postForEntity(url: String, request: Any, responseType: Class&lt;T&gt;, vararg uriVariables: Any): ResponseEntity&lt;T&gt;<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; postForEntity(url: String, request: Any, responseType: Class&lt;T&gt;, uriVariables: Map&lt;String, *&gt;): ResponseEntity&lt;T&gt;<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun &lt;T&gt; postForEntity(url: URI, request: Any, responseType: Class&lt;T&gt;): ResponseEntity&lt;T&gt;</pre>
<p>Here is an example of how to call these functions:</p>
<pre>/** POST **/<br/><br/>val restTemplate = RestTemplate()<br/><br/>val baseUrl: String ?= "YOUR_URL"<br/>val uri = URI(baseUrl)<br/>val body = "The Body"<br/><br/>val response = restTemplate.postForEntity(baseUrl, body, String::class.java)<br/><br/>val request = HttpEntity(body)<br/>val responseExchange = restTemplate.exchange(baseUrl, HttpMethod.POST, request, String::class.java)<br/><br/>val responseURI = restTemplate.postForEntity(uri, body, String::class.java)<br/>val responseExchangeURI = restTemplate.exchange(uri, HttpMethod.POST, request, String::class.java)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP PUT</h1>
                
            
            
                
<p>To store an element at a URI, the <kbd>PUT</kbd> function can create a new element or update a current one. A <kbd>PUT</kbd> request is idempotent. Idempotency is the fundamental contrast between the desires for <kbd>PUT</kbd> versus a <kbd>POST</kbd> request.</p>
<p>Here are the common functions of HTTP <kbd>PUT</kbd>:</p>
<pre class="mce-root">Here are the common functions -<br/><strong>@Throws(RestClientException::class)</strong><br/>fun put(url: String, request: Any, vararg urlVariables: Any)<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun put(url: String, request: Any, urlVariables: Map&lt;String, *&gt;)<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun put(url: String, request: Any, urlVariables: Map&lt;String, *&gt;)</pre>
<p class="mce-root"/>
<p>Here is an example of how to call the functions of HTTP <kbd>PUT</kbd>:</p>
<pre>val baseUrl: String ?= "YOUR_URL"<br/>val restTemplate = RestTemplate()<br/>val uri = URI(baseUrl)<br/><br/>val body = "The Body"<br/><br/>restTemplate.put(baseUrl, body)<br/>restTemplate.put(uri, body)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP DELETE</h1>
                
            
            
                
<p>HTTP <kbd>DELETE</kbd> is a request function that is used to remove a resource. However, the resource does not have to be removed immediately. <kbd>DELETE</kbd> could be an asynchronous or long-running request.</p>
<p>Here are the common functions of HTTP <kbd>DELETE</kbd>:</p>
<pre><strong>@Throws(RestClientException::class)</strong><br/>fun delete(url: String, vararg urlVariables: Any)<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun delete(url: String, urlVariables: Map&lt;String, *&gt;)<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun delete(url: URI) </pre>
<p>Here is an example of how to call these functions:</p>
<pre>val baseUrl: String ?= "YOUR_URL"<br/>val restTemplate = RestTemplate()<br/>val uri = URI(baseUrl)<br/><br/>restTemplate.delete(baseUrl)<br/>restTemplate.delete(uri)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP OPTIONS</h1>
                
            
            
                
<p>The HTTP <kbd>OPTIONS</kbd> function is utilized to depict the correspondence options for the target resource. The client can indicate a URL for the <kbd>OPTIONS</kbd> method, or a reference mark, <kbd>(*)</kbd>, to allude to the whole server.</p>
<p>Here are the common functions of HTTP <kbd>OPTIONS</kbd>:</p>
<pre><strong>@Throws(RestClientException::class)</strong><br/>fun optionsForAllow(url: String, vararg urlVariables: Any): Set&lt;HttpMethod&gt;<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun optionsForAllow(url: String, urlVariables: Map&lt;String, *&gt;): Set&lt;HttpMethod&gt;<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun optionsForAllow(url: URI): Set&lt;HttpMethod&gt;</pre>
<p>Here is an example of how to call the functions:</p>
<pre>val baseUrl: String ?= "YOUR_URL"<br/>val restTemplate = RestTemplate()<br/>val allowHeaders = restTemplate.optionsForAllow(baseUrl)<br/><br/>val uri = URI(baseUrl)<br/>val allowHeadersURI = restTemplate.optionsForAllow(uri)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP HEAD</h1>
                
            
            
                
<p>In the current version of Spring (4.3.10), <kbd>HEAD</kbd> is automatically supported.</p>
<p><kbd>@RequestMapping</kbd> functions mapped to <kbd>GET</kbd> are also implicitly mapped to <kbd>HEAD</kbd>, meaning that there is no need to have <kbd>HEAD</kbd> explicitly declared. An HTTP <kbd>HEAD</kbd> request is processed as if it were an HTTP <kbd>GET</kbd>, but instead of writing the body, only the number of bytes is counted, as well as the Content-Length header set.</p>
<p>Here are the common functions of HTTP <kbd>HEAD</kbd>:</p>
<pre><strong>@Throws(RestClientException::class)</strong><br/>fun headForHeaders(url: String, vararg urlVariables: Any): HttpHeaders<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun headForHeaders(url: String, urlVariables: Map&lt;String, *&gt;): HttpHeaders<br/><br/><strong>@Throws(RestClientException::class)</strong><br/>fun headForHeaders(url: URI): HttpHeaders</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrofit</h1>
                
            
            
                
<p><strong>Retrofit</strong> is a library that makes parsing an API reaction simple and better for utilization in the application. Retrofit is a REST client for Java and Android that makes it moderately simple to recover and transfer JSON by means of a REST-based web service. In Retrofit, you can arrange which converter is utilized for the information serialization. Normally, for JSON, you utilize Gson, but you can add custom converters to process XML or different conventions. Retrofit utilizes the <kbd>OkHttp</kbd> library for HTTP requests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The use of Retrofit</h1>
                
            
            
                
<p>To work with Retrofit, you will require the following three classes:</p>
<ul>
<li>A model class, which is utilized as a JSON model</li>
<li class="mce-root">Interfaces that characterize the conceivable HTTP activities</li>
<li class="mce-root"> The <kbd>Retrofit.Builder</kbd> class, which utilizes the interface and the developer programming interface to permit characterizing the URL endpoint for HTTP activities.</li>
</ul>
<p>Each function of an interface speaks to one conceivable programming interface call. It must have an HTTP annotation (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>DELETE</kbd>, and so on) to determine the request type and the relative URL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages of Retrofit</h1>
                
            
            
                
<p class="mce-root">Retrofit is very easy to utilize. It basically gives you a chance to regard programming interface calls as straightforward Java method calls, so you just characterize which URLs to hit and the request/reaction parameters as Java classes.</p>
<p class="mce-root">The whole system call, plus JSON/XML parsing, is totally taken care of by Retrofit (with assistance from Gson for JSON parsing), alongside support for self-assertive formats with pluggable serialization/deserialization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Retrofit</h1>
                
            
            
                
<p>Of course, Retrofit can just deserialize HTTP bodies into <kbd>OkHttp</kbd>'s <kbd>ResponseBody</kbd> type and it can acknowledge its <kbd>RequestBody</kbd> type for <kbd>@Body</kbd>.</p>
<p class="mce-root">Converters can be added in order to support different sorts. Seven kinds of modules adjust mainstream serialization libraries for your benefit. These include the following libraries:</p>
<ul>
<li><strong>Gson</strong>: <kbd>com.squareup.retrofit2:converter-gson</kbd></li>
<li><strong>Jackson</strong>: <kbd>com.squareup.retrofit2:converter-jackson</kbd></li>
<li><strong>Moshi</strong>: <kbd>com.squareup.retrofit2:converter-moshi</kbd></li>
<li><strong>Protobuf</strong>: <kbd>com.squareup.retrofit2:converter-protobuf</kbd></li>
<li><strong>Wire</strong>: <kbd>com.squareup.retrofit2:converter-wire</kbd></li>
<li><strong>Simple XML</strong>: <kbd>com.squareup.retrofit2:converter-simplexml</kbd></li>
<li><strong>Scalars (primitives, boxed, and String)</strong>: <kbd>com.squareup.retrofit2:converter-scalars</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Downloading Retrofit</h1>
                
            
            
                
<p>Download the latest JAR from <a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&amp;a=retrofit&amp;v=LATEST">https://search.maven.org/remote_content?g=com.squareup.retrofit2&amp;a=retrofit&amp;v=LATEST</a>.<a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&amp;a=retrofit&amp;v=LATEST"/></p>
<p>Alternatively, you can inject the dependency via Maven with the following code:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;<br/>    &lt;artifactId&gt;retrofit&lt;/artifactId&gt;<br/>    &lt;version&gt;2.4.0&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>Alternatively, you can use Gradle, as per the following code:</p>
<pre>implementation 'com.squareup.retrofit2:retrofit:2.4.0'<br/>implementation 'com.squareup.retrofit2:converter-gson:2.3.0'<br/>compile 'com.jakewharton.picasso:picasso2-okhttp3-downloader:1.1.0'<br/><br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP request functions</h1>
                
            
            
                
<p>Each function must have an HTTP annotation that gives the request function and relative URL. There are five built-in annotations—<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, and <kbd>HEAD</kbd>. The overall URL of the asset is indicated in the annotation.</p>
<p>Let's take a look at the use of these annotations. We are considering all the URLs based on GitHub API v3 (<a href="https://developer.github.com/v3/">https://developer.github.com/v3/</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">GET</h1>
                
            
            
                
<p>Let's assume that you want to get a response to your details from your GitHub account. You need to use the following endpoint with the <kbd>@GET</kbd> function to get the user's info:</p>
<pre><strong>@GET("group/{id}/users")<br/></strong>Call&lt;List&lt;Users&gt;&gt; groupList(<strong>@Path("id")</strong> int id);</pre>
<p>Let's assume that you want to create a new repo in your GitHub account. Here, you need to use the following endpoint with the <kbd>@POST</kbd> function:</p>
<pre><strong>@POST("user/repos")</strong><br/>fun createRepo(<strong>@Body</strong> repo:Repository, <br/>               <strong>@Header("Authorization")</strong> accessToken: String,<br/>               <strong>@Header("Accept")</strong> apiVersionSpec: String,<br/>               <strong>@Header("Content-Type")</strong> contentType: String): Call&lt;Repository&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">PUT</h1>
                
            
            
                
<p>Let's assume that you want to update a GitHub <kbd>Gist</kbd> object. You need to use the following endpoint with the <kbd>@PUT</kbd> function:</p>
<pre><strong>@PUT("gists/{id}")</strong><br/>fun updateGist(<strong>@Path("id")</strong> id: String, <br/>               <strong>@Body </strong>gist: Gist): Call&lt;ResponseBody&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">DELETE</h1>
                
            
            
                
<p>Let's assume that you want to delete a repository from your GitHub account. In this case, you need to use the following endpoint with the <kbd>@DELETE</kbd> function:</p>
<pre><strong>@DELETE("repos/{owner}/{repo}")</strong><br/>    fun deleteRepo(<strong>@Header("Authorization")</strong> accessToken: String,<br/><strong>                   @Header("Accept")</strong> apiVersionSpec: String,<br/><strong>                   @Path("repo")</strong> repo: String,<br/><strong>                   @Path("owner")</strong> owner: String): Call&lt;DeleteRepos&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HEAD</h1>
                
            
            
                
<p>A request header can be refreshed progressively using the <kbd>@Header</kbd> annotation. If the value is invalid, the header will be overlooked:</p>
<pre class="prettyprint prettyprinted">// example one<br/>@GET("user")
Call&lt;User&gt; getUser(<strong>@Header("Authorization")</strong> String authorization)<br/><br/>// example two<br/><strong>@Headers("Accept: application/vnd.github.v3.full+json", "User-Agent: Spring for Android")</strong><br/>@GET("users/{username}")<br/>fun getUser(@Path("username") username: String): Call&lt;Users&gt;<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Android app</h1>
                
            
            
                
<p>Let's create a simple Android app as a client that will retrieve the REST API using the GitHub API. First of all, we need to create an app from Android Studio and put down our project and the company domain. Don't forget to check <strong>Include Kotlin support</strong>. It will include all of the support of Kotlin. The following screenshot shows the <strong>Create Android Project</strong> window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7bcaa137-45c0-45c7-bc1b-d99aec15152a.png" style="width:43.67em;height:31.58em;"/></p>
<p>Then, select the minimum API version from the <strong>Phone and Tablet</strong> option. There is no need to add other options for this project. After clicking Next, in the <strong>Add an Activity to Mobile </strong>section, you can select <strong>Empty Activity</strong> and then, after renaming the <strong>Activity Name</strong> and layout, click Finish. After the build, you will be ready to start creating an Android app.</p>
<p>The final files of this project are shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6edfddbb-1421-48a1-b5b1-bf25f815c0c2.png" style="width:21.08em;height:40.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle information</h1>
                
            
            
                
<p>Here are the details of my Android Studio's Gradle file:</p>
<pre>buildscript {<br/><strong>    ext.kotlin_version = '1.3.10'<br/></strong>    repositories {<br/>        google()<br/>        jcenter()<br/>    }<br/>    dependencies {<br/>        <strong>classpath 'com.android.tools.build:gradle:3.2.1'<br/>        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version</strong><strong>"</strong><br/><br/>        // NOTE: Do not place your application dependencies here; they belong<br/>        // in the individual module build.gradle files<br/>    }<br/>}<br/><br/>allprojects {<br/>    repositories {<br/>        google()<br/>        jcenter()<br/>    }<br/>}<br/><br/>task clean(type: Delete) {<br/>    delete rootProject.buildDir<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle dependencies</h1>
                
            
            
                
<p>We will use Retrofit and its features, so we need to implement all the dependencies, as shown in the following code:</p>
<pre>    implementation 'com.squareup.retrofit2:retrofit:2.4.0'<br/>    implementation 'com.squareup.retrofit2:converter-gson:2.4.0'<br/><br/>    implementation 'com.squareup.retrofit2:retrofit-converters:2.5.0'<br/>    implementation 'com.squareup.retrofit2:retrofit-adapters:2.5.0'<br/>    implementation 'com.squareup.okhttp3:logging-interceptor:3.12.0'<br/>    implementation 'com.google.code.gson:gson:2.8.5'</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a model</h1>
                
            
            
                
<p>We will use the GitHub API. You can check all the REST API URLs at <a href="https://api.github.com/">https://api.github.com/</a>. We will use the simplest API, which has no security issues. We will show the list of a user's repositories. The API is <a href="https://api.github.com/users/%7Buser%7D/repos">https://api.github.com/users/{user}/repos</a>. You need a <kbd>GET</kbd> HTTP function with a username parameter.</p>
<p>The following screenshot shows the output of the REST API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2e4a3efe-9a90-438e-a6ff-3ebbcf9017b4.png"/></p>
<p>The left-hand side of the preceding screenshot shows part of the content of a repo and the right-hand side is the collapsed total repo list.</p>
<p class="mce-root"/>
<p>So, according to the API, we will create a user model for the client side. Here is the model class named <kbd>GitHubUserModel.kt</kbd>, where we will show only the name of the list of all the repos:</p>
<pre>class GitHubUserModel {<br/><strong>    val name: String? = null<br/></strong>}</pre>
<p>Create an interface that will have the HTTP request functions. In this project, we will only use a <kbd>GET</kbd> function that retrieves all the details of the users. Here, we are using the <kbd>GET</kbd> Retrofit annotation to encode details about the parameters and the request function. For this function, our endpoint is <kbd>/users/{user}/repos</kbd>, where you need to add a parameter of the <kbd>userName</kbd> and it will provide a list of <kbd>UserModel</kbd>. </p>
<p>Here is the code of the <kbd>GithubService</kbd> interface:</p>
<pre>interface GithubService {<br/><strong>    @GET("/users/{user}/repos")</strong><br/>    fun reposOfUser(<strong>@Path("user") user: String</strong>): Call&lt;List&lt;GitHubUserModel&gt;&gt;<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a service</h1>
                
            
            
                
<p>This class is responsible for the main task. It will be responsive for the control of all the tasks using the <kbd>Retrofit.builder</kbd> class and will configure it with the base of the given URL.   </p>
<p>Here is the code of <strong><kbd>UserServiceImpl.kt</kbd>: </strong></p>
<pre>class GithubServiceImpl{<br/>   fun getGithubServiceFactory(): GithubService {<br/>        val retrofit = Retrofit.Builder()<br/>                .baseUrl("https://api.github.com/")<br/>                .addConverterFactory(GsonConverterFactory.create())<br/>                .build()<br/>        return retrofit.create(GithubService::class.java)<br/>    }<br/>}</pre>
<p>Here, our <kbd>baseUrl()</kbd> is <kbd>https://api.github.com/</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling callback</h1>
                
            
            
                
<p>Here, we are calling <kbd>CallBack&lt;&gt;</kbd> from the <kbd>MainActivity</kbd>. This callback will have the response of the REST API request.</p>
<p>Let's check the <kbd>MainActivity.kt</kbd> code:</p>
<pre>class MainActivity : AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/><br/>        val githubService: GithubService = GithubServiceImpl().getGithubServiceFactory()<br/><br/>        val call: Call&lt;List&lt;GitHubUserModel&gt;&gt; = githubService.reposOfUser(<strong>"sunnat629"</strong>)<br/>        call.enqueue(object: Callback&lt;List&lt;GitHubUserModel&gt;&gt;{<br/>            override fun onFailure(call: Call&lt;List&lt;GitHubUserModel&gt;&gt;, t: Throwable) {<br/>                Log.wtf("PACKTPUB", t.message)<br/>            }<br/><br/>            override fun onResponse(call: Call&lt;List&lt;GitHubUserModel&gt;&gt;, response: Response&lt;List&lt;GitHubUserModel&gt;&gt;) {<br/>                val listItems = arrayOfNulls&lt;String&gt;( response.body()!!.size)<br/>                for (i in 0 until response.body()!!.size) {<br/>                    val recipe = response.body()!![i]<br/>                    listItems[i] = recipe.name<br/>                }<br/>                val adapter = ArrayAdapter&lt;String&gt;(this@MainActivity, android.R.layout.simple_list_item_1, listItems)<br/>                displayList.adapter = adapter<br/>            }<br/>        })<br/>    }<br/>}</pre>
<p>First of all, we need to initialize <kbd>GithubServiceImpl().getGithubServiceImpl(username,password)</kbd> so that we can call  <kbd>reposOfUser()</kbd> from  <kbd>UserService</kbd>. Here, I add my GitHub username in the parameter. Then, we will call <kbd>enqueue(retrofit2.Callback&lt;T&gt;)</kbd>, which will be executed asynchronously and send the request and get the response. It has two functions—<kbd>onResponse()</kbd> and <kbd>onFailure()</kbd>. If there is any server-related error, then it will call <kbd>onFailure()</kbd>, and if it gets the response and the resources, it will call <kbd>onResponse()</kbd>. We can use the resources of the <kbd>onResponse()</kbd> function for this.</p>
<p>Here, we will get a response of the <kbd>UserModel</kbd> list. So, we can use this list to show our REST output in our application UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an interface</h1>
                
            
            
                
<p>We will show a list of the user's details and the names of all the repos. Here, we will use <kbd>ListView.</kbd></p>
<p>Here is the code of the <kbd>acitivity_main.xml</kbd> file:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;<br/><br/>    &lt;ListView<br/>        android:id="@+id/displayList"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintLeft_toLeftOf="parent"<br/>        app:layout_constraintRight_toRightOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>We will use this <kbd>listview</kbd> in the <kbd>onResponse()</kbd> function of <kbd>MainActivity</kbd>. </p>
<p>We will get the list and create a custom adapter to show the user list, as shown in the following code:</p>
<pre>val listItems = arrayOfNulls&lt;String&gt;( response.body()!!.size)<br/>for (i in 0 until response.body()!!.size) {<br/>    val recipe = response.body()!![i]<br/>    listItems[i] = recipe.name<br/>}<br/><strong>val adapter = ArrayAdapter&lt;String&gt;(this@MainActivity, android.R.layout.simple_list_item_1, listItems)</strong><br/>displayList.adapter = adapter</pre>
<p>Here, we get the list of repos and convert them into an array. Then, we create the native adapter for the list with <kbd>val adapter = ArrayAdapter&lt;String&gt;(this@MainActivity, android.R.layout.simple_list_item_1, listItems)</kbd> and set the adapter in our list with <kbd>displayList.adapter = adapter</kbd>.</p>
<p> </p>
<p>You should never perform long-running tasks on the main thread. It will incur an <strong>Application Not Responding</strong> (<strong>ANR</strong>) message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mobile applications</h1>
                
            
            
                
<p>So, after everything, run your server. Then, run your app. The following screenshot shows the output of our app:</p>
<div><img src="img/8ffb7df1-9c5d-4f8a-9556-88a7c0c99056.png" style="width:19.75em;height:35.83em;"/></div>
<p> You can modify this as you wish, although you have to be careful about the endpoint and the model.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we have given a quick presentation of the ideas driving REST and the REST client modules. The RESTful HTTP way of dealing with uncovering functionality is unique. We have seen the different libraries of REST client functions. First, we saw what RestTemplate is and its implementation in an Android application. Now, we know about the constructors of RestTemplate and its functionalities. Furthermore, we have learned about Retrofit, allowing us to actualize Retrofit in an Android application. We have also seen the utilization of its functionalities. Lastly, we look at how to implement Retrofit to get data from a REST API.</p>
<p class="mce-root">In the following chapters, we will develop a total project, including security, authorization/authentication, a database, and a custom REST API, with the Spring and Android application to deal with the API as a client. In these chapters, you will explore the full usage of the API and prepare to figure out how to make an API for a server and recover it from the client. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the difference between REST and RESTful?</li>
<li>What is the architectural style for creating a web API?</li>
<li>What tools are required to test your web API?</li>
<li>What are RESTful web services?</li>
<li>What is a URI? What is the purpose of a URI in REST-based web services?</li>
<li>What does the HTTP Status Code <kbd>200</kbd> state? </li>
<li>What does the HTTP Status Code <kbd>404</kbd> state?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Hands-On RESTful API Design Patterns and Best Practices</em> (<a href="https://www.packtpub.com/application-development/hands-restful-api-design-patterns-and-best-practices">https://www.packtpub.com/application-development/hands-restful-api-design-patterns-and-best-practices</a>), by Pethuru Raj, Anupama Raman, and Harihara Subramanian</li>
<li><em>Building a RESTful Web Service with Spring</em> (<a href="https://www.packtpub.com/web-development/building-restful-web-service-spring">https://www.packtpub.com/web-development/building-restful-web-service-spring</a>), by Ludovic Dewailly</li>
</ul>


            

            
        
    </body></html>