- en: Chapter 2. Scenes in Sprite Kit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. Sprite Kit 中的场景
- en: The *Hello World* game, made in the previous chapter. was the first step to
    Sprite Kit. We also made acquaintance with the Swift programming language, which
    we are going to use for iOS game development using Sprite Kit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中制作的 *Hello World* 游戏是 Sprite Kit 的第一步。我们还认识了 Swift 编程语言，这是我们使用 Sprite Kit
    进行 iOS 游戏开发将要使用的语言。
- en: In this chapter, we will dive deep into various fundamentals of the Sprite Kit
    project and also discuss in depth about scenes in a game. We are further going
    to continue the development of the game, *Platformer*, and use it as a tool to
    learn Sprite Kit. We will be learning about different auto generated files in
    an Xcode project and about their importance. Only then will we be able to understand
    what scenes are, and their importance in game development. Further we will also
    learn how nodes play an important part in Sprite Kit and help us to improve optimization
    and control of our game. In this chapter, we will also learn how to add more than
    one scene in our game and successfully transit from one scene to another along
    with animating various transition effects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Sprite Kit 项目的各种基础，并深入讨论游戏中的场景。我们还将继续开发游戏 *Platformer*，并使用它作为学习
    Sprite Kit 的工具。我们将学习 Xcode 项目中的不同自动生成文件及其重要性。只有这样，我们才能理解场景是什么，以及它们在游戏开发中的重要性。进一步地，我们还将学习节点如何在
    Sprite Kit 中发挥重要作用，帮助我们提高游戏优化和控制。在本章中，我们还将学习如何在游戏中添加多个场景，并成功从一个场景过渡到另一个场景，同时动画各种过渡效果。
- en: We will be learning all of this and testing our progress with development of
    the game *Platformer*, so that by the end of the book, you are able make your
    own 2D game from scratch. Let's get going!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习所有这些内容，并通过游戏 *Platformer* 的开发来测试我们的进度，以便在本书结束时，你能够从头开始制作自己的 2D 游戏。让我们开始吧！
- en: Device orientation in Sprite Kit
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sprite Kit 中的设备方向
- en: 'There are two types of modes, namely portrait and landscape; you can select
    the desired orientation for your game while setting up your project. Any time
    during the development of your game, you can change the orientation under the
    properties section of your Sprite Kit project. There are four types of orientations
    available:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种模式，即竖屏和横屏；在设置项目时，你可以选择你游戏的所需方向。在游戏开发过程中，你可以在 Sprite Kit 项目的属性部分随时更改方向。有四种方向可供选择：
- en: Portrait
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖屏
- en: Upside Down
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下颠倒
- en: Landscape Left
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横屏左
- en: Landscape Right
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横屏右
- en: You can select any of the orientations depending on your game. If you want to
    make your game scene in portrait mode, you can select either **Portrait** or **Upside
    Down** options. If want to make your game in landscape mode, you can select the
    **Landscape Left** or **Landscape Right** option. If you want to make your game
    in both portrait and landscape, then you can select both the options too. Caution,
    if you want to make your game in both portrait and landscape mode, make sure that
    you have to handle the positions of sprites in your game during runtime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据你的游戏选择任何方向。如果你想制作竖屏模式的游戏场景，你可以选择 **竖屏** 或 **上下颠倒** 选项。如果你想制作横屏模式的游戏，你可以选择
    **横屏左** 或 **横屏右** 选项。如果你想制作同时支持竖屏和横屏的游戏，你也可以选择这两个选项。注意，如果你想制作同时支持竖屏和横屏模式的游戏，确保你在运行时处理游戏中精灵的位置。
- en: Orientation in our project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们项目中的方向
- en: 'As we are making a *Platformer* game, it''s better to opt for landscape mode.
    Although you can select both **Landscape Left** and **Landscape Right**, it is
    better to opt for one orientation for easier programming. Following are the steps
    to do the same:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在制作 *Platformer* 游戏，选择横屏模式会更好。虽然你可以选择 **横屏左** 和 **横屏右**，但选择一个方向进行编程会更简单。以下是将相同方向设置的步骤：
- en: Launch the `Platformer` project that we made in the last chapter, either by
    double-clicking `Platformer.xcodeproj` from the directory of project, or from
    your Xcode.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动我们在上一章制作的 `Platformer` 项目，可以通过双击项目目录中的 `Platformer.xcodeproj`，或者从你的 Xcode
    中启动。
- en: Click on the **Project Navigator** and then click **Platformer**, which is just
    under it, on the left panel.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **项目导航器**，然后点击左侧面板中位于其下的 **Platformer**。
- en: Untick the **Portrait** checkbox and tick **Landscape Left** under the **Device
    Orientation** section:![Orientation in our project](img/B04201_02_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选 **竖屏** 复选框，并在 **设备方向** 部分勾选 **横屏左**：![我们项目中的方向](img/B04201_02_01.jpg)
- en: Revisiting project elements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾项目元素
- en: Now we are going to discuss about some auto-generated files in your Sprite Kit
    project. They can be found on the left panel in your Xcode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论您 Sprite Kit 项目中的一些自动生成文件。它们可以在 Xcode 的左侧面板中找到。
- en: AppDelegate.swift
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppDelegate.swift
- en: This file is an entry point file to our game. Its existence is crucial when
    the game goes from an active state to inactive state (or background state), in
    simple terms, when there are some sorts of temporary interruptions (such as incoming
    phone calls or SMS messages), or when the user force quits the application. The
    essence of this file in a project comes when you have to perform any specific
    task between the transition of active and inactive states, such as saving game
    data when the game is moving into a background state due to a phone call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是进入我们游戏的入口文件。当游戏从活动状态变为非活动状态（或后台状态），简单来说，当出现某些临时中断（如来电或短信消息）或用户强制退出应用程序时，其存在至关重要。此文件在项目中的本质在于，当您需要在活动和非活动状态之间执行任何特定任务时，例如，当游戏因电话而进入后台状态时保存游戏数据。
- en: GameScene.sks
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameScene.sks
- en: This file is a static archive of your scene's content. This file presents a
    view in your editor, it is used to save static content of a game such as spawning
    the position of a player, level ending position, and so on. The main essence and
    importance of this file is that it has worked towards helping you to separate
    the dynamic and static part of a game. Now a developer does not need to write
    extra lines of code for specifying trivial elements of a game such as spawning
    position, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是场景内容的静态存档。此文件在编辑器中显示一个视图，用于保存游戏静态内容，如玩家的生成位置、关卡结束位置等。此文件的主要本质和重要性在于，它有助于您将游戏的动态部分和静态部分分开。现在，开发者不需要编写额外的代码来指定游戏中的琐碎元素，如生成位置等。
- en: GameScene.swift
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameScene.swift
- en: This file contains the `GameScene` class which is a type of `SKScene`. An `SKScene`
    class object is used to make a scene in a game. When we developed the "Hello World"
    sample game in the previous chapter, the logic part was present inside this file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含 `GameScene` 类，它是一种 `SKScene` 类型。`SKScene` 类对象用于在游戏中创建场景。当我们在前一章中开发 "Hello
    World" 示例游戏时，逻辑部分就在此文件中。
- en: GameViewController.swift
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameViewController.swift
- en: When a game starts, a default view is added to the game, which is controlled
    by the game view controller. If the user wants to add scenes to the game, then
    it is added on top of the view.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，会向游戏中添加一个默认视图，该视图由游戏视图控制器控制。如果用户想要向游戏中添加场景，则它将添加到视图之上。
- en: Main.storyboard
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Main.storyboard
- en: This is responsible for displaying content on the screen. A storyboard with
    a view controller whose view is set to `SKView` is created, the scene then displays
    the content of the Sprite Kit game. You can create additional view controllers
    and storyboards along with applying transition between them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这负责在屏幕上显示内容。创建了一个具有 `SKView` 视图的视图控制器的故事板，场景随后显示 Sprite Kit 游戏的内容。您可以在它们之间应用转换的同时创建额外的视图控制器和故事板。
- en: LaunchScreen.xib
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LaunchScreen.xib
- en: New projects are created with this launch screen file. The Launch Screen uses
    size classes to adapt to different screen sizes and orientations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目使用此启动屏幕文件创建。启动屏幕使用大小类来适应不同的屏幕尺寸和方向。
- en: Adjusting the project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整项目
- en: 'We are going to make some adjustments in the already-created project called
    `Platformer`. Please follow the steps listed, in order to customize the project
    according to our needs:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对已创建的项目 `Platformer` 进行一些调整。请按照以下步骤操作，以根据我们的需求定制项目：
- en: Delete the `GameScene.swift` and `GameScene.sks` files present in your project.
    We will be recreating these files as per our need. Don't worry about the error,
    we are going to fix it in the next step. `GameScene.swift` is the default scene
    given by Xcode; we are deleting the default ones as we are going to create the
    menu Scene before the game scene. Take a look at the next screenshot:![Adjusting
    the project](img/B04201_02_02.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除项目中现有的 `GameScene.swift` 和 `GameScene.sks` 文件。我们将根据需要重新创建这些文件。不用担心错误，我们将在下一步中修复它。`GameScene.swift`
    是 Xcode 提供的默认场景；我们正在删除默认场景，因为我们将在游戏场景之前创建菜单场景。请看下一张截图：![调整项目](img/B04201_02_02.jpg)
- en: Open `GameViewController.swift` and delete the code, as shown in the following
    screenshot:![Adjusting the project](img/B04201_02_03.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameViewController.swift` 文件并删除代码，如图所示：![调整项目](img/B04201_02_03.jpg)
- en: Delete the **Spaceship** image from `Images.xcassets`. Spaceship images are
    not required in this project.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Images.xcassets`中删除**Spaceship**图像。在这个项目中不需要Spaceship图像。
- en: 'Now you will not see an error in your Xcode, and if you run `Platformer`, you
    will see nothing. Well, that is not what we desire. Now, before getting your feet
    wet in code, we need to know what we have done (almost nothing but deleting) so
    far:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将不会在Xcode中看到错误，如果你运行`Platformer`，你将看不到任何东西。嗯，这不是我们想要的。现在，在我们开始编写代码之前，我们需要知道我们到目前为止已经做了什么（几乎什么都没做，只是删除了）：
- en: '**Extension SKNode**: This extension is inserted by Sprite Kit presuming that
    every game must have an initial scene, creating a GameScene.sks file. We do not
    need this initial scene at the start of our *Platformer* game, as we will create
    our own menu screen on start.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展SKNode**：这个扩展由Sprite Kit插入，假设每个游戏都必须有一个初始场景，创建一个GameScene.sks文件。在我们的*平台游戏*开始时，我们不需要这个初始场景，因为我们将在开始时创建自己的菜单屏幕。'
- en: '**If statement within viewDidLoad**: As `GameScene.sks` file created by extension
    `SKNode` is used in this statement.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewDidLoad中的if语句**：由于由扩展`SKNode`创建的`GameScene.sks`文件用于此语句。'
- en: Now we are going to create our own custom scene for this game, but before that,
    let's now see what a scene really is.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为此游戏创建自己的自定义场景，但在那之前，让我们先看看场景到底是什么。
- en: What is a scene?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是场景？
- en: A scene is basically a collection of different elements such as sprites, sounds,
    and so on, in a logical way. Suppose we want to make a menu, we'll have to put
    some buttons, background, and sounds in a manner that is positioned according
    to our needs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 场景基本上是不同元素（如精灵、声音等）的逻辑集合。假设我们想要创建一个菜单，我们必须以根据我们的需求定位的方式放置一些按钮、背景和声音。
- en: 'A `Scene` object is a collection of nodes, but a scene itself acts as a node.
    Imagine a tree of nodes having scene objects as its root. As all nodes in the
    scene are positioned in defined coordinates, their linkage can be shown as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`场景`对象是节点的集合，但场景本身充当一个节点。想象一个以场景对象为根的节点树。由于场景中的所有节点都定位在定义的坐标中，它们的链接可以表示为：'
- en: '*Node (Content) → Descendant Node*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点（内容）→ 后代节点*'
- en: This linkage of a node with its descendant(s) is very useful. Say, if you rotate
    a node on the top of the tree, all the nodes will be subsequently rotated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 节点与其后代之间的这种链接非常有用。比如说，如果你旋转树顶部的节点，所有节点都将随后旋转。
- en: In technical terms, `Scene` is an `SKScene` object, which holds an `SKNode`
    object (such as `SKSpriteNode` objects for sprites) inside a view (`SKView` object),
    so that we can render and use them. Scene is itself an `SKNode` object, which
    acts as a root node and attaches in an `SKView` object. Other objects required
    for that scene are added to this node as a child node. A scene runs different
    kinds of actions and simulates physics (if required), and then renders the node
    tree. A game consists of many scenes, and we can make as many scenes required
    by sub-classing `SKScene` class. An `SKView` object is required to display a scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术术语中，`场景`是一个`SKScene`对象，它在一个视图（`SKView`对象）内部持有`SKNode`对象（例如用于精灵的`SKSpriteNode`对象），这样我们就可以渲染和使用它们。场景本身也是一个`SKNode`对象，它作为根节点并附加在`SKView`对象中。该场景所需的其他对象作为子节点添加到这个节点中。场景运行不同的动作并模拟物理（如果需要），然后渲染节点树。一个游戏由许多场景组成，我们可以通过子类化`SKScene`类来创建所需数量的场景。显示场景需要一个`SKView`对象。
- en: Coordinate system
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系统
- en: Everything in a game built in Sprite Kit is related to nodes, and it follows
    a node tree structure where a scene is a root node and other nodes are child nodes
    of it. When we put a node in the node tree, it uses its position property to place
    it within the coordinate system provided by its parent.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sprite Kit中构建的游戏中的所有内容都与节点相关，它遵循节点树结构，其中场景是根节点，其他节点是它的子节点。当我们把节点放入节点树中时，它使用其位置属性将其放置在其父提供的坐标系中。
- en: As a scene is also a node, it is placed inside the view provided by the `SKView`
    object. The code part which we deleted in `viewDidLoad`, `GameScene`, was added
    as a child in the `SKView` object. A scene uses its parent `SKView` object coordination
    system to render itself and the content within it. The coordinate system is the
    same as we learned in basic mathematics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于场景也是一个节点，它被放置在由`SKView`对象提供的视图中。我们在`viewDidLoad`、`GameScene`中删除的代码部分被添加为`SKView`对象的子节点。场景使用其父`SKView`对象的坐标系来渲染自身及其内容。坐标系与我们学习的基本数学中的坐标系相同。
- en: '![Coordinate system](img/B04201_02_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![坐标系统](img/B04201_02_04.jpg)'
- en: As the preceding diagram shows, if we move right from **(0,0)**, then **x**
    will be positive, and negative if we move left from **(0,0)**. If we move up from
    **(0,0)**, then **y** will be positive, and negative if we move down from **(0,0)**.
    Coordinate values are measured in points and when the scene is rendered, it will
    be converted to pixels.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，如果我们从**(0,0)**向右移动，则**x**值为正，如果我们从**(0,0)**向左移动，则**x**值为负。如果我们从**(0,0)**向上移动，则**y**值为正，如果我们从**(0,0)**向下移动，则**y**值为负。坐标值以点为单位测量，当场景渲染时，它将被转换为像素。
- en: All the nodes in Sprite Kit will not draw the content. For example, `SKSpriteNode`
    is used to draw sprites in a game, but `SKNode` class does not draw anything as
    `SKNode` is a fundamental building block for most Sprite Kit content.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit中的所有节点都不会绘制内容。例如，`SKSpriteNode`用于在游戏中绘制精灵，但`SKNode`类不绘制任何内容，因为`SKNode`是大多数Sprite
    Kit内容的基石。
- en: Creating a scene
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景
- en: When we create a scene, we can define many of its properties such as size, origin,
    and so on. as we require in our game. A scene size defines the visible area in
    the **SKView** object. Of course, we can put nodes outside this area, but they
    will be totally ignored by the renderer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建场景时，我们可以定义许多属性，如大小、原点等，以满足我们在游戏中的需求。场景大小定义了**SKView**对象中的可见区域。当然，我们可以将节点放置在这个区域之外，但它们将被渲染器完全忽略。
- en: However, if we try to change the position property of a scene, it will be ignored
    by Sprite Kit because a scene is a root node in a node tree, its default value
    is `CGPointZero`. But we can move scene origin by the `anchorPoint` property.
    Default value for `anchorPoint` is `(0.5,0.5)`, which indicates the center point
    of the screen. By reassigning a new `anchorPoint` property, we can change the
    coordinate system for its child. For example, if we set `anchorPoint` to `(0,0)`,
    the child node of the scene will start from the bottom left of the scene.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试更改场景的位置属性，Sprite Kit将会忽略它，因为场景是节点树中的根节点，其默认值是`CGPointZero`。但我们可以通过`anchorPoint`属性移动场景原点。`anchorPoint`的默认值是`(0.5,0.5)`，表示屏幕的中心点。通过重新分配新的`anchorPoint`属性，我们可以为其子节点改变坐标系。例如，如果我们设置`anchorPoint`为`(0,0)`，场景的子节点将从场景的左下角开始。
- en: If we make the `anchorPoint (0.5, 0.5)` or the middle of the screen, the child
    node of the scene will start from the middle of the screen. It totally depends
    on us and what `anchorPoint` we choose as per our requirement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`anchorPoint (0.5, 0.5)`或屏幕中间设置为锚点，场景的子节点将从屏幕中间开始。这完全取决于我们以及我们根据需求选择的`anchorPoint`。
- en: Creating a node tree
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建节点树
- en: 'A node tree for a scene is created as a parent child relation. As a scene acts
    similar to a root node, another node acts as a child to it. Following are some
    common methods used to make a node tree:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的节点树是以父子关系创建的。作为一个场景类似于根节点，另一个节点作为其子节点。以下是一些常用的创建节点树的方法：
- en: '`addChild`: It adds a node to the end of the receiver''s list of child nodes'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addChild`：它将节点添加到接收者子节点列表的末尾'
- en: '`insertChild:atIndex`: It inserts a child at a specific position in the receiver''s
    list of child nodes'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertChild:atIndex`：它在接收者子节点列表中的特定位置插入一个子节点'
- en: 'If you want to remove a node from a node tree, you can use the following method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从一个节点树中移除一个节点，你可以使用以下方法：
- en: '`removeFromParent`: It removes the receiving node from its parent'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeFromParent`：它从父节点中移除接收到的节点'
- en: Drawing order for a node tree
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点树的绘制顺序
- en: When a node tree renders, all its children also render. First, the parent is
    rendered, and then, its children, in the order they are added to parent. If you
    have many nodes to render in a scene, it is a difficult task to maintain them
    in order. For this, Sprite Kit provides a solution using the *z* position. You
    can set nodes to the *z* position by using the `zPosition` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点树渲染时，所有子节点也会渲染。首先渲染父节点，然后按照它们添加到父节点的顺序渲染其子节点。如果你在一个场景中有很多节点需要渲染，保持它们顺序是一个困难的任务。为此，Sprite
    Kit提供了一个使用*z*位置的解决方案。你可以通过使用`zPosition`属性设置节点的*z*位置。
- en: 'When you take the z position into account, the node tree will be rendered as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑*z*位置时，节点树将按照以下方式渲染：
- en: First of all, each node's global *z* position is calculated
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，计算每个节点的全局*z*位置
- en: Then, nodes are drawn in order from smallest *z* value to largest *z* value
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，节点按照从最小的*z*值到最大的*z*值的顺序绘制
- en: If two nodes share the same z value, ancestors are rendered first, and siblings
    are rendered in child order
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个节点具有相同的*z*值，则先绘制祖先节点，然后按照子节点顺序绘制兄弟节点
- en: As you've just seen, Sprite Kit uses a deterministic rendering order, based
    on the height nodes and their positions in the node tree. But, because the rendering
    order is so deterministic, Sprite Kit may be unable to apply some rendering optimizations
    that it might otherwise apply. For example, it might be better if Sprite Kit could
    gather all of the nodes that share the same texture and drawing mode and draw
    them with a single drawing pass. To enable these sorts of optimizations, you have
    to set the view's `ignoresSiblingOrder` property to `true`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Sprite Kit使用基于高度的节点及其在节点树中的位置的确定性渲染顺序。但是，由于渲染顺序非常确定，Sprite Kit可能无法应用它可能应用的某些渲染优化。例如，如果Sprite
    Kit能够收集所有共享相同纹理和绘图模式的节点，并使用单个绘图过程绘制它们，可能会更好。为了启用这些类型的优化，你必须将视图的`ignoresSiblingOrder`属性设置为`true`。
- en: When you ignore sibling order, Sprite Kit uses the graphics hardware to render
    the nodes so that they appear in z-axis order. It sorts nodes into a drawing order
    that reduces the number of draw calls needed to render the scene. But with this
    optimized drawing order, you cannot predict the rendering order for nodes that
    share the same z-axis index. The rendering order may change each time a new frame
    is rendered. In many cases, the drawing order of these nodes is not important.
    For example, if the nodes are at the same height but do not overlap on screen,
    they can be drawn in any order.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你忽略兄弟顺序时，Sprite Kit使用图形硬件来渲染节点，使它们按z轴顺序出现。它将节点排序到一个绘图顺序，以减少渲染场景所需的绘制调用次数。但是，使用这种优化的绘图顺序，你无法预测具有相同z轴索引的节点的渲染顺序。渲染顺序可能会在每次渲染新帧时改变。在许多情况下，这些节点的绘图顺序并不重要。例如，如果节点处于相同的高度但屏幕上不重叠，它们可以按任何顺序绘制。
- en: So, we can use node tree-based rendering or depth-based rendering, just by setting
    the `ignoresSiblingOrder` property to `false` or `true`. If we set it to true,
    we can set z position, but if set to false, we have to be careful about sequence
    when adding child node to parent node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过设置`ignoresSiblingOrder`属性为`false`或`true`来使用基于节点树渲染或基于深度渲染。如果我们将其设置为`true`，我们可以设置z位置，但如果设置为`false`，我们必须在向父节点添加子节点时注意顺序。
- en: 'Following is a depiction of node-based rendering (parent child rendering):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于节点渲染（父子渲染）的描述：
- en: '![Drawing order for a node tree](img/B04201_02_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![节点树的绘图顺序](img/B04201_02_05.jpg)'
- en: 'Next is a depiction of depth-based rendering (z position-based rendering):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是基于深度渲染（基于z位置的渲染）的描述：
- en: '![Drawing order for a node tree](img/B04201_02_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![节点树的绘图顺序](img/B04201_02_06.jpg)'
- en: Adding the first scene in our game
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的游戏中添加第一个场景
- en: Now it is time to add a menu scene to our game. For this, select the `Platformer`
    folder and right-click on this folder, select **New File**. Select **iOS** | **Source**
    | **Swift File** and then **Next**. Inside **Save As**, give it the name `MenuScene`,
    and click on **Create**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将菜单场景添加到我们的游戏中了。为此，选择`Platformer`文件夹，右键单击此文件夹，选择**New File**。选择**iOS**
    | **Source** | **Swift File**然后**Next**。在**Save As**中，将其命名为`MenuScene`，然后点击**Create**。
- en: 'Click on your `MenuScene.swift` file. Now it''s time to do some code stuff:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击你的`MenuScene.swift`文件。现在该做一些代码工作了：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we created a class `MenuScene` type of `SKScene`. `SKScene`
    is a class used to create scene. Let''s look out for some terminology used in
    this code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`MenuScene`类，其类型为`SKScene`。`SKScene`是一个用于创建场景的类。让我们看看在这个代码中使用的术语：
- en: In the `#1` code block (refer to the preceding code), we define two `SKSpriteNode`
    references. One for play button and the other for background. The `let` keyword
    denotes that once we assign a value to this reference, we can't change it. If
    you want to change that, you should use the `var` keyword instead of `let`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`#1`代码块（参考前面的代码）中，我们定义了两个`SKSpriteNode`引用。一个用于播放按钮，另一个用于背景。`let`关键字表示一旦我们为这个引用分配了一个值，我们就不能改变它。如果你想改变它，你应该使用`var`关键字而不是`let`。
- en: In the `#2` code block (refer to the preceding code), we define an initializer
    for this class. The initializer is used to create an instance of a particular
    type. Inside this, we initialize `PlayButton` and `Background`. We give background
    a full screen size by setting its `size` property. In the end, we call parent
    class `init` by `super.init`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`#2`代码块（参考前面的代码）中，我们为这个类定义了一个初始化器。初始化器用于创建特定类型的实例。在这个初始化器内部，我们初始化`PlayButton`和`Background`。我们通过设置其`size`属性为全屏大小来给背景。最后，我们通过`super.init`调用父类的`init`。
- en: In the `#3` code block (refer to the preceding code), we remove errors at compile
    time. The required keyword denotes that every subclass of that class must implement
    that initializer.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `#3` 代码块（参考前面的代码）中，我们在编译时移除错误。所需的关键字表示该类的每个子类都必须实现该初始化器。
- en: In the `#4` code block (refer to the preceding code), we override its parent
    class method. The `didMoveToView` is called immediately after a scene is presented
    by a view. We have called our custom method `addChildToScene` here.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `#4` 代码块（参考前面的代码）中，我们重写了其父类方法。`didMoveToView` 方法在视图呈现场景后立即被调用。在这里，我们调用了自定义方法
    `addChildToScene`。
- en: In the `#5` code block (refer to the preceding code), we define our `addChildToScene`
    method. Inside this we did nothing but give `z` position to `PlayButton` and defined
    `size` for `Background`. Remember, we can use `z` depth to control which layer
    will render above what. If you have `z` depth set to minimum, it will render first,
    and then to maximum. It means that the lower the *z* depth, the lower it will
    be in a scene. That's why we put the `Background` `z` depth lower than `PlayButton`,
    so that `PlayButton` could render above `Background`. After that, we added `PlayButton`
    and `Background` to scene.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `#5` 代码块（参考前面的代码）中，我们定义了 `addChildToScene` 方法。在这个方法内部，我们只是给 `PlayButton` 分配了
    `z` 位置，并为 `Background` 定义了 `size`。记住，我们可以使用 `z` 深度来控制哪个层将渲染在哪个之上。如果你将 `z` 深度设置为最小值，它将首先渲染，然后是最大值。这意味着
    `z` 深度越低，在场景中的位置就越低。这就是为什么我们将 `Background` 的 `z` 深度设置得低于 `PlayButton`，这样 `PlayButton`
    就可以渲染在 `Background` 之上。之后，我们将 `PlayButton` 和 `Background` 添加到场景中。
- en: In the `#6` code block (refer to the preceding code), we just override the update
    method. The code for this method will be updated later.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `#6` 代码块（参考前面的代码）中，我们只是重写了更新方法。此方法的代码将在以后更新。
- en: 'Whoa! We have created our first scene. Now it''s time to see what we have done.
    But before that, we have to add this scene to the view, so that we can make it
    visible and live. Open your `GameViewController` class and paste the code inside
    `viewDidLoad` under `super.viewDidLoad()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经创建了第一个场景。现在是时候看看我们做了什么。但在那之前，我们必须将此场景添加到视图中，以便我们可以使其可见并活跃。打开你的 `GameViewController`
    类，在 `super.viewDidLoad()` 下的 `viewDidLoad` 中粘贴代码：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we created the `menuscene` instance and added it to the view.
    `Play` and `BG` are the names of the PNG sprite, which we will add later. We have
    typecast view as `SKView` and set some of its properties. If we want to see frame
    per second rate, we set `showFPS` to `true`. Same goes for the counting node.
    If we set `ignoresSiblingOrder` property to `false`, then it means that the nodes
    that are sharing the same `z` depth will be rendered in parent to child preference.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了 `menuscene` 实例并将其添加到视图中。`Play` 和 `BG` 是 PNG 精灵的名称，我们稍后会添加。我们将视图类型转换为
    `SKView` 并设置了一些属性。如果我们想看到每秒帧率，我们将 `showFPS` 设置为 `true`。对于计数节点也是如此。如果我们将 `ignoresSiblingOrder`
    属性设置为 `false`，那么这意味着共享相同 `z` 深度的节点将按照父到子的顺序渲染。
- en: This implies that the parent will render first and then its child. If we set
    it `true`, then it means that all the nodes with the same `z` depth will render
    at the same time, and not by some parent child preference. So to maximize the
    optimization, we will just set this value to true; in simple terms, it's better
    to set this to true if you want faster results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着父节点将首先渲染，然后是其子节点。如果我们将其设置为 `true`，那么这意味着具有相同 `z` 深度的所有节点将同时渲染，而不是按照父到子的偏好顺序。为了最大化优化，我们将此值设置为
    `true`；简单来说，如果你想得到更快的结果，最好将其设置为 `true`。
- en: '`.scaleMode` is used to fill the scene inside a view. `ResizeFill` means that
    it will resize itself to fill the whole view.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`.scaleMode` 用于填充视图内的场景。`ResizeFill` 表示它会调整自身大小以填充整个视图。'
- en: Now, for the `anchorPoint`. It decides what would be a child's coordinate system
    according to parent position. If we set it to `.5, .5`, that means that the nodes
    that will be added to these scenes, will have their coordinate system starting
    from the middle of the screen. You can choose whatever you are comfortable with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于 `anchorPoint`。它决定了根据父节点位置，子节点的坐标系将是什么。如果我们将其设置为 `.5, .5`，这意味着将添加到这些场景中的节点，其坐标系将从屏幕中间开始。你可以选择你感到舒适的方式。
- en: In the last line, we just added `menuscene` to the view so that it could render.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们只是将 `menuscene` 添加到视图中，以便它可以渲染。
- en: Now, it's time to add some images to the project. The first question that comes
    to mind is, "How one can maintain the quality of an image on various screen sizes?"
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向项目中添加一些图像了。首先想到的问题是，“如何在各种屏幕尺寸上保持图像的质量？”
- en: To optimize the quality of an image on large screen devices, we add the same
    image in two different sizes, 1x—the original image—and 2x—double the size of
    the original image, for better display quality on larger devices. iOS will automatically
    select the appropriate image size.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化大屏幕设备上图像的质量，我们在两个不同的大小中添加了相同的图像，1x——原始图像，和2x——原始图像的两倍大小，以便在更大的设备上获得更好的显示质量。iOS
    将自动选择适当的大小。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Also, you can go for a 3x image size, for even larger devices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以选择3x的图像大小，用于更大的设备。
- en: Two sets of image sizes are sufficient to cover most commonly used screen sizes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 两组图片大小足以覆盖大多数常用的屏幕尺寸。
- en: 'Following are the steps to add images in the project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是向项目中添加图片的步骤：
- en: Click on `Images.xcassets` | select **New Image Set**:![Adding the first scene
    in our game](img/B04201_02_07.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Images.xcassets` | 选择 **New Image Set**：![在我们的游戏中添加第一个场景](img/B04201_02_07.jpg)
- en: After that, Name it `BG`, and drag and drop your background images according
    to size. As shown in the next image:![Adding the first scene in our game](img/B04201_02_08.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将其命名为 `BG`，并根据大小拖放你的背景图片。如图所示：![在我们的游戏中添加第一个场景](img/B04201_02_08.jpg)
- en: Repeat the process for the set of play images.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一组游戏图片重复此过程。
- en: Run it and see. You will see your background in full screen, with a **Play**
    button in the middle of the screen. We can also control the **Play** button size,
    as we did for `Background`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并查看。你将看到背景全屏显示，屏幕中央有一个 **Play** 按钮。我们也可以控制 **Play** 按钮的大小，就像我们对 `Background`
    做的那样。
- en: Congratulations, you made your first scene. Now it's time to make another scene,
    that is the `GameScene`, and also transition between `Menuscene` and `Gamescene`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你创建了你的第一个场景。现在是你创建另一个场景的时候了，即 `GameScene`，以及从 `Menuscene` 到 `Gamescene` 的过渡。
- en: Adding another scene to our game
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的游戏中添加另一个场景
- en: 'Create the `GameScene` file as we did for `MenuScene`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `GameScene` 文件，就像我们为 `MenuScene` 做的那样：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code is self-explanatory, we added only a background to the `GameScene`,
    the same as what we did for the `MenuScene`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自我解释的，我们只为 `GameScene` 添加了背景，这与我们对 `MenuScene` 做的相同。
- en: A transition from one scene to another
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个场景到另一个场景的过渡
- en: 'A transition is used to perform animation; while shifting from one scene to
    another, an object called `SKTransition` is used to perform this action. As we
    know, scenes are the basic building blocks of games. Transiting from one scene
    to another is often necessary in a game at various instances such as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡动画是通过使用一个名为 `SKTransition` 的对象来实现的；在从一个场景切换到另一个场景时，会用到这个对象来执行这个动作。正如我们所知，场景是游戏的基本构建块。在游戏中，从一个场景过渡到另一个场景在许多情况下都是必要的，例如：
- en: A loading scene, which is shown in a game while other objects are being loaded
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个加载场景，在游戏中显示其他对象正在加载时
- en: A main menu scene, in which different options are shown to the user
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主菜单场景，其中向用户展示了不同的选项
- en: A level selection menu scene, to select different levels available
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关卡选择菜单场景，用于选择可用的不同关卡
- en: A game play scene, which contains the main elements of the game
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个游戏玩法场景，其中包含游戏的主要元素
- en: A game over scene, to represent ending of the game, and so on
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束场景，用于表示游戏的结束，等等
- en: When you present a new scene in a view that is already presenting a scene, you
    have the option of using a transition to animate the change from the old scene
    into the new scene. Using a transition provides continuity, so that the scene
    change is not abrupt and doesn't disturb the UI of the game.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在已经显示场景的视图中呈现一个新的场景时，你有使用过渡来动画化从旧场景到新场景的变化的选项。使用过渡提供了连续性，因此场景变化不会突然发生，也不会打扰游戏的
    UI。
- en: When the transition occurs, the scene property is immediately updated to point
    to the new scene. Then, the animation occurs. Finally, the strong reference to
    the old scene is removed. If you need to keep the scene around after the transition
    occurs, your game has to keep its own strong reference to the old scene.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当过渡发生时，场景属性会立即更新以指向新的场景。然后，动画开始。最后，对旧场景的强引用被移除。如果你需要在过渡发生后保留场景，你的游戏必须保留对旧场景的自己的强引用。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载所有已购买 Packt 出版物的示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给您。
- en: Setting animation play during transition
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置过渡期间的动画播放
- en: Generally, when a transition occurs between two scenes, both the scenes are
    paused. This implies that if any animation is being played in any one of the two
    scenes, it will be paused until the transition has been completed. Sometimes,
    it is required to complete the animation effect of one scene. The `pausesIncomingScene`
    and `pausesOutgoingScene` properties on the transition object define which animations
    are played during the transition.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当两个场景之间发生过渡时，两个场景都会暂停。这意味着如果两个场景中的任何一个场景正在播放动画，它将暂停，直到过渡完成。有时，需要完成一个场景的动画效果。过渡对象上的
    `pausesIncomingScene` 和 `pausesOutgoingScene` 属性定义了在过渡期间播放哪些动画。
- en: Creating transition objects
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建过渡对象
- en: 'Transitions are used by making `SKTransition` an object; some of the methods
    to do that are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `SKTransition` 作为对象使用来应用过渡；执行此操作的一些方法如下：
- en: '`class func crossFadeWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a cross fade transition; it takes the duration of transition as its
    parameter and returns an `SKTransition` object.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func crossFadeWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    这将创建一个交叉淡入淡出过渡；它接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func doorsCloseHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of closing horizontal
    doors; it also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func doorsCloseHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    这将创建一个过渡，新场景以一对关闭的水平门的形式出现；它也接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func doorsCloseVerticalWithDuration(sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of closing vertical
    doors. It also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func doorsCloseVerticalWithDuration(sec: NSTimeInterval) -> SKTransition`:
    这将创建一个过渡，新场景以一对关闭的垂直门的形式出现。它也接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func doorsOpenHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of opening horizontal
    doors. It also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func doorsOpenHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    这将创建一个过渡，新场景以一对开启的水平门的形式出现。它也接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func doorsOpenVerticalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of opening vertical
    doors. It also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func doorsOpenVerticalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    这将创建一个过渡，新场景以一对开启的垂直门的形式出现。它还接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func doorwayWithDuration(_ sec: NSTimeInterval) -> SKTransition`: This
    creates a transition where the previous scene disappears as a pair of opening
    doors. The new scene starts in the background and moves closer as the doors open.
    It also takes the duration of transition as its parameter and returns an `SKTransition`
    object.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func doorwayWithDuration(_ sec: NSTimeInterval) -> SKTransition`: 这将创建一个过渡，前一个场景以一对开启的门的形式消失。新场景在背景中开始，随着门的开启而逐渐靠近。它也接受过渡的持续时间作为参数，并返回一个
    `SKTransition` 对象。'
- en: '`class func fadeWithColor(_ color: UIColor, duration sec: NSTimeInterval) ->
    SKTransition`: This creates a transition that first fades to a constant color,
    and then fades to the new scene. It takes the fade color and the duration of transition
    as parameters, and returns the `SKTransition` as object.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func fadeWithColor(_ color: UIColor, duration sec: NSTimeInterval) ->
    SKTransition`: 这将创建一个过渡，首先淡入到恒定颜色，然后淡入到新场景。它接受淡入颜色和过渡的持续时间作为参数，并返回 `SKTransition`
    对象。'
- en: '`class func fadeWithDuration(_ sec: NSTimeInterval) -> SKTransition`: This
    creates a transition that first fades to black and then fades to the new scene.
    It takes the duration of transition as its parameter and returns an `SKTransition`
    object.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func fadeWithDuration(_ sec: NSTimeInterval) -> SKTransition`: 这创建了一个过渡效果，首先淡入黑色，然后淡入新的场景。它接受过渡的持续时间作为参数，并返回一个
    `SKTransition` 对象。'
- en: '`class func flipHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the two scenes are flipped across a horizontal
    line running through the center of the view. It takes the duration of transition
    as its parameter and returns an `SKTransition` object.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func flipHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    这创建了一个过渡效果，其中两个场景在视图中通过中心线的水平方向翻转。它接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func flipVerticalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the two scenes are flipped across a vertical line
    running through the center of the view. It takes the duration of transition as
    its parameter and returns an `SKTransition` object.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func flipVerticalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    这创建了一个过渡效果，其中两个场景在视图中通过中心线的垂直方向翻转。它接受过渡的持续时间作为参数，并返回一个 `SKTransition` 对象。'
- en: '`class func moveInWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: This creates a transition where the new
    scene moves on top of the old scene. It takes the direction of the move and the
    duration as its parameters, and returns an SKTransition object.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func moveInWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: 这创建了一个过渡效果，其中新场景在旧场景之上移动。它接受移动的方向和持续时间作为参数，并返回一个
    SKTransition 对象。'
- en: '`class func pushWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: This creates a transition where the new
    scene moves in, pushing the old scene out of the view. It takes the direction
    of the push and the duration of transition as its parameters, and returns an SKTransition
    object.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func pushWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: 这创建了一个过渡效果，其中新场景进入，将旧场景推出视图。它接受推动的方向和过渡的持续时间作为参数，并返回一个
    SKTransition 对象。'
- en: '`class func revealWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: This creates a transition where the old
    scene moves out of the view, revealing the new scene underneath it. It takes the
    direction of the reveal and the duration of transition as its parameters, and
    returns an `SKTransition` object.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class func revealWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: 这创建了一个过渡效果，其中旧场景从视图中移出，从而揭示其下方的新的场景。它接受揭示的方向和过渡的持续时间作为参数，并返回一个
    `SKTransition` 对象。'
- en: Adding transition in our game
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的游戏中添加过渡效果
- en: 'Now, open `MenuScene`. First, define the `GameScene` reference inside the `MenuScene`
    class, before the init code block:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `MenuScene`。首先，在 `MenuScene` 类中初始化代码块之前定义 `GameScene` 引用：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside `didMoveToView`, place the following line just under `addChildToScene`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `didMoveToView` 中，将以下行放置在 `addChildToScene` 之下：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run it now, you will see our menu scene with a play button and a background;
    if you click outside the play button, nothing will happen. When you click on the
    play button, you will see a smooth transition to the game scene.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行它，你会看到我们的菜单场景，其中有一个播放按钮和背景；如果你点击播放按钮之外的地方，什么也不会发生。当你点击播放按钮时，你会看到一个平滑的过渡到游戏场景。
- en: In the preceding code, `var` is a keyword that means it can change its value.
    But what is this `?` symbol doing after `GameScene`?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`var` 是一个关键字，表示它的值可以改变。但是 `GameScene` 后面的 `?` 符号是什么意思？
- en: The `?` symbol means that the reference is optional. It means it can either
    have a value, or it can be nil.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`?` 符号表示引用是可选的。这意味着它可以有值，也可以是 nil。'
- en: That's why we don't need to initialize it in the init code block.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为什么我们不需要在初始化代码块中初始化它的原因。
- en: In `PlayButton.name = "PLAY"` we are just giving the `SKSpriteNode` object a
    name, so that when we touch this sprite, we can verify it by name.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlayButton.name = "PLAY"` 中，我们只是给 `SKSpriteNode` 对象赋予一个名称，这样当我们触摸这个精灵时，我们可以通过名称来验证它。
- en: '`touchesBegan`, is an override method which is used to identify when a touch
    event is just beginning. In this method, we are getting a node at the touch position
    and checking if the desired node is there. If the play `SKSpriteNode` is there,
    it will be identified by its name and will call the `goToGameScene` method.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`touchesBegan` 是一个重写方法，用于识别触摸事件刚开始时的情况。在这个方法中，我们获取触摸位置的节点并检查是否包含所需的节点。如果存在
    `SKSpriteNode` 节点，它将通过其名称被识别，并调用 `goToGameScene` 方法。'
- en: In `goToGameScene` method, we just added `GameScene` to the view with some transition
    effect. Transitions are an `SKTransition` class instance. Here, we used the `flipHorizontalWithDuration`
    transition effect.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `goToGameScene` 方法中，我们只是添加了带有一些过渡效果的 `GameScene` 到视图中。过渡是 `SKTransition` 类的实例。在这里，我们使用了
    `flipHorizontalWithDuration` 过渡效果。
- en: You can also tweak and play with other transitions available.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以调整并尝试其他可用的过渡效果。
- en: 'In `gameScene!.anchorPoint = CGPoint(x: 0.5, y: 0.5)`, we have put an exclamation
    mark after `GameScene`. As we know that `GameScene` is optional, we have to tell
    the compiler that we know it has a value, and that we are forcing the it to unwrap
    its value. The `!` symbol is used for force unwrapping optional values.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `gameScene!.anchorPoint = CGPoint(x: 0.5, y: 0.5)` 中，我们在 `GameScene` 后面放置了一个感叹号。正如我们所知，`GameScene`
    是可选的，我们必须告诉编译器我们知道它有值，并且我们正在强制展开其值。`!` 符号用于强制展开可选值。'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about device orientation and about the different
    auto generated files in a Sprite Kit project. Also, we studied scenes and saw
    how to create them in a Sprite Kit project. Furthermore, we discussed about transitions
    between scenes and their types.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了设备方向以及 Sprite Kit 项目中自动生成的不同文件。我们还研究了场景，并看到了如何在 Sprite Kit 项目中创建它们。此外，我们还讨论了场景之间的过渡及其类型。
- en: In the next chapter, we will learn about sprites and texture atlases. Our *Platformer*
    game will become much more exciting and interesting to play, as we move further.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于精灵和纹理图集的内容。随着我们的深入，我们的 *Platformer* 游戏将变得更加有趣和吸引人。
