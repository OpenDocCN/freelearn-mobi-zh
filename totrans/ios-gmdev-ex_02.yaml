- en: Chapter 2. Scenes in Sprite Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Hello World* game, made in the previous chapter. was the first step to
    Sprite Kit. We also made acquaintance with the Swift programming language, which
    we are going to use for iOS game development using Sprite Kit.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive deep into various fundamentals of the Sprite Kit
    project and also discuss in depth about scenes in a game. We are further going
    to continue the development of the game, *Platformer*, and use it as a tool to
    learn Sprite Kit. We will be learning about different auto generated files in
    an Xcode project and about their importance. Only then will we be able to understand
    what scenes are, and their importance in game development. Further we will also
    learn how nodes play an important part in Sprite Kit and help us to improve optimization
    and control of our game. In this chapter, we will also learn how to add more than
    one scene in our game and successfully transit from one scene to another along
    with animating various transition effects.
  prefs: []
  type: TYPE_NORMAL
- en: We will be learning all of this and testing our progress with development of
    the game *Platformer*, so that by the end of the book, you are able make your
    own 2D game from scratch. Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Device orientation in Sprite Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of modes, namely portrait and landscape; you can select
    the desired orientation for your game while setting up your project. Any time
    during the development of your game, you can change the orientation under the
    properties section of your Sprite Kit project. There are four types of orientations
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: Portrait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upside Down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape Left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape Right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can select any of the orientations depending on your game. If you want to
    make your game scene in portrait mode, you can select either **Portrait** or **Upside
    Down** options. If want to make your game in landscape mode, you can select the
    **Landscape Left** or **Landscape Right** option. If you want to make your game
    in both portrait and landscape, then you can select both the options too. Caution,
    if you want to make your game in both portrait and landscape mode, make sure that
    you have to handle the positions of sprites in your game during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Orientation in our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are making a *Platformer* game, it''s better to opt for landscape mode.
    Although you can select both **Landscape Left** and **Landscape Right**, it is
    better to opt for one orientation for easier programming. Following are the steps
    to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the `Platformer` project that we made in the last chapter, either by
    double-clicking `Platformer.xcodeproj` from the directory of project, or from
    your Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Project Navigator** and then click **Platformer**, which is just
    under it, on the left panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Untick the **Portrait** checkbox and tick **Landscape Left** under the **Device
    Orientation** section:![Orientation in our project](img/B04201_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting project elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to discuss about some auto-generated files in your Sprite Kit
    project. They can be found on the left panel in your Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: AppDelegate.swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This file is an entry point file to our game. Its existence is crucial when
    the game goes from an active state to inactive state (or background state), in
    simple terms, when there are some sorts of temporary interruptions (such as incoming
    phone calls or SMS messages), or when the user force quits the application. The
    essence of this file in a project comes when you have to perform any specific
    task between the transition of active and inactive states, such as saving game
    data when the game is moving into a background state due to a phone call.
  prefs: []
  type: TYPE_NORMAL
- en: GameScene.sks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This file is a static archive of your scene's content. This file presents a
    view in your editor, it is used to save static content of a game such as spawning
    the position of a player, level ending position, and so on. The main essence and
    importance of this file is that it has worked towards helping you to separate
    the dynamic and static part of a game. Now a developer does not need to write
    extra lines of code for specifying trivial elements of a game such as spawning
    position, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: GameScene.swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This file contains the `GameScene` class which is a type of `SKScene`. An `SKScene`
    class object is used to make a scene in a game. When we developed the "Hello World"
    sample game in the previous chapter, the logic part was present inside this file.
  prefs: []
  type: TYPE_NORMAL
- en: GameViewController.swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a game starts, a default view is added to the game, which is controlled
    by the game view controller. If the user wants to add scenes to the game, then
    it is added on top of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Main.storyboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is responsible for displaying content on the screen. A storyboard with
    a view controller whose view is set to `SKView` is created, the scene then displays
    the content of the Sprite Kit game. You can create additional view controllers
    and storyboards along with applying transition between them.
  prefs: []
  type: TYPE_NORMAL
- en: LaunchScreen.xib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New projects are created with this launch screen file. The Launch Screen uses
    size classes to adapt to different screen sizes and orientations.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to make some adjustments in the already-created project called
    `Platformer`. Please follow the steps listed, in order to customize the project
    according to our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `GameScene.swift` and `GameScene.sks` files present in your project.
    We will be recreating these files as per our need. Don't worry about the error,
    we are going to fix it in the next step. `GameScene.swift` is the default scene
    given by Xcode; we are deleting the default ones as we are going to create the
    menu Scene before the game scene. Take a look at the next screenshot:![Adjusting
    the project](img/B04201_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `GameViewController.swift` and delete the code, as shown in the following
    screenshot:![Adjusting the project](img/B04201_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **Spaceship** image from `Images.xcassets`. Spaceship images are
    not required in this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you will not see an error in your Xcode, and if you run `Platformer`, you
    will see nothing. Well, that is not what we desire. Now, before getting your feet
    wet in code, we need to know what we have done (almost nothing but deleting) so
    far:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension SKNode**: This extension is inserted by Sprite Kit presuming that
    every game must have an initial scene, creating a GameScene.sks file. We do not
    need this initial scene at the start of our *Platformer* game, as we will create
    our own menu screen on start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If statement within viewDidLoad**: As `GameScene.sks` file created by extension
    `SKNode` is used in this statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we are going to create our own custom scene for this game, but before that,
    let's now see what a scene really is.
  prefs: []
  type: TYPE_NORMAL
- en: What is a scene?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scene is basically a collection of different elements such as sprites, sounds,
    and so on, in a logical way. Suppose we want to make a menu, we'll have to put
    some buttons, background, and sounds in a manner that is positioned according
    to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Scene` object is a collection of nodes, but a scene itself acts as a node.
    Imagine a tree of nodes having scene objects as its root. As all nodes in the
    scene are positioned in defined coordinates, their linkage can be shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Node (Content) → Descendant Node*'
  prefs: []
  type: TYPE_NORMAL
- en: This linkage of a node with its descendant(s) is very useful. Say, if you rotate
    a node on the top of the tree, all the nodes will be subsequently rotated.
  prefs: []
  type: TYPE_NORMAL
- en: In technical terms, `Scene` is an `SKScene` object, which holds an `SKNode`
    object (such as `SKSpriteNode` objects for sprites) inside a view (`SKView` object),
    so that we can render and use them. Scene is itself an `SKNode` object, which
    acts as a root node and attaches in an `SKView` object. Other objects required
    for that scene are added to this node as a child node. A scene runs different
    kinds of actions and simulates physics (if required), and then renders the node
    tree. A game consists of many scenes, and we can make as many scenes required
    by sub-classing `SKScene` class. An `SKView` object is required to display a scene.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything in a game built in Sprite Kit is related to nodes, and it follows
    a node tree structure where a scene is a root node and other nodes are child nodes
    of it. When we put a node in the node tree, it uses its position property to place
    it within the coordinate system provided by its parent.
  prefs: []
  type: TYPE_NORMAL
- en: As a scene is also a node, it is placed inside the view provided by the `SKView`
    object. The code part which we deleted in `viewDidLoad`, `GameScene`, was added
    as a child in the `SKView` object. A scene uses its parent `SKView` object coordination
    system to render itself and the content within it. The coordinate system is the
    same as we learned in basic mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Coordinate system](img/B04201_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the preceding diagram shows, if we move right from **(0,0)**, then **x**
    will be positive, and negative if we move left from **(0,0)**. If we move up from
    **(0,0)**, then **y** will be positive, and negative if we move down from **(0,0)**.
    Coordinate values are measured in points and when the scene is rendered, it will
    be converted to pixels.
  prefs: []
  type: TYPE_NORMAL
- en: All the nodes in Sprite Kit will not draw the content. For example, `SKSpriteNode`
    is used to draw sprites in a game, but `SKNode` class does not draw anything as
    `SKNode` is a fundamental building block for most Sprite Kit content.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a scene, we can define many of its properties such as size, origin,
    and so on. as we require in our game. A scene size defines the visible area in
    the **SKView** object. Of course, we can put nodes outside this area, but they
    will be totally ignored by the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to change the position property of a scene, it will be ignored
    by Sprite Kit because a scene is a root node in a node tree, its default value
    is `CGPointZero`. But we can move scene origin by the `anchorPoint` property.
    Default value for `anchorPoint` is `(0.5,0.5)`, which indicates the center point
    of the screen. By reassigning a new `anchorPoint` property, we can change the
    coordinate system for its child. For example, if we set `anchorPoint` to `(0,0)`,
    the child node of the scene will start from the bottom left of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: If we make the `anchorPoint (0.5, 0.5)` or the middle of the screen, the child
    node of the scene will start from the middle of the screen. It totally depends
    on us and what `anchorPoint` we choose as per our requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a node tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A node tree for a scene is created as a parent child relation. As a scene acts
    similar to a root node, another node acts as a child to it. Following are some
    common methods used to make a node tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addChild`: It adds a node to the end of the receiver''s list of child nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertChild:atIndex`: It inserts a child at a specific position in the receiver''s
    list of child nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to remove a node from a node tree, you can use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`removeFromParent`: It removes the receiving node from its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing order for a node tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a node tree renders, all its children also render. First, the parent is
    rendered, and then, its children, in the order they are added to parent. If you
    have many nodes to render in a scene, it is a difficult task to maintain them
    in order. For this, Sprite Kit provides a solution using the *z* position. You
    can set nodes to the *z* position by using the `zPosition` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you take the z position into account, the node tree will be rendered as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, each node's global *z* position is calculated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, nodes are drawn in order from smallest *z* value to largest *z* value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two nodes share the same z value, ancestors are rendered first, and siblings
    are rendered in child order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you've just seen, Sprite Kit uses a deterministic rendering order, based
    on the height nodes and their positions in the node tree. But, because the rendering
    order is so deterministic, Sprite Kit may be unable to apply some rendering optimizations
    that it might otherwise apply. For example, it might be better if Sprite Kit could
    gather all of the nodes that share the same texture and drawing mode and draw
    them with a single drawing pass. To enable these sorts of optimizations, you have
    to set the view's `ignoresSiblingOrder` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When you ignore sibling order, Sprite Kit uses the graphics hardware to render
    the nodes so that they appear in z-axis order. It sorts nodes into a drawing order
    that reduces the number of draw calls needed to render the scene. But with this
    optimized drawing order, you cannot predict the rendering order for nodes that
    share the same z-axis index. The rendering order may change each time a new frame
    is rendered. In many cases, the drawing order of these nodes is not important.
    For example, if the nodes are at the same height but do not overlap on screen,
    they can be drawn in any order.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can use node tree-based rendering or depth-based rendering, just by setting
    the `ignoresSiblingOrder` property to `false` or `true`. If we set it to true,
    we can set z position, but if set to false, we have to be careful about sequence
    when adding child node to parent node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a depiction of node-based rendering (parent child rendering):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing order for a node tree](img/B04201_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next is a depiction of depth-based rendering (z position-based rendering):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing order for a node tree](img/B04201_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the first scene in our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to add a menu scene to our game. For this, select the `Platformer`
    folder and right-click on this folder, select **New File**. Select **iOS** | **Source**
    | **Swift File** and then **Next**. Inside **Save As**, give it the name `MenuScene`,
    and click on **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on your `MenuScene.swift` file. Now it''s time to do some code stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a class `MenuScene` type of `SKScene`. `SKScene`
    is a class used to create scene. Let''s look out for some terminology used in
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `#1` code block (refer to the preceding code), we define two `SKSpriteNode`
    references. One for play button and the other for background. The `let` keyword
    denotes that once we assign a value to this reference, we can't change it. If
    you want to change that, you should use the `var` keyword instead of `let`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `#2` code block (refer to the preceding code), we define an initializer
    for this class. The initializer is used to create an instance of a particular
    type. Inside this, we initialize `PlayButton` and `Background`. We give background
    a full screen size by setting its `size` property. In the end, we call parent
    class `init` by `super.init`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `#3` code block (refer to the preceding code), we remove errors at compile
    time. The required keyword denotes that every subclass of that class must implement
    that initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `#4` code block (refer to the preceding code), we override its parent
    class method. The `didMoveToView` is called immediately after a scene is presented
    by a view. We have called our custom method `addChildToScene` here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `#5` code block (refer to the preceding code), we define our `addChildToScene`
    method. Inside this we did nothing but give `z` position to `PlayButton` and defined
    `size` for `Background`. Remember, we can use `z` depth to control which layer
    will render above what. If you have `z` depth set to minimum, it will render first,
    and then to maximum. It means that the lower the *z* depth, the lower it will
    be in a scene. That's why we put the `Background` `z` depth lower than `PlayButton`,
    so that `PlayButton` could render above `Background`. After that, we added `PlayButton`
    and `Background` to scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `#6` code block (refer to the preceding code), we just override the update
    method. The code for this method will be updated later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whoa! We have created our first scene. Now it''s time to see what we have done.
    But before that, we have to add this scene to the view, so that we can make it
    visible and live. Open your `GameViewController` class and paste the code inside
    `viewDidLoad` under `super.viewDidLoad()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we created the `menuscene` instance and added it to the view.
    `Play` and `BG` are the names of the PNG sprite, which we will add later. We have
    typecast view as `SKView` and set some of its properties. If we want to see frame
    per second rate, we set `showFPS` to `true`. Same goes for the counting node.
    If we set `ignoresSiblingOrder` property to `false`, then it means that the nodes
    that are sharing the same `z` depth will be rendered in parent to child preference.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that the parent will render first and then its child. If we set
    it `true`, then it means that all the nodes with the same `z` depth will render
    at the same time, and not by some parent child preference. So to maximize the
    optimization, we will just set this value to true; in simple terms, it's better
    to set this to true if you want faster results.
  prefs: []
  type: TYPE_NORMAL
- en: '`.scaleMode` is used to fill the scene inside a view. `ResizeFill` means that
    it will resize itself to fill the whole view.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the `anchorPoint`. It decides what would be a child's coordinate system
    according to parent position. If we set it to `.5, .5`, that means that the nodes
    that will be added to these scenes, will have their coordinate system starting
    from the middle of the screen. You can choose whatever you are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: In the last line, we just added `menuscene` to the view so that it could render.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to add some images to the project. The first question that comes
    to mind is, "How one can maintain the quality of an image on various screen sizes?"
  prefs: []
  type: TYPE_NORMAL
- en: To optimize the quality of an image on large screen devices, we add the same
    image in two different sizes, 1x—the original image—and 2x—double the size of
    the original image, for better display quality on larger devices. iOS will automatically
    select the appropriate image size.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also, you can go for a 3x image size, for even larger devices.
  prefs: []
  type: TYPE_NORMAL
- en: Two sets of image sizes are sufficient to cover most commonly used screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to add images in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on `Images.xcassets` | select **New Image Set**:![Adding the first scene
    in our game](img/B04201_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, Name it `BG`, and drag and drop your background images according
    to size. As shown in the next image:![Adding the first scene in our game](img/B04201_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process for the set of play images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it and see. You will see your background in full screen, with a **Play**
    button in the middle of the screen. We can also control the **Play** button size,
    as we did for `Background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, you made your first scene. Now it's time to make another scene,
    that is the `GameScene`, and also transition between `Menuscene` and `Gamescene`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another scene to our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `GameScene` file as we did for `MenuScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code is self-explanatory, we added only a background to the `GameScene`,
    the same as what we did for the `MenuScene`.
  prefs: []
  type: TYPE_NORMAL
- en: A transition from one scene to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A transition is used to perform animation; while shifting from one scene to
    another, an object called `SKTransition` is used to perform this action. As we
    know, scenes are the basic building blocks of games. Transiting from one scene
    to another is often necessary in a game at various instances such as:'
  prefs: []
  type: TYPE_NORMAL
- en: A loading scene, which is shown in a game while other objects are being loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A main menu scene, in which different options are shown to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A level selection menu scene, to select different levels available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A game play scene, which contains the main elements of the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A game over scene, to represent ending of the game, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you present a new scene in a view that is already presenting a scene, you
    have the option of using a transition to animate the change from the old scene
    into the new scene. Using a transition provides continuity, so that the scene
    change is not abrupt and doesn't disturb the UI of the game.
  prefs: []
  type: TYPE_NORMAL
- en: When the transition occurs, the scene property is immediately updated to point
    to the new scene. Then, the animation occurs. Finally, the strong reference to
    the old scene is removed. If you need to keep the scene around after the transition
    occurs, your game has to keep its own strong reference to the old scene.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Setting animation play during transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, when a transition occurs between two scenes, both the scenes are
    paused. This implies that if any animation is being played in any one of the two
    scenes, it will be paused until the transition has been completed. Sometimes,
    it is required to complete the animation effect of one scene. The `pausesIncomingScene`
    and `pausesOutgoingScene` properties on the transition object define which animations
    are played during the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating transition objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transitions are used by making `SKTransition` an object; some of the methods
    to do that are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class func crossFadeWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a cross fade transition; it takes the duration of transition as its
    parameter and returns an `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func doorsCloseHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of closing horizontal
    doors; it also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func doorsCloseVerticalWithDuration(sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of closing vertical
    doors. It also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func doorsOpenHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of opening horizontal
    doors. It also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func doorsOpenVerticalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the new scene appears as a pair of opening vertical
    doors. It also takes the duration of transition as its parameter and returns an
    `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func doorwayWithDuration(_ sec: NSTimeInterval) -> SKTransition`: This
    creates a transition where the previous scene disappears as a pair of opening
    doors. The new scene starts in the background and moves closer as the doors open.
    It also takes the duration of transition as its parameter and returns an `SKTransition`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func fadeWithColor(_ color: UIColor, duration sec: NSTimeInterval) ->
    SKTransition`: This creates a transition that first fades to a constant color,
    and then fades to the new scene. It takes the fade color and the duration of transition
    as parameters, and returns the `SKTransition` as object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func fadeWithDuration(_ sec: NSTimeInterval) -> SKTransition`: This
    creates a transition that first fades to black and then fades to the new scene.
    It takes the duration of transition as its parameter and returns an `SKTransition`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func flipHorizontalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the two scenes are flipped across a horizontal
    line running through the center of the view. It takes the duration of transition
    as its parameter and returns an `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func flipVerticalWithDuration(_ sec: NSTimeInterval) -> SKTransition`:
    This creates a transition where the two scenes are flipped across a vertical line
    running through the center of the view. It takes the duration of transition as
    its parameter and returns an `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func moveInWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: This creates a transition where the new
    scene moves on top of the old scene. It takes the direction of the move and the
    duration as its parameters, and returns an SKTransition object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func pushWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: This creates a transition where the new
    scene moves in, pushing the old scene out of the view. It takes the direction
    of the push and the duration of transition as its parameters, and returns an SKTransition
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class func revealWithDirection(_ direction: SKTransitionDirection, duration
    sec: NSTimeInterval) -> SKTransition`: This creates a transition where the old
    scene moves out of the view, revealing the new scene underneath it. It takes the
    direction of the reveal and the duration of transition as its parameters, and
    returns an `SKTransition` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding transition in our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, open `MenuScene`. First, define the `GameScene` reference inside the `MenuScene`
    class, before the init code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `didMoveToView`, place the following line just under `addChildToScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you run it now, you will see our menu scene with a play button and a background;
    if you click outside the play button, nothing will happen. When you click on the
    play button, you will see a smooth transition to the game scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `var` is a keyword that means it can change its value.
    But what is this `?` symbol doing after `GameScene`?
  prefs: []
  type: TYPE_NORMAL
- en: The `?` symbol means that the reference is optional. It means it can either
    have a value, or it can be nil.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we don't need to initialize it in the init code block.
  prefs: []
  type: TYPE_NORMAL
- en: In `PlayButton.name = "PLAY"` we are just giving the `SKSpriteNode` object a
    name, so that when we touch this sprite, we can verify it by name.
  prefs: []
  type: TYPE_NORMAL
- en: '`touchesBegan`, is an override method which is used to identify when a touch
    event is just beginning. In this method, we are getting a node at the touch position
    and checking if the desired node is there. If the play `SKSpriteNode` is there,
    it will be identified by its name and will call the `goToGameScene` method.'
  prefs: []
  type: TYPE_NORMAL
- en: In `goToGameScene` method, we just added `GameScene` to the view with some transition
    effect. Transitions are an `SKTransition` class instance. Here, we used the `flipHorizontalWithDuration`
    transition effect.
  prefs: []
  type: TYPE_NORMAL
- en: You can also tweak and play with other transitions available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `gameScene!.anchorPoint = CGPoint(x: 0.5, y: 0.5)`, we have put an exclamation
    mark after `GameScene`. As we know that `GameScene` is optional, we have to tell
    the compiler that we know it has a value, and that we are forcing the it to unwrap
    its value. The `!` symbol is used for force unwrapping optional values.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about device orientation and about the different
    auto generated files in a Sprite Kit project. Also, we studied scenes and saw
    how to create them in a Sprite Kit project. Furthermore, we discussed about transitions
    between scenes and their types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about sprites and texture atlases. Our *Platformer*
    game will become much more exciting and interesting to play, as we move further.
  prefs: []
  type: TYPE_NORMAL
