- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Mobile UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we were introduced to the Unity UI system and how to build
    resolution-independent UI elements, which are useful for all game projects that
    utilize different aspect ratios and resolutions. In this chapter, we will be exploring
    some mobile-specific aspects of working on a UI, such as requiring on-screen controls
    and adapting our UI to fit devices with notches.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be split into a number of topics. The chapter is a simple
    step-by-step process from beginning to end. The following is the outline of our
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pause screen button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an on-screen joystick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting GUIs for notch devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over the course of this chapter, we will take the pause screen that we implemented
    in the previous chapter and adapt it to work on a mobile device. We will then
    implement an on-screen joystick as an additional movement option, and lastly,
    have our UI automatically adapt to fit mobile devices that have notches.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system** **requirements**section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pause screen button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While many mobile games do support controllers through Bluetooth, most, if not
    all, of them allow the users to control the game via just the device. Increasingly,
    many mobile games will include on-screen buttons or analog sticks that players
    can use to control their avatars. In this section, we will see just how we can
    implement that if we wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, let’s build a pause menu button:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are going to be creating multiple types of on-screen controls, let’s
    create a panel to hold them all. From the `On Screen Controls`. From the **Inspector**
    view, remove or disable the **Image** component, as we don’t need to see the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this version of our controls, we will be using some 2D sprites to make it
    easier to tell what the various UI elements are. The sprites are included in the
    example code for this book if you’d like to use the exact ones I’m using.
  prefs: []
  type: TYPE_NORMAL
- en: From the `Sprites` and drag and drop the image files into the newly added folder.
    Since our project is a 3D one, Unity assumes we want them to be textures, but
    we want to use them with Unity’s UI system. With that in mind, select all three
    sprites. From the **Inspector**, change **Texture Type** to **Sprite (2D and UI)**,
    then scroll all the way down, and then hit the **Apply** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The sprites used here are from *Kenney’s Onscreen Controls* pack. There are
    seven other possible styles that you could use, which are available from [https://kenney.nl/assets/onscreen-controls](https://kenney.nl/assets/onscreen-controls).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the sprites, let’s build our first UI element, a pause button.
    From the **Hierarchy** view, right-click on the **On Screen Controls** object
    and select **UI** | **Button -** **TextMeshPro**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new object `Show Pause Button` and use the **Anchor Presets** menu
    to place the object at the bottom right of the screen (use *Alt*+ *Shift*to set
    **Pivot** and **Position** as well).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Bottom-right option](img/B18868_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Bottom-right option
  prefs: []
  type: TYPE_NORMAL
- en: Then, from the **Image** component, drag and drop our **pauseButton** sprite
    into the **Source Image** property. You’ll notice it’s stretched out, so click
    on the **Set Native Size** button to have the sprite automatically resize itself
    for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don’t actually need the text object included, so select the **Text (TMP)**
    object and hit the *Delete* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Creating the pause button](img/B18868_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Creating the pause button
  prefs: []
  type: TYPE_NORMAL
- en: Go back and select the `pause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to **Resume Button** and add another event to its button to turn the
    **Show Pause Menu** button back on when we leave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Creating the Resume Button click action](img/B18868_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Creating the Resume Button click action
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to remove our on-screen controls whenever we pause the game. This
    can be done through **Inspector**, but we can also do this through code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PauseScreenBehaviour` script and add the following property to the
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterward, update the **SetPauseMenu** function to have the following new line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are using `!paused` and not `paused` like in the previous line.
    The `!` operator will take something that is `true` and make it `false`, and vice
    versa. This will cause the `onScreenControls` window to turn on when the game
    is not paused and off when it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are already in the code editor, we can also use this time to fix something
    that will come up later: as mentioned previously, one problem that won’t be apparent
    now unless you restart the level is the fact that `static` variables will keep
    their values each time we reload the game. In our case, we set `paused`, which
    turns `Time.timeScale` to `0`. Thankfully, we can fix this fairly easily.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PauseScreenBehaviour` script and update the `Start` function to have
    the following, replacing the original line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity and go to the **Pause Screen Handler** object. From the **Pause
    Screen Behaviour** script, set the **On Screen Controls** property to our **On
    Screen** **Controls** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Updating Pause Screen Behaviour](img/B18868_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Updating Pause Screen Behaviour
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your script and the scene, and then play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The current state of the game](img/B18868_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: The pause menu now works correctly. This is a simple way to add on-screen controls
    to the screen. A more advanced version would be an analog stick that we can use
    to control the player’s movement. Let’s tackle that next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an on-screen joystick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement this on-screen joystick, we will utilize two images: a background
    image and then a joystick image placed on top of it. We will then write code to
    allow the player to simulate that they are physically moving the joystick. Later,
    we learn how we can have the simulated joystick actually affect the game properly:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Joystick Background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `analogStickBackground` sprite and click on the **Set Native** **Size**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Rect Transform** component, hold down *Alt* **+** *Shift* and use
    the **Anchor Presets** menu to move **Joystick Background** to the bottom-left
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click on the `Joystick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `analogStick` sprite and click on the **Set Native** **Size** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Creating the Joystick UI](img/B18868_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Creating the Joystick UI
  prefs: []
  type: TYPE_NORMAL
- en: We want this joystick to move, so to do that, we will create a new script. From
    the `Scripts` folder and create a new C# script called `MobileJoystick`. Then,
    attach the `MobileJoystick` script to the `Joystick` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your code editor to the `MobileJoystick` script and add the following
    properties and initialization of those properties in the `Start` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To have the joystick do something when we are dragging it, we can add an interface
    to our script for when we are dragging and when we stop. To do so, we need to
    add the following `using` statement to the top of our script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we add the following bold code to the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will get some errors because we haven’t actually defined the functions
    given in the interfaces, let’s do that now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your script and return to the Unity editor. Play the game and try to click
    and drag the analog sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Joysticks can now be moved](img/B18868_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Joysticks can now be moved
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that they functionally work, let’s have them actually affect the game.
    We need to have some way to communicate the information that `MobileJoystick`
    has. To do this, let’s add a new property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following line to the `OnDrag` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following line to the `OnEndDrag` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to go to the `PlayerBehaviour` script. From there, we will add
    a new variable to tell us whether we have a `MobileJoystick` or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way, if the player has turned off `MobileJoystick`, we still want the game
    to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will need to update the `FixedUpdate` function to have the following
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your scripts and return to the Unity editor. Save your scene and then
    play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Joystick moving the player](img/B18868_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Joystick moving the player
  prefs: []
  type: TYPE_NORMAL
- en: In this way, if we have the joystick enabled when the game starts, the game
    will use it to move the player. Alternatively, you can disable the joystick and
    your game will work in the same way as before.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our UI should work for the vast majority of cell phones. However,
    there are certain phones that contain “notches.” We will see how to adjust our
    UI for that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting GUIs for notch devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the first edition of this book, there have been many phones that have
    come out with sensor housings, more commonly known as “notches.” Made popular
    with the iPhone X, this has grown to be a part of many phones that are out right
    now. While some people online state that entire-screen displays are the future,
    iOS devices, Android devices running 9.0 and above, and Unity have added support
    for notches built into devices, and we can use the `Screen.safeArea`property in
    Unity to ensure that all of our content is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we will first go to the main menu to tweak the menu text:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `MainMenu` Scene in the `Scenes` folder. In the *Adding a pause menu*section,
    we saw how we can use the **Panel** object in order to hold the contents we want
    to display. We will use this concept to account for the safe area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the level opened, go to the **Hierarchy** view and create a child panel
    for our title screen to be inside by right-clicking on the **Canvas - Scale w/Screen**
    object and selecting **UI |** **Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Afterward, make **Title Text** a child of the newly created panel by dragging
    and dropping the object on top of the newly created **Panel** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – SafeArea setup](img/B18868_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – SafeArea setup
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Scripts``UISafeAreaHandler`. Double-click on it to open your code
    editor and use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Screen.safeArea` property returns a variable of the `Rect` type, which
    contains an X and Y position and a width and height, just like the `Screen.safeArea`
    will just return `Rect(0, 0, Screen.width, Screen.height)`, which will work due
    to the lack of a notch.
  prefs: []
  type: TYPE_NORMAL
- en: '`Screen.safeArea``Update` function to do modifications.'
  prefs: []
  type: TYPE_NORMAL
- en: We previously saw that anchors can be used to specify the size of a panel. Anchors
    work in viewport space, which is to say that the values go from `(0, 0)` to `(1,
    1)`. Since the `Rect``Screen.safeArea`is in screen (pixel) space, we divide by
    the screen size in pixels to convert to the points to viewport space.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and return to the Unity Editor. Then, attach the **UI Safe Area
    Handler** component to the **Panel** object that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the Unity editor and transition to the `Screen.safeArea` property,
    you should notice the panel tweak its size appropriately to fit everything within
    our screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Adjusting the notch value](img/B18868_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Adjusting the notch value
  prefs: []
  type: TYPE_NORMAL
- en: The **Device Simulator** is a tool that aims to allow developers to see what
    their game will look like on many devices. For more information on it, check out
    [https://docs.unity3d.com/Manual/device-simulator-view.html](https://docs.unity3d.com/Manual/device-simulator-view.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In portrait mode, the top portion of the screen is cut off for the notch and
    the bottom is cut off for the home button. We can also click on the buttons next
    to the **Rotate** text to see how our game will look on the device facing the
    other direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Landscape mode](img/B18868_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Landscape mode
  prefs: []
  type: TYPE_NORMAL
- en: Switching to landscape mode, we lose the left/right side for the notch, and
    on iOS, it cuts off the other side as well. Just as in portrait mode, the top
    is cut off for the home button.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we see that the menu adjusts itself correctly! However, there is
    a chance that the **Play** button no longer works. This is because both of our
    **Canvas** objects are drawn in the same sorting order, which means either can
    be on top of the other, similar to the concept of Z-fighting that you may know
    of if you’ve worked on 2D games in the past. Thankfully, we can fix that pretty
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `-1`. The button with a `0` will always be on top of the contents
    of this Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the semi-transparent white panel is useful in illustrating the concept,
    we don’t actually want our users to see it when the game is being played. With
    that in mind, let’s turn off the image.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Panel** object. From the **Image** component, uncheck the checkbox
    to the left of the component’s name to disable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to still have the image visible and have the button still work,
    you can instead uncheck the **Raycast** **Target** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the first Canvas is completed, we can now do the same actions for
    the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the **Canvas - Scale Physical** component and create another **Panel**
    object with the **UI Safe Area Handler** component attached to it, making sure
    to disable the **Image** component. Next, make the **Play** button a child of
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.12 – Adjusting the\uFEFF Safe Area Handler](img/B18868_05_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Adjusting the Safe Area Handler
  prefs: []
  type: TYPE_NORMAL
- en: Save your Scene. Now that we have the main menu completed, we can tweak the
    `Gameplay` Scene as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Gameplay` Scene, select the **On Screen Controls** object, and then
    just add the **UI Safe Area Handler** component to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Making the On Screen Controls use the UI Safe Area](img/B18868_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Making the On Screen Controls use the UI Safe Area
  prefs: []
  type: TYPE_NORMAL
- en: To adjust the **Pause Menu**, we don’t want to change the **Pause Menu** object
    as we want the black screen even in the notch areas. We have previously created
    a panel to hold the contents of the pause menu, but that object is using the **Aspect
    Ratio Fitter**, which will overwrite any anchor changes we would make in the code.
    To keep this functionality as well as **Content Size Fitters** in the child objects,
    we can just create a parent panel to act as a holder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the **Pause Menu** object active again by selecting it in the **Hierarchy**
    window and then clicking on the checkbox by its name in the **Inspector** window.
    Right-click on the **Panel** object and create a **Panel** object by right-clicking
    and selecting **UI | Panel**. In the new panel, add the **UI Safe Area Handler**
    component and disable the **Image** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Adjusting the Pause Menu to work with notches](img/B18868_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Adjusting the Pause Menu to work with notches
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since we are not working with the **Pause Menu** object anymore, select
    the **Pause Menu** object from the **Hierarchy** window, and in the **Inspector**
    window, uncheck the checkbox by the name to disable the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save your Scene and play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – UI now responds correctly to notches](img/B18868_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – UI now responds correctly to notches
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if we hold down the spacebar, we can see both menus working
    correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we integrated the pause menu into our game itself and made
    it work with everything in our project. We then saw how we could create on-screen
    controls to give players another way to interact with the game using mobile devices.
    Finally, we saw how to have our game automatically adapt to fit within the allotted
    safe areas to handle the notches on phones. We will be exploring the previous
    concepts more deeply in later chapters, so keep these explanations in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into monetization and take a look at just
    how we can add Unity ads to our project.
  prefs: []
  type: TYPE_NORMAL
