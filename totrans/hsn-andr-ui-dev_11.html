<html><head></head><body>
        

                            
                    <h1 class="header-title">Polishing Your Design</h1>
                
            
            
                
<p>Application polish is one of the more subtle areas of the user experience. The mix of colors, fonts, and animations are generally not something that users register on a conscious level, but this doesn't mean they're not important. While the choice of colors doesn't directly affect the application's functionality, it does affect the usability of the application. These choices can also be the difference between a user completing a sale through your application, or the same user uninstalling it.</p>
<p>Android has a massive array of tools that you can use to polish your application. Applying branding, colors, and extensive theming to your application can be done in ways that allow you to maintain a distinct look and feel, while still following Material Design guidelines and without building any custom widgets. In fact, most graphical effects for widgets on Android can be achieved purely through styling. In this chapter, we'll explore the given topics:</p>
<ul>
<li style="font-weight: 400">How to choose and apply colors to an application</li>
<li style="font-weight: 400">How and when to generate color palettes dynamically</li>
<li style="font-weight: 400">Creating and applying animations, and when to do so</li>
<li style="font-weight: 400">Defining and using custom styles for widgets</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing colors and theming</h1>
                
            
            
                
<p>Colors are one of the least understood and most important aspects of your user interface design. Text colors must stand out from the background colors to keep text legible, but not too much either. Color choices should follow a palette throughout the application and should reflect the application's branding, but should also help convey meaning to the user. Choosing the right mix of colors will maximize the usability of your application, while helping reduce the user's cognitive load. The wrong color combinations will make text more difficult to read, cause eye strain, and increase the user's levels of cognitive fatigue.</p>
<p>When you apply custom colors to your application, it's important to ensure that you don't have too many colors, and that they are applied consistently within the application. Color conveys meaning; it can be used to tell the user that the <em>new</em> button is the opposite of the <em>delete</em> button. These styles should be defined as resources and applied consistently throughout your application. Consistent styling helps the user understand each screen in the application more quickly, by telling them what they are looking at. Typically, style information is defined in the <kbd>res/values/styles.xml</kbd> file of your project. This is an excellent starting point in our exploration of colors and in polishing your application. If you open the <kbd>res/values/styles.xml</kbd> file of the travel claim example app, you'll see something like this near the top of the file:</p>
<pre>&lt;!-- Base application theme. --&gt;<br/>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;<br/>    &lt;!-- Customize your theme here. --&gt;<br/>    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;<br/>    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;<br/>    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;<br/>&lt;/style&gt;</pre>
<p>This defines a style named <kbd>AppTheme</kbd>, which is applied to your entire application from the <kbd>AndroidManifest.xml</kbd> file. The style declares that its parent is the <kbd>Theme.AppCompat.Light.DarkActionBar</kbd> style, which is imported from the <kbd>app-compat</kbd> library (in your <kbd>build.gradle</kbd> dependencies). The parent of the style is a bit like the parent of a class; it defines all the defaults, and you can override them in the child style. In the default <kbd>AppTheme</kbd> style, there are three colors that are overridden with references to color resources: primary, primary-dark, and accent. These colors are used all over the <kbd>AppTheme</kbd> for the backgrounds of the <kbd>Toolbar</kbd> objects, buttons, floating action buttons, and so on. Primary is used for the background of a <kbd>Toolbar</kbd> and <kbd>FloatingActionButton</kbd> by default, primary-dark is used for the status bar background, and accent is used for the foreground of <kbd>FloatingActionButton</kbd> and the labels above the <kbd>TextInputLayout</kbd> widgets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Producing an application palette</h1>
                
            
            
                
<p>The first thing to do when applying colors to your application is to decide on your application color scheme, or palette. A <strong>palette</strong> is a small group of colors that form the basis of your theme, and can be adjusted (typically by making them brighter or darker) to produce a wide range of colors that will all look similar enough to be seen as part of the same theme.</p>
<p class="mce-root">It's best to use a good color designing or palette construction tool. An excellent one is <strong>Paletton</strong>, which is available at <a href="http://paletton.com" target="_blank">http://paletton.com</a> for free (another good tool is <a href="https://www.materialpalette.com/" target="_blank">https://www.materialpalette.com/</a>). For this section, we'll use Paletton to define a basic color palette for the travel claims application example; let's get started:</p>
<ol>
<li style="font-weight: 400">Navigate to <a href="http://paletton.com">http://paletton.com</a> in your web browser of choice.</li>
<li style="font-weight: 400">There are two major parts to the Paletton application; on the left is a color-wheel with draggable handles that allow you to select a primary color (the secondary colors are derived automatically using various available algorithms). On the right of the application is the palette sample for the application:</li>
</ol>
<div><img height="175" width="369" src="img/b03c436e-1179-4ad0-900d-fc3266da5c06.png"/></div>
<ol start="3">
<li style="font-weight: 400">Use the <strong>Scheme Type</strong> selector to choose the second type of color scheme: Adjacent colors (3-colors).</li>
<li style="font-weight: 400">To the right of the Scheme Type selector, use the small toggle button to turn on add complementary. This will add a complimentary color to your palette. A complementary color will be on the opposite side of the color-wheel to your main color, and will serve as <em>accent</em> color.</li>
</ol>
<ol start="5">
<li style="font-weight: 400">Adjust the base color and shades until the palette preview on the right is a combination you are happy with:</li>
</ol>
<div><img height="225" width="264" src="img/68b3551e-2b20-4aba-ad28-2c111f4b3128.png"/></div>
<ol start="6">
<li style="font-weight: 400">By clicking on any of the boxes in the palette preview and then their hex codes, you can copy the RGB hex code to the clipboard and paste it into Android Studio:</li>
</ol>
<div><img height="242" width="374" src="img/c73fd892-7a74-49f8-884e-8612b571ec9e.png"/></div>
<ol start="7">
<li>Ensure that you use colors from the top-left box for your primary and primaryDark colors, while you use a color from the bottom-right box for the accent color.</li>
</ol>
<ol start="8">
<li style="font-weight: 400">In Android Studio, use Tools | Android | Theme Editor to open the Android Theme Editor.</li>
<li>In the Theme panel on the right-hand side, you'll find a list of colors that define your theme:</li>
</ol>
<div><img height="321" width="358" src="img/fde5ec77-f9fd-41bd-b1bc-1218e3a69c74.png"/></div>
<ol start="10">
<li>Click on the color buttons in the Theme Editor to open a color editor. Copy the colors from Paletton into the theme editor for primary, primary-dark, and accent.</li>
</ol>
<p>If you run the travel claim example application now, you'll see that the entire application has a completely new theme. The floating action button will be the same color as the underline on the <kbd>EditText</kbd> widget. This will be your accent color, while the background of your <kbd>Toolbar</kbd> will be your primary color.</p>
<p>It' generally best to use your primary color's complementary color as your accent color. This is the color that is on the opposite side of color wheel, and will normally have an excellent contrast against your primary color. The contrast will help readability and reduce eye strain. It's important to ensure legibility for everyone, and Paletton includes a Vision simulation option below the palette preview that can be used to test your palette for various types of colorblindness.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating palettes dynamically</h1>
                
            
            
                
<p>There are times when you're not sure what your palette should be ahead of time. There are also times that you would like the color scheme to match some user content, such as a photo or the album art for the music they're listening to. In cases like these, it's nice to be able to grab the key colors from an image and produce a palette that will match them. The problem is that the palette still needs to not be too jarring, and your text still needs to be legible against the background color. These are pretty hard problems to solve in pure code, but Android support libraries have an excellent little tool that does exactly this--the <kbd>Palette</kbd> API.</p>
<p class="mce-root">A very useful way of using generated palettes is to colorize cards with different icons according to the colors in the icon. Let's write a <kbd>CardView</kbd> implementation that can colorize its contents according to a generated palette:</p>
<ol>
<li style="font-weight: 400">You'll first need to add the <kbd>Palette</kbd> API to your project. In the travel claim app, open the app module's <kbd>build.gradle</kbd> file in Android Studio.</li>
<li style="font-weight: 400">In the <kbd>dependencies</kbd> at the bottom of the file, include the <kbd>Palette</kbd> API by declaring this:</li>
</ol>
<pre style="padding-left: 60px">implementation 'com.android.support:palette-v7:+'</pre>
<ol start="3">
<li style="font-weight: 400">Click on the Sync Now link that appears at the top of the editor panel.</li>
<li style="font-weight: 400">Right-click on the widget's package and select New| Java Class.</li>
<li style="font-weight: 400">Name the new class <kbd>ColorizedCardView</kbd>.</li>
<li style="font-weight: 400">Change the <kbd>Superclass</kbd> to <kbd>android.support.v7.widget.CardView</kbd>.</li>
<li style="font-weight: 400">Add <kbd>android.support.v7.graphics.Palette.PaletteAsyncListener</kbd> to the Interface(s).</li>
<li style="font-weight: 400">Click OK to create the new class.</li>
<li style="font-weight: 400">Add the required <kbd>View</kbd> constructors so that the class can be used from XML files:</li>
</ol>
<pre style="padding-left: 60px">public ColorizedCardView(final Context context) {<br/>  super(context);<br/>}<br/><br/>public ColorizedCardView(<br/>      final Context context,<br/>      final AttributeSet attrs) {<br/>  super(context, attrs);<br/>}<br/><br/>public ColorizedCardView(<br/>      final Context context,<br/>      final AttributeSet attrs,<br/>      final int defStyleAttr) {<br/>  super(context, attrs, defStyleAttr);<br/>}</pre>
<ol start="10">
<li>The <kbd>ColorizedCardView</kbd> doesn't just change its own background, it needs to change the color of any text as well so that the text remains legible to the user. This means that the <kbd>ColorizedCardView</kbd> needs to find all the <kbd>TextView</kbd> instances that don't have their background <kbd>Drawable</kbd> set (a <kbd>Button</kbd> is just a <kbd>TextView</kbd> with a specialized background, and we want to leave that as is). This method will traverse (depth-first) into the <kbd>ColorizedCardView</kbd>, and add any <kbd>TextView</kbd> objects it finds to a <kbd>Collection</kbd>:</li>
</ol>
<pre style="padding-left: 60px">static Collection&lt;TextView&gt; findTextViews(<br/>    final ViewGroup viewGroup,<br/>    final Collection&lt;TextView&gt; textViews) {<br/><br/>  final int childCount = viewGroup.getChildCount();<br/>  for (int i = 0; i &lt; childCount; i++) {<br/>    final View child = viewGroup.getChildAt(i);<br/><br/>    if (child instanceof ViewGroup) {<br/>      // recurse downwards<br/>      findTextViews((ViewGroup) child, textViews);<br/>    } else if (child instanceof TextView<br/>          &amp;&amp; child.getBackground() == null) {<br/>      textViews.add((TextView) child);<br/>    }<br/>  }<br/><br/>  return textViews;<br/>}</pre>
<ol start="11">
<li>Each <kbd>Palette</kbd> is actually a list of <kbd>Swatch</kbd> objects, each one containing a base color and colors suitable for heading text and body text. The <kbd>ColorizedCardView</kbd> allows you to specify a <kbd>Swatch</kbd> directly to colorize the background and all the text:</li>
</ol>
<pre style="padding-left: 60px">public void setSwatch(final Palette.Swatch swatch) {<br/>  setCardBackgroundColor(swatch.getRgb());<br/><br/>  final Collection&lt;TextView&gt; textViews = findTextViews(<br/>      this, new ArrayList&lt;TextView&gt;()<br/>  );<br/><br/>  if (!textViews.isEmpty()) {<br/>    for (final TextView textView : textViews) {<br/>      textView.setTextColor(swatch.getBodyTextColor());<br/>    }<br/>  }<br/>}</pre>
<ol start="12">
<li>When a <kbd>Palette</kbd> is generated, it can have any number of <kbd>Swatch</kbd> objects. There are a selection of <em>standard</em> swatches that are normally generated when you create a <kbd>Palette</kbd> from a <kbd>Bitmap</kbd>, but any number of them may remain unpopulated (<kbd>null</kbd>). When you colorize the card by a <kbd>Palette</kbd> object, you'll need to look for an available <kbd>Swatch</kbd>; in the <kbd>ColorizedCardView</kbd> implementation. We'll favor <em>light</em> swatches over <em>dark</em> swatches, and <em>muted</em> swatches over <em>vibrant</em>:</li>
</ol>
<pre style="padding-left: 60px">public void setPalette(final Palette palette) {<br/>  if (palette.getLightMutedSwatch() != null) {<br/>    setSwatch(palette.getLightMutedSwatch());<br/>  } else if (palette.getLightVibrantSwatch() != null) {<br/>    setSwatch(palette.getLightVibrantSwatch());<br/>  } else if (palette.getDarkMutedSwatch() != null) {<br/>    setSwatch(palette.getDarkMutedSwatch());<br/>  } else if (palette.getDarkVibrantSwatch() != null) {<br/>    setSwatch(palette.getDarkVibrantSwatch());<br/>  }<br/>}</pre>
<p>You may need to adjust the ordering of this method in your application, depending on the colors chosen for the rest of the application. Typically, muted colors cause less eye strain for your users, but you may want to colorize action buttons using vibrant colors to draw attention to them.</p>
<ol start="13">
<li>Now, we need a way to specify a <kbd>Bitmap</kbd> to colorize the entire <kbd>ColorizedCardView</kbd> with. The <kbd>Palette</kbd> uses a <kbd>Builder</kbd> object to generate its swatches, and has its own built-in <kbd>AsyncTask</kbd> to handle generating the <kbd>Palette</kbd> on a background thread (which can take a few seconds on larger images or slower devices). The <kbd>setColorizeBitmap</kbd> method is defined so that it's easy to invoke from a data-bound layout XML file. The <kbd>Palette.Builder</kbd> needs a callback to handle the generated <kbd>Palette</kbd>, which will be the <kbd>ColorizedCardView</kbd> instance (remember that you've implemented the <kbd>PaletteAsyncListener</kbd> interface):</li>
</ol>
<pre style="padding-left: 60px">public void setColorizeBitmap(final Bitmap image) {<br/>  new Palette.Builder(image).generate(this);<br/>}<br/><br/>@Override<br/>public void onGenerated(final Palette palette) {<br/>  setPalette(palette);<br/>}</pre>
<ol start="14">
<li>You'll also need a way to colorize the <kbd>ColorizedCardView</kbd> based on a <kbd>Drawable</kbd> object, which will offer better interoperability with application <kbd>Resources</kbd>. The following <kbd>renderDrawable</kbd> method has a shortcut if the <kbd>Drawable</kbd> object is a <kbd>BitmapDrawable</kbd> (which simply wraps a <kbd>Bitmap</kbd>); otherwise, it'll try and render the <kbd>Drawable</kbd> to a <kbd>Bitmap</kbd> object. As a <kbd>Drawable</kbd> has bounds that include its position (and not just its size), you'll need to translate the <kbd>Canvas</kbd> that it's going to draw on so that it renders in the top-left corner of the <kbd>Bitmap</kbd>:</li>
</ol>
<pre>private Bitmap renderDrawable(final Drawable drawable) {<br/>  if (drawable instanceof BitmapDrawable) {<br/>    return ((BitmapDrawable) drawable).getBitmap();<br/>  }<br/><br/>  final Rect bounds = drawable.getBounds();<br/>  final Bitmap bitmap = Bitmap.createBitmap(<br/>      bounds.width(),<br/>      bounds.height(),<br/>      Bitmap.Config.ARGB_8888<br/>  );<br/><br/>  final Canvas canvas = new Canvas(bitmap);<br/>  canvas.translate(-bounds.left, -bounds.top);<br/>  drawable.draw(canvas);<br/><br/>   return bitmap;<br/>}<br/><br/>public void setColorizeDrawable(final Drawable drawable) {<br/>  setColorizeBitmap(renderDrawable(drawable));<br/>}</pre>
<p>To use the <kbd>ColorizedCardView</kbd> in the travel claim application, you can find and download colored icons for all the categories and change the <kbd>ItemPresenter</kbd> to use them, instead of the standard black icons we imported from the Material Icons set. An excellent resource for finding icons and sets of icons is Iconfinder--<a href="https://www.iconfinder.com/" target="_blank">https://www.iconfinder.com/</a>. Iconfinder allows you to search for and filter icon sets according to your criteria, and purchase or download the icons you need for your application.</p>
<p>To change the overview screen to use your favorite colorful icons, follow these steps:</p>
<ol>
<li>Place your new icons in the <kbd>res/drawable</kbd> directory of your application; ensure that you download PNG icons so that they can be read by Android.</li>
<li>Open the <kbd>card_claim_item</kbd> layout resource in Android Studio.</li>
<li>Change to the Text editor.</li>
<li>Change the declaration of the <kbd>CardView</kbd> to a <kbd>ColorizedCardView</kbd>, and use the <kbd>app:colorizeDrawable</kbd> data binding attribute to invoke <kbd>setColorizeDrawable</kbd> with the same <kbd>Drawable</kbd> that will be rendered as the icon:</li>
</ol>
<pre style="padding-left: 60px">&lt;com.packtpub.claim.widget.ColorizedCardView<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:layout_marginTop="@dimen/grid_spacer1"<br/>    android:foreground="?attr/selectableItemBackground"<br/>    android:onClick="@{() -&gt; presenter.viewClaimItem(item)}"<br/>    <strong>app:colorizeDrawable="@{presenter.getCategoryIcon(item.category)}"</strong></pre>
<ol start="5">
<li>Open the <kbd>ItemPresenter</kbd> Java source file.</li>
<li>Change the icons returned by the <kbd>getCategoryIcon</kbd> method to return your new icons, instead of those used by the category selector:</li>
</ol>
<pre style="padding-left: 60px">public Drawable getCategoryIcon(final Category category) {<br/>  final Resources resources = context.getResources();<br/>  switch (category) {<br/>    case ACCOMMODATION:<br/>        return resources.getDrawable(<strong>R.drawable.hotel</strong>);<br/>    case FOOD:<br/>        return resources.getDrawable(<strong>R.drawable.dinner</strong>);<br/>    case TRANSPORT:<br/>        return resources.getDrawable(<strong>R.drawable.airplane</strong>);<br/>    case ENTERTAINMENT:<br/>        return resources.getDrawable(<strong>R.drawable.clapboard</strong>);<br/>    case BUSINESS:<br/>        return resources.getDrawable(<strong>R.drawable.briefcase</strong>);<br/>    case OTHER:<br/>    default:<br/>        return resources.getDrawable(<strong>R.drawable.misc</strong>);<br/>  }<br/>}</pre>
<div><p>The icon names used earlier are just an example; you'll need to use the names of the icon files you downloaded and placed in the <kbd>drawable</kbd> directory.</p>
</div>
<p>The <kbd>ColorizedCardView</kbd> is a very useful and generic implementation of colorization using the <kbd>Palette</kbd> class. Using the bold background colors on each card makes them quickly recognizable to the user, and allows the user to more quickly find what they are looking for in a long scrolling list of items. As it can be automatically colorized using data binding, the <kbd>ColorizedCardView</kbd> can be populated with virtually any content.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding animations</h1>
                
            
            
                
<p>Animations may appear to just be a nice bit of polishing on top of your user interface, but they can also serve an important purpose. In any design, whether it's a building, an API, or a user interface, it's good to try and follow a principle of <em>least surprise</em>. Try and offer your user things that make sense without them having to try and understand the details of how it works. A good example of violating this principle is when a button is wired incorrectly. If you were to press the <em>copy</em> button on a printer, and instead of making a copy it printed a test page, this would be a surprise. You expected the machine to do one thing because of the label, but it did something unexpected.</p>
<p>It's always important to consider what your user will expect to happen when they look at or use your application's user interface. Using well-known names and icons for the elements of a user interface help make it instantly understood by your user, but sometimes your application will change what is on the screen without being entirely obvious as to <em>what has changed</em>. In cases like this, animations become essential to tell users what has happened. A good example of using animation to express a change is the automatic animations you added to the <kbd>RecyclerView</kbd> using the <kbd>DiffUtil</kbd> class. When the user adds a new claim item, it appears in the list at the correct position, but an animation will draw the user's attention to where it has appeared and let them know that it's the new item.</p>
<p class="mce-root">Animations have to strike a careful balance. However, if everything is animated, then the user can become frustrated by the extra time being taken by the animations. This leads to another important factor--animations should be quick. The Android platform defines a <em>short</em> animation as just <em>200 milliseconds</em>, just one-fifth of a second.</p>
<p class="mce-root">You've already added implicit animations to the travel claim application using the <kbd>RecyclerView</kbd> and <kbd>DiffUtil</kbd>. <strong>Implicit animations</strong> are all over in the Android platform and cover a wide range of everyday cases, such as the changes in the <kbd>RecyclerView</kbd> contents. There are also ways to add your own animations to layouts and widgets, and there are several widgets that are specifically designed to render animations and transitions.</p>
<p class="mce-root">Within layout animations, there are four basic actions that an animation can perform on a widget or group of widgets that are being animated.</p>
<p>A widget can be translated, which involves moving it left or right, up or down (or any combination of those), as shown here:</p>
<div><img src="img/e38a3010-0b55-4013-a1fa-795839b533d4.jpg"/></div>
<p>An animation can also scale a widget. This involves changing its size to make it appear larger or smaller. Scaling, like translation, can be applied on either the horizontal (x) axis, or the vertical (y) axis, or both of them together:</p>
<div><img src="img/677c2a6b-0de2-4107-9d22-82dbfa5fc502.jpg"/></div>
<p>You can also have an animation rotate the widget. Rotation is not a natural change for a user interface widget, as typically, all widgets are layouts out of a box-like grid. Rotation can be very useful, and can produce a pleasing effect when applied to widgets that appear to be round (such as a <kbd>FloatingActionButton</kbd> or a circular avatar):</p>
<div><img src="img/fc54fe9b-5e44-42dd-ad28-70ee671ad406.jpg"/></div>
<p>While all the first three transformations are concerned with the physical structure of the widget being animated, the fourth one changes how opaque it is. The alpha transformation allows you to produce animations where widgets appear to fade-in or fade-out:</p>
<div><img src="img/11c9b8a9-cbf7-4e62-920c-d0fd3d27305b.jpg"/></div>
<p>These four animation actions can be combined into what Android calls a <strong>set</strong>. A <em>set</em> is a group of animation actions that will all appear to happen at the same time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating custom animations</h1>
                
            
            
                
<p>Android animations are in fact resource files, much like an icon or a layout. The animations that apply to layouts and widgets are XML files that define the various transformations and are placed in the <kbd>res/anim</kbd> directory. Android provides a small selection of simple animations that you can use in your application, without needing to build your own:</p>
<ul>
<li style="font-weight: 400"><kbd>android.R.anim.fade_in</kbd> - <kbd>@android:anim/fade_in</kbd></li>
<li style="font-weight: 400"><kbd>android.R.anim.fade_out</kbd> - <kbd>@android:anim/fade_out</kbd></li>
<li style="font-weight: 400"><kbd>android.R.anim.slide_in_left</kbd> - <kbd>@android:anim/slide_in_left</kbd></li>
<li style="font-weight: 400"><kbd>android.R.anim.slide_out_right</kbd> - <kbd>@android:anim/slide_out_right</kbd></li>
</ul>
<p>These four animations cover two different types of transition: fading out and in, or sliding the widgets from left to right. Nothing stops you from mixing them together, for example, fading the widget out and then sliding a new one in from the left.</p>
<p class="mce-root">To do these sorts of transitions, there are a family of Android widgets that will manage the animation for you. These can either focus on animating the content (that is, text or an image), or they transition through a list of child widgets. The base of these classes is <kbd>android.widget.ViewAnimator</kbd>, and the best-known implementations are these:</p>
<ul>
<li style="font-weight: 400"><kbd>TextSwitcher</kbd>: Behaves like an animated <kbd>TextView</kbd>; each time its text is changed, it animates between the old text and the new text</li>
<li style="font-weight: 400"><kbd>ImageSwitcher</kbd>: Just like <kbd>TextSwitcher</kbd>, but for images</li>
<li style="font-weight: 400"><kbd>ViewFlipper</kbd>: It is used like a <kbd>FrameLayout</kbd>, but only one of its children is shown at a time, and you can have it animate between them</li>
</ul>
<p>Let's create two new animation sets to animate some text, and change the category label in the <kbd>CategoryPickerFragment</kbd> to use a <kbd>TextSwitcher</kbd>:</p>
<ol>
<li style="font-weight: 400">Right-click on the res directory in the travel claim example app and select New | Android resource file.</li>
<li style="font-weight: 400">Name the new file <kbd>slide_in_top</kbd>.</li>
<li style="font-weight: 400">Change the Resource type to Animation (not Animator):</li>
</ol>
<div><img height="162" width="479" src="img/63c504aa-d97f-49d2-82ca-4005d9a06fd3.png"/></div>
<div><p>An <kbd>Animator</kbd> allows the direct manipulation of any property in any Java Object; while this is a very powerful system to use, it does not work with classes such as <kbd>TextSwitcher</kbd>. <kbd>Animation</kbd> refers to the <em>view animation</em> system, which is designed specifically for animating widgets, and has various performance enhancements in the layout system to avoid the user interface stuttering during animations.</p>
</div>
<ol start="4">
<li>Click OK to create the new animation XML resource.</li>
<li>On the <kbd>&lt;set&gt;</kbd> element, we need to define how long the animation will take, and the interpolator. The <strong>interpolator</strong> defines the relative motion of the animation. Does it happen with linear smoothness (which often appears artificial, but is the easiest), or does the animation appear to <em>bounce</em>, or something else entirely? In this case, we will use the standard <kbd>anticipate_overshoot_interpolator</kbd>, which includes a small <em>bounce</em> effect at the end of the animation:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;set <br/>    <strong>android:interpolator="@android:anim/anticipate_overshoot_interpolator"</strong><br/><strong>    android:shareInterpolator="true"</strong><br/><strong>    android:duration="@android:integer/config_shortAnimTime"</strong>&gt;<br/>&lt;/set&gt;</pre>
<ol start="6">
<li>This animation will consist of two parts. The first part is a translation from offscreen, downward to where the text should normally appear. The second part is a fade in from fully transparent to opaque. Each action taken by a view animation is defined in terms of what the value should be when the animation starts, and what the value should be when it stops (from and to). The values in between are defined by the time of each frame, and the interpolator. Inside the <kbd>&lt;set&gt;</kbd> element, add a <kbd>translation</kbd> to bring the view along the y-axis from above where it ends:</li>
</ol>
<pre style="padding-left: 60px">&lt;translate<br/>    android:fromYDelta="-50%p"<br/>    android:toYDelta="0" /&gt;</pre>
<ol start="7">
<li>Now, add the fade-in using an <kbd>alpha</kbd> action. A zero alpha value indicates that the widget should be invisible, while a one indicates that it should be fully opaque. The alpha is a floating-point number, so you can define any value between zero and one for partial transparency:</li>
</ol>
<pre>&lt;alpha<br/>    android:fromAlpha="0.0"<br/>    android:toAlpha="1.0" /&gt;</pre>
<ol start="8">
<li>While a single animation is nice, you need two animations running together to create a <em>transition</em>. Right-click on the new <kbd>res/anim</kbd> directory and select New| Animation resource file.</li>
<li style="font-weight: 400">Name the new animation <kbd>slide_out_bottom</kbd>.</li>
<li style="font-weight: 400">Click OK to create the new resource file.</li>
<li style="font-weight: 400">This animation works the same way as <kbd>slide_in_top</kbd>, but pushes the view downward and makes it transparent:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;set <br/>    android:interpolator="@android:anim/anticipate_overshoot_interpolator"<br/>    android:shareInterpolator="true"<br/>    android:duration="@android:integer/config_shortAnimTime"&gt;<br/><br/>    &lt;translate<br/>        android:fromYDelta="0"<br/>        android:toYDelta="50%p" /&gt;<br/><br/>    &lt;alpha<br/>        android:fromAlpha="1.0"<br/>        android:toAlpha="0.0" /&gt;<br/>&lt;/set&gt;</pre>
<ol start="12">
<li style="font-weight: 400">Now, you'll need to change the <kbd>CategoryPickerFragment</kbd> to use a <kbd>TextSwitcher</kbd> instead of a <kbd>TextView</kbd>. Start by opening the <kbd>fragment_category_picker</kbd> layout resource file and change to the Text editor.</li>
<li style="font-weight: 400">Locate the <kbd>TextView</kbd> at the bottom of the file, and change it to be a <kbd>TextSwitcher</kbd>. A <kbd>TextSwitcher</kbd> needs two <kbd>TextView</kbd> child elements to animate between. Each time you change the text on the <kbd>TextSwitcher</kbd>, it puts the new text on the invisible <kbd>TextView</kbd> and then animates between the visible <kbd>TextView</kbd> and the invisible one (that is, it switches them around and hence its name). You'll need to tell the <kbd>TextSwitcher</kbd> to use the animation resources you just created as its <em>in</em> and <em>out</em> animations:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextSwitcher<br/>    android:id="@+id/selected_category"<br/>    android:inAnimation="@anim/slide_in_top"<br/>    android:outAnimation="@anim/slide_out_bottom"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"&gt;<br/><br/>    &lt;TextView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:textAppearance="@style/TextAppearance.AppCompat.Medium" /&gt;<br/><br/>    &lt;TextView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:textAppearance="@style/TextAppearance.AppCompat.Medium" /&gt;<br/>&lt;/TextSwitcher&gt;</pre>
<ol start="14">
<li>Open the <kbd>CategoryPickerFragment</kbd> source file and change the references to the <kbd>TextView</kbd> to a <kbd>TextSwitcher</kbd>. There will be one as a field, and the other should be in the <kbd>onCreateView</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">private RadioGroup categories;<br/><strong>private TextSwitcher categoryLabel;</strong><br/><br/>// …<br/><br/>categories = (RadioGroup) picker.findViewById(R.id.categories);<br/><strong>categoryLabel = (TextSwitcher) picker.findViewById(R.id.selected_category);</strong></pre>
<ol start="15">
<li>Open the <kbd>IconPickerWrapper</kbd> source file. This currently wraps a <kbd>TextView</kbd>, but will now need to wrap a <kbd>TextSwitcher</kbd>. Like the <kbd>CategoryPickerFragment</kbd>, change the references from <kbd>TextView</kbd> to <kbd>TextSwitcher</kbd>:</li>
</ol>
<pre style="padding-left: 60px">private final TextSwitcher label;<br/>public IconPickerWrapper(final TextSwitcher label) {<br/>    this.label = label;<br/>}</pre>
<p>That's all you need to do in this case; the <kbd>CaptureClaimActivity</kbd> will now have a very pleasing animation on the text in the category chooser, which indicates that the icons are used to change the category. While a <kbd>TextSwitcher</kbd> doesn't subclass <kbd>TextView</kbd>, it does expose the same critical method for these cases--<kbd>setText(CharSequence)</kbd>. Unfortunately, this means that you can't substitute the classes directly one for the other. Instead, you'll need to treat each as a separate type (as earlier). You can, however, create <kbd>abstract</kbd> <kbd>wrapper</kbd> class to wrap these two and allow your layout to define whether there should be animations or not:</p>
<pre class="CDPAlignLeft CDPAlign">public abstract class TextWrapper&lt;V extends View&gt; {<br/>  public final V view;<br/><br/>  public TextWrapper(final V view) {<br/>    this.view = view;<br/>  }<br/><br/>  public abstract void setText(CharSequence text);<br/><br/>  public abstract CharSequence getText();<br/><br/>  public static TextWrapper&lt;TextView&gt; wrap(final TextView tv) {<br/>    return new TextWrapper&lt;TextView&gt;(tv) {<br/>        @Override<br/>        public void setText(final CharSequence text) {<br/>          view.setText(text);<br/>        }<br/><br/>        @Override<br/>        public CharSequence getText() {<br/>          return view.getText();<br/>        }<br/>      };<br/>  }<br/><br/>  public static TextWrapper&lt;TextSwitcher&gt; wrap(final TextSwitcher ts) {<br/>    return new TextWrapper&lt;TextSwitcher&gt;(ts) {<br/>        @Override<br/>        public void setText(final CharSequence text) {<br/>          view.setText(text);<br/>        }<br/><br/>        @Override<br/>        public CharSequence getText() {<br/>          return ((TextView) view.getCurrentView()).getText();<br/>        }<br/>    };<br/>  }<br/><br/>  public static TextWrapper&lt;?&gt; wrap(final View v) {<br/>    if (v instanceof TextView) {<br/>      return wrap((TextView) v);<br/>    } else if (v instanceof TextSwitcher) {<br/>      return wrap((TextSwitcher) v);<br/>    } else {<br/>      throw new IllegalArgumentException("unknown text view: " + v);<br/>    }<br/>  }<br/>}</pre>
<p>This class can be used to wrap references to widgets that can be either <kbd>TextView</kbd> or <kbd>TextSwitcher</kbd>, depending on the context. This allows you to reuse more of your Java code when dealing with cases where some screens require a simple layout, while others require animations. It's generally a useful pattern to remember, because it reduces the coupling between your user interface and your code when you can't use the class inheritance, and want to avoid casting.</p>
<p class="mce-root">Data binding can also be used to solve this problem. By having the <kbd>CategoryPickerFragment</kbd>, use a data-bound layout; the <kbd>TextSwitcher</kbd> will automatically animate when the model was changed by the user clicking on the <kbd>RadioButton</kbd> widgets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Activating more animations</h1>
                
            
            
                
<p>There are some other small ways in which Android can provide your application with animations that let the user know what is going on. For example, you can tell any <kbd>ViewGroup</kbd> implementation (any of the <kbd>Layout</kbd> classes: <kbd>FrameLayout</kbd>, <kbd>LinearLayout</kbd>, or <kbd>ConstraintLayout</kbd>) to animate the changes to the layout. You do this by simply turning on <kbd>animateLayoutChanges</kbd> in your layout resource:</p>
<pre>&lt;android.support.v7.widget.CardView<br/><strong>    android:animateLayoutChanges="true"</strong><br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;</pre>
<p>This is especially useful when you offer the ability to <em>unfold</em> a card to expose more functionality or more information. Coupling the <kbd>animateLayoutChanges</kbd> attribute with the <kbd>ViewGroup</kbd> class is a very powerful combination. <kbd>ViewStub</kbd> is a special type of widget that can be used like an <kbd>&lt;include&gt;</kbd>, that only loads when you tell it to. When it's loaded, it doesn't act as a container, but <em>replaces itself</em> with the layout it has loaded. Using <kbd>animateLayoutChanges</kbd> inflating a <kbd>ViewStub</kbd> can automatically trigger a nice animation to reveal the new content to the user. The following code snippet is a <kbd>CardView</kbd> that will animate the inflation of a menu that can be made to appear at the bottom of the card:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.v7.widget.CardView<br/>    <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    app:contentPadding="@dimen/grid_spacer1"&gt;<br/><br/>    &lt;android.support.constraint.ConstraintLayout<br/>        <strong>android:animateLayoutChanges="true"</strong><br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"&gt;<br/><br/>        &lt;ImageView<br/>            android:id="@+id/imageView"<br/>            android:layout_width="48dp"<br/>            android:layout_height="48dp"<br/>            app:layout_constraintStart_toStartOf="parent"<br/>            app:layout_constraintTop_toTopOf="parent"<br/>            app:srcCompat="@drawable/ic_category_food" /&gt;<br/><br/>        &lt;TextView<br/>            android:id="@+id/heading"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:layout_marginStart="8dp"<br/>            android:textAppearance="@style/TextAppearance.AppCompat.Large"<br/>            app:layout_constraintStart_toEndOf="@+id/imageView"<br/>            app:layout_constraintTop_toTopOf="parent"<br/>            tools:text="Dinner a the Hotel" /&gt;<br/><br/>        &lt;TextView<br/>            android:id="@+id/date"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:layout_marginStart="8dp"<br/>            app:layout_constraintStart_toEndOf="@+id/imageView"<br/>            app:layout_constraintTop_toBottomOf="@+id/heading"<br/>            tools:text="22-September-2017" /&gt;<br/><br/>        <strong>&lt;ViewStub</strong><br/><strong>            android:id="@+id/menu"</strong><br/><strong>            android:layout_width="0dp"</strong><br/><strong>            android:layout_height="wrap_content"</strong><br/><strong>            android:layout_marginEnd="8dp"</strong><br/><strong>            android:layout_marginStart="8dp"</strong><br/><strong>            android:layout_marginTop="8dp"</strong><br/><strong>            android:layout="@layout/card_menu"</strong><br/><strong>            app:layout_constraintBottom_toBottomOf="parent"</strong><br/><strong>            app:layout_constraintEnd_toEndOf="parent"</strong><br/><strong>            app:layout_constraintStart_toStartOf="parent"</strong><br/><strong>            app:layout_constraintTop_toBottomOf="@+id/date" /&gt;</strong><br/><br/>    &lt;/android.support.constraint.ConstraintLayout&gt;<br/>&lt;/android.support.v7.widget.CardView&gt;</pre>
<p>When you inflate the preceding <kbd>ViewStub</kbd>, it will replace itself with the contents of the <kbd>card_menu</kbd> layout resource, and the <kbd>ConstraintLayout</kbd> will animate the change, making the <kbd>card_menu</kbd> appear to unfold. You can use the following code snippet to inflate the <kbd>ViewStub</kbd> when the <kbd>CardView</kbd> is tapped on by the user:</p>
<pre>cardView.setOnClickListener(new View.OnClickListener() {<br/>  @Override public void onClick(final View view) {<br/>    final ViewStub menu = (ViewStub) findViewById(R.id.menu);<br/>    menu.inflate();<br/>    view.setOnClickListener(null);<br/>  }<br/>});</pre>
<p>The preceding code is a single-use <kbd>OnClickListener</kbd> that removes itself when it's been triggered. This is important because once a <kbd>ViewStub</kbd> has been inflated, it no longer exists in the layout. After the preceding listener is triggered, <kbd>findViewById(R.id.menu)</kbd> will return the root element of the <kbd>card_menu</kbd> layout resource, not the <kbd>ViewStub</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating custom styles</h1>
                
            
            
                
<p>When polishing your application, you'll find that certain styling requirements become common over the entire application, but in specific places. For example, the <em>positive</em> / <em>go</em> buttons should have a specific background color that highlights them from the other buttons in the application, or that the <em>negative</em> / <em>delete</em> buttons should have a color that highlights them as destructive for the user.</p>
<p>Android offers you the ability to define your own styles apart from those defined by the system. The theming system in Android is built entirely on top of the styling system. Styles have some very simple attributes:</p>
<ul>
<li style="font-weight: 400">Styles can be named</li>
<li style="font-weight: 400">A style can change any attribute exposed in the layout XML file</li>
<li style="font-weight: 400">A style can inherit from another style and override its attributes (a bit like classes extending each other)</li>
<li style="font-weight: 400">Styles are defined as value resources (a bit like dimensions, strings, and colors)</li>
</ul>
<p>Let's jump right in and create a new style for the travel claim application for the amount-input; we want to create a style that can be reused whenever the user needs to type a monetary amount into the application:</p>
<ol>
<li>Open the <kbd>styles.xml</kbd> resource file in the res/values project folder.</li>
<li>You'll note in this file that you already have several styles defined by the Android Studio templates. These are mostly theme-related styles, and will apply to the entire application. We want to define a new style that can be applied to specific widgets. Declare a new style element named <kbd>AmountInput</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;style name="AmountInput"&gt;<br/>&lt;/style&gt;</pre>
<ol start="3">
<li>The first thing we want this style to do is to align the text to the right of the input box. This is normally done by changing the <kbd>android:gravity</kbd> attribute on the <kbd>EditText</kbd> box. In the <kbd>style</kbd> element, you need to declare this as an <kbd>item</kbd> you wish to override:</li>
</ol>
<pre style="padding-left: 60px">&lt;item name="android:gravity"&gt;right&lt;/item&gt;</pre>
<ol start="4">
<li>You also want to change the focus behavior so that when the user taps to edit the amount, the existing value is selected. This allows them to more easily enter a new number, which is more common than wanting to edit an existing number. The <kbd>TextView</kbd> class defines an attribute named <kbd>selectAllOnFocus</kbd> that is perfect for this purpose:</li>
</ol>
<pre style="padding-left: 60px">&lt;item name="android:selectAllOnFocus"&gt;true&lt;/item&gt;</pre>
<ol start="5">
<li>To apply the style to the amount input, open the <kbd>fragment_claim_capture_details.xml</kbd> layout resource in Text mode (this is from the Try it Yourself section of <a href="1799a69f-adfc-4439-883c-f2db5e4ad199.xhtml" target="_blank">Chapter 4</a>, <em>Composing User Interfaces</em>).</li>
<li>Find the <kbd>EditText</kbd> entry for the amount, and apply the style. It's important to note that the style attribute is not in the android XML namespace:</li>
</ol>
<pre style="padding-left: 60px">&lt;EditText<br/>    <strong>style="@style/AmountInput"</strong><br/>    android:id="@+id/amount"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:hint="@string/label_amount"<br/>    android:inputType="number|numberDecimal" /&gt;</pre>
<p>When you run the application or change to the Design view, you'll find that the amount field is now right aligned, and if you tap on it, the entire content will be selected. This style can now be applied to any number of fields in your application:</p>
<div><img height="125" width="285" src="img/1e2c39fb-ce32-40d0-abe7-66c1f8b19350.png"/></div>
<p>Styles themselves can be overridden at each layer. When you inherit from another style, the child can override any of its parent items. When a widget has a style applied, any attributes specified on the widget's XML element take precedence over the style being applied. For example, if you wanted to create an <kbd>AmountInput</kbd> styled widget that left aligned its text content (instead of the style's right alignment), you might use the following:</p>
<pre style="padding-left: 60px">&lt;EditText<br/>    <strong>style="@style/AmountInput"</strong><br/>    android:id="@+id/amount"<br/>    <strong>android:gravity="left"</strong><br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:hint="@string/label_amount"<br/>    android:inputType="number|numberDecimal" /&gt;</pre>
<p>Although it's not commonly done, you can also use styles to apply attributes, such as labels and hints, to widgets. This allows for two screens to easily replicate a widget exactly, without requiring an <kbd>include</kbd>. Any time you find that your layout code appears to repeat itself, consider using a style if an include doesn't look suitable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<ol>
<li>When choosing a color scheme, it's important that the accent color has which of these features?
<ul>
<li>It is the same hue as the primary color</li>
<li>It is complementary to the primary color</li>
<li>It is not black and not white</li>
</ul>
</li>
<li>Dynamically generating a palette should meet which of these conditions?
<ul>
<li>It should be used in preference to defining the color scheme up front</li>
<li>It should be done on a background thread</li>
<li>It should only be used in media applications</li>
</ul>
</li>
<li>Which of these is to be kept in mind while animating layouts in your application?
<ul>
<li>They should not block or distract the user from achieving their goals</li>
<li>They should be done whenever the user interface changes</li>
<li>They should be kept as simple as possible to conserve battery</li>
</ul>
</li>
<li>Custom styles can be used to define which of these?
<ul>
<li>Common groups of attributes for widgets based on their class</li>
<li>Common groups of attributes to be applied through the <kbd>style</kbd> attribute</li>
<li>Default values for any attribute in a layout resource file</li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Polishing an application (much like optimizing an application) shouldn't be taken on too early in its development, as it can distract getting the application working and making the user experience smooth. It is, however, a vital part of an application's development, and the careful application of colors, fonts, and animations can sometimes be the difference between success and failure.</p>
<p>Using color tools such as Paletton make the selection of a color-scheme much easier. It's important to also consider how color-blind people will see your application, and to ensure that the application is still usable by this sizeable portion of the population. If you know someone who has any form of color blindness, ask them to help test your choice in colors. Alternatively, use the color blindness simulations that palette design tools such as Paletton provide.</p>
<p>When adding animations to the application, it's a good idea to leverage the default animation systems provided by the platform. Avoid adding animations to widgets that don't already provide some form of animation capability. If you find yourself animating things by hand, there is probably something wrong. Try and stick to using the animations built into classes like <kbd>RecyclerView</kbd> and <kbd>ViewPager</kbd>, while using animating widgets such as <kbd>TextSwitcher</kbd> where appropriate. It's also important to keep animations short. While you might think your animation looks lovely, your users will become frustrated if they slow down the use of the application.</p>
<p>In this chapter, we looked at various ways in which your application can be styled to fit a color-scheme, and polished with animations and styles for certain components. In the next chapter, we'll look at how to create your own completely customized widget classes and how to repurpose the existing widget classes for new or specialized use cases.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>