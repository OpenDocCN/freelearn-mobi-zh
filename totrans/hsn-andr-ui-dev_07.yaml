- en: Creating Overview Screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview screens, or dashboard screens, are layouts that allow the user to get
    a quick look at their data within an application. As such, they are also screens
    that the user will return to again and again. Most often, they are positioned
    as the first screen the user will normally see when they open the application,
    like the Inbox in an email application, or the list of files in your Google Drive.
    In apps, navigation is usually goal-oriented; the user starts with an overview,
    and then navigates to perform a specific action. Once they are finished with their
    action (for example, writing and sending an email), they are redirected to the
    overview screen.
  prefs: []
  type: TYPE_NORMAL
- en: Overview screens can be complex systems to build as they should be reactive,
    and they will often depend on large amounts of application data. As it's the screen
    your users will see the most often in your app, an overview screen needs special
    attention in the design process. It's important to present the user with the most
    important data, without overwhelming them. Placing too much information on the
    screen makes it harder for your user to find the information that they want.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at how to design Overview screens. We''ll take
    a detailed look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RecyclerView` class, which is the most commonly used component in overview
    lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How data-binding can make `RecyclerView` much easier to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques that can be used when designing an Overview screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get data from a Room database into a `RecyclerView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an Overview screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview screens and dashboard screens are not only the first thing your users
    will typically see, but they're also the most common point of contact with your
    user. They need to be functional, beautiful, and also very fast. An application
    that takes too long to load its first screen will only frustrate its users. If
    your application is frustrating to users, they will avoid using it. As such, it's
    very important to consider what information your user will need, and what are
    the most important actions they will take from the overview screen.
  prefs: []
  type: TYPE_NORMAL
- en: The *Material Design guideline*s have excellent recommendations to help you
    decide on these aspects of your application, which in turn will help you produce
    better applications. Remember that while it's fun (and important) to get creative
    with your designs, it's also very important to **stick to the rules**. Common
    patterns in design help your users understand what you're asking them to do, and
    how to use your application. This understanding between you and your users is
    why *Material Design is a Design Language*, and not just a look and feel. It's
    a language that you can speak to your users, and they can easily understand. For
    example, when you have a floating action button in the bottom-right of a screen,
    the user knows that it will generally start or create something new, such as create
    an empty document, or take a new photograph (depending on the application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Overview screens need to allow a user to reach every part of your application,
    but unlike a website or desktop application, this might have some intermediary
    steps (although as few as possible). This means that while you might present them
    with data, it should never be for viewing only. Every element placed on an overview
    screen must earn its right to be there. They should all fulfill two roles: give
    the user information, and allow them to take some action with that information
    (even if only to find out more). One role is fulfilled by simply being on the
    screen, the other is fulfilled by allowing the user to tap on the widget. You
    can, of course, add more: swipe to dismiss, scroll, and so on. In these cases,
    the interactions must be consistent with interactions in Material Design (that
    is, swipe to dismiss should always be on list items, not on a button).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example flow through an application should look like the following diagram.
    You''ll note that all the processes eventually return the user to the overview
    screen. This is what is meant to be deep navigation; it''s a goal-oriented structure
    designed to guide the user toward completing what they are trying to accomplish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39b85b0b-39f1-4cc1-a17b-30a77658797e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Elements of an Overview screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overview screens have certain common elements that let the user know what it
    is they''re looking at, and how they''re expected to use the screen. It''s helpful
    to know how people look at a screen when they see it for the first time. Studies
    by groups such as Neilson show that most western people follow a sort of **F**
    shaped pattern when looking at the screen for the first time. Starting in the
    top-left corner, their eyes track right and downwards, as shown in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df07f81-5ceb-4775-ae38-caa26d4d961a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that when designing an overview screen, the most important information
    should be at the top of the screen, with the second most important information
    to its right, and as you work down the screen, the information becomes less important.
    The preceding diagram uses a graph at the top of its screen; this is also an important
    element: favor using graphics and indicators over raw numbers where it''s applicable.
    A user can get a much quicker overview from a graph than they can from a table
    of numbers, even though the latter is more powerful. An overview screen should
    be something the user can use in a few seconds; it''s not a place where they will
    want to spend time understanding the details. As such, an overview screen should
    not need to be scrolled in order to be useful. It''s not as important to avoid
    scrolling an overview screen as it is on a form/input screen, but any scrolling
    should only be applicable to access detailed information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s common for an overview screen to start with a graph, or some summary
    of the user''s data, and then have a list of the most applicable details. Using
    the travel claim''s app as an example, the overview should have the overview fragment
    you developed at the top of the screen, and this should be followed by a list
    of their travel claims with the most recent at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d645629b-96d5-4cb3-8be7-7f9a6be57bc5.png)'
  prefs: []
  type: TYPE_IMG
- en: The overview fragment allows them to see how much they have spent, while the
    list shows them instantly what they've been spending the money on. Another possibility
    would be a graph showing them the breakdown of how much they have spent in each
    category. However, this will typically be less useful on a day-to-day basis and
    more useful at the end of a business trip in the form of a report.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common elements on an overview screen is a list of some sort.
    Even when the overview doesn''t include graphs and info-graphics, a list of the
    user''s most current / most useful items is a very common structure, and Android
    provides the `RecylcerView` as the perfect system to build these sorts of lists.
    Unlike `ViewPager` or `ListView`, a `RecyclerView` is a generic system for displaying
    large amounts of scrolling data. Its child widgets don''t need to be laid out
    in a strict way; they can be lists, they can be a grid, staggered unevenly, or
    anything you care to think of with a custom layout manager. However, they all
    share a common collection of structures--every `RecyclerView` needs the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Adapter` to provide the child `View` objects, and bind them to the data
    model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewHolder` classes that wrap the child `View` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LayoutManager` to determine how to place the child `View` objects relative
    to each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore how to build and use the components of a `RecyclerView` in some
    more detail, and how to build the overview screen for the travel claim app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating layouts for ViewHolders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `RecyclerView` does just what its name suggests--it recycles or reuses its
    children to present different data to the user. This means that while it appears
    to have a long list of child-widgets (such as cards or images), it actually has
    the ones that the user can actually see. When a widget is scrolled off the screen,
    the `RecyclerView` changes its data, and then scrolls it back into view. The `RecyclerView`
    doesn''t directly bind the data to the child views; however, it instead goes through
    a `ViewHolder`. The job of the `ViewHolder` is to help speed up the data binding
    process. Think of the travel claim app again; if we want to display each claim
    item in a `RecyclerView`, each one will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35725611-1c45-4bd8-ad7d-f7e47770b77f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of the preceding items will require a different Android widget, and every
    time you want to populate them, they need to be looked up and bound to their new
    data. A `ViewHolder` implementation is a convenient place to look up, hold, and
    bind data for a specific data model type and display component. Let''s go ahead
    and build a layout resource for the preceding diagram, and then we can create
    a `ViewHolder` to use it with a `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, under the application resources (res) directory, right-click
    on the layout directory and select New| Layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new layout resource `card_claim_item`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the Root element to `CardView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9252a871-8c69-479e-9a8e-f811caa9b3ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Click OK to create the new layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Palette, open the Layouts section and drag a `ConstraintLayout` into
    the Design canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Palette, open the Images section and drag an `ImageView` into the Design
    canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `ic_other_black` icon from the drawable resource selector that automatically
    opens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the constraint editor on the right to add constraints to the top, left,
    and bottom of the new `ImageView`, and set all of them to 8, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2da0a0d1-9057-46f6-baa6-caf326b33dbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the ID of the `ImageView` to `item_category`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Palette, open the Text section and drag a new `TextView` into the Design
    canvas to the right of the category icon `ImageView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the constraint editor to add constraints of `8dp` to the top, right, and
    bottom of the new `TextView` so that it centers and places itself to the right
    of the Design canvas (directly opposite the category icon `ImageView`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the ID of the `TextView` to `item_amount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the contents of the text attribute, and change the text attribute below
    it (the one with the spanner icon) to `250`. This value is only used by the Design
    canvas, and allows you to preview what the layout will look like with set values
    (even though the real values are populated at runtime):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/106fa629-d493-4c5d-81a9-56d974b9f2f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the textAppearance attribute to `@style/TextAppearance.AppCompat.Medium`,
    which will appear in the drop-down as `AppCompat.Medium`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Palette, drag another `TextView` into the design view, roughly between
    the icon `ImageView` and the amount `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a constraint from the left of the `TextView` to the right handle of the
    `ImageView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6cbf6ca0-fcdc-4af8-8025-a9c72e7b6b69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag another constraint from the right of the new `TextView` to the left of
    the amount `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8d9f203-c38f-4ae7-bd53-786b4454340a.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the constraint editor to add a constraint to the top of the new `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the top constraint to `8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58ab0190-b105-4f8c-86c2-cc4ec50a1895.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the `layout_width` attribute of the new `TextView` to `match_constraint`
    using the Attributes panel (just below the constraint editor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the ID of the new `TextView` to `item_description`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the text attribute, and set the Design text attribute to `Airport Shuttle`
    so that you still have something visible in the Design canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the textAppearance attribute to `@style/TextAppearance.AppCompat.Medium`,
    which will appear in the drop-down as `AppCompat.Medium`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Palette, drag a third `TextView` into the Design canvas and drop it
    between the category icon `ImageView` and the amount `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like the description `TextView`, constrain the new `TextView` to the right
    of the category icon and to the left of the amount `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the constraint editor, add a constraint at the bottom of the new `TextView`,
    and set its bottom margin to `8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6dc42f5a-4a43-4eb2-b06f-1fb6ffcf269a.png)'
  prefs: []
  type: TYPE_IMG
- en: Set the ID of the new `TextView` to `item_timestamp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the layout_width of the new `TextView` to match_constraint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a constraint from the top of the new `TextView` to the bottom of the description
    `TextView`; this will ensure that they have at least 8dp between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the text attribute, and set the Design tool text attribute to a date such
    as `27-December-2017`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Component Tree panel, select the `CardView` at the root of your layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch over to the View all attributes panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Layout_Margin group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the top margin to `@dimen/grid_spacer1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the layout_height of the `CardView` to wrap_content; the layout will
    roll up looking something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/083ab09e-f133-47ad-a21a-bd2c2d4b0472.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a simple ViewHolder class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a `ViewHolder` is very simple, and it''s a good place to encapsulate
    any display specific logic for rendering the items for a `RecyclerView`. For the
    preceding layout, follow these steps to build a `ViewHolder`:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the ui package in Android Studio, and select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `ClaimItemViewHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the new classes Superclass to `android.support.v7.widget.RecyclerView.ViewHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main job of a `ViewHolder` is to speed up the binding between the data
    model and the user interface widgets and for that to happen, the `ViewHolder`
    needs references to each of the `View` objects it will populate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ViewHolder` will also need a way to format the timestamp, and the best
    way to do that is with a `java.text.DateFormat`, which is also something to keep
    a reference to as they''re quite expensive to construct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ViewHolder` is usually constructed with the `View` object it''s expected
    to bind to. You can inflate the `View` object within the `ViewHolder` constructor,
    but to keep things flexible and avoid argument clutter on the constructor, this
    `ViewHolder` implementation will just take the `View` object it will wrap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to create the `DateFormat` object and, for this, you want the
    long date format in the user''s current locale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This class will need a utility method to figure out which icon should be rendered
    for a `Category` that will involve manually referencing the application `Resources`
    to retrieve the black versions of the category icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need a utility method to format the amounts so that integer amounts
    don''t have any decimal component, while non-integers only display two decimal
    places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need a way for the adapter to populate all the `View` elements
    with data, and because this class is specific to the `ClaimItem` data objects,
    you can make this simple by having a setter-like method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating a ViewHolder with data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from building a traditional `ViewHolder` implementation, there
    is quite a lot of work and boilerplate code required just to put the data from
    a single item onto the screen in a layout. Further, it's actually quite expensive
    in its own right, because every one of the `ViewHolder` instances creates and
    holds an instance of the `DateFormatter` where they can easily be shared between
    all the `ClaimItemViewHolder` instances for a `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases like this, data binding can make a huge difference. Using a few tricks,
    you can actually create a completely generic `ViewHolder` implementation that
    will work for any data object in your application (assuming that you can bind
    it to a layout file). First, you''ll need to create a nice generic `ItemPresenter`,
    and then modify the layout, and then you''re ready to create a generic data-binding
    `ViewHolder` implementation. Follow these instructions, and you''ll only ever
    need one `ViewHolder` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the presenters package in Android Studio, and select New| Java
    Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class `ItemPresenter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ItemPresenter` will need a `Context` to reference application `Resources`
    and files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `formatAmount` utility method the same way as in the simple `ViewHolder`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a `getCategoryIcon` utility method into the new `ItemPresenter` (this
    is almost exactly the same as the one in the `ClaimItemViewHolder`, except in
    how it accesses the `Resources` object):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a `formatDate` utility method that will convert the `Date` objects into
    text suitable for displaying on the screen. The conversion is done by a `DateFormat`
    object, which is only created the first time `formatDate` is called (it is lazy-initialized).
    The lazy-initialization is important, as this class is expected to be generic
    across all possible item presenters in the application and so, there will be cases
    where it''s not used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `card_claim_item.xml` layout resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Text view in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new layout root element above the `CardView`, and ensure that you
    remove the namespace declarations from the `CardView` and close the layout element
    at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Above the `CardView`, declare a data block with two variables. It''s important
    to keep these names generic. One will be an instance of `ItemPresenter`, and the
    other will be the `ClaimItem` to be bound by the layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the `ImageView` declaration for `item_category` and add a new data-bound
    attribute to use the `ItemPresenter` to find the correct icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the amount `TextView` declaration and data bind its text attribute, using
    the presenter to format the amount from the `ClaimItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Data bind the description from the `ClaimItem` to the `item_description` `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the presenter to data bind the timestamp from the `ClaimItem` to the timestamp
    `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to start on a generic `ViewHolder` class that can be reused with
    any data-bound layout. Right-click on the ui package and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `DataBoundViewHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Superclass to `android.support.v7.widget.RecyclerView.ViewHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a generic declaration to the class so that you have generic types for the
    Presenter, and Item (P, I) variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Every Binding class generated by the data binding system extends `ViewDataBinding`;
    the `DataBoundViewHolder` will actually wrap one of these so that any data-bound
    layout can be wrapped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write a constructor that takes a `ViewDataBinding` object and a Presenter
    object for the data-bound layout to use. As `ViewDataBinding` is a generic abstract
    class, we can''t directly call the `setPresenter` method that will be generated
    by the data binding system in the `CardClaimItemBinding` class. Instead, we can
    use a special generic data binding method that allows you to assign unknown variables
    based on a generated ID number; this is a bit like using Java reflection, except
    that the actual implementation is generated at compile time and is very fast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you are presented with a choice of multiple `BR` classes to import, use the
    one for your own project (`com.packtpub.claim`). Much like the normal Android
    resources (`R`), the data binding system generates a lookup class for each project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, write in two setter methods so that the `Presenter` and `item` variables
    can be changed uniformly from the outside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `setVariable` method is generated at compile time, just like the getter
    and setter methods as a series of `if` statements. This makes it a little slower
    than the actual setter methods, but much faster than using reflection to invoke
    the setter methods. It's not the sort of area that should need optimization, especially
    as there are only two possible variables for these data-bound layouts. If your
    layout needs more than these two variables in a `RecyclerView`, you should consider
    composing or inheriting the logic and data required into more specific classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated `setVariable` implementation of the `card_claim_item` layout
    defined in this section will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code will execute very quickly and won't throw exceptions
    if an unknown variable ID is given. However, it will throw a `ClassCastException`
    if you tried to pass in the wrong type for a data-bound variable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RecyclerView adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get data into a `RecyclerView`, you need an `Adapter` class, not
    unlike the `PagerAdapter` you wrote to display the attachment previews for the
    `CaptureClaimActivity`. However, `RecyclerView` does a lot more of the heavy lifting
    than `ViewPager` and as a result, what you can and can''t do inside the adapter
    is far more restricted than with `PagerAdapter`. Also, unlike a `PagerAdapter`,
    a `RecylcerView` adapter has two actions that are involved in displaying each
    element: create and bind. When the `RecyclerView` needs a new child widget for
    an element, it will invoke `onCreateViewHolder`, which should return an unpopulated
    `ViewHolder`, which will then be passed to `onBindViewHolder` where the data should
    be mapped into the `View` from whatever data source the adapter uses.'
  prefs: []
  type: TYPE_NORMAL
- en: First off, the `RecyclerView` maintains the list of its child views completely,
    so the adapter must never add or remove them directly. Secondly, the `RecyclerView`
    expects the adapter to be stable, that is, the data within the adapter must not
    change without telling the `RecyclerView` about the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike older recycling widget classes like `ListView` and `GridView`, `RecyclerView`
    does not assume that it's presenting the same object model over and over. Instead,
    each object returned from the `Adapter` can optionally have a view type indicator;
    when these are different, the `RecylcerView` maintains a separate pool for each
    of the view types and recycles all of them separately.
  prefs: []
  type: TYPE_NORMAL
- en: When using different view types, it's common for the adapter to use the layout
    resource ID as the view type; these are unique per application and avoid any need
    for a `switch` statement or similar mapping between internal view type IDs and
    the actual resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the travel claim example, you will need an adapter to display all the `ClaimItems`
    on the overview screen. Fortunately, Room provides you with a prebuilt `LiveData`,
    which can be observed directly, which makes building the adapter much simpler.
    Follow these simple steps to build a `RecyclerView` adapter bound to a `LiveData`
    object, and use the `DataBoundViewHolder` to present the data to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the ui package and select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `ClaimItemAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class declaration to extend from `RecyclerView.Adapter` and describe
    the `DataBoundViewHolder` generic you will be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This adapter class will inflate the data-bound layout files as resources, so
    it''ll need a `LayoutInflator` to do the work for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemPresenter` instances can also be shared between all the claim item
    layouts that are on screen, so the `ClaimItemAdapter` should hold a reference
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Most importantly, the `ClaimItemAdapter` needs data to display. Ensure that
    you instantiate this reference so that you don''t need null-checks in your other
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, declare a constructor for `ClaimItemAdapter`; as `ClaimItemAdapter` will
    observe a `LiveData` object, it''ll need a `LifecycleOwner` as well. The `LifecycleOwner`
    tells the `LiveData` when to notify you of changes, and when not to and also when
    to unregister any listeners. Typical `LifecycleOwners` are `Activity` or `Fragment`
    instances, but you can make almost any class a `LifecycleOwner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For further flexibility, you can allow the `ItemPresenter` to be passed into
    the constructor. This will allow the `ItemPresenter` to be extended or configured
    outside of the `ClaimItemAdapter` objects, and each instance can be given different
    presentation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `ClaimItemAdapter` doesn''t keep a reference to the `LiveData`
    instance yet, and in fact, it won''t directly hold a reference at all. Instead,
    you''ll use an anonymous inner class (or lambda if it''s available to you) to
    observe the `LiveData`. It''s important to know that when you start observing
    a `LiveData` instance, you will automatically get an *initial* event with the
    current state of the data, if your `LifecycleOwner` is in the correct state. This
    means you should never need to attempt to fetch the data directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the constructor is complete, and it''s time to implement the binding-related
    features. The first step is to implement `onCreateViewHolder`, which will use
    the `DataBindingUtil` to create the layout and the `ViewDataBinding` that the
    `DataBoundViewHolder` will wrap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the `DataBoundViewHolder` implementation, the `onBindViewHolder` method
    is trivial to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RecyclerView` also needs to know how many items are in the data model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This adapter can be very easily adapted further in the same way as the `DataBoundViewHolder`,
    to allow you to present any `LiveData` list returned from a Room database with
    an arbitrary data-bound layout file. The combination of data binding and `LiveData`
    makes for an extremely powerful combination that dramatically simplifies your
    user-interface code, and avoids the need to write lots of boilerplate structure
    for every combination of views and models.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding an adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to use data binding on a layout with a `RecyclerView` in it, you
    can even data bind the adapter object to the `RecyclerView`. All you need to do
    is expose a method to access the desired adapter object in a presenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important that you preconstruct or cache the instances you create to
    avoid recreating the adapter object unnecessarily. It''s also important to remember
    not to make the adapter an `ObservableField` or similar, since the adapter''s
    content should be what changes, not the adapter itself. To bind the `RecyclerView`
    to its adapter, use the data binding system''s *auto property* system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It's really important when using data binding and adapter views together to
    remember that they both update the user interface. As such, it's important to
    ensure that you keep the adapter reference in the presenter stable, and don't
    change it without being sure of yourself. Changing the adapter reference will
    cause the `AdapterView` (such as a `RecyclerView`) to completely rebuild its contents
    rather than just refreshing its contents. It's much better to use the adapter
    to notify the `AdapterView` of changes than it is to make the adapter observable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Overview activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The travel claim example app needs a nice overview activity to tie together
    the allowance overview, a list of the claim items, and a way for the user to create
    new claim items. As we have a Room database, things can become significantly more
    decoupled, and that's a really good thing. Having a central reactive source of
    data allows different parts of your application to always reflect the actual state
    of the application as it changes, without having to coordinate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of building the `OverviewActivity` is creating the `Activity`
    class itself and populating it with the claim items that the user has entered.
    Follow these steps to create a skeleton `OverviewActivity` and register it as
    the main `Activity` for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by right-clicking on your main package (that is, com.packtpub.claim) and
    selecting New | Activity | Empty Activity from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `OverviewActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave all the other fields as their defaults and select Finish to create the
    new `Activity` and its layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new `activity_overview.xml` layout file and change to the Text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Android Studio will have placed a `ConstraintLayout` as the root element; change
    it to a `FrameLayout` instead, because this layout is very simple and since the
    logic will be self-binding, there is no point in using a data-bound layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A **FrameLayout** is a very simple layout where its children are rendered on
    top of each other. The first child is painted first, and then the second child
    is painted on top of the first. This makes it ideally suited for building layered
    scenes, even when some layers will not always be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first child of the `FrameLayout` will be a simple `LinearLayout` to allow
    you to place the allowance overview above the scrolling list of claim items. `LinearLayout`
    is ideal here as it''s a very simple and very fast layout to use, and we don''t
    need the complexities of a `ConstraintLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first child of the `LinearLayout` is the `AllowanceOverviewFragment`, which
    will allow the user to edit their daily allowance and see how much they''re spending:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the `RecyclerView`, which will display a scrolling list of the claim
    items that the user has entered. Note the clipping and padding attributes here;
    they ensure that the claim item cards are inset, but that their full borders and
    shadows will be visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `OverviewActivity` class that Android Studio generated; it's time
    to populate the layout with claim items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll be rendering a list of `ClaimItem` objects using the `ClaimItemAdapter`,
    and it needs to watch for changes using the `LiveData` object produced by the
    database. This requires that the `Activity` report its life cycle, and this is
    done by extending one of the `Activity` implementations provided by the support
    packages (in this case, `AppCompatActivity`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As all the behavior for this Activity is actually handled by its fragments
    and by the `LiveData` changes triggered by the `ClaimDatabase`, the `onCreate`
    implementation only needs to set the adapter for the `RecyclerView`. All other
    logic and behavior for the `OverviewActivity` will be handled by the fragments
    and adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you'll need to change the `AndroidManifest.xml` file to tell the system
    that the main entry point for the application is now the `OverviewActivity`, and
    not the `CaptureClaimActivity`; open the `manifests` folder near the top of your
    projects file-tree and open the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the activity element declarations so that the MAIN / LAUNCHER intent-filter
    is in the `OverviewActivity` element instead of the `CaptureClaimActivity` element.
    It''s also worth changing the `windowSoftInputMode` attribute so that the software
    keyboard doesn''t automatically open when the `OverviewActivity` is started. The
    keyboard opens by default because the first widget on the screen is the `EditText`
    field, where the user can enter their daily allowance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run your application, you''ll see that while the screen is technically
    complete, there are no claim items and no way to add them. As such, there is nothing
    in the `RecyclerView` to look at or scroll through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c19f042-71c9-42b4-aad1-d96b93993b2f.png)'
  prefs: []
  type: TYPE_IMG
- en: You need to provide a way for your user to add new claim items. The best way
    is with a floating action button in the bottom-right corner of the screen, and
    we'll be doing that with a new `Fragment`. By using a `Fragment` for this task,
    you'll be able to place a "new item" floating action button on any screen in the
    application without having to implement any special code in the `Activity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new ClaimItems with a Fragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An unusual property of using `LiveData` from a Room database is that various
    parts of your application can now interact without needing any direct knowledge
    of each other. In the case of your `OverviewActivity`, this will allow you to
    populate the database with new `ClaimItem` entities without dispatching any sort
    of "new item" or "item added" events to the `ClaimItemAdapter`. However, the Room
    database abstraction layer prevents you from running any query on the main thread
    unless it returns a `LiveData`. While the query to retrieve the `ClaimItem` entities
    returned a `LiveData`, inserting new `LiveData` entities will be required to run
    in the background. Follow these steps to build a `Fragment` that can allow the
    user to capture and record a new travel claim item:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll need a task to insert both a `ClaimItem` entity and any `Attachment`
    entities associated with it. This task will need to run on a background worker
    thread, so open the `ClaimDatabase` class in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the abstract methods that return, the `ClaimItemDao` and `AttachmentDao`
    declare a new method to return a `Runnable` task to insert a new `ClaimItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the new `Runnable` task, you''ll want to use a transaction to save the
    contents of the `ClaimItem` object into the database; if any part of this method
    fails, the transaction will be rolled back, and the method will have had no effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You'll also need a method in `ClaimItem` to ensure that it has content and is
    considered valid, so open the `ClaimItem` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of the `ClaimItem` class, create a new `isValid` method; this will
    be used when the `CaptureClaimActivity` returns a `ClaimItem` to check whether
    we should store the new `ClaimItem` in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You'll need a new icon for adding claim items; right-click on the drawable resource
    directory and select New| Vector Asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Icon selector, find and select the icon named `add`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new icon resource `ic_add_white_24dp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next and then on Finish to create the new resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new icon resource in the Android Studio text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `fillColor` attribute of the path element to make it white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, right-click on the ui package and select New| Fragment| Fragment (Blank).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Fragment` class `NewClaimItemFloatingActionButtonFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the Include fragment factory methods and Include interface callbacks
    options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Finish button to create the new `Fragment` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new layout file that should be called `fragment_new_claim_item_floating_action_button.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of this file with just a `FloatingActionButton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the new `NewClaimItemFloatingActionButtonFragment` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class declaration to implement the `View.OnClickListener` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a request-code to be used when sending the user to the `CaptureClaimActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `onCreateView` method to also set the `OnClickListener` of the `FloatingActionButton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onClick` method from the `View.OnClickListener` and start the
    `CaptureClaimActivity` for result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onActivityResult` method to handle the incoming `ClaimItem`,
    and if it''s valid, save it in the database using the `SERIAL_EXECUTOR` from `AsyncTask`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll need to add the new fragment to the `OverviewActivity`. Open the
    `activity_overview` layout file and change to Text mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of the `FrameLayout` root element, include a fragment tag referencing
    the `NewClaimItemFloatingActionButtonFragment` and position it at the bottom-right
    of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now you should be able to run the application again; not only should you now
    have a floating action button at the bottom of the overview screen, but it will
    work! If you click on the button and capture some details on the `CaptureClaimActivity`
    and then select to navigate back to the `OverviewActivity`, the new claim item
    will appear in the list, sorted by date.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike using `SQLiteDatabase` directly, Room will enforce only running queries
    on a worker thread. This makes it attractive to encapsulate your updates in a
    `Runnable` that can be run on a background thread such as you did with the `createClaimItemTask`
    in the `ClaimDatabase` class. Having these methods available on the `ClaimDatabase`
    makes them easily reusable, and keeps the logic consistent throughout your application.
    It also allows you to put them into queues or run them in parallel with other
    tasks if you choose to use a thread-pool instead of the `SERIAL_EXECUTOR` from
    `AsyncTask` (which will only run one task at a time).
  prefs: []
  type: TYPE_NORMAL
- en: Allowance overview with a Room database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run the overview screen and add a few claims to it, you''ll notice that
    one piece of the code isn''t reacting to the new items being added to the database:
    the allowance overview at the top of the screen. This is because while everything
    else is connected to the Room database, it''s still watching the `Allowance` data
    model. Using a data model like this is a good idea when the data is just in memory,
    but now that you have a database in place, things can change and simplify. For
    example, the `Allowance` class only really keeps how much the user plans to spend
    each day; the claim items can actually be seen as an entirely separate structure
    in the database model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, you can move the daily allowance into a different type of data storage--`SharedPreferences`.
    `SharedPreferences` are key-value stores for Android that have a shared in-memory
    representation and atomic updates. If you don''t expect them to store too much
    data, this makes them ideal to keep track of data that doesn''t really go in an
    SQLite database. Let''s change the model of the `Allowance` overview to use the
    `ClaimDatabase` and `SharedPreferences`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `AllowanceOverviewPresenter` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change it from using the `Allowance` class to instead expose the daily allowance
    as an `ObservableInt`, and remove the `OnPropertyChangeCallback` so that the fields
    now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the `UpdateSpendingStatsCommand` inner class to take a `List` of
    `ClaimItem` objects instead of an `Allowance` as its parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change the `onBackground` implementation to run a single scan through the
    given `List` of `ClaimItem` objects and calculate all the spending stats at once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the constructor so that it takes a `LifecycleOwner` and the starting
    allowance to display to the user. Then, use the `ClaimDatabase` to update the
    spending statistics whenever there are new `ClaimItem` objects added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to change the `updateAllowance` method to use the `ObservableInt`
    instead of the `Allowance` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `AllowanceOverviewFragment` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `SharedPreferences` field to the `AllowanceOverviewFragment`; we''ll
    be using them more than once in this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onCreate` method of `Fragment` and retrieve the private `SharedPreferences`
    instance you''ll be storing the daily allowance in. The first argument specifies
    the name of the `SharedPreferences` to retrieve, while the second specifies the
    scope as `private`, meaning only your application will be able to see or use this
    `SharedPreferences` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `onCreateView` method to create an `AllowanceOverviewPresenter` and
    pass the `Fragment` instance as the `LifecycleOwner`, and to retrieve the current
    `allowancePerDay` from the `SharedPreferences`. The second argument passed to
    the `SharedPreferences.getInt` method is a default value that is returned if there
    is no existing value stored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create an `onDestroy` method to store the allowance per day back in
    the `SharedPreferences` object. You do this by first requesting an `Editor` from
    the `SharedPreferences`, and then applying the changes. All the changes in an
    `Editor` are atomically applied at the same time (atomically):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you build and run the application, you'll notice that the allowance
    overview will correctly show you how much you've spent "today", "this week", and
    in total. Use the date selector in the `CaptureClaimActivity` to add a few claim
    items on different days and see how the user interface reacts and recalculates
    the amounts that you've spent.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An instance of `RecyclerView` will create one `View` instance for which of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every item of data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Every item of data visible on the screen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type of data element that is also visible on the screen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When attaching an observer to `LiveData` you need to do which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detach it when its `LifecycleOwner` is destroyed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach it on the main thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a valid `LifecycleOwner`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview / Dashboard screens should have which of these features?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They should only use graphs to display statistics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They should not scroll if it can be avoided
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They should display an overview with the most important information first
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ViewHolder` class is used by the `RecyclerView` to do what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improve the data binding performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference the views that will be garbage collected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the `View` objects in a `Bundle`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `LiveData` objects to reference data used by multiple `Fragment`
    objects, which of these is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Fragment` instances must share the same `LiveData` reference to see changes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LiveData` will only update one of the `Fragment` instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Fragment` classes must all extend `android.support.v4.app.Fragment`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview screens are the first thing a user will see and interact with in your
    application, and will be the area of the application they will spend most of their
    time in. It's important to keep the screen focused and opinionated on what data
    is displayed to the user, and how it's displayed. Always consider how long the
    user has to look at your screen, and what information they will need easy access
    to. Make use of the `RecyclerView` and `LiveData` classes to provide the user
    with detailed views arranged with the most important information first, and allow
    them to quickly scroll through their most important recent events.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to consider the navigation of your application, the various
    ways the user will leave your overview screen, and how they will get back to it.
    As far as possible, keep the `Overview` class responsible for just arranging the
    data on the screen. Any logic that takes the user away from the screen, for whatever
    reason, should be encapsulated in `Fragment` classes that also hold the logic
    to deal with their eventual return to the overview screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at a very simple way to build an overview screen.
    There are many ways that these sorts of screens can be made more useful and powerful
    by reshaping the layout on the screen as the user scrolls and drags various elements
    of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at how to leverage some of the layout
    systems provided by the Material Design API to allow the user interface to change
    its shape and emphasis dynamically.
  prefs: []
  type: TYPE_NORMAL
