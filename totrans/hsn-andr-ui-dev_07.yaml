- en: Creating Overview Screens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建概览屏幕
- en: Overview screens, or dashboard screens, are layouts that allow the user to get
    a quick look at their data within an application. As such, they are also screens
    that the user will return to again and again. Most often, they are positioned
    as the first screen the user will normally see when they open the application,
    like the Inbox in an email application, or the list of files in your Google Drive.
    In apps, navigation is usually goal-oriented; the user starts with an overview,
    and then navigates to perform a specific action. Once they are finished with their
    action (for example, writing and sending an email), they are redirected to the
    overview screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕，或仪表盘屏幕，是允许用户快速查看应用程序中数据的布局。因此，它们也是用户会反复返回的屏幕。通常情况下，它们被定位为用户打开应用程序时通常会看到的第一个屏幕，例如电子邮件应用程序中的收件箱，或Google
    Drive中的文件列表。在应用程序中，导航通常是目标导向的；用户从一个概览开始，然后导航以执行特定操作。一旦他们完成操作（例如，撰写并发送电子邮件），他们就会被重定向到概览屏幕。
- en: Overview screens can be complex systems to build as they should be reactive,
    and they will often depend on large amounts of application data. As it's the screen
    your users will see the most often in your app, an overview screen needs special
    attention in the design process. It's important to present the user with the most
    important data, without overwhelming them. Placing too much information on the
    screen makes it harder for your user to find the information that they want.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕可能是一个复杂的构建系统，因为它们应该是响应式的，并且通常依赖于大量的应用程序数据。由于这是用户在您的应用程序中最常看到的屏幕，因此在设计过程中概览屏幕需要特别注意。向用户提供最重要的数据，而不会让他们感到不知所措是很重要的。在屏幕上放置过多的信息会让用户更难找到他们想要的信息。
- en: 'In this chapter, we''ll look at how to design Overview screens. We''ll take
    a detailed look at the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何设计概览屏幕。我们将详细探讨以下内容：
- en: The `RecyclerView` class, which is the most commonly used component in overview
    lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView`类，这是概览列表中最常用的组件'
- en: How data-binding can make `RecyclerView` much easier to use
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定如何使`RecyclerView`的使用更加容易
- en: Techniques that can be used when designing an Overview screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计概览屏幕时可以使用的技巧
- en: How to get data from a Room database into a `RecyclerView`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从Room数据库获取数据到`RecyclerView`
- en: Designing an Overview screen
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计概览屏幕
- en: Overview screens and dashboard screens are not only the first thing your users
    will typically see, but they're also the most common point of contact with your
    user. They need to be functional, beautiful, and also very fast. An application
    that takes too long to load its first screen will only frustrate its users. If
    your application is frustrating to users, they will avoid using it. As such, it's
    very important to consider what information your user will need, and what are
    the most important actions they will take from the overview screen.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕和仪表盘屏幕不仅是用户通常会看到的第一个界面，而且也是与用户接触最频繁的点。它们需要具备功能性、美观性，并且非常快速。如果一个应用程序加载第一个屏幕需要太长时间，只会让用户感到沮丧。如果应用程序让用户感到沮丧，他们就会避免使用它。因此，考虑用户需要的信息以及他们在概览屏幕上最可能采取的重要操作非常重要。
- en: The *Material Design guideline*s have excellent recommendations to help you
    decide on these aspects of your application, which in turn will help you produce
    better applications. Remember that while it's fun (and important) to get creative
    with your designs, it's also very important to **stick to the rules**. Common
    patterns in design help your users understand what you're asking them to do, and
    how to use your application. This understanding between you and your users is
    why *Material Design is a Design Language*, and not just a look and feel. It's
    a language that you can speak to your users, and they can easily understand. For
    example, when you have a floating action button in the bottom-right of a screen,
    the user knows that it will generally start or create something new, such as create
    an empty document, or take a new photograph (depending on the application).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Material Design指南*提供了极好的建议，可以帮助您决定应用程序的这些方面，从而帮助您制作出更好的应用程序。记住，虽然发挥创意（并且很重要）是件有趣的事情，但坚持规则也非常重要。设计中的常见模式有助于用户理解您要求他们做什么，以及如何使用您的应用程序。您和用户之间的这种理解是为什么*Material
    Design是一种设计语言*，而不仅仅是外观和感觉。这是一种您可以与用户交谈的语言，他们可以轻松理解。例如，当您在屏幕的右下角有一个浮动操作按钮时，用户知道它通常用于启动或创建新事物，例如创建一个空文档或拍摄一张新照片（取决于应用程序）。'
- en: 'Overview screens need to allow a user to reach every part of your application,
    but unlike a website or desktop application, this might have some intermediary
    steps (although as few as possible). This means that while you might present them
    with data, it should never be for viewing only. Every element placed on an overview
    screen must earn its right to be there. They should all fulfill two roles: give
    the user information, and allow them to take some action with that information
    (even if only to find out more). One role is fulfilled by simply being on the
    screen, the other is fulfilled by allowing the user to tap on the widget. You
    can, of course, add more: swipe to dismiss, scroll, and so on. In these cases,
    the interactions must be consistent with interactions in Material Design (that
    is, swipe to dismiss should always be on list items, not on a button).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕需要允许用户到达应用程序的每个部分，但与网站或桌面应用程序不同，这可能需要一些中间步骤（尽管尽可能少）。这意味着虽然你可能向他们展示数据，但这绝不应该只是为了查看。放置在概览屏幕上的每个元素都必须有存在的理由。它们都应该履行两个角色：向用户提供信息，并允许他们使用这些信息采取某些行动（即使只是了解更多）。一个角色是通过简单地出现在屏幕上完成的，另一个角色是通过允许用户点击小部件来完成的。当然，你可以添加更多：滑动以取消，滚动等。在这些情况下，交互必须与Material
    Design中的交互保持一致（即，滑动以取消应该始终应用于列表项，而不是按钮）。
- en: 'An example flow through an application should look like the following diagram.
    You''ll note that all the processes eventually return the user to the overview
    screen. This is what is meant to be deep navigation; it''s a goal-oriented structure
    designed to guide the user toward completing what they are trying to accomplish:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中一个示例流程应类似于以下图表。你会注意到所有流程最终都会将用户带回到概览屏幕。这就是所谓的深度导航；它是一个以目标为导向的结构，旨在引导用户完成他们试图完成的任务：
- en: '![](img/39b85b0b-39f1-4cc1-a17b-30a77658797e.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39b85b0b-39f1-4cc1-a17b-30a77658797e.jpg)'
- en: Elements of an Overview screen
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概览屏幕的元素
- en: 'Overview screens have certain common elements that let the user know what it
    is they''re looking at, and how they''re expected to use the screen. It''s helpful
    to know how people look at a screen when they see it for the first time. Studies
    by groups such as Neilson show that most western people follow a sort of **F**
    shaped pattern when looking at the screen for the first time. Starting in the
    top-left corner, their eyes track right and downwards, as shown in this diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕有一些常见的元素，让用户知道他们正在看什么，以及他们应该如何使用该屏幕。了解人们在第一次看到屏幕时是如何看待屏幕的很有帮助。尼尔森等团体进行的研究表明，大多数西方人在第一次看屏幕时遵循一种类似**F**形的模式。从左上角开始，他们的眼睛向右下方移动，如图所示：
- en: '![](img/5df07f81-5ceb-4775-ae38-caa26d4d961a.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5df07f81-5ceb-4775-ae38-caa26d4d961a.jpg)'
- en: 'This means that when designing an overview screen, the most important information
    should be at the top of the screen, with the second most important information
    to its right, and as you work down the screen, the information becomes less important.
    The preceding diagram uses a graph at the top of its screen; this is also an important
    element: favor using graphics and indicators over raw numbers where it''s applicable.
    A user can get a much quicker overview from a graph than they can from a table
    of numbers, even though the latter is more powerful. An overview screen should
    be something the user can use in a few seconds; it''s not a place where they will
    want to spend time understanding the details. As such, an overview screen should
    not need to be scrolled in order to be useful. It''s not as important to avoid
    scrolling an overview screen as it is on a form/input screen, but any scrolling
    should only be applicable to access detailed information.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在设计概览屏幕时，最重要的信息应该位于屏幕顶部，其次是位于其右侧的第二重要信息，随着你在屏幕上向下工作，信息的重要性逐渐降低。前面提到的图表在其屏幕顶部使用了一个图表；这也是一个重要的元素：在适用的情况下，优先使用图形和指标而不是原始数字。用户可以从图表中获得比从数字表更快的概览，尽管后者更强大。概览屏幕应该是用户可以在几秒钟内使用的；它不是一个他们想要花时间理解细节的地方。因此，概览屏幕不需要滚动就可以有用。避免滚动概览屏幕的重要性不如在表单/输入屏幕上那么重要，但任何滚动只应适用于访问详细信息。
- en: 'It''s common for an overview screen to start with a graph, or some summary
    of the user''s data, and then have a list of the most applicable details. Using
    the travel claim''s app as an example, the overview should have the overview fragment
    you developed at the top of the screen, and this should be followed by a list
    of their travel claims with the most recent at the top:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕通常以图表或用户数据的摘要开始，然后是适用细节的列表。以旅行报销应用为例，概览应该有屏幕顶部的概览片段，然后是他们的旅行报销列表，最近的报销在最上面：
- en: '![](img/d645629b-96d5-4cb3-8be7-7f9a6be57bc5.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d645629b-96d5-4cb3-8be7-7f9a6be57bc5.png)'
- en: The overview fragment allows them to see how much they have spent, while the
    list shows them instantly what they've been spending the money on. Another possibility
    would be a graph showing them the breakdown of how much they have spent in each
    category. However, this will typically be less useful on a day-to-day basis and
    more useful at the end of a business trip in the form of a report.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 概览片段允许他们看到他们花了多少钱，而列表则立即显示他们花在什么上。另一种可能性是显示他们在每个类别中花费的细分情况的图表。然而，这通常在日常基础上不太有用，而在商务旅行结束时以报告的形式更有用。
- en: 'One of the most common elements on an overview screen is a list of some sort.
    Even when the overview doesn''t include graphs and info-graphics, a list of the
    user''s most current / most useful items is a very common structure, and Android
    provides the `RecylcerView` as the perfect system to build these sorts of lists.
    Unlike `ViewPager` or `ListView`, a `RecyclerView` is a generic system for displaying
    large amounts of scrolling data. Its child widgets don''t need to be laid out
    in a strict way; they can be lists, they can be a grid, staggered unevenly, or
    anything you care to think of with a custom layout manager. However, they all
    share a common collection of structures--every `RecyclerView` needs the following
    components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕上最常见的元素之一是某种类型的列表。即使概览中不包含图表和信息图表，用户最新/最有用的项目列表也是非常常见的结构，Android提供了`RecyclerView`作为构建此类列表的完美系统。与`ViewPager`或`ListView`不同，`RecyclerView`是一个用于显示大量滚动数据的通用系统。其子小部件不需要以严格的方式布局；它们可以是列表，可以是网格，可以是错落有致的，或者任何你想要用自定义布局管理器想到的东西。然而，它们都共享一组公共结构--每个`RecyclerView`都需要以下组件：
- en: An `Adapter` to provide the child `View` objects, and bind them to the data
    model
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Adapter`来提供子`View`对象，并将它们绑定到数据模型
- en: '`ViewHolder` classes that wrap the child `View` objects'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装子`View`对象的`ViewHolder`类
- en: A `LayoutManager` to determine how to place the child `View` objects relative
    to each other
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`LayoutManager`来决定如何放置子`View`对象相对于彼此的位置
- en: Let's explore how to build and use the components of a `RecyclerView` in some
    more detail, and how to build the overview screen for the travel claim app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨如何构建和使用`RecyclerView`的组件，以及如何构建旅行报销应用的概览屏幕。
- en: Creating layouts for ViewHolders
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为ViewHolder创建布局
- en: 'A `RecyclerView` does just what its name suggests--it recycles or reuses its
    children to present different data to the user. This means that while it appears
    to have a long list of child-widgets (such as cards or images), it actually has
    the ones that the user can actually see. When a widget is scrolled off the screen,
    the `RecyclerView` changes its data, and then scrolls it back into view. The `RecyclerView`
    doesn''t directly bind the data to the child views; however, it instead goes through
    a `ViewHolder`. The job of the `ViewHolder` is to help speed up the data binding
    process. Think of the travel claim app again; if we want to display each claim
    item in a `RecyclerView`, each one will look something like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`正是其名称所暗示的--它回收或重用其子元素来向用户展示不同的数据。这意味着虽然它看起来有一个长长的子小部件列表（如卡片或图片），但实际上它只有用户可以看到的那些。当一个小部件被滚动出屏幕时，`RecyclerView`会更改其数据，然后将其滚动回视图。`RecyclerView`不会直接将数据绑定到子视图中；然而，它通过`ViewHolder`来完成。`ViewHolder`的职责是帮助加快数据绑定过程。再次以旅行报销应用为例；如果我们想在`RecyclerView`中显示每个报销项目，每个项目将看起来像以下这样：'
- en: '![](img/35725611-1c45-4bd8-ad7d-f7e47770b77f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35725611-1c45-4bd8-ad7d-f7e47770b77f.png)'
- en: 'Each of the preceding items will require a different Android widget, and every
    time you want to populate them, they need to be looked up and bound to their new
    data. A `ViewHolder` implementation is a convenient place to look up, hold, and
    bind data for a specific data model type and display component. Let''s go ahead
    and build a layout resource for the preceding diagram, and then we can create
    a `ViewHolder` to use it with a `RecyclerView`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前述每一项都需要不同的Android小部件，并且每次您想要填充它们时，都需要查找并将它们绑定到新的数据。`ViewHolder`实现是一个方便的地方，可以查找、保留和绑定特定数据模型类型和显示组件的数据。让我们继续为前面的图创建一个布局资源，然后我们可以创建一个`ViewHolder`来使用它与`RecyclerView`：
- en: In Android Studio, under the application resources (res) directory, right-click
    on the layout directory and select New| Layout resource file.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，在应用程序资源（res）目录下，右键单击布局目录并选择“新建|布局资源文件”：
- en: Name the new layout resource `card_claim_item`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的布局资源命名为`card_claim_item`。
- en: 'Change the Root element to `CardView`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素更改为`CardView`：
- en: '![](img/9252a871-8c69-479e-9a8e-f811caa9b3ca.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9252a871-8c69-479e-9a8e-f811caa9b3ca.png)'
- en: Click OK to create the new layout file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的布局文件：
- en: In the Palette, open the Layouts section and drag a `ConstraintLayout` into
    the Design canvas.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板中，打开布局部分，并将一个`ConstraintLayout`拖动到设计画布中：
- en: In the Palette, open the Images section and drag an `ImageView` into the Design
    canvas.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板中，打开图像部分，并将一个`ImageView`拖动到设计画布中：
- en: Select the `ic_other_black` icon from the drawable resource selector that automatically
    opens.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从自动打开的可绘制资源选择器中选择`ic_other_black`图标：
- en: 'Use the constraint editor on the right to add constraints to the top, left,
    and bottom of the new `ImageView`, and set all of them to 8, as shown:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右侧的约束编辑器添加到新`ImageView`顶部、左侧和底部的约束，并将所有这些设置为8，如下所示：
- en: '![](img/2da0a0d1-9057-46f6-baa6-caf326b33dbc.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2da0a0d1-9057-46f6-baa6-caf326b33dbc.png)'
- en: Change the ID of the `ImageView` to `item_category`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ImageView`的ID更改为`item_category`：
- en: In the Palette, open the Text section and drag a new `TextView` into the Design
    canvas to the right of the category icon `ImageView`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板中，打开文本部分，并将一个新的`TextView`拖动到设计画布中，位于类别图标`ImageView`的右侧：
- en: Use the constraint editor to add constraints of `8dp` to the top, right, and
    bottom of the new `TextView` so that it centers and places itself to the right
    of the Design canvas (directly opposite the category icon `ImageView`).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用约束编辑器为新`TextView`添加顶部、右侧和底部的`8dp`约束，以便它居中并放置在Design canvas的右侧（直接对应类别图标`ImageView`）：
- en: Change the ID of the `TextView` to `item_amount`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TextView`的ID更改为`item_amount`：
- en: 'Remove the contents of the text attribute, and change the text attribute below
    it (the one with the spanner icon) to `250`. This value is only used by the Design
    canvas, and allows you to preview what the layout will look like with set values
    (even though the real values are populated at runtime):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除文本属性的值，并将下面的文本属性（带有扳手图标的属性）更改为`250`。此值仅用于设计画布，并允许您预览设置值后的布局外观（尽管实际值在运行时填充）：
- en: '![](img/106fa629-d493-4c5d-81a9-56d974b9f2f2.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/106fa629-d493-4c5d-81a9-56d974b9f2f2.png)'
- en: Change the textAppearance attribute to `@style/TextAppearance.AppCompat.Medium`,
    which will appear in the drop-down as `AppCompat.Medium`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`textAppearance`属性更改为`@style/TextAppearance.AppCompat.Medium`，它将在下拉菜单中显示为`AppCompat.Medium`：
- en: From the Palette, drag another `TextView` into the design view, roughly between
    the icon `ImageView` and the amount `TextView`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板中拖动另一个`TextView`到设计视图中，大致位于图标`ImageView`和金额`TextView`之间：
- en: 'Drag a constraint from the left of the `TextView` to the right handle of the
    `ImageView`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`TextView`的左侧拖动一个约束到`ImageView`的右侧手柄：
- en: '![](img/6cbf6ca0-fcdc-4af8-8025-a9c72e7b6b69.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cbf6ca0-fcdc-4af8-8025-a9c72e7b6b69.png)'
- en: 'Drag another constraint from the right of the new `TextView` to the left of
    the amount `TextView`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新`TextView`的右侧拖动另一个约束到金额`TextView`的左侧：
- en: '![](img/b8d9f203-c38f-4ae7-bd53-786b4454340a.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8d9f203-c38f-4ae7-bd53-786b4454340a.png)'
- en: Use the constraint editor to add a constraint to the top of the new `TextView`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用约束编辑器为新`TextView`添加顶部约束：
- en: 'Set the top constraint to `8`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶部约束设置为`8`：
- en: '![](img/58ab0190-b105-4f8c-86c2-cc4ec50a1895.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58ab0190-b105-4f8c-86c2-cc4ec50a1895.png)'
- en: Change the `layout_width` attribute of the new `TextView` to `match_constraint`
    using the Attributes panel (just below the constraint editor).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用属性面板（位于约束编辑器下方）将新`TextView`的`layout_width`属性更改为`match_constraint`：
- en: Change the ID of the new `TextView` to `item_description`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新`TextView`的ID更改为`item_description`：
- en: Clear the text attribute, and set the Design text attribute to `Airport Shuttle`
    so that you still have something visible in the Design canvas.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除文本属性，并将设计文本属性设置为 `Airport Shuttle`，这样你仍然在设计画布上有所可见。
- en: Change the textAppearance attribute to `@style/TextAppearance.AppCompat.Medium`,
    which will appear in the drop-down as `AppCompat.Medium`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本外观属性更改为 `@style/TextAppearance.AppCompat.Medium`，它将在下拉菜单中显示为 `AppCompat.Medium`。
- en: From the Palette, drag a third `TextView` into the Design canvas and drop it
    between the category icon `ImageView` and the amount `TextView`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板中拖动第三个 `TextView` 到设计画布，并将其放在类别图标 `ImageView` 和金额 `TextView` 之间。
- en: Just like the description `TextView`, constrain the new `TextView` to the right
    of the category icon and to the left of the amount `TextView`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像描述 `TextView` 一样，将新的 `TextView` 约束到类别图标右侧和金额 `TextView` 左侧。
- en: 'Using the constraint editor, add a constraint at the bottom of the new `TextView`,
    and set its bottom margin to `8`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用约束编辑器，在新的 `TextView` 底部添加一个约束，并将其底部边距设置为 `8`：
- en: '![](img/6dc42f5a-4a43-4eb2-b06f-1fb6ffcf269a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dc42f5a-4a43-4eb2-b06f-1fb6ffcf269a.png)'
- en: Set the ID of the new `TextView` to `item_timestamp`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新 `TextView` 的 ID 设置为 `item_timestamp`。
- en: Change the layout_width of the new `TextView` to match_constraint.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新 `TextView` 的 `layout_width` 更改为 `match_constraint`。
- en: Drag a constraint from the top of the new `TextView` to the bottom of the description
    `TextView`; this will ensure that they have at least 8dp between them.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新 `TextView` 的顶部拖动一个约束到描述 `TextView` 的底部；这将确保它们之间至少有 8dp 的空间。
- en: Clear the text attribute, and set the Design tool text attribute to a date such
    as `27-December-2017`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除文本属性，并将设计工具文本属性设置为日期，例如 `27-December-2017`。
- en: In the Component Tree panel, select the `CardView` at the root of your layout.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件树面板中，选择布局根部的 `CardView`。
- en: Switch over to the View all attributes panel.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到查看所有属性面板。
- en: Open the Layout_Margin group.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开布局边距组。
- en: Set the top margin to `@dimen/grid_spacer1`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶部边距设置为 `@dimen/grid_spacer1`。
- en: 'Change the layout_height of the `CardView` to wrap_content; the layout will
    roll up looking something like this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CardView` 的 `layout_height` 设置为 `wrap_content`；布局将卷起，看起来像这样：
- en: '![](img/083ab09e-f133-47ad-a21a-bd2c2d4b0472.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/083ab09e-f133-47ad-a21a-bd2c2d4b0472.png)'
- en: Creating a simple ViewHolder class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的 ViewHolder 类
- en: 'Creating a `ViewHolder` is very simple, and it''s a good place to encapsulate
    any display specific logic for rendering the items for a `RecyclerView`. For the
    preceding layout, follow these steps to build a `ViewHolder`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `ViewHolder` 非常简单，并且这是一个封装 `RecyclerView` 中渲染项目特定逻辑的好地方。对于前面的布局，按照以下步骤构建一个
    `ViewHolder`：
- en: Right-click on the ui package in Android Studio, and select New| Java Class.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中的 ui 包上右键单击，并选择 New| Java Class。
- en: Name the new class `ClaimItemViewHolder`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `ClaimItemViewHolder`。
- en: Set the new classes Superclass to `android.support.v7.widget.RecyclerView.ViewHolder`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类的父类设置为 `android.support.v7.widget.RecyclerView.ViewHolder`。
- en: Click OK to create the new class.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定以创建新的类。
- en: 'The main job of a `ViewHolder` is to speed up the binding between the data
    model and the user interface widgets and for that to happen, the `ViewHolder`
    needs references to each of the `View` objects it will populate:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewHolder` 的主要任务是加快数据模型与用户界面小部件之间的绑定，为此，`ViewHolder` 需要引用它将要填充的每个 `View`
    对象：'
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `ViewHolder` will also need a way to format the timestamp, and the best
    way to do that is with a `java.text.DateFormat`, which is also something to keep
    a reference to as they''re quite expensive to construct:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `ViewHolder` 还需要一种格式化时间戳的方法，而最好的方法就是使用 `java.text.DateFormat`，这也是需要保留引用的东西，因为它们构建起来相当昂贵：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `ViewHolder` is usually constructed with the `View` object it''s expected
    to bind to. You can inflate the `View` object within the `ViewHolder` constructor,
    but to keep things flexible and avoid argument clutter on the constructor, this
    `ViewHolder` implementation will just take the `View` object it will wrap:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewHolder` 通常使用它预期绑定到的 `View` 对象来构建。你可以在 `ViewHolder` 构造函数中填充 `View` 对象，但为了保持灵活性并避免在构造函数中产生参数混乱，这个
    `ViewHolder` 实现将只接受它将要包装的 `View` 对象：'
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You also need to create the `DateFormat` object and, for this, you want the
    long date format in the user''s current locale:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要创建一个 `DateFormat` 对象，并且你希望使用用户当前区域的长时间日期格式：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This class will need a utility method to figure out which icon should be rendered
    for a `Category` that will involve manually referencing the application `Resources`
    to retrieve the black versions of the category icons:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类需要一个工具方法来确定应该渲染哪个图标用于 `Category`，这将涉及手动引用应用程序的 `Resources` 来检索类别图标的黑色版本：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You''ll also need a utility method to format the amounts so that integer amounts
    don''t have any decimal component, while non-integers only display two decimal
    places:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要一个工具方法来格式化金额，使得整数金额没有小数部分，而非整数只显示两位小数：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you need a way for the adapter to populate all the `View` elements
    with data, and because this class is specific to the `ClaimItem` data objects,
    you can make this simple by having a setter-like method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要一种方式让适配器用数据填充所有 `View` 元素，并且因为这个类是针对 `ClaimItem` 数据对象的，你可以通过提供一个类似设置器的方法来简化这个过程：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating a ViewHolder with data binding
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据绑定创建 ViewHolder
- en: As you can see from building a traditional `ViewHolder` implementation, there
    is quite a lot of work and boilerplate code required just to put the data from
    a single item onto the screen in a layout. Further, it's actually quite expensive
    in its own right, because every one of the `ViewHolder` instances creates and
    holds an instance of the `DateFormatter` where they can easily be shared between
    all the `ClaimItemViewHolder` instances for a `RecyclerView`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从构建传统的 `ViewHolder` 实现中看到的那样，仅仅为了将单个项目中的数据放置在布局中，就需要做很多工作，并且有很多样板代码。此外，它本身实际上相当昂贵，因为每个
    `ViewHolder` 实例都会创建并持有 `DateFormatter` 的一个实例，它们可以很容易地在 `RecyclerView` 的所有 `ClaimItemViewHolder`
    实例之间共享：
- en: 'In cases like this, data binding can make a huge difference. Using a few tricks,
    you can actually create a completely generic `ViewHolder` implementation that
    will work for any data object in your application (assuming that you can bind
    it to a layout file). First, you''ll need to create a nice generic `ItemPresenter`,
    and then modify the layout, and then you''re ready to create a generic data-binding
    `ViewHolder` implementation. Follow these instructions, and you''ll only ever
    need one `ViewHolder` implementation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据绑定可以带来巨大的差异。通过使用一些技巧，你实际上可以创建一个完全通用的 `ViewHolder` 实现，它将适用于你应用程序中的任何数据对象（假设你可以将其绑定到布局文件）。首先，你需要创建一个漂亮的通用
    `ItemPresenter`，然后修改布局，然后你就可以创建一个通用的数据绑定 `ViewHolder` 实现了。按照这些说明操作，你将只需要一个 `ViewHolder`
    实现：
- en: Right-click on the presenters package in Android Studio, and select New| Java
    Class.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，右键单击 `presenters` 包，然后选择 New| Java Class。
- en: Name the class `ItemPresenter`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为 `ItemPresenter`。
- en: Click OK to create the new class.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'The `ItemPresenter` will need a `Context` to reference application `Resources`
    and files:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ItemPresenter` 需要一个 `Context` 来引用应用程序的 `Resources` 和文件：'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `formatAmount` utility method the same way as in the simple `ViewHolder`
    class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与简单 `ViewHolder` 类中相同方式的 `formatAmount` 工具方法：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Write a `getCategoryIcon` utility method into the new `ItemPresenter` (this
    is almost exactly the same as the one in the `ClaimItemViewHolder`, except in
    how it accesses the `Resources` object):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `ItemPresenter` 中编写一个 `getCategoryIcon` 工具方法（这几乎与 `ClaimItemViewHolder`
    中的方法完全相同，只是在访问 `Resources` 对象的方式上有所不同）：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Write a `formatDate` utility method that will convert the `Date` objects into
    text suitable for displaying on the screen. The conversion is done by a `DateFormat`
    object, which is only created the first time `formatDate` is called (it is lazy-initialized).
    The lazy-initialization is important, as this class is expected to be generic
    across all possible item presenters in the application and so, there will be cases
    where it''s not used:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `formatDate` 工具方法，将 `Date` 对象转换为适合在屏幕上显示的文本。转换是通过一个 `DateFormat` 对象完成的，它仅在第一次调用
    `formatDate` 时创建（它是延迟初始化的）。延迟初始化很重要，因为这个类预期将在应用程序中所有可能的项表示器中通用，因此，将会有一些情况下它不会被使用：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, open the `card_claim_item.xml` layout resource.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `card_claim_item.xml` 布局资源。
- en: Change to the Text view in the editor.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中切换到文本视图。
- en: 'Create a new layout root element above the `CardView`, and ensure that you
    remove the namespace declarations from the `CardView` and close the layout element
    at the end of the file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CardView` 上方创建一个新的布局根元素，并确保从 `CardView` 中移除命名空间声明，并在文件末尾关闭布局元素：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Above the `CardView`, declare a data block with two variables. It''s important
    to keep these names generic. One will be an instance of `ItemPresenter`, and the
    other will be the `ClaimItem` to be bound by the layout:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CardView`上方声明一个包含两个变量的数据块。保持这些名称的泛型是很重要的。一个将是`ItemPresenter`的实例，另一个将是布局要绑定的`ClaimItem`：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Find the `ImageView` declaration for `item_category` and add a new data-bound
    attribute to use the `ItemPresenter` to find the correct icon:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`item_category`的`ImageView`声明，并添加一个新的数据绑定属性，使用`ItemPresenter`找到正确的图标：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Find the amount `TextView` declaration and data bind its text attribute, using
    the presenter to format the amount from the `ClaimItem`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`TextView`的声明并绑定其文本属性，使用`Presenter`将`ClaimItem`中的金额格式化：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Data bind the description from the `ClaimItem` to the `item_description` `TextView`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ClaimItem`中的描述数据绑定到`item_description` `TextView`：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the presenter to data bind the timestamp from the `ClaimItem` to the timestamp
    `TextView`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Presenter`将`ClaimItem`中的时间戳数据绑定到时间戳`TextView`：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, it's time to start on a generic `ViewHolder` class that can be reused with
    any data-bound layout. Right-click on the ui package and select New | Java Class.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候开始创建一个通用的`ViewHolder`类，它可以与任何数据绑定布局一起重用。在`ui`包上右键单击，然后选择“新建 | Java类”。
- en: Name the new class `DataBoundViewHolder`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`DataBoundViewHolder`。
- en: Change the Superclass to `android.support.v7.widget.RecyclerView.ViewHolder`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将超类改为`android.support.v7.widget.RecyclerView.ViewHolder`。
- en: Click OK to create the new class.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'Add a generic declaration to the class so that you have generic types for the
    Presenter, and Item (P, I) variables:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个泛型声明，以便为`Presenter`和Item（P，I）变量提供泛型类型：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Every Binding class generated by the data binding system extends `ViewDataBinding`;
    the `DataBoundViewHolder` will actually wrap one of these so that any data-bound
    layout can be wrapped:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据绑定系统生成的每个绑定类都扩展了`ViewDataBinding`；`DataBoundViewHolder`实际上将包装这些之一，以便任何数据绑定布局都可以被包装：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, write a constructor that takes a `ViewDataBinding` object and a Presenter
    object for the data-bound layout to use. As `ViewDataBinding` is a generic abstract
    class, we can''t directly call the `setPresenter` method that will be generated
    by the data binding system in the `CardClaimItemBinding` class. Instead, we can
    use a special generic data binding method that allows you to assign unknown variables
    based on a generated ID number; this is a bit like using Java reflection, except
    that the actual implementation is generated at compile time and is very fast:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写一个构造函数，它接受一个`ViewDataBinding`对象和一个用于数据绑定布局的`Presenter`对象。由于`ViewDataBinding`是一个泛型抽象类，我们无法直接调用在`CardClaimItemBinding`类中由数据绑定系统生成的`setPresenter`方法。相反，我们可以使用一个特殊的泛型数据绑定方法，它允许你根据生成的ID号分配未知变量；这有点像使用Java反射，但实际的实现是在编译时生成的，并且非常快：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are presented with a choice of multiple `BR` classes to import, use the
    one for your own project (`com.packtpub.claim`). Much like the normal Android
    resources (`R`), the data binding system generates a lookup class for each project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你面临多个`BR`类的选择，请使用你自己的项目（`com.packtpub.claim`）的类。与正常的Android资源（`R`）类似，数据绑定系统为每个项目生成一个查找类。
- en: 'Then, write in two setter methods so that the `Presenter` and `item` variables
    can be changed uniformly from the outside:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编写两个setter方法，以便可以从外部统一更改`Presenter`和`item`变量：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `setVariable` method is generated at compile time, just like the getter
    and setter methods as a series of `if` statements. This makes it a little slower
    than the actual setter methods, but much faster than using reflection to invoke
    the setter methods. It's not the sort of area that should need optimization, especially
    as there are only two possible variables for these data-bound layouts. If your
    layout needs more than these two variables in a `RecyclerView`, you should consider
    composing or inheriting the logic and data required into more specific classes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`setVariable`方法在编译时生成，就像getter和setter方法一样，由一系列`if`语句组成。这使得它比实际的setter方法慢一点，但比使用反射调用setter方法要快得多。这不是需要优化的区域，特别是当这些数据绑定布局只有两个可能的变量时。如果你的布局在`RecyclerView`中需要超过这两个变量，你应该考虑将这些逻辑和数据组合或继承到更具体的类中。'
- en: 'The generated `setVariable` implementation of the `card_claim_item` layout
    defined in this section will look something like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中定义的`card_claim_item`布局生成的`setVariable`实现将类似于以下内容：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this code will execute very quickly and won't throw exceptions
    if an unknown variable ID is given. However, it will throw a `ClassCastException`
    if you tried to pass in the wrong type for a data-bound variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码将非常快速地执行，如果给出了未知变量ID，则不会抛出异常。然而，如果您尝试为数据绑定变量传递错误类型，它将抛出`ClassCastException`。
- en: Creating a RecyclerView adapter
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RecyclerView适配器
- en: 'In order to get data into a `RecyclerView`, you need an `Adapter` class, not
    unlike the `PagerAdapter` you wrote to display the attachment previews for the
    `CaptureClaimActivity`. However, `RecyclerView` does a lot more of the heavy lifting
    than `ViewPager` and as a result, what you can and can''t do inside the adapter
    is far more restricted than with `PagerAdapter`. Also, unlike a `PagerAdapter`,
    a `RecylcerView` adapter has two actions that are involved in displaying each
    element: create and bind. When the `RecyclerView` needs a new child widget for
    an element, it will invoke `onCreateViewHolder`, which should return an unpopulated
    `ViewHolder`, which will then be passed to `onBindViewHolder` where the data should
    be mapped into the `View` from whatever data source the adapter uses.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据放入`RecyclerView`中，你需要一个`Adapter`类，这类似于你为显示`CaptureClaimActivity`的附件预览而编写的`PagerAdapter`。然而，`RecyclerView`比`ViewPager`做了更多繁重的工作，因此，在适配器内部可以和不可以做的事情比`PagerAdapter`要受到更多的限制。此外，与`PagerAdapter`不同，`RecyclerView`适配器涉及两个与显示每个元素相关的操作：创建和绑定。当`RecyclerView`需要为元素创建一个新的子视图小部件时，它将调用`onCreateViewHolder`，这个方法应该返回一个未填充的`ViewHolder`，然后这个`ViewHolder`将被传递到`onBindViewHolder`，在那里应该将数据映射到从适配器使用的任何数据源中。
- en: First off, the `RecyclerView` maintains the list of its child views completely,
    so the adapter must never add or remove them directly. Secondly, the `RecyclerView`
    expects the adapter to be stable, that is, the data within the adapter must not
    change without telling the `RecyclerView` about the changes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`RecyclerView`完全维护其子视图的列表，因此适配器绝不能直接添加或删除它们。其次，`RecyclerView`期望适配器是稳定的，也就是说，适配器内部的数据必须在通知`RecyclerView`的情况下才能改变。
- en: Unlike older recycling widget classes like `ListView` and `GridView`, `RecyclerView`
    does not assume that it's presenting the same object model over and over. Instead,
    each object returned from the `Adapter` can optionally have a view type indicator;
    when these are different, the `RecylcerView` maintains a separate pool for each
    of the view types and recycles all of them separately.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与像`ListView`和`GridView`这样的旧回收小部件类不同，`RecyclerView`并不假设它一次又一次地展示相同的对象模型。相反，从`Adapter`返回的每个对象可以可选地有一个视图类型指示器；当这些不同时，`RecyclerView`为每个视图类型维护一个单独的池，并分别回收它们。
- en: When using different view types, it's common for the adapter to use the layout
    resource ID as the view type; these are unique per application and avoid any need
    for a `switch` statement or similar mapping between internal view type IDs and
    the actual resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不同的视图类型时，适配器通常使用布局资源ID作为视图类型；这些在应用程序中是唯一的，避免了在内部视图类型ID和实际资源之间进行`switch`语句或类似映射的需要。
- en: 'For the travel claim example, you will need an adapter to display all the `ClaimItems`
    on the overview screen. Fortunately, Room provides you with a prebuilt `LiveData`,
    which can be observed directly, which makes building the adapter much simpler.
    Follow these simple steps to build a `RecyclerView` adapter bound to a `LiveData`
    object, and use the `DataBoundViewHolder` to present the data to the user:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旅行索赔示例，您需要一个适配器来在概览屏幕上显示所有的`ClaimItems`。幸运的是，Room为您提供了预构建的`LiveData`，可以直接观察，这使得构建适配器变得简单得多。按照以下简单步骤构建一个绑定到`LiveData`对象的`RecyclerView`适配器，并使用`DataBoundViewHolder`将数据展示给用户：
- en: Right-click on the ui package and select New| Java Class.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击ui包，选择New| Java Class。
- en: Name the new class `ClaimItemAdapter`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`ClaimItemAdapter`。
- en: Click OK to create the new class.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'Change the class declaration to extend from `RecyclerView.Adapter` and describe
    the `DataBoundViewHolder` generic you will be using:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类声明修改为继承自`RecyclerView.Adapter`，并描述你将使用的`DataBoundViewHolder`泛型：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This adapter class will inflate the data-bound layout files as resources, so
    it''ll need a `LayoutInflator` to do the work for it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此适配器类将作为资源填充数据绑定的布局文件，因此它需要一个`LayoutInflator`来完成这项工作：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ItemPresenter` instances can also be shared between all the claim item
    layouts that are on screen, so the `ClaimItemAdapter` should hold a reference
    to it:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ItemPresenter`实例也可以在屏幕上所有显示的索赔项布局之间共享，因此`ClaimItemAdapter`应该持有它的引用：'
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Most importantly, the `ClaimItemAdapter` needs data to display. Ensure that
    you instantiate this reference so that you don''t need null-checks in your other
    methods:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的是，`ClaimItemAdapter`需要数据来展示。确保你实例化这个引用，这样你就不需要在其他方法中进行空检查：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, declare a constructor for `ClaimItemAdapter`; as `ClaimItemAdapter` will
    observe a `LiveData` object, it''ll need a `LifecycleOwner` as well. The `LifecycleOwner`
    tells the `LiveData` when to notify you of changes, and when not to and also when
    to unregister any listeners. Typical `LifecycleOwners` are `Activity` or `Fragment`
    instances, but you can make almost any class a `LifecycleOwner`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，声明一个`ClaimItemAdapter`的构造函数；由于`ClaimItemAdapter`将观察一个`LiveData`对象，它需要一个`LifecycleOwner`。`LifecycleOwner`告诉`LiveData`何时通知你变化，何时不通知，以及何时注销任何监听器。典型的`LifecycleOwners`是`Activity`或`Fragment`实例，但你几乎可以将任何类变成`LifecycleOwner`：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For further flexibility, you can allow the `ItemPresenter` to be passed into
    the constructor. This will allow the `ItemPresenter` to be extended or configured
    outside of the `ClaimItemAdapter` objects, and each instance can be given different
    presentation rules.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更大的灵活性，你可以允许将`ItemPresenter`传递给构造函数。这将允许在`ClaimItemAdapter`对象外部扩展或配置`ItemPresenter`，并且每个实例都可以有不同的展示规则。
- en: 'Note that the `ClaimItemAdapter` doesn''t keep a reference to the `LiveData`
    instance yet, and in fact, it won''t directly hold a reference at all. Instead,
    you''ll use an anonymous inner class (or lambda if it''s available to you) to
    observe the `LiveData`. It''s important to know that when you start observing
    a `LiveData` instance, you will automatically get an *initial* event with the
    current state of the data, if your `LifecycleOwner` is in the correct state. This
    means you should never need to attempt to fetch the data directly:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`ClaimItemAdapter`还没有保留对`LiveData`实例的引用，实际上，它根本不会直接持有任何引用。相反，你将使用匿名内部类（如果可用的话，可以使用lambda表达式）来观察`LiveData`。重要的是要知道，当你开始观察一个`LiveData`实例时，如果你的`LifecycleOwner`处于正确的状态，你将自动接收到一个*初始*事件，其中包含数据的当前状态。这意味着你永远不需要尝试直接获取数据：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now the constructor is complete, and it''s time to implement the binding-related
    features. The first step is to implement `onCreateViewHolder`, which will use
    the `DataBindingUtil` to create the layout and the `ViewDataBinding` that the
    `DataBoundViewHolder` will wrap:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构造函数已经完成，是时候实现与绑定相关的功能了。第一步是实现`onCreateViewHolder`，这将使用`DataBindingUtil`来创建布局和`ViewDataBinding`，后者将被`DataBoundViewHolder`包装：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Due to the `DataBoundViewHolder` implementation, the `onBindViewHolder` method
    is trivial to implement:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`DataBoundViewHolder`的实现，`onBindViewHolder`方法非常容易实现：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `RecyclerView` also needs to know how many items are in the data model:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecyclerView`还需要知道数据模型中有多少项：'
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This adapter can be very easily adapted further in the same way as the `DataBoundViewHolder`,
    to allow you to present any `LiveData` list returned from a Room database with
    an arbitrary data-bound layout file. The combination of data binding and `LiveData`
    makes for an extremely powerful combination that dramatically simplifies your
    user-interface code, and avoids the need to write lots of boilerplate structure
    for every combination of views and models.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此适配器可以非常容易地进一步适应，就像`DataBoundViewHolder`一样，允许你使用任意数据绑定的布局文件展示从Room数据库返回的任何`LiveData`列表。数据绑定和`LiveData`的结合是一个非常强大的组合，极大地简化了你的用户界面代码，并避免了为每种视图和模型组合编写大量样板结构的需要。
- en: Data binding an adapter
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定适配器
- en: 'If you want to use data binding on a layout with a `RecyclerView` in it, you
    can even data bind the adapter object to the `RecyclerView`. All you need to do
    is expose a method to access the desired adapter object in a presenter class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在包含`RecyclerView`的布局上使用数据绑定，你甚至可以将适配器对象数据绑定到`RecyclerView`。你所需做的只是在一个表示类中公开一个方法来访问所需的适配器对象：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s important that you preconstruct or cache the instances you create to
    avoid recreating the adapter object unnecessarily. It''s also important to remember
    not to make the adapter an `ObservableField` or similar, since the adapter''s
    content should be what changes, not the adapter itself. To bind the `RecyclerView`
    to its adapter, use the data binding system''s *auto property* system:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是你预先构建或缓存你创建的实例，以避免不必要地重新创建适配器对象。同时，也要记住不要将适配器设置为`ObservableField`或类似类型，因为适配器的内容应该是变化的，而不是适配器本身。要绑定`RecyclerView`到其适配器，请使用数据绑定系统的*自动属性*系统：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's really important when using data binding and adapter views together to
    remember that they both update the user interface. As such, it's important to
    ensure that you keep the adapter reference in the presenter stable, and don't
    change it without being sure of yourself. Changing the adapter reference will
    cause the `AdapterView` (such as a `RecyclerView`) to completely rebuild its contents
    rather than just refreshing its contents. It's much better to use the adapter
    to notify the `AdapterView` of changes than it is to make the adapter observable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据绑定和适配器视图一起时，记住它们都会更新用户界面是非常重要的。因此，确保你保持适配器引用在表示者中稳定，并且在没有确定的情况下不要更改它。更改适配器引用将导致`AdapterView`（例如`RecyclerView`）完全重建其内容，而不是仅仅刷新其内容。使用适配器来通知`AdapterView`变化，比使适配器可观察要好得多。
- en: Creating the Overview activity
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建概览活动
- en: The travel claim example app needs a nice overview activity to tie together
    the allowance overview, a list of the claim items, and a way for the user to create
    new claim items. As we have a Room database, things can become significantly more
    decoupled, and that's a really good thing. Having a central reactive source of
    data allows different parts of your application to always reflect the actual state
    of the application as it changes, without having to coordinate with each other.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行报销示例应用需要一个很好的概览活动来整合津贴概览、报销项列表以及用户创建新报销项的方式。由于我们有Room数据库，事情可以变得显著地更加解耦，这真的是一件好事。拥有一个中央的响应式数据源允许应用程序的不同部分始终反映应用程序的实际状态，而无需相互协调。
- en: 'The first part of building the `OverviewActivity` is creating the `Activity`
    class itself and populating it with the claim items that the user has entered.
    Follow these steps to create a skeleton `OverviewActivity` and register it as
    the main `Activity` for the application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`OverviewActivity`的第一部分是创建`Activity`类本身，并用用户输入的报销项填充它。按照以下步骤创建一个骨架`OverviewActivity`并将其注册为应用程序的主`Activity`：
- en: Start by right-clicking on your main package (that is, com.packtpub.claim) and
    selecting New | Activity | Empty Activity from the menu.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先右键单击你的主包（即com.packtpub.claim），然后从菜单中选择New | Activity | Empty Activity。
- en: Name the new class `OverviewActivity`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`OverviewActivity`。
- en: Leave all the other fields as their defaults and select Finish to create the
    new `Activity` and its layout file.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他字段保留为默认值，并选择Finish以创建新的`Activity`及其布局文件。
- en: Open the new `activity_overview.xml` layout file and change to the Text editor.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的`activity_overview.xml`布局文件并切换到文本编辑器。
- en: 'Android Studio will have placed a `ConstraintLayout` as the root element; change
    it to a `FrameLayout` instead, because this layout is very simple and since the
    logic will be self-binding, there is no point in using a data-bound layout:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android Studio已经将`ConstraintLayout`作为根元素放置好了；将其更改为`FrameLayout`，因为这个布局非常简单，而且由于逻辑将是自绑定，使用数据绑定布局就没有意义了：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A **FrameLayout** is a very simple layout where its children are rendered on
    top of each other. The first child is painted first, and then the second child
    is painted on top of the first. This makes it ideally suited for building layered
    scenes, even when some layers will not always be visible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**FrameLayout**是一个非常简单的布局，其中其子元素是相互叠加渲染的。第一个子元素先被绘制，然后第二个子元素在第一个子元素之上被绘制。这使得它非常适合构建分层场景，即使某些层可能不会总是可见。'
- en: 'The first child of the `FrameLayout` will be a simple `LinearLayout` to allow
    you to place the allowance overview above the scrolling list of claim items. `LinearLayout`
    is ideal here as it''s a very simple and very fast layout to use, and we don''t
    need the complexities of a `ConstraintLayout`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FrameLayout`的第一个子元素将是一个简单的`LinearLayout`，以便你可以在报销项滚动列表上方放置津贴概览。在这里使用`LinearLayout`是理想的，因为它是一个非常简单且非常快的布局，我们不需要`ConstraintLayout`的复杂性：'
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first child of the `LinearLayout` is the `AllowanceOverviewFragment`, which
    will allow the user to edit their daily allowance and see how much they''re spending:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LinearLayout`的第一个子元素是`AllowanceOverviewFragment`，它将允许用户编辑他们的每日津贴并查看他们花费了多少：'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next comes the `RecyclerView`, which will display a scrolling list of the claim
    items that the user has entered. Note the clipping and padding attributes here;
    they ensure that the claim item cards are inset, but that their full borders and
    shadows will be visible:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`RecyclerView`，它将显示用户输入的报销项的滚动列表。注意这里的裁剪和填充属性；它们确保报销项卡片有内边距，但它们的完整边框和阴影将可见：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, open the `OverviewActivity` class that Android Studio generated; it's time
    to populate the layout with claim items.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 Android Studio 生成的 `OverviewActivity` 类；是时候用声明项填充布局了。
- en: 'We''ll be rendering a list of `ClaimItem` objects using the `ClaimItemAdapter`,
    and it needs to watch for changes using the `LiveData` object produced by the
    database. This requires that the `Activity` report its life cycle, and this is
    done by extending one of the `Activity` implementations provided by the support
    packages (in this case, `AppCompatActivity`):'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `ClaimItemAdapter` 渲染 `ClaimItem` 对象的列表，并且它需要使用数据库产生的 `LiveData` 对象来监视变化。这要求
    `Activity` 报告其生命周期，这通过扩展支持包提供的 `Activity` 实现之一（在这种情况下，`AppCompatActivity`）来完成：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As all the behavior for this Activity is actually handled by its fragments
    and by the `LiveData` changes triggered by the `ClaimDatabase`, the `onCreate`
    implementation only needs to set the adapter for the `RecyclerView`. All other
    logic and behavior for the `OverviewActivity` will be handled by the fragments
    and adapter:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此 `Activity` 的所有行为实际上都是由其片段和由 `ClaimDatabase` 触发的 `LiveData` 变化处理的，因此 `onCreate`
    实现只需要设置 `RecyclerView` 的适配器。`OverviewActivity` 的所有其他逻辑和行为将由片段和适配器处理：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, you'll need to change the `AndroidManifest.xml` file to tell the system
    that the main entry point for the application is now the `OverviewActivity`, and
    not the `CaptureClaimActivity`; open the `manifests` folder near the top of your
    projects file-tree and open the `AndroidManifest.xml` file.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要更改 `AndroidManifest.xml` 文件，告诉系统应用程序的主入口点是 `OverviewActivity`，而不是 `CaptureClaimActivity`；打开项目文件树顶部附近的
    `manifests` 文件夹，并打开 `AndroidManifest.xml` 文件。
- en: 'Change the activity element declarations so that the MAIN / LAUNCHER intent-filter
    is in the `OverviewActivity` element instead of the `CaptureClaimActivity` element.
    It''s also worth changing the `windowSoftInputMode` attribute so that the software
    keyboard doesn''t automatically open when the `OverviewActivity` is started. The
    keyboard opens by default because the first widget on the screen is the `EditText`
    field, where the user can enter their daily allowance:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改活动元素声明，使 MAIN / LAUNCHER intent-filter 在 `OverviewActivity` 元素中而不是 `CaptureClaimActivity`
    元素中。还值得更改 `windowSoftInputMode` 属性，以便在启动 `OverviewActivity` 时软件键盘不会自动打开。键盘默认打开，因为屏幕上的第一个小部件是
    `EditText` 字段，用户可以在其中输入他们的每日津贴：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you now run your application, you''ll see that while the screen is technically
    complete, there are no claim items and no way to add them. As such, there is nothing
    in the `RecyclerView` to look at or scroll through:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用程序，你会看到虽然屏幕在技术上已经完成，但没有声明项，也没有添加它们的方法。因此，`RecyclerView` 中没有内容可供查看或滚动：
- en: '![](img/2c19f042-71c9-42b4-aad1-d96b93993b2f.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c19f042-71c9-42b4-aad1-d96b93993b2f.png)'
- en: You need to provide a way for your user to add new claim items. The best way
    is with a floating action button in the bottom-right corner of the screen, and
    we'll be doing that with a new `Fragment`. By using a `Fragment` for this task,
    you'll be able to place a "new item" floating action button on any screen in the
    application without having to implement any special code in the `Activity` class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要提供一个方法让用户添加新的声明项。最好的方法是在屏幕右下角使用一个浮动操作按钮，我们将使用一个新的 `Fragment` 来实现这一点。通过使用
    `Fragment` 来完成这项任务，你可以在应用程序的任何屏幕上放置一个“新建项”浮动操作按钮，而无需在 `Activity` 类中实现任何特殊代码。
- en: Creating new ClaimItems with a Fragment
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段创建新的声明项
- en: 'An unusual property of using `LiveData` from a Room database is that various
    parts of your application can now interact without needing any direct knowledge
    of each other. In the case of your `OverviewActivity`, this will allow you to
    populate the database with new `ClaimItem` entities without dispatching any sort
    of "new item" or "item added" events to the `ClaimItemAdapter`. However, the Room
    database abstraction layer prevents you from running any query on the main thread
    unless it returns a `LiveData`. While the query to retrieve the `ClaimItem` entities
    returned a `LiveData`, inserting new `LiveData` entities will be required to run
    in the background. Follow these steps to build a `Fragment` that can allow the
    user to capture and record a new travel claim item:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Room 数据库中的 `LiveData` 的一个不寻常的特性是，现在应用程序的各个部分可以相互交互，而无需相互直接了解。在你的 `OverviewActivity`
    的情况下，这将允许你在不向 `ClaimItemAdapter` 发送任何“新项目”或“项目已添加”事件的情况下，用新的 `ClaimItem` 实体填充数据库。然而，Room
    数据库抽象层阻止你在主线程上运行任何查询，除非它返回 `LiveData`。虽然检索 `ClaimItem` 实体的查询返回了 `LiveData`，但插入新的
    `LiveData` 实体需要在后台运行。按照以下步骤构建一个允许用户捕捉和记录新的旅行索赔项的 `Fragment`：
- en: You'll need a task to insert both a `ClaimItem` entity and any `Attachment`
    entities associated with it. This task will need to run on a background worker
    thread, so open the `ClaimDatabase` class in Android Studio.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一项任务来插入一个 `ClaimItem` 实体以及与其相关的任何 `Attachment` 实体。这项任务需要在后台工作线程上运行，因此打开 Android
    Studio 中的 `ClaimDatabase` 类。
- en: 'After the abstract methods that return, the `ClaimItemDao` and `AttachmentDao`
    declare a new method to return a `Runnable` task to insert a new `ClaimItem`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回抽象方法的后面，`ClaimItemDao` 和 `AttachmentDao` 声明了一个新的方法，该方法返回一个插入新 `ClaimItem`
    的 `Runnable` 任务：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Within the new `Runnable` task, you''ll want to use a transaction to save the
    contents of the `ClaimItem` object into the database; if any part of this method
    fails, the transaction will be rolled back, and the method will have had no effect:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `Runnable` 任务中，你希望使用事务将 `ClaimItem` 对象的内容保存到数据库中；如果此方法的任何部分失败，事务将被回滚，并且该方法将没有任何效果：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You'll also need a method in `ClaimItem` to ensure that it has content and is
    considered valid, so open the `ClaimItem` class.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要在 `ClaimItem` 中有一个方法来确保它有内容并且被认为是有效的，因此打开 `ClaimItem` 类。
- en: 'At the end of the `ClaimItem` class, create a new `isValid` method; this will
    be used when the `CaptureClaimActivity` returns a `ClaimItem` to check whether
    we should store the new `ClaimItem` in the database:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ClaimItem` 类的末尾创建一个新的 `isValid` 方法；这将用于在 `CaptureClaimActivity` 返回 `ClaimItem`
    时检查我们是否应该将新的 `ClaimItem` 存储到数据库中：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You'll need a new icon for adding claim items; right-click on the drawable resource
    directory and select New| Vector Asset.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个用于添加索赔项的新图标；在可绘制资源目录上右键单击，然后选择新建|矢量资产。
- en: Using the Icon selector, find and select the icon named `add`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图标选择器找到并选择名为 `add` 的图标。
- en: Name the new icon resource `ic_add_white_24dp`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的图标资源命名为 `ic_add_white_24dp`。
- en: Click on Next and then on Finish to create the new resource.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步然后点击完成以创建新的资源。
- en: Open the new icon resource in the Android Studio text editor.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 文本编辑器中打开新的图标资源。
- en: 'Change the `fillColor` attribute of the path element to make it white:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径元素的 `fillColor` 属性更改为白色：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, right-click on the ui package and select New| Fragment| Fragment (Blank).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 ui 包上右键单击，然后选择新建|片段|片段（空白）。
- en: Name the new `Fragment` class `NewClaimItemFloatingActionButtonFragment`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `Fragment` 类命名为 `NewClaimItemFloatingActionButtonFragment`。
- en: Turn off the Include fragment factory methods and Include interface callbacks
    options.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭包含片段工厂方法和包含接口回调选项。
- en: Click on the Finish button to create the new `Fragment` class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成按钮以创建新的 `Fragment` 类。
- en: Open the new layout file that should be called `fragment_new_claim_item_floating_action_button.xml`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的布局文件，该文件应命名为 `fragment_new_claim_item_floating_action_button.xml`。
- en: 'Replace the content of this file with just a `FloatingActionButton`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个 `FloatingActionButton` 替换此文件的内容：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, open the new `NewClaimItemFloatingActionButtonFragment` class.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开新的 `NewClaimItemFloatingActionButtonFragment` 类。
- en: 'Change the class declaration to implement the `View.OnClickListener` interface:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类声明更改为实现 `View.OnClickListener` 接口：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Declare a request-code to be used when sending the user to the `CaptureClaimActivity`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个请求码，用于将用户发送到 `CaptureClaimActivity`：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Change the `onCreateView` method to also set the `OnClickListener` of the `FloatingActionButton`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onCreateView` 方法更改为同时设置 `FloatingActionButton` 的 `OnClickListener`：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Override the `onClick` method from the `View.OnClickListener` and start the
    `CaptureClaimActivity` for result:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onClick`方法从`View.OnClickListener`并启动`CaptureClaimActivity`以获取结果：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Override the `onActivityResult` method to handle the incoming `ClaimItem`,
    and if it''s valid, save it in the database using the `SERIAL_EXECUTOR` from `AsyncTask`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onActivityResult`方法以处理传入的`ClaimItem`，如果它是有效的，则使用`AsyncTask`的`SERIAL_EXECUTOR`将其保存到数据库中：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, you'll need to add the new fragment to the `OverviewActivity`. Open the
    `activity_overview` layout file and change to Text mode.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要将新片段添加到`OverviewActivity`中。打开`activity_overview`布局文件并切换到文本模式。
- en: 'At the bottom of the `FrameLayout` root element, include a fragment tag referencing
    the `NewClaimItemFloatingActionButtonFragment` and position it at the bottom-right
    of the screen:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FrameLayout`根元素的底部，包含一个引用`NewClaimItemFloatingActionButtonFragment`的片段标签，并将其定位在屏幕的右下角：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now you should be able to run the application again; not only should you now
    have a floating action button at the bottom of the overview screen, but it will
    work! If you click on the button and capture some details on the `CaptureClaimActivity`
    and then select to navigate back to the `OverviewActivity`, the new claim item
    will appear in the list, sorted by date.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够再次运行应用程序了；不仅你现在的概览屏幕底部应该有一个浮动操作按钮，而且它将正常工作！如果你点击该按钮并在`CaptureClaimActivity`上捕获一些细节，然后选择导航回`OverviewActivity`，新的索赔项目将出现在列表中，按日期排序。
- en: Unlike using `SQLiteDatabase` directly, Room will enforce only running queries
    on a worker thread. This makes it attractive to encapsulate your updates in a
    `Runnable` that can be run on a background thread such as you did with the `createClaimItemTask`
    in the `ClaimDatabase` class. Having these methods available on the `ClaimDatabase`
    makes them easily reusable, and keeps the logic consistent throughout your application.
    It also allows you to put them into queues or run them in parallel with other
    tasks if you choose to use a thread-pool instead of the `SERIAL_EXECUTOR` from
    `AsyncTask` (which will only run one task at a time).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接使用`SQLiteDatabase`相比，Room将只允许在工作线程上运行查询。这使得将更新封装在可以在后台线程上运行的`Runnable`中（就像你在`ClaimDatabase`类中的`createClaimItemTask`所做的那样）变得很有吸引力。在`ClaimDatabase`上提供这些方法使得它们易于重用，并保持应用程序中逻辑的一致性。它还允许你将它们放入队列中或与其他任务并行运行，如果你选择使用线程池而不是`AsyncTask`的`SERIAL_EXECUTOR`（它一次只能运行一个任务）。
- en: Allowance overview with a Room database
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Room数据库的津贴概览
- en: 'If you run the overview screen and add a few claims to it, you''ll notice that
    one piece of the code isn''t reacting to the new items being added to the database:
    the allowance overview at the top of the screen. This is because while everything
    else is connected to the Room database, it''s still watching the `Allowance` data
    model. Using a data model like this is a good idea when the data is just in memory,
    but now that you have a database in place, things can change and simplify. For
    example, the `Allowance` class only really keeps how much the user plans to spend
    each day; the claim items can actually be seen as an entirely separate structure
    in the database model.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行概览屏幕并添加一些索赔到其中，你会注意到代码中的一段没有对新添加到数据库中的新项目做出反应：屏幕顶部的津贴概览。这是因为尽管其他所有内容都与Room数据库连接，但它仍在监视`Allowance`数据模型。当数据仅存在于内存中时，使用此类数据模型是一个好主意，但现在你已经有了数据库，事情可以改变并简化。例如，`Allowance`类实际上只保留用户计划每天花费的金额；索赔项实际上可以被视为数据库模型中的一个完全独立的结构。
- en: 'As such, you can move the daily allowance into a different type of data storage--`SharedPreferences`.
    `SharedPreferences` are key-value stores for Android that have a shared in-memory
    representation and atomic updates. If you don''t expect them to store too much
    data, this makes them ideal to keep track of data that doesn''t really go in an
    SQLite database. Let''s change the model of the `Allowance` overview to use the
    `ClaimDatabase` and `SharedPreferences`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将每日津贴移动到不同类型的数据存储中--`SharedPreferences`。`SharedPreferences`是Android中的键值存储，具有共享的内存表示和原子更新。如果你不期望它们存储太多数据，这使得它们非常适合跟踪那些实际上不会进入SQLite数据库的数据。让我们将`Allowance`概览的模型更改为使用`ClaimDatabase`和`SharedPreferences`：
- en: First, open the `AllowanceOverviewPresenter` class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`AllowanceOverviewPresenter`类。
- en: 'Change it from using the `Allowance` class to instead expose the daily allowance
    as an `ObservableInt`, and remove the `OnPropertyChangeCallback` so that the fields
    now look like this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其从使用`Allowance`类更改为公开每日津贴作为`ObservableInt`，并移除`OnPropertyChangeCallback`，以便现在字段看起来像这样：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, change the `UpdateSpendingStatsCommand` inner class to take a `List` of
    `ClaimItem` objects instead of an `Allowance` as its parameter:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`UpdateSpendingStatsCommand`内部类更改为接受`ClaimItem`对象`List`而不是`Allowance`作为其参数：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now change the `onBackground` implementation to run a single scan through the
    given `List` of `ClaimItem` objects and calculate all the spending stats at once:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`onBackground`实现更改为通过给定的`ClaimItem`对象`List`进行单次扫描，并一次性计算所有支出统计：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, change the constructor so that it takes a `LifecycleOwner` and the starting
    allowance to display to the user. Then, use the `ClaimDatabase` to update the
    spending statistics whenever there are new `ClaimItem` objects added:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更改构造函数，使其接受`LifecycleOwner`和要显示给用户的起始津贴。然后，使用`ClaimDatabase`在添加新的`ClaimItem`对象时更新支出统计：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You''ll also need to change the `updateAllowance` method to use the `ObservableInt`
    instead of the `Allowance` object:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要将`updateAllowance`方法更改为使用`ObservableInt`而不是`Allowance`对象：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, open the `AllowanceOverviewFragment` class.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`AllowanceOverviewFragment`类。
- en: 'Add a `SharedPreferences` field to the `AllowanceOverviewFragment`; we''ll
    be using them more than once in this class:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AllowanceOverviewFragment`中添加一个`SharedPreferences`字段；我们将在本类中多次使用它们：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Override the `onCreate` method of `Fragment` and retrieve the private `SharedPreferences`
    instance you''ll be storing the daily allowance in. The first argument specifies
    the name of the `SharedPreferences` to retrieve, while the second specifies the
    scope as `private`, meaning only your application will be able to see or use this
    `SharedPreferences` instance:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`Fragment`的`onCreate`方法，并检索你将存储每日津贴的私有`SharedPreferences`实例。第一个参数指定要检索的`SharedPreferences`的名称，而第二个参数指定范围为`private`，意味着只有你的应用程序能够看到或使用此`SharedPreferences`实例：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create an `onCreateView` method to create an `AllowanceOverviewPresenter` and
    pass the `Fragment` instance as the `LifecycleOwner`, and to retrieve the current
    `allowancePerDay` from the `SharedPreferences`. The second argument passed to
    the `SharedPreferences.getInt` method is a default value that is returned if there
    is no existing value stored:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`onCreateView`方法来创建`AllowanceOverviewPresenter`，并将`Fragment`实例作为`LifecycleOwner`传递，以及从`SharedPreferences`检索当前的`allowancePerDay`。传递给`SharedPreferences.getInt`方法的第二个参数是默认值，如果没有存储现有值，则返回该值：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, create an `onDestroy` method to store the allowance per day back in
    the `SharedPreferences` object. You do this by first requesting an `Editor` from
    the `SharedPreferences`, and then applying the changes. All the changes in an
    `Editor` are atomically applied at the same time (atomically):'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个`onDestroy`方法，将每日津贴存储回`SharedPreferences`对象。你这样做是通过首先从`SharedPreferences`请求一个`Editor`，然后应用更改。`Editor`中的所有更改都是原子性地同时应用的（原子性地）：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, if you build and run the application, you'll notice that the allowance
    overview will correctly show you how much you've spent "today", "this week", and
    in total. Use the date selector in the `CaptureClaimActivity` to add a few claim
    items on different days and see how the user interface reacts and recalculates
    the amounts that you've spent.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行应用程序，你会注意到津贴概览将正确显示你今天、“本周”以及总支出。使用`CaptureClaimActivity`中的日期选择器添加几个不同日期的报销项，并查看用户界面如何响应并重新计算你已支出的金额。
- en: Test your knowledge
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: An instance of `RecyclerView` will create one `View` instance for which of these?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecyclerView`的一个实例将为以下哪项创建一个`View`实例？'
- en: Every item of data
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每项数据
- en: Every item of data visible on the screen
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上可见的每一项数据
- en: Each type of data element that is also visible on the screen
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种也可见于屏幕上的数据元素
- en: When attaching an observer to `LiveData` you need to do which of the following?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将观察者附加到`LiveData`时，你需要执行以下哪项操作？
- en: Detach it when its `LifecycleOwner` is destroyed
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其`LifecycleOwner`被销毁时将其分离
- en: Attach it on the main thread
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主线程上附加它
- en: Provide a valid `LifecycleOwner`
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个有效的`LifecycleOwner`
- en: Overview / Dashboard screens should have which of these features?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概览/仪表盘屏幕应该具备哪些功能？
- en: They should only use graphs to display statistics
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该只使用图表来显示统计信息
- en: They should not scroll if it can be avoided
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以避免，它们不应该滚动
- en: They should display an overview with the most important information first
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该首先显示最重要的信息概览
- en: The `ViewHolder` class is used by the `RecyclerView` to do what?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewHolder`类被`RecyclerView`用来做什么？'
- en: Improve the data binding performance
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高数据绑定性能
- en: Reference the views that will be garbage collected
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用将被垃圾回收的视图
- en: Store the `View` objects in a `Bundle`
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`View`对象存储在`Bundle`中
- en: When using `LiveData` objects to reference data used by multiple `Fragment`
    objects, which of these is true?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`LiveData`对象引用多个`Fragment`对象使用的数据时，以下哪个是正确的？
- en: The `Fragment` instances must share the same `LiveData` reference to see changes
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fragment`实例必须共享相同的`LiveData`引用以查看更改'
- en: The `LiveData` will only update one of the `Fragment` instances
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveData`只会更新一个`Fragment`实例'
- en: The `Fragment` classes must all extend `android.support.v4.app.Fragment`
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fragment`类必须都扩展`android.support.v4.app.Fragment`'
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Overview screens are the first thing a user will see and interact with in your
    application, and will be the area of the application they will spend most of their
    time in. It's important to keep the screen focused and opinionated on what data
    is displayed to the user, and how it's displayed. Always consider how long the
    user has to look at your screen, and what information they will need easy access
    to. Make use of the `RecyclerView` and `LiveData` classes to provide the user
    with detailed views arranged with the most important information first, and allow
    them to quickly scroll through their most important recent events.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕是用户在应用程序中首先看到并与之交互的东西，也将是他们将在应用程序中花费大部分时间的地方。保持屏幕专注于显示给用户的数据，以及如何显示数据，这一点很重要。始终考虑用户需要查看你的屏幕多长时间，以及他们需要轻松访问哪些信息。利用`RecyclerView`和`LiveData`类为用户提供以最重要的信息为先的详细视图，并允许他们快速滚动查看他们最重要的最近事件。
- en: It's also important to consider the navigation of your application, the various
    ways the user will leave your overview screen, and how they will get back to it.
    As far as possible, keep the `Overview` class responsible for just arranging the
    data on the screen. Any logic that takes the user away from the screen, for whatever
    reason, should be encapsulated in `Fragment` classes that also hold the logic
    to deal with their eventual return to the overview screen.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要考虑你应用程序的导航，用户将如何从概览屏幕离开的各种方式，以及他们将如何返回。尽可能保持`概览`类只负责在屏幕上排列数据。任何将用户从屏幕上移开（无论出于何种原因）的逻辑都应该封装在`Fragment`类中，这些类还包含处理他们最终返回概览屏幕的逻辑。
- en: In this chapter, we looked at a very simple way to build an overview screen.
    There are many ways that these sorts of screens can be made more useful and powerful
    by reshaping the layout on the screen as the user scrolls and drags various elements
    of the user interface.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了构建概览屏幕的一种非常简单的方法。通过在用户滚动和拖动用户界面各种元素时重新设计屏幕布局，这些类型的屏幕可以通过多种方式变得更加有用和强大。
- en: In the next chapter, we'll take a look at how to leverage some of the layout
    systems provided by the Material Design API to allow the user interface to change
    its shape and emphasis dynamically.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用Material Design API提供的某些布局系统，允许用户界面动态地改变其形状和重点。
