["```swift\ns3eKeyboardSetInt(S3E_KEYBOARD_GET_CHAR, 1);\n```", "```swift\nif ((s3eKeyboardGetState(s3eKey3) & S3E_KEY_STATE_PRESSED) != 0)\n{\n  // Number 3 key has just been pressed!\n}\n```", "```swift\n// Callback function that will receive key state notifications\nint32 KeyStateCallback(s3eKeyboardEvent* apKeyEvent,\n                       void* apUserData)\n{\n  if (apKeyEvent->m_Key == s3eKey3)\n  {\n    if (apKeyEvent->m_Pressed)\n    {\n      // Number 3 key has just been pressed\n    }\n    else\n    {\n      // Number 3 key has just been released\n    }\n  }\n}\n\n// We use this to register the callback function…\ns3eKeyboardRegister(S3E_KEYBOARD_KEY_EVENT,\n                    (s3eCallback) KeyStateCallback, NULL);\n\n// …and this to cancel notifications\ns3eKeyboardUnRegister(S3E_KEYBOARD_KEY_EVENT,\n                      (s3eCallback) KeyStateCallback);\n```", "```swift\ns3eWChar lCharCode = s3eKeyboardGetChar();\n```", "```swift\n// Callback function that will receive pointer button notifications\nint32 ButtonEventCallback(s3ePointerEvent* apButtonEvent,\n                          void* apUserData)\n{\n  if (apButtonEvent->m_Button == S3E_POINTER_BUTTON_SELECT)\n  {\n    if (apButtonEvent->m_Pressed)\n    {\n      // Left mouse button or touch screen pressed\n    }\n    else\n    {\n      // Left mouse button or touch screen released\n    }\n  }\n  return 0;\n}\n\n// We use this to register the callback function…\ns3ePointerRegister(S3E_POINTER_BUTTON_EVENT,\n                   (s3eCallback) ButtonEventCallback, NULL);\n\n// …and this to cancel notifications\ns3ePointerUnRegister(S3E_POINTER_BUTTON_EVENT,\n                     (s3eCallback) ButtonEventCallback);\n```", "```swift\nfor (uint32 i = 0; i < S3E_POINTER_TOUCH_MAX; i++)\n{\n  // Find position of this touch id.  Position is only valid if the\n  // state for the touch ID is not S3E_POINTER_STATE_UNKNOWN or\n  // S3E_POINTER_STATE_UP\n  int32 x = s3ePointerGetTouchX(i);\n  int32 y = s3ePointerGetTouchY(i);\n\n  switch(s3ePointerGetTouchState(i))\n  {\n    case S3E_POINTER_STATE_RELEASED:\n     // User just released the screen at x,y\n     break;\n    case S3E_POINTER_STATE_DOWN:\n     // User just pressed or moved their finger to x,y\n     // We need to know if we've already been tracking this\n     // touch ID to tell whether this is a new press or a move\n     break;\n    default:\n     // This touch ID is not currently active\n     break;\n  }\n}\n```", "```swift\nif (s3eAccelerometerGetInt(S3E_ACCELEROMETER_AVAILABLE) != 0)\n{\n  // Accelerometer is available!  Start receiving input.\n  s3eAccelerometerStart();\n}\n```", "```swift\niwangle xAngle = IwGeomAtan2(-accY, -accZ);\nint32 lYZProjection = (int32) sqrtf((float) ((accY * accY) +\n                                             (accZ * accZ)));\niwangle yAngle = IwGeomAtan2(accX, lYZProjection);\n```", "```swift\nint32 accX = 0, accY = 0, accZ = 0;\nint32 lSmoothFactor = IW_GEOM_ONE / 4;\n// The following loop shows how we generate the smoothed accelerometer\n// inputs.  In a real application the code within the loop would be called once\n// per game frame.\nwhile (TRUE)\n{\n  int32 deltaX = s3eAccelerometerGetX() - accX;\n  int32 deltaY = s3eAccelerometerGetY() - accY;\n  int32 deltaZ = s3eAccelerometerGetZ() - accZ;\n  accX += IW_FIXED_MUL(lSmoothFactor, deltaX);\n  accY += IW_FIXED_MUL(lSmoothFactor, deltaY);\n  accZ += IW_FIXED_MUL(lSmoothFactor, deltaZ);\n}\n```"]