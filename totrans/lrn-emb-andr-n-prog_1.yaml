- en: Chapter 1\. Understanding the Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：理解架构
- en: In this chapter, the user will learn about Android hardware and software architecture.
    We will provide an overview on the *Android Compatibility Definition Document*
    to properly understand what we need in order to create a fully compliant and certified
    device.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，用户将了解Android的硬件和软件架构。我们将概述*Android兼容性定义文档*，以便正确理解我们为了创建一个完全合规和认证的设备需要什么。
- en: The user will learn about the **Android Application Framework** (**AAF**), the
    two different Android runtime systems—Dalvik, and ART, and a collection on Google-provided
    system libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将了解**Android应用框架**（**AAF**）、两个不同的Android运行时系统——Dalvik和ART，以及Google提供的系统库集合。
- en: The user will have a first hands-on moment, setting up and running Android Compatibility
    Test Suite. We will test together an existing certified device and we will take
    the first step on the path towards the creation of a certified device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将有一个第一次上手的机会，设置和运行Android兼容性测试套件。我们将一起测试一个现有的认证设备，并迈出创建认证设备道路的第一步。
- en: An overview of the Android system
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android系统概述
- en: 'Android, as with every other operating system, has a layer-based structure.
    The next image shows a properly abstracted overview of the whole system architecture:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个其他操作系统一样，Android有一个基于层的结构。下一张图展示了整个系统架构的正确抽象概述：
- en: '![](img/epub_36702041_3.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_3.jpeg)'
- en: 'We can divide the system into the following main layers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将系统分为以下主要层：
- en: Linux kernel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核
- en: Hardware abstraction layer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件抽象层
- en: Core libraries and runtime environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心库和运行环境
- en: Application framework
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用框架
- en: Binder IPC
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Binder IPC
- en: Applications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: The software layer closest to the hardware architecture is the *Linux kernel*.
    This layer is in charge of communicating with the hardware components and provides
    an easy-to-use interface for the layer above.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件层最接近硬件架构的是*Linux内核*。这一层负责与硬件组件通信，并为上层提供了一个易于使用的接口。
- en: Moving up on the architecture path, we have Android runtime and core libraries.
    This layer provides the basics tools for the application framework. The application
    framework is a collection of **ready-to-use** components that the system provides
    to the Applications layer via the Android SDK. The top layer contains all those
    applications we use everyday—games, productivity apps, multimedia, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构路径上继续前进，我们有Android运行时和核心库。这一层为应用框架提供了基本工具。应用框架是一组**现成可用**的组件，系统通过Android
    SDK将这些组件提供给应用层。顶层包含我们每天使用的所有应用——游戏、生产力应用、多媒体等。
- en: Linux kernel
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux内核
- en: 'Android is based on the Linux kernel, but it''s not a classic Linux-based desktop
    system: it''s not Ubuntu. However, Android architecture designers and developers
    rely on the Linux kernel, because it''s open source, it''s extensively tested
    worldwide, and it can be easily tailored to fit Android-specific hardware needs,
    on any kind of device.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android基于Linux内核，但它不是一个经典的基于Linux的桌面系统：它不是Ubuntu。然而，Android架构设计师和开发者依赖于Linux内核，因为它开源，全球范围内经过广泛测试，并且可以轻松定制以适应Android特定的硬件需求，适用于任何类型的设备。
- en: From a very pragmatic point of view, choosing to base the system on an open
    source heart reinforced the Android philosophy of being an open system, supported
    by its community and trusted by enterprise companies, thanks to its transparency.
    Besides, this approach saved a lot of development time—they didn't have to start
    from scratch and they could focus on the rest of the architecture, taking advantage
    of a popular and well-documented core.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个非常实际的角度来看，选择基于开源核心来构建系统强化了Android的开放系统哲学，由其社区支持，并得到企业公司的信任，这得益于其透明度。此外，这种方法节省了大量开发时间——他们不必从头开始，可以专注于架构的其他部分，利用一个流行且文档齐全的核心。
- en: 'The vanilla Linux kernel needed some love to properly fit all the Android requirements.
    Most of the contributions by Google were focused on:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 原味Linux内核需要一些调整才能正确满足所有Android的要求。谷歌的大部分贡献集中在以下方面：
- en: Fixing bugs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复错误
- en: Enabling new hardware
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用新硬件
- en: Improving power management
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高电源管理
- en: Improving error reporting
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进错误报告
- en: Improving performance
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高性能
- en: Improving security
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高安全性
- en: From a hardware point of view, the Android team made a great effort to add new
    goodies to the Linux kernel. Lots of fixes and hacks were released to improve
    Bluetooth support and management, lots of **General Purpose Input/Output** (**GPIO**)
    drivers were added, ARM compatibility was enhanced, as ARM was the primary Android-supported
    architecture and also MMC management received lots of contributions. The new ADB
    gadget driver was added to help developers to communicate via USB with external
    devices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件的角度来看，Android团队在Linux内核中添加了许多新功能。发布了大量修复和黑客工具来改进蓝牙支持和管理，添加了许多**通用输入/输出**（**GPIO**）驱动程序，增强了ARM兼容性，因为ARM是Android支持的主要架构，同时MMC管理也收到了许多贡献。新增加了ADB设备驱动程序，帮助开发者通过USB与外部设备通信。
- en: From a memory point of view, the Android team introduced PMEM, the process memory
    allocator. This gave the ability to manage large physically contiguous memory
    regions between user space and kernel space. Working in a specific low-resource
    hardware domain, the Android team released Ashmem, Android Shared Memory, which
    targeted low-memory devices and provided an easy-to-use file-based API to manage
    shared memory, especially under memory pressure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存的角度来看，Android团队引入了PMEM，即进程内存分配器。这使得能够在用户空间和内核空间之间管理大型的物理连续内存区域。在特定的低资源硬件领域工作，Android团队发布了Ashmem，Android共享内存，它针对低内存设备，并提供了一个易于使用的基于文件的API来管理共享内存，尤其是在内存压力下。
- en: From a power management point of view, the Android team introduced an improved
    suspend system, wakelocks, and Android Alarm Timers, the kernel implementation
    to support Android Alarm Manager.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从电源管理的角度来看，Android团队引入了一个改进的挂起系统、唤醒锁和Android闹钟定时器，这是内核实现以支持Android闹钟管理器。
- en: The other interesting contributions were the kernel support for Android logcat
    command, that provides logs of system messages, application debug messages, and
    exceptions, and Android Binder, an Android-specific interprocess communication
    system, used for remote method invocation too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的贡献包括对Android logcat命令的内核支持，该命令提供了系统消息、应用调试消息和异常的日志，以及Android Binder，这是一个Android特定的进程间通信系统，也用于远程方法调用。
- en: Hardware abstraction layer – HAL
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件抽象层 – HAL
- en: To overcome the increasing hardware fragmentation, Android engineers created
    an abstraction layer that allows the system to interact with the hardware just
    being aware of a specific intercommunication interface. The system completely
    ignores the low-level implementation of hardware and drivers. This approach enforces
    the idea of developing software *against an interface* instead of *against an
    implementation*. With this approach, the Android system does not know and does
    not need to know how hardware is accessed or managed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服日益增长的硬件碎片化，Android工程师创建了一个抽象层，允许系统仅通过了解特定的互通信接口与硬件交互。系统完全忽略了硬件和驱动程序的低级实现。这种方法强制执行了“针对接口”而不是“针对实现”开发软件的理念。采用这种方法，Android系统不知道也不需要知道如何访问或管理硬件。
- en: 'As a mid-level layer between the hardware and the system, Android HAL is commonly
    developed using native technology—C/C++ and shared libraries. There is no constraint
    from Google about how we need to implement our HAL and our device drivers: it''s
    up to us to design it as we think best for our scenario. There is only one simple
    rule:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为硬件和系统之间的中间层，Android HAL通常使用本地技术——C/C++和共享库来开发。谷歌没有关于我们如何实现我们的HAL和设备驱动程序的约束：我们有权根据我们的场景设计它。只有一个简单的规则：
- en: '*Our implementation must provide the same interface that the system is expecting.*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们的实现必须提供系统所期望的相同接口。*'
- en: Libraries and the application framework
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库和应用程序框架
- en: Going up on the architecture ladder, we find the two most important software
    layers. The Android application framework and Android system libraries are the
    middleware between the bare hardware, managed by the Linux kernel, and all those
    fancy, shiny apps we have on our smartphones.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构层次结构中向上，我们发现两个最重要的软件层。Android应用程序框架和Android系统库是裸硬件（由Linux内核管理）和我们在智能手机上拥有的所有那些花哨、闪亮的应用程序之间的中间件。
- en: Libraries
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 库
- en: 'Android system libraries are a set of libraries, specifically created to work
    on Android, to allow and help with system components and app development. The
    most important are:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统库是一组专门为Android创建的库，用于允许并帮助系统组件和应用程序开发。其中最重要的是：
- en: '**SQLite**: SQLite is the entry point to the SQL world. It''s a tiny SQL implementation
    for embedded systems and it provides a standard way to access data published by
    content providers or SQL DB created by the user.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite**：SQLite是进入SQL世界的大门。它是一个针对嵌入式系统的微小SQL实现，它提供了一种标准方式来访问内容提供者发布的数据或用户创建的SQL数据库。'
- en: '**SSL**: SSL provides the standard security environment for network communication.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSL**：SSL为网络通信提供标准的安全环境。'
- en: '**OpenGL**: OpenGL libraries are the link between the Java (and C/C++ JNI)
    world and the OpenGL/ES 3D graphics rendering API.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL**: OpenGL库是Java（以及C/C++ JNI）世界与OpenGL/ES 3D图形渲染API之间的桥梁。'
- en: '**SGL**: SGL provides a way to access 2D rendering engine.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SGL**：SGL提供了一种访问2D渲染引擎的方法。'
- en: '**Media framework**: Media framework provides codecs for rendering, recording,
    and playback for the most common media formats.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体框架**：媒体框架为渲染、录制和回放最常见的媒体格式提供编解码器。'
- en: '**WebKit**: WebKit is the popular HTML rendering engine.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebKit**: WebKit是流行的HTML渲染引擎。'
- en: '**libc**: The libc library is a BSD-derived implementation of the standard
    C library, specifically tuned to best perform on embedded Linux-based devices.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libc**：libc库是BSD派生的标准C库实现，专门针对嵌入式基于Linux的设备进行优化以获得最佳性能。'
- en: '**Surface manager**: Surface manager manages access to the display subsystem.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Surface manager**：Surface manager管理对显示子系统的访问。'
- en: The application framework
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序框架
- en: 'This is the core of the Android software ecosystem. It provides a plethora
    of managers that facilitate the most common tasks of Android developers and the
    Android system itself. The most important components of the Application Framework
    are:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Android软件生态系统的核心。它提供了一系列管理器，这些管理器简化了Android开发者和Android系统本身的常见任务。应用程序框架最重要的组件包括：
- en: '**Activity manager**: This provides the *navigation backstack* and manages
    the Android activity lifecycle'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动管理器**：提供*导航回退栈*并管理Android活动生命周期。'
- en: '**Resource manager**: This provides access to noncode resources contained in
    the apps: graphics, localized string, styles, and colors'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器**：提供对应用中包含的非代码资源的访问：图形、本地化字符串、样式和颜色。'
- en: '**Location manager:** This is in charge of providing the most accurate position
    information, using data collected by the GPS sensor, from cell towers and Wi-Fi
    networks nearby'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置管理器**：负责提供最准确的位置信息，使用由GPS传感器收集的数据、附近的基站和Wi-Fi网络。'
- en: '**Notification manager**: This enables apps to display notification alerts
    in the status bar, according to Google Design Guidelines, to provide a common
    and familiar user experience'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知管理器**：根据谷歌设计指南，允许应用在状态栏中显示通知警报，以提供一致且熟悉的用户体验。'
- en: '**Content providers**: This provides a common approach to share data between
    different apps, for instance, accessing contacts data or sharing a common data
    set between two apps'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容提供者**：提供了一种在不同应用之间共享数据的方法，例如访问联系人数据或在两个应用之间共享公共数据集。'
- en: '**Views and widgets**: These comprise the UI core of the Android experience.
    Buttons, text fields, and layouts are the building blocks of every Android system
    component and user app'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图和控件**：这些构成了Android体验的UI核心。按钮、文本字段和布局是每个Android系统组件和用户应用的构建块。'
- en: Everything on Android is achieved using the official Android SDK that provides
    a consistent and documented way to use all these system managers, views, and logic
    components to let you create the next big hit of the Google Play Store.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上实现一切都是使用官方的Android SDK，它提供了一种一致且文档化的方式来使用所有这些系统管理器、视图和逻辑组件，让您能够创建下一个Google
    Play Store的大热门。
- en: Binder IPC
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Binder IPC
- en: From an Application Framework point of view, the Binder Inter-Process Communication
    (IPC) is a hidden layer. It takes care of creating a transparent communication
    channel between the high-level Android API, accessible via the Android SDK, and
    the actual Android system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序框架的角度来看，Binder进程间通信（IPC）是一个隐藏层。它负责在高级Android API（可通过Android SDK访问）和实际Android系统之间创建一个透明的通信通道。
- en: The application layer
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序层
- en: All the applications created by third-party entities, such as smartphone manufacturers
    or Android programmers will be installed on the application layer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由第三方实体（如智能手机制造商或Android程序员）创建的应用都将安装在应用程序层。
- en: 'Usually, this relies on a read/write area of the handset solid memory, but
    for software provided by manufacturers, typically, it uses a read-only memory
    area to be sure that these applications will always be installed no matter what.
    Apps such as Google Maps, YouTube, Samsung TouchWiz Nature, and HTC Sense are
    examples of apps in this very group: they are shipped with the device''s operating
    system, they are installed on a read-only memory area of the device, and they
    are meant to be uninstallable as a core component of the system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这依赖于手机固态存储的读写区域，但对于制造商提供的软件，通常，它使用只读存储区域以确保这些应用无论发生什么情况都能始终安装。例如，Google Maps、YouTube、Samsung
    TouchWiz Nature和HTC Sense都属于这一类应用：它们与设备的操作系统一起发货，安装在设备的只读存储区域，并且作为系统核心组件，它们旨在不可卸载。
- en: As we will see, this is not 100% true—once you have the proper skill set, you
    will be able to manipulate the whole system. In the following chapters, you will
    acquire these skills and you will learn how to heavily modify an already existing
    Android version and get rid of those apps, if necessary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这并不完全正确——一旦你掌握了适当的技能集，你将能够操纵整个系统。在接下来的章节中，你将获得这些技能，并学习如何大幅度修改现有的Android版本，并在必要时删除这些应用。
- en: Android compatibility
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android兼容性
- en: Every successful Android device on the market, before being launched, has been
    certified. Manufacturers have designed, developed, and tested their device according
    to precise guidelines, rules, and constraints.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上每一款成功的Android设备在上市前都经过了认证。制造商根据精确的指南、规则和限制设计了、开发和测试了他们的设备。
- en: 'To make the task as easy as possible, Google has created the Android Compatibility
    Program that defines details and tools that help OEMs to create a device that
    will properly support the OS, the SDK, and the developers'' expectations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使任务尽可能简单，谷歌创建了Android兼容性计划，该计划定义了帮助OEM创建能够正确支持操作系统、SDK和开发者期望的详细信息和工具：
- en: '*"To run Android apps on a variety of Android devices."*'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在多种Android设备上运行Android应用。"*'
- en: 'As a manufacturer, creating and distributing a certified device has critical
    importance. Our goal is to create a device with a unique, but at the same time
    familiar, user experience: we have to be cool, but not weird! Users want to customize
    their Android device and they want to be sure that their favorite apps will run
    smoothly, without problems of any sort. Developers want to be sure that they won''t
    waste time fixing bugs on every different smartphone, tablet, or TV—they want
    a common ecosystem on which they can rely.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为制造商，创建和分发一个经过认证的设备具有至关重要的意义。我们的目标是创建一个独特但同时又熟悉的用户体验：我们必须酷，但不能奇怪！用户希望自定义他们的Android设备，并且他们想要确保他们最喜欢的应用能够顺畅运行，没有任何问题。开发者希望确保他们不会浪费时间在每一款不同的智能手机、平板电脑或电视上修复错误——他们希望有一个他们可以依赖的共同生态系统。
- en: 'A well-defined and well-supported ecosystem brings more certified devices that
    bring more and more developers that bring more and more happy users. The following
    diagram shows exactly how the Android ecosystem lives thanks to the constant creation
    of well-designed, well-produced, certified devices:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个定义良好且得到良好支持的生态系统带来了更多经过认证的设备，这些设备带来了更多开发者，进而带来了更多快乐的用户。以下图表显示了Android生态系统如何通过不断创建设计精良、生产精良、经过认证的设备而得以生存：
- en: '![](img/epub_36702041_4.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_4.jpeg)'
- en: The Android Compatibility Definition Document
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android兼容性定义文档
- en: The **Android Compatibility Definition Document** (**CDD**) is Google's way
    to specify guidelines, rules, and constraints to be considered for an Android-compatible
    device. Every device designer and manufacturer has to refer to the CDD to be able
    to easily port Android onto its own hardware platform.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android兼容性定义文档**（**CDD**）是谷歌指定要考虑的指南、规则和约束的方式，以使设备兼容Android。每个设备设计师和制造商都必须参考CDD，以便能够轻松地将Android移植到自己的硬件平台上。'
- en: For each release of the Android platform, Google provides a detailed CDD. The
    CDD represents the *policy* aspect of Android compatibility and its role is to
    codify and clarify all the requirements and eliminate any ambiguity. The main
    goal is to provide rules for manufacturers to let them create complex hardware
    devices, compatible with Android SDK and Android apps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android平台的每个版本，谷歌都提供了一份详细的CDD。CDD代表了Android兼容性的*政策*方面，其作用是编纂和阐明所有要求，消除任何歧义。主要目标是提供规则，让制造商能够创建与Android
    SDK和Android应用兼容的复杂硬件设备。
- en: Designing and developing a new device is no easy task. Even the smallest detail
    matters. Think about OpenGL support. There is no possible way to be sure that
    the graphical experience will be great for the user. The only thing that's possible
    is working according to the guidelines and then "test, test, and test". That's
    why providing as many details and guidelines as possible is the only way to help
    the manufactures to achieve their goal.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和开发一款新设备并非易事。即使是细节也至关重要。想想OpenGL支持。我们无法保证图形体验对用户来说会很好。唯一可能的是按照指南工作，然后“测试，测试，再测试”。这就是为什么尽可能提供尽可能多的细节和指南是帮助制造商实现目标唯一途径。
- en: 'However, the CDD does not attempt to be comprehensive—it couldn''t be. It just
    serves as guidance to approach as easily as possible the final goal—a compatible
    device. Further help comes from the source code itself and from the Android SDK
    API that can be considered a compatibility-proof test bench. Think about CDD as
    an overview of the minimum set of constraints to be compliant with: it''s the
    very first step of the journey.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CDD并不试图全面——它不可能做到。它只是作为指导，尽可能容易地接近最终目标——一个兼容的设备。进一步的帮助来自源代码本身和Android SDK
    API，它可以被视为兼容性测试平台。将CDD视为符合最小约束集的概述：它是旅程的第一步。
- en: Device types
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备类型
- en: 'In the beginning, Android was born to run on digital cameras. Luckily for us,
    a lot has happened since then: smartphones invaded our world! Then we had tablets
    and mp3 players. Nowadays, we have TVs, watches, media centers, glasses, and even
    cars, running Android and Android apps. Every device on the market will probably
    land in one specific category, according to its features. CDD gives a few pointers
    about which category your new device would be placed in:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，Android是为了在数码相机上运行而诞生的。幸运的是，从那时起发生了许多事情：智能手机入侵了我们的世界！然后我们有平板电脑和MP3播放器。如今，我们有电视、手表、媒体中心、眼镜，甚至汽车，都在运行Android和Android应用。市场上的每款设备都可能根据其功能被归入一个特定的类别。CDD提供了一些关于您的设备将被放置在哪个类别的指导：
- en: Every device with an embedded touchscreen, a power source that allows mobility,
    and that can be held in hand can be considered an **Android Handset**.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个具有内置触摸屏、允许移动的电源和可以手持的设备都可以被认为是**Android手机**。
- en: 'An **Android Television device** is a device designed for media content: video,
    music, TV, games, with users sitting about three meters or ten feet away. This
    kind of device must have an embedded screen or an output video interface—HDMI,
    VGA, DVI, or a wireless display port.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android电视设备**是一种为媒体内容设计的设备：视频、音乐、电视、游戏，用户距离大约三米或十英尺。这类设备必须具备内置屏幕或输出视频接口——HDMI、VGA、DVI或无线显示端口。'
- en: A device designed to be worn on a wrist, with a touchscreen display with a diagonal
    between 2.79 cm and 6.35 cm is considered an **Android Watch**.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种设计用于佩戴在手腕上的设备，具有对角线长度在2.79厘米到6.35厘米之间的触摸屏显示器，被认为是**Android手表**。
- en: Having a car with an infotainment system, based on Android, gives us an **Android
    Automotive implementation**.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一辆基于Android的信息娱乐系统汽车，为我们提供了**Android Automotive实现**。
- en: Software compatibility
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 软件兼容性
- en: From a software execution point of view, the basic requirement is being capable
    of executing the Android Dalvik bytecode. Our device must support the *Android
    Application Programming Interface* and must provide complete implementations of
    any documented behaviors of any documented API exposed by the Android SDK or annotated
    with the `@SystemAp` annotation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件执行的角度来看，基本要求是能够执行Android Dalvik字节码。我们的设备必须支持**Android应用程序编程接口**，并且必须提供任何由Android
    SDK公开或用`@SystemAp`注解标注的API的任何文档化行为的完整实现。
- en: Hardware compatibility is a tricky task, because even if our device is lacking
    some specific hardware, for instance GPS or accelerometers, our implementation
    must contain GPS-related code and should be capable of handling inappropriate
    requests in a reasonable way to avoid crashes or misbehaviors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件兼容性是一项棘手的工作，因为即使我们的设备缺少某些特定硬件，例如GPS或加速度计，我们的实现也必须包含与GPS相关的代码，并且应该能够以合理的方式处理不适当的请求，以避免崩溃或不良行为。
- en: 'One of the main players of software compatibility is the ability of our device
    to support intents. Every device properly implementing Android API must support
    Android loose-coupling intent system. Intents allow Android apps to easily request
    functionality from other Android components and avoid the effort to implement
    everything from scratch. The Android system has a set of core applications that
    implement the intent pattern:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 软件兼容性的主要参与者之一是我们设备支持意图的能力。每个正确实现Android API的设备都必须支持Android松耦合意图系统。意图允许Android应用程序轻松请求其他Android组件的功能，并避免从头开始实现一切的努力。Android系统有一套实现意图模式的内核应用程序：
- en: Desk clock
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面时钟
- en: Browser
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: Calendar
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历
- en: Contacts
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人
- en: Gallery
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相册
- en: Global Search
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局搜索
- en: Launcher
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动器
- en: Music
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐
- en: Settings
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置
- en: As a vendor, we could integrate the default Android components or implement
    our own component, according to the public API. Those components will have special
    system permissions to act as system apps and they will be the first proposed choice
    for the matching intent filter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为供应商，我们可以集成默认的Android组件或根据公共API实现自己的组件。这些组件将具有特殊系统权限，作为系统应用，并将是匹配意图过滤器首选的第一个选择。
- en: For instance, when a developer ask to open a web page, the system will suggest
    "our browser component" as the first chosen app to perform the task. Of course,
    being a good citizen means that we must provide a proper settings menu to give
    the user the possibility to override our default choice and let the final user
    pick a different app for the task.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当开发者请求打开一个网页时，系统将建议“我们的浏览器组件”作为执行此任务的首选应用程序。当然，作为一个好公民，我们必须提供一个适当的设置菜单，使用户能够覆盖我们的默认选择，并让最终用户为任务选择不同的应用程序。
- en: Beyond Java
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越Java
- en: 'Android applications development is mostly based on Java programming. The SDK
    is based on Java, the runtime system is fully compliant with Java6, partially
    with Java7, and Google is already experimenting with Java8\. Most developers will
    easily approach the platform if they already know Java programming language. However,
    Android offers a lot more to those developers that are dealing with heavy-duty,
    performance-oriented scenarios: Android Native API.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序开发主要基于Java编程。SDK基于Java，运行时系统完全符合Java6，部分符合Java7，而谷歌已经在尝试Java8。如果开发者已经熟悉Java编程语言，他们很容易接近这个平台。然而，Android为那些处理重型、性能导向场景的开发者提供了更多：Android原生API。
- en: Native API
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原生API
- en: Native API gives the developers the opportunity to call native *C*, and partially
    *C++*, code from an Android Java application. Native code is compiled as standard
    ELF `.so` files and stored in the app APK file. Being native code, it has to be
    compiled for every architecture we are going to support, because, contrary to
    the bytecode, it can't be built once and run on every architecture.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 原生API为开发者提供了从Android Java应用程序调用原生*C*和部分*C++*代码的机会。原生代码被编译成标准的ELF `.so` 文件，并存储在应用程序APK文件中。作为原生代码，它必须为我们将要支持的每个架构进行编译，因为与字节码不同，它不能编译一次并在每个架构上运行。
- en: 'As integrators, we must embrace one or more **Android Application Binary Interfaces**
    (**ABIs**) and aim for having full compatibility with the Android NDK. Of course,
    Google provides guidelines and constraints to easily reach this goal. These are
    the basic rules for proper compatibility:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为集成者，我们必须接受一个或多个**Android应用程序二进制接口**（**ABIs**）并力求与Android NDK完全兼容。当然，谷歌提供了指南和约束，以便轻松达到这一目标。这些是确保兼容性的基本规则：
- en: Our implementation must include support for code running in the managed environment,
    that is Java code, to call into native code, using the standard **Java Native
    Interface** (**JNI**) semantics
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的实现必须包括对在托管环境中运行代码的支持，即Java代码，以使用标准的**Java原生接口**（**JNI**）语义调用原生代码
- en: If our implementation supports the 64-bit ABI, we must support its relative
    32-bit version, too, because we must provide compatibility to non-64 bit potential
    devices
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的实现支持64位ABI，我们也必须支持其相关的32位版本，因为我们必须为非64位潜在设备提供兼容性
- en: Google suggests that we build our implementation using the source code and header
    files available in the Android Open Source Project—just don't reinvent the wheel
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌建议我们使用Android开源项目中可用的源代码和头文件来构建我们的实现——只是不要重新发明轮子
- en: 'From a libraries point of view, our implementation must be source-compatible
    (that is, header compatible) and binary-compatible (for the ABI) with all the
    following libraries:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从库的角度来看，我们的实现必须与以下所有库源代码兼容（即，头文件兼容）和二进制兼容（对于ABI）：
- en: libc (C library)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libc (C库)
- en: libm (math library)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libm (数学库)
- en: liblog (Android logging)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: liblog (Android日志)
- en: libz (Zlib compression)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libz (Zlib压缩)
- en: libdl (dynamic linker)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libdl (动态链接器)
- en: libGLESv1_CM.so (OpenGL ES 1.x)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libGLESv1_CM.so (OpenGL ES 1.x)
- en: libGLESv2.so (OpenGL ES 2.0)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libGLESv2.so (OpenGL ES 2.0)
- en: libGLESv3.so (OpenGL ES 3.x)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libGLESv3.so (OpenGL ES 3.x)
- en: libEGL.so (native OpenGL surface management)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libEGL.so (原生OpenGL表面管理)
- en: libjnigraphics.so, libOpenSLES.so (OpenSL ES 1.0.1 audio support)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libjnigraphics.so, libOpenSLES.so (OpenSL ES 1.0.1音频支持)
- en: libOpenMAXAL.so (OpenMAX AL 1.0.1 support)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libOpenMAXAL.so (OpenMAX AL 1.0.1支持)
- en: libandroid.so (native Android activity support)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libandroid.so (原生Android活动支持)
- en: libmediandk.so (native media APIs support)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libmediandk.so (原生媒体API支持)
- en: These libraries also provide minimal support for the C++ JNI interface as well
    as support for OpenGL.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库还提供了对C++ JNI接口的最小支持，以及OpenGL的支持。
- en: 'An implementation of each one of these libraries must be present in our system
    to be compatible with Android NDK. This is a dynamic list and we cannot treat
    it as a definitive set of libraries: future versions of Android could add new
    libraries and increase development possibilities and scenarios. That''s why native
    code compatibility is challenging. For this reason, Google strongly suggests to
    use the implementations of the libraries listed earlier from the Android Open
    Source Project, taking advantage of the Open Source philosophy of Android and
    to enjoy well-supported and well-tested source code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统必须包含这些库的每个实现，才能与Android NDK兼容。这是一个动态列表，我们不能将其视为一个确定的库集合：Android的未来版本可能会添加新的库，并增加开发可能性和场景。这就是为什么原生代码兼容性具有挑战性。因此，谷歌强烈建议使用Android开源项目中列出的库的实现，利用Android的开放源代码哲学，并享受良好支持和测试过的源代码。
- en: Maintaining 32-bit support
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护32位支持
- en: Nowadays, all major manufactures are switching to 64-bit architecture and new
    ARMv8 architecture deprecates lots of old CPU operations. Unfortunately, the market
    is still full of 32-bit compatible software and even on 64-bit architecture we
    must still support these deprecated operations, to avoid scaring developers and
    losing precious market share. Fortunately, we can choose to make them available
    via real hardware support or software emulation, at the expense of performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有主要制造商都在转向64位架构，新的ARMv8架构废弃了许多旧的CPU操作。不幸的是，市场上仍然充满了32位兼容的软件，甚至在64位架构上，我们也必须支持这些废弃的操作，以避免吓跑开发者并失去宝贵的市场份额。幸运的是，我们可以选择通过真实硬件支持或软件仿真来提供它们，这将以性能为代价。
- en: 'Supporting 32-bit architecture can be very tricky. We can just think about
    one simple scenario, for example, accessing the `/proc/cpuinfo` file. Legacy versions
    of the Android NDK used `/proc/cpuinfo` to discover CPU features. For compatibility
    with applications built using 32-bit NDK, we must specifically include the following
    things in `/proc/cpuinfo` when it is read by 32-bit ARM applications:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 支持32位架构可能非常棘手。我们可以考虑一个简单的场景，例如，访问`/proc/cpuinfo`文件。Android NDK的旧版本使用`/proc/cpuinfo`来发现CPU特性。为了与使用32位NDK构建的应用程序兼容，我们必须在32位ARM应用程序读取时，在`/proc/cpuinfo`中特别包含以下内容：
- en: '**Features**: This is followed by a list of any optional ARMv7 CPU features
    supported by the device'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性**：此列表之后是设备支持的任何可选ARMv7 CPU特性的列表'
- en: '**CPU architecture**: This is followed by an integer describing the device''s
    highest supported ARM architecture (for example, 8 for ARMv8 devices)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU架构**：此列表之后是一个整数，描述设备支持的最高ARM架构（例如，ARMv8设备的8）'
- en: The tricky part is that these requirements only apply when `/proc/cpuinfo` is
    read by 32-bit ARM applications. The file must be not altered when read by 64-bit
    ARM or non-ARM applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分是，这些要求仅在32位ARM应用程序读取`/proc/cpuinfo`时适用。当由64位ARM或非ARM应用程序读取时，文件不得被修改。
- en: From Dalvik to ART runtime
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Dalvik到ART运行时
- en: The original Android runtime implementation was Dalvik. Dalvik was a virtual
    machine, specifically created for Android, due to the necessity to target low-memory
    devices. It was an integral part of the system until Android KitKat.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Android运行时实现是Dalvik。Dalvik是一个虚拟机，专门为Android创建，由于需要针对低内存设备，它是系统的一个基本组成部分，直到Android
    KitKat。
- en: As we already said, Android applications are mostly written in Java. When Dalvik
    was the in-use runtime system, the Java code was compiled into bytecode. This
    bytecode was then translated to Dalvik bytecode and finally stored into a `.dex`
    (Dalvik Executable). After this procedure, Dalvik was able to run the Android
    app.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Android应用程序大多是用Java编写的。当Dalvik是正在使用的运行时系统时，Java代码被编译成字节码。然后这些字节码被转换成Dalvik字节码，并最终存储在`.dex`（Dalvik可执行文件）中。在此过程之后，Dalvik能够运行Android应用程序。
- en: 'Although Dalvik had been designed for slow devices, with low memory, its performance
    has never been astonishing, not even when the **Just-In-Time** compilation was
    introduced, back with Android 2.2 Froyo. Dalvik JIT was supposed to bring a huge
    performance boost to Android apps and, from some points of view, it did, but with
    limitations, such as the infamous *maximum methods number*, and the pressure from
    alternative solutions forced Google to look forward to a new runtime:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Dalvik是为慢速设备、低内存设计的，其性能从未令人惊叹，甚至在Android 2.2 Froyo中引入**即时编译**时也是如此。Dalvik
    JIT本应给Android应用程序带来巨大的性能提升，从某些角度来看，它确实做到了，但有一些限制，例如臭名昭著的*最大方法数*，以及来自替代解决方案的压力迫使谷歌寻求新的运行时：
- en: '![](img/epub_36702041_5.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_5.jpeg)'
- en: The Android runtime
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android运行时
- en: 'When Android 4.4 *KitKat* was released, users could select a new experimental
    runtime environment in the **Settings** menu: ART. Android RunTime or, shortened,
    ART, is the current default runtime solution that replaced Dalvik from Android
    5 *Lollipop*. The previous diagram shows a comparison between Dalvik and ART architecture.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android 4.4 *KitKat*发布时，用户可以在**设置**菜单中选择一个新的实验性运行时环境：ART。Android RunTime或简称ART，是当前默认的运行时解决方案，自Android
    5 *Lollipop*以来取代了Dalvik。前面的图表显示了Dalvik和ART架构的比较。
- en: The idea behind Dalvik's JIT (just-in-time) execution was to profile the applications
    while they were being executed and dynamically compile the most-used segments
    of the bytecode into native machine code. Native execution of these most-used
    segments called **traces** would then greatly speed-up the execution of the application
    even though most of the code would still be interpreted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik的JIT（即时）执行背后的想法是在应用程序执行时分析应用程序，并动态地将字节码中最常用的部分编译成本地机器代码。这些最常用部分的本地执行称为**跟踪**，这将大大加快应用程序的执行速度，尽管大部分代码仍然需要解释。
- en: A new old approach – AOT compilation
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一种新的旧方法 – AOT编译
- en: Art re-introduces the concept of AOT (ahead-of-time) compilation. It works as
    most compilers do, that is, it compiles the whole application code into the native
    machine code, without interpreting bytecode at all. This takes some time, but
    it is done only once when the user downloads the app, so considering the time
    and amount of resources needed for JIT profiling and optimization that are needed
    on every application start, it is an acceptable trade-off. Also, since the whole
    application is now compiled, it is quicker overall and the power consumption is
    reduced, which improves the device autonomy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Art重新引入了AOT（提前时间）编译的概念。它的工作方式与大多数编译器类似，也就是说，它将整个应用程序代码编译成本地机器代码，完全不解释字节码。这需要一些时间，但用户下载应用程序时只编译一次，所以考虑到每次应用程序启动时所需的JIT分析和优化所需的时间和资源量，这是一个可接受的权衡。此外，由于整个应用程序现在都已编译，整体上更快，功耗降低，这提高了设备的自主性。
- en: ART is the default runtime since Android 5, but Android needs to ensure compatibility
    with all those apps that are already on the market and all those devices that
    are running a previous version of Android and won't receive any operating system
    updates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ART自Android 5以来成为默认运行时，但Android需要确保与市场上所有已安装的应用程序以及运行先前版本Android且不会收到任何操作系统更新的所有设备保持兼容性。
- en: For backward compatibility reasons, the input bytecode is the same for ART and
    Dalvik. The application APK file still contains standard `.dex` files, but replaces
    the `.odex` files (Optimized Dalvik Executables) with the standard Unix ELF files
    (Executable and Linkable Format). During the installation, ART uses `dex2oat`
    utility to compile the bytecode into native code stored in the ELF file. As already
    mentioned, this step is performed only once and requires fewer resources and less
    overhead than Dalvik's JIT compilation. The downside is that the APK files are
    larger because they effectively contain double the code (uncompiled bytecode and
    compiled executable). After this compilation, the system will run just the ELF
    executable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向后兼容性的原因，ART和Dalvik的输入字节码是相同的。应用程序APK文件仍然包含标准的`.dex`文件，但用标准的Unix ELF文件（可执行和链接格式）替换了`.odex`文件（优化后的Dalvik可执行文件）。在安装过程中，ART使用`dex2oat`实用程序将字节码编译成存储在ELF文件中的本地代码。如前所述，此步骤只执行一次，并且比Dalvik的JIT编译需要更少的资源和开销。缺点是APK文件更大，因为它们实际上包含了双倍的代码（未编译的字节码和编译后的可执行文件）。在此编译之后，系统将仅运行ELF可执行文件。
- en: The bottom line is faster apps, but a bit less free space on your smartphone
    memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是应用程序运行更快，但智能手机内存中的空闲空间会少一些。
- en: Garbage collection and other improvements
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 垃圾回收和其他改进
- en: AOT compilation is not the only improvement that ART brought in. One of the
    most important features is the improved garbage collection. **Garbage Collection**
    (**GC**) is a form of automatic memory management, completely different from the
    old idea where the developer was the one in charge of allocating memory when needed
    and freeing it when it was not needed anymore.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译不是ART带来的唯一改进。其中一个最重要的特性是改进的垃圾回收。**垃圾回收**（**GC**）是一种自动内存管理形式，与旧的想法完全不同，旧的想法是开发者在需要时分配内存，在不再需要时释放内存。
- en: The whole philosophy is based on the concept of **Garbage Collector**, an entity
    that tries to reclaim memory occupied by objects that are not used anymore in
    the program. It's a well-known tool in the Java world and Android has always suffered
    from its downside—GC is very slow and blocking.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 整个理念基于**垃圾回收器**的概念，这是一个尝试回收程序中不再使用的对象占用的内存的实体。它是Java世界中的一个知名工具，Android一直受其缺点的影响——GC非常慢且会阻塞。
- en: 'Android 2.3 introduced the concurrent garbage collector—GC is not blocking
    the app anymore when it occurs, but there will always be an overall slowdown when
    it occurs. Finally, ART introduced a few more performance improvements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.3引入了并发垃圾回收器——当垃圾回收发生时，GC不再阻塞应用程序，但发生时总会导致整体速度放缓。最后，ART引入了一些更多的性能改进：
- en: Just one pause for garbage collection instead of Dalvik's two pauses
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需一次暂停进行垃圾回收，而不是Dalvik的两次暂停
- en: GC processing is now parallelized, reducing the duration of the GC pause
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC处理现在是并行化的，减少了GC暂停的持续时间
- en: New Rosalloc memory allocator that uses thread-local region allocations for
    smaller objects and separate locks for bigger objects, instead of a single global
    lock
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的Rosalloc内存分配器使用线程局部区域分配来处理较小的对象，并为较大的对象使用单独的锁，而不是单个全局锁
- en: Full garbage collection is run only when the phone is locked so that the user
    doesn't notice when the GC is run
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当手机锁定时才运行完整的垃圾回收，这样用户就不会注意到GC何时运行
- en: There is a compacting GC that reduces memory fragmentation and so diminishes
    the need to kill other applications just because bigger contiguous memory chunks
    are needed
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种压缩GC可以减少内存碎片，从而减少因为需要更大的连续内存块而杀死其他应用程序的需求
- en: From a development and debugging point of view, ART brought in the support for
    sampling profiler, support for more debugging features, and improved diagnostic
    details in exceptions and crash reports.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发和调试的角度来看，ART引入了对采样分析器的支持，对更多调试功能的支持，以及在异常和崩溃报告中改进的诊断细节。
- en: Waiting for Android Nougat
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待Android Nougat
- en: 'The upcoming version of Android will bring some enhancement to the current
    ART runtime. Google will introduce a so-called Profile-guided JIT/AOT compilation.
    JIT stands for Just In Time and looks similar to the old Dalvik approach: a compiler
    with code profiling capabilities. This JIT compiler will work together with ART
    and will provide constant performance improvement as it will continuously be profiling
    code and resource usage.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 即将推出的 Android 版本将为当前的 ART 运行时带来一些增强。谷歌将引入所谓的基于配置文件的 JIT/AOT 编译。JIT 代表即时编译，类似于旧的
    Dalvik 方法：一个具有代码分析能力的编译器。这个 JIT 编译器将与 ART 合作，并会提供持续的性能改进，因为它将不断分析代码和资源使用情况。
- en: To improve performance during the installation phase, ART won't pre-compile
    Ahead-Of-Time the whole app. Instead, thanks to the profiling approach, it will
    detect hot methods in the app and will only pre-compile them, leaving unused parts
    of the app uncompiled. This precompilation process is smartly performed when the
    device is idle and charging, to have the smallest negative impact on the user
    experience and allow the user to install in instants apps that in Android 6 would
    take several seconds to be installed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在安装阶段提高性能，ART 不会预先编译整个应用程序。相反，得益于分析方法，它将检测应用程序中的热点方法，并且只会预先编译这些方法，而将应用程序未使用的部分保持未编译状态。这个预编译过程在设备空闲且充电时智能执行，以最小化对用户体验的负面影响，并允许用户瞬间安装应用程序，这在
    Android 6 中可能需要几秒钟才能安装。
- en: This whole new approach aims to improve applications and system performance
    on low end devices, reducing RAM memory footprint, battery draining and increasing
    runtime performance, for a satisfying Android experience on a wide range of devices.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 整个新的方法旨在提高低端设备上的应用程序和系统性能，减少 RAM 内存占用，降低电池消耗，并提高运行时性能，以在广泛的设备上提供令人满意的 Android
    体验。
- en: Meeting the Compatibility Test Suite
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符合兼容性测试套件
- en: We are aware of the CDD and we did our best to create a compatible device. A
    lot of aspects could still have glitches and we surely want to get rid of them.
    To make sure that everything works as expected, our Android implementation must
    be tested with Android Compatibility Test Suite. Android CTS will accompany us
    throughout the journey to our certified device. We will constantly use it to keep
    an eye on what is working and what is not working yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解 CDD，并尽最大努力创建了一个兼容的设备。许多方面可能仍然存在故障，我们当然希望消除它们。为了确保一切按预期工作，我们的 Android 实现必须使用
    Android 兼容性测试套件进行测试。Android CTS 将伴随我们走过认证设备之旅。我们将不断使用它来关注哪些正在工作，哪些尚未工作。
- en: 'Every new version of Android platform comes with a new **Compatibility Test
    Suite** (**CTS**). This automated testing suite has two main components:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的 Android 平台版本都附带一个新的**兼容性测试套件**（**CTS**）。这个自动化测试套件有两个主要组件：
- en: Tradefed, that manages text execution from the desktop.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tradefed，它管理桌面上的文本执行。
- en: Test cases executed on the **Device Under Test** (**DUT**). These cases are
    regular JUnit tests written in Java and packaged as Android `.apk` files so that
    they can be executed on the target device.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**测试设备**（**DUT**）上执行的测试用例。这些案例是使用 Java 编写的常规 JUnit 测试，打包成 Android `.apk` 文件，以便在目标设备上执行。
- en: There is also the CTS Verifier, a tool for manual testing that consists of the
    verifier app that is executed on the device and collects the test results; and
    other executables or scripts that are executed on the desktop machine in order
    to provide further data or control for some test cases in the Verifier app.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 CTS 验证器，这是一个用于手动测试的工具，它包括在设备上执行并收集测试结果的验证器应用程序；以及在其他桌面机器上执行的其它可执行文件或脚本，以便为验证器应用程序中的某些测试用例提供更多数据或控制。
- en: 'The following diagram shows the CTS workflow:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 CTS 工作流程：
- en: '![](img/epub_36702041_6.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_6.jpeg)'
- en: The test suite on your computer will install the test on the device and will
    launch it. The device will test that particular subset of features and will give
    the results back to the test suite on your computer. The test suite will store
    these results, install the next test, and will start the cycle again, until every
    test is executed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您计算机上的测试套件将在设备上安装测试并启动它。设备将测试特定的功能子集，并将结果返回到您计算机上的测试套件。测试套件将存储这些结果，安装下一个测试，并再次开始循环，直到每个测试都执行完毕。
- en: 'Currently, the CTS provides two main types of test cases:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，CTS 提供两种主要的测试用例类型：
- en: Unit tests
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Functional tests
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Unit tests test the smallest logical units of code within the Android platform,
    for example, a single class, such as `java.util.HashMap`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试测试Android平台中代码的最小逻辑单元，例如，一个单独的类，如`java.util.HashMap`。
- en: Functional tests are used to test a specific function that can consist of numerous
    API method calls.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试用于测试特定的功能，这可能包括多个API方法调用。
- en: 'Google is planning to provide more tests in the future versions of the test
    case. A couple of ideas are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Google计划在测试用例的未来版本中提供更多测试。一些想法包括：
- en: '**Robustness tests**: This tests the system''s durability under stress conditions'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鲁棒性测试**：这项测试是在压力条件下测试系统的耐用性'
- en: '**Performance tests**: This tests the system''s performance, such as frames
    per second'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：这项测试是测试系统的性能，例如每秒帧数'
- en: 'The following table shows the areas covered by the Compatibility Test Suite:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了兼容性测试套件覆盖的区域：
- en: '![](img/epub_36702041_7.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_7.jpeg)'
- en: CTS setup
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CTS设置
- en: 'Our journey will be very practical and hands-on, that''s why in this section
    we are going to set up Android Compatibility Test Suite to test an existing device.
    We can''t start working on our own Android implementation without knowing what
    we are going to support and test. To be able to run Android CTS, we will need:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程将非常实用和动手，这就是为什么在本节中我们将设置Android兼容性测试套件来测试现有设备。在不知道我们将支持什么以及要测试什么之前，我们不能开始我们的Android实现工作。为了能够运行Android
    CTS，我们需要：
- en: A computer running Linux or OS X
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Linux或OS X的计算机
- en: '*Android SDK*: [http://developer.android.com/sdk/installing/index.html](http://developer.android.com/sdk/installing/index.html)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Android SDK*：[http://developer.android.com/sdk/installing/index.html](http://developer.android.com/sdk/installing/index.html)'
- en: '*Java SDK 6 or 7*: [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java SDK 6或7*：[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
- en: '*Android CTS*: [http://source.android.com/compatibility/downloads.html](http://source.android.com/compatibility/downloads.html)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Android CTS*：[http://source.android.com/compatibility/downloads.html](http://source.android.com/compatibility/downloads.html)'
- en: '*Android CTS Media*: [https://dl.google.com/dl/android/cts/android-cts-media-1.1.zip](https://dl.google.com/dl/android/cts/android-cts-media-1.1.zip)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Android CTS媒体*：[https://dl.google.com/dl/android/cts/android-cts-media-1.1.zip](https://dl.google.com/dl/android/cts/android-cts-media-1.1.zip)'
- en: There are a lot of files to download. In the meantime, we will set up our device.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要下载的文件有很多。同时，我们将设置我们的设备。
- en: Device setup
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备设置
- en: We are testing an existing device, a smartphone, so we are already satisfying
    needs such as having a screen and we can move to device software configuration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在测试一个现有的设备，一部智能手机，所以我们已经满足了诸如拥有屏幕等需求，我们可以转向设备软件配置。
- en: Tests should be executed on a *clean* device, so we should run a **Factory Restore**
    to erase all the data on the smartphone. Be sure of having a backup of your data
    if you are not using a development device. On Android 4.4 KitKat, you can reach
    the specific menu by navigating to **Settings** | **Backup & reset** | **Factory
    data reset**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应在**干净**的设备上执行，因此我们应该运行**出厂重置**来擦除智能手机上的所有数据。如果您不是使用开发设备，请确保备份了您的数据。在Android
    4.4 KitKat上，您可以通过导航到**设置** | **备份与重置** | **出厂数据重置**来访问特定菜单。
- en: This will take a while—the device will shut down and the erasing process will
    start. The procedure will remove every single byte that is not part of the original
    Android system provided with your device, restoring all the settings and bringing
    the device to its original setup.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间——设备将关闭，擦除过程将开始。该程序将移除不属于您设备上提供的原始Android系统中的每个字节，恢复所有设置，并将设备恢复到原始设置。
- en: When the device restarts, we need to select `English US` language by navigating
    to **Settings** | **Language & input** | **Language**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备重启时，我们需要通过导航到**设置** | **语言和输入** | **语言**来选择`英语（美国）`语言。
- en: 'Now we need to turn on the **Location**: We need Wi-Fi and GPS and we need
    to provide some Internet connectivity. We need to disable any **Screen Lock**
    by navigating to **Settings** | **Security** | **Screen Lock = ''None''**.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要打开**位置**：我们需要Wi-Fi和GPS，我们需要提供一些互联网连接。我们需要通过导航到**设置** | **安全** | **屏幕锁定
    = '无'**来禁用任何**屏幕锁定**。
- en: 'We need a few settings from the **Developer options** menu. On a brand new
    installation of a vanilla Android system this menu is hidden. We can enable using
    the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从**开发者选项**菜单中设置一些设置。在全新安装的纯净Android系统中，此菜单是隐藏的。我们可以通过以下步骤启用：
- en: Navigate to **Settings** | **About phone**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**设置** | **关于手机**。
- en: Scroll to the bottom.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到页面底部。
- en: Tap continuously on build number item.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续点击构建号项。
- en: You are now a developer!
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在是一名开发者！
- en: Note
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you are working with an HTC, Samsung, or Sony device and its custom version
    of Android, the previous steps could be a bit different. We leave it as an exercise
    to find the right navigation path for your non-vanilla Android version.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 HTC、三星或索尼设备及其定制的 Android 版本，之前的步骤可能略有不同。我们将将其留作练习，以找到适合您非标准 Android
    版本的正确导航路径。
- en: 'Once the **Developer options** menu has been enabled, navigate back to the
    **Settings** screen. In the **Developer options** menu, we need to enable the
    following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 **开发者选项** 菜单被启用，导航回 **设置** 屏幕。在 **开发者选项** 菜单中，我们需要启用以下选项：
- en: USB debugging
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB 调试
- en: Stay awake
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持清醒
- en: Allow mock locations
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许模拟位置
- en: Before running any tests, it's important that the device is on a steady support
    to avoid triggering accelerometers and the gyroscope. The camera should be pointing
    to a focusable object. Don't press any buttons or keys during the tests—this could
    invalidate test results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何测试之前，确保设备在一个稳定的支撑物上，以避免触发加速度计和陀螺仪。相机应该指向一个可聚焦的对象。测试期间不要按任何按钮或键——这可能会使测试结果无效。
- en: Media files setup
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体文件设置
- en: 'To properly run all the tests, we will need a few multimedia files on the device—Android
    CTS media files. First of all, let''s connect the device to the USB. If this is
    the first time that you connect this device to this host PC, the device will display
    a dialog to authorize the connection—allow the connection:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正确运行所有测试，我们需要在设备上准备一些多媒体文件——Android CTS 媒体文件。首先，让我们将设备连接到 USB。如果这是您第一次将此设备连接到这台主机
    PC，设备将显示一个对话框以授权连接——允许连接：
- en: Any Android device can communicate with a host PC using Android `ADB`. This
    key tool is covered in great detail in the next chapters, so, for now, we can
    start downloading the latest Android SDK from [https://developer.android.com/studio/index.html#downloads](https://developer.android.com/studio/index.html#downloads),
    according to your platform. Once the download is completed, decompress the file
    and you will be provided with an `android-sdk` folder, containing a `platform-tools`
    folder, containing adb executable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Android 设备都可以使用 Android `ADB` 与主机 PC 通信。这个关键工具将在下一章中详细介绍，所以现在我们可以根据您的平台从
    [https://developer.android.com/studio/index.html#downloads](https://developer.android.com/studio/index.html#downloads)
    开始下载最新的 Android SDK。下载完成后，解压缩文件，您将获得一个包含 `platform-tools` 文件夹的 `android-sdk` 文件夹，其中包含可执行的
    adb。
- en: 'Back to our media files setup now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的媒体文件设置：
- en: Open a terminal.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'Navigate to the downloaded file, for instance:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到下载的文件，例如：
- en: '[PRE0]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unzip the file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压文件：
- en: '[PRE1]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the brand new `android-cts-media` folder with:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进入全新的 `android-cts-media` 文件夹：
- en: '[PRE2]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This folder contains a file that we must make executable:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件夹包含一个我们必须使其可执行文件：
- en: '[PRE3]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we are ready to copy all the media files we need onto the device:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备将所有需要的媒体文件复制到设备上：
- en: '[PRE4]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next screenshot shows the output of the whole procedure:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了整个过程的输出：
- en: '![](img/epub_36702041_8.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_8.jpeg)'
- en: Run!
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行！
- en: 'Everything is in place now and we can use `cts-tradefed` to run some test plans.
    Move to the Android CTS folder and run the following command to enter the `cts`
    console:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就绪，我们可以使用 `cts-tradefed` 运行一些测试计划。移动到 Android CTS 文件夹，并运行以下命令以进入 `cts` 控制台：
- en: '[PRE5]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/epub_36702041_9.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_9.jpeg)'
- en: The previous screenshot shows how `cts-tradefed` automatically identifies our
    connected device and gets ready to test.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示了 `cts-tradefed` 如何自动识别我们连接的设备并准备测试。
- en: 'CTS console provides a few useful commands:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: CTS 控制台提供了一些有用的命令：
- en: '`list plans`: This will list all the available test plans in the repository'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list plans`：这将列出存储库中所有可用的测试计划'
- en: '`list packages`: This will list all the available test packages in the repository'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list packages`：这将列出存储库中所有可用的测试包'
- en: '`run`: This will allow us to run all the tests we want'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：这将允许我们运行所有想要的测试'
- en: 'Typically, the following test plans are available:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，以下测试计划可用：
- en: All CTS tests required for compatibility
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有兼容性所需的 CTS 测试
- en: Signature tests the signature verification of all public APIs
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名测试检查所有公共 API 的签名验证
- en: Android tests for the Android APIs
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android API 的 Android 测试
- en: Java tests for the Java core library
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 核心库的 Java 测试
- en: VM tests for ART or Dalvik
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ART 或 Dalvik 的虚拟机测试
- en: Performance tests for your implementation
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对您的实现进行性能测试
- en: 'As our first approach to CTS, we are going to run *CTS* plan:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们对 CTS 的第一次尝试，我们将运行 *CTS* 计划：
- en: '[PRE6]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The testing will start immediately and the console will be full of log messages
    in the blink of an eye, as shown in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将立即开始，控制台将在一瞬间充满日志消息，如下面的截图所示：
- en: '![](img/epub_36702041_10.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/epub_36702041_10.jpeg)'
- en: 'Now, grab some coffee or make some good tea: this will take a while. `cts-tradefed`
    will test everything that is possible to test with an automatic test. Luckily
    for us, there is a lot that can be tested in this way.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拿一些咖啡或泡一些好茶：这需要一段时间。`cts-tradefed` 将测试所有可以通过自动测试进行测试的内容。幸运的是，有很多内容可以通过这种方式进行测试。
- en: Analyzing the test results
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析测试结果
- en: 'Time has passed, the tea has gone, and the tests are over. On a quad-core smartphone,
    such as a Motorola Moto G or Nexus 4, this could take up to 10 hours. Eventually,
    we have got some nice results to check out. According to the folder''s path we
    are working in, we will have results in a `.zip` file in the `cts` folder:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 时间已经过去，茶已经喝完，测试结束了。在四核智能手机上，例如摩托罗拉Moto G或Nexus 4，这可能需要长达10小时。最终，我们得到了一些可以检查的不错的结果。根据我们正在工作的文件夹路径，我们将在
    `cts` 文件夹中有一个 `.zip` 文件的结果：
- en: '[PRE7]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unzipping the file, we will find a `testResult.xml` file. Opening this file
    with a recent web browser (Firefox is working fine here) will show plenty of meaningful
    tables, with all kind of test and results. The next screenshot shows the initial
    Test Summary. We have information about the test duration, how many tests were
    executed, how many tests passed, and how many tests failed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 解压文件后，我们会找到一个 `testResult.xml` 文件。使用最新的网络浏览器（Firefox在这里运行良好）打开此文件将显示许多有意义的表格，包含各种测试和结果。下一个截图显示了初始测试摘要。我们有关于测试持续时间、执行了多少测试、多少测试通过以及多少测试失败的信息：
- en: '![](img/epub_36702041_11.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/epub_36702041_11.jpeg)'
- en: As you can see, even testing a certified smartphone, currently on the market,
    will produce some failed tests. This gives you an idea about the complexity of
    producing the perfect Android device.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使是测试目前市场上认证的手机，也会产生一些失败的测试。这让您对制造完美安卓设备的复杂性有了概念。
- en: 'The next screenshot shows Test Summary by Package, specifying the test results
    one test after the other. For brevity, we are showing just a subset of the results:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了按包分组的测试摘要，指定了一个接一个的测试结果。为了简洁，我们只显示了一部分结果：
- en: '![](img/epub_36702041_12.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/epub_36702041_12.jpeg)'
- en: 'The previous Test Summary screenshot shows that 29 tests have failed. If we
    dig into the test result file, we see that detailed reports are also available.
    This further information is hugely useful to precisely spot the failed test, like
    the one in the following screenshot, and investigate the issue:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试摘要截图显示有29个测试失败。如果我们深入研究测试结果文件，我们会看到还有详细的报告可用。这些进一步的信息对于精确地定位失败的测试，如以下截图所示，并调查问题非常有用：
- en: '![](img/epub_36702041_13.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/epub_36702041_13.jpeg)'
- en: The test result file tries to play polite and, for brevity, does not show the
    full stacktrace of the failed test. To reach the stack trace of the failure, we
    must inspect the source code of `testResult.xml`. For every executed test, there
    is a corresponding `<Test>` tag. For those tests that failed, we will have a `<StackTrace>`
    tag too. That's what we are looking for!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果文件试图表现得礼貌一些，为了简洁，没有显示失败测试的完整堆栈跟踪。要达到失败的堆栈跟踪，我们必须检查 `testResult.xml` 的源代码。对于每个执行的测试，都有一个相应的
    `<Test>` 标签。对于失败的测试，我们也会有 `<StackTrace>` 标签。这就是我们要找的！
- en: As a final note, `testResult.xml` contains a huge section with all the information
    about the device it has been able to retrieve. It's a very large amount of data
    that, for brevity, we are not reporting here, not even as an example.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意的是，`testResult.xml` 包含了一个包含所有已检索到的设备信息的巨大部分。这是一大批数据，为了简洁，我们在这里没有报告，甚至没有作为例子。
- en: Diving deeper with CTS Verifier
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入使用CTS Verifier
- en: We already know that there are lots of APIs and functions that we can automatically
    test with `cts-tradefed`, but what about all the other APIs and functions that
    cannot be tested within an automated environment?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，有很多API和函数我们可以使用 `cts-tradefed` 自动测试，但那些在自动化环境中无法测试的其他API和函数怎么办？
- en: CTS Verifier comes in every time an API or a function cannot be tested on a
    device without manual input. These are scenarios involving audio quality, touchscreen
    effectiveness, accelerometer precision and reactivity, camera quality, and features
    that are meant so specifically for human interaction that they are impossible
    to test without human interaction.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备上无法手动输入的情况下，API 或函数无法测试时，CTS Verifier 就会出现。这些场景包括音频质量、触摸屏有效性、加速度计精度和反应性、相机质量，以及专门为人类交互而设计的功能，这些功能在没有人类交互的情况下无法测试。
- en: Setup
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'All we need to run CTS Verifier is an Android certified device and the appropriate
    CTS Verifier APK file. As we are testing an Android 4.4 device, we need to pay
    attention to downloading the proper CTS Verifier version. You can download the
    APK for your Android version and device architecture here: [http://source.android.com/compatibility/downloads.html](http://source.android.com/compatibility/downloads.html).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 CTS Verifier 所需的只是 Android 认证设备和相应的 CTS Verifier APK 文件。由于我们正在测试 Android
    4.4 设备，我们需要注意下载正确的 CTS Verifier 版本。您可以从这里下载适合您 Android 版本和设备架构的 APK：[http://source.android.com/compatibility/downloads.html](http://source.android.com/compatibility/downloads.html)。
- en: 'You just need to unzip the downloaded file and you will find a folder hierarchy
    and two `.apk` files. You can install `CtsVerifier.apk` using ADB:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需解压下载的文件，您将找到一个文件夹层次结构和两个 `.apk` 文件。您可以使用 ADB 安装 `CtsVerifier.apk`：
- en: '[PRE8]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows the properly installed CTS Verified app and
    the initial screen:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了正确安装的 CTS Verified 应用程序和初始屏幕：
- en: '![](img/epub_36702041_14.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_14.jpeg)'
- en: Manual testing
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动测试
- en: As we know, CTS Verifier contains tests that need manual input to execute, evaluate,
    pass, or fail. Every test has its own **Info** screen that helps the tester to
    perform the test. As an example, we will run the **Accelerometer Test**, in the
    **Sensors** section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，CTS Verifier 包含需要手动输入来执行、评估、通过或失败的测试。每个测试都有自己的“信息”屏幕，帮助测试人员执行测试。例如，我们将运行“加速度计测试”，在“传感器”部分。
- en: 'Launching the test, we are welcomed by the info screen, as shown in the following
    screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 启动测试，我们欢迎信息屏幕，如图所示的下一个屏幕截图：
- en: '![](img/epub_36702041_15.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_15.jpeg)'
- en: 'The **Info** button explains how to perform the test and what to evaluate.
    As we move into the testing, we can evaluate if the accelerometer is working as
    expected. The following screenshot shows three different moments of the test:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: “信息”按钮解释了如何执行测试以及要评估的内容。随着我们进入测试阶段，我们可以评估加速度计是否按预期工作。以下屏幕截图显示了测试的三个不同时刻：
- en: The smartphone lays on the desk
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能手机放在桌子上
- en: The smartphone is held in hand, in portrait mode
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能手机手持，竖屏模式
- en: The smartphone is held in hand, in landscape mode![](img/epub_36702041_16.jpeg)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能手机手持，横屏模式![图片](img/epub_36702041_16.jpeg)
- en: 'As specified in the **Info** button, the arrow is always pointing in the same
    direction as the gravity: the sensor is working properly. We can consider that
    we have passed the test and click on the **Pass** button.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如“信息”按钮中所述，箭头始终指向与重力相同的方向：传感器工作正常。我们可以认为我们已经通过了测试，并点击“通过”按钮。
- en: We have passed our first test. CTS Verifier provides dozens of tests and, one
    by one, we are going to run, verify, and pass them, in the long journey towards
    our first Android Certified Device.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过了第一次测试。CTS Verifier 提供了数十项测试，我们将逐一运行、验证并通过它们，在通往我们第一个 Android 认证设备的漫长旅程中。
- en: Retrieving the results
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取结果
- en: 'When every test has been executed, we can save the result using the Save icon
    in the top-right corner of the initial screen, as shown in previous screenshot.
    The results will be saved on the device and a dialog box will show the precise
    path, as shown in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个测试都执行完毕后，我们可以使用初始屏幕右上角的“保存”图标来保存结果，如图所示的前一个屏幕截图。结果将保存在设备上，并将显示精确路径的对话框，如图所示的下一个屏幕截图：
- en: '![](img/epub_36702041_17.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_17.jpeg)'
- en: 'Now, let''s open a terminal and copy all the results from the phone to our
    computer:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个终端，并将所有结果从手机复制到我们的电脑上：
- en: '[PRE9]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, we have a `ctsVerifierReport-[…].xml` with all the info about
    our manually executed tests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个包含我们手动执行的所有测试信息的 `ctsVerifierReport-[…].xml` 文件。
- en: Congratulations! You have fully tested an Android device. Step 0 of our journey
    is complete.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已完全测试了一款 Android 设备。我们旅程的第 0 步已完成。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned what we are going to need to create a certified
    Android device. We saw the Android Compatibility Definition Document and we learned
    how to design a system to match the Android architecture. We had an overview of
    the two different runtime systems: Dalvik and ART and their main differences.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了创建认证Android设备所需的内容。我们看到了Android兼容性定义文档，并学习了如何设计一个与Android架构相匹配的系统。我们还对两个不同的运行时系统：Dalvik和ART及其主要区别有了概述。
- en: We had a full immersion into Android device testing, we learned how to run CTS
    automated tests and CTS manual tests on a already certified device.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Android设备测试进行了全面的学习，我们学习了如何在已认证的设备上运行CTS自动化测试和CTS手动测试。
- en: The next chapter will be very *hands-on*. We will learn how to retrieve Android
    source code and we will understand the code structure and organization.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将非常**实用**。我们将学习如何检索Android源代码，并了解代码的结构和组织。
