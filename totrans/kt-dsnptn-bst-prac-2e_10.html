<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer019">&#13;
			<h1 id="_idParaDest-192"><em class="italic"><a id="_idTextAnchor198"/>Chapter 8</em>: Designing for Concurrency</h1>&#13;
			<p><strong class="bold">Concurrent design patterns</strong> help us<a id="_idIndexMarker563"/> to manage many tasks at once and structure their life cycle. By using these patterns efficiently, we can avoid problems such as resource leaks and deadlocks. </p>&#13;
			<p>In this chapter, we'll discuss concurrent design patterns and how they are implemented in <strong class="bold">Kotlin</strong>. To do this, we'll be using the building blocks from previous chapters: coroutines, channels, flows, and concepts from <strong class="bold">functional programming</strong>.</p>&#13;
			<p>We will be covering the following topics in this chapter:</p>&#13;
			<ul>&#13;
				<li>Deferred value</li>&#13;
				<li>Barrier</li>&#13;
				<li>Scheduler</li>&#13;
				<li>Pipeline</li>&#13;
				<li>Fan out</li>&#13;
				<li>Fan in</li>&#13;
				<li>Racing </li>&#13;
				<li>Mutex</li>&#13;
				<li>Sidekick channel</li>&#13;
			</ul>&#13;
			<p>After completing this chapter, you'll be able to work with asynchronous values efficiently, coordinate the work of different coroutines, and distribute and aggregate work, as well as have the tools needed to resolve any concurrency problems that may arise in the process.</p>&#13;
			<h1 id="_idParaDest-193"><a id="_idTextAnchor199"/>Technical requirements</h1>&#13;
			<p>In addition to the technical requirements from the previous chapters, you will also need a <strong class="bold">Gradle</strong>-enabled Kotlin project to be able to add the required dependencies.</p>&#13;
			<p>You can find the source code used in this chapter on <strong class="bold">GitHub</strong> at the following location:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter08">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter08</a></p>&#13;
			<h1 id="_idParaDest-194"><a id="_idTextAnchor200"/>Deferred Value</h1>&#13;
			<p>The goal <a id="_idIndexMarker564"/>of the <strong class="bold">Deferred Value</strong> design pattern is to return a reference to a result of an asynchronous computation. A <strong class="bold">Future</strong> in <strong class="bold">Java</strong> and <strong class="bold">Scala</strong>, and a <strong class="bold">Promise</strong> in <strong class="bold">JavaScript</strong> are both implementations of the Deferred Value design pattern. </p>&#13;
			<p>We've already discussed <strong class="bold">deferred values</strong> in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>. We've seen that the <strong class="source-inline">async()</strong> function returns a type called <strong class="source-inline">Deferred</strong>, which is also an implementation of this design pattern.</p>&#13;
			<p>Interestingly enough, the <strong class="source-inline">Deferred</strong> value itself is an implementation of both the <strong class="bold">Proxy</strong> design<a id="_idIndexMarker565"/> pattern that we've seen in <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>, and<a id="_idIndexMarker566"/> the <strong class="bold">State</strong> design pattern from <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>.</p>&#13;
			<p>We can create a new container for the result of an asynchronous computation using the <strong class="source-inline">CompletableDeferred</strong> constructor:</p>&#13;
			<p class="source-code">val deferred = CompletableDeferred&lt;String&gt;()</p>&#13;
			<p>To populate the <strong class="source-inline">Deferred</strong> value with a result, we use the <strong class="source-inline">complete()</strong> function, and if an error occurs in the process, we can use the <strong class="source-inline">completeExceptionally()</strong> function to pass the exception to the caller. To understand it better, let's write a function that returns an asynchronous result. Half of the time the result will contain <strong class="source-inline">OK</strong>, and the other half of the time it will contain an exception. </p>&#13;
			<p class="source-code">suspend fun valueAsync(): Deferred&lt;String&gt; = coroutineScope {</p>&#13;
			<p class="source-code">    val deferred = CompletableDeferred&lt;String&gt;()</p>&#13;
			<p class="source-code">    launch {</p>&#13;
			<p class="source-code">        delay(100)</p>&#13;
			<p class="source-code">        if (Random.nextBoolean()) {</p>&#13;
			<p class="source-code">            deferred.complete("OK")</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        else {</p>&#13;
			<p class="source-code">            deferred.completeExceptionally(</p>&#13;
			<p class="source-code">              RuntimeException()</p>&#13;
			<p class="source-code">            )</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    deferred</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>You can see that<a id="_idIndexMarker567"/> we return the <strong class="source-inline">Deferred</strong> value almost immediately, then we start an asynchronous computation using <strong class="source-inline">launch</strong> and simulate some computation using the <strong class="source-inline">delay()</strong> function.</p>&#13;
			<p>Since the process is asynchronous, the results won't be ready immediately. To wait for the results, we can use the <strong class="source-inline">await()</strong> function that we've already discussed in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>:</p>&#13;
			<p class="source-code">runBlocking {</p>&#13;
			<p class="source-code">    val value = valueAsync()</p>&#13;
			<p class="source-code">    println(value.await())</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>It's important to make sure that you always complete your <strong class="source-inline">Deferred</strong> value by calling either of the <strong class="source-inline">complete()</strong> or <strong class="source-inline">completeExceptionally()</strong> functions. Otherwise, your program may wait indefinitely for the results. It is also possible to cancel <strong class="source-inline">deferred</strong> if you're no longer interested in its results. To do this, simply call <strong class="source-inline">cancel()</strong> on it:</p>&#13;
			<p class="source-code">deferred.cancel()</p>&#13;
			<p>You'll rarely need to create your own deferred value. Usually, you would work with the one returned from the <strong class="source-inline">async()</strong> function.</p>&#13;
			<p>Next, let's <a id="_idIndexMarker568"/>discuss how to wait for multiple asynchronous results at once.</p>&#13;
			<h1 id="_idParaDest-195"><a id="_idTextAnchor201"/>Barrier</h1>&#13;
			<p>The <strong class="bold">Barrier</strong> design <a id="_idIndexMarker569"/>pattern provides us with the ability to wait for multiple concurrent tasks to complete before proceeding further. A common use case for this is composing objects from different sources.</p>&#13;
			<p>For example, take the following class:</p>&#13;
			<p class="source-code">data class FavoriteCharacter(</p>&#13;
			<p class="source-code">    val name: String,</p>&#13;
			<p class="source-code">    val catchphrase: String,</p>&#13;
			<p class="source-code">    val picture: ByteArray = Random.nextBytes(42)</p>&#13;
			<p class="source-code">)</p>&#13;
			<p>Let's assume that the <strong class="source-inline">catchphrase</strong> data comes from one service and the <strong class="source-inline">picture</strong> data comes from another. We would like to fetch these two pieces of data concurrently:</p>&#13;
			<p class="source-code">fun CoroutineScope.getCatchphraseAsync</p>&#13;
			<p class="source-code">(</p>&#13;
			<p class="source-code">    characterName: String</p>&#13;
			<p class="source-code">) = async { … }</p>&#13;
			<p class="source-code">fun CoroutineScope.getPicture</p>&#13;
			<p class="source-code">(</p>&#13;
			<p class="source-code">    characterName: String</p>&#13;
			<p class="source-code">) = async { … }</p>&#13;
			<p>The most basic way to implement concurrent fetching would be as follows:</p>&#13;
			<p class="source-code">suspend fun fetchFavoriteCharacter(name: String) = coroutineScope {</p>&#13;
			<p class="source-code">    val catchphrase = getCatchphraseAsync(name).await()</p>&#13;
			<p class="source-code">    val picture = getPicture(name).await()</p>&#13;
			<p class="source-code">    FavoriteCharacter(name, catchphrase, picture)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>But this solution has a major problem – we don't start fetching the <strong class="source-inline">picture</strong> data until the <strong class="source-inline">catchphrase</strong> data was fetched. In other words, the code is unnecessarily <em class="italic">sequential</em>. Let's<a id="_idIndexMarker570"/> see how this can be improved.</p>&#13;
			<h2 id="_idParaDest-196"><a id="_idTextAnchor202"/>Using data classes as barriers</h2>&#13;
			<p>We can<a id="_idIndexMarker571"/> slightly alter the previous code to achieve the concurrency we want:</p>&#13;
			<p class="source-code">suspend fun fetchFavoriteCharacter(name: String) = coroutineScope { </p>&#13;
			<p class="source-code">    val catchphrase = getCatchphraseAsync(name) </p>&#13;
			<p class="source-code">    val picture = getPicture(name) </p>&#13;
			<p class="source-code">    FavoriteCharacter(name, catchphrase.await(),       picture.await()) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Moving the <strong class="source-inline">await</strong> function into the invocation of the data class constructor allows us to start all of the coroutines at once and then wait for them to complete, just as we wanted. </p>&#13;
			<p>The additional benefit of using data classes as barriers is the ability to <em class="italic">destructure</em> them easily:</p>&#13;
			<p class="source-code">val (name, catchphrase, _) = fetchFavoriteCharacter("Inigo Montoya")</p>&#13;
			<p class="source-code">println("$name says: $catchphrase")</p>&#13;
			<p>This works well if the type of data we receive from different asynchronous tasks is heterogeneous. In some cases, we receive the same types of data from different sources. </p>&#13;
			<p>For example, let's ask <strong class="source-inline">Michael</strong> (our canary product owner), <strong class="source-inline">Taylor</strong> (our barista), and <strong class="source-inline">Me</strong> who our favorite movie character is:</p>&#13;
			<p class="source-code">object Michael {</p>&#13;
			<p class="source-code">    suspend fun getFavoriteCharacter() = coroutineScope {</p>&#13;
			<p class="source-code">        async {</p>&#13;
			<p class="source-code">            FavoriteCharacter("Terminator", </p>&#13;
			<p class="source-code">              "Hasta la vista, baby")</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">object Taylor {</p>&#13;
			<p class="source-code">    suspend fun getFavoriteCharacter() = coroutineScope {</p>&#13;
			<p class="source-code">        async {</p>&#13;
			<p class="source-code">            FavoriteCharacter("Don Vito Corleone", "I'm </p>&#13;
			<p class="source-code">              going to make him an offer he can't refuse")</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">object Me {</p>&#13;
			<p class="source-code">    suspend fun getFavoriteCharacter() = coroutineScope {</p>&#13;
			<p class="source-code">        async {</p>&#13;
			<p class="source-code">            // I already prepared the answer!</p>&#13;
			<p class="source-code">            FavoriteCharacter("Inigo Montoya",               "Hello, my name is...")</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we have three very similar objects that differ only in the contents of the asynchronous results they return. </p>&#13;
			<p>In this case, we can use a list to gather the results:</p>&#13;
			<p class="source-code">val characters: List&lt;Deferred&lt;FavoriteCharacter&gt;&gt; =    listOf(</p>&#13;
			<p class="source-code">        Me.getFavoriteCharacter(),</p>&#13;
			<p class="source-code">        Taylor.getFavoriteCharacter(),</p>&#13;
			<p class="source-code">        Michael.getFavoriteCharacter(),</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p>Notice the type <a id="_idIndexMarker572"/>of the list. It's a collection of the <strong class="source-inline">Deferred</strong> elements of the <strong class="source-inline">FavoriteCharacter</strong> type. On such collections, there's an <strong class="source-inline">awaitAll()</strong> function available that acts as a barrier as well:</p>&#13;
			<p class="source-code">println(characters.awaitAll())</p>&#13;
			<p>When working with a set of homogenous asynchronous results and you need all of them to complete before proceeding further, use <strong class="source-inline">awaitAll()</strong>.</p>&#13;
			<p>The Barrier design pattern creates a rendezvous point for multiple asynchronous tasks. The next pattern will help us abstract the execution of those tasks.</p>&#13;
			<h1 id="_idParaDest-197"><a id="_idTextAnchor203"/>Scheduler</h1>&#13;
			<p>The goal of <a id="_idIndexMarker573"/>the <strong class="bold">Scheduler</strong> design pattern is to decouple <em class="italic">what</em> is being run from <em class="italic">how</em> it's being run and optimize the use of resources when doing so.</p>&#13;
			<p>In Kotlin, <strong class="bold">Dispatchers</strong> are an implementation of the Scheduler design pattern that decouple the coroutine (that is, the <em class="italic">what</em>) from underlying thread pools (that is, the <em class="italic">how</em>).</p>&#13;
			<p>We've already seen dispatchers briefly in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>. </p>&#13;
			<p>To remind you, the coroutine builders such as <strong class="source-inline">launch()</strong> and <strong class="source-inline">async()</strong> can specify which dispatcher to use. Here's an example of how you specify it explicitly:</p>&#13;
			<p class="source-code">runBlocking {</p>&#13;
			<p class="source-code">    // This will use the Dispatcher from the parent </p>&#13;
			<p class="source-code">    // coroutine</p>&#13;
			<p class="source-code">    launch {</p>&#13;
			<p class="source-code">        // Prints: main</p>&#13;
			<p class="source-code">        println(Thread.currentThread().name) </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    launch(Dispatchers.Default) {</p>&#13;
			<p class="source-code">        // Prints DefaultDispatcher-worker-1</p>&#13;
			<p class="source-code">        println(Thread.currentThread().name) </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The default dispatcher <a id="_idIndexMarker574"/>creates as many threads as you have CPUs in the underlying thread pool. Another dispatcher that is available to you is the <strong class="bold">IO Dispatcher</strong>:</p>&#13;
			<p class="source-code">async(Dispatchers.IO) {</p>&#13;
			<p class="source-code">    for (i in 1..1000) {</p>&#13;
			<p class="source-code">        println(Thread.currentThread().name)</p>&#13;
			<p class="source-code">        yield()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This will output the following:</p>&#13;
			<p class="source-code">&gt; …</p>&#13;
			<p class="source-code">&gt; DefaultDispatcher-worker-2</p>&#13;
			<p class="source-code">&gt; DefaultDispatcher-worker-1</p>&#13;
			<p class="source-code">&gt; DefaultDispatcher-worker-1</p>&#13;
			<p class="source-code">&gt; DefaultDispatcher-worker-1</p>&#13;
			<p class="source-code">&gt; DefaultDispatcher-worker-3</p>&#13;
			<p class="source-code">&gt; DefaultDispatcher-worker-3</p>&#13;
			<p class="source-code">&gt; ...</p>&#13;
			<p>The IO Dispatcher is used for potentially long-running or blocking operations and will create up to 64 threads for that purpose. Since our example code doesn't do much, the IO Dispatcher <a id="_idIndexMarker575"/>doesn't need to create many threads. That's why you'll see only a small number of workers used in this example.</p>&#13;
			<h2 id="_idParaDest-198"><a id="_idTextAnchor204"/>Creating your own schedulers</h2>&#13;
			<p>We are not<a id="_idIndexMarker576"/> limited to the dispatchers Kotlin provides. We can also define dispatchers of our own.</p>&#13;
			<p>Here is an example of creating a dispatcher that would use a dedicated thread pool of <strong class="source-inline">4</strong> threads based on <strong class="source-inline">ForkJoinPool</strong>, which is efficient for <em class="italic">divide-and-conquer</em> tasks:</p>&#13;
			<p class="source-code">val forkJoinPool = ForkJoinPool(4).asCoroutineDispatcher()</p>&#13;
			<p class="source-code">        </p>&#13;
			<p class="source-code">repeat(1000) {</p>&#13;
			<p class="source-code">    launch(forkJoinPool) {</p>&#13;
			<p class="source-code">        println(Thread.currentThread().name)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you create your own dispatcher, make sure that you either release it with <strong class="source-inline">close()</strong> or reuse it, as creating a new dispatcher and holding to it is expensive in terms of resources.</p>&#13;
			<h1 id="_idParaDest-199"><a id="_idTextAnchor205"/>Pipeline</h1>&#13;
			<p>The <strong class="bold">Pipeline</strong> design <a id="_idIndexMarker577"/>pattern allows us to scale heterogeneous work, consisting of multiple steps of varying complexity across multiple CPUs, by breaking the work into smaller, concurrent pieces. Let's look at the following example to understand it better.</p>&#13;
			<p>Back in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, we wrote an HTML page parser. It was assumed that the HTML pages themselves were already fetched for us, though. What we would like to design now is a process that would create a possibly infinite stream of pages.</p>&#13;
			<p>First, we would<a id="_idIndexMarker578"/> like to fetch news pages once in a while. For that, we'll have a producer:</p>&#13;
			<p class="source-code">fun CoroutineScope.producePages() = produce {</p>&#13;
			<p class="source-code">    fun getPages(): List&lt;String&gt; {</p>&#13;
			<p class="source-code">        // This should actually fetch something</p>&#13;
			<p class="source-code">        return listOf(</p>&#13;
			<p class="source-code">            "&lt;html&gt;&lt;body&gt;&lt;h1&gt;</p>&#13;
			<p class="source-code">               Cool stuff&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;",</p>&#13;
			<p class="source-code">            "&lt;html&gt;&lt;body&gt;&lt;h1&gt;</p>&#13;
			<p class="source-code">               Even more stuff&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</p>&#13;
			<p class="source-code">        )</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    val pages = getPages()</p>&#13;
			<p class="source-code">    </p>&#13;
			<p class="source-code">    while (this.isActive) {</p>&#13;
			<p class="source-code">        for (p in pages) {</p>&#13;
			<p class="source-code">            send(p)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The <strong class="source-inline">isActive</strong> flag will be true as long as the coroutine is running and hasn't been canceled. It is a good practice to check this property in loops that may run for a long time so they can be stopped between iterations if needed.</p>&#13;
			<p>Each time we receive new titles, we send them downstream. Since tech news isn't updated very often, we can check for updates only once in a while by using <strong class="source-inline">delay()</strong>. In the actual code, the delay would probably be minutes, if not hours.</p>&#13;
			<p>The next step is <a id="_idIndexMarker579"/>creating a <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) out of those raw strings containing HTML. For that, we'll have a second producer, with this one receiving a channel that <a id="_idIndexMarker580"/>connects it to the first one:</p>&#13;
			<p class="source-code">fun CoroutineScope.produceDom(pages: ReceiveChannel&lt;String&gt;) = produce {</p>&#13;
			<p class="source-code">    fun parseDom(page: String): Document {</p>&#13;
			<p class="source-code">        // In reality this would use a DOM library to parse </p>&#13;
			<p class="source-code">        // string to DOM</p>&#13;
			<p class="source-code">        return Document(page)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    for (p in pages) {</p>&#13;
			<p class="source-code">        send(parseDom(p))</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We can use the <strong class="source-inline">for</strong> loop to iterate over the channel as long as it's still open. This is a very elegant way of consuming data from an asynchronous source without the need to define callbacks. </p>&#13;
			<p>We'll have a third function that receives the parsed documents and extracts the title out of each one:</p>&#13;
			<p class="source-code">fun CoroutineScope.produceTitles(parsedPages: ReceiveChannel&lt;Document&gt;) = produce {</p>&#13;
			<p class="source-code">    fun getTitles(dom: Document): List&lt;String&gt; {</p>&#13;
			<p class="source-code">        return dom.getElementsByTagName("h1").map {</p>&#13;
			<p class="source-code">            it.toString()</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    for (page in parsedPages) {</p>&#13;
			<p class="source-code">        for (t in getTitles(page)) {</p>&#13;
			<p class="source-code">            send(t)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We're looking for the headers, and so we use <strong class="source-inline">getElementsByTagName("H1")</strong>. For each header<a id="_idIndexMarker581"/> found, we turn it into its string representation.</p>&#13;
			<p>Now, we will move on toward composing our coroutines into pipelines.</p>&#13;
			<h2 id="_idParaDest-200"><a id="_idTextAnchor206"/>Composing a pipeline</h2>&#13;
			<p>Now that<a id="_idIndexMarker582"/> we've familiarized ourselves with the components of the pipeline, let's see how we can combine multiple components together:</p>&#13;
			<p class="source-code">runBlocking {</p>&#13;
			<p class="source-code">    val pagesProducer = producePages()</p>&#13;
			<p class="source-code">    val domProducer = produceDom(pagesProducer)</p>&#13;
			<p class="source-code">    val titleProducer = produceTitles(domProducer)</p>&#13;
			<p class="source-code">    titleProducer.consumeEach {</p>&#13;
			<p class="source-code">        println(it)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The resulting pipeline will look as follows:</p>&#13;
			<p class="source-code">Input=&gt;pagesProducer=&gt;domProducer=&gt;titleProducer=&gt;Output</p>&#13;
			<p>A pipeline is a great way to break a long process into smaller steps. Note that each resulting coroutine is a <em class="italic">pure function</em>, so it's also easy to test and reason about. </p>&#13;
			<p>The entire<a id="_idIndexMarker583"/> pipeline could be stopped by calling <strong class="source-inline">cancel()</strong> on the first coroutine in line.</p>&#13;
			<h1 id="_idParaDest-201"><a id="_idTextAnchor207"/>Fan Out</h1>&#13;
			<p>The goal <a id="_idIndexMarker584"/>of the <strong class="bold">Fan Out</strong> design pattern is to distribute work between multiple concurrent processors, also known as <em class="italic">workers</em>. To understand it better, let's look again at the previous section but consider the following problem:</p>&#13;
			<p><em class="italic">What if the amount of work at the different steps in our pipeline is very different?</em></p>&#13;
			<p>For example, it takes a lot more time to <em class="italic">fetch</em> the HTML content than to <em class="italic">parse</em> it. In such a case, we may want to distribute that heavy work between multiple coroutines. In the previous example, only a single coroutine was reading from each channel. But multiple coroutines can consume from a single channel too, thus dividing the work.</p>&#13;
			<p>To simplify the problem we're about to discuss, let's have only one coroutine producing some results:</p>&#13;
			<p class="source-code">fun CoroutineScope.generateWork() = produce {</p>&#13;
			<p class="source-code">    for (i in 1..10_000) {</p>&#13;
			<p class="source-code">        send("page$i")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    close()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>And we'll have a function that creates a new coroutine that reads those results:</p>&#13;
			<p class="source-code">fun CoroutineScope.doWork(</p>&#13;
			<p class="source-code">    id: Int,</p>&#13;
			<p class="source-code">    channel: ReceiveChannel&lt;String&gt;</p>&#13;
			<p class="source-code">) = launch(Dispatchers.Default) {</p>&#13;
			<p class="source-code">    for (p in channel) {</p>&#13;
			<p class="source-code">        println("Worker $id processed $p")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This function will generate a coroutine that is executed on the <strong class="source-inline">Default</strong> dispatcher. Each coroutine will listen to a channel and print every message it receives to the console.</p>&#13;
			<p>Now, let's start<a id="_idIndexMarker585"/> our producer. Remember that all the following pieces of code need to be wrapped in the <strong class="source-inline">runBlocking</strong> function, but for simplicity, we omitted that part:</p>&#13;
			<p class="source-code">val workChannel = generateWork()</p>&#13;
			<p>Then, we can create multiple workers that distribute the work between themselves by reading from the same channel:</p>&#13;
			<p class="source-code">val workers = List(10) { id -&gt;</p>&#13;
			<p class="source-code">    doWork(id, workChannel)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Let's now examine a part of the output of this program:</p>&#13;
			<p class="source-code">&gt; ...</p>&#13;
			<p class="source-code">&gt; Worker 4 processed page9994</p>&#13;
			<p class="source-code">&gt; Worker 8 processed page9993</p>&#13;
			<p class="source-code">&gt; Worker 3 processed page9992</p>&#13;
			<p class="source-code">&gt; Worker 6 processed page9987</p>&#13;
			<p>Note that no two workers receive the same message and the messages are not being printed in the order they were sent. The Fan Out design pattern allows us to efficiently distribute the work across a number of coroutines, threads, and CPUs.</p>&#13;
			<p>Next, let's discuss <a id="_idIndexMarker586"/>an accompanying design pattern that often goes hand-in-hand with Fan Out.</p>&#13;
			<h1 id="_idParaDest-202"><a id="_idTextAnchor208"/>Fan In</h1>&#13;
			<p>The goal of <a id="_idIndexMarker587"/>the <strong class="bold">Fan In</strong> design pattern is to combine results from multiple workers. This design pattern is helpful when our workers produce results and we need to gather them.</p>&#13;
			<p>This design pattern is the opposite of the Fan Out design pattern we discussed in the previous section. Instead of multiple coroutines <em class="italic">reading</em> from the same channel, multiple coroutines can <em class="italic">write</em> their results to the same channel.</p>&#13;
			<p>Combining the Fan Out and Fan In design patterns is a good base for <strong class="bold">MapReduce</strong> algorithms. To demonstrate this, we'll slightly change the workers from the previous example, as follows:</p>&#13;
			<p class="source-code">private fun CoroutineScope.doWorkAsync(</p>&#13;
			<p class="source-code">    channel: ReceiveChannel&lt;String&gt;,</p>&#13;
			<p class="source-code">    resultChannel: Channel&lt;String&gt;</p>&#13;
			<p class="source-code">) = async(Dispatchers.Default) {</p>&#13;
			<p class="source-code">    for (p in channel) {</p>&#13;
			<p class="source-code">        resultChannel.send(p.repeat(2))</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, once done, each worker sends the results of its calculation to <strong class="source-inline">resultChannel</strong>.</p>&#13;
			<p>Note that this pattern is different from the actor and producer builders we've seen before. Actors each have their own channels, while in this case, <strong class="source-inline">resultChannel</strong> is shared across all the workers.</p>&#13;
			<p>To collect the results from the workers, we'll use the following code:</p>&#13;
			<p class="source-code">runBlocking {</p>&#13;
			<p class="source-code">    val workChannel = generateWork()</p>&#13;
			<p class="source-code">    val resultChannel = Channel&lt;String&gt;()</p>&#13;
			<p class="source-code">    val workers = List(10) {</p>&#13;
			<p class="source-code">        doWorkAsync(workChannel, resultChannel)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    resultChannel.consumeEach {</p>&#13;
			<p class="source-code">        println(it)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Let's now <a id="_idIndexMarker588"/>clarify what this code does:</p>&#13;
			<ol>&#13;
				<li>First, we create <strong class="source-inline">resultChannel</strong>, which all our workers will share.</li>&#13;
				<li>Then, we supply it to each worker. We have ten workers in total. Each worker repeats the message it received twice and sends it on <strong class="source-inline">resultChannel</strong>.</li>&#13;
				<li>Finally, we consume the results from the channel in our main coroutine. This way, we accumulate results from multiple concurrent workers in the same place.</li>&#13;
			</ol>&#13;
			<p>Here's a sample of the output from the preceding code:</p>&#13;
			<p class="source-code">&gt; ...</p>&#13;
			<p class="source-code">&gt; page9995page9995</p>&#13;
			<p class="source-code">&gt; page9996page9996</p>&#13;
			<p class="source-code">&gt; page9997page9997</p>&#13;
			<p class="source-code">&gt; page9999page9999</p>&#13;
			<p class="source-code">&gt; page9998page9998</p>&#13;
			<p class="source-code">&gt; page10000page10000</p>&#13;
			<p>Next, let's discuss another design pattern, which will help us improve the responsiveness <a id="_idIndexMarker589"/>of our code in some cases.</p>&#13;
			<h1 id="_idParaDest-203"><a id="_idTextAnchor209"/>Racing</h1>&#13;
			<p><strong class="bold">Racing</strong> is a design pattern<a id="_idIndexMarker590"/> that runs multiple jobs concurrently, picking the result that returns first as the <em class="italic">winner</em> and discarding others as <em class="italic">losers</em>.</p>&#13;
			<p>We can implement Racing in Kotlin using the <strong class="source-inline">select()</strong> function on channels.</p>&#13;
			<p>Let's imagine you are building a weather application. For redundancy, you fetch the weather from two different sources, <em class="italic">Precise Weather</em> and <em class="italic">Weather Today</em>. We'll describe them as two producers that return their name and temperature.</p>&#13;
			<p>If we have more than one producer, we can subscribe to their channels and take the first result that is available.</p>&#13;
			<p>First, let's declare the two weather producers:</p>&#13;
			<p class="source-code">fun CoroutineScope.preciseWeather() = produce {</p>&#13;
			<p class="source-code">    delay(Random.nextLong(100))</p>&#13;
			<p class="source-code">    send("Precise Weather" to "+25c")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">fun CoroutineScope.weatherToday() = produce {</p>&#13;
			<p class="source-code">    delay(Random.nextLong(100))</p>&#13;
			<p class="source-code">    send("Weather Today" to "+24c")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Their logic is pretty much the same. Both wait for a random number of milliseconds and then return a temperature reading and the name of the source. </p>&#13;
			<p>We can listen to both channels simultaneously using the <strong class="source-inline">select</strong> expression:</p>&#13;
			<p class="source-code">runBlocking {</p>&#13;
			<p class="source-code">  val winner = select&lt;Pair&lt;String, String&gt;&gt; {</p>&#13;
			<p class="source-code">    preciseWeather().onReceive { preciseWeatherResult -&gt;</p>&#13;
			<p class="source-code">            preciseWeatherResult</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        weatherToday().onReceive { weatherTodayResult -&gt;</p>&#13;
			<p class="source-code">            weatherTodayResult</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    println(winner)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Using the <strong class="source-inline">onReceive()</strong> function allows us to listen to multiple channels simultaneously.</p>&#13;
			<p>Running this code multiple times will randomly print <strong class="source-inline">(Precise Weather, +25c)</strong><em class="italic"> </em>and <strong class="source-inline">(Weather Today, +24c)</strong>, as there is an equal chance for both of them to arrive first.</p>&#13;
			<p>Racing is a very useful concept when you are willing to sacrifice resources in order to get the most <a id="_idIndexMarker591"/>responsiveness from your system and we achieved that using Kotlin's <strong class="source-inline">select</strong> expression. Now, let's explore the <strong class="source-inline">select</strong> expression a little further to discover another concurrent design pattern that it implements. </p>&#13;
			<h2 id="_idParaDest-204"><a id="_idTextAnchor210"/>Unbiased select</h2>&#13;
			<p>When <a id="_idIndexMarker592"/>using the <strong class="source-inline">select</strong> clause, the order is important. Because it is inherently biased, if two events happen at the same time, it will select the first clause. </p>&#13;
			<p>Let's see what that means in the following example. </p>&#13;
			<p>We'll have only one producer this time, which sends over a channel which movie we should watch next:</p>&#13;
			<p class="source-code">fun CoroutineScope.fastProducer(</p>&#13;
			<p class="source-code">    movieName: String</p>&#13;
			<p class="source-code">) = produce(capacity = 1) {</p>&#13;
			<p class="source-code">    send(movieName)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since we defined a non-zero capacity on the channel, the value will be available as soon as this coroutine runs. </p>&#13;
			<p>Now, let's start the two producers and use a <strong class="source-inline">select</strong> expression to see which of the two movies<a id="_idIndexMarker593"/> will be selected:</p>&#13;
			<p class="source-code">runBlocking {</p>&#13;
			<p class="source-code">    val firstOption = fastProducer("Quick&amp;Angry 7")</p>&#13;
			<p class="source-code">    val secondOption = fastProducer(</p>&#13;
			<p class="source-code">      "Revengers: Penultimatum")</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    delay(10)</p>&#13;
			<p class="source-code">    val movieToWatch = select&lt;String&gt; {</p>&#13;
			<p class="source-code">        firstOption.onReceive { it }</p>&#13;
			<p class="source-code">        secondOption.onReceive { it }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    println(movieToWatch)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>No matter how many times you run this code, the winner will always be the same: <strong class="source-inline">Quick&amp;Angry 7</strong>. This is because if both values are ready at the same time, the <strong class="source-inline">select</strong> clause will always pick the first channel available in the order they are declared.</p>&#13;
			<p>Now, let's use <strong class="source-inline">selectUnbiased</strong> instead of the <strong class="source-inline">select</strong> clause:</p>&#13;
			<p class="source-code">...</p>&#13;
			<p class="source-code">val movieToWatch = <strong class="bold">selectUnbiased</strong>&lt;String&gt; {</p>&#13;
			<p class="source-code">    firstOption.onReceive { it }</p>&#13;
			<p class="source-code">    secondOption.onReceive { it }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">...</p>&#13;
			<p>Running this code now will sometimes produce <strong class="source-inline">Quick&amp;Angry 7</strong> and sometimes produce <strong class="source-inline">Revengers: Penultimatum</strong>. Unlike the regular <strong class="source-inline">select</strong> clause, <strong class="source-inline">selectUnbiased</strong> doesn't care about the order. If more than one result is available, it will pick<a id="_idIndexMarker594"/> one randomly.</p>&#13;
			<h1 id="_idParaDest-205"><a id="_idTextAnchor211"/>Mutex</h1>&#13;
			<p>Also<a id="_idIndexMarker595"/> known as <strong class="bold">mutual exclusions</strong>, <strong class="bold">mutex</strong> provides a means to protect a shared state that can be accessed by multiple coroutines at once. </p>&#13;
			<p>Let's start with the same old dreaded <strong class="source-inline">counter</strong> example, where multiple concurrent tasks try to update the same <strong class="source-inline">counter</strong>:</p>&#13;
			<p class="source-code">var counter = 0</p>&#13;
			<p class="source-code">val jobs = List(10) {</p>&#13;
			<p class="source-code">    async(Dispatchers.Default) {</p>&#13;
			<p class="source-code">        repeat(1000) {</p>&#13;
			<p class="source-code">            counter++</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">jobs.awaitAll()</p>&#13;
			<p class="source-code">println(counter)</p>&#13;
			<p>As you've probably guessed, the result that is printed is less than 10,000 – <em class="italic">totally embarrassing!</em></p>&#13;
			<p>To solve this, we can introduce a locking mechanism that will allow only a single coroutine to interact with the variable at once, making the operation <em class="italic">atomic</em>.</p>&#13;
			<p>Each coroutine will try to obtain the ownership of the <strong class="source-inline">counter</strong>. If another coroutine is updating the <strong class="source-inline">counter</strong>, our coroutine will wait patiently and then try to acquire the lock again. Once updated, it must release the lock so that other coroutines can proceed:</p>&#13;
			<p class="source-code">var counter = 0</p>&#13;
			<p class="source-code">val mutex = Mutex()</p>&#13;
			<p class="source-code">val jobs = List(10) {</p>&#13;
			<p class="source-code">    launch {</p>&#13;
			<p class="source-code">        repeat(1000) {</p>&#13;
			<p class="source-code">            mutex.lock()</p>&#13;
			<p class="source-code">            counter++</p>&#13;
			<p class="source-code">            mutex.unlock()</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, our <a id="_idIndexMarker596"/>example always prints the correct number: <strong class="source-inline">10,000</strong>.</p>&#13;
			<p>Mutex in Kotlin is different from the Java mutex. In Java, <strong class="source-inline">lock()</strong> on a mutex blocks the thread, until the lock can be acquired. A Kotlin mutex suspends the coroutine instead, providing better concurrency. Locks in Kotlin are cheaper. </p>&#13;
			<p>This is good for simple cases. But what if the code within the critical section, that is, between <strong class="source-inline">lock()</strong> and <strong class="source-inline">unlock()</strong>, throws an exception?</p>&#13;
			<p>We would have to wrap our code in <strong class="source-inline">try...catch</strong>, which is not very convenient:</p>&#13;
			<p class="source-code">try { </p>&#13;
			<p class="source-code">    mutex.lock() </p>&#13;
			<p class="source-code">    counter++                      </p>&#13;
			<p class="source-code">} </p>&#13;
			<p class="source-code">finally { </p>&#13;
			<p class="source-code">    mutex.unlock()                     </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>However, if we omit the <strong class="source-inline">finally</strong> block, our lock will never be released and it will block all other coroutines from proceeding and creating a deadlock. </p>&#13;
			<p>Exactly for this purpose, Kotlin also introduces <strong class="source-inline">withLock()</strong>:</p>&#13;
			<p class="source-code">mutex.withLock {</p>&#13;
			<p class="source-code">    counter++</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Notice how <a id="_idIndexMarker597"/>much more concise this syntax is compared with the previous example. </p>&#13;
			<h1 id="_idParaDest-206"><a id="_idTextAnchor212"/>Sidekick channel</h1>&#13;
			<p>The <strong class="bold">Sidekick channel</strong> design <a id="_idIndexMarker598"/>pattern allows us to offload some work from our main worker to a <em class="italic">back worker</em>.</p>&#13;
			<p>Up until now, we've only discussed the use of <strong class="source-inline">select</strong> as a <em class="italic">receiver</em>. But we can also use <strong class="source-inline">select</strong> to <em class="italic">send</em> items to another channel. Let's look at the following example. </p>&#13;
			<p>First, we'll declare <strong class="source-inline">batman</strong> as an actor coroutine that processes 10 messages per second:</p>&#13;
			<p class="source-code">val batman = actor&lt;String&gt; {</p>&#13;
			<p class="source-code">    for (c in channel) {</p>&#13;
			<p class="source-code">        println("Batman is beating some sense into $c")</p>&#13;
			<p class="source-code">        delay(100)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Next, we'll declare <strong class="source-inline">robin</strong> as another actor coroutine that is a bit slower and processes only four messages per second:</p>&#13;
			<p class="source-code">val robin = actor&lt;String&gt; {</p>&#13;
			<p class="source-code">    for (c in channel) {</p>&#13;
			<p class="source-code">        println("Robin is beating some sense into $c")</p>&#13;
			<p class="source-code">        delay(250)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>So, we have a superhero and his sidekick as two actors. Since the superhero is more experienced, it usually takes him less time to beat the villain he's facing. </p>&#13;
			<p>But in some cases, he still has his hands full, so a sidekick needs to step in. We'll throw five villains at <a id="_idIndexMarker599"/>the pair with a few delays and see how they fare:</p>&#13;
			<p class="source-code">val epicFight = launch {</p>&#13;
			<p class="source-code">    for (villain in listOf("Jocker", "Bane", "Penguin",       "Riddler", "Killer Croc")) {</p>&#13;
			<p class="source-code">        val result = select&lt;Pair&lt;String, String&gt;&gt; {</p>&#13;
			<p class="source-code">            batman.onSend(villain) {</p>&#13;
			<p class="source-code">                "Batman" to villain</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">            robin.onSend(villain) {</p>&#13;
			<p class="source-code">                "Robin" to villain</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        delay(90)</p>&#13;
			<p class="source-code">        println(result)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Notice that the type of parameter for <strong class="source-inline">select</strong> refers to what is <em class="italic">returned</em> from the block and not what is being <em class="italic">sent</em> to the channels. That's the reason we use <strong class="source-inline">Pair&lt;String, String&gt;</strong> here.</p>&#13;
			<p>This code prints the following:</p>&#13;
			<p class="source-code">&gt; Batman is beating some sense into Jocker</p>&#13;
			<p class="source-code">&gt; (Batman, Jocker)</p>&#13;
			<p class="source-code">&gt; Robin is beating some sense into Bane</p>&#13;
			<p class="source-code">&gt; (Robin, Bane)</p>&#13;
			<p class="source-code">&gt; Batman is beating some sense into Penguin</p>&#13;
			<p class="source-code">&gt; (Batman, Penguin)</p>&#13;
			<p class="source-code">&gt; Batman is beating some sense into Riddler</p>&#13;
			<p class="source-code">&gt; (Batman, Riddler)</p>&#13;
			<p class="source-code">&gt; Robin is beating some sense into Killer Croc</p>&#13;
			<p class="source-code">&gt; (Robin, Killer Croc)</p>&#13;
			<p>Using a <a id="_idIndexMarker600"/>sidekick channel is a useful technique to provide fallback values. Consider using one in cases when you need to consume a consistent stream of data and cannot easily scale your consumers. </p>&#13;
			<h1 id="_idParaDest-207"><a id="_idTextAnchor213"/>Summary</h1>&#13;
			<p>In this chapter, we covered various design patterns related to <em class="italic">concurrency</em> in Kotlin. Most of them are based on coroutines, channels, deferred values, or a combination of these building blocks. </p>&#13;
			<p>Deferred values are used as placeholders for asynchronous values. The Barrier design pattern allows multiple asynchronous tasks to rendezvous before proceeding further. The Scheduler design pattern decouples the code of tasks from the way they are executed at runtime. </p>&#13;
			<p>The Pipeline, Fan In, and Fan Out design patterns help us distribute the work and collect the results. Mutex helps us to control the number of tasks that are being executed at the same time. The Racing design pattern allows us to improve the responsiveness of our application. Finally, the Sidekick Channel design pattern offloads work onto a backup task in case the main task is not able to process the incoming events quickly enough. </p>&#13;
			<p>All of these patterns should help you to manage the concurrency of your application in an efficient and extensible manner. In the next chapter, we'll discuss Kotlin's idioms and best practices, as well as some of the anti-patterns that emerged with the language.</p>&#13;
			<h1 id="_idParaDest-208"><a id="_idTextAnchor214"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What does it mean when we say that the <strong class="source-inline">select</strong> expression in Kotlin is <em class="italic">biased</em>?</li>&#13;
				<li>When should you use a <em class="italic">mutex</em> instead of a <em class="italic">channel</em>?</li>&#13;
				<li>Which of the concurrent design patterns could help you implement a MapReduce or divide-and-conquer algorithm efficiently?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>