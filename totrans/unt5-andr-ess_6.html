<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Optimization and Transformation Techniques</h1></div></div></div><p>This chapter will introduce you to the usage of <strong>occlusion culling</strong> (<strong>OC</strong>)<a id="id299" class="indexterm"/> and level of detail in optimization techniques. Also, you will learn to optimize Unity C# and Unity JS code. Finally, you will see how to transform Unity C# code to Unity JavaScript code and vice versa.</p><p>The topics that will be covered in the chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Occlusion culling and level of detail in optimization techniques</li><li class="listitem" style="list-style-type: disc">Unity C# and Unity JS optimization tips and tricks</li><li class="listitem" style="list-style-type: disc">Transforming Unity C# code to Unity JavaScript code and vice versa</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Occlusion culling and level of detail in optimization techniques</h1></div></div></div><p>Let's look more closely and carefully at the basic principles of occlusion culling<a id="id300" class="indexterm"/> in Unity (only Pro license) and how to use them in your projects to achieve excellent performance. </p><p>You can open the occlusion culling editor from the Unity menu as shown in the following screenshot:</p><div><img src="img/9191OT_06_01.jpg" alt="Occlusion culling and level of detail in optimization techniques"/></div><p>The main aim of the occlusion culling<a id="id301" class="indexterm"/> mechanism is sifting and filtering off objects that are not visible in the camera area in order to improve optimization. This primarily means that the objects will not be using resources, only when necessary, with the result that of helping you create a game or app that will work much faster.</p><p>Frustum culling<a id="id302" class="indexterm"/> is different from occlusion culling because it disables the renderers that are outside the view of the camera, but does not disable the renderers that overlap other renderers; for example, if a wall hides an object, it will be invisible for the camera. Using occlusion culling, you can automatically take the advantage of frustum culling. With the usage of visual occlusion culling technique, we can see in two examples as shown in the following screenshots:</p><div><img src="img/9191OT_06_02.jpg" alt="Occlusion culling and level of detail in optimization techniques"/></div><p>In the screenshot shown here, you can see <a id="id303" class="indexterm"/>occlusion culling in action:</p><div><img src="img/9191OT_06_03.jpg" alt="Occlusion culling and level of detail in optimization techniques"/></div><p>The occlusion culling process in Unity uses a virtual camera that will scan the entire scene and create a hierarchy of potentially visible sets of objects. Then, this information will be used by other cameras in your game or in your application in real time, in order to reduce the number of draw calls and to improve your performance.</p><p>In order to use <a id="id304" class="indexterm"/>occlusion culling, you need to set the <strong>Occluder Static</strong> tag for each object in the scene to be processed by this optimization mechanism. Also, you can use another object's tag, which is called <strong>Occludee Static</strong> as shown in the next screenshot. Occludees may be obscured by other objects and will be disabled in a similar situation to improve performance, but these objects cannot overlap other objects. Therefore, they will increase the performance of your entire project.</p><div><img src="img/9191OT_06_04.jpg" alt="Occlusion culling and level of detail in optimization techniques"/></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>It is also very important to create areas for occlusion culling, only where the camera will render objects.</p></div></div><p>We just opened the basic and key aspects of the optimization by occlusion culling approach. We cannot describe all the details of the settings and features in this chapter. The following sections describe the various ideas, methods, approaches, and ways to optimize and improve performance. The purpose of the next section is to direct you on the right path to improve performance. You will use the desired optimization techniques from this chapter, and if it is necessary, you can find more detailed information about methods, implementations, and customizations from the web. Let's now consider another optimization technique known as<a id="id305" class="indexterm"/> <strong>Level Of Detail</strong> (<strong>LOD</strong>).</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Optimizing by LOD</h2></div></div></div><p>The LOD optimization technique is a method of reducing the complexity of frame rendering by reducing the total number of polygons, textures, and other resources in the scene, the general decline in its complexity. A simple example is that the main character model consists of 10,000 polygons. In cases where the treated stage is located close to the camera, it is important to use all the polygons. However, at a great distance from the camera, in the final image, it will take only a few pixels; there is no sense in handling all 10,000 polygons. Perhaps, in this case, it would be enough for hundreds of polygons, or even a couple of pieces and textures, specially prepared for about the same display model. Accordingly, at intermediate distances, it makes sense to use a model consisting of a number of triangles greater than the simplest model and smaller than the most complex.</p><p>The LOD<a id="id306" class="indexterm"/> method is commonly used for modeling and rendering three-dimensional scenes using multiple difficulty levels (geometric or some other) for the objects in proportion to their distance from the camera. Changing complexity, particularly in the number of triangles in the model may be performed automatically, is based on a three-dimensional model of highest complexity, but can be on the basis of several predefined patterns with different levels of detail. Using a model with less detail for different distances, you will reduce rendering design complexity, almost without compromising the overall image detail.</p><p>The method is particularly effective when the number of objects in the scene is large, and they are located at different distances from the camera. For example, consider a sports game, such as football game or a hockey simulator. Low-poly character models are used when they are away from the camera, but when it approaches, the models are replaced by a large number of polygons. This example is very simple, and it shows that the essence of the method is based on two levels of detail of the model, but no one bothers to create multiple levels of detail. In order to effect change, the LOD level was not too obvious, so the object detail gradually grows.</p><p>Consider the following factors that have an effect on the level of detail technique: the total number of objects on the screen (when one or two characters in the frame, use complex models, and when 10–20, they are switched to a simpler model) or the FPS (predetermined limited values of the FPS, which varies with the level of detail, such as FPS below 30 reduces the complexity of the models on the screen, while 60 FPS raises the complexity). Other possible factors that affect the level of detail are as follows: the speed of movement of the object (in case of a rocket in motion you see it moving fast, but a snail moves slowly), the importance of a character from the game's point of view (for example, in football, the player models you see the closest and most often uses more complex geometry and texture). It all depends on the desires and capabilities of a particular developer. The main thing is to not overdo it; frequent and noticeable changes in the level of detail will be annoying.</p><p>We want to remind you that the level of detail does not necessarily refer only to the geometry. The method can also be used to save other resources: texturing (although GPUs use mipmapping, sometimes it makes sense to change the texture on the fly on the other with some detail), lighting technician (close objects covered by a complex algorithm, and distant objects covered by a prime), and texturing techniques.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Unity C# and Unity JS optimization tips and tricks</h1></div></div></div><p>To begin, we will consider <a id="id307" class="indexterm"/>some aspects of optimization concerning the<a id="id308" class="indexterm"/> JavaScript programming language. Try to avoid the use of dynamic typing in JavaScript. The best solution for your performance is undoubtedly static typing. The use of dynamic typing of variables will be consumed while executing a code to find the appropriate data type for a particular variable, which in principle could and should be avoided by specifying the data types for all your variables. Bad and good examples are shown here:</p><div><pre class="programlisting">// Dynamic Typing, BAD FOR YOUR PERFORMANCE
var yourVariableName = 23;

// Static Typing, GOOD FOR YOUR PERFORMANCE
var myGo : GameObject = null;</pre></div><p>The following example shows what you should not do if you want to improve your performance. This example uses dynamic typing for our variable, <code class="literal">yourVariableName</code>, which in turn affects the performance of the whole system in the negative sense. Before calling any function of this object, there will be time spent searching for the right object type and checking if the called function is accessible. The bad example is shown here:</p><div><pre class="programlisting">function Start() {
  var yourVariableName = GetComponent(YourScriptName);
  yourVariableName.YourFunctionName();
}</pre></div><p>Instead of wasting CPU time on unnecessary expenses, you should always use static typing for all your variables in order to improve performance:</p><div><pre class="programlisting">function Start() {
  var yourVariableName : YourScriptName = GetComponent(YourScriptName);
  yourVariableName.YourFunctionName();
}</pre></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>
<strong>Use Static Typing instead of Dynamic Typing wherever possible</strong>
</p><p>You can use <code class="literal">#pragma</code> strict preprocessor directive in order to help you not to forget about using static typing instead of dynamic typing everywhere in your JavaScript script. You should write this directive at the top of your script before any code. In the event of utilizing <code class="literal">#pragma</code> strict and dynamic typing in your script, the compiler will throw errors. Therefore, this preprocessor directive forces you to use static typing only.</p></div></div><p>We also want to mention the other techniques to optimize your code. One of them is the technique of caching components or variables. During optimization, you first need to turn your attention to the functions that are very often performed in your code, especially callbacks such as <code class="literal">Update</code> and <code class="literal">FixedUpdate</code> and similar functions that are called in every frame, or almost each frame, or in other words, many times per second. Therefore, reference to any component or variable in such risky functions depends on the situation. Of course, there are situations for the overall system performance, where such things are not so bad for your performance in general, and there are situations where performance drops almost to zero because of the many unnecessary expenses. In such functions, it is best not to call the Unity method <code class="literal">GetComponent</code> each time, which will very often look for a component or other similar functions of the Unity library to find objects and so on. Instead, you can call the function<a id="id309" class="indexterm"/> you want, when it is necessary to obtain a <a id="id310" class="indexterm"/>desired component or desired object(s) and store them in local variables or arrays, as you like. The following examples <a id="id311" class="indexterm"/>demonstrate this:</p><div><pre class="programlisting">// BAD for your performance
void Update() {
  transform.position = new Vector3(0.0f, 1.0f, -1.0f);
}

// Second example:
// GOOD for your performance
private Transform _t;
void Start() {
  _t = transform;
}

void Update() {
  _t.position = new Vector3(0.0f, 1.0f, -1.0f);
}</pre></div><p>The code shown in the second example is much faster then the respective code in the first example, because Unity will not look up the transform component each <code class="literal">Update</code> cycle or in other words each frame.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>You should call a function only if necessary, not more and not less, just exactly when needed.</p></div></div><p>The best optimization for your code and generally for the whole system is when the code is as small as possible, or rather when nothing unnecessary is executed at all. Unnecessary calculations lead to unnecessary overhead; for mobile devices, in general, this question is one of the most acute. A good example of a small optimization is shown in the following example, but this example is not the best solution for your performance. After each frame, checking the distance between the two points will take away your precious time:</p><div><pre class="programlisting">private Transform yourTransform:
void Update() {
  if (Vector3.Distance(yourTransform.position, transform.position) &gt; 200) {
    return;
  }
  // your next code may be here ...
}</pre></div><p>To not waste time on <a id="id312" class="indexterm"/>unnecessary mistakes, you should use <a id="id313" class="indexterm"/>the <code class="literal">OnBecameInvisible</code> and <code class="literal">OnBecameVisible</code> callbacks. With these callbacks, Unity calls in an event in which none of the cameras can see (for <code class="literal">OnBecameInvisible</code>) or at least one camera sees (for <code class="literal">OnBecameVisible</code>) your renderer. Certainly, these callbacks are only good in certain situations and not in others. For example, if your object does not contain a renderer component, then you will need to invent a way to enable or disable the execution of your code accordingly. A simple example of these two callbacks is shown here:</p><div><pre class="programlisting">void OnBecameVisible() {
  enabled = true;
}

void OnBecameInvisible() {
  enabled = false;
}</pre></div><p>To achieve the performance that you need, you will need to take care of many details in your code and many other details that are discussed in this book. Code optimization in most cases impedes readability and therefore impedes understanding of the code. Keep this in mind, or at least do not forget about it. Like everything else in life, we need to find a middle ground or, in other words, the golden balance between quality and performance.</p><p>Let's see how static functions behave and how much time we need for them, since the use of these functions significantly reduces the time of the function call as compared to call a non-static function. If we examine the question of what happens with static functions when you compile your code, it is, however, no secret that all the code is translated into machine code or assembler as it is called, which is the lowest programming level. If we consider the very assembly instructions to call static functions, we see that it requires fewer machine instructions and consequently less CPU time than calling a nonstatic function.</p><p>In the call, each function with parameters passed by value requires memory duplication. As discussed earlier in text, this may impair your performance. Therefore, it is better to call a function with parameters passed by reference rather than by value. It is easy to bypass this problem. The best thing for enhancing your performance is to use local variables of a class or object that is used in the function. You can create a set of variables within a function, which in turn will significantly increase the consumption of memory and CPU time of the function call with a lot of variables. The function must be remembered in the stack for further opportunities to work with these variables. Even if these variables are not used in the function, they are still in the stack and they will occupy memory space.</p><p>The following discussion focuses on the constants. Constants do not require RAM allocation, since their values are directly sewed in the instruction stream. Using constants instead of creating a large number of local or global variables can significantly accelerate the performance of your software, avoiding the overhead of memory and CPU time.</p><p>Static <a id="id314" class="indexterm"/>variables (variables of a class) as well as static <a id="id315" class="indexterm"/>functions (methods of a class) require less CPU time, since static variables belong to the whole class, rather than to an object of this class. The time spent on searching for supplies is declining, which has obvious advantages in optimization. For variables or functions of any object machine, instructions will be executed to locate the appropriate object to which they belong, which obviously require the overhead of CPU time and memory.</p><p>The <code class="literal">if</code> and <code class="literal">switch</code> statements can be easily changed for each other; for example, to increase the understanding and readability of the code or to optimize all the same code. If you look at the postcompilation machine instructions and directions through any disassembler, you can see the difference between these two expressions. The <code class="literal">switch</code> statement<strong>,</strong> for example, after compiling becomes a<strong> </strong>go-to mechanism, which in turn makes jumping through machine instructions in its transition table. It needs to find the desired transition in the first place, and then those going to the command assembly. If construction behaves low bit differently, it turns normal branching as in high-level programming language; for example, in our case, the C# language. In some cases, some <code class="literal">switch</code> design may be executed faster than the same <code class="literal">if</code>/<code class="literal">else if</code>/<code class="literal">else</code> design. Performance of these two structures solely depends on their correct application or in other words the correct use. For example, let's consider two simple cases, where in the first case will be quicker and faster <code class="literal">switch</code>, and in the second situation the <code class="literal">if</code> design is better for performance than a <code class="literal">switch</code> solution, as shown in the following code example:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class IfSwitchTestFirstCase : MonoBehaviour {
  public const int CYCLES_COUNTER = 100000000;

  bool IfTest(int yourIntegerExample)
  {
    if (yourIntegerExample == 0 || yourIntegerExample == 1) {
      return true;
    }

    if (yourIntegerExample == 2 || yourIntegerExample == 3) {
      return false;
    }

    if (yourIntegerExample == 4 || yourIntegerExample == 5) {
      return true;
    }

    return false;
  }
  
  bool SwitchTest(int yourIntegerExample)
  {
    switch (yourIntegerExample)
    {
      case 0:
      case 1:
        return true;

      case 2:
      case 3:
        return false;

      case 4:
      case 5:
        return true;

      default:
        return false;
    }
  }

  void Start() {
    Stopwatch ifTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES_COUNTER; i++)
    {
      IfTest(i);
    }
    ifTimer.Stop();

    Stopwatch switchTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES_COUNTER; i++)
    {
      SwitchTest(i);
    }
    switchTimer.Stop();

    UnityEngine.Debug.Log(
      "IF time = " +
      (
(double)(ifTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES_COUNTER
      ).ToString("0.00 nanoseconds average per cycle")
    );

    UnityEngine.Debug.Log(
      "Switch time = " +
      (
(double)(switchTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES_COUNTER
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel Core i5 2.7 GHz, after testing the first example in the Unity editor the results were:</p><div><pre class="programlisting">IF time = 11.54 nanoseconds average per cycle
Switch time = 8.76 nanoseconds average per cycle</pre></div><p>Based on the preceding<a id="id316" class="indexterm"/> results, we can say that the design of <code class="literal">switch</code> affects<a id="id317" class="indexterm"/> your performance better, but it is not always true. Let's now consider the second case, where the <code class="literal">if</code> construction turns out to be the best design solution for your optimization, as shown in code example here:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class IfSwitchTestSecondCase : MonoBehaviour {
  public const int CYCLES_COUNTER = 100000000;

  int SwitchTest(int yourIntegerExample)
  {
    switch (yourIntegerExample)
    {
      case 0:
      {
        return 11;
      }

      case 1:
      {
        return 22;
      }

      default:
      {
        return -11;
      }
    }
  }
  
  int IfTest(int yourIntegerExample)
  {
    if (0 == yourIntegerExample)
    {
      return 11;
    }

    if (1 == yourIntegerExample)
    {
      return 22;
    }

    return -11;
  }
  
  void Start() {
    Stopwatch switchTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES_COUNTER; i++)
    {
      SwitchTest(0);
      SwitchTest(0);
      SwitchTest(0);
      SwitchTest(0);
      SwitchTest(0);
      SwitchTest(0);
      SwitchTest(1);
      SwitchTest(1);
      SwitchTest(1);
      SwitchTest(1);
    }
    switchTimer.Stop();

    Stopwatch ifTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES_COUNTER; i++)
    {
      IfTest(0);
      IfTest(0);
      IfTest(0);
      IfTest(0);
      IfTest(0);
      IfTest(0);
      IfTest(1);
      IfTest(1);
      IfTest(1);
      IfTest(1);
    }
    ifTimer.Stop();
    
    UnityEngine.Debug.Log(
      "IF time = " +
      (
(double)(ifTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES_COUNTER
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Switch time = " +
      (
(double)(switchTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES_COUNTER
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On a Mac OS X, Intel Core i5 2.7 GHz, after testing the second example in the Unity editor, the results were:</p><div><pre class="programlisting">IF time = 54.46 nanoseconds average per cycle
Switch time = 64.24 nanoseconds average per cycle</pre></div><p>Since different<a id="id318" class="indexterm"/> situations require different designs, the most important <a id="id319" class="indexterm"/>thing is for you to understand the true meaning of what is happening in the construction machine after compiling your code. Then, it will be much easier to make the right choices to improve and enhance your performance. In both examples, discussed earlier, we saw that in different situations the <code class="literal">if</code> and <code class="literal">switch</code> designs, which at first sight are absolutely equivalent, may differ in speed and efficiency with respect to performance. We also saw that different situations give a performance advantage with different designs, although they have the same semantics, or in other words, the same algorithm designed in different forms. However, the meaning does not change when dealing with any problems, except for the time of execution, as we have already considered earlier.</p><p>The following<a id="id320" class="indexterm"/> two-dimensional arrays can be used in the form of <a id="id321" class="indexterm"/>one-dimensional arrays, and this will increase your performance. For example, we have a two-dimensional array with <strong>N</strong> rows and <strong>M</strong> of columns: the table size is N × M:</p><div><pre class="programlisting">// [i, j] from float 2D array (table)
// 0 ≤ i ≤ N - 1
// 0 ≤ j ≤ M - 1
float2Darray[i, j] = 123.321f;</pre></div><p>In the case of optimization of the two-dimensional array by switching it to the one-dimensional array, we can refer to an element (i, j) of our table with the size N × M as follows:</p><div><pre class="programlisting">// [i, j] from float 1D array
// 0 ≤ i ≤ N - 1
// 0 ≤ j ≤ M - 1
float1Darray[(i * M) + j] = 123.321f;</pre></div><p>Here is a complete sample code in Unity C# as shown in the following code example:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class Array2Dvs1D : MonoBehaviour {
  public const int N = 1000, M = 1500;

  float[,] float2Darray;
  float[] float1Darray;
  
  void Start() {
    float2Darray = new float[N, M];
    float1Darray = new float[N * M];

    Stopwatch array2DTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; N; i++)
    {
      for (int j = 0; j &lt; M; j++)
      {
        // [i, j] from float 2D array
        // 0 ≤ i ≤ N - 1
        // 0 ≤ j ≤ M - 1
        float2Darray[i, j] = 123.321f;
      }
    }
    array2DTimer.Stop();
    
    Stopwatch array1DTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; N; i++)
    {
      for (int j = 0; j &lt; M; j++)
      {
        // [i, j] from float 1D array
        // 0 ≤ i ≤ N - 1
        // 0 ≤ j ≤ M - 1
        float1Darray[(i * M) + j] = 123.321f;
      }
    }
    array1DTimer.Stop();
    
    UnityEngine.Debug.Log(
      "Array 1D time = " +
      (
(double)(array1DTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / (N * M)
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Array 2D time = " +
      (
(double)(array2DTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / (N * M)
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac<a id="id322" class="indexterm"/> OS X, Intel Core i5 2.7 GHz, after testing this example <a id="id323" class="indexterm"/>in the Unity editor the following results were obtained:</p><div><pre class="programlisting">Array 1D time = 3.24 nanoseconds average per cycle
Array 2D time = 7.87 nanoseconds average per cycle</pre></div><p>As we can see a difference in the implementation of the same ideas, but in different forms as two-dimensional and one-dimensional arrays. Also consider the next simple example code as shown here, which shows a two-level array in comparison with one-dimensional arrays for speed of execution:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class LeveledArray2Dvs1D : MonoBehaviour {
  public const int N = 1000, M = 1500;
  
  float[][] float2Darray;
  float[] float1Darray;
  
  void Start() {
    float2Darray = new float[N][];
    float1Darray = new float[N * M];

    for (int i = 0; i &lt; N; i++)
    {
      float2Darray[i] = new float[M];
    }
    
    Stopwatch array2DTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; N; i++)
    {
      for (int j = 0; j &lt; M; j++)
      {
        // [i][j] from float 2D array
        // 0 ≤ i ≤ N - 1
        // 0 ≤ j ≤ M - 1
        float2Darray[i][j] = 123.321f;
      }
    }
    array2DTimer.Stop();
    
    Stopwatch array1DTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; N; i++)
    {
      for (int j = 0; j &lt; M; j++)
      {
        // [i, j] from float 1D array
        // 0 ≤ i ≤ N - 1
        // 0 ≤ j ≤ M - 1
        float1Darray[(i * M) + j] = 123.321f;
      }
    }
    array1DTimer.Stop();
    
    UnityEngine.Debug.Log(
      "Leveled Array 1D time = " +
      (
(double)(array1DTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / (N * M)
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Leveled Array 2D time = " +
      (
(double)(array2DTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / (N * M)
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity editor the following results were obtained:</p><div><pre class="programlisting">Leveled Array 1D time = 3.23 nanoseconds average per cycle
Leveled Array 2D time = 3.36 nanoseconds average per cycle</pre></div><p>For convenience, you<a id="id324" class="indexterm"/> can use the two-level array if you are satisfied <a id="id325" class="indexterm"/>with its performance. You will need to make the right decision starting from your tasks, not forgetting about the middle ground between the readability of the code and its performance.</p><p>As for strings and character arrays, let's see which among them is faster and more efficient. In the following code example, we represent our test performance between the two variables:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class StringCharArray : MonoBehaviour {
  public const int LENGTH = 1000;

  string str;
  char[] charArray;
  
  void Start() {
    charArray = new char[LENGTH];
    
    Stopwatch charArrayTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      charArray[i] = (i % 10).ToString()[0];
    }
    charArrayTimer.Stop();

    str = string.Empty;
    Stopwatch stringTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      str += (i % 10).ToString();
    }
    stringTimer.Stop();
    
    UnityEngine.Debug.Log(
      "String time = " +
      (
(double)(stringTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Char Array time = " +
      (
(double)(charArrayTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel<a id="id326" class="indexterm"/> Core i5 2.7 GHz, after testing this example in<a id="id327" class="indexterm"/> the Unity editor the following results were obtained:</p><div><pre class="programlisting">String time = 1274.00 nanoseconds average per cycle
Char Array time = 369.00 nanoseconds average per cycle</pre></div><p>The difference is obvious, but readability of this optimization falls down rapidly. As always everything in life needs a strong balance sheet or, in other words, the golden mean. Here is another example, in which we compare the performance of <code class="literal">StringBuilder</code> and character array as shown in the following code example:</p><div><pre class="programlisting">using UnityEngine;
using System.Text;
using System.Diagnostics;

public class StringBuilderCharArray : MonoBehaviour {
  public const int LENGTH = 1000;
  
  StringBuilder str;
  char[] charArray;
  
  void Start() {
    charArray = new char[LENGTH];
    
    Stopwatch charArrayTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      charArray[i] = (i % 10).ToString()[0];
    }
    charArrayTimer.Stop();
    
    str = new StringBuilder();
    Stopwatch stringBuilderTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      str.Append((i % 10).ToString());
    }
    stringBuilderTimer.Stop();
    
    UnityEngine.Debug.Log(
      "String Builder time = " +
      (
(double)(stringBuilderTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Char Array time = " +
      (
(double)(charArrayTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel <a id="id328" class="indexterm"/>Core i5 2.7 GHz, after testing this example in<a id="id329" class="indexterm"/> the Unity editor the following results were obtained:</p><div><pre class="programlisting">String Builder time = 463.00 nanoseconds average per cycle
Char Array time = 370.00 nanoseconds average per cycle</pre></div><p>
<code class="literal">StringBuilder</code> is slightly inferior to the performance of a character array. However, do not forget that for the garbage collector, <code class="literal">StringBuilder</code> is very well optimized and does not create a memory leak with large volumes of data. You have to solve various problems in the course of software development. If every decision will confidently and firmly take any criticism, then success is not far away. You should definitely prioritize your tasks for all to see where you need to go with compromises.</p><p>In the next step, we <a id="id330" class="indexterm"/>will examine and study the performance of<a id="id331" class="indexterm"/> collections in C#. Collection is very useful in certain situations, but you always have to remember that it is a wrapper for ordinary arrays. When using large data, collections can utilize significant costs of processing time, which in turn negatively affects the whole performance of your code. In the following code example, a list collection execution speed is compared with the conventional one-dimensional array:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;
using System.Diagnostics;

public class ListVsArray : MonoBehaviour {
  public const int LENGTH = 1000000;
  
  List&lt;int&gt; intList;
  int[] intArray;

  int tmpInt;
  
  void Start() {
    intList = new List&lt;int&gt;();
    intArray = new int[LENGTH];
    
    Stopwatch intArrayTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      intArray[i] = i;
      tmpInt = intArray[i]++;
    }
    intArrayTimer.Stop();

    Stopwatch listTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      intList.Add(i);
      tmpInt = intList[intList.Count - 1]++;
    }
    listTimer.Stop();
    
    UnityEngine.Debug.Log(
      "Integer List time = " +
      (
(double)(listTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Integer Array time = " +
      (
(double)(intArrayTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel <a id="id332" class="indexterm"/>Core i5 2.7 GHz, after testing this example<a id="id333" class="indexterm"/> in the Unity editor the following results were obtained:</p><div><pre class="programlisting">Integer List time = 36.68 nanoseconds average per cycle
Integer Array time = 5.54 nanoseconds average per cycle</pre></div><p>As can be seen from the results discussed earlier in the text, the list collection is significantly inferior in performance compared to simple one-dimensional arrays. Next, as shown in the following code example, the performance of the <code class="literal">ArrayList</code> class is compared with the same simple one-dimensional array:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Diagnostics;

public class ArrayListVsArray : MonoBehaviour {
  public const int LENGTH = 1000000;
  
  ArrayList intArrayList;
  int[] intArray;
  
  int tmpInt;
  
  void Start() {
    intArrayList = new ArrayList();
    intArray = new int[LENGTH];
    
    Stopwatch intArrayTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      intArray[i] = i;
      tmpInt = intArray[i] + 23;
    }
    intArrayTimer.Stop();
    
    Stopwatch arrayListTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; LENGTH; i++)
    {
      intArrayList.Add(i);
      tmpInt = (int)intArrayList[intArrayList.Count - 1] + 23;
    }
    arrayListTimer.Stop();
    
    UnityEngine.Debug.Log(
      "Integer Array List time = " +
      (
(double)(arrayListTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Integer Array time = " +
      (
(double)(intArrayTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / LENGTH
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel <a id="id334" class="indexterm"/>Core i5 2.7 GHz, after testing this example in<a id="id335" class="indexterm"/> the Unity editor the following results were obtained:</p><div><pre class="programlisting">Integer Array List time = 183.36 nanoseconds average per cycle
Integer Array time = 4.78 nanoseconds average per cycle</pre></div><p>The difference is awesome and more than in the previous example, while using the class <code class="literal">List</code>. Thus, we demonstrated the obvious advantages of a simple one-dimensional array, compared with collections when large amounts of data can greatly ruin your performance. What <a id="id336" class="indexterm"/>cannot be said about the simple one-dimensional <a id="id337" class="indexterm"/>arrays is which of them are the building blocks for a variety of collections. As always, the choice is yours. The most important thing is not to forget the basic axioms in optimization decisions. Let's look at another example with the class <code class="literal">Dictionary</code> as shown in code example here:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;
using System.Diagnostics;

public class DictionaryVsArray : MonoBehaviour {
  public const int CYCLES = 1000000;
  
  Dictionary&lt;int, int&gt; dictionary;
  int[] intArray;
  
  int tmpInt;
  
  void Start() {
    dictionary = new Dictionary&lt;int, int&gt;();
    intArray = new int[CYCLES];
    
    Stopwatch intArrayTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES; i++)
    {
      intArray[i] = i + 117;
      tmpInt = intArray[i] + 23;
    }
    intArrayTimer.Stop();
    
    Stopwatch dictionaryTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES; i++)
    {
      dictionary.Add(i, i + 117);
      tmpInt = (int)dictionary[dictionary.Count - 1] + 23;
    }
    dictionaryTimer.Stop();
    
    UnityEngine.Debug.Log(
      "Integer Dictionary time = " +
      (
(double)(dictionaryTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Integer Array time = " +
      (
(double)(intArrayTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel <a id="id338" class="indexterm"/>Core i5 2.7 GHz, after testing this example<a id="id339" class="indexterm"/> in the Unity editor the following results were obtained:</p><div><pre class="programlisting">Integer Dictionary time = 132.75 nanoseconds average per cycle
Integer Array time = 4.63 nanoseconds average per cycle</pre></div><p>Also, I want to show you the following code example using the <code class="literal">Hashtable</code> collection for our performance testing, as shown in code example here:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Diagnostics;

public class HashtableVsArray : MonoBehaviour {
  public const int CYCLES = 1000000;
  
  Hashtable hashtable;
  int[] intArray;
  
  int tmpInt;
  
  void Start() {
    hashtable = new Hashtable();
    intArray = new int[CYCLES];
    
    Stopwatch intArrayTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES; i++)
    {
      intArray[i] = i + 117;
      tmpInt = intArray[i] + 23;
    }
    intArrayTimer.Stop();
    
    Stopwatch hashtableTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES; i++)
    {
      hashtable.Add(i, i + 117);
      tmpInt = (int)hashtable[hashtable.Count - 1] + 23;
    }
    hashtableTimer.Stop();
    
    UnityEngine.Debug.Log(
      "Integer Hashtable time = " +
      (
(double)(hashtableTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "Integer Array time = " +
      (
(double)(intArrayTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel<a id="id340" class="indexterm"/> Core i5 2.7 GHz, after testing this example<a id="id341" class="indexterm"/> in the Unity editor, the following results were obtained:</p><div><pre class="programlisting">Integer Hashtable time = 539.59 nanoseconds average per cycle
Integer Array time = 4.52 nanoseconds average per cycle</pre></div><p>As you can see, all the collections are significantly inferior to the simple one-dimensional array in performance, but the benefit in many situations is more convenient because of the use of a more readable code. However, you lose a lot of CPU time and memory, and have to sacrifice clarity of code. The rest of the collection and all other constructions you are interested in, you can easily perform your own tests for your system's performance, on the basis of the examples discussed earlier.</p><p>We will not leave without attention on loops that are used very often in code-like branching structure. Loops <code class="literal">for</code>, <code class="literal">while</code>, and <code class="literal">do</code>-<code class="literal">while</code> are the fastest compared to other cycles such as <code class="literal">foreach</code>. Another trick when using loops is that we can deploy loops for fewer passes as shown in code example here:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class LoopsTest : MonoBehaviour {
  public const int CYCLES = 1000000;

  int [] tmpInt;
  int i, _optimizedCycles;
  
  void Start() {
    tmpInt = new int[CYCLES];

    Stopwatch doWhileLoopTimer = Stopwatch.StartNew();
    i = 0;
    do
    {
      // do while loop test
      tmpInt[i] = i + 123;
      i++;
    } while (i &lt; CYCLES);
    doWhileLoopTimer.Stop();

    Stopwatch whileLoopTimer = Stopwatch.StartNew();
    i = 0;
    while (i &lt; CYCLES)
    {
      // while loop test
      tmpInt[i] = i + 123;
      i++;
    }
    whileLoopTimer.Stop();

    Stopwatch forLoopTimer = Stopwatch.StartNew();
    for (i = 0; i &lt; CYCLES; i++)
    {
      // for loop test
      tmpInt[i] = i + 123;
    }
    forLoopTimer.Stop();

    _optimizedCycles = Mathf.CeilToInt(CYCLES / 5);
    Stopwatch optimizedTimer = Stopwatch.StartNew();
    for (i = 0; i &lt; _optimizedCycles; i++)
    {
      // optimized for loop test
      tmpInt[i*5] = i*5 + 123;
      if (CYCLES &gt; i*5+1) tmpInt[i*5+1] = i*5 + 124;
      if (CYCLES &gt; i*5+2) tmpInt[i*5+2] = i*5 + 125;
      if (CYCLES &gt; i*5+3) tmpInt[i*5+3] = i*5 + 126;
      if (CYCLES &gt; i*5+4) tmpInt[i*5+4] = i*5 + 127;
    }
    optimizedTimer.Stop();

    Stopwatch foreachTimer = Stopwatch.StartNew();
    i = tmpInt.Length - 1;
    foreach (int intElement in tmpInt)
    {
      // foreach test
      tmpInt[i] = intElement;
      i--;
    }
    foreachTimer.Stop();

    UnityEngine.Debug.Log(
      "Optimized For loop time = " +
      (
(double)(optimizedTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
    
    UnityEngine.Debug.Log(
      "For loop time = " +
      (
(double)(forLoopTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );

    UnityEngine.Debug.Log(
      "While loop time = " +
      (
(double)(whileLoopTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );

    UnityEngine.Debug.Log(
      "Do While loop time = " +
      (
(double)(doWhileLoopTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );

    UnityEngine.Debug.Log(
      "Foreach time = " +
      (
(double)(foreachTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity editor the following results are obtained:</p><div><pre class="programlisting">Optimized For loop time = 2.89 nanoseconds average per cycle
For loop time = 3.63 nanoseconds average per cycle
While loop time = 3.72 nanoseconds average per cycle
Do While loop time = 3.72 nanoseconds average per cycle
Foreach time = 5.62 nanoseconds average per cycle</pre></div><p>The results speak for <a id="id342" class="indexterm"/>themselves. So, do not forget about optimizing <a id="id343" class="indexterm"/>your loops. The first step is to draw attention to the cycles with a huge number of passes, since they can lower your performance by several orders of magnitude. Before optimizing anything, you need to find the bottlenecks in your code and only then decide which optimization techniques you prefer or require.</p><p>As for the loop <code class="literal">foreach</code>, we recommend that you use this cycle only in exceptional situations. Let's look at a small sample code for each loop, and the next step as it is transformed into a completely different code loop. The next example shows a simple <code class="literal">foreach</code> loop:</p><div><pre class="programlisting">foreach (YourType yt in yourCollection) 
{
  yt.YourAction();
}</pre></div><p>Next, let's look at what happens to a piece of code <strong>foreach</strong> loop. As we can see in the code example here, our cycle turns into a loop while using the enumerator object. The code is given here:</p><div><pre class="programlisting">using (YourType.Enumerator e = this.yourCollection.GetEnumerator()) 
{
  while (e.MoveNext())
  {
    YourType yt = (YourType)e.Current;
    yt.YourAction();
  }
}</pre></div><p>As for the characters, it is better to use a single character than a string consisting of a single character. A symbol is passed by value, and it is necessary and requires only two bytes of memory, while the string with one character requires more than 20 bytes of memory, since the string is passed by reference.</p><p>I would also like to<a id="id344" class="indexterm"/> mention the <code class="literal">ToString</code> function that is best used <a id="id345" class="indexterm"/>only when necessary, otherwise you risk degrading your performance. For example, using this function for characters is not always exact: there is rarely a decision justified. Generally, you should remember one simple and most important axiom of code optimization—with less code executed, less CPU time and memory is used that significantly improves your productivity. Let's look at a simple code example shown here, which covers one of the simplest options for optimizing the transfer of an integer to a string:</p><div><pre class="programlisting">using UnityEngine;
using System.Diagnostics;

public class IntegerToStringTest : MonoBehaviour {
  public const int CYCLES = 1000;

  string str;

  void Start() {
    str = "";
    Stopwatch toStringTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES; i++)
    {
      str += i.ToString();
    }
    toStringTimer.Stop();

    str = "";
    Stopwatch optimizedToStringTimer = Stopwatch.StartNew();
    for (int i = 0; i &lt; CYCLES; i++)
    {
      str += string.Empty + i;
    }
    optimizedToStringTimer.Stop();
    
    UnityEngine.Debug.Log(
      "ToString time = " +
      (
(double)(toStringTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );

    UnityEngine.Debug.Log(
      "Optimized ToString time = " +
      (
(double)(optimizedToStringTimer.Elapsed.TotalMilliseconds * 1000 * 1000) / CYCLES
      ).ToString("0.00 nanoseconds average per cycle")
    );
  }
}</pre></div><p>On Mac OS X, Intel Core i5 2.7 GHz after testing this example in the Unity editor I got the following results:</p><div><pre class="programlisting">ToString time = 18229.00 nanoseconds average per cycle
Optimized ToString time = 13576.00 nanoseconds average per cycle</pre></div><p>Try to build your <a id="id346" class="indexterm"/>own tests for your functions on the basis of<a id="id347" class="indexterm"/> the preceding examples. In optimization, you should often trust your own instincts to find the cause of all ills, but to make the right decisions you need to rely on the results of the tests, that is, just pure mathematics and well-defined numbers.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Transforming Unity C# code into Unity JavaScript code and vice versa</h1></div></div></div><p>The following is an <a id="id348" class="indexterm"/>example of how easy it is to convert your <a id="id349" class="indexterm"/>Unity C# code to Unity JavaScript code and vice versa. You can find on the web a lot of different automatic tools that you can use for free in order get conversation between Unity Scripts done as early as possible. As an example, you can convert Unity JS to Unity C# on this <a class="ulink" href="http://www.m2h.nl/files/js_to_c.php">http://www.m2h.nl/files/js_to_c.php</a>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec62"/>JavaScript variables and types</h2></div></div></div><p>By default, the Unity JS code <a id="id350" class="indexterm"/>variables <a id="id351" class="indexterm"/>are public and visible in Unity Inspector. In order to hide your variables from Unity inspector or from other classes, you should mark all those variables with a <code class="literal">private</code> keyword as shown in the following simple examples:</p><div><pre class="programlisting">// private variables are invisible in Unity Inspector
private var length : float = 2.9;

// visible in Unity Inspector
var title : String = "Title";

// visible in Unity Inspector
var isLoop : boolean = false;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec63"/>C# variables and types</h2></div></div></div><p>Float values in C# must have a <a id="id352" class="indexterm"/>lowercase <strong>f</strong> or an uppercase <strong>F</strong> at the end. Otherwise, it will be<a id="id353" class="indexterm"/> treated as a double value. Also notice that in JS code, the string type should be written with the first letter uppercase. However, in C# code with lowercase letters you can see our simple examples here:</p><div><pre class="programlisting">// public variables are visible in Unity Inspector
public float length = 2.9f;

// is invisible in Unity Inspector
string title = "Title";

// is invisible in Unity Inspector
private bool isLoop = false;</pre></div><p>By default, in Unity C# code, variables are private and invisible in the Unity inspector. In order to show your variables in the Unity inspector, you should mark all these variables with the <code class="literal">public</code> keyword as shown in our previous simple examples.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Converting types in Unity JS</h2></div></div></div><p>You can use the <a id="id354" class="indexterm"/>following <a id="id355" class="indexterm"/>code to convert types in Unity JS:</p><div><pre class="programlisting">var length : float = 0.08; // variable with float type
var number : int = length; // converting float to integer
print(number); // prints "0" in Unity console</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Converting types in Unity C#</h2></div></div></div><p>You can use the following<a id="id356" class="indexterm"/> code to <a id="id357" class="indexterm"/>convert types in Unity C#:</p><div><pre class="programlisting">float length = 0.08f; // variable with float type
int number = (int)length; // converting float to integer
Debug.Log(number); // prints "0" in Unity console</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Unity JS function versus Unity C# function</h2></div></div></div><p>The following code snippet shows the syntax of the code as written in Unity JS and Unity C#</p><div><pre class="programlisting">// Unity JS Function
function YourFunctionName (yourStringVarName : String) {
    print(yourStringVarName);
}

// Unity C# Function
public void YourFunctionName (string yourStringVarName) {
    Debug.Log(yourStringVarName);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Unity JS return versus Unity C# return</h2></div></div></div><p>In Unity JS, you don't <a id="id358" class="indexterm"/>need to<a id="id359" class="indexterm"/> declare return type as shown in a simple <a id="id360" class="indexterm"/>function <a id="id361" class="indexterm"/>example here:</p><div><pre class="programlisting">function JSReturnString() {
    return "Hello World !";
}</pre></div><p>In Unity C#, you have to always declare a <code class="literal">return</code> type:</p><div><pre class="programlisting">public string CSharpReturnString() {
    return "Hello World !";
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Unity JS yielding versus Unity C# yielding</h2></div></div></div><p>In JS yielding is quite simple, like<a id="id362" class="indexterm"/> the <code class="literal">return</code> keyword. You can just use <a id="id363" class="indexterm"/>yield statements without any declarations as shown in the simple example here:</p><div><pre class="programlisting">function Start() {
    yield YourFunc();
    yield new WaitForSeconds(1.7);
    print("[Start] FINISH");
}

function YourFunc() {
    print("[YourFunc] START");
    yield new WaitForSeconds(0.8);
    print("[YourFunc] FINISH");
}

//Output will be similar as shown below:
// [YourFunc] START
// [YourFunc] FINISH
// [Start] FINISH</pre></div><p>In C# code, you should<a id="id364" class="indexterm"/> declare the <code class="literal">IEnumerator</code> type in your <a id="id365" class="indexterm"/>method declaration as shown in the following example:</p><div><pre class="programlisting">IEnumerator Start() { 
    yield return StartCoroutine(YourMethod());
    yield return new WaitForSeconds(1.7f);
    Debug.Log("[Start] FINISH");
}

IEnumerator YourMethod() {
    Debug.Log("[YourMethod] START");
    yield return new WaitForSeconds(0.8f);
    Debug.Log("[YourMethod] FINISH");
}

//Output will be similar as shown below:
// [YourMethod] START
// [YourMethod] FINISH
// [Start] FINISH</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Unity JS directives versus Unity C# directives</h2></div></div></div><p>Unity has a number <a id="id366" class="indexterm"/>of <strong>script directives</strong>, for example, <code class="literal">AddComponentMenu</code>. The <a id="id367" class="indexterm"/>difference in syntax is shown in the following code:</p><div><pre class="programlisting">// Unity JS example
@script AddComponentMenu ("Your Company Name/Your Action Name")
class YourFunctionName extends MonoBehaviour {}

// Unity C# example
[AddComponentMenu("Your Scope Name/Your Action Name")]
public class YourMethodName : MonoBehaviour {}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Summary</h1></div></div></div><p>This chapter introduced different details about occlusion culling and LOD optimization techniques. Also, this chapter showed how to optimize Unity C# and Unity JS code. Finally, you saw main differences in syntax between Unity C# and Unity JS codes and learned how it is easy to transform between them.</p><p>In the next chapter, you will explore how to enhance the quality in games and applications using different techniques such as physically-based shaders and global illumination in Unity 5. At the end of the chapter, you will know how to optimize any shader code.</p></div></body></html>