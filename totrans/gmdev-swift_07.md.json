["```swift\nenum PhysicsCategory:UInt32 {\n    case playerTank = 1\n    case enemyTanks = 2\n    case missiles = 4\n    case bullets = 8\n    case buildings = 16\n}\n```", "```swift\nenum PhysicsCategory:UInt32 {\n    case penguin = 1\n    case damagedPenguin = 2\n    case ground = 4\n    case enemy = 8\n    case coin = 16\n    case powerup = 32\n}\n```", "```swift\nself.physicsBody?.categoryBitMask =\n    PhysicsCategory.penguin.rawValue\nself.physicsBody?.contactTestBitMask =\n    PhysicsCategory.enemy.rawValue |\n    PhysicsCategory.ground.rawValue |\n    PhysicsCategory.powerup.rawValue |\n    PhysicsCategory.coin.rawValue\n```", "```swift\nself.physicsBody?.categoryBitMask =\n    PhysicsCategory.ground.rawValue\n```", "```swift\nself.physicsBody?.categoryBitMask =\n    PhysicsCategory.powerup.rawValue\n```", "```swift\nself.physicsBody?.categoryBitMask = PhysicsCategory.enemy.rawValue\nself.physicsBody?.collisionBitMask =\n    ~PhysicsCategory.damagedPenguin.rawValue\n```", "```swift\nself.physicsBody?.categoryBitMask = PhysicsCategory.coin.rawValue\nself.physicsBody?.collisionBitMask = 0\n```", "```swift\n    class GameScene: SKScene, SKPhysicsContactDelegate {\n    ```", "```swift\n    self.physicsWorld.contactDelegate = self\n    ```", "```swift\n    func didBeginContact(contact: SKPhysicsContact) {\n        // Each contact has two bodies; we do not know which is which.\n        // We will find the penguin body, then use\n        // the other body to determine the type of contact.\n        let otherBody:SKPhysicsBody\n        // Combine the two penguin physics categories into one\n        // bitmask using the bitwise OR operator |\n        let penguinMask = PhysicsCategory.penguin.rawValue |\n            PhysicsCategory.damagedPenguin.rawValue\n        // Use the bitwise AND operator & to find the penguin.\n        // This returns a positive number if body A's category\n        // is the same as either the penguin or damagedPenguin:\n        if (contact.bodyA.categoryBitMask & penguinMask) > 0 {\n            // bodyA is the penguin, we will test bodyB: \n            otherBody = contact.bodyB\n        }\n        else {\n            // bodyB is the penguin, we will test bodyA:\n            otherBody = contact.bodyA\n        }\n        // Find the type of contact:\n        switch otherBody.categoryBitMask {\n        case PhysicsCategory.ground.rawValue:\n            println(\"hit the ground\")\n        case PhysicsCategory.enemy.rawValue:\n            println(\"take damage\")\n        case PhysicsCategory.coin.rawValue:\n            println(\"collect a coin\")\n        case PhysicsCategory.powerup.rawValue:\n            println(\"start the power-up\")\n        default:\n            println(\"Contact with no game logic\")\n        }\n    }\n    ```", "```swift\n    // The player will be able to take 3 hits before game over:\n    var health:Int = 3\n    // Keep track of when the player is invulnerable:\n    var invulnerable = false\n    // Keep track of when the player is newly damaged:\n    var damaged = false\n    // We will create animations to run when the player takes\n    // damage or dies. Add these properties to store them:\n    var damageAnimation = SKAction()\n    var dieAnimation = SKAction()\n    // We want to stop forward velocity if the player dies,\n    // so we will now store forward velocity as a property:\n    var forwardVelocity:CGFloat = 200\n    ```", "```swift\n    // Set a constant velocity to the right:\n    self.physicsBody?.velocity.dx = self.forwardVelocity\n\n    ```", "```swift\n    if self.health <= 0 { return }\n    ```", "```swift\n    if self.health <= 0 { return }\n    ```", "```swift\n    func die() {\n        // Make sure the player is fully visible:\n        self.alpha = 1\n        // Remove all animations:\n        self.removeAllActions()\n        // Run the die animation:\n        self.runAction(self.dieAnimation)\n        // Prevent any further upward movement:\n        self.flapping = false\n        // Stop forward movement:\n        self.forwardVelocity = 0\n    }\n    ```", "```swift\n    func takeDamage() {\n        // If invulnerable or damaged, return:\n        if self.invulnerable || self.damaged { return }\n\n        // Remove one from our health pool\n        self.health--\n        if self.health == 0 {\n            // If we are out of health, run the die function:\n            die()\n        }\n        else {\n            // Run the take damage animation:\n            self.runAction(self.damageAnimation)\n        }\n    }\n    ```", "```swift\n    case PhysicsCategory.enemy.rawValue:\n        println(\"take damage\")\n     player.takeDamage()\n\n    ```", "```swift\n    case PhysicsCategory.ground.rawValue:\n        println(\"hit the ground\")\n     player.takeDamage()\n\n    ```", "```swift\n// --- Create the taking damage animation ---\nlet damageStart = SKAction.runBlock {\n    // Allow the penguin to pass through enemies:\n    self.physicsBody?.categoryBitMask =\n        PhysicsCategory.damagedPenguin.rawValue\n    // Use the bitwise NOT operator ~ to remove\n    // enemies from the collision test:\n    self.physicsBody?.collisionBitMask =\n        ~PhysicsCategory.enemy.rawValue\n}\n// Create an opacity pulse, slow at first and fast at the end:\nlet slowFade = SKAction.sequence([\n    SKAction.fadeAlphaTo(0.3, duration: 0.35),\n    SKAction.fadeAlphaTo(0.7, duration: 0.35)\n    ])\nlet fastFade = SKAction.sequence([\n    SKAction.fadeAlphaTo(0.3, duration: 0.2),\n    SKAction.fadeAlphaTo(0.7, duration: 0.2)\n    ])\nlet fadeOutAndIn = SKAction.sequence([\n    SKAction.repeatAction(slowFade, count: 2),\n    SKAction.repeatAction(fastFade, count: 5),\n    SKAction.fadeAlphaTo(1, duration: 0.15)\n    ])\n// Return the penguin to normal:\nlet damageEnd = SKAction.runBlock {\n    self.physicsBody?.categoryBitMask =\n        PhysicsCategory.penguin.rawValue\n    // Collide with everything again:\n    self.physicsBody?.collisionBitMask = 0xFFFFFFFF\n    // Turn off the newly damaged flag:\n    self.damaged = false\n}\n// Store the whole sequence in the damageAnimation property:\nself.damageAnimation = SKAction.sequence([\n    damageStart,\n    fadeOutAndIn,\n    damageEnd\n    ])\n```", "```swift\n// If invulnerable or damaged, return out of the function:\nif self.invulnerable || self.damaged { return }\n// Set the damaged state to true after being hit:\nself.damaged = true\n\n```", "```swift\n/* --- Create the death animation --- */\nlet startDie = SKAction.runBlock {\n    // Switch to the death texture with X eyes:\n    self.texture =\n        self.textureAtlas.textureNamed(\"pierre-dead.png\")\n    // Suspend the penguin in space:\n    self.physicsBody?.affectedByGravity = false\n    // Stop any movement:\n    self.physicsBody?.velocity = CGVector(dx: 0, dy: 0)\n    // Make the penguin pass through everything except the ground:\n    self.physicsBody?.collisionBitMask =\n        PhysicsCategory.ground.rawValue\n}\n\nlet endDie = SKAction.runBlock {\n    // Turn gravity back on:\n    self.physicsBody?.affectedByGravity = true\n}\n\nself.dieAnimation = SKAction.sequence([\n    startDie,\n    // Scale the penguin bigger:\n    SKAction.scaleTo(1.3, duration: 0.5),\n    // Use the waitForDuration action to provide a short pause:\n    SKAction.waitForDuration(0.5),\n    // Rotate the penguin on to his back:\n    SKAction.rotateToAngle(3, duration: 1.5),\n    SKAction.waitForDuration(0.5),\n    endDie\n])\n```", "```swift\n    var coinsCollected = 0\n    ```", "```swift\n    func collect() {\n        // Prevent further contact:\n        self.physicsBody?.categoryBitMask = 0\n        // Fade out, move up, and scale up the coin:\n        let collectAnimation = SKAction.group([\n            SKAction.fadeAlphaTo(0, duration: 0.2),\n            SKAction.scaleTo(1.5, duration: 0.2),\n            SKAction.moveBy(CGVector(dx: 0, dy: 25), duration: 0.2)\n        ])\n        // After fading it out, move the coin out of the way\n        // and reset it to initial values until the encounter\n        // system re-uses it:\n        let resetAfterCollected = SKAction.runBlock {\n            self.position.y = 5000\n            self.alpha = 1\n            self.xScale = 1\n            self.yScale = 1\n            self.physicsBody?.categoryBitMask =\n                PhysicsCategory.coin.rawValue\n        }\n        // Combine the actions into a sequence:\n        let collectSequence = SKAction.sequence([\n            collectAnimation,\n            resetAfterCollected\n        ])\n        // Run the collect animation:\n        self.runAction(collectSequence)\n    }\n    ```", "```swift\n    case PhysicsCategory.coin.rawValue:\n        // Try to cast the otherBody's node as a Coin:\n        if let coin = otherBody.node as? Coin {\n            // Invoke the collect animation:\n            coin.collect()\n            // Add the value of the coin to our counter:\n            self.coinsCollected += coin.value\n            println(self.coinsCollected)\n        }\n    ```", "```swift\n    func starPower() {\n        // Remove any existing star power-up animation, if\n        // the player is already under the power of star\n        self.removeActionForKey(\"starPower\")\n        // Grant great forward speed:\n        self.forwardVelocity = 400\n        // Make the player invulnerable:\n        self.invulnerable = true\n        // Create a sequence to scale the player larger,\n        // wait 8 seconds, then scale back down and turn off\n        // invulnerability, returning the player to normal: \n        let starSequence = SKAction.sequence([\n            SKAction.scaleTo(1.5, duration: 0.3),\n            SKAction.waitForDuration(8),\n            SKAction.scaleTo(1, duration: 1),\n            SKAction.runBlock {\n                self.forwardVelocity = 200\n                self.invulnerable = false\n            }\n        ])\n        // Execute the sequence:\n        self.runAction(starSequence, withKey: \"starPower\")\n    }\n    ```", "```swift\n    case PhysicsCategory.powerup.rawValue:\n        player.starPower()\n    ```", "```swift\n//let starRoll = Int(arc4random_uniform(10))\nlet starRoll = 0\nif starRoll == 0 {\n```"]