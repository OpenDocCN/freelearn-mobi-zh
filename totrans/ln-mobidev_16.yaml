- en: Scaling Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn what determines your app's scalability and what
    you need to do for it to scale well. You will also learn when scaling will become
    important and what elements will influence your scaling strategy. When you just
    get started, the scale is not important at all. In fact, we did tell you earlier
    to do things that do not scale. So, what made us change our mind? Nothing really.
    It is still important to prove your hypotheses and, until that is done, it would
    be a waste of time to make your app scale. However, what is important is that
    you should think about the scalability of your app and what your strategy will
    be in case your app becomes very popular and starts to grow quickly. Now, it is
    perfectly fine that your app backend can handle only one hundred simultaneous
    connections. But your app backend also needs to be capable of handling thousands
    of simultaneous requests, if not more. Not being able to scale things quickly
    leads to downtime, which leads to sad users, which in turn leads to a large churn
    percentage. People walk away and, instead of steady growth, your short moment
    of fame will be gone. This would be even a bigger waste. So, we need a plan and
    this chapter will help you to define this plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in the chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn why it is important to make your app able to scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine when and how to scale your app and how analytics can help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out what you need to do to have a scalable backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it scalable but do not scale it right away
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, the definition of scalability may vary from culture to culture,
    but for your app it is important that it is responsive and functional in the most
    common circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: If you foresee any issues at a given moment in time, it is time to scale up;
    but the key element here is that being able to scale up quickly is more important.
    Make sure that you can do the right things when there is momentum!
  prefs: []
  type: TYPE_NORMAL
- en: So, you made an app and it has been shown on a site such as Product Hunt or
    Betalist. You have some enthusiastic early adopters for an audience. As an early-stage
    startup company, you should not care too much about how well your app scales,
    but you should have an idea on how to make it scale if your audience suddenly
    becomes larger than expected.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability is not just about the backend solution for your app. It is also
    about to what extent it is possible to automate the services for your app and
    how easy it will be to serve any amount of app users. Only when your app services
    can be near 100% automated, will you have a really scalable solution. Anything
    that requires your personal, or other people's attention, prevents your app from
    being fully scalable. The more support your app requires, the less scalable it
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scalability of your app could also be limited by the nature of your app
    and its targeted audience. A game app: Flappy Bird, for example, can by definition
    be very scalable. It has no backend and the game is distributed by the App Store
    or Play Store. For things such as leaderboards, you can use the Google or Apple
    services. You can trust that these services are scalable. A social app will be
    harder to scale because it requires that you have a (complex) backend solution.
    Although it is distributed via the stores, your users need to be able to download
    and upload streams of data that not just involve text, but also images and video.
    Your server should be capable of handling that load.'
  prefs: []
  type: TYPE_NORMAL
- en: All of it needs to be stored somewhere and it needs to be delivered quickly.
    Also, moderation, although it can be automated to a large extent, becomes more
    important when user-generated content comes in. Moderation requires manual intervention
    that will have an effect on the scalability of the app. Other apps, such as Uber,
    come with other (non-technical) challenges. They need to deal with all kinds of
    regulations that also require manual interaction. Anything that requires manual
    interaction can threaten the scalability of your solution. Once your hypotheses
    are proven and your app starts to grow, it is important to automate as many components
    of your app as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more staff, you can hire more people, of course. However, automation
    is better. In this chapter, we will focus in particular on the technical scalability
    of an app. When the distribution of the app itself is taken care of by the Play
    Store or App Store, there is no need to have a strategy. The stores can distribute
    these apps as often as you want without the need to worry about scaling. Well,
    this is why they charge 30% (for paid apps), right? Discussing the scalability
    of your app is relevant if your app will use some kind of backend. For example,
    you might use a backend to share stories, images, videos, or whatever.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you have created a first MVP for your app. The MVP itself is
    not an app yet. It is just there for validation. Imagine that through a website
    or email, you obtain user input that requires some kind of processing. As we have
    seen in previous chapters, it is perfectly fine to have a concierge service. You
    will be doing the process partly or completely manually. True, that does not scale,
    but why would you automate the process if you do not know yet if it is going to
    work out?
  prefs: []
  type: TYPE_NORMAL
- en: If your MVP does work as expected, it will result in a few happy customers.
    You have proven your hypotheses and you can start to automate the process. You
    actually built an app and created the backend for it. You stored all data (texts,
    images, and video) on a single server. If this went well, there will be more happy
    customers. And then, your app gets featured in the App Store or a very influential
    early adopter writes a blog about your app and it goes Boom! Suddenly a lot of
    people start using your app and smoke is coming out of your server(s). You quickly
    need to come up with a solution before things start to slow down or before they
    stop working. You need to prevent people from becoming disappointed or your momentum
    will be gone. You can add a couple of extra servers and think of some smart load-balancing
    solution, but, on the other hand, you could save yourself a lot of trouble if
    you start to utilize cloud services, running on, for example, Amazon or Azure
    from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think it won''t go that fast, then consider this: If you do not expect
    your app to go Boom! then why bother building it in the first place? Even pet
    projects can suddenly become very popular!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bdaba72-6279-48fc-af4f-6e850718d183.png)'
  prefs: []
  type: TYPE_IMG
- en: A scalable backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on your particular situation, a mobile backend solution may have
    to deal with these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Database and load balancing the database tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server and load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the amount of data that goes 'over the line' (low bandwidth support)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage of media (images, video, and audio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content delivery (video streaming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud storage space is pretty affordable nowadays and, with most solutions,
    you just need to click a few buttons to scale up (and spend a little bit more
    money). So, why not use cloud services right from the start? If you have the skills
    and the time, you can build your own solution and run it on the (scalable) cloud
    using an Infrastructure-as-a-Service (IaaS) solution such as AWS or Azure. If
    you do not have the skills or time, you can also choose to use a Mobile Backend
    as a Service (MBaaS). The latter will be less flexible and it will be more costly,
    but no matter which one you choose, both services will be scalable without too
    much effort on your side.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based storage and processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run your app backend solution and store your data in the cloud, for example
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon (Amazon Web Services and Amazon Storage Service, S3 for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google (App Engine, Cloud Storage, Cloud Datastore, and Cloud SQL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure (Virtual server, databases, storage, and content delivery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of these solutions offer at least these components:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage of media (images and video)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content delivery (video)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things that will have an influence on what service to use are pricing, specific
    needs, database support, database type (NoSQL versus SQL), and the programming
    language that is most convenient for you or your team. Also, the ease of use and
    the pricing for push notification services are important to evaluate. The programming
    languages that you can use vary from cloud solution to cloud solution. Google
    App Engine is a better choice for Java developers, and .NET believers better deploy
    their solution in the Azure Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most cloud solutions offer multiple programming environments. If you want to
    do Java on Heroku, or Node.js on AWS or Azure, then you can do so. All solutions
    support Java, PHP, Python, and Ruby programming languages. Azure and Amazon both
    support .NET but Azure will probably be the preferred choice here. Go is supported
    by all of them, except Amazon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2616c4c1-3dc4-4522-966b-b127cc110fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: If you prefer to go for a ready-made backend solution, such as Firebase and
    Parse server, please check out [Chapter 8](f05cc1f7-9372-486a-b2ea-4fe6f4a5d69f.xhtml),
    *Cloud Solutions for App Experiments*. An MBaaS is convenient and to a particular
    extent just as scalable, but convenience comes with a price. You start with a
    freemium plan, but when you need to scale up to a premium plan, it is often more
    expensive than developing your own cloud solution. Another pitfall can be that
    it could lead to a vendor lock-in more than would be the case otherwise. However,
    if you need an extra database or an extra server for storage or to process data,
    it is easy to scale things up, but the same applies to IaaS.
  prefs: []
  type: TYPE_NORMAL
- en: Seen from a client perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example. From the perspective of a client (here, an Android
    app) the architectural picture could look as shown in the following figure. From
    some endpoint, the API is being consumed. This will result in receiving data that
    will be handled by the Retrofit client (HTTP client for Android) in this example.
    It consumes data in the **JavaScript Object Notation** (**JSON**) format and eventually
    changes this data into objects using a JSON converter, such as Gson library, a
    library capable of doing object mapping on JSON data. Often an SDK is available
    from the party offering the service, which will make it faster and easier to consume
    data from the endpoint or to send data to it. The Parser Server SDKs, for example,
    will take care of object mapping and data synchronization from and to the Parse
    server. As you can see here, it does not really matter to your Android or iOS
    app what the structure of the backend will look like and where it is hosted. For
    the client side, all that matters is the interface, which, in this example, is
    a REST API delivering JSON data on request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/084d051c-0c59-4bc1-957c-1eabef8bb6f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Things are not always as ideal as in this preceding image. If you are developing
    an app that is getting its data from an endpoint that originally was intended
    to use with a website or another non-mobile solution, you might need to create
    a middleware solution first. Mobile scalability also means that you need to deal
    with low bandwidth circumstances. It is important to limit the amount of data
    in a single transaction as much as possible. Anything that is not instantly needed
    to be displayed in your app should not be in there. Your app should download thumbnails
    instead of downloading images or videos; it should have a paging mechanism (Load
    More options) and the data should be optimized for use on a device that may have
    a low bandwidth connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture nicely demonstrates the difference between a non-optimized
    and an optimized situation for mobile usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4eae3c6-da6b-43b2-b360-e2846f90f54a.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of loading the whole dataset in JSON with large and descriptive names,
    you should load the smallest amount of data possible and persist it on the device
    for caching purposes. Even with low-bandwidth conditions, and even if you do not
    have an internet connection, your app will remain responsive and usable. For further
    optimization, your app should retrieve thumbnails first. It makes no sense to
    download hi-res images if your user only sees a small picture of it. Also, your
    (middleware) solution should allow your app to retrieve the app in chunks. Have
    a look at the Facebook app for example. It only loads a part of the stream, and
    when you scroll down (some apps have a Load More button for this at the bottom
    of the list), it loads another section of the data. If you are building things
    from scratch and you go for a mobile-first strategy, then this paging mechanism
    is something you need right away. If the current API is intended for non-mobile
    use, you should consider creating a middleware solution first to optimize the
    data stream.
  prefs: []
  type: TYPE_NORMAL
- en: A well scalable app comes with an improved user experience and better reliability,
    and will be easier to leverage particular events. Think of holidays or particular
    happenings that, depending on the type of app, could all heavily influence the
    amount of traffic involved with your app. A scalable app backend should be easy
    to scale up, allowing you to deliver what is needed during peak hours/day. It
    should also allow you to scale down at other moments to avoid wasting resources
    when they are not utilized.
  prefs: []
  type: TYPE_NORMAL
- en: You should know when you need to scale up or to scale down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using analytics the right way, you will know when to up or to downscale
    your solution. Seasonality and also the nature of your app can help to make some
    forecasts here. At what time of the day or during what specific events will your
    app be used the most, or when will your users be using the app less? For example,
    if your app is an alarm clock, people will use it less during the holiday season.
    Also, if your app is related to the Olympic Games you can expect a peak usage
    during that event. During holidays, people often spend more money in the App Store,
    resulting in additional downloads and app usage. Finally, campaigns, certainly
    when you are offering your app at a lower price, will have a heavy impact on your
    app's usage rates. Other events are much harder to predict. What if your app gets
    featured and grows 150% a day? You better be prepared for it.
  prefs: []
  type: TYPE_NORMAL
- en: The number of users says something about the number of simultaneous users. That
    last number is what is really important for scaling your app backend. You can
    have ten million users that are using your app regularly or you can have ten million
    users that are using your app every day. One is quite different from the other.
    Metrics can tell you something about the average time spent in the app in a particular
    time frame. If you have an international app, it is important to segment this
    by time zone. Your users may use your app all day long but (maybe) not while they
    are sleeping.
  prefs: []
  type: TYPE_NORMAL
- en: Anyhow, it is important to realize that it is okay if your app does not scale
    yet or if it only supports a small number of (concurrent) users as long as it
    can be scaled up relatively easily. Do not scale because your app needs to be
    scalable. You need to be prepared to do the right things when necessary, but also
    do not put too much effort in it. Perfectionism has killed many great projects.
    Do not let that happen to you.
  prefs: []
  type: TYPE_NORMAL
- en: A real horror story about an app backend that did not scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low bandwidth can create a poor user experience even with caching and keeping
    data consumption to a minimum, but some things are outside your control. On the
    other hand, a totally overloaded backend is something that you have control over
    to a certain level. Your users judge the total app experience. This is why the
    whole architecture matters.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example to illustrate this point. A while ago, I was working on an
    Android SecondScreen app for a well-known international TV show. A **Non Disclosure
    Agreement** (**NDA**) prevents me to tell you which one, but it does not really
    matter to the story. Anyhow, the show was broadcasted on television. The people
    watching the show at home were able to give their votes for the various candidates
    that appeared on the show. Due to this, it was easy to predict that there would
    be a lot of traffic at the time the show was broadcasted. So, when asking the
    third party that was developing the backend of the app about the scalability of
    their solution, they told me that they could guarantee that at least 100K users
    could use the use the app while watching the show. I was na√Øve not to ask them
    if they did some proper load testing at their end. I just assumed that they were
    a professional company. Unfortunately, they turned out to be not so professional.
  prefs: []
  type: TYPE_NORMAL
- en: When the show's new season started and people began to use the app for the first
    time, something went horribly wrong during the first broadcast. The first 30 minutes
    went fine and about 40K users were using the app actively by voting. Then, the
    app stopped working in most cases and it became very hard to vote. The reason
    for this was that the backend could not handle the large traffic load. Although
    it was not the frontend (the app) to blame instead of the backend, from the user's
    perspective it was the app that sucked. The poor performance generated a lot of
    negative reviews. Even though the next broadcast went well, it was hard to recover
    from the bad reviews. The damage was done.
  prefs: []
  type: TYPE_NORMAL
- en: Captain hindsight to the rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is the retrospective on this issue. If we had a proper load test that proved
    what was promised, then the situation perhaps could have been avoided. Also, if
    we would have been able to upscale quickly, we could have avoided a lot of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting the future is pretty hard unless you have a crystal ball that actually
    works. As far as I know, there are none. So instead, always make sure that you
    can respond quickly to new situations.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be prepared for situations that you can, more or less, foresee.
    Go figure it out for yourself and do some heavy load tests. Break things before
    your users do it for you. If you notice any trouble, then you need to find the
    bottlenecks and see what the best fixes are for them.
  prefs: []
  type: TYPE_NORMAL
- en: To scale up or to refactor? That is the question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just realize that upscaling is not always the correct answer. If your architecture
    is bad you can add another database or another server, but that would just be
    a short-term patch and you would be wasting hardware resources (and money). If
    a better architecture without upscaling results in a better performance, then
    that is what you should preferably do. In addition, you still need to make sure
    that you can scale up quickly.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to keep the app as thin as possible (although there
    are some exceptions). Let your servers do all the heavy work instead of a small
    device that otherwise could lead to battery drain and heavy CPU usage. From this
    perspective, scalability often applies to the backend alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'As your app user base grows from 10 users to a population of 100, to 10K, 100K,
    or 1 million, scalability becomes more and more important. The best practices
    here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the app as thin as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep it simple and do not scale yet, but make it scalable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cloud storage and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider building the interface (API) first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to obtain great insights through analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the market, plan your campaigns carefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep data traffic as low as possible and don't transfer data that will not be
    utilized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use autoscale options where possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Things that influence the scalability of your solutions involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average size of traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regions of your server and where (most of) your users reside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice between using an MBaaS, hosting your solution yourself, and cloud-based
    solutions such as App Engine, Azure, or Amazon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you choose to use Azure as a backend for your mobile app, you can use Azure''s
    mobile services. It offers most infrastructure for you, including processing,
    storage, and scaling options. You can pick a pricing tier, such as free, one of
    the basic, or one of the premium plans. An example from the Microsoft document
    that shows how scaling works in Azure is provided in the following picture. The
    picture is taken from the classic environment and it looks a bit different in
    the ''new'' portal; however, the way it is presented here is clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66fe4123-b6cd-47bb-8176-d7d3ee333592.png)'
  prefs: []
  type: TYPE_IMG
- en: Most Azure services, including the previously mentioned one, come with autoscaling.
    The solution will automatically scale up or down depending on traffic or by following
    schedules. Think, for example, of a day and night schedule, a weekend versus weekdays
    schedule, or a schedule for a specific period when you are running a campaign.
    It depends on how your app is used as to what will work best for you. If you have
    no clue, you can learn what the best approach will be by keeping an eye on statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Amazon, you have more or less the same options for autoscaling and AWS Mobile
    Services can help you to build apps faster. It comes with support for push notifications,
    user analytics, data storage, and synchronization options. It can automatically
    increase the number of instances during peak hours (or days) and decrease them
    when less capacity is needed, thus saving you money by reducing costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e82cb26e-186f-4179-be21-c06b2d5fc010.png)'
  prefs: []
  type: TYPE_IMG
- en: Amazon Cloud Watch enables auto-scaling, which is a monitoring service for AWS
    Cloud resources and applications. You can read more about it at [https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/).
  prefs: []
  type: TYPE_NORMAL
- en: There are some very good books available on the topic that provide you with
    more in-depth knowledge of any of the IaaS here. I suggest that you check them
    out later. In this chapter, we just had a look at what your options are and how
    it affects your strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting read is: [http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html](http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling an MBaaS, such as Firebase, basically comes down to picking another
    price plan. Unlike Azure, Amazon, and App Engine, it does not come with autoscale
    options and in general, it is less suitable to support a very large number of
    users. This, however, should not prevent you from using Firebase, for example,
    as it is a great solution to get started and more importantly, it allows you to
    validate quickly. Additionally, if you want to migrate from MBaaS to IaaS later,
    you can use the time that you have saved earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about a scaling strategy for your app and
    how this strategy applies in particular to your app backend. A good architecture
    and the ability to scale, not the scale itself, are key elements here.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, storing data and processing services in the cloud is often very
    scalable but, depending on what you choose, could also be very costly. If you
    want to use data from an API that originally was not intended to be consumed on
    a mobile device, you might need to create a middleware solution first. This way
    you can ensure that your app works well even with low-bandwidth conditions. Minimizing
    the amount of data and paging it can help improve your app's performance.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud services offer convenience but at a price. This should not be an issue
    as soon as your app becomes profitable. There are many ways for monetization and
    we are going to look at that in the next chapter. Do you need to create a premium
    app or will in-app purchases lead to more revenue? Let's find out!
  prefs: []
  type: TYPE_NORMAL
