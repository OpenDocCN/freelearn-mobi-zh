- en: Chapter 7. Textures and Mapping Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 纹理和映射技术
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Applying texture with UV mapping
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UV映射应用纹理
- en: Efficient rendering with ETC2 compressed texture format
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ETC2压缩纹理格式进行高效渲染
- en: Applying multiple textures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用多种纹理
- en: Implementing Skybox with seamless cube mapping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无缝立方贴图实现Skybox
- en: Implementing reflection and refraction with environment mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境贴图实现反射和折射
- en: Implementing render to texture with Frame Buffer Objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用帧缓冲对象实现渲染到纹理
- en: Implementing terrain with displacement mapping
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位移贴图实现地形
- en: Implementing bump mapping
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凹凸贴图实现
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will shed some light on textures, which is a very interesting part
    of the 3D computer graphics study. Texturing is a technique by which the surface
    of a 3D mesh model is painted with static images. In our previous chapter, we
    described the procedural and image texturing technique. The former uses a special
    algorithm to calculate the colors of the fragments in order to generate specific
    patterns. On the other hand, the latter one uses static images, which are wrapped
    onto the 3D mesh or geometry.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍纹理，这是3D计算机图形研究中的一个非常有趣的部分。纹理是一种技术，通过该技术，3D网格模型的表面被涂上静态图像。在我们上一章中，我们描述了过程纹理和图像纹理技术。前者使用特殊算法计算片段的颜色以生成特定图案。另一方面，后者使用静态图像，这些图像被包裹在3D网格或几何体上。
- en: This chapter is all about image texturing that explains its various applications
    in the field of 3D computer graphics. We will begin this chapter with a simple
    recipe that demonstrates the UV mapping to render a texture on the 2D planar surface;
    moving ahead from single texture, you will learn how to apply multiple textures
    on 3D objects. OpenGL ES 3.0 has introduced many new features. Among these, nonpower
    of two (NPOT) texture support, ETC2/EAC texture compression support, and seamless
    cube mapping are explained in detail in this chapter, with the help of a few practical
    recipes. In the later sections of this chapter, we will implement the environment
    mapping recipes to simulate the reflection and refraction behavior on the surface
    of objects. The chapter will continue to explain an effective technique called
    render to texture; this allows you to render scenes to user-defined texture buffers.
    Further, we will discuss the displacement mapping technique, which can be used
    to render a geographical terrain; the last recipe in this chapter will discuss
    the bump mapping technique, which is used to produce a high quality, detailed
    surface using a low polygon mesh.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于图像纹理，解释了其在3D计算机图形领域的各种应用。我们将从演示UV映射以在二维平面表面上渲染纹理的简单食谱开始本章；从单个纹理开始，你将学习如何将多个纹理应用于3D对象。OpenGL
    ES 3.0引入了许多新特性。在这些特性中，非2的幂（NPOT）纹理支持、ETC2/EAC纹理压缩支持和无缝立方贴图在本章中通过一些实际食谱进行了详细解释。在章节的后续部分，我们将实现环境贴图食谱以模拟物体表面的反射和折射行为。章节将继续解释一种称为渲染到纹理的有效技术；这允许你将场景渲染到用户定义的纹理缓冲区。此外，我们将讨论位移贴图技术，它可以用来渲染地形；本章的最后一个食谱将讨论凹凸贴图技术，该技术用于使用低多边形网格生成高质量、详细的表面。
- en: Applying texture with UV mapping
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UV映射应用纹理
- en: A texture is basically an image represented by a chunk of memory in the computer;
    this memory contains color information in the form of red (R), green (G), blue
    (B), and alpha (A) component; each component is represented as a series of bits/bytes,
    depending on the format of the type of texture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理基本上是计算机内存中由一块内存表示的图像；这块内存包含以红色（R）、绿色（G）、蓝色（B）和alpha（A）组件形式存在的颜色信息；每个组件都表示为一串位/字节，具体取决于纹理类型的格式。
- en: 'In this recipe, we will create a simple square and apply texture to it; three
    things are required for texture mapping:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个简单的正方形并对其应用纹理；纹理映射需要以下三个要素：
- en: An image first needs to be loaded into the OpenGL ES texture memory with the
    help of texture objects.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先需要使用纹理对象将图像加载到OpenGL ES纹理内存中。
- en: A texture is mapped to the geometry using texture coordinates.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纹理坐标将纹理映射到几何体上。
- en: Use texture coordinates to get the corresponding color from texture in order
    to apply it on the surface of the geometry.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纹理坐标从纹理中获取相应的颜色，以便将其应用于几何体的表面。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The GLPI framework allows to load **Portable Network Graphics** (**PNG**) image
    files using a high-level abstracted class called `.png` image, which is derived
    from image; this class loads the `.png` image and stores image metrics in the
    class, such as name, dimensions, raw bits, and OpenGL ES texture name (ID). Internally,
    this class uses `libpng`, which is a platform-independent library that allows
    you to parse `.png` images.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GLPI 框架允许使用名为 `.png` 的高层抽象类加载 **可移植网络图形** （**PNG**）图像文件，该类是从图像派生出来的；此类加载 `.png`
    图像并在类中存储图像度量，如名称、尺寸、原始位和 OpenGL ES 纹理名称（ID）。内部，此类使用 `libpng`，这是一个平台无关的库，允许您解析
    `.png` 图像。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following procedure describes the steps to render geometry with the `.png`
    image texture:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程描述了使用 `.png` 图像纹理渲染几何形状的步骤：
- en: The `libpng` library is available under the `GLPLFramework` folder; this book
    will use version 1.5.13 of `libpng`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`libpng` 库位于 `GLPLFramework` 文件夹下；本书将使用 `libpng` 的 1.5.13 版本。'
- en: '**iOS**: On iOS, this library needs to be added to the project. In Xcode, under
    your project, you can include this library using **File** | **Add to <Project
    Name>**.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**：在 iOS 上，需要将此库添加到项目中。在 Xcode 中，在您的项目下，您可以通过 **文件** | **添加到 <项目名称>**
    来包含此库。'
- en: '**Android**: For Android, `libpng` can be compiled as a shared library called
    `GLPipng`; for this, create `Android.mk` in the `libpng` folder and add the following
    code:'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：对于 Android，`libpng` 可以编译为一个名为 `GLPipng` 的共享库；为此，在 `libpng` 文件夹中创建
    `Android.mk` 并添加以下代码：'
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This makefile (`<GLPIFramework>/libpng/Android.mk`) needs to be included in
    the makefile main project (`SimpleTexture/Android/JNI/ Android.mk`) and the following
    line must be included in order to compile it in the makefile of your main project:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 makefile (`<GLPIFramework>/libpng/Android.mk`) 需要包含在主项目 makefile (`SimpleTexture/Android/JNI/Android.mk`)
    中，并且必须在主项目的 makefile 中包含以下行，以便编译它：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The generated shared library called `GLPipng` must be added to the project,
    as given in the following code:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的名为 `GLPipng` 的共享库必须添加到项目中，如下代码所示：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to read or write files on the external storage, your app must acquire
    the system permissions:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在外部存储上读取或写入文件，您的应用必须获取系统权限：
- en: Note
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Beginning with Android 4.4, these permissions are not required if you're reading
    or writing only files that are private to your app.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 Android 4.4 开始，如果您只读取或写入您应用私有的文件，则不需要这些权限。
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a `SimpleTexture` class derived from `Model`; inside the constructor
    of this class, use the `PngImage` class member variable image to load an image:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `Model` 派生的 `SimpleTexture` 类；在这个类的构造函数中，使用 `PngImage` 类成员变量 image 加载图像：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PngImage::loadImage()` is responsible for loading an image and assigning
    a unique name to the loaded texture, which is provided by OpenGL ES to recognize
    a texture uniquely in the system.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PngImage::loadImage()` 负责加载图像并为加载的纹理分配一个唯一的名称，该名称由 OpenGL ES 在系统中唯一识别纹理。'
- en: '**Syntax**:'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Variable | Description |'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fileName` | This is the name of the image file that needs to be loaded.
    |'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `fileName` | 这是需要加载的图像文件名称。 |'
- en: '| `generateTexID` | This is the Boolean value that decides whether the image
    needs a unique name ID or not. If the Boolean value is `true`, then the loaded
    image is assigned with a unique ID and if the Boolean value is `false`, no ID
    is assigned to the image. The default value of this parameter is Boolean `true`.
    |'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `generateTexID` | 这是一个布尔值，用于决定图像是否需要唯一的名称 ID。如果布尔值为 `true`，则加载的图像被分配一个唯一的
    ID；如果布尔值为 `false`，则不分配 ID 给图像。此参数的默认值是布尔值 `true`。 |'
- en: '| `target` | This specifies the target to which the texture needs to be bound.
    The possible targets are `GL_TEXTURE_2D`, `GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY`,
    or `GL_TEXTURE_CUBE_MAP`. The default value of this parameter is `GL_TEXTURE_2D`.
    |'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 这指定了需要绑定纹理的目标。可能的目标是 `GL_TEXTURE_2D`、`GL_TEXTURE_3D`、`GL_TEXTURE_2D_ARRAY`
    或 `GL_TEXTURE_CUBE_MAP`。此参数的默认值是 `GL_TEXTURE_2D`。 |'
- en: '**Code**: The working code for the `loadImage` function of the `PngImage` class
    is as follows:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：`PngImage` 类的 `loadImage` 函数的工作代码如下：'
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `loadImage` function parses the specified image filename and stores the
    read image buffer in the `bitraw` class member of `PngImage`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loadImage` 函数解析指定的图像文件名并将读取的图像缓冲区存储在 `PngImage` 类的 `bitraw` 成员中。'
- en: The unique texture name is generated using the `glGenTexture` OpenGL ES API.
    This API generates a number of unused names in textures as specified by `n`. This
    name exists in the form of an unsigned integer ID; the generated ID is stored
    in the `texID` PngImage's member variable.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一的纹理名称是通过使用`glGenTexture` OpenGL ES API生成的。此API根据`n`指定的数量在纹理中生成一定数量的未使用名称。该名称以无符号整数ID的形式存在；生成的ID存储在PngImage的成员变量`texID`中。
- en: '**Syntax**:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Variable | Description |'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `n` | This specifies the number of texture names to be generated |'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `n` | 这指定了要生成的纹理名称数量 |'
- en: '| `textures` | This specifies an array of unused generated texture names |'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `textures` | 这指定了一个未使用的生成纹理名称数组 |'
- en: 'Consider the following code:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Bind the generated `texID` into a specified target using `glBindTexture`; this
    API of OpenGL ES 3.0 specifies the pipeline and what kind of texture it needs
    to manage. For example, the following code mentions that the current state of
    OpenGL ES contains a 2D type texture:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`glBindTexture`将生成的`texID`绑定到指定的目标；OpenGL ES 3.0的此API指定了管道以及它需要管理的纹理类型。例如，以下代码提到OpenGL
    ES当前状态包含一个2D类型的纹理：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This API is very important to be called to perform any operation on a texture;
    it binds the correct texture name to OpenGL ES, which allows you to perform any
    texture operation on it.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此API非常重要，必须调用以在纹理上执行任何操作；它将正确的纹理名称绑定到OpenGL ES，这允许您对其进行任何纹理操作。
- en: '**Syntax**:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Variable | Description |'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the target to which the texture is bound. This
    must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`.
    |'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 这指定了纹理绑定的目标。这必须是`GL_TEXTURE_2D`、`GL_TEXTURE_3D`、`GL_TEXTURE_2D_ARRAY`或`GL_TEXTURE_CUBE_MAP`之一。
    |'
- en: '| `texture` | This specifies an array of unused generated texture names. |'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `texture` | 这指定了一个未使用的生成纹理名称数组。 |'
- en: 'Load the image in the OpenGL ES texture memory using the `glTexImage2D` OpenGL
    ES 3.0 API:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OpenGL ES 3.0的`glTexImage2D` API将图像加载到OpenGL ES纹理内存中：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The syntax of the `glTexImage2D` API describing each parameter is as follows:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 描述`glTexImage2D` API每个参数的语法如下：
- en: '**Syntax**:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Variable | Description |'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the target to which the texture is bound. |'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 这指定了纹理绑定的目标。 |'
- en: '| `level` | This is the level of detail number for mipmapping. |'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `level` | 这是米级映射的细节级别数。 |'
- en: '| `internalFormat` | This specifies the number of components in the texture.
    For example, this recipe uses an image with four components (red, green, blue,
    and alpha). Therefore, the format will be `GL_RGBA`. |'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `internalFormat` | 这指定了纹理中的组件数。例如，这个配方使用了一个具有四个组件（红色、绿色、蓝色和alpha）的图像。因此，格式将是`GL_RGBA`。
    |'
- en: '| `width` | This specifies the width of the texture; the new version of OpenGL
    ES 3.0 supports 2048 texels for all implementations. |'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `width` | 这指定了纹理的宽度；OpenGL ES 3.0的新版本支持所有实现中的2048个texels。 |'
- en: '| `height` | This specifies the height of the texture; the new version of OpenGL
    ES 3.0 supports 2048 texels for all implementations. |'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `height` | 这指定了纹理的高度；OpenGL ES 3.0的新版本支持所有实现中的2048个texels。 |'
- en: '| `border` | This value must be 0. |'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `border` | 此值必须是0。 |'
- en: '| `format` | This specifies the pixel data format; for this recipe, it''s `GL_RGBA`.
    |'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `format` | 这指定了像素数据格式；对于这个配方，它是`GL_RGBA`。 |'
- en: '| `type` | This specifies the data type of the pixel data; in this recipe,
    all components used 8 bits unsigned integer. Therefore, the type must be `GL_UNSIGNED_BYTE`.
    |'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `type` | 这指定了像素数据的数据类型；在这个配方中，所有使用的组件都是8位无符号整数。因此，类型必须是`GL_UNSIGNED_BYTE`。
    |'
- en: '| `data` | This is a pointer to the image parsed data. |'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `data` | 这是一个指向图像解析数据的指针。 |'
- en: 'Create a vertex shader file called `SimpleTexutreVertex.glsl` and add the following
    code; this shader file receives the vertex and texture coordinate information
    from the OpenGL ES program; the received texture coordinates are further sent
    to the fragment shader for texture sampling purposes:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SimpleTextureVertex.glsl`的顶点着色器文件，并添加以下代码；此着色器文件从OpenGL ES程序接收顶点和纹理坐标信息；接收到的纹理坐标随后被发送到片段着色器以进行纹理采样：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, create a shader file called `SimpleTexureFragment.glsl`; this is
    responsible for receiving the texture coordinate from the vertex shader and the
    texture image. The texture is received in sampler2D, which is a built-in data
    type in GLSL to access texture in the shader. Another GLSL API texture is used
    to retrieve the fragment color; this API accepts the texture and texture coordinate
    as an argument:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，创建一个名为 `SimpleTexureFragment.glsl` 的着色器文件；这个文件负责接收从顶点着色器传来的纹理坐标和纹理图像。纹理以
    sampler2D 的形式接收，这是 GLSL 中的一个内置数据类型，用于在着色器中访问纹理。另一个 GLSL API 纹理用于检索片段颜色；这个 API
    接受纹理和纹理坐标作为参数：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the geometry vertices of the square and texture coordinates to map the
    texture on the geometry:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义正方形的几何顶点和纹理坐标以将纹理映射到几何形状上：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How to do it...](img/5527OT_07_01.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_07_01.jpg)'
- en: Note
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A single texture is always represented in the UV coordinate system from (0.0,
    0.0) bottom-left to (1.0, 1.0) top-right. If the texture coordinates goes beyond
    these dimensional ranges, then the special wrapping rule can be applied to control
    texture wrapping. For more information, refer to the *There's more…* section in
    this recipe.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单个纹理始终在 UV 坐标系中以 (0.0, 0.0) 左下角到 (1.0, 1.0) 右上角表示。如果纹理坐标超出这些尺寸范围，则可以应用特殊的包裹规则来控制纹理包裹。有关更多信息，请参阅本配方中的
    *还有更多…* 部分。
- en: 'The OpenGL ES shader accesses loaded images using texture units; texture units
    are pieces of hardware that have access to images. Each texture unit has an ID
    that ranges from `0` to `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS -1`. In order to
    make a texture unit active, use `glActiveTexture`. In the current recipe, the
    loaded texture is made accessible to the shader through texture unit 0 (`GL_TEXTURE0`).
    Bind the texture to this texture unit:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenGL ES 着色器通过纹理单元访问加载的图像；纹理单元是能够访问图像的硬件部件。每个纹理单元都有一个从 `0` 到 `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
    -1` 的 ID。为了使一个纹理单元生效，使用 `glActiveTexture`。在当前配方中，加载的纹理通过纹理单元 0 (`GL_TEXTURE0`)
    使着色器可访问。将纹理绑定到这个纹理单元：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Send the texture unit ID to the fragment shader using a `glUniform1i`. In the
    fragment shader, the `Tex1` uniform variable receives this information; query
    the location of this uniform variable in order to provide the texture unit information.
    Note that `0` here is the texture unit number, not the handle of the texture:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `glUniform1i` 将纹理单元 ID 发送到片段着色器。在片段着色器中，`Tex1` 常量变量接收这个信息；查询这个常量变量的位置以提供纹理单元信息。注意，这里的
    `0` 是纹理单元号，而不是纹理句柄：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the minification, magnification, and wrapping behavior on the texture using
    `glTexParameterf`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glTexParameterf` 设置纹理的缩小、放大和包裹行为：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the current shader program and send the vertex and texture coordinate information
    to the shader to render geometry:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前着色器程序并将顶点和纹理坐标信息发送到着色器以渲染几何形状：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The GLPI framework provides a high-level PNG image parsing class called `PNGImage`;
    it internally uses the `libpng` library to parse PNG files and stores vital information
    in a local data structure. This class generates texture objects, binds them with
    an OpenGL state machine, and loads the image buffer data in it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: GLPI 框架提供了一个名为 `PNGImage` 的高级 PNG 图像解析类；它内部使用 `libpng` 库解析 PNG 文件，并将关键信息存储在本地数据结构中。这个类生成纹理对象，与
    OpenGL 状态机绑定，并在其中加载图像缓冲区数据。
- en: OpenGL ES supports texture through texture objects; these texture objects are
    prepared using the `glGenTextures` API within the `loadImage` function. This API
    generates a texture object behind the curtains and returns the (`texID`) unique
    name ID. OpenGL ES is a state machine; therefore, before applying any operation
    on a texture, it needs to set it as a current texture; this can be achieved using
    `glBindTexture`. This API will bind the `texID` to the current OpenGL ES state
    as current texture, which allows the OpenGL ES state machine to apply all texture-related
    operations to the current texture object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 通过纹理对象支持纹理；这些纹理对象是在 `loadImage` 函数中使用 `glGenTextures` API 准备的。这个 API
    在幕后生成一个纹理对象，并返回一个唯一的 (`texID`) 名称 ID。OpenGL ES 是一个状态机；因此，在纹理上应用任何操作之前，需要将其设置为当前纹理；这可以通过
    `glBindTexture` 实现。这个 API 将 `texID` 绑定到当前的 OpenGL ES 状态作为当前纹理，这使得 OpenGL ES 状态机能够将所有与纹理相关的操作应用于当前纹理对象。
- en: 'The OpenGL ES loads the texture in the form of an image buffer in its texture
    memory; this information is provided through `glTexImage2D`, which specifies the
    format of the image to the underlying programmable pipeline. The `glActiveTexture`
    API is used to bind the texture with a texture unit; the texture units in OpenGL
    ES are meant to access textures in the fragment shader. In our recipe, the loaded
    texture is attached to texture unit `0` (`GL_TEXTURE0`). The fragment uses a uniform
    `Sampler2D` data type that contains the handle of texture unit through which the
    texture is attached. The `glUniform1i` is used to send information to the sampler
    `Tex1` variable in the fragment shader:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES以图像缓冲区形式将其纹理加载到其纹理内存中；此信息通过`glTexImage2D`提供，该函数指定了底层可编程管道中图像的格式。`glActiveTexture`
    API用于将纹理绑定到纹理单元；OpenGL ES中的纹理单元旨在访问片元着色器中的纹理。在我们的菜谱中，加载的纹理附加到纹理单元`0`（`GL_TEXTURE0`）。片元使用包含通过纹理单元附加的句柄的统一`Sampler2D`数据类型。`glUniform1i`用于将信息发送到片元着色器中的`Tex1`变量：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The vertex shader has two generic attributes, namely, `VertexPosition` and `VertexTexCoord`,
    which receive the vertex coordinates and the texture coordinates. Per-vertex texture
    coordinates (received in the vertex shader) are sent to the fragment shader using
    `TexCoord`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器有两个通用属性，即`VertexPosition`和`VertexTexCoord`，它们接收顶点坐标和纹理坐标。每个顶点的纹理坐标（在顶点着色器中接收）通过`TexCoord`发送到片元着色器。
- en: The fragment shader is responsible for sampling the texture; sampling is a process
    of selecting a desire `texel` using texture coordinates; this `texel` provides
    the color information that needs to be applied to the corresponding pixel in the
    primitive. It uses the incoming per-vertex generic attribute called `TexCoord`
    to retrieve texture coordinates and a texture handle in the sampler2D. Texture
    handles allow you to access the texture from the OpenGL ES texture memory to be
    used in shaders to perform the sampling operation. The shading language provides
    a texture for sampling purposes; it uses the texture handle, which is `0` for
    this recipe, and the `TexCoord` texture coordinate.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 片元着色器负责采样纹理；采样是一个使用纹理坐标选择一个期望的`texel`的过程；这个`texel`提供了需要应用到原始图形中相应像素的颜色信息。它使用传入的每个顶点的通用属性`TexCoord`来检索纹理坐标和在采样器2D中的纹理句柄。纹理句柄允许您从OpenGL
    ES纹理内存中访问纹理，以便在着色器中执行采样操作。着色语言为采样目的提供了一个纹理；它使用纹理句柄，在这个菜谱中为`0`，以及`TexCoord`纹理坐标。
- en: '![How it works...](img/5527OT_07_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_07_02.jpg)'
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this section, we will discuss the various built-in filtering and wrapping
    techniques available in the OpenGL ES 3.0 pipeline. These techniques are applied
    through `glTexParamterf`, `glTexParameteri`, `glTexParameterf`, `glTexParameteriv`,
    or `glTexParameterfv` by specifying various symbolic constants.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论OpenGL ES 3.0管道中可用的各种内置过滤和包装技术。这些技术通过指定各种符号常量通过`glTexParamterf`、`glTexParameteri`、`glTexParameterf`、`glTexParameteriv`或`glTexParameterfv`来应用。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike texture, coordinates have the UV coordinate system; the sampling texels
    have a convention of the ST coordinate system, where S corresponds to the horizontal
    axis and T corresponds to the vertical axis. This can be used to define the filtering
    and wrapping behavior along S and T in the sampling process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与纹理不同，坐标具有UV坐标系；采样的`texel`具有ST坐标系的传统，其中S对应水平轴，T对应垂直轴。这可以用来定义采样过程中S和T方向上的过滤和包装行为。
- en: Filtering
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: The texture filtering technique allows you to control the appearance of the
    texture quality; sometimes, at correct depth, one texel corresponds to exactly
    one pixel on screen. However, in other cases, mapping a smaller texture on to
    a bigger geometry may cause the texture to appear stretched (magnification). Similarly,
    in the vice versa case, many texels are shader by a few pixels (minification).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理过滤技术允许您控制纹理质量的外观；有时，在正确的深度，一个`texel`在屏幕上正好对应一个像素。然而，在其他情况下，将较小的纹理映射到较大的几何体上可能会导致纹理看起来被拉伸（放大）。同样，在相反的情况下，许多`texel`被几个像素所着色（最小化）。
- en: 'This type of situation is called minification and magnification. Let''s look
    at them in detail:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况被称为最小化处理和放大处理。让我们详细看看：
- en: '**Minification**: This occurs when many texels exist for a few screen pixels.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化处理**：这种情况发生在几个屏幕像素对应许多texel时。'
- en: '**Magnification**: This occurs when many screen pixels exist for a few texels.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**放大**：这种情况发生在几个屏幕像素对应少数`texel`时。'
- en: 'In order to deal with minification and magnification, OpenGL ES 3.0 provides
    the following two types of filtering techniques:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理缩小和放大，OpenGL ES 3.0提供了以下两种类型的过滤技术：
- en: '`GL_NEAREST`: This uses the pixel color closest to texture coordinates'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_NEAREST`：这使用最接近纹理坐标的像素颜色'
- en: '`GL_LINEAR`: This uses the weighted average of four surrounding pixels closest
    to texture coordinates![Filtering](img/5527OT_07_03.jpg)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_LINEAR`：这使用最接近纹理坐标的四个周围像素的加权平均值![过滤](img/5527OT_07_03.jpg)'
- en: OpenGL ES 3.0 provides `GL_TEXTURE_MAG_FILTER` and `GL_TEXTURE_MIN_FILTER` as
    symbolic constants, which can be used in `glTexParamterf` as a parameter to specify
    the filtering technique on magnification and minification respectively.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0提供了`GL_TEXTURE_MAG_FILTER`和`GL_TEXTURE_MIN_FILTER`作为符号常量，可以在`glTexParameterf`中用作参数，分别指定放大和缩小时的过滤技术。
- en: Wrapping
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装
- en: 'One obvious question that comes to mind is what happens when the range of texture
    mapping is greater than 1.0; the OpenGL ES 3.0 sampling allows three types of
    wrapping mode:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显而易见的问题是，当纹理映射的范围大于1.0时会发生什么；OpenGL ES 3.0采样允许三种类型的包装模式：
- en: '`GL_REPEAT`: This produces repeating patterns'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_REPEAT`：这会产生重复图案'
- en: '`GL_MIRRORED_REPEAT`: This produces a repeating pattern where adjacent texture
    is mirrored'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_MIRRORED_REPEAT`：这会产生一个相邻纹理镜像的重复图案'
- en: '`GL_CLAMP_TO_EDGE`: This produces border edges pixels that are repeated'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_CLAMP_TO_EDGE`：这会产生重复的边缘像素'
- en: 'The following image uses 2 x 2 texture coordinates and demonstrates the use
    of wrapping modes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像使用了2 x 2纹理坐标，并演示了包装模式的使用：
- en: '![Wrapping](img/5527OT_07_04.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![包装](img/5527OT_07_04.jpg)'
- en: MIP mapping
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MIP映射
- en: This is a texture mapping technique that improves the visual output by reducing
    the aliasing effect and increases the performance of the system by reducing the
    texture bandwidth. MIP mapping uses precalculated versions as a texture (where
    each texture is half of the resolution of the previous one). An appropriate texture
    is selected at runtime according to how far away the viewer is.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种纹理映射技术，通过减少走样效应来提高视觉输出，并通过减少纹理带宽来提高系统的性能。MIP映射使用预先计算的版本作为纹理（其中每个纹理的分辨率是前一个纹理的一半）。根据观察者与纹理的距离，在运行时选择合适的纹理。
- en: 'Textures can be viewed from a far or near viewer''s distance; this changes
    the shape and size of the texture that causes the texture to undergo the minification
    and magnification artefacts. These artefacts can be minimized using the previously
    mentioned filters, but the effective result can only be produced if the texture
    size scales in a factor of half or double; beyond these scales, the filter may
    not produce pleasing results. The MIP mapping improves the quality by picking
    the correct resolution based on the viewer''s distance from the given texture.
    Not only does it improve the quality of the image by minimizing the minification/magnification
    artefacts, but it also increases the performance of the system by picking a correct
    resolution texture instead of using the full resolution image:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以从远距离或近距离的观察者处查看；这会改变纹理的形状和大小，导致纹理出现缩小和放大的伪影。这些伪影可以通过使用之前提到的过滤器来最小化，但只有在纹理大小以半或双倍的比例缩放时，才能产生有效结果。超出这些比例，过滤器可能不会产生令人满意的结果。MIP映射通过根据观察者与给定纹理的距离选择正确的分辨率来提高质量。它不仅通过最小化缩小/放大的伪影来提高图像质量，而且还通过选择正确的分辨率纹理而不是使用全分辨率图像来提高系统的性能：
- en: '![MIP mapping](img/5527OT_07_05.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![MIP映射](img/5527OT_07_05.jpg)'
- en: The `glGenerateMipmap` API can be used to generate mipmaps.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`glGenerateMipmap` API生成MIP映射。
- en: '**Syntax**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| Variable | Description |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the target type to which the texture mipmaps are
    going to generate and bound. The target must be either of `GL_TEXTURE_2D`, `GL_TEXTURE_3D`,
    `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 这指定了纹理MIP映射将要生成和绑定的目标类型。目标必须是`GL_TEXTURE_2D`、`GL_TEXTURE_3D`、`GL_TEXTURE_2D_ARRAY`或`GL_TEXTURE_CUBE_MAP`之一。
    |'
- en: The generated mipmaps can be bound to a particular level of depth using the
    `glTexImage2D` API; the second parameter of this API can be used to specify the
    level of detail. Refer to step 2 under *How to do it…* section of current recipe
    to see the full description of the `glTexImage2D` API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的MIP映射可以使用`glTexImage2D` API绑定到特定的深度级别；此API的第二个参数可以用来指定细节级别。请参阅当前配方下的“如何做……”部分的步骤2，以查看`glTexImage2D`
    API的完整描述。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Procedural texture shading with texture coordinates* recipe in
    [Chapter 6](ch06.html "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第6章](ch06.html "第6章。使用着色器")中的*使用纹理坐标进行程序纹理着色*菜谱，*使用着色器*
- en: '*Applying multiple textures*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用多个纹理*'
- en: '*Efficient rendering with the ETC2 compressed texture*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ETC2压缩纹理进行高效渲染*'
- en: Efficient rendering with the ETC2 compressed texture
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ETC2压缩纹理进行高效渲染
- en: For many reasons, compressed texture is desirable over uncompressed textures;
    the major benefit is reduced memory footprint on the device, smaller size of the
    downloadable application, and an increase in performance. The OpenGL ES 3.0 specifications
    made it compulsory for all vendors to support ETC2 and EAC texture compression
    formats. Prior to this, in OpenGL ES 2.0, texture compression was not standard,
    as a result of which various hardware specific extensions were evolved. Developers
    have to support programs of various extensions in order to achieve texture compression
    on different types of devices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多原因，压缩纹理比未压缩纹理更受欢迎；主要好处是减少了设备上的内存占用，应用程序的下载大小更小，并且性能有所提高。OpenGL ES 3.0规范要求所有供应商必须支持ETC2和EAC纹理压缩格式。在此之前，在OpenGL
    ES 2.0中，纹理压缩不是标准化的，因此出现了各种针对特定硬件的扩展。为了在不同的设备上实现纹理压缩，开发者必须支持各种扩展的程序。
- en: In this recipe, we will demonstrate ETC2, which is very famous among different
    texture compression schemes. ETC stands for **Ericson Texture Compression**, which
    is a lossy texture compression technique; this scheme supports both RGB and RGBA
    formats. Additionally, this recipe also demonstrates the new feature of OpenGL
    ES 3.0, which is capable of loading the **nonpower of two** (**NPOT**) texture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将演示非常著名的ETC2，它在不同的纹理压缩方案中都非常受欢迎。ETC代表**Ericson Texture Compression**，这是一种有损纹理压缩技术；该方案支持RGB和RGBA格式。此外，本菜谱还演示了OpenGL
    ES 3.0的新特性，能够加载**非2的幂**（**NPOT**）纹理。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The ETC2 compressed texture can be stored in two types of file formats, that
    is, KTX and `PKM`. The `KTX` file format is a standard Khronos Group compression
    format, which stores multiple textures under a single file; for example, mipmaps
    in `KTX` require only one file to contain all mipmapped textures. On the other
    hand, `PKM` is a very simple file format that stores each compressed texture as
    a separate file. Therefore, in case of mipmaps, it will generate multiple files.
    For this recipe, we will use the `PKM` file format. It consists of a header and
    is followed by the payload; the following c structure declaration describes the
    header:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ETC2压缩纹理可以存储在两种文件格式中，即KTX和`PKM`。`KTX`文件格式是一个标准的Khronos Group压缩格式，它将多个纹理存储在单个文件中；例如，`KTX`中的mipmap只需要一个文件来包含所有mipmap纹理。另一方面，`PKM`是一个非常简单的文件格式，它将每个压缩纹理存储为单独的文件。因此，在mipmap的情况下，将生成多个文件。对于本菜谱，我们将使用`PKM`文件格式。它由一个头部和一个随后的有效负载组成；以下c结构声明描述了头部：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: OpenGL ES 3.0 supports compressed textures using the `glCompressedTexImage2D`
    API.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0支持使用`glCompressedTexImage2D` API进行压缩纹理。
- en: '**Syntax**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Except the `internalFormat` and `imageSize`, most of the parameters are similar
    to glTexImage2D, which was described in the first recipe. The former is a format
    of the compressed texture and the latter specifies the image size, which is specifically
    calculated using formula. For example, in this recipe, the `internalFormat` is
    a `GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2` format, which is an RGBA. The
    `imageSize` is calculated using the *ceil(width/4) * ceil(height/4) * 8* formula,
    where width and height are the image dimensions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`internalFormat`和`imageSize`，大多数参数与`glTexImage2D`类似，这在第一道菜谱中已有描述。前者是压缩纹理的格式，后者指定了图像大小，它使用公式进行特别计算。例如，在本菜谱中，`internalFormat`是一个`GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2`格式，它是一个RGBA格式。`imageSize`使用公式`*ceil(width/4)
    * ceil(height/4) * 8*`计算，其中width和height是图像的尺寸。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the internal formation and image size calculations,
    refer to OpenGL ES 3.0 reference pages at [https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml](https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内部结构和图像大小计算的更多信息，请参阅[https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml](https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml)的OpenGL
    ES 3.0参考页面。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to program compressed textures; you can refer to
    the `CompressedTexture` sample recipe of this chapter. In this recipe, we will
    render a compressed image on to a square plane:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以编程压缩纹理；您可以参考本章的`CompressedTexture`示例食谱。在本食谱中，我们将在正方形平面上渲染压缩图像：
- en: This recipe reuses our first `SimpleTexture`; there is no change in the vertex
    or fragment shader; the code to render the square geometry has also been reused.
    For more information, refer to *Applying texture with UV mapping*.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本食谱重用了我们的第一个`SimpleTexture`；顶点或片段着色器没有变化；渲染正方形几何体的代码也已重用。有关更多信息，请参阅*使用UV映射应用纹理*。
- en: 'In order to process the compressed PKM format image, the GLPI framework provides
    a high-level helper class called `CompressImage`. This class is responsible for
    loading the compressed PKM image using the `loadImage` function. The compressed
    image can be loaded using the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理压缩的PKM格式图像，GLPI框架提供了一个名为`CompressImage`的高级辅助类。该类负责使用`loadImage`函数加载压缩的PKM图像。可以使用以下代码加载压缩图像：
- en: '[PRE24]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In `CompressedImage::loadImage`, open the compressed image and read the header
    bytes specified by the ETC2 header specification mentioned previously:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CompressedImage::loadImage`中，打开压缩图像并读取之前提到的ETC2头部规范中指定的头部字节：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Convert read bytes to the Big Endian format:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将读取的字节转换为Big Endian格式：
- en: '[PRE26]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calculate the size of the compressed image as per the specified formula mentioned
    in the *Getting ready* section of this recipe; use it to read the payload image
    buffer:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据本食谱中“准备工作”部分中提到的指定公式计算压缩图像的大小；使用它来读取有效载荷图像缓冲区：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Generate and bind the `texID` named texture and use `glCompressedTexImage2D`
    to load the compressed texture image buffer:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成并绑定名为`texID`的纹理，并使用`glCompressedTexImage2D`加载压缩纹理图像缓冲区：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `CompressedTexture` class helps in loading the PKM format ETC2 compressed
    texture images. The PKM file format is simple; the header `ETC2Header` size is
    16 bytes long and the payload is variable. The first four bytes of the header
    must be PKM and the next two bytes must be `20` to ensure the ETC2 scheme. The
    format provides the internal format of the compressed image, the next two bytes
    provide the padded dimension of the image, and the last two each byte represents
    the original dimension of the image in pixels. The internal format helps to identify
    the correct formula to calculate the size of the image:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompressedTexture`类有助于加载PKM格式ETC2压缩纹理图像。PKM文件格式很简单；头部`ETC2Header`大小为16字节，有效载荷是可变的。头部的前四个字节必须是PKM，接下来的两个字节必须是`20`以确保ETC2方案。该格式提供了压缩图像的内部格式，接下来的两个字节提供了图像填充的维度，最后两个字节分别代表图像的原始像素维度。内部格式有助于识别正确的公式来计算图像的大小：'
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, the compressed texture is loaded using the `glCompressedTexImage2D`
    OpenGL ES 3.0 API; this API will also provide a table reference for all compressed
    internal formats, which is very helpful to know the image size calculation formula,
    as mentioned in the preceding code. Refer to the previous recipe for more information
    on texture rendering using UV texture coordinates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用OpenGL ES 3.0 API的`glCompressedTexImage2D`加载压缩纹理；此API还将提供所有压缩内部格式的表格参考，这对于了解图像大小计算公式非常有帮助，如前述代码中所述。有关使用UV纹理坐标进行纹理渲染的更多信息，请参阅前面的食谱。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a variety of texture compression tools available that can be used
    for texture compression; among them, the famous tools are PVRtexTool, Mali GPU
    Texture Compression Tool, and so on. You can use them to compress a desired image
    into the PKM format.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多纹理压缩工具可供使用，可用于纹理压缩；其中，著名的工具有PVRtexTool、Mali GPU纹理压缩工具等。您可以使用它们将所需的图像压缩成PKM格式。
- en: See also
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Applying texture with UV mapping*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用UV映射应用纹理*'
- en: Applying multiple textures
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用多个纹理
- en: The multitexturing allows you to apply more than one texture on a given geometry
    to produce many interesting results; modern graphics allow you to apply multiple
    textures on to geometry by means of texture units. In this recipe, you will learn
    how to make use of multiple texture units in order to implement multitexturing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 多纹理允许您在给定的几何体上应用多个纹理，以产生许多有趣的结果；现代图形允许您通过纹理单元将多个纹理应用到几何体上。在本食谱中，您将学习如何利用多个纹理单元来实现多纹理。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is similar to our first recipe, that is, `SimpleTexture`. The only
    difference is that we will use more than one texture. Instead of using the 2D
    plane geometry, we will use a 3D cube. Additionally, there are some changes required
    in the fragment shader. We will discuss this in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方与我们的第一个配方类似，即`SimpleTexture`。唯一的区别是我们将使用多个纹理。我们不会使用2D平面几何形状，而是使用3D立方体。此外，还需要在片段着色器中进行一些更改。我们将在下一节中讨论这个问题。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This section will discuss all the important changes made to support multiple
    textures:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论为支持多个纹理所做的所有重要更改：
- en: 'Modify the fragment shader to support two given textures simultaneously; these
    two textures are referenced using the `TexFragile` and `Texwood` handles:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改片段着色器以同时支持两个给定的纹理；这两个纹理使用`TexFragile`和`Texwood`句柄引用：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a function called `loadMultiTexture`, which will be responsible for
    loading multiple textures in the `MultipleTexture` class; it must be called after
    the loading and compilation of the shader programs. In this function, query the
    location of `TexFragile` and `Texwood` uniform sampler variables:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`loadMultiTexture`的函数，该函数将负责在`MultipleTexture`类中加载多个纹理；它必须在加载和编译着色器程序之后调用。在这个函数中，查询`TexFragile`和`Texwood`均匀采样器变量的位置：
- en: '[PRE31]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Activate the texture unit `1` and load the `fragile.png` image using the PngImage''s
    class and the `loadImage` function. This takes care of creating the named texture
    ID and binds it to the current OpenGL ES state. Internally, this API uses `glGenTextures`,
    `glBindTexture`, and `glTexImage2D` to load the image; this wrapper API makes
    the job of loading images easy:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活纹理单元`1`，并使用PngImage类和`loadImage`函数加载`fragile.png`图像。这负责创建命名纹理ID并将其绑定到当前OpenGL
    ES状态。内部，此API使用`glGenTextures`、`glBindTexture`和`glTexImage2D`来加载图像；此包装API使加载图像变得容易：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set the texture filtering and wrapping properties:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置纹理过滤和包装属性：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the `TEX` location of `TexFragile`, send the texture unit information
    to the shader using the `glUniform1i` API. The Fragile.png texture can be accessed
    using texture unit `1`; therefore, send `1` as parameter in the `glUniform1i`
    API:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TexFragile`的`TEX`位置，通过`glUniform1i` API将纹理单元信息发送到着色器。可以使用纹理单元`1`访问Fragile.png纹理；因此，在`glUniform1i`
    API中将`1`作为参数发送：
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, for the second texture, that is, wooden.png, follow the same procedure
    mentioned from the third to the fifth steps:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，对于第二个纹理，即wooden.png，按照从第三步到第五步提到的相同程序进行操作：
- en: '[PRE35]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The fragment shader uses two samplers, namely `TexFragile` and `TexWood`; these
    are used to access texture images in the shader. It stores the handle of texture
    units; therefore, it's very important to query their locations from the fragment
    shader and is stored in the `TEX` and `TEX1`. Texture images are loaded in the
    OpenGL texture memory using the `PngImage::loadImage` function. For single or
    multiple textures, it's compulsory to activate texture units so that they become
    available in the shader program; the texture unit is made active using the `glActiveTexture`
    API. It accepts the handle of the texture unit as an argument. Refer to the next
    section for more information on texture units.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器使用两个采样器，即`TexFragile`和`TexWood`；这些用于在着色器中访问纹理图像。它存储纹理单元的句柄；因此，从片段着色器查询它们的地址并将其存储在`TEX`和`TEX1`中非常重要。使用`PngImage::loadImage`函数在OpenGL纹理内存中加载纹理图像。对于单个或多个纹理，必须激活纹理单元，以便它们在着色器程序中可用；使用`glActiveTexture`
    API激活纹理单元。它接受纹理单元的句柄作为参数。有关纹理单元的更多信息，请参阅下一节。
- en: The texture unit 1 is activated for the first texture object (`fragile.png`)
    and a corresponding uniform variable is set with `1` using `glUniform1i(TEX1,
    1)`. Similarly, the second texture unit (`woodenBox.png`) is activated and its
    corresponding uniform variable `TEX1` is set to value `2`. There is no special
    change required for the vertex shader because it sets clip coordinates for the
    incoming position and shares texture coordinates with the fragment shader. The
    fragment shader utilizes these texture coordinates for texture sampling from the
    available two textures; the sampling provides two color values stored in the `TextureFragile`
    and `TextureWood`; these colors are mixed together with the help of the mix GLSL
    API to produce mixed color effect; this API takes three parameters as an input.
    The first two parameters specifies the colors that need to be mixed together,
    whereas the third parameter specifies the proportion of the colors in which these
    need to be mixed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为第一个纹理对象（`fragile.png`）激活了纹理单元1，并使用`glUniform1i(TEX1, 1)`将其对应的统一变量设置为`1`。同样，第二个纹理单元（`woodenBox.png`）被激活，其对应的统一变量`TEX1`被设置为值`2`。对于顶点着色器没有特殊的要求，因为它设置了输入位置的裁剪坐标，并与片段着色器共享纹理坐标。片段着色器利用这些纹理坐标从可用的两个纹理中进行纹理采样；采样提供了存储在`TextureFragile`和`TextureWood`中的两个颜色值；这些颜色通过混合GLSL
    API混合在一起，以产生混合颜色效果；此API接受三个输入参数。前两个参数指定需要混合的颜色，而第三个参数指定这些颜色混合的比例。
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Texture units can be thought of as buffers that contain texture information
    and the number of texture units fixed; the number is very specific to the hardware
    implementation of the OpenGL ES 3.0\. This number can be checked by using the
    `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` macro. The texture object is not directly
    bound with the shader program. Instead, they are bound to the index of the texture
    unit.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将纹理单元视为包含纹理信息的缓冲区，并且纹理单元的数量是固定的；这个数字非常具体，取决于OpenGL ES 3.0的硬件实现。这个数字可以通过使用`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`宏来检查。纹理对象不是直接绑定到着色器程序上的。相反，它们绑定到纹理单元的索引上。
- en: 'In the following figure, the texture memory shows 16 texture units. Out of
    these, only three seem unoccupied (blue in color) and the rest of them are utilized
    by various texture images. Texture units are uniquely recognized by their index;
    these can be accessed in the shader program directly, thereby giving a unique
    capability of multitexturing. Texture units 1 and 2 are accessed in the fragment
    shader to produce the desired output, as shown in the following figure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，纹理内存显示了16个纹理单元。其中，只有三个看起来是空的（以蓝色表示），其余的都被各种纹理图像所占用。纹理单元可以通过它们的索引唯一识别；这些可以直接在着色器程序中访问，从而赋予多纹理的独特能力。纹理单元1和2在片段着色器中被访问，以产生如图所示所需输出：
- en: '![There''s more...](img/5527OT_07_11.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_07_11.jpg)'
- en: Implementing Skybox with seamless cube mapping
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无缝立方图映射实现天空盒
- en: Cube mapping is a texturing technique used in 3D graphics to fill the background
    of a scene with a given set of images. This technique reduces the number of objects
    required to draw a scene in order to make the scene look populated (the scene
    looks bigger). It is commonly used in gaming to render sky horizons, rooms, mountains,
    day/night effect, reflection, and refraction.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 立方图映射是一种在3D图形中使用的纹理技术，用于用给定的一组图像填充场景的背景。这项技术减少了绘制场景所需的对象数量，以使场景看起来更加拥挤（场景看起来更大）。它通常用于游戏，以渲染天空地平线、房间、山脉、昼夜效果、反射和折射。
- en: A cube map is achieved by wrapping six sets of images on six faces of the cube;
    these images perfectly stitch with each other on the edges. In the cube mapping
    technique, the viewer or camera is always in the center of the cube. When camera
    displaces in the 3D space, the cubes are also displaced with respect to it. This
    way, the camera never reaches close to any face of the cube and creates an illusion
    of a horizon that always remains at the same distance from the viewer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 立方图是通过将六组图像分别包裹在立方体的六个面上来实现的；这些图像在边缘处完美拼接。在立方图映射技术中，观察者或相机始终位于立方体的中心。当相机在三维空间中移动时，立方体也会相对于它移动。这样，相机永远不会接近立方体的任何一面，从而产生一个始终与观察者保持相同距离的地平线幻觉。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe uses six images named bottom, top, left, right, front, and back
    for each face of the cube to be mapped on, as shown in the following image. When
    these images are wrapped around the cube and viewed from inside, it produces an
    illusion of the sky environment. So far, we have already learned the mapping of
    texture on to a given geometry in our previous recipes using the UV texture coordinate
    mapping. However, OpenGL ES provides a special mapping called cube mapping; this
    mapping makes the job easier to wrap images to a cube-shaped geometry.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用六个图像（底部、顶部、左侧、右侧、前侧和后侧）为要映射的立方体每个面命名，如图所示。当这些图像围绕立方体包裹并从内部观看时，会产生天空环境的幻觉。到目前为止，我们已经在我们之前的配方中学习了如何使用UV纹理坐标映射将纹理映射到给定的几何形状。然而，OpenGL
    ES提供了一种特殊的映射称为立方体贴图；这种映射使得将图像包裹到立方体形状几何形状的工作变得更容易。
- en: 'Creating the cube map in OpenGL ES 3.0 is simple:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES 3.0中创建立方体贴图很简单：
- en: Create a texture object using `glGenTexture`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glGenTexture`创建一个纹理对象。
- en: Bind the texture using the `glBindTexture` API with the `GL_TEXTURE_CUBE_MAP`
    argument. This will help the OpenGL ES to understand the type of texture it needs
    to store.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`GL_TEXTURE_CUBE_MAP`参数的`glBindTexture` API绑定纹理。这将帮助OpenGL ES理解它需要存储的纹理类型。
- en: Load six images in the OpenGL ES texture memory, using `glTexImage2D` with `GL_CUBE_MAP_{POSITIVE,
    NEGATIVE}_{X, Y, Z}` as the target parameter:![Getting ready](img/5527OT_07_07.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glTexImage2D`和`GL_CUBE_MAP_{POSITIVE, NEGATIVE}_{X, Y, Z}`作为目标参数，在OpenGL
    ES纹理内存中加载六个图像：![准备中](img/5527OT_07_07.jpg)
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This section will describe the practical steps required to implement this recipe:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述实现此配方所需的实际步骤：
- en: Create a class called Skybox to render cube geometry; you can reuse the *Efficient
    rendering with Vertex Buffer Object* recipe from [Chapter 2](ch02.html "Chapter 2. OpenGL
    ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Skybox的类来渲染立方体几何形状；你可以重用[第2章](ch02.html "第2章。OpenGL ES 3.0基础知识")中提到的*使用顶点缓冲对象进行高效渲染*配方。
- en: 'Implement the vertex and fragment shader, as given in the following code. For
    cube mapping, we require the vertex information in the fragment shader. Therefore,
    each incoming per-vertex needs to be shared with the fragment shader:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如以下代码所示的顶点和片段着色器。对于立方体贴图，我们在片段着色器中需要顶点信息。因此，每个传入的顶点信息都需要与片段着色器共享：
- en: '| Vertex shader | Fragment shader |'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 顶点着色器 | 片段着色器 |'
- en: '| --- | --- |'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'Create a function called `createCubeMap` in the `Skybox` class and call the
    following function after the shaders are loaded and compiled:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Skybox`类中创建一个名为`createCubeMap`的函数，并在着色器加载和编译后调用以下函数：
- en: '[PRE38]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `createCubeMap` function, make the texture unit `1` active; this allows
    you to access the cube map texture from the fragment shader:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createCubeMap`函数中，使纹理单元`1`激活；这允许你从片段着色器访问立方体贴图纹理：
- en: '[PRE39]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `createCubeMap` function first loads six images using `PngImage:: loadImage`.
    This function creates the texture objects into the OpenGL ES texture memory. Only
    the first image needs to send with the `true` value in the second argument; this
    parameter will tell the function to generate the named texture (an ID is given
    to the texture object). The rest of the images will use the same texture name
    (ID); therefore, the rest must be sent with a `false` argument. If the image appears
    at the right-hand side corner of the cube box and (`Right.png`) is located at
    the positive *x* axis, then use `GL_TEXTURE_CUBE_MAP_POSITIVE_X` as the fourth
    argument. Similarly, for other images, use the appropriate argument, as shown
    in the preceding code.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createCubeMap`函数首先使用`PngImage::loadImage`加载六个图像。这个函数将纹理对象创建到OpenGL ES纹理内存中。只有第一个图像需要在第二个参数中发送`true`值；这个参数将告诉函数生成指定的纹理（给纹理对象一个ID）。其余的图像将使用相同的纹理名称（ID）；因此，其余的必须使用`false`参数发送。如果图像出现在立方体盒子的右手侧角，并且(`Right.png`)位于正*x*轴上，那么使用`GL_TEXTURE_CUBE_MAP_POSITIVE_X`作为第四个参数。同样，对于其他图像，使用适当的参数，如前述代码所示。'
- en: Set linear filtering for the minification/magnification and wrapping scheme.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置线性过滤用于缩小/放大和包装方案。
- en: Query the location of the `CubeMapTexture` uniform sampler from the fragment
    shader and set the handle of texture unit as `1`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从片段着色器查询`CubeMapTexture`统一采样器的位置，并将纹理单元句柄设置为`1`。
- en: 'Render the scene using the `Skybox::Render` function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Skybox::Render`函数渲染场景：
- en: '[PRE40]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The cubemap texturing requires six sets of 2D images; these images are mapped
    to the six faces of the cube geometry. Select a texture unit and make it active.
    In the present case, its texture unit is `1` (`GL_TEXTURE1`). Load the image using
    `PngImage::loadImage`; this function is called in the `Skybox::InitModel`. After
    the shaders are loaded, it accepts three arguments. The first argument specifies
    the image file to be loaded and the second argument decides whether to create
    a texture object or not. For example, in the case of cubemap, only the first image
    is required to create a texture object; the remaining images will share the same
    texture object. The final argument specifies the face to which the image belongs
    to in the cubemap. In this function, it creates a texture object using `glGenTexture`
    and bounds it using `glBindTexture` with the `GL_TEXTURE_CUBE_MAP` parameter.
    The `glTexImage2D` API will allocate the necessary storage space for all textures;
    this API accepts important parameters, such as `GL_TEXTURE_CUBE_MAP_POSITIVE_X`,
    `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, and so on and helps OpenGL ES to know what texture
    to apply on which surface. Share the cubemap texture stored in the texture unit
    `1` to the fragment shader.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图纹理需要六组2D图像；这些图像被映射到立方体几何的六个面上。选择一个纹理单元并使其激活。在本例中，其纹理单元为`1`（`GL_TEXTURE1`）。使用`PngImage::loadImage`加载图像；此函数在`Skybox::InitModel`中被调用。在着色器加载后，它接受三个参数。第一个参数指定要加载的图像文件，第二个参数决定是否创建纹理对象。例如，在立方体贴图的情况下，只需要第一张图像来创建纹理对象；其余的图像将共享相同的纹理对象。最后一个参数指定图像属于立方体贴图的哪个面。在此函数中，它使用`glGenTexture`创建一个纹理对象，并使用`glBindTexture`与`GL_TEXTURE_CUBE_MAP`参数将其绑定。`glTexImage2D`
    API将为所有纹理分配必要的存储空间；此API接受重要的参数，如`GL_TEXTURE_CUBE_MAP_POSITIVE_X`、`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`等，并帮助OpenGL
    ES知道在哪个表面上应用哪个纹理。将存储在纹理单元`1`中的立方体贴图纹理共享到片段着色器。
- en: In order to render the cubes, we have reused the *Efficient rendering with Vertex
    Buffer Object* recipe, [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"),
    *OpenGL ES 3.0 Essentials*. The rendering process takes place in the `Render()`
    function, the cube is scaled in order to fill up the screen and the culling and
    depth testing should be disabled.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染立方体，我们重用了[第2章](ch02.html "第2章. OpenGL ES 3.0 基础"), *《OpenGL ES 3.0 基础》*中的*使用顶点缓冲对象高效渲染*配方。渲染过程发生在`Render()`函数中，立方体被缩放以填满屏幕，并且应该禁用剔除和深度测试。
- en: From the shader's perspective, cube vertices are received in the vertex shader;
    these are shared to the fragment shader in the form of the position vector as
    the origin is at (0.0, 0.0, 0.0). The position vector turns out to be the same
    as vertex positions. This vertex position in the fragment shader is used for sampling
    purposes where the texture API is provided with the sampler and vertex position;
    it returns the corresponding color of the fragment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从着色器的角度来看，立方体顶点在顶点着色器中被接收；这些以位置向量的形式共享到片段着色器中，原点位于（0.0，0.0，0.0）。位置向量实际上与顶点位置相同。片段着色器中的这个顶点位置用于采样目的，其中纹理API提供了采样器和顶点位置；它返回片段的相应颜色。
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing reflection and refraction with environment mapping*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用环境贴图实现反射和折射*'
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第2章](ch02.html "第2章. OpenGL ES 3.0 基础"), *《OpenGL ES 3.0 基础》*中的*使用顶点缓冲对象高效渲染*配方。
- en: Implementing reflection and refraction with environment mapping
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境贴图实现反射和折射
- en: 'Environment mapping is a simple yet effective and efficient technique that
    allows you to map the surrounding environment effect to render 3D objects. There
    are two ways in which environment mapping can be used: reflection and refraction.
    In the former technique, rendered objects are mapped with the reflection of the
    surroundings, which shows the reflection of the surrounding view of objects. However,
    in the latter case, objects mapped with the refraction allow you to see through
    objects. These environment mapping techniques require cube mapping that we programmed
    in the previous recipe Skybox with seamless cube mapping. In this recipe, we will
    implement the reflection and refraction environment mapping.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 环境映射是一种简单、有效且高效的技巧，允许你将周围环境效果映射到渲染3D对象。环境映射可以使用两种方式：反射和折射。在前一种技术中，渲染的对象被映射到周围环境的反射，显示了对象的周围视图的反射。然而，在后一种情况下，通过折射映射的对象允许你透过对象看。这些环境映射技术需要我们在先前的食谱“无缝立方体贴图天空盒”中编写的立方体贴图。在本食谱中，我们将实现反射和折射的环境映射。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, we can reuse the *Implementing Skybox with seamless cube mapping*
    recipe and *Rendering the wavefront OBJ mesh model* recipes in [Chapter 5](ch05.html
    "Chapter 5. Light and Materials"), *Working with Meshes*. The former recipe does
    not require any special changes. However, we will program a new shader for the
    latter case.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们可以重用[第5章](ch05.html "第5章。光和材料")中“*实现无缝立方体贴图天空盒*”和“*渲染wavefront OBJ网格模型*”的食谱。前者不需要任何特殊更改。然而，我们将为后者编写一个新的着色器。
- en: 'Reflection is a phenomenon in which light/wave changes its direction when it
    interacts with other mediums. As a result, it bounces back to the same medium
    from which it was coming from. The angle of incidence of the light is always equal
    to the angle of reflection after bouncing, as shown in the following figure:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一种现象，当光/波与其他介质相互作用时，会改变其方向。结果，它从它来的相同介质弹回。光线入射角在弹跳后始终等于反射角，如下面的图所示：
- en: '![Getting ready](img/5527OT_07_08.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5527OT_07_08.jpg)'
- en: Refraction is a phenomenon that bends the direction of the wave/light through
    the transmission medium in which it is traveling. The reason for this bending
    is the difference between the optical densities of these two mediums. For example,
    a straw in a glass of water appears bent because light travels at different speeds
    in the given medium/material, such as air and water. This characteristic of the
    medium or material that affects the speed of light is called the refractive index.
    The refractive index of a medium tells us how fast the light travels in a given
    medium; it's the ratio of the speed of light in vacuum (c) to the speed of light
    in that medium (v), *n=c/v*, therefore, the bending of the light is determined
    by its refractive index.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 折射是一种现象，当波/光通过其传播的传输介质时，会改变其方向。这种弯曲的原因是这两种介质的光学密度之间的差异。例如，一根放在水杯中的吸管看起来是弯曲的，因为光在给定介质/材料（如空气和水）中的传播速度不同。这种影响光速的介质或材料的特性称为折射率。介质的折射率告诉我们光在给定介质中的传播速度；它是光在真空中的速度（c）与在该介质中的速度（v）的比值，*n=c/v*，因此，光的弯曲由其折射率决定。
- en: Snell's law gives the relation between the refractive index and the direction
    of propagation. Mathematically, *n1.sinθ1 = n2.sinθ2*. As per this law, the ratio
    of the sine angle of incidence and refraction (*sinθ1/sinθ2*) is equivalent to
    the opposite ratio of refractive index of the mediums (*n2/n1*).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 斯涅尔定律给出了折射率与传播方向之间的关系。数学上，*n1.sinθ1 = n2.sinθ2*。根据此定律，入射角的正弦与折射角的正弦之比（*sinθ1/sinθ2*）等于介质折射率之比的倒数（*n2/n1*）。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this section, you will learn the step-by-step procedure to program environment
    mapping for reflection and refraction:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习逐步编写环境映射以实现反射和折射的程序：
- en: 'The surrounded environment required in environment mapping is created using
    the cube mapped Skybox from the previous recipe in this chapter. Inside the Skybox
    simple 3D waveform, objects are rendered (refer to the *Rendering the wavefront
    OBJ mesh model* recipe [Chapter 5](ch05.html "Chapter 5. Light and Materials"),
    *Working with Meshes*). Add the `Skybox` and the `ObjLoader` model in the `createModels`
    function and include the required headers:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境映射所需的环境是通过本章先前的配方中使用的立方体贴图Skybox创建的。在Skybox内部，简单的3D波形，对象被渲染（参考*渲染波前OBJ网格模型*配方[第5章](ch05.html
    "第5章。光和材料"), *与网格一起工作*)。在`createModels`函数中添加`Skybox`和`ObjLoader`模型，并包含所需的头文件：
- en: '[PRE41]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Skybox model is responsible for rendering the Skybox environment using the
    cube mapped texture; there is no change required for shader programs. The cube
    mapped texture is stored in the texture unit `1`.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Skybox模型负责使用立方体贴图纹理渲染Skybox环境；着色器程序不需要更改。立方体贴图纹理存储在纹理单元`1`。
- en: The ObjLoader model renders mesh objects and uses the texture unit `1` (containing
    the cube mapped texture) to apply the reflection and refraction mapping.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ObjLoader模型渲染网格对象，并使用包含立方体贴图纹理的纹理单元`1`来应用反射和折射映射。
- en: 'Define new shader programs (`ReflectionVertex.glsl`) for the vertex shader:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新的着色器程序（`ReflectionVertex.glsl`）用于顶点着色器：
- en: '[PRE42]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the following code reflection mapping fragment shader in `ReflectionFragment.glsl`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ReflectionFragment.glsl`中使用以下代码反射映射片段着色器：
- en: '[PRE43]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, for refraction, reuse the preceding reflection shader and define
    a uniform float variable for the refraction index called `RefractIndex`. Additionally,
    replace the GLSL `reflect` API with the refract API and rename the `reflectedDirection`
    with `refractedDirection`:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，对于折射，重用前面的反射着色器，并定义一个名为`RefractIndex`的折射指数统一浮点变量。此外，用折射API替换GLSL `reflect`
    API，并将`reflectedDirection`重命名为`refractedDirection`：
- en: '[PRE44]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create `RefractionFragment.glsl` and reuse the code from `ReflectionFragment.glsl`;
    the only change required is renaming the incoming shared attribute called `reflectedDirection`
    with `refractedDirection`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`RefractionFragment.glsl`并重用`ReflectionFragment.glsl`中的代码；所需更改仅是将传入的共享属性`reflectedDirection`重命名为`refractedDirection`。
- en: 'Load and compile the shader in the `ObjLoader::InitModel` function and initialize
    all uniform variables required by the reflection and refraction shaders. Set the
    current texture in `CubeMap` from the texture unit `1` as it contains the cube
    mapped texture. Note that this texture unit was loaded from the Skybox model class:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ObjLoader::InitModel`函数中加载和编译着色器，并初始化反射和折射着色器所需的所有统一变量。将当前纹理`CubeMap`从纹理单元`1`设置为它包含立方体贴图纹理。请注意，此纹理单元是从Skybox模型类加载的：
- en: '[PRE45]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The working model of the reflection and refraction environment mapping is very
    similar; both use the cube map texturing to produce the reflection and refraction
    effect. The following image shows the logic behind this working model. Here, the
    top view of the cube map is represented with a green rectangle and all the labeled
    edges are faces of the cube. The camera position is depicted by an eye, which
    looks toward the sphere direction that are placed inside the cube map Skybox.
    Each vertex position produces an incident ray from the camera position, which
    is used with the normal vector at the vertex position to calculate the reflected
    vector. This reflected vector is used with the cube-mapped texture to look up
    the corresponding texel. For example, in the following image, the vertex v1, v2,
    and v3 after reflection corresponds to the right, back and left face of the cube
    map. Similarly, refracted rays correspond to the front face of the cube map:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 反射和折射环境映射的工作模型非常相似；两者都使用立方体贴图纹理来产生反射和折射效果。以下图像展示了这种工作模型的逻辑。在这里，立方体贴图的上视图用绿色矩形表示，所有标记的边缘都是立方体的面。摄像机位置用一个眼睛表示，它朝向放置在立方体贴图Skybox内部的球体方向。每个顶点位置从摄像机位置产生一个入射光线，该光线与顶点位置的法向量一起用于计算反射向量。这个反射向量与立方体贴图纹理一起用于查找相应的texel。例如，在以下图像中，反射后的顶点v1、v2和v3对应于立方体贴图的右面、后面和左面。同样，折射光线对应于立方体贴图的前面：
- en: '![How it works...](img/5527OT_07_09.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_07_09.jpg)'
- en: The reflected and refracted positional vector is calculated in the vertex shader;
    these vectors are shared with the fragment shader, where the cubemap texture is
    used to look up the texel for the corresponding texture.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 反射和折射的位置向量在顶点着色器中计算；这些向量与片段着色器共享，其中使用立方图纹理查找相应的texel。
- en: Now, we know that the working of the environment mapping is at a higher level;
    let's understand the code for reflection environment mapping. The vertex shader
    calculates the world position of each vertex position (`VertexPosition`) and normal
    vector (Normal) in the world coordinate using the model matrix (`MODELMATRIX`)
    and stores it in `worldCoordPosition` and `worldCoordNormal` respectively. The
    incident ray for each vector with respect to camera position is calculated and
    stored in the `incidenceRay`. The OpenGL ES shading language provides a high level
    `reflect()` API to calculate the reflected vector. This API takes an incident
    ray, normal vector, and returns the reflected vector.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道环境映射的工作在更高层次；让我们了解反射环境映射的代码。顶点着色器使用模型矩阵（`MODELMATRIX`）在全局坐标中计算每个顶点位置（`VertexPosition`）和法线向量（`Normal`），并将其分别存储在`worldCoordPosition`和`worldCoordNormal`中。根据相机位置计算每个向量的入射光线并存储在`incidenceRay`中。OpenGL
    ES着色语言提供了一个高级的`reflect()` API来计算反射向量。此API接受入射光线、法线向量，并返回反射向量。
- en: '**Syntax**:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| Variable | Description |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `I` | This is the incidence ray from coming from source to destination |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `I` | 这是来自源到目的地的入射光线 |'
- en: '| `N` | This is the normal of the surface |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 这是表面的法线 |'
- en: '| `Return` | This is the reflected vector given by *I - 2.0 * dot(N, I) *N*
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `Return` | 这是通过 *I - 2.0 * dot(N, I) *N* 给出的反射向量 |'
- en: The reflected vector is shared with the fragment shader using an out variable
    called reflected direction. The fragment shader uses this vector to find the corresponding
    texel in the cube map using the `texture()` API.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 反射向量通过一个名为反射方向的输出变量与片段着色器共享。片段着色器使用此向量通过`texture()` API在立方图中查找相应的texel。
- en: '![How it works...](img/5527OT_07_10.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_07_10.jpg)'
- en: Similarly, the refraction is calculated using the `refract()` GLSL API; unlike
    the reflect API, this accepts an additional parameter called refract index of
    the material and returns the refracted vector.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，折射是通过`refract()` GLSL API计算的；与反射API不同，它接受一个额外的参数，即材料的折射率，并返回折射向量。
- en: '**Syntax**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE47]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| Variable | Description |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `I` | This is the incidence ray from coming from source to destination |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `I` | 这是来自源到目的地的入射光线 |'
- en: '| `N` | This is the normal of the surface |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 这是表面的法线 |'
- en: '| `RI` | This is the refractive index of the medium |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `RI` | 这是介质的折射率 |'
- en: '| `Return` | This is the refracted vector |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `Return` | 这是折射向量 |'
- en: The refracted vector is shared with the fragment shader using `refractedDirection`.
    The texel color is calculated for the corresponding fragment.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 折射向量通过`refractedDirection`与片段着色器共享。为相应的片段计算texel颜色。
- en: See also
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing Skybox with seamless cube mapping*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现无缝立方映射的天空盒*'
- en: Refer to the *Rendering the wavefront OBJ mesh model* recipe in [Chapter 4](ch04.html
    "Chapter 4. Working with Meshes"), *Working with Meshes*
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第4章](ch04.html "第4章. 处理网格")中的*渲染波前OBJ网格模型*配方，*处理网格*
- en: Implementing render to texture with Frame Buffer Objects
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用帧缓冲对象实现渲染到纹理
- en: OpenGL ES renders a scene on framebuffer; this framebuffer is called the default
    framebuffer. A framebuffer consist of various buffers, such as color, depth, and
    the stencil buffer. **Frame Buffer Objects** (**FBO**) allows you to create user-defined
    framebuffers, which can be used to render scenes on non-default framebuffers.
    The rendered scene on the nondefault framebuffer can be used as a texture to map
    objects. In this recipe, we will demonstrate render to texture in which a scene
    is rendered to a texture and this texture is mapped to a 2D plane surface; the
    2D plane can be rotated in a 3D space using touch gesture events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES在帧缓冲上渲染场景；这个帧缓冲被称为默认帧缓冲。帧缓冲由各种缓冲区组成，例如颜色、深度和模板缓冲区。**帧缓冲对象**（**FBO**）允许您创建用户定义的帧缓冲区，可用于在非默认帧缓冲区上渲染场景。在非默认帧缓冲区上渲染的场景可以用作纹理来映射对象。在本配方中，我们将演示渲染到纹理，其中场景被渲染到纹理，并将此纹理映射到二维平面表面；二维平面可以使用触摸手势事件在三维空间中旋转。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The detailed procedure to implement the render to texture recipe using FBO
    is as follows. We will reuse the *Generating the polka dot pattern* recipe from
    [Chapter 6](ch06.html "Chapter 6. Working with Shaders"), *Working with Shaders*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FBO实现渲染到纹理的详细步骤如下。我们将重用[第6章](ch06.html "第6章。使用着色器")中*使用着色器*的*生成圆点图案*配方：
- en: 'Create a `DemoFBO` class derived from the `Model` base class and add `SimpleTexture`
    and `ObjLoader` pointer objects; initialize these objects in the constructor of
    `DemoFBO`. For more information on dependent recipes, refer to the *See also*
    subsection in this recipe:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`Model`基类派生的`DemoFBO`类，并添加`SimpleTexture`和`ObjLoader`指针对象；在`DemoFBO`的构造函数中初始化这些对象。有关依赖配方的信息，请参阅本配方中的*也见*子节：
- en: '[PRE48]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define the `generateTexture` function; this function is responsible for generating
    the color or depth texture depending on the (`isDepth`) Boolean argument passed
    to it:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`generateTexture`函数；此函数负责根据传递给它的(`isDepth`)布尔参数生成颜色或深度纹理：
- en: '[PRE49]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define the `GenerateFBO` and use the following code. This function is responsible
    for generating the FBO; it uses the color buffer and the depth buffer from the
    framebuffer. This recipe also contains the `GenerateFBOWithRenderBuffer` alternate
    function, which uses Render buffer''s depth buffer to create FBO. For more information,
    refer to *There''s more…* subsection in this recipe:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`GenerateFBO`并使用以下代码。此函数负责生成FBO；它使用帧缓冲区中的颜色缓冲区和深度缓冲区。此配方还包含`GenerateFBOWithRenderBuffer`备用函数，它使用渲染缓冲区的深度缓冲区来创建FBO。有关更多信息，请参阅本配方中的*更多内容*子节：
- en: '[PRE50]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the `InitModel` function and initialize the Polka dots and simple texture
    classes. Also, generate the FBO using the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`InitModel`函数并初始化圆点和简单纹理类。此外，使用以下代码生成FBO：
- en: '[PRE51]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `Render()` function, render the polka dots in the FBO texture and map
    this texture to the 2D plane:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Render()`函数中，渲染FBO纹理中的圆点并将其映射到2D平面上：
- en: '[PRE52]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Shader programs can be reused completely without any changes. The only exception
    being that we rename shader from `SimpleTexture` to FBO.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序可以完全重用，无需任何更改。唯一的例外是我们将着色器从`SimpleTexture`重命名为FBO。
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The final destination of all the rendering commands in the rendering pipeline
    is the default framebuffer; OpenGL ES 3.0 provides means to create additional
    framebuffers using FBO. FBO allows you to render a scene directly to a texture,
    which can be used like any other texture for mapping purposes. It can also be
    used for post processing of a scene. Similar to the default framebuffer, FBO also
    contains color, depth, and stencil buffers; these buffers are accessed through
    the (`GL_COLOR_ATTACHMENT0..N`, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT`)
    attachment points, as shown in the following image given in the *There's more…*
    section..
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管线中所有渲染命令的最终目的地是默认帧缓冲区；OpenGL ES 3.0提供了使用FBO创建附加帧缓冲区的手段。FBO允许您直接将场景渲染到纹理中，这可以像任何其他纹理一样用于映射目的。它还可以用于场景的后处理。类似于默认帧缓冲区，FBO也包含颜色、深度和模板缓冲区；这些缓冲区通过(`GL_COLOR_ATTACHMENT0..N`、`GL_DEPTH_ATTACHMENT`、`GL_STENCIL_ATTACHMENT`)附加点访问，如*更多内容*部分所示的下图中所示。
- en: First, like any other buffer object in OpenGL ES, create an FBO and bind it
    using `glGenFramebuffer` and `glBindFrameBuffer`. Use the `generateTexture` function
    and create an empty 256 x 256 color and depth buffer texture object and store
    the handles in `textureId` and `depthTextureId` respectively. The FBO implementation
    of OpenGL ES 3.0 allows one color buffer and one depth buffer, which can be attached
    to the FBO, using the `glFramebufferTexture2D` API; more color buffers may be
    defined depending on the OpenGL ES Driver implementation. This is defined via
    the macro `MAX_COLOR_ATTACHMENTS`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像OpenGL ES中的任何其他缓冲对象一样，创建一个FBO并使用`glGenFramebuffer`和`glBindFrameBuffer`将其绑定。使用`generateTexture`函数创建一个空的256
    x 256颜色和深度缓冲纹理对象，并将句柄分别存储在`textureId`和`depthTextureId`中。OpenGL ES 3.0的FBO实现允许一个颜色缓冲区和一个深度缓冲区，可以使用`glFramebufferTexture2D`
    API将其附加到FBO；更多的颜色缓冲区可能取决于OpenGL ES驱动程序的实现。这通过宏`MAX_COLOR_ATTACHMENTS`定义。
- en: 'The `glFramebufferTexture2D` API attaches the handle of the created color and
    depth buffer:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`glFramebufferTexture2D` API将创建的颜色和深度缓冲区的句柄附加：'
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Syntax**:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| Variables | Description |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the framebuffer target and should be `GL_FRAMEBUFFER`,
    `GL_DRAW_FRAMEBUFFER`, or `GL_READ_FRAMEBUFFER`. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 这指定了帧缓冲区目标，应该是`GL_FRAMEBUFFER`、`GL_DRAW_FRAMEBUFFER`或`GL_READ_FRAMEBUFFER`。
    |'
- en: '| `attachment` | This specifies the framebuffer target. For this recipe, it
    should be `GL_COLOR_ATTACHMENT0` for the color buffer and `GL_DEPTH_ATTACHMENT`
    for the depth buffer. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `attachment` | 这指定了帧缓冲区目标。对于这个配方，它应该是颜色缓冲区的`GL_COLOR_ATTACHMENT0`和深度缓冲区的`GL_DEPTH_ATTACHMENT`。|'
- en: '| `textarget` | This specifies the 2D texture target, which in the present
    case is `GL_TEXTURE_2D`. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `textarget` | 这指定了2D纹理目标，在本例中是`GL_TEXTURE_2D`。|'
- en: '| `texture` | This specifies the handle of the texture buffer. In the current
    recipe, it should be `textureID` for the color buffer and `depthTextureId` for
    the depth buffer. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `texture` | 这指定了纹理缓冲区的句柄。在当前配方中，它应该是颜色缓冲区的`textureID`和深度缓冲区的`depthTextureId`。|'
- en: '| `level` | This specified the Mipmap level. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `level` | 这指定了Mipmap级别。|'
- en: Check the status of the created framebuffer using the `glCheckFramebufferStatus`
    API; this API must return `GL_FRAMEBUFFER_COMPLETE` if the framebuffer is created
    successfully.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glCheckFramebufferStatus` API检查创建的帧缓冲区的状态；如果帧缓冲区创建成功，此API必须返回`GL_FRAMEBUFFER_COMPLETE`。
- en: Now, we have an FBO with the color and depth buffer attached; the second thing
    we need to do is to render the scene to this texture. For this, we need to redirect
    the rendering command to our FBO instead of a default framebuffer. We need to
    query the handle of the default framework using `glGetIntergerv` with the `GL_FRAMEBUFFER_BINDING`
    parameter and store it in `currentFbo`; we will use this handle to restore the
    default framebuffer once the render to texture operation is accomplished. Bind
    the rendering pipeline with the `fboID` frame buffer object handle using `glBindFramebuffer`.
    Prepare the viewport and clear the color and depth buffer of the FBO using `glViewPort`
    and `glClearColor` APIs respectively. Finally, rendering the Polka dots will redirect
    all the procedural texture-patterned meshes to our `textureId` FBO color texture
    object. After the rendering is completed, restore the default framebuffer by binding
    its handle to the rendering pipeline using `glBindFramebuffer` with `CurrentFbo`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有一个带有颜色和深度缓冲区的FBO；接下来我们需要做的是将场景渲染到这个纹理上。为此，我们需要将渲染命令重定向到我们的FBO而不是默认帧缓冲区。我们需要使用`glGetIntegerv`函数和`GL_FRAMEBUFFER_BINDING`参数查询默认框架的句柄，并将其存储在`currentFbo`中；我们将使用这个句柄在渲染到纹理操作完成后恢复默认帧缓冲区。使用`glBindFramebuffer`函数绑定渲染管线与`fboID`帧缓冲区对象句柄。使用`glViewPort`和`glClearColor`
    API分别准备视口并清除FBO的颜色和深度缓冲区。最后，渲染波点将所有程序纹理图案网格重定向到我们的`textureId` FBO颜色纹理对象。渲染完成后，通过使用`glBindFramebuffer`函数并将句柄绑定到渲染管线中的`CurrentFbo`来恢复默认帧缓冲区。
- en: 'The third important thing is to use the (`textureId`) FBO texture and apply
    it to this 2D square; this process of applying texture is similar to our first
    recipe, that is, simple texture; the only difference here is that instead of a
    static texture, we will use the FBO texture. As we have switched to the default
    buffer, we need to set the viewport and clear the color and depth buffer. Set
    the active texture unit ID to `0` using `glActiveTexture` with the `GL_TEXTURE0`
    parameter or make sure that this texture unit is the same as what is sent to the
    fragment shader. Finally, render the square geometry and see the render to texture
    in action:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第三件重要的事情是使用（`textureId`）FBO纹理并将其应用到这个2D正方形上；这个过程与我们的第一个配方类似，即简单的纹理；这里唯一的区别是，我们不会使用静态纹理，而是使用FBO纹理。因为我们已经切换到默认缓冲区，所以我们需要设置视口并清除颜色和深度缓冲区。使用`glActiveTexture`函数和`GL_TEXTURE0`参数将活动纹理单元ID设置为`0`，或者确保这个纹理单元与发送到片段着色器的相同。最后，渲染正方形几何形状，看看渲染到纹理的效果：
- en: '![How it works...](img/5527OT_07_12.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_07_12.jpg)'
- en: Make sure that the FBO is deleted using the `glDeleteFramebuffers` API when
    it's not required by any application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在不需要时使用`glDeleteFramebuffers` API删除FBO。
- en: There's more...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The current FBO recipe uses the depth buffer from the `Texture` object. Alternatively,
    we can also use the depth buffer of the render buffer for this purpose. The render
    buffer is a special OpenGL ES object used with the FBO that allows you to render
    off screen; it renders the scene directly to the render buffer object instead
    of a texture object. The render buffer can only store a single image in its internal
    format.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当前FBO配方使用来自`Texture`对象的深度缓冲区。作为替代，我们也可以使用渲染缓冲区的深度缓冲区来完成这个目的。渲染缓冲区是一个特殊的OpenGL
    ES对象，与FBO一起使用，允许你在屏幕外进行渲染；它将场景直接渲染到渲染缓冲区对象而不是纹理对象。渲染缓冲区只能在其内部格式中存储单个图像。
- en: 'In the following code, we will see how we can use the render buffer''s depth
    buffer instead of using the depth buffer from the texture object; the process
    of creating an FBO object and attaching with the color buffer of texture images
    is the same as described in the previous section:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将看到如何使用渲染缓冲区的深度缓冲区而不是使用纹理对象的深度缓冲区；创建 FBO 对象并与纹理图像的颜色缓冲区附加的过程与上一节中描述的相同：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The render buffer is created using `glGenRenderBuffers`, this API returns a
    non-zero value when a **Render** **Buffer Objects** (**RBO**) is created successfully.
    Unlike the other OpenGL ES objects also need to be bound first before using it
    with the help of the `glBindRenderBuffer` API. The created object is empty. Therefore,
    it's allocated to the memory space using the `glRenderbufferStorage` API; this
    API takes four arguments. The first argument specifies the target of the allocation
    (which is `GL_RENDERBUFFER`), the second argument is the internal format render
    buffer image (which may be a color-renderable, depth-renderable, or stencil-renderable
    format). For this recipe, we will use the depth renderable format. The last two
    parameters are used to specify the dimensions of the render buffer.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染缓冲区是通过 `glGenRenderBuffers` 创建的，此 API 在成功创建 **渲染** **缓冲区对象**（**RBO**）时返回非零值。与其它
    OpenGL ES 对象一样，在使用之前也需要先绑定，这可以通过 `glBindRenderBuffer` API 实现。创建的对象是空的。因此，它使用 `glRenderbufferStorage`
    API 分配到内存空间；此 API 需要四个参数。第一个参数指定了分配的目标（即 `GL_RENDERBUFFER`），第二个参数是内部格式渲染缓冲区图像（可能是一个可渲染颜色、深度或模板的格式）。对于此配方，我们将使用深度可渲染格式。最后两个参数用于指定渲染缓冲区的尺寸。
- en: '**Syntax**:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Finally, the `glFramebufferRenderbuffer` API helps the RBO depth buffer to attach
    to the FBO depth attachment point. The first parameter of this API specifies the
    framebuffer target, which should be `GL_FRAMEBUFFER` in this case. The second
    argument is the attachment point of the FBO; as we want to attach to the depth
    attachment point, it should be `GL_DEPTH_ATTACHMENT`. The third argument specifies
    the render buffer target and must be `GL_RENDERBUFFER`. The last argument specifies
    the handle of the `rboId` render buffer object. When RBO is no longer in need,
    it can be deleted using `glDeleteRenderbuffers`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`glFramebufferRenderbuffer` API 帮助 RBO 深度缓冲区附加到 FBO 深度附加点。此 API 的第一个参数指定了帧缓冲区目标，在这种情况下应该是
    `GL_FRAMEBUFFER`。第二个参数是 FBO 的附加点；因为我们想要附加到深度附加点，所以它应该是 `GL_DEPTH_ATTACHMENT`。第三个参数指定了渲染缓冲区目标，必须是
    `GL_RENDERBUFFER`。最后一个参数指定了 `rboId` 渲染缓冲区对象的句柄。当 RBO 不再需要时，可以使用 `glDeleteRenderbuffers`
    删除它。
- en: '**Syntax**:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![There''s more...](img/5527OT_07_13.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_07_13.jpg)'
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Applying* *texture* *with UV mapping*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用* *UV贴图纹理*'
- en: Refer to the *Generating the polka dot pattern* recipe in [Chapter 6](ch06.html
    "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 [6章](ch06.html "第6章。使用着色器") 中 *生成圆点图案* 的配方，*使用着色器*
- en: Implementing terrain with displacement mapping
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位移贴图实现地形
- en: The displacement map technique modifies the surface of a geometric shape using
    procedural texture or texture image. This recipe uses the texture image called
    height maps to implement a geographical terrain surface on a 2D plane. A height
    map is a grayscale image where each texel stores the elevation information in
    the range of 0.0 to 1.0 (white is mapped to 1.0 and black is mapped to 0.0). The
    2D plane is represented by a set of vertices arranged in a grid fashion; the elevation
    information for each vertex in this 3D grid space is read from the height map.
    This recipe uses another texture image, which is used to map the grass texture
    on the generated terrain, to make it more realistic.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 位移贴图技术使用程序纹理或纹理图像修改几何形状的表面。此配方使用名为高度图的纹理图像在二维平面上实现地形表面。高度图是一个灰度图像，其中每个 texel
    存储了 0.0 到 1.0 范围内的海拔信息（白色映射到 1.0，黑色映射到 0.0）。二维平面由一组以网格方式排列的顶点表示；此 3D 网格空间中每个顶点的海拔信息是从高度图中读取的。此配方还使用另一个纹理图像，用于将草地纹理映射到生成的地面上，使其更加逼真。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps to implement the displacement mapping height field
    recipe:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现位移贴图高度场配方：
- en: 'Create a `HeightField` class and declare the following member variables in
    it:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `HeightField` 类并在其中声明以下成员变量：
- en: '[PRE58]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Define the parameterize constructor; the first argument specifies the parent
    of the `HeightField` class, the next two parameters define the dimensions of the
    terrain, and the final two parameters specify the row and column used to create
    the vertex grid for the terrain plane.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义参数化构造函数；第一个参数指定`HeightField`类的父类，接下来的两个参数定义地形的维度，最后的两个参数指定用于创建地形平面顶点网格的行和列。
- en: 'In this function, load the `HeightMap.png` and `grass.png` textures for the
    displacement mapping and texture mapping respectively; this will generate two
    texture objects. We are interested only in the front face of the terrain; the
    total number of faces will be the product of the rows and columns. Allocate the
    memory space for the total number of vertices (`v`), normals (`n`), texture coordinates
    (`tex`), and populate them with their respective information. Calculate vertex
    coordinates using the dimension argument; the normal information is assumed to
    be a positive unit vector along the *y* axis for each vertex. Assign texture coordinates
    for each vertex in the grid plane. Finally, use this populated buffer information
    to generate the VBO and IBO:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，加载`HeightMap.png`和`grass.png`纹理分别用于位移映射和纹理映射；这将生成两个纹理对象。我们只对地形的正面感兴趣；面的总数将是行和列的乘积。为总数量的顶点（`v`）、法线（`n`）、纹理坐标（`tex`）分配内存空间，并用它们各自的信息填充它们。使用维度参数计算顶点坐标；假设每个顶点的法线信息是沿*y*轴的正单位向量。为网格平面中的每个顶点分配纹理坐标。最后，使用这个填充的缓冲区信息生成VBO和IBO：
- en: '[PRE59]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `initModel` function, link and compile the vertex and fragment shader.
    Activate texture units and bind it with the height map and grass texture objects.
    The height map texture is used by the vertex shader to read the elevation information
    for each vertex. However, the grass texture is used in the fragment shader to
    paint the geometric surface. The vertex shader uses a `heightFactor` uniform variable
    to control the elevation value for each vertex:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initModel`函数中，链接和编译顶点着色器和片段着色器。激活纹理单元并将其与高度图和草地纹理对象绑定。高度图纹理由顶点着色器用于读取每个顶点的海拔信息。然而，草地纹理在片段着色器中用于绘制几何表面。顶点着色器使用一个`heightFactor`统一变量来控制每个顶点的海拔值：
- en: '[PRE60]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create the `HeightFldVertex.glsl` vertex shader and add the following code.
    In this shader, use texture coordinates and read the elevation information for
    each vertex from the height map texture stored in the `HeightMapTexture`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`HeightFldVertex.glsl`顶点着色器并添加以下代码。在这个着色器中，使用纹理坐标并从存储在`HeightMapTexture`中的高度图纹理中读取每个顶点的海拔信息：
- en: '[PRE61]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Similarly, for the `HeightFldFragment.glsl` fragment shader, add the following
    code. Make use of texture coordinates and map the grass texture from the `ImageGrassTexture`
    texture unit to the surface of the terrain:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，对于`HeightFldFragment.glsl`片段着色器，添加以下代码。利用纹理坐标并将`ImageGrassTexture`纹理单元中的草地纹理映射到地形表面：
- en: '[PRE62]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the `Renderer.cpp`, add the `HeightField` model, as shown in the following
    code; the model is `5` units in horizontal and vertical dimensions and contains
    `50` rows and columns:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Renderer.cpp`中添加`HeightField`模型，如下所示；该模型在水平和垂直维度上为`5`个单位，包含`50`行和列：
- en: '[PRE63]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following image shows the working of displacement mapping that renders
    the dummy geographical terrain. In this simple example, we assumed the terrain
    plane with dimension as 1 x 1 units with three rows and columns, resulting in
    a 3 x 3 vertex grid. Vertex positions are calculated in such a way that the origin
    always resides in the center; all vertex elevations by default are at 0.0\. The
    vertex shader is responsible for calculating the elevation for each given vertex
    using the gray scale height map texture. This texture is loaded and accessed using
    the `HeightMapTexture` texture unit (image part **A**), the height information
    is read using the `TexCoords` texture coordinate (image part **D**) from the height
    map and is assigned to elevation coordinates (image part **B: H0**, **H1\. . .
    H8**). Finally, the output of the displacement mapping looks like part **C**,
    as shown in the following image. This is the screenshot of the practical recipe,
    in which the terrain is 5 x 5 wide and contains 50 x 50 rows and columns.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '以下图像显示了位移贴图的工作原理，它渲染了虚拟的地理地形。在这个简单的例子中，我们假设地形平面具有1 x 1单位的尺寸，有三行和三列，从而产生一个3
    x 3的顶点网格。顶点位置是计算得，使得原点始终位于中心；所有顶点的高度默认为0.0。顶点着色器负责使用灰度高度图纹理计算每个给定顶点的高度。这个纹理是通过`HeightMapTexture`纹理单元（图像部分**A**）加载和访问的，高度信息是通过`TexCoords`纹理坐标（图像部分**D**）从高度图中读取的，并分配给高度坐标（图像部分**B:
    H0**，**H1...H8**）。最后，位移贴图的输出看起来像以下图像中的部分**C**。这是实际配方的截图，其中地形宽度为5 x 5，包含50 x 50行和列。'
- en: 'In the fragment shader, the grass image texture is applied to the surface of
    the terrain geometry with the help of a simple texture mapping technique; this
    makes the geometry more realistic. The image parts **D**, **E**, and **F** show
    the output of the fragment shader:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，使用简单的纹理映射技术将草地图像纹理应用到地形几何体的表面上；这使得几何体更加逼真。图像部分**D**，**E**和**F**显示了片段着色器的输出：
- en: '![How it works...](img/5527OT_07_14.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_07_14.jpg)'
- en: See also
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第2章](ch02.html "第2章。OpenGL ES 3.0基础知识")中的*使用顶点缓冲对象高效渲染*配方，*OpenGL ES 3.0基础知识*
- en: Refer to the *Managing VBO with Vertex Array Objects* recipe in [Chapter 3](ch03.html
    "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL ES 3.0*
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第3章](ch03.html "第3章。OpenGL ES 3.0的新特性")中的*使用顶点数组对象管理VBO*配方，*OpenGL ES 3.0新特性*
- en: Implementing bump mapping
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现凹凸贴图
- en: The bump mapping technique is a very efficient technique as compared to displacement
    mapping. This technique is also used to add depth details or elevations to the
    surface of the geometry. However, this depth or elevation is fake. The geometry
    vertices do not undergo any change in the elevation. Instead, it uses the light
    illumination to simulate the depth appearance on a smooth surface. Light illumination
    uses the vertex normal information stored in normal maps to add depth. Like height
    maps, which store the height or elevation information, the normal map stores normal
    information. The idea in normal maps is to avoid calculation of normal maps for
    each triangular face; these can be sampled from the texture.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 与位移贴图相比，凹凸贴图技术是一种非常高效的技巧。这项技术也用于向几何体的表面添加深度细节或高度。然而，这种深度或高度是虚假的。几何体的顶点在高度上没有发生任何变化。相反，它使用光照来模拟光滑表面上的深度外观。光照使用存储在法线图中的顶点法线信息来添加深度。与存储高度或高度信息的法线图一样，法线图存储法线信息。法线图中的想法是避免为每个三角形面计算法线图；这些可以从纹理中采样。
- en: The designer responsible for designing mesh models first create a very high
    polygon (100,000+) mesh model, then they create a normal map out of it in an image
    file. Finally, they reduced the high-resolution model to a low polygon mesh (between
    3000 and 5000 depends). Depth details are applied at runtime to the low poly mesh
    using a normal map, which results in a similar appearance like the high poly mesh.
    Therefore, bump mapping is used to add high details in a low poly mesh model.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 负责设计网格模型的设计师首先创建一个非常高多边形的网格模型（100,000+），然后从它创建一个法线图，保存在图像文件中。最后，他们将高分辨率模型降低到低多边形网格（介于3000到5000之间）。在运行时，使用法线图将深度细节应用到低多边形网格上，从而产生与高多边形网格相似的外观。因此，凹凸贴图用于在低多边形网格模型中添加高细节。
- en: In this recipe, we will implement an earth globe, which makes use of the normal
    map to produce the bump mapping effect; this makes the 3D depth information more
    obvious on the globe surface.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个地球球体，它利用法线图来产生凹凸映射效果；这使得球面表面的3D深度信息更加明显。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to implement this recipe, we need two textures. The first texture contains
    the color information to apply texture on the geometric surface. The second texture
    is the normal map of the first texture. There are many tools available to generate
    normal maps, such as CrazyBump, GIMP, PixPlant, Photoshop plugins, XNormals, and
    so on.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个菜谱，我们需要两个纹理。第一个纹理包含应用于几何表面的颜色信息。第二个纹理是第一个纹理的法线图。有许多工具可以生成法线图，例如CrazyBump、GIMP、PixPlant、Photoshop插件、XNormals等等。
- en: '![Getting ready](img/5527OT_07_15.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/5527OT_07_15.jpg)'
- en: How to do it...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The step-by-step instructions to implement bump mapping are as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 实现凹凸映射的逐步说明如下：
- en: Load the `sphere.obj` with `ObjLoader::LoadMesh()`; this function uses the `OBJMesh`
    class to load the mesh data. This recipe requires the tangent information from
    the loaded mesh in order to implement the bump mapping; this is automatically
    calculated by the `OBJMesh` class with the help of the `CalculateTangents` function.
    For more information on this function and mathematics calculations, refer to the
    *There's more…* section of this recipe.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ObjLoader::LoadMesh()`加载`sphere.obj`；此函数使用`OBJMesh`类来加载网格数据。这个菜谱需要从加载的网格中获取切线信息以实现凹凸映射；这由`OBJMesh`类通过`CalculateTangents`函数自动计算。有关此函数和数学计算的更多信息，请参阅此菜谱的*更多内容…*部分。
- en: Load the `earthcolor.png` earth texture and its normal (`earthnormal.png`) to
    create texture objects in the `ObjLoader::initModel`, as shown in previous recipes.
    Attach and bind these two texture objects to the texture unit `0` and `1` respectively
    so that they become available to the shader programs.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`earthcolor.png`地球纹理及其法线（`earthnormal.png`），在`ObjLoader::initModel`中创建纹理对象，如前述菜谱所示。将这两个纹理对象分别附加并绑定到纹理单元`0`和`1`，以便它们可用于着色器程序。
- en: 'Create the `BumpVertex.glsl` and add the following code snippet; this code
    is responsible for calculating the bi-normal tangent (`B`) with the help of the
    cross product of normal (`N`) and tangent (`T`). All these vertex parameters are
    in the tangent space; these must be normalized and stored as a 3x3 tangent space
    matrix represented by (`[Tx, Bx, Nx]`, `[Ty, By, Ny]`, and `[Tz, Bz, Nz]`). This
    is used to convert the eye space to a tangent space. The `eyecoord` in the present
    case is converted to the tangent space and shared with the fragment shader:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`BumpVertex.glsl`并添加以下代码片段；此代码通过法线（`N`）和切线（`T`）的叉积来计算双法线切线（`B`）。所有这些顶点参数都在切线空间中；这些必须归一化并存储为表示为（`[Tx,
    Bx, Nx]`, `[Ty, By, Ny]`, 和 `[Tz, Bz, Nz]`）的3x3切线空间矩阵。这用于将视空间转换为切线空间。在当前情况下，`eyecoord`被转换为切线空间并与片段着色器共享：
- en: '[PRE64]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create the `BumpFragment.glsl` and use the following code; the fragment shader
    coverts the light direction from eye coordinates to the tangent space; this is
    helpful in calculating the diffuse and specular intensity:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`BumpFragment.glsl`并使用以下代码；片段着色器将光方向从眼坐标转换为切线空间；这在计算漫反射和镜面强度时很有帮助：
- en: '[PRE65]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The bump map requires two texture files. The first texture file contains color
    information and is used in the diffuse shading. The second texture is called the
    normal map, which contains the normal information for the geometry; this information
    is helpful for specular shading. Both these textures are loaded and stored in
    texture units in order to make it accessible to the shader.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 凹凸映射需要两个纹理文件。第一个纹理文件包含颜色信息，用于漫反射着色。第二个纹理称为法线图，包含几何形状的法线信息；这些信息对于镜面着色很有帮助。这两个纹理都加载并存储在纹理单元中，以便着色器可以访问。
- en: 'Bump mapping heavily relies on the tangent information calculated in the `ObjMesh`
    class when the mesh is loaded. For more information on the tangent calculation,
    refer to the next section in this recipe. The tangents that are calculated are
    stored within the mesh VBO and are available to the vertex shader unlike other
    vertex attributes. In the vertex shader, this information in conjunction with
    the normal information helps to calculate per-vertex bi-tangent vectors. Once
    the normal (N), tangent (T), and bi-tangent (B) vectors are available, they are
    normalized and used to create a tangent space matrix, as shown in the following
    figure:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图高度依赖于在加载网格时在`ObjMesh`类中计算出的切线信息。有关切线计算的更多信息，请参阅本食谱中的下一节。计算出的切线存储在网格VBO中，并且可供顶点着色器使用，与其他顶点属性不同。在顶点着色器中，这些信息与法线信息结合，有助于计算每个顶点的双切线向量。一旦有了法线（N）、切线（T）和双切线（B）向量，它们就会被归一化并用于创建切线空间矩阵，如图所示：
- en: '![How it works...](img/5527OT_07_16.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_07_16.jpg)'
- en: The obtained tangent space matrix (`tangentSpace`) is multiplied with the eye
    coordinates of the `VertexPosition` to yield tangent space eye coordinates (`eyeCoord`).
    These are then shared with the fragment shader, along with the tangent space matrix
    and the `TexCoords` texture coordinates.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的切线空间矩阵（`tangentSpace`）与`VertexPosition`的视口坐标相乘，以产生切线空间视口坐标（`eyeCoord`）。然后这些坐标与切线空间矩阵和`TexCoords`纹理坐标一起与片段着色器共享。
- en: In the fragment shader, the image texture and normal texture are sampled using
    texture coordinates and are stored in the `texColor` and `normalMap`. It's necessary
    to change the normal map values from the range `[0, 1]` to `[-1, 1]`. Once changed,
    these two texture values are then sent to the `GouraudShading`. In this function,
    the light direction for each vertex is calculated and multiplied with the `tangentSpace`
    in order to transform into the tangent space. This modified `normalizeLightVec`
    and `eyeCoord` are then used to calculate diffuse and specular illumination components
    in the same way we calculated in the Gouraud shading technique. For more information
    on this technique, refer to [Chapter 5](ch05.html "Chapter 5. Light and Materials"),
    *Light and Materials*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，使用纹理坐标采样图像纹理和法线纹理，并存储在`texColor`和`normalMap`中。有必要将法线贴图值从范围`[0, 1]`转换为`[-1,
    1]`。一旦更改，这两个纹理值随后被发送到`GouraudShading`。在这个函数中，计算每个顶点的光方向并将其与`tangentSpace`相乘以转换为切线空间。然后使用修改后的`normalizeLightVec`和`eyeCoord`以与我们在Gouraud着色技术中计算相同的方式计算漫反射和镜面反射分量。有关此技术的更多信息，请参阅[第5章](ch05.html
    "第5章。光与材料")，*光与材料*。
- en: '![How it works...](img/5527OT_07_17.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_07_17.jpg)'
- en: There's more...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The normal map used in the bump mapping technique stores normal information
    of the geometry with respect to some default direction when normal map was generated.
    When this texture is mapped on the geometry and used for rendering purposes, it
    may generate incorrect results because not all faces of the geometry have the
    same direction as the mapped normal map. Therefore, the normal map needs to be
    manipulated on the fly at runtime, depending on the direction of the face, which
    is done using tangent planes. In the `ObjMesh` class, this tangent plane is calculated
    using `OBJMesh::CalculateTangents`; the tangent plane consists of Tangent (T)
    and BiTangent (B) vectors.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在法线贴图技术中使用的法线贴图存储了在生成法线贴图时相对于某个默认方向的空间几何体的法线信息。当此纹理映射到几何体并用于渲染目的时，可能会产生不正确的结果，因为几何体的所有面并不都具有与映射的法线贴图相同的方向。因此，法线贴图需要在运行时动态操作，取决于面的方向，这通过切平面来完成。在`ObjMesh`类中，此切平面是通过`OBJMesh::CalculateTangents`计算的；切平面由切线（T）和双切线（B）向量组成。
- en: A tangent is a vector that touches a curved surface at a given point; there
    could be too many tangents at a given point. Hence, it's very important to choose
    the correct tangent. Therefore, we want our tangent space to be aligned in such
    a way that **X** direction corresponds to the **U** direction of texture coordinates
    and **Y** direction corresponds to the **V** direction of texture coordinates.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 切线是一个在给定点上接触曲面上的向量；在给定点上可能会有太多的切线。因此，选择正确的切线非常重要。因此，我们希望我们的切线空间以这种方式对齐，即**X**方向对应于纹理坐标的**U**方向，**Y**方向对应于纹理坐标的**V**方向。
- en: 'Consider a scenario where there is a triangle with vertices P[0], P[1], and
    P[2] and corresponding texture coordinates as (U[0], V[0]), (U[1], V[1]), and
    (U[2], V[2]), the following image explains the calculation of the tangent space
    (see the equations). This gives the un-normalized Tangent (T) and BiTangent (B)
    for the triangle face created using P[0], P[1], and P[2]. In order to calculate
    the tangent for a given vertex, take the average tangents of all triangle faces
    that share this vertex:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个三角形，其顶点为P[0]、P[1]和P[2]，相应的纹理坐标为(U[0], V[0])、(U[1], V[1])和(U[2], V[2])，以下图像解释了切线空间的计算（见方程）。这给出了使用P[0]、P[1]和P[2]创建的三角形面的未归一化切线(T)和双切线(B)。为了计算给定顶点的切线，取共享此顶点的所有三角形面的平均切线：
- en: '![There''s more...](img/5527OT_07_18.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_07_18.jpg)'
- en: 'The preceding pictorial illustration and given equations in it, the tangent
    information is calculated in the `OBJMesh` class, as shown in the following code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示说明和其中的方程中，切线信息是在`OBJMesh`类中计算的，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: See also
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to the *Gouraud shading – the per-vertex shading technique* recipe in
    [Chapter 5](ch05.html "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第5章中关于*Gouraud着色 - 每顶点着色技术*的配方，*光与材质*
- en: Refer to the *Rendering the wavefront OBJ mesh model* recipe in [Chapter 4](ch04.html
    "Chapter 4. Working with Meshes"), *Working with Meshes*
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第4章中的*渲染wavefront OBJ网格模型*配方，*处理网格*
