- en: Chapter 5. Exposing the C API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn all about the **C API** (**C application programming
    interface**) and, through code, make use of it in your application. By having
    over 200 API calls to this light, small, and expanding API set, SQLite will surprise
    you with how it can achieve what you want from a mobile and flexible database.
  prefs: []
  type: TYPE_NORMAL
- en: You will look at some of the syntax and usage and see how to actually extend
    the functionality of SQLite by using its vast arsenal of API calls.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite C components' functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite has been written using C language, and its creator has enabled it to
    be exposed and has enhanced its functionality by having an API, the C API. In
    general, SQLite has many different API calls, for example, about 200 APIs for
    different functionalities. As a programmer, you may find it hard to accept, but
    the APIs are designed for specific tasks, for example, the `sqlite3_reset()` function
    clears the object connected with the SQLite prepared statement and resets it to
    its original state and value.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, the two core objects are the database connection and the prepared
    statement objects. The order and the types of functions give you an idea of how
    to write an SQL transaction to connect to a database, create a table and an index,
    and populate it with an `insert` statement. These functions form the main elements
    of the SQL-C interface functions, allowing data to be connected and passed from
    code to SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: sqlite3_open()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sqlite3_open(const char *filename, sqlite ** Db_name)` will open a connection
    to the SQLite database file at your chosen location and return the database connection
    object, which will be used by other SQLite components or functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite3_open()` function is required to make a connection before any other
    operation can take place. It will enable the rest of the operations to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, in the `sqlite3_open` function, the filename does not contain a `NULL`,
    the function will use a value from the provided values, or if no database file
    already exists, SQLite will attempt to open a new database using the name. Once
    a database connection via the `sqlite_open()` function had been achieved, commands
    such as `sqlite_prepare()` can go forward. An example of `sqlite3_open()` is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sqlite3_open()](img/B04725_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: sqlite3_prepare()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a new database connection, we will get a pointer address that will serve
    as the input for the `sqlite_prepare()` command. The statements will compile the
    source SQL statements into the object code. The functionality of the `sqlite3_prepare()`
    function is to bind and set up the relevant parameters to link up your query strings
    as part of the data process. Here is a brief example outlining the process for
    `sqlite3_prepare()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sqlite3_prepare()](img/B04725_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: sqlite3_step()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sqlite3_step()` statement will analyze, inspect, and evaluate the output
    object code from the previous the `sqlite3_prepare()` statement. It will execute
    a `prepare` statement and will return an SQLite status code. If there is data,
    then the `SQLITE_ROW` status code will be returned. When the statement has finished
    executing, the `SQLITE_DONE` status code will be returned. Any other returned
    value will be regarded as an error. `SQLite3_step()` must be reset for it to be
    used again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is mainly used for the `SELECT` statement. Other statements such
    as `DELETE`, `UPDATE`, or `INSERT` will execute to completion from the first record
    to the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sqlite3_step()](img/B04725_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: sqlite3_column()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `SQLITE3_prepare` statement is being evaluated, the `SQLITE3_column`
    statement displays a single column as part of the result set. `SQLITE3_column`
    performs a placeholder function within the `SQLITE` API and is the centerpoint
    for a variety of other functions, such as `SQLite_column_count()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sqlite3_column()](img/B04725_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: sqlite3_finalize()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, this statement will finalize and seal all prepared statements.
    Once the `sqlite3_finalize` statement has been executed, any memory is deallocated
    and internal process resources are released. Once completed, the statement cannot
    be reused and is not valid internally. See the following command for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sqlite3_finalize()](img/B04725_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: sqlite3_close()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the last component to be executed, namely the `sqlite3_close` command,
    which will close the database using the pointer and reference from the database
    connection, and previously created prepared statements will have to be finished
    before the connection is closed.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, in order to call or run SQL statements within SQLite
    or any other database, you must connect to the database and once you finish your
    work, you must disconnect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `SQLite_open()` statement is a way of using the C API directly
    without any implementation of the Swift language. The following are two methods
    for using the open database statement, in C API and in Swift. There are two types
    of approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **C API** with the open database statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Swift with the open database statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C API with the open database statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A variable of `db1` is defined to call the `SQLiteDatabase()` function. Then
    the `db1.open()` method is used with the data within the brackets to point to
    the `database1` database, as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Using Swift with the open database statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative way to open the database using Swift is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember that for Swift, you have to import the `sqlite3.h` file and add the
    `libsqlite3.0.dylib` SQLite library to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this `libsqlite3.0.dylib` to your project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the target and framework within the project editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Build Phases** at the top of the editor and open the link with the
    libraries section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **+** to add the framework or, in our case, the `libsqlite3.0.dylib`
    SQLite library.![Using Swift with the open database statement](img/B04725_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A search `NSSearchPAthForDirectoriesinDomains` is used to set up the `datadocuments`
    variable, and then the `databasepath` variable is set up as a place for the `sqlite`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable of `databasedb` is set up and a check is performed to see if the
    `sqlite3_open()` function with the input parameters actually works to open the
    database, otherwise an error message is shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The beauty of SQLite is its flexibility and the extensions of the product, which
    include extendable SQL features such as collating sequences, and SQL functions
    that enable your application to be different and unique. The range of change and
    ability to extend the app is growing.
  prefs: []
  type: TYPE_NORMAL
- en: The extension you build can be linked to your app and you can use of a function
    such as `SQLite_extension_init` as a pointer or address to ensure names don't
    conflict.
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite extension is classed as a **DLL** (a **dynamic link library**—a collection
    of programs that are used when required by larger applications).
  prefs: []
  type: TYPE_NORMAL
- en: DLLs by definition require an entry or starting point to engage with a program.
    It is where processes attach themselves to the DLL and a join or connection is
    made to exchange information and use functionality. The entry point function is
    used to perform cleanup tasks or initialization when engaged. When a process uses
    the entry point function, it can be used for allocating memory or virtual address
    space.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite can use load extensions, which are coded outside SQLite and tested and
    deployed as necessary. Once developed, these extensions can easily link up to
    SQLite. If there was some functionality SQLite did not have, a third party could
    develop it and make it available to potential customers or users in a particular
    industry, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an extension for SQLite, the extension differs for each operating
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: Some Unix systems use the `.so` file extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows systems use the `.dll` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS X (Mac) systems use the `.Dylib` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shows the great flexibility of the software, which can cater to a variety
    of operating systems and, therefore, allow the SQLite database to be applied to
    different systems and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: load_extension()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `load_extension(X,Y)` function is another capable function that allows functions/extensions
    to be loaded. Its methods are similar to that of the `sqlite3_load_extension()`
    C interface. Both these methods use entry points, and a name is required as an
    identifier. Null pointers can be passed in for the input argument.
  prefs: []
  type: TYPE_NORMAL
- en: There are commands that change the database and don't return any results, such
    as the `Update` statement. The function that carries out this task is `sqlite3_exec()`.
    This method is faster and is not difficult to learn or execute.
  prefs: []
  type: TYPE_NORMAL
- en: sqlite3_exec()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sqlite3_exec()` process has a pointer to an open database, a single or
    a list of SQL statements using a pointer to the callback function as part of its
    functionality. It will use one or several SQL statements combined with a null-terminated
    string for processing. Each row of the query will have a pointer to a callback
    function. There will also be a pointer sent ahead as part of the first argument
    to a callback function. A pointer to an error string variable is included.
  prefs: []
  type: TYPE_NORMAL
- en: sqlite3_config()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functionality of `sqlite3_config()` is useful for allowing changes to be
    made at a global level. The `sqlite3_config()` must be called before opening the
    database. The `sqlite3_config()` interface will allow SQLite's memory allocation
    to be adjusted, producing an error log for the whole process. It sets up and configures
    the `SQLite` library, controlling many aspects of memory allocation and related
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: To extend SQLite, further functions and routines such as `sqlite3_create_collation()`,
    `sqlite3_create_function()`, `sqlite3_create_module()`, and `sqlite3_vfs_register()`
    are investigated and used as necessary to improve the product functionality. Maintenance
    of these systems will be limited to those who know and use the technology.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of using some of the database functions using the
    `select`, `update`, `delete`, and `insert` commands with Apple's new language,
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, there are different SQLite wrappers out there, some
    specifically written for Swift (not many), but the most common one is **FMDB**,
    which has been tested for different apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to bring Objective-C into Swift, a "bridging header" is required,
    namely `sqlite3.h`. To use this header, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `libsqlite3.0.dylib` SQLite library to your project, as discussed previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `libsqlite3.0.dylib` library has been added to the project, the next
    task is to create the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, use the `sqlite3_exec` functionality to perform the `create table...`
    SQL statement, for example, as part of using Swift:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next statement to use is an `Insert` statement to enter data into the newly
    created `test` table. The following information will show how to prepare, bind,
    and step the SQL statement. The `sqlite3_prepare_v2` function will be used to
    prepare the SQL using a placeholder of `?` to bind the required value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A constant, `SQLITE_TRANSIENT`, can be used as a part of the following process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the standard way of using these variables. Sometimes these variables
    don't work if they have not been included as part of the `.h` file or as defined
    in the following section. They are not supported in Swift because of "unsafe pointer
    casting."
  prefs: []
  type: TYPE_NORMAL
- en: The prepare statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of the `prepare` statement, the functionality of `sqlite3_prepare_v2`
    is used with the SQL statement, using the question mark (`?`) as a placeholder
    to bind input values. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard was of using the `SQLITE_STATIC` and `SQLITE_TRANSIENT` as setup
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 2, the code could change, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s perform an `insert` statement using a `NULL` value to prove that
    SQL does work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, SQLite can work by allowing each SQL statement to be
    prepared once, evaluated, executed, and then destroyed, but it also has the facility
    to prepare the same system and be evaluated several different times by using the
    routines like the `sqlite3_reset()` and `sqlite3_bind()` functions. SQLite is
    a good and functional database that would work for different applications without
    any adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is then used to close the database after the work has been
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the advantage of the language having built-in SQL functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The information in this chapter has focused on the functionality of the C API.
    Developers today will extend and use different types of functionalities, as required,
    for their apps, but embedding the use of Swift, Objective-C, Java, or other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to extend the C API and produce code, which
    can be used to build some interesting, exciting, new, and intelligent data-driven
    applications and promote the use of SQLite. The language used is Swift. In the
    next chapter, you will learn briefly how to use Swift with IOS and SQLite, and
    you will be shown how to install Xcode and work with Swift and an SQLite library.
  prefs: []
  type: TYPE_NORMAL
