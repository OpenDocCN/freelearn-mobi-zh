- en: Chapter 5. Exposing the C API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。公开C API
- en: In this chapter, you will learn all about the **C API** (**C application programming
    interface**) and, through code, make use of it in your application. By having
    over 200 API calls to this light, small, and expanding API set, SQLite will surprise
    you with how it can achieve what you want from a mobile and flexible database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解有关**C API**（**C应用程序编程接口**）的所有内容，并通过代码在你的应用程序中使用它。通过拥有超过200个API调用到这个轻量级、小型且不断扩展的API集，SQLite将让你惊讶于它如何实现你想要的移动和灵活的数据库。
- en: You will look at some of the syntax and usage and see how to actually extend
    the functionality of SQLite by using its vast arsenal of API calls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将查看一些语法和用法，并了解如何通过使用其庞大的API调用库来扩展SQLite的功能。
- en: SQLite C components' functionality
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite C组件的功能
- en: SQLite has been written using C language, and its creator has enabled it to
    be exposed and has enhanced its functionality by having an API, the C API. In
    general, SQLite has many different API calls, for example, about 200 APIs for
    different functionalities. As a programmer, you may find it hard to accept, but
    the APIs are designed for specific tasks, for example, the `sqlite3_reset()` function
    clears the object connected with the SQLite prepared statement and resets it to
    its original state and value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是用C语言编写的，其创建者已经使它能够公开，并通过提供一个API（C API）增强了其功能。一般来说，SQLite有许多不同的API调用，例如，大约有200个API用于不同的功能。作为程序员，你可能觉得难以接受，但API是为特定任务设计的，例如，`sqlite3_reset()`函数清除与SQLite预编译语句关联的对象，并将其重置到其原始状态和值。
- en: To start with, the two core objects are the database connection and the prepared
    statement objects. The order and the types of functions give you an idea of how
    to write an SQL transaction to connect to a database, create a table and an index,
    and populate it with an `insert` statement. These functions form the main elements
    of the SQL-C interface functions, allowing data to be connected and passed from
    code to SQLite.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，两个核心对象是数据库连接和预编译语句对象。函数的顺序和类型可以给你一个如何编写SQL事务连接数据库、创建表和索引以及用`insert`语句填充它的概念。这些函数构成了SQL-C接口函数的主要元素，允许数据在代码和SQLite之间连接和传递。
- en: sqlite3_open()
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_open()
- en: The `sqlite3_open(const char *filename, sqlite ** Db_name)` will open a connection
    to the SQLite database file at your chosen location and return the database connection
    object, which will be used by other SQLite components or functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_open(const char *filename, sqlite ** Db_name)`将打开位于您选择位置的SQLite数据库文件，并返回数据库连接对象，该对象将被其他SQLite组件或函数使用。'
- en: The `sqlite3_open()` function is required to make a connection before any other
    operation can take place. It will enable the rest of the operations to follow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何其他操作之前，需要`sqlite3_open()`函数来建立连接。它将使其他操作得以进行。
- en: 'If, in the `sqlite3_open` function, the filename does not contain a `NULL`,
    the function will use a value from the provided values, or if no database file
    already exists, SQLite will attempt to open a new database using the name. Once
    a database connection via the `sqlite_open()` function had been achieved, commands
    such as `sqlite_prepare()` can go forward. An example of `sqlite3_open()` is shown
    here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`sqlite3_open`函数中，文件名不包含`NULL`，则函数将使用提供的值，或者如果不存在数据库文件，SQLite将尝试使用该名称打开一个新的数据库。一旦通过`sqlite_open()`函数建立了数据库连接，就可以执行`sqlite_prepare()`等命令。以下是`sqlite3_open()`的一个示例：
- en: '![sqlite3_open()](img/B04725_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![sqlite3_open()](img/B04725_05_01.jpg)'
- en: sqlite3_prepare()
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_prepare()
- en: 'With a new database connection, we will get a pointer address that will serve
    as the input for the `sqlite_prepare()` command. The statements will compile the
    source SQL statements into the object code. The functionality of the `sqlite3_prepare()`
    function is to bind and set up the relevant parameters to link up your query strings
    as part of the data process. Here is a brief example outlining the process for
    `sqlite3_prepare()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的数据库连接，我们将获得一个指针地址，该地址将作为`sqlite_prepare()`命令的输入。语句将编译源SQL语句到目标代码。`sqlite3_prepare()`函数的功能是绑定并设置相关参数，将查询字符串作为数据处理的一部分链接起来。以下是`sqlite3_prepare()`过程的简要示例：
- en: '![sqlite3_prepare()](img/B04725_05_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![sqlite3_prepare()](img/B04725_05_02.jpg)'
- en: sqlite3_step()
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_step()
- en: The `sqlite3_step()` statement will analyze, inspect, and evaluate the output
    object code from the previous the `sqlite3_prepare()` statement. It will execute
    a `prepare` statement and will return an SQLite status code. If there is data,
    then the `SQLITE_ROW` status code will be returned. When the statement has finished
    executing, the `SQLITE_DONE` status code will be returned. Any other returned
    value will be regarded as an error. `SQLite3_step()` must be reset for it to be
    used again.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_step()` 语句将对之前 `sqlite3_prepare()` 语句生成的输出对象代码进行分析、检查和评估。它将执行一个 `prepare`
    语句并返回一个 SQLite 状态码。如果有数据，则返回 `SQLITE_ROW` 状态码。当语句执行完毕时，将返回 `SQLITE_DONE` 状态码。任何其他返回值都将被视为错误。`SQLite3_step()`
    必须重置后才能再次使用。'
- en: 'This method is mainly used for the `SELECT` statement. Other statements such
    as `DELETE`, `UPDATE`, or `INSERT` will execute to completion from the first record
    to the last:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法主要用于 `SELECT` 语句。其他语句，如 `DELETE`、`UPDATE` 或 `INSERT`，将从第一条记录执行到最后一项完成：
- en: '![sqlite3_step()](img/B04725_05_03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![sqlite3_step()](img/B04725_05_03.jpg)'
- en: sqlite3_column()
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_column()
- en: As the `SQLITE3_prepare` statement is being evaluated, the `SQLITE3_column`
    statement displays a single column as part of the result set. `SQLITE3_column`
    performs a placeholder function within the `SQLITE` API and is the centerpoint
    for a variety of other functions, such as `SQLite_column_count()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `SQLITE3_prepare` 语句的评估，`SQLITE3_column` 语句将显示结果集中的一个单独的列。`SQLITE3_column`
    在 `SQLITE` API 中执行占位符功能，并且是其他各种函数的中心点，例如 `SQLite_column_count()`。
- en: 'See the following for more information:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅以下内容：
- en: '![sqlite3_column()](img/B04725_05_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![sqlite3_column()](img/B04725_05_04.jpg)'
- en: sqlite3_finalize()
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_finalize()
- en: 'As the name suggests, this statement will finalize and seal all prepared statements.
    Once the `sqlite3_finalize` statement has been executed, any memory is deallocated
    and internal process resources are released. Once completed, the statement cannot
    be reused and is not valid internally. See the following command for more information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此语句将最终化并密封所有预准备语句。一旦执行了 `sqlite3_finalize` 语句，任何内存都将被释放，内部进程资源也将被释放。一旦完成，该语句就不能再被重用，并且在内部也不有效。有关更多信息，请参阅以下命令：
- en: '![sqlite3_finalize()](img/B04725_05_05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![sqlite3_finalize()](img/B04725_05_05.jpg)'
- en: sqlite3_close()
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_close()
- en: This is the last component to be executed, namely the `sqlite3_close` command,
    which will close the database using the pointer and reference from the database
    connection, and previously created prepared statements will have to be finished
    before the connection is closed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后要执行的部分，即 `sqlite3_close` 命令，它将使用数据库连接的指针和引用关闭数据库，并且必须在关闭连接之前完成之前创建的预准备语句。
- en: As mentioned previously, in order to call or run SQL statements within SQLite
    or any other database, you must connect to the database and once you finish your
    work, you must disconnect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了在 SQLite 或任何其他数据库中调用或运行 SQL 语句，您必须连接到数据库，并在完成工作后断开连接。
- en: 'The preceding `SQLite_open()` statement is a way of using the C API directly
    without any implementation of the Swift language. The following are two methods
    for using the open database statement, in C API and in Swift. There are two types
    of approach:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `SQLite_open()` 语句是直接使用 C API 而不涉及 Swift 语言实现的一种方式。以下是在 C API 和 Swift 中使用打开数据库语句的两种方法。有两种类型的处理方式：
- en: Using the **C API** with the open database statement
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **C API** 和打开数据库语句
- en: Using Swift with the open database statement
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swift 和打开数据库语句
- en: Using the C API with the open database statement
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 C API 和打开数据库语句
- en: 'Have a look at the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A variable of `db1` is defined to call the `SQLiteDatabase()` function. Then
    the `db1.open()` method is used with the data within the brackets to point to
    the `database1` database, as shown in the preceding code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个名为 `db1` 的变量来调用 `SQLiteDatabase()` 函数。然后使用括号内的数据使用 `db1.open()` 方法指向 `database1`
    数据库，如前述代码所示。
- en: Using Swift with the open database statement
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Swift 和打开数据库语句
- en: 'An alternative way to open the database using Swift is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swift 打开数据库的另一种方法是：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember that for Swift, you have to import the `sqlite3.h` file and add the
    `libsqlite3.0.dylib` SQLite library to your project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于 Swift，您必须导入 `sqlite3.h` 文件并将 `libsqlite3.0.dylib` SQLite 库添加到您的项目中。
- en: 'To add this `libsqlite3.0.dylib` to your project, follow these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `libsqlite3.0.dylib` 添加到您的项目中，请按照以下步骤操作：
- en: Select the target and framework within the project editor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目编辑器中选择目标和框架。
- en: Click on **Build Phases** at the top of the editor and open the link with the
    libraries section.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器的顶部点击**构建阶段**，并打开包含库部分的链接。
- en: Click on **+** to add the framework or, in our case, the `libsqlite3.0.dylib`
    SQLite library.![Using Swift with the open database statement](img/B04725_05_06.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**以添加框架，或者在我们的情况下，添加`libsqlite3.0.dylib` SQLite库。![使用Swift与开放数据库语句](img/B04725_05_06.jpg)
- en: A search `NSSearchPAthForDirectoriesinDomains` is used to set up the `datadocuments`
    variable, and then the `databasepath` variable is set up as a place for the `sqlite`
    file.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`NSSearchPathForDirectoriesinDomains`搜索来设置`datadocuments`变量，然后设置`databasepath`变量作为`sqlite`文件的存放位置。
- en: A variable of `databasedb` is set up and a check is performed to see if the
    `sqlite3_open()` function with the input parameters actually works to open the
    database, otherwise an error message is shown.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个名为`databasedb`的变量，并执行检查以查看带有输入参数的`sqlite3_open()`函数是否实际打开数据库，否则显示错误信息。
- en: The beauty of SQLite is its flexibility and the extensions of the product, which
    include extendable SQL features such as collating sequences, and SQL functions
    that enable your application to be different and unique. The range of change and
    ability to extend the app is growing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的美丽之处在于其灵活性和产品的扩展性，包括可扩展的SQL功能，如排序序列，以及使你的应用程序与众不同和独特的SQL函数。改变的范围和扩展应用程序的能力正在增长。
- en: The extension you build can be linked to your app and you can use of a function
    such as `SQLite_extension_init` as a pointer or address to ensure names don't
    conflict.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的扩展可以链接到你的应用程序中，你可以使用`SQLite_extension_init`函数作为指针或地址来确保名称不冲突。
- en: The SQLite extension is classed as a **DLL** (a **dynamic link library**—a collection
    of programs that are used when required by larger applications).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite扩展被归类为**DLL**（动态链接库——一组在需要时由大型应用程序使用的程序）。
- en: DLLs by definition require an entry or starting point to engage with a program.
    It is where processes attach themselves to the DLL and a join or connection is
    made to exchange information and use functionality. The entry point function is
    used to perform cleanup tasks or initialization when engaged. When a process uses
    the entry point function, it can be used for allocating memory or virtual address
    space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，DLL需要入口或起始点来与程序交互。这是进程附加到DLL并建立连接或交换信息和使用功能的地方。入口点函数用于在交互时执行清理任务或初始化。当进程使用入口点函数时，它可以用于分配内存或虚拟地址空间。
- en: SQLite can use load extensions, which are coded outside SQLite and tested and
    deployed as necessary. Once developed, these extensions can easily link up to
    SQLite. If there was some functionality SQLite did not have, a third party could
    develop it and make it available to potential customers or users in a particular
    industry, for example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite可以使用加载扩展，这些扩展是在SQLite外部编写的，根据需要测试和部署。一旦开发完成，这些扩展可以轻松地链接到SQLite。如果SQLite没有某些功能，第三方可以开发它，并将其提供给特定行业的潜在客户或用户，例如。
- en: 'When creating an extension for SQLite, the extension differs for each operating
    system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当为SQLite创建扩展时，每个操作系统的扩展都不同：
- en: Some Unix systems use the `.so` file extension
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些Unix系统使用`.so`文件扩展名
- en: Windows systems use the `.dll` extension
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows系统使用`.dll`扩展
- en: OS X (Mac) systems use the `.Dylib` extension
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS X（Mac）系统使用`.Dylib`扩展
- en: This shows the great flexibility of the software, which can cater to a variety
    of operating systems and, therefore, allow the SQLite database to be applied to
    different systems and technologies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了该软件的巨大灵活性，可以满足各种操作系统，因此允许SQLite数据库应用于不同的系统和技术。
- en: load_extension()
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: load_extension()
- en: The `load_extension(X,Y)` function is another capable function that allows functions/extensions
    to be loaded. Its methods are similar to that of the `sqlite3_load_extension()`
    C interface. Both these methods use entry points, and a name is required as an
    identifier. Null pointers can be passed in for the input argument.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_extension(X,Y)`函数是另一个功能强大的函数，允许加载函数/扩展。其方法与`sqlite3_load_extension()`
    C接口类似。这两种方法都使用入口点，需要一个名称作为标识符。可以传递空指针作为输入参数。'
- en: There are commands that change the database and don't return any results, such
    as the `Update` statement. The function that carries out this task is `sqlite3_exec()`.
    This method is faster and is not difficult to learn or execute.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些更改数据库但不返回任何结果的命令，例如`Update`语句。执行此任务的函数是`sqlite3_exec()`。这种方法更快，且学习或执行都不困难。
- en: sqlite3_exec()
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_exec()
- en: The `sqlite3_exec()` process has a pointer to an open database, a single or
    a list of SQL statements using a pointer to the callback function as part of its
    functionality. It will use one or several SQL statements combined with a null-terminated
    string for processing. Each row of the query will have a pointer to a callback
    function. There will also be a pointer sent ahead as part of the first argument
    to a callback function. A pointer to an error string variable is included.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_exec()` 过程包含一个指向打开数据库的指针，一个或多个 SQL 语句，以及一个使用指向回调函数的指针作为其功能的一部分。它将使用一个或多个
    SQL 语句与一个以 null 结尾的字符串结合进行处理。查询的每一行都将有一个指向回调函数的指针。作为回调函数的第一个参数的一部分，还将发送一个指针。包括一个指向错误字符串变量的指针。'
- en: sqlite3_config()
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlite3_config()
- en: The functionality of `sqlite3_config()` is useful for allowing changes to be
    made at a global level. The `sqlite3_config()` must be called before opening the
    database. The `sqlite3_config()` interface will allow SQLite's memory allocation
    to be adjusted, producing an error log for the whole process. It sets up and configures
    the `SQLite` library, controlling many aspects of memory allocation and related
    resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_config()` 函数的功能允许在全局范围内进行更改。必须在打开数据库之前调用 `sqlite3_config()`。`sqlite3_config()`
    接口将允许调整 SQLite 的内存分配，并为整个过程生成错误日志。它设置并配置 `SQLite` 库，控制内存分配和相关资源的许多方面。'
- en: To extend SQLite, further functions and routines such as `sqlite3_create_collation()`,
    `sqlite3_create_function()`, `sqlite3_create_module()`, and `sqlite3_vfs_register()`
    are investigated and used as necessary to improve the product functionality. Maintenance
    of these systems will be limited to those who know and use the technology.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展 SQLite，需要进一步研究并使用 `sqlite3_create_collation()`、`sqlite3_create_function()`、`sqlite3_create_module()`
    和 `sqlite3_vfs_register()` 等函数和例程，根据需要作为改进产品功能的一部分。这些系统的维护将限于那些了解和使用该技术的人。
- en: The following is an example of using some of the database functions using the
    `select`, `update`, `delete`, and `insert` commands with Apple's new language,
    Swift.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用 `select`、`update`、`delete` 和 `insert` 命令结合 Apple 的新语言 Swift 使用数据库函数的示例。
- en: 'As mentioned previously, there are different SQLite wrappers out there, some
    specifically written for Swift (not many), but the most common one is **FMDB**,
    which has been tested for different apps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，存在不同的 SQLite 包装器，其中一些专门为 Swift 编写（不多），但最常见的是 **FMDB**，它已被用于不同的应用程序测试：
- en: 'In order to bring Objective-C into Swift, a "bridging header" is required,
    namely `sqlite3.h`. To use this header, use the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将 Objective-C 引入 Swift，需要一个“桥接头”，即 `sqlite3.h`。要使用此头文件，请使用以下命令：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add the `libsqlite3.0.dylib` SQLite library to your project, as discussed previously.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，将 `libsqlite3.0.dylib` SQLite 库添加到您的项目中。
- en: Once the `libsqlite3.0.dylib` library has been added to the project, the next
    task is to create the database.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `libsqlite3.0.dylib` 库添加到项目后，下一个任务是创建数据库。
- en: 'Next, use the `sqlite3_exec` functionality to perform the `create table...`
    SQL statement, for example, as part of using Swift:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `sqlite3_exec` 功能执行 `create table...` SQL 语句，例如，在使用 Swift 的过程中：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next statement to use is an `Insert` statement to enter data into the newly
    created `test` table. The following information will show how to prepare, bind,
    and step the SQL statement. The `sqlite3_prepare_v2` function will be used to
    prepare the SQL using a placeholder of `?` to bind the required value:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要使用的语句是 `Insert` 语句，用于将数据输入到新创建的 `test` 表中。以下信息将展示如何准备、绑定和执行 SQL 语句。将使用 `sqlite3_prepare_v2`
    函数准备 SQL，使用占位符 `?` 来绑定所需值：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A constant, `SQLITE_TRANSIENT`, can be used as a part of the following process:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用一个常量 `SQLITE_TRANSIENT` 作为以下过程的组成部分：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the standard way of using these variables. Sometimes these variables
    don't work if they have not been included as part of the `.h` file or as defined
    in the following section. They are not supported in Swift because of "unsafe pointer
    casting."
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用这些变量的标准方式。有时，如果它们没有作为 `.h` 文件的一部分或在下述部分中定义，则这些变量可能不起作用。由于“不安全的指针转换”，它们在
    Swift 中不受支持。
- en: The prepare statement
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备语句
- en: 'As part of the `prepare` statement, the functionality of `sqlite3_prepare_v2`
    is used with the SQL statement, using the question mark (`?`) as a placeholder
    to bind input values. This is shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `prepare` 语句的一部分，使用 `sqlite3_prepare_v2` 的功能与 SQL 语句一起使用，使用问号 (`?`) 作为占位符来绑定输入值。以下示例展示了这一点：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The standard was of using the `SQLITE_STATIC` and `SQLITE_TRANSIENT` as setup
    is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 标准是使用 `SQLITE_STATIC` 和 `SQLITE_TRANSIENT` 作为设置，如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In Swift 2, the code could change, as shown in the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，代码可能会有所改变，如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s perform an `insert` statement using a `NULL` value to prove that
    SQL does work:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用一个 `NULL` 值执行一个 `insert` 语句来证明 SQL 确实是有效的：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As mentioned previously, SQLite can work by allowing each SQL statement to be
    prepared once, evaluated, executed, and then destroyed, but it also has the facility
    to prepare the same system and be evaluated several different times by using the
    routines like the `sqlite3_reset()` and `sqlite3_bind()` functions. SQLite is
    a good and functional database that would work for different applications without
    any adjustments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SQLite 可以通过允许每个 SQL 语句只准备一次、评估、执行然后销毁来工作，但它也提供了使用如 `sqlite3_reset()` 和
    `sqlite3_bind()` 函数之类的例程来准备相同的系统并多次评估不同时间的功能。SQLite 是一个良好且功能齐全的数据库，无需任何调整即可适用于不同的应用程序。
- en: 'The following code is then used to close the database after the work has been
    done:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于在完成工作后关闭数据库：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the advantage of the language having built-in SQL functionality.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是具有内置 SQL 功能的语言的优势。
- en: The information in this chapter has focused on the functionality of the C API.
    Developers today will extend and use different types of functionalities, as required,
    for their apps, but embedding the use of Swift, Objective-C, Java, or other languages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的信息主要集中在 C API 的功能上。今天的开发者将根据需要扩展并使用不同类型的功能，为他们的应用程序嵌入 Swift、Objective-C、Java
    或其他语言的使用。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to extend the C API and produce code, which
    can be used to build some interesting, exciting, new, and intelligent data-driven
    applications and promote the use of SQLite. The language used is Swift. In the
    next chapter, you will learn briefly how to use Swift with IOS and SQLite, and
    you will be shown how to install Xcode and work with Swift and an SQLite library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何扩展 C API 并生成代码，这些代码可以用来构建一些有趣、激动人心、新颖和智能的数据驱动应用程序，并促进 SQLite 的使用。所使用的语言是
    Swift。在下一章中，你将简要了解如何使用 Swift 与 IOS 和 SQLite，以及如何安装 Xcode 并与 Swift 和 SQLite 库一起工作。
