- en: <st c="0">5</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Enhancing iOS Applications with WidgetKit</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="43">As iPhones have evolved over the years, new capabilities have been
    added to take advantage of the big screen, the memory capacity, and the</st> <st
    c="183">powerful processor.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="202">One of those capabilities is the home screen widgets – a great way
    to extend our apps and provide information and even interaction in</st> <st c="337">new
    places.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="348">In this chapter, we will cover the</st> <st c="384">following topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="401">The idea</st> <st c="411">of widgets</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="421">Understanding how</st> <st c="440">widgets work</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="452">Add our first widget and build a timeline</st> <st c="495">of entries</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="505">Add a</st> <st c="512">user-configurable widget</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="536">Ensure our widgets are up</st> <st c="563">to date</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="570">Customize the</st> <st c="585">widget animations</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="602">Add user interactions such as buttons</st> <st c="641">and toggles</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="652">Add a control widget to the control center and</st> <st c="700">lock
    screen</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="711">So, let’s start with the basics – what is the idea</st> <st c="763">of
    widgets?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="774">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="797">For this chapter, it’s essential to download Xcode version 15.0
    or higher from the</st> <st c="881">App Store.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="891">Ensure you’re operating on the most recent version of macOS (Ventura
    or newer).</st> <st c="972">Just search for Xcode in the App Store, choose the
    latest version, and proceed with the download.</st> <st c="1070">Open Xcode and
    complete any further setup instructions that appear.</st> <st c="1138">After Xcode
    is completely up and running, you</st> <st c="1184">can begin.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1194">To gain additional capabilities, such as sharing data between the
    widget and the app, you must set up AppGroups and define your AppGroups in</st>
    <st c="1336">your profile.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1349">Download the sample code from the following</st> <st c="1394">GitHub
    link:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[<st c="1406">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205)'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1492">The idea of widgets</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1512">Adding a widget is not a new concept in iOS or, in fact, in the</st>
    <st c="1577">Apple ecosystem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1593">Widgets existed</st> <st c="1610">long ago in 2005 in the</st>
    *<st c="1634">Tiger</st>* <st c="1639">version of macOS, as part of the Dashboard
    feature.</st> <st c="1692">Apple took that idea and introduced</st> *<st c="1728">Today
    Widgets</st>* <st c="1741">in the</st> *<st c="1749">Notification Center</st>*
    <st c="1768">in iOS 8, and in iOS 14, Apple introduced the home screen widgets,
    similar to the widgets that already exist in the Android operating system.</st>
    <st c="1911">In iOS 18, Apple added the ability for third-party applications to
    add widgets to the control center and the</st> <st c="2020">home screen.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2032">The idea of widgets is not to act as a full-blown application –
    widgets are not supposed to be a mini-version of our app or one of its screens,
    but rather an extension of our current</st> <st c="2216">app’s capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2235">Widgets exist to enhance user convenience and productivity and,
    in general, the</st> <st c="2316">overall experience.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2335">There are</st> <st c="2346">three key roles for widgets</st> <st
    c="2374">in iOS:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="2381">Information at a glance</st>** <st c="2405">– Widgets provide
    up-to-date and important information to the user about our app.</st> <st c="2488">It
    can be a delivery status, stock values, event calendars, or any other information
    that is useful on a</st> <st c="2593">day-to-day basis.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2610">A shortcut to our app</st>** <st c="2632">– Tapping on a widget
    opens our app, and in many cases, a specific screen of our app.</st> <st c="2719">Opening
    our app using widgets is even more important in watchOS, where, unlike iOS, the
    springboard is not the user’s default view.</st> <st c="2851">For many app developers,
    it’s a great way of promoting their app and</st> *<st c="2920">fighting</st>*
    <st c="2928">for the user’s attention on the</st> <st c="2961">home screen.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2973">Performing basic actions</st>** <st c="2998">– Starting iOS
    17, Apple added interactive widgets, allowing users to perform basic actions without
    opening their app, such as completing a task, opening the garage door, or accepting
    a payment request.</st> <st c="3202">In iOS 18, this capability</st> <st c="3229">went
    even further, and it’s possible to add our widgets to the control center, or open
    them using the action button on iPhone</st> <st c="3355">15 devices.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3366">Going over the different Apple platforms, we can see that the idea
    of showing information</st> <st c="3457">at a glance is widespread – we’ve got
    home and lock screen widgets, complications, and live activities in iOS, padOS,
    macOS,</st> <st c="3582">and watchOS.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3594">For example, the Yahoo!</st> <st c="3619">Weather app shows the
    weather in the user’s current location and Apple’s Reminders app shows the user’s</st>
    <st c="3723">uncompleted reminders.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3745">It’s only natural for Apple to straighten the line between the
    different platforms into a single framework –</st> *<st c="3855">WidgetK</st><st
    c="3862">it</st>*<st c="3865">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3866">Understanding how widgets work</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3897">As mentioned at the beginning of this chapter, widgets are not
    mini applications.</st> <st c="3980">Instead, widgets are simple views that show
    relevant information and are updated according to a declared timeline or</st>
    <st c="4097">app events.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4108">Widgets run</st> <st c="4121">on a different process than the app.</st>
    <st c="4158">They receive a runtime to perform any code, so they work as static
    views, showing pre-made information to our users.</st> <st c="4275">But, since
    our user’s data is being constantly updated, we can create an array of entries,
    each with information and a date.</st> <st c="4400">The</st> *<st c="4404">WidgetCenter</st>*
    <st c="4416">is responsible for creating a different view for each one of the
    entries, storing it, and replacing the</st> <st c="4521">widget UI according to
    the entries’ dates.</st> <st c="4564">This array of entries is called</st> <st
    c="4596">a</st> **<st c="4598">timeline</st>**<st c="4606">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4607">One good example is the</st> *<st c="4632">Next Event</st>* <st
    c="4642">widget.</st> <st c="4651">The</st> *<st c="4655">Next Event</st>* <st
    c="4665">widget shows the next event in our calendar, and since we have access
    to our user’s calendar, we can build a timeline and refresh the widget data based
    on the calendar event’s list.</st> <st c="4848">All we need to provide is the
    timeline including the different data for each</st> <st c="4925">timeline entry.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4940">Using a timeline to update the widget’s content makes the widget
    an extremely effective way to present information to the user, both in battery
    usage and</st> <st c="5095">processing time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5111">However, the timeline also produces some challenges in the way
    we work with widgets because, unlike the</st> *<st c="5216">Next Event</st>* <st
    c="5226">widget, not every timeline can be built</st> <st c="5267">up front.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5276">But let’s wait before we dive into the solution to our problems
    and try to add our</st> <st c="5360">first widget.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5373">Adding a widget</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="5389">Widgets operate</st> <st c="5406">and live outside of our app,
    therefor they are considered to be an</st> *<st c="5473">extension</st>* <st c="5482">of</st>
    <st c="5486">our app.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5494">To add a new widget – we need to a new</st> **<st c="5534">Widget
    Extension</st>** <st c="5550">target by selecting</st> **<st c="5571">File</st>**
    <st c="5575">-></st> **<st c="5579">New</st>** <st c="5582">-></st> **<st c="5586">Target…</st>**<st
    c="5593">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5594">Then, in the</st> **<st c="5608">Choose a template for your new
    target</st>** <st c="5645">window, we search for a widget and add the widget extension
    (see</st> *<st c="5711">Figure 5</st>**<st c="5719">.1</st>*<st c="5721">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: The Choose a template for your new target window](img/B21795_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="5870">Figure 5.1: The Choose a template for your new target window</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5930">After clicking on</st> **<st c="5949">Next</st>**<st c="5953">,
    we should provide a name for our widget, just like any target we add.</st> <st
    c="6025">In addition, uncheck the</st> *<st c="6050">Include Configuration App</st>*
    *<st c="6076">Intent</st>* <st c="6082">checkbox.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6092">Once the widget is added, we can see a new target with the name
    we provided.</st> <st c="6170">Xcode creates a few files for us as part of the
    widget template (assuming that the target name</st> <st c="6265">is</st> `<st
    c="6268">MyWidget</st>`<st c="6276">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="6279">MyWidgetBundle</st>` <st c="6294">– The widget bundle is a container
    for the different widgets our extension holds.</st> <st c="6377">Currently, we
    have only one widget, but it is possible to</st> <st c="6435">add more.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="6444">MyWidget</st>` <st c="6453">– Contains the widget code itself,
    including its UI</st> <st c="6506">and configuration.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="6524">Assets</st>` <st c="6531">– An asset catalog specifically for
    the</st> <st c="6572">widget extension.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="6589">Info.plist</st>` <st c="6600">– Just like any target, the widget
    extension contains a</st> `<st c="6657">plist</st>` <st c="6662">file with general
    information about the</st> <st c="6703">widget extension.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="6720">Now, it’s time to</st> <st c="6739">clarify what a widget is –
    the fact that we have different sizes for a widget doesn’t mean they are different
    widgets, as the same widget can have multiple sizes.</st> <st c="6902">A different
    widget is usually a different product, a different UI, and a different use case.</st>
    <st c="6995">In our case, the widget bundle describes the different widgets and
    not the different</st> <st c="7080">widget sizes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7093">Now that we have added a widget to our project, we can run our
    app and add the new widget to our springboard (</st>*<st c="7204">Figure 5</st>**<st
    c="7213">.2</st>*<st c="7215">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Our new template widget in the springboard](img/B21795_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="7220">Figure 5.2: Our new template widget in the springboard</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7274">We can see in</st> *<st c="7289">Figure 5</st>**<st c="7297">.2</st>*
    <st c="7299">that the new widget consists of the current time and some emoji.</st>
    <st c="7365">This is a</st> <st c="7375">good time to play with it and to try
    adding additional</st> <st c="7430">widget sizes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7443">Configuring our widget</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7466">The way we set up our widget’s look and behavior is by determining
    its configuration.</st> <st c="7553">We have</st> <st c="7561">several configurations
    to work with, and they all conform to a protocol</st> <st c="7633">named</st>
    `<st c="7639">WidgetConfiguration</st>`<st c="7658">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7659">One of the configurations available for us is</st> `<st c="7706">StaticConfiguration</st>`<st
    c="7725">.</st> `<st c="7727">StaticConfiguration</st>` <st c="7746">allows us
    to create a widget that has no</st> <st c="7788">user-configurable options.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7814">Let’s have a look at the</st> `<st c="7840">StaticConfiguration</st>`
    <st c="7859">that Xcode provides when we add a</st> <st c="7894">new widget:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8230">We can</st> <st c="8238">see that</st> `<st c="8247">StaticConfiguration</st>`
    <st c="8266">has several properties shared with all configuration types.</st>
    <st c="8327">Let’s see them in</st> <st c="8345">depth, here:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="8357">kind</st>` <st c="8362">– This is the widget configuration unique
    identifier.</st> <st c="8417">It helps us send requests to a specific widget configuration
    using</st> <st c="8484">the</st> *<st c="8488">WidgetCenter</st>*<st c="8500">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="8501">configurationDisplayName</st>` <st c="8526">– This is the widget
    display name as it appears for the user when he wants to pick the right widget</st>
    <st c="8627">to add.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="8634">description</st>` <st c="8646">– This is the widget’s description
    that is shown to the user, next to its</st> <st c="8721">display name.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8734">Besides these three parameters, we have additional important parameters.</st>
    `<st c="8807">supportedFamilies</st>` <st c="8825">determines the different sizes
    the widget supports.</st> <st c="8878">Here’s an example of how to limit the widget
    to appear only in</st> <st c="8941">medium size:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8988">Another property is</st> `<st c="9009">backgroundTask</st>`<st
    c="9023">, which allows our widget to perform a background operation when the
    system gives</st> <st c="9105">it time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9113">Notice that</st> `<st c="9126">WidgetConfiguration</st>` <st c="9145">is
    just a protocol – when creating a widget, we need to return, in the widget body,
    a structure that conforms to that protocol, and</st> `<st c="9278">StaticConfiguration</st>`
    <st c="9297">is just one way to</st> <st c="9317">do that.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9325">Currently, there are three configurations available</st> <st c="9378">for
    us:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="9385">StaticConfiguration</st>` <st c="9405">– As mentioned earlier,
    this configuration allows us to create a non-user</st> <st c="9480">configurable
    widget</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="9499">AppIntentConfiguration</st>` <st c="9522">– This enables the
    user to customize their widget, for example, selecting a city for a weather widget,
    or a specific list for the</st> <st c="9653">reminders app</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="9666">ActivityConfiguration</st>` <st c="9688">– This configuration
    shows live data for the Live</st> <st c="9739">Activity widget</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9754">A widget can</st> <st c="9768">contain only one configuration.</st>
    <st c="9800">If we need to have more than one configuration, that’s a good sign
    we need to create several widgets with different configurations and share some
    of our code</st> <st c="9958">between them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9971">All these widget configurations sound exciting!</st> <st c="10020">Let’s
    start exploring them by starting with</st> <st c="10064">the</st> `<st c="10068">StaticConfiguration</st>`<st
    c="10087">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10088">Working with static configuration</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10122">A static widget is a widget that has no user-configurable options.</st>
    <st c="10190">For example, a widget that shows</st> <st c="10223">the current
    time in a specific city cannot be static because the user needs to specify a city
    or a location for</st> <st c="10335">the widget.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10346">However, a good example of a static widget is a calendar widget
    that shows a view of the whole month and marks the current day, or a music app
    widget that shows the songs that have been</st> <st c="10533">played recently.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10549">Even though both the calendar and the music app widgets show information
    not updated by the user, they need to update themselves every once in</st> <st
    c="10693">a while.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10701">If we look back at the static configuration example (in the</st>
    *<st c="10762">Configuring our widget</st>* <st c="10784">section), we can see
    a parameter called</st> `<st c="10825">provider</st>`<st c="10833">, which contains
    a parameter for the view builder closure</st> <st c="10891">named</st> `<st c="10897">entry</st>`<st
    c="10902">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10903">Using</st> `<st c="10910">provider</st>` <st c="10918">and</st>
    `<st c="10923">entry</st>`<st c="10928">, we can provide data to our widget across
    time in an</st> <st c="10982">efficient way.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10996">One key aspect of Widgets is providing data over time, and we
    do that using the Timeline provider.</st> <st c="11096">Now, let’s understand
    what Timeline</st> <st c="11132">Provider means.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11147">Understanding the Timeline Provider for Widgets</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11195">There’s a reason why it took Apple almost 14 years to support
    widgets on the iOS home screen.</st> <st c="11290">The</st> <st c="11294">primary
    reason is performance, both power and memory performance.</st> <st c="11360">While
    today’s devices are highly capable, having numerous</st> <st c="11418">active
    widgets on the</st> *<st c="11440">Springboard</st>* <st c="11451">can consume
    a significant amount of power.</st> <st c="11495">Hence, we need to find more
    efficient ways to load our</st> <st c="11550">widgets efficiently.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11570">We mentioned efficiency in the</st> *<st c="11602">Understanding
    how widgets work</st>* <st c="11632">section, so let’s get down to the details.</st>
    <st c="11676">Unlike apps, widgets are not active even when they are visible.</st>
    <st c="11740">We can “wake” these widgets at specific times to reload their views.</st>
    <st c="11809">To set the specific periods, we need to create a timeline – an array
    of entries that contain points in time and</st> <st c="11921">relevant data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11935">For example, if we want to reload a calendar widget that displays
    the next event, we can create a timeline that holds an array of entries, one for
    each event.</st> <st c="12095">Each entry holds an event time and the name of
    the event that</st> <st c="12157">comes afterward.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12173">Conversely, if we want a calendar widget that displays full-day
    information, we may want to create a timeline with an entry for each day.</st>
    <st c="12312">In this case, each entry holds the time of the beginning of the
    day and the list of events</st> <st c="12403">that day.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12412">Creating a longer timeline can maximize the frequency of updates
    for</st> <st c="12482">our widget.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12493">Now, let’s turn to code and create our first timeline.</st> <st
    c="12549">Here is an example of a timeline provider that displays the</st> <st
    c="12609">next event:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13275">The preceding code consists of two structs –</st> `<st c="13321">EventEntry</st>`
    <st c="13331">and</st> `<st c="13336">Provider</st>`<st c="13344">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="13345">EventEntry</st>` <st c="13356">is a struct that conforms to</st>
    `<st c="13386">TimeLineEntry</st>` <st c="13399">protocol.</st> <st c="13410">The</st>
    `<st c="13414">TimeLineEntry</st>` <st c="13427">protocol represents a single
    entry in the widget timeline.</st> <st c="13487">The protocol contains a required
    variable</st> <st c="13529">named date:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13563">The</st> `<st c="13568">date</st>` <st c="13572">variable contains
    the entry point in time where we expect our widget to reload.</st> <st c="13653">Other
    than</st> `<st c="13664">date</st>`<st c="13668">, we added another variable that
    represents the entry’s next event title</st> <st c="13741">named</st> `<st c="13747">nextEvent</st>`<st
    c="13756">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13757">Our second</st> <st c="13769">struct is</st> `<st c="13779">Provider</st>`<st
    c="13787">. The</st> `<st c="13793">Provider</st>` <st c="13801">struct conforms
    to</st> `<st c="13821">TimeLineProvider</st>`<st c="13837">. The goal of the</st>
    `<st c="13855">Provider</st>` <st c="13863">struct is to generate a timeline so
    the</st> *<st c="13904">WidgetCenter</st>* <st c="13916">can reload the widget
    when needed.</st> <st c="13952">Let’s see how the</st> `<st c="13970">Provider</st>`
    <st c="13978">does that.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13989">Generating a timeline</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="14011">I mentioned earlier that a timeline is an array of timeline entries,
    but the reality is a little bit more</st> <st c="14118">complex than that.</st>
    <st c="14137">Looking at the timeline provider implementation, we can see several
    functions that help us to deliver a static UI at any</st> <st c="14258">given
    time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14269">The Provider struct is a protocol implementation</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14318">There’s no</st> <st c="14330">need to call the</st> `<st c="14347">Provider</st>`
    <st c="14355">functions directly.</st> <st c="14376">We pass the timeline provider
    to the widget configuration, and the configuration uses the</st> `<st c="14466">Provider</st>`
    <st c="14474">functions</st> <st c="14485">when needed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14497">The first and primary function is</st> `<st c="14532">getTimeLine</st>`<st
    c="14543">. Let’s look at the implementation of the</st> `<st c="14585">getTimeline</st>`
    <st c="14596">function here:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14833">The</st> `<st c="14838">getTimeline()</st>` <st c="14851">function</st>
    <st c="14861">creates an array of entries, wraps them in a</st> `<st c="14906">Timeline</st>`
    <st c="14914">struct, and returns it using the</st> `<st c="14948">completion</st>`
    <st c="14958">closure.</st> <st c="14968">There</st> <st c="14974">are two interesting
    things</st> <st c="15001">we can see here – the</st> `<st c="15023">Context</st>`
    <st c="15030">parameter and the</st> **<st c="15049">Timeline</st>** **<st c="15058">reload
    policy</st>**<st c="15071">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="15073">Context</st>` <st c="15080">– The</st> `<st c="15087">Context</st>`
    <st c="15094">parameter contains information about the widget environment, such</st>
    <st c="15161">as the widget family (is it a small widget?</st> <st c="15205">Perhaps
    medium?), or the actual widget size.</st> <st c="15250">If the widget UI shows
    more information when it is large, we probably want to load more data into our
    timeline entry.</st> <st c="15368">But the most important information here is
    probably the</st> `<st c="15424">isPreview</st>` <st c="15433">property, which
    indicates whether the widget appears in the widget gallery.</st> <st c="15510">Generally
    speaking, it is best practice to show real user data in our widget in the widget
    gallery, but that’s not only possible due to security or networking issues.</st>
    <st c="15677">Therefore, we can provide mock data for the widget gallery by checking
    the</st> `<st c="15752">isPreview</st>` <st c="15761">property.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15771">policy</st>` <st c="15778">– The timeline we provide to our
    widget has a final number of entries.</st> <st c="15850">So, what happens when
    they are done, and the timeline reaches its end?</st> <st c="15921">That’s exactly
    the</st> <st c="15940">role of the</st> `<st c="15952">policy</st>` <st c="15958">parameter
    when it describes the timeline reload behavior.</st> <st c="16017">There are several
    options –</st> `<st c="16045">atEnd</st>` <st c="16050">(</st>*<st c="16052">WidgetKit</st>*
    <st c="16062">requests a new timeline),</st> `<st c="16088">never</st>` <st c="16093">(</st>*<st
    c="16095">WidgetKit</st>* <st c="16105">doesn’t ask for a new timeline), and</st>
    `<st c="16142">after(date:Date)</st>` <st c="16158">(</st>*<st c="16160">WidgetKit</st>*
    <st c="16170">generates a new timeline in a specific date).</st> <st c="16216">The
    policy helps the</st> *<st c="16237">WidgetCenter</st>* <st c="16249">to optimize
    the timeline reloading</st> <st c="16285">mechanism better.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16302">Before we continue, a few words about timeline reloading optimization.</st>
    <st c="16374">The fact that we want to build our timeline as long as possible
    doesn’t mean that our widget needs to constantly reload.</st> <st c="16495">The</st>
    *<st c="16499">WidgetCenter</st>* <st c="16511">has a “budget” for each widget
    on the home screen, specifying times during the day when it performs refreshes.</st>
    <st c="16623">It’s in our interest to optimize the way our timeline is structured
    and to “save” the system budget.</st> <st c="16724">Carefully planning the timeline
    entries and reload policy can help us achieve relevant, event-driven</st> <st
    c="16825">refresh intervals.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16843">Going back to the</st> `<st c="16862">TimelineProvider</st>` <st
    c="16878">protocol, we can see additional two functions –</st> `<st c="16927">placeholder</st>`
    <st c="16938">and</st> `<st c="16943">getSnapshot</st>`<st c="16954">. Let’s</st>
    <st c="16962">implement them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16977">The first function is</st> `<st c="17000">getTimeline</st>`<st
    c="17011">, which returns a</st> `<st c="17029">Timeline</st>` <st c="17037">structure
    containing a list of entries with actual data for specific periods.</st> <st c="17116">But
    is it enough for our widget to be</st> <st c="17154">fully functional?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17171">The answer is no – there are two more cases when providing actual
    data may not</st> <st c="17251">be sufficient.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17265">The</st> `<st c="17270">placeholder</st>` <st c="17281">function
    answers the first use case.</st> <st c="17319">When the user adds a widget to
    their home screen,</st> *<st c="17369">WidgetKit</st>* <st c="17379">needs to
    display something immediately, before the widget fetches</st> <st c="17445">or
    updates real data from our app.</st> <st c="17480">The</st> `<st c="17484">placeholder</st>`
    <st c="17495">function returns temporary data just to show something to</st> <st
    c="17554">the user:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17672">In our example, we can see a</st> `<st c="17702">placeholder</st>`
    <st c="17713">function that returns the</st> `<st c="17740">English</st>` `<st
    c="17748">class</st>` <st c="17753">text.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17759">It is important to return temporary data instead of a loading
    indicator, for example, and that’s because we want our user experience to be consistent
    and smooth.</st> <st c="17922">It is also better to be creative and come up with
    elegant information.</st> <st c="17993">For example, if our widget has a timer
    or a time, it is a good idea to show 00:00 to indicate to the user that a timer
    should</st> <st c="18119">appear here.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18131">The second function is</st> `<st c="18155">getSnapshot</st>`<st
    c="18166">. The</st> `<st c="18172">getSnapShot</st>` <st c="18183">function is
    even more important than</st> `<st c="18221">placeholder</st>`<st c="18232">.
    When the user browses the widget gallery, the system presents the different widgets.</st>
    <st c="18319">These widgets are being presented without the</st> <st c="18365">system-generated
    timelines.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18392">The</st> `<st c="18397">getSnapshot</st>` <st c="18408">function
    returns a</st> `<st c="18428">TimelineEntry</st>`<st c="18441">-based struct with
    data to present in the</st> <st c="18484">widget gallery.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18499">Here’s an example of a</st> `<st c="18523">getSnapshot</st>` <st
    c="18534">function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18720">In this code, the</st> `<st c="18739">getSnapshot</st>` <st c="18750">function
    returns an example event with the current date.</st> <st c="18808">This snapshot
    demonstrates to the user the purpose of our</st> <st c="18866">widget easily.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18880">Note that in both</st> `<st c="18899">placeholder</st>` <st c="18910">and</st>
    `<st c="18915">getSnapshot</st>`<st c="18926">, we have the same</st> `<st c="18945">Context</st>`
    <st c="18952">parameter</st> <st c="18963">as the one we had in the</st> `<st
    c="18988">getTimeline</st>` <st c="18999">function.</st> <st c="19010">We need
    the</st> `<st c="19022">Context</st>` <st c="19029">for the same reason as before
    – to understand the environment surrounding</st> <st c="19104">our widget.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19115">Now that we understand how to generate a timeline provider, let’s
    discuss</st> <st c="19190">the</st> `<st c="19194">TimelineEntry</st>`<st c="19207">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19208">Building our TimelineEntry structure</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="19245">We can see by now that the</st> `<st c="19273">TimelineProvider</st>`
    <st c="19289">protocol is straightforward as there are only</st> <st c="19336">three
    functions to implement.</st> <st c="19366">One of the things we need to design
    here is</st> `<st c="19410">TimelineEntry</st>`<st c="19423">, and the</st> <st
    c="19433">reason for its importance is that it holds the information we need not
    only to determine when to present information but also what</st> <st c="19564">to
    present.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19575">The structure of</st> `<st c="19593">TimelineEntry</st>` <st c="19606">needs
    to fit our widget goal and be aligned with its UI.</st> <st c="19664">Because
    we pre-generate all the entries according to a timeline, we should perform all
    the calculations in advance and generate a structure that can help update the
    widget</st> <st c="19836">content easily.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19851">In fact,</st> `<st c="19861">TimelineEntry</st>` <st c="19874">may
    consist of</st> <st c="19890">four components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="19906">date</st>` <st c="19911">– The date</st> <st c="19923">when
    we want our widget to reload the specific entry information.</st> <st c="19989">Notice
    that in most cases, the</st> `<st c="20020">date</st>` <st c="20024">property
    is not part of the information presented on the screen.</st> <st c="20090">For
    example, in a calendar widget, we probably have a date property as part of the</st>
    `<st c="20173">TimelineEntry</st>` <st c="20186">protocol, and something like</st>
    `<st c="20216">eventDate</st>` <st c="20225">for the actual</st> <st c="20241">event
    time.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="20401">title</st>`<st c="20406">,</st> `<st c="20408">bodyText</st>`<st
    c="20416">, and</st> `<st c="20422">timeString</st>`<st c="20432">, can simplify
    our code and even</st> <st c="20465">increase performance.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="20819">TimelineEntry</st>` <st c="20832">is all that we have when the
    user interacts</st> <st c="20877">with it.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="20902">relevance</st>` <st c="20911">property is an optional property
    that we have as part of the</st> `<st c="20973">TimelineEntry</st>` <st c="20986">protocol.</st>
    <st c="20997">In the</st> `<st c="21004">relevance</st>` <st c="21013">property,
    we can determine the relevance priority of the entry to the user.</st> <st c="21090">For
    example, a to-do app that shows the next task to the user may want to set a high
    score to an entry with a critical task.</st> <st c="21215">Or, a sports app that
    shows the latest news in a widget may want to set a high score for entries that
    contain news about the user’s favorite team.</st> <st c="21362">The entries’ relevance
    values help</st> *<st c="21397">WidgetKit</st>* <st c="21407">to decide how and
    when to present widgets in the system.</st> <st c="21464">For example,</st> *<st
    c="21477">WidgetKit</st>* <st c="21487">may decide to rotate the stack widget
    and show a widget with high-relevance information.</st> <st c="21576">Let’s see
    an example how to set</st> `<st c="21608">relevance</st>` <st c="21617">for</st>
    <st c="21622">a</st> `<st c="21624">TimeLineEntry</st>`<st c="21637">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="22276">Now that we have created a timeline, let’s turn to the main topic,
    which is building our</st> <st c="22366">widget UI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22376">Building our widget UI</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="22399">Creating a timeline of entries is critical for our widget to provide
    accurate and relevant information</st> <st c="22503">to the user.</st> <st c="22516">But
    to do that, we also need to render the widget UI.</st> <st c="22570">The place
    where we do that is in the widget’s structure, as we saw at the beginning of this
    chapter in the</st> *<st c="22677">Configuring our</st>* *<st c="22693">widget</st>*
    <st c="22699">section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22708">Let’s see the</st> <st c="22723">configuration again:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="22891">As we can see, the</st> `<st c="22910">StaticConfiguration</st>`
    <st c="22929">has a view builder that returns a SwiftUI view, and this is probably
    the first thing we need to understand in</st> *<st c="23040">WidgetKit</st>* <st
    c="23050">– widgets are built with SwiftUI only.</st> <st c="23089">If you still
    haven’t got any experience with SwiftUI,</st> *<st c="23143">WidgetKit</st>* <st
    c="23153">is a great opportunity</st> <st c="23176">to start.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23185">Something that might have caught your attention is the</st> `<st
    c="23241">containerBackground</st>` <st c="23260">view modifier.</st> <st c="23276">If
    you remember, we have discussed how widgets now can be shown in different places
    in the Apple ecosystem –</st> *<st c="23385">iOS</st>* <st c="23388">(both home
    screen and lock screen),</st> *<st c="23425">padOS</st>*<st c="23430">,</st> *<st
    c="23432">macOS</st>*<st c="23437">, and</st> *<st c="23443">watchOS</st>*<st
    c="23450">. But the primary issue with having our widgets on different platforms
    might be the</st> <st c="23534">widget’s background.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23554">Adding the</st> `<st c="23566">containerBackground</st>` <st c="23585">view
    modifier ensures that the widget’s background adjusts itself to its container
    and always looks good, no matter where</st> <st c="23708">it appears.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23719">If we look at</st> <st c="23734">our code example again, we can
    see that</st> `<st c="23774">MyWidgetEntryView</st>` <st c="23791">receives one
    parameter, which is the current timeline entry.</st> <st c="23853">Let’s see what
    we can learn</st> <st c="23881">from it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23889">Working with timeline entries</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="23919">Connecting the timeline entry to the widget view is the core of
    how widgets work.</st> <st c="24002">The main role of</st> *<st c="24019">WidgetCenter</st>*
    <st c="24031">is to generate a timeline and provide our widget with the right
    timeline entry at the</st> <st c="24118">right time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24129">The widget</st> <st c="24141">configuration view builder has one
    parameter, a specific timeline entry, so we can return a widget view with</st>
    <st c="24250">relevant data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24264">Here’s an example of a widget view that uses a specific</st> <st
    c="24321">timeline entry:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24632">This code</st> <st c="24643">example shows a simple view that
    shows the next event title and time while using the</st> <st c="24728">timeline
    entry.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24743">There are two things we can learn from the way the timeline entry
    works with the</st> <st c="24825">widget view:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24837">The entry should contain all the widget’s data</st>** <st c="24884">–
    We discussed it when we talked about the timeline provider, but now we can see
    why.</st> <st c="24971">Widgets need to be as static and simple as possible.</st>
    <st c="25024">We don’t want to perform any data fetching operations while the
    view</st> <st c="25093">is displayed.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="25106">There is no state</st>** <st c="25124">– Unlike regular SwiftUI
    views, our widget view doesn’t have a state.</st> <st c="25195">There are cases
    where we probably would want to see different views for different situations.</st>
    <st c="25289">For example, in our</st> *<st c="25309">next event</st>* <st c="25319">widget
    example, maybe we want to show a</st> *<st c="25360">connect to your calendar</st>*
    <st c="25384">message if the user hasn’t approved his calendar permissions.</st>
    <st c="25447">To do that, we need to generate different timeline entries and perhaps
    show a different view in the static configuration closure.</st> <st c="25577">Either
    way, we should do these checks</st> <st c="25615">in advance.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25626">Even though the widgets are naturally static, their UI doesn’t
    have to stay static and bold.</st> <st c="25720">In</st> `<st c="25723">WidgetKit</st>`<st
    c="25732">, it is possible to bring life to our widget by animating</st> <st c="25790">the
    changes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25802">Adding animations</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="25820">We already</st> <st c="25832">know how animations in iOS development
    work – view animations work by transitioning between two or more states.</st>
    <st c="25944">For example, if a specific view has an opacity of</st> `<st c="25994">1.0</st>`
    <st c="25997">and we change it to</st> `<st c="26018">0.5</st>`<st c="26021">,
    UIKit and SwiftUI can animate that change if</st> <st c="26068">we like.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26076">Widgets are written in SwiftUI, and in SwiftUI, we can animate
    state changes.</st> <st c="26155">However, widgets don’t use state at all.</st>
    <st c="26196">Instead, we change the widget content using the timeline provider
    (perhaps we can say that, in a way, the timeline entry is our</st> <st c="26324">widget
    state).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26338">Starting with iOS 16, whenever the</st> *<st c="26374">WidgetCenter</st>*
    <st c="26386">reloads a widget and changes its content using a new entry, it performs
    this</st> <st c="26464">transition automatically.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26489">Can we</st> <st c="26497">customize this animation even if we
    don’t have a state in widgets?</st> <st c="26564">Of course we can,</st> <st c="26582">using</st>
    `<st c="26588">contentTransition</st>`<st c="26605">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26606">As mentioned, in most cases, SwiftUI performs animations based
    on a state change.</st> <st c="26689">For example, look at the</st> <st c="26714">following
    code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26941">In this code example, we have a view and a button.</st> <st c="26993">Tapping
    on the button changes the view color, and it does that using the</st> `<st c="27066">withAnimation</st>`
    <st c="27079">function.</st> <st c="27090">Clearly, that can’t work in a widget
    because we need a state to</st> <st c="27154">do that.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27162">Instead, what we</st> <st c="27180">need to do is define how the
    content changes when it’s animated.</st> <st c="27245">To do that, we can</st>
    <st c="27264">use</st> `<st c="27268">contentTransition</st>`<st c="27285">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="27462">contentTransition</st>` <st c="27480">is a view modifier we
    can add to views to define their transition method.</st> <st c="27555">Imagine
    that all content changes in widgets are done with</st> `<st c="27613">withAnimation</st>`
    <st c="27626">in mind and all we have to do is to change the</st> <st c="27674">transition
    method.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27692">Take, for example, the following</st> <st c="27726">code snippet:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'struct MyWidgetEntryView : View {'
  prefs: []
  type: TYPE_NORMAL
- en: 'var entry: Provider.Entry'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var body: some View {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text("Time:")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Text(entry.nextEventTime, style: .time)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text("Next Event")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text(entry.nextEvent) <st c="28429">.contentTransition(.numericText())</st>
    }
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'struct CalendarWidgetIntent: WidgetConfigurationIntent {'
  prefs: []
  type: TYPE_NORMAL
- en: 'static var title: LocalizedStringResource = "Select'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calendar"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Parameter(title: "Calendar") var calendar:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CalendarEntity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'struct CalendarEntity: AppEntity {'
  prefs: []
  type: TYPE_NORMAL
- en: 'let id: String'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let name: String'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'static var typeDisplayRepresentation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeDisplayRepresentation = "Calendar"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static var defaultQuery = CalendarQuery()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var displayRepresentation: DisplayRepresentation {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DisplayRepresentation(title: name)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'struct CalendarQuery: EntityQuery {'
  prefs: []
  type: TYPE_NORMAL
- en: 'func entities(for identifiers: [CalendarEntity.ID])'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async throws -> [CalendarEntity] {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: allCalendars.filter { identifiers.contains($0.id) }
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: func suggestedEntities() async throws ->
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[CalendarEntity] {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: allCalendars
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: func defaultResult() async -> CalendarEntity? {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nil
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'AppIntentConfiguration(kind: kind, <st c="33478">intent:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="33485">CalendarWidgetIntent.self,</st> provider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ConfigurableProvider(), content: { entry in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ConfigurableWidgetView(entry: entry)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'struct ConfigurableProvider: AppIntentTimelineProvider {'
  prefs: []
  type: TYPE_NORMAL
- en: 'func timeline(for configuration: CalendarWidgetIntent,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'in context: Context) async ->'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Timeline<ConfiguredNextEventEntry>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'let timeline = Timeline(entries: entries, <st c="35357">WidgetCenter</st> to
    reload the timeline immediately, due to data changes or any other alterations.'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35451">Let’s see how</st> <st c="35466">it happens.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35477">Reload widgets using the WidgetCenter</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35515">Throughout</st> <st c="35527">the chapter, I have mentioned</st>
    *<st c="35557">WidgetCenter</st>* <st c="35569">frequently but I haven’t explained
    what</st> <st c="35610">it means.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="35619">WidgetCenter</st>* <st c="35632">is an object that holds information
    about the different configured widgets currently used, and it also provides an
    option to</st> <st c="35758">reload them.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35770">To use</st> `<st c="35778">WidgetCenter</st>`<st c="35790">, we
    need to call the</st> `<st c="35812">shared</st>` <st c="35818">property to access
    its</st> <st c="35842">singleton reference:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35882">The difference between</st> *<st c="35906">WidgetCenter</st>*
    <st c="35918">and the rest of the code we have handled up until now is the fact
    that we call</st> *<st c="35998">WidgetCenter</st>* <st c="36010">from the app
    and not the</st> <st c="36036">widget extension.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36053">Let’s see how we can call the</st> `<st c="36084">WidgetCenter</st>`
    <st c="36096">to get a list of</st> <st c="36114">active widgets:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36278">The</st> `<st c="36283">getCurrentConfigurations</st>` <st c="36307">function
    uses a closure to return an array of active widgets.</st> <st c="36370">Each one
    of them is the</st> `<st c="36394">WidgetInfo</st>` <st c="36404">type – a structure
    that contains information</st> <st c="36450">about a specific</st> <st c="36467">configured
    widget.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36485">The</st> `<st c="36490">WidgetInfo</st>` <st c="36500">structure
    has three properties – kind, family,</st> <st c="36548">and configuration:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="36566">kind</st>` <st c="36571">– This is the string we set when we
    created the widget configuration (look again at the</st> *<st c="36660">Configuring
    our</st>* *<st c="36676">widget</st>* <st c="36682">section).</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="36692">family</st>` <st c="36699">– The family size of the widget –
    small, medium,</st> <st c="36749">or large.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="36758">configuration</st>` <st c="36772">– The intent that contains
    user configuration information.</st> <st c="36832">The</st> `<st c="36836">configuration</st>`
    <st c="36849">property</st> <st c="36859">is optional.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36871">If needed, we can use that information to reload the timeline
    of a specific kind of widget.</st> <st c="36964">For example, if we want to reload
    widgets with the kind of</st> `<st c="37023">MyWidget</st>`<st c="37031">, we
    need to call</st> <st c="37049">the following:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="37119">Notice that the function says</st> `<st c="37150">Timelines</st>`
    <st c="37159">and not</st> `<st c="37168">Timeline</st>`<st c="37176">, as it
    is possible to have several widgets of the</st> <st c="37227">same kind.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37237">If we want to reload all our app widgets, we can call the</st>
    `<st c="37296">reloadAllTimelines()</st>` <st c="37316">function:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="37326">WidgetCenter.shared.reloadAllTimelines()</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37367">There are several great use cases for reloading our widget timeline,
    such as when we get a push notification, or when the user data or settings have
    changed.</st> <st c="37526">If you remember, when we discussed the widget timeline
    in the</st> *<st c="37588">Generating a timeline</st>* <st c="37609">section,
    we talked about the fact that widgets have a certain budget for the amount of
    reloading they can do each day.</st> <st c="37729">But the good news is that calling
    the</st> `<st c="37767">reloadTimelines</st>` <st c="37782">or</st> `<st c="37786">reloadAllTimelines</st>`
    <st c="37804">functions doesn’t count in this budget if our app is in the foreground
    or uses some other technique, such as playing audio in</st> <st c="37931">the
    background.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37946">In most</st> <st c="37955">cases,</st> `<st c="37962">reloadTimelines</st>`
    <st c="37977">works well when the updated data is already on the device or in
    our app.</st> <st c="38051">But what should we do when the local persistent store
    is</st> <st c="38108">not updated?</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38120">We perform a network request,</st> <st c="38151">of course!</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38161">Go to the network for updates</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38191">Performing a network request to update local data is a typical
    operation in mobile apps.</st> <st c="38281">But how</st> <st c="38289">does it
    work</st> <st c="38302">in widgets?</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38313">Let’s look at the</st> `<st c="38332">getTimeline</st>` <st c="38343">function
    again:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'func getTimeline(in context: Context, completion: @escaping'
  prefs: []
  type: TYPE_NORMAL
- en: (Timeline<SimpleEntry>) -> Void) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var entries: [SimpleEntry] = [] <st c="38822">calendarService.fetchNextEvents
    { result in</st> switch result {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case .success(let events):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: for event in events {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let entry = SimpleEntry(date:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'event.alertTime, nextEvent:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'event.title, nextEventTime:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: event.date)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: entries.append(entry)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case .failure(let error):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print("Error fetching next events:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: \(error.localizedDescription)")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let timeline = Timeline(entries: entries, policy:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .atEnd)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: completion(timeline)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: http://www.myGreatCalendarAp.com/event/<eventID>/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'struct MyWidgetEntryView : View {'
  prefs: []
  type: TYPE_NORMAL
- en: 'var entry: Provider.Entry'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var body: some View {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text("Time:")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Text(entry.nextEventTime, style: .time)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text("Next Event")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text(entry.nextEvent) <st c="41571">.widgetURL(URL(string:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41593">"</st>https://www.myGreatCalendarApp.com/event/\(entry.eventID)/"<st
    c="41654">))</st> }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Button("Turn \(entry.isAlarm ? "Off" : "On") Alarm" , role:'
  prefs: []
  type: TYPE_NORMAL
- en: nil, <st c="43802">entry.isAlaram</st> value. But what’s more interesting here
    is that we have an additional parameter called <st c="43904">Intent</st>, where
    we pass a struct named <st c="43941">MyWidgetIntent</st> along with the <st c="43971">eventID</st>.
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43979">Let’s talk about the App Intent, but this time, in the context
    of</st> <st c="44046">user interaction.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44063">Performing the data change using the intent</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44107">We have already said that the widget doesn’t manage any state.</st>
    <st c="44171">Therefore, the real widgets</st> <st c="44199">state is some kind
    of a combination between a local store and the</st> <st c="44265">timeline provider.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44283">The</st> `<st c="44288">MyWidgetIntent</st>` <st c="44302">receives
    an</st> `<st c="44315">eventID</st>` <st c="44322">and is responsible for reaching
    out to</st> `<st c="44362">EventKit</st>` <st c="44370">and updating the actual
    event</st> <st c="44401">alarm information.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44419">Let’s look at the</st> <st c="44438">App Intent:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="44780">Besides the</st> `<st c="44793">LocalizedStringResource</st>`
    <st c="44816">static property that we discussed in the</st> *<st c="44858">Customize
    our widget</st>* <st c="44878">section, we have one primary function called</st>
    `<st c="44924">perform()</st>`<st c="44933">. The</st> `<st c="44939">perform()</st>`
    <st c="44948">function executes when the user taps on the button that is linked
    to that App Intent.</st> <st c="45035">Notice that the</st> `<st c="45051">perform()</st>`
    <st c="45060">function is also an async function that lets us perform</st> <st
    c="45117">heavier tasks, such as writing to the database or even performing a</st>
    <st c="45185">URL request.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45197">Once the</st> `<st c="45207">perform()</st>` <st c="45216">function
    completes its execution, the App Intent triggers</st> <st c="45275">the</st> *<st
    c="45279">WidgetCenter</st>*<st c="45291">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45292">Updating the widget UI</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45315">Now that the local store is updated, it’s time for the</st> *<st
    c="45371">WidgetCenter</st>* <st c="45383">to reload the Timeline</st> <st c="45407">Provider.</st>
    <st c="45417">We should already be familiar with that process – the Timeline Provider
    fetches the relevant local data and builds a timeline based on the changes we
    just performed.</st> <st c="45583">At the end, the widget UI is</st> <st c="45612">being
    updated.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45626">Working with App Intent is also great if we want to share code
    execution between different app components.</st> <st c="45734">For example, we
    can share logic code between our widget and the</st> <st c="45798">Siri Shortcut.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45812">We should remember that even if the widget could have a runtime
    of its own, it is still a good practice to separate our code for better flexibility</st>
    <st c="45961">and modularity.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45976">Another great usage for App Intent is the control widget, another
    great addition to iOS 18\.</st> <st c="46069">Let’s go over</st> <st c="46083">it
    now.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46090">Adding a control widget</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="46114">WidgetKit</st>* <st c="46125">provides ways</st> <st c="46139">to
    present our apps in the springboard.</st> <st c="46179">However, it doesn’t stop
    there.</st> <st c="46211">Starting iOS 18, it is possible to present widgets in
    the control center and on the lock screen and even attach an App Intent to the
    action button in iPhone</st> <st c="46368">15 Pro.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46375">Adding a widget to the control center or the lock screen</st>
    <st c="46433">is easy.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46441">Similar to how we create a widget by conforming to the Widget
    protocol, we need to conform to the</st> `<st c="46540">ControlWidget</st>` <st
    c="46553">protocol to create a control widget.</st> <st c="46591">For example,
    imagine we have an app that helps us control smart home accessories, and we want
    to create a widget</st> <st c="46704">that opens and closes our home’s main door.</st>
    <st c="46748">Let’s start by creating a simple control widget</st> <st c="46796">called</st>
    `<st c="46803">MaindoorControl</st>`<st c="46818">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="47012">In this code example, the</st> `<st c="47039">MaindoorControl</st>`
    <st c="47054">widget contains the</st> `<st c="47075">body</st>` <st c="47079">variable
    from the time of</st> `<st c="47106">ControlWidgetConfiguration</st>`<st c="47132">.
    This is very similar to how we created a home screen widget under the</st> *<st
    c="47204">Configuring our</st>* *<st c="47220">widget</st>* <st c="47226">section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47235">In this case, we return an instance of the</st> `<st c="47279">StaticControlConfiguration</st>`
    <st c="47305">type, which means we don’t give the user the ability to configure
    it.</st> <st c="47376">However, similar to the home screen widget, we can also
    add a user-configurable control widget by returning</st> `<st c="47484">AppIntentControlConfiguration</st>`
    <st c="47513">(look in the</st> *<st c="47527">Customize our</st>* *<st c="47541">widget</st>*
    <st c="47547">section).</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47557">We can add two control widget controls – a toggle and a button.</st>
    <st c="47622">In the case of controlling our home’s main door state, we need to
    add a toggle.</st> <st c="47702">Let’s modify our code and add a</st> `<st c="47734">ControlWidgetToggle</st>`
    <st c="47753">instance:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <st c="48141">In this</st> <st c="48150">code example, we add the</st> `<st
    c="48175">ControlWidgetToggle</st>`<st c="48194">, containing the</st> <st c="48211">following
    parameters:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="48232">A title</st>** <st c="48240">– The widget title that appears
    for the widget in the</st> <st c="48295">widget gallery.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="48310">isOn</st>` <st c="48315">– Here, we connect the widget to the
    actual state in</st> <st c="48369">our app.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="48377">action</st>` <st c="48384">– The App Intent that runs when the
    user taps our control widget.</st> <st c="48451">We’ll cover that later in</st>
    <st c="48477">this section.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="48545">Label</st>` <st c="48550">displays the control state’s title
    and</st> <st c="48590">an image.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="48599">The widget instance is straightforward.</st> <st c="48640">Let’s
    see how it looks in our control center (</st>*<st c="48686">Figure 5</st>**<st
    c="48695">.5</st>*<st c="48697">):</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.5: Our control widget in the control center](img/B21795_05_5.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="48702">Figure 5.5: Our control widget in the control center</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="48754">Figure 5</st>**<st c="48763">.5</st>* <st c="48765">shows the
    control center’s main door control widget.</st> <st c="48819">However, there’s
    another side</st> <st c="48849">to our control widget – connecting the control
    widget to the action of opening and closing the main door.</st> <st c="48955">Let’s
    look at the</st> `<st c="48973">MaindoorIntent</st>` <st c="48987">struct we saw
    in the</st> `<st c="49009">action</st>` <st c="49015">parameter:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49275">In this code example, we see the</st> `<st c="49309">MaindoorIntent</st>`
    <st c="49323">implementation.</st> <st c="49340">The</st> `<st c="49344">MaindoorIntent</st>`
    <st c="49358">structure conforms to the</st> `<st c="49385">SetValueIntent</st>`
    <st c="49399">protocol, which contains a value we can set.</st> <st c="49445">In
    this example, the value is from the</st> `<st c="49484">Bool</st>` <st c="49488">type,
    which we can use to perform the</st> <st c="49527">desired operation.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="49545">Adding a</st> <st c="49555">control widget to our app involves
    similar practices that we saw when we added a home screen widget and app intents
    that allow us to share code between widgets and other</st> <st c="49725">app components.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="49740">Summary</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="49748">Widgets are enjoyable and fun UI elements we can work with in
    iOS development.</st> <st c="49828">They provide sleek UI, great animation, and
    a glanceable user experience.</st> <st c="49902">We have seen that each iOS version
    has added interesting new widget capabilities to make widgets more powerful</st>
    <st c="50013">than ever.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50023">In this chapter, we learned about the idea of widgets, how to
    add widgets, creating a timeline, and adding user-configurable options.</st> <st
    c="50158">Also, we learned how to create custom animations and even add user interaction.</st>
    *<st c="50238">WidgetKit</st>* <st c="50248">has become a fascinating framework
    to work with.</st> <st c="50297">In the next chapter, we’ll continue to discover
    how to improve the user experience, this time with</st> <st c="50396">SwiftUI
    animations.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
