<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. SpriteKit and 2D Game Design</h1></div></div></div><p class="calibre8">Now that we understand the basics of coding in Swift, the generic flow and class structure of an iOS app, as well as the optional structuring of apps with storyboards and segues, we can move on to transforming our apps into playable games.</p><p class="calibre8">For this chapter, we will begin with the 2D game design and game development framework created exclusively by Apple for iOS game developers known as SpriteKit. SpriteKit first became available with iOS 7 to help simplify the game development process for the family of iOS devices. The framework runs a typical rendering loop to draw and update 2D objects/sprites to your game's scene. There's much going on behind the scenes to run this loop and draw your game sprites. Thankfully, Apple built the first party game development frameworks to do much of the heavy lifting for us. This way, we can focus more on making the game itself without worrying too much about how that game will connect and run with the hardware, something developers in the past had to contend with.</p><p class="calibre8">Every update of iOS and Xcode continues to add more tools and frameworks to improve the ease of game design, including the companion framework introduced first at <em class="calibre10">WWDC15</em> for iOS 9 known as <a id="id121" class="calibre1"/><strong class="calibre9">GameplayKit</strong>. GameplayKit can allow us to separate, copy, and modularize the game logic and even copy for use in future game projects, be it SpriteKit or the 3D framework of our next chapter, SceneKit. We will go over GameplayKit in later chapters as well. At the end of this chapter, we will look at a complete game example that is for a simple game in its gameplay but somewhat complex in its logic.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec27" class="calibre1"/>A brief history of iOS game development engines</h1></div></div></div><p class="calibre8">SpriteKit <a id="id122" class="calibre1"/>and the 3D game framework, SceneKit, were not the first methods used for developing games in iOS. We'll quickly see why it became a welcomed addition to the developer toolset. Initially, we, the game developers, had to practically talk directly with the GPU using the OpenGL API to put both 2D and 3D graphics/vertices on to the screen. On the upper level, there always was Foundation and CocoaTouch to interact with user gestures to manipulate UIKit objects, but dealing with game development essentials, such as SpriteSheets, mipmaps, normal maps, partial emitters, bounding boxes, and culling, involved some level of lower-level structuring. Apple made those calls to various graphics buffers and VBOs slightly easier when they created their GLKit framework in 2011. Thankfully, various third-party frameworks, such as Cocos2D, Box2D, Sparrow, GameMaker, Unity, Unreal Engine, and others made this process less engineering-intensive in an effort to keep the <em class="calibre10">design</em> aspect of game design the focus. GameMaker, Unity, and Unreal Engine are more sandboxing- / drag-and-drop-styled engines akin to the mentality behind storyboards and segues, while engines such as Cocos2D and Sparrow are more code-heavy / boilerplate OOP structures that shortcut the initial coding buildup. Engines such as Unity and Unreal Engine are great in that they offer a more hands-on sandboxing-type environment with various features that simplify the MVC model. Some drawbacks to such engines are that they are sometimes closed source, usually cost money to utilize to their fullest and aren't device-specific (Unity particularly falls into this category). Working with these visual engines could sometimes <a id="id123" class="calibre1"/>lead to optimizations being required in platform-specific IDEs such as Xcode, due to a sometimes <em class="calibre10">one-size-fits-all</em> methodology. Apple's SpriteKit and the 3D API, SceneKit which we'll see later, give us a first-party platform-specific middle ground that grants the developer both upper-level API editing, but even lower-level graphic API (OpenGL/Metal) customizations.</p><div><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre8">The negatives to sandbox/drag-and-drop-styled engines have decreased over time. Engines used by AAA studios, such as Unreal Engine, Unity, Havok, and others have lessened their upper-level ambiguity between the API and targeted devices' lower-level code. A good example of this would be Unity's IL2CPP, which converts the upper-level API calls directly to fast device-specific C++ code. This includes code and graphics pipeline optimizations that make use of Apple's slim Metal API. This homogenization of upper level applications with traditional boilerplate code now allows developers from all skill levels to make amazing games. That is why from iOS 8, iOS 9, and onwards, the Apple game development frameworks adopted a more visual design methodology. Xcode 7 introduced game state machines, components, and the ability to edit/copy and reuse player actions and animations throughout your projects. This allows developers to work specifically in iOS/Xcode while utilizing the visual design benefits of the device-independent game engines.</p></div><p class="calibre8">For this chapter, we will learn how to make a tile puzzle game named <code class="email">SwiftSweeper</code> using the SpriteKit framework and with a more traditional boilerplate code method. This means that we will make our first demo game in a code-heavy / model-centric fashion. Not only will this give us a look into the inner workings of SpriteKit's code but it will also let us utilize more from the Swift programming language from <a class="calibre1" title="Chapter 1. The Swift Programming Language" href="part0014_split_000.html#DB7S1-d06b23b4a4554b3182353558917969c2">Chapter 1</a>, <em class="calibre10">The Swift Programming Language</em>.</p><p class="calibre8">We will conclude this chapter by briefly mentioning Apple's latest SpriteKit demo game, DemoBots, which utilizes more of the visual tools/frameworks from Xcode 7 and later. Seeing the more code-intensive method first though will later let us appreciate the time saved with these newer tools.</p><p class="calibre8">Apple has gone out <a id="id124" class="calibre1"/>of their way to mimic the visual design methodology to game design seen in other engines since game design is as much about code/logic as it is about art and design.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>The game loop</h1></div></div></div><p class="calibre8">The game loop <a id="id125" class="calibre1"/>is a game developer's roadmap. The names differ depending on the framework and platform, but the same rules apply. The game loop comprises of all the methods, physics updates, and draw calls that occur during a single frame of your game and their order of execution. The golden rule to game development is to try to keep this loop always spinning in full iterations at no slower than 16.6 milliseconds, or 60 frames per second.</p><p class="calibre8">There are aspects of the game loop that don't have to be controlled by the game developer as much as they used to be in the past, though we do have the option to work down to the very GPU calls using OpenGL, or even better, Apple's Metal API. We will discuss more on these topics later on.</p><p class="calibre8">Here is what the SpriteKit <a id="id126" class="calibre1"/>game loop looks like:</p><div><img src="img/00020.jpeg" alt="The game loop" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The preceding is an illustration given to us directly from the Apple Developer site. We see a number of functions that are called during a single frame. The first function iterated through is <code class="email">update()</code>. The <code class="email">update()</code> function is where we add most of our own game-specific updates and various checks on game objects (such as positions and character statuses). </p><p class="calibre8">The loop structure gives us the option to do updates after we know a certain set of tasks in the frame have <a id="id127" class="calibre1"/>happened, that's where <code class="email">didEvaluateActions()</code>, <code class="email">didSimulatePhysics()</code>, <code class="email">didApplyConstraints()</code>, and <code class="email">didFinishUpdate()</code> functions <a id="id128" class="calibre1"/>come in handy.</p><div><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">Anyone coming from Unity might be familiar with its general game loop functions, such as <code class="email">Awake()</code>, <code class="email">Start()</code>, <code class="email">FixedUpdate()</code>, <code class="email">update()</code>, and <code class="email">LateUpdate()</code>. The SpriteKit game loop allows some similar code/render flow, but as we'll see, there are some slight differences.</p><p class="calibre8">For more on the game <a id="id129" class="calibre1"/>loop and its functions, see the following link from the Apple documentation at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html">https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html</a>.</p></div><p class="calibre8">Utilizing the other game loop methods could make sure certain calls in your game don't go out of order and can even help with the important task of making the most out of each frame in a fast, efficient manner.</p><p class="calibre8">For instance, in the public game PikiPop, mentioned previously, here's how the game uses the game loop in its main <code class="email">GameScene.swift</code> code:</p><div><pre class="programlisting">//Update() Example
//From main GameScene.swift
override func update(currentTime: CFTimeInterval) {
        //Update player
        if(player?.isPlayable==true){
            player!.update(currentTime)
        }
    }</pre></div><p class="calibre8">The preceding code first checks whether the player is playable with the <code class="email">isPlayable</code> Boolean. This status can mean a number of things, like if the player is alive or not, is spawning, and so on. The game loop's <code class="email">update()</code> function, which is being overridden from its parent <code class="email">update()</code> function of the <code class="email">SKScene</code> object, takes a parameter of the time utility type <code class="email">CFTimeInterval</code>. <code class="email">CFTimeInterval</code> is a special Core Foundation double type that measures time in seconds and thus updates the player object (if not null) during each interval.</p><p class="calibre8">As a brief summary of PikiPop, it's a procedural 2D side-scrolling game somewhat similar to the game Flappy Bird. Unlike Flappy Bird, Piki is able to traverse the game in all directions based on player taps and swipes. Piki could get trapped between the stage objects and the edge of the stage.</p><div><img src="img/00021.jpeg" alt="The game loop" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The preceding image is Piki getting injured if pushed into the left-hand side of the screen.</p><p class="calibre8">Edges in that game's stages use SpriteKit's own special objects named <strong class="calibre9">SKConstraints</strong>. More on these later, but in <a id="id130" class="calibre1"/>short, they dictate the range and orientation SpriteKit sprites can take. Sprites in SpriteKit (both developer-defined objects, such as <a id="id131" class="calibre1"/>PikiPop's Player object and the default <code class="email">SKSpriteNode</code>) are all <a id="id132" class="calibre1"/>derived from <code class="email">SKNode</code> objects that work with <code class="email">SKConstraints</code> and other physics-based framework functionality.</p><p class="calibre8">We could check whether Piki is being pushed against the corner in the <code class="email">update()</code> part of the game loop, but since constraints are part of the framework's physics architecture, it's best to do this check during the <code class="email">didSimulatePhysics()</code> portion of the render loop of <code class="email">SKScene</code> as seen here:</p><div><pre class="programlisting">override func didSimulatePhysics() {
    
    //run check on Player
    let block: (SKNode!, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt;
	Void  = { node, stop in
        /*checks if the node is the player and is moved/crushed to the left by a physics object.  This is done by comparing the node's position to a position that is, in this case, less than 26% off the left side of the screen; calculated by multiplying the screen's width by 0.26  */
        if let playerNode = node as? Player{
            if (playerNode.position.x &lt; self.frame.size.width*0.26 &amp;&amp; playerNode.isPlayable) {
                playerNode.playerHitEdge()
            }
            
        }

    }


...more code</pre></div><p class="calibre8">The first part of this code, <code class="email">let block: (SKNode!, UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void  = { node, stop in</code>, is done in what's known as a <strong class="calibre9">block</strong> or a <strong class="calibre9">closure</strong> syntax, which Swift lets us do rather dynamically. Don't mind the details of this kind of code for the moment; just note that we check the player's position in <em class="calibre10">x</em> <a id="id133" class="calibre1"/>versus the edge of the window's frame in this portion of the <a id="id134" class="calibre1"/>game loop.</p><div><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre8">Here's more <a id="id135" class="calibre1"/>information on <a id="id136" class="calibre1"/>writing blocks/closures in Swift:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html</a>
</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Tile game – SwiftSweeper</h1></div></div></div><p class="calibre8">Time to stop <a id="id137" class="calibre1"/>talking about SpriteKit and get right into it! As stated at the beginning of this chapter, we will first show you how to make a simple-looking tile game in SpriteKit using the slightly more difficult boilerplate/code-drive-styled design. Don't worry, this is not going to involve direct calls to the GPU with C++ and handling extremely tiny memory requirements like veteran game developers did during the early console days. However, we will be using lots of code-heavy calls with SpriteKit objects, functions, and classes. Granted, getting down into the code directly is continually becoming less of the developer's responsibility as Apple continues to make more design-centric functionalities in Xcode. </p><p class="calibre8">Knowing the code structure can give you an edge over developers coming in on a more top-down methodology and coding will always be behind custom game logic.</p><div><img src="img/00022.jpeg" alt="Tile game – SwiftSweeper" class="calibre11"/></div><p class="calibre12"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec33" class="calibre1"/>What is SwiftSweeper?</h2></div></div></div><p class="calibre8">
<code class="email">SwiftSweeper</code> is a <a id="id138" class="calibre1"/>clone of the classic tile puzzle game, MineSweeper, written entirely in Swift. <code class="email">SwiftSweeper</code> makes use of Swift's ability to use Unicode emoticons so that we don't have to use many image assets and should give us a great starting point to making our own tile/puzzler game with difficulty levels.</p><p class="calibre8">We will build up much of the <a id="id139" class="calibre1"/>game from scratch, but the full source code can be found at <a class="calibre1" href="https://github.com/princetrunks/SwiftSweeper">https://github.com/princetrunks/SwiftSweeper</a>.</p><div><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre8">As at the time writing of this book, this was built in Xcode 7 Beta (7A120f) for the initial iOS 9 release and optimized for iPhone.</p></div><p class="calibre8">The goal of the game is to tap every tile on the game board without hitting mines hidden throughout the board. You do get some help though. Every tile that isn't a mine will tell the player how many tiles around it are mines. If the player knows that a tile without a doubt is a mine via the process of elimination, they can plant a flag on that tile to make sure that they don't tap that space. Tap all of the tiles that aren't a mine to win the game! <code class="email">SwiftSweeper</code> even saves the time it took you to win for each difficulty level you chose to give the game a bit of replay value.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>Creating our SpriteKit game</h1></div></div></div><p class="calibre8">Now that we <a id="id140" class="calibre1"/>know the goal of our game, here's how we go about building it in SpriteKit:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, open Xcode and create a new project.</li><li class="listitem" value="2">Now select the Game template and click on <strong class="calibre9">Next</strong>.<div><img src="img/00023.jpeg" alt="Creating our SpriteKit game" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">Next, fill in the product name. We will name this project <code class="email">SwiftSweeperExample</code> and make sure that the language is Swift with <strong class="calibre9">SpriteKit</strong> selected as the game technology as well as the devices set to iPhone.<div><img src="img/00024.jpeg" alt="Creating our SpriteKit game" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="4">Then, click on <strong class="calibre9">Next</strong>, and we now have a brand new SpriteKit game project with a number of files already written up for us to get us started.</li><li class="listitem" value="5">Now click on the project's main file in the navigation pane and deselect all but the <strong class="calibre9">Portrait</strong> <a id="id141" class="calibre1"/>selection in the <strong class="calibre9">Device Orientation</strong> field.<div><img src="img/00025.jpeg" alt="Creating our SpriteKit game" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="6">Since we are going to work mostly with code, we can also either ignore or delete the <code class="email">GameScene.sks</code> file for now. These files are Xcode's option for you to visually design your game scene. We will know more on these files later when we work with our more visually designed SpriteKit game example.</li><li class="listitem" value="7">Build and run the app to see Apple's default SpriteKit project, which has <code class="email">Hello World</code> <a id="id142" class="calibre1"/>written in Chalkduster font and a rotating spaceship appears where you click or tap on the screen.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec34" class="calibre1"/>An overview of the SpriteKit structure and objects</h2></div></div></div><p class="calibre8">Before we add <a id="id143" class="calibre1"/>our code, let's use this template to get an idea on how SpriteKit's basic objects, functions, and flow work.</p><p class="calibre8">As we stated in the <a id="id144" class="calibre1"/>previous chapter, <code class="email">AppDelegate.swift</code> is the main entry point. The code then moves to <code class="email">GameViewController.swift</code>, which is a child of the <code class="email">UIViewController</code> class that imports the SpriteKit framework. The following code is written in the <code class="email">viewDidLoad()</code> function of <code class="email">GameViewController</code>:</p><div><pre class="programlisting">override func viewDidLoad() {
        super.viewDidLoad()
        if let scene = GameScene(fileNamed:"GameScene") {
            // Configure the view.
            let skView = self.view as! SKView
            skView.showsFPS = true
            skView.showsNodeCount = true
            /* Sprite Kit applies additional optimizations to improve rendering performance */
            skView.ignoresSiblingOrder = true
            /* Set the scale mode to scale to fit the window */
            scene.scaleMode = .AspectFill
            skView.presentScene(scene)
        }
    }</pre></div><div><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8">
<strong class="calibre9">Downloading the example code</strong>
</p><p class="calibre8">You can download the example code files from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre8">Using the keyword <code class="email">override</code>, this version of <code class="email">viewDidLoad()</code> can now either add to or well override the parent class's functionality. <code class="email">super.viewDidLoad()</code> calls the parent class's original functionality and then it works its own custom functionality. This is how Swift handles the OOP concept of inheritance.</p><p class="calibre8">Next, we see how a game scene is first created with <code class="email">GameViewController</code>. A major aspect of SpriteKit is that it works in scenes that are members of the <code class="email">SKScene</code> class, which are themselves children of the <code class="email">SKNode</code> class. The <code class="email">SKNode</code> classes are the main building blocks of nearly every object in SpriteKit. Be it sprites, lights, videos, effects, physics fields, audio files (<code class="email">SKAudioNodes</code>), cameras (<code class="email">SKCameraNodes</code>), or labels/UI objects, they are <code class="email">SKNode</code> classes. These objects all hold important information, most importantly coordinate information of object's node family. For games, this allows the developer to create custom classes, such as <code class="email">Enemies</code>, <code class="email">GameLights</code>, <code class="email">Tiles</code>, and so on, that all have screen and other information on both parent and child nodes. For example, we can hit every enemy on the screen with an attack by the player by calling an inherited function in a parent <code class="email">Enemy</code> class. We don't need to check for each individual type of enemy but instead enumerate through the parent nodes in the various game loop functions of <code class="email">SKScene</code>:</p><div><pre class="programlisting">enumerateChildNodesWithName("player", usingBlock: block)</pre></div><p class="calibre8">Do you remember the block/closure call in PikiPop? To actually use it in the <code class="email">didSimulatePhysics()</code> function of <code class="email">SKScene</code>, we call the <code class="email">enumerateChildNodesWithName</code> function of <code class="email">SKNode</code> to target only those nodes in the scene and have that block of code run for each member in the scene with that name.</p><div><pre class="programlisting">playerNode.name = "player"</pre></div><p class="calibre8">The name is simply a <a id="id145" class="calibre1"/><em class="calibre10">string</em> that can be set using the <code class="email">SKNode.name</code> property. Have every custom node initiate with a given name (or change during game play), and <a id="id146" class="calibre1"/>you have a whole group of objects you can single out in the scene.</p><p class="calibre8">You can find more on <code class="email">SKNode</code> <a id="id147" class="calibre1"/>in Apple's official documentation at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/">https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec35" class="calibre1"/>Scene transitions and the choice of code, storyboards, and/or SKS files</h2></div></div></div><p class="calibre8">The <code class="email">GameScene.swift</code> class in our project inherits from <code class="email">SKScene</code>, and it is there that the game loop / rendering functions we mentioned earlier occur. SpriteKit runs on scenes, and scenes can be <a id="id148" class="calibre1"/>transitioned and segued to and from it.</p><p class="calibre8">In the previous <a id="id149" class="calibre1"/>chapter, we showed how to structure a game using storyboards <a id="id150" class="calibre1"/>and segues. <code class="email">SKScene</code> makes it where you <a id="id151" class="calibre1"/>don't even have to use storyboards but just straight code to transition. We can use storyboards, and we can also visually design each individual scene using <code class="email">.sks</code> files or a combination of all three methods. With code, <code class="email">SKScene</code> can transition with the <code class="email">SKTransition</code> objects and functions. Actually, as we'll see with <code class="email">SwiftSweeper</code>, we can just use code to manually refresh assets in the scene to do <em class="calibre10">transitions</em>. This method is rather old fashioned and not as elegant as <code class="email">SKTransition</code> storyboards and SKS files, so let's take a quick look at how to transition scenes in code with <code class="email">SKTransition</code>, storyboards, and briefly into SKS files via code. Later, and in the next chapter, we will focus much more on the visual SKS files since every update to iOS and Xcode continues to put the focus on these visual tools to shorten the coding time and workflow.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec36" class="calibre1"/>An SKTransition example</h2></div></div></div><p class="calibre8">The following <a id="id152" class="calibre1"/>code changes the game's scene:</p><div><pre class="programlisting">  override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {
    super.touchesBegan(touches, withEvent: event)
    if let location = touches.first?.locationInNode(self) {
        let touchedNode = self.nodeAtPoint(location)
        if touchedNode.name == "SceneChangeButton" {
            let transition = SKTransition.revealWithDirection(SKTransitionDirection.Up, duration: 1.0)

            let scene = AnotherGameScene(size: self.scene!.size)
            scene.scaleMode = SKSceneScaleMode.AspectFill
            self.scene!.view!.presentScene(scene, transition: transition)
        }
    }
}</pre></div><p class="calibre8">The <code class="email">SKTransition</code> classes are really just types of segues. As in the preceding code, the transition is a directional switch to the next scene with the <code class="email">SKTransitionDirection.Up</code> enumerator type. As we saw in <code class="email">GameViewController</code>, the new scene is created with the similar functions that control the scene's view size and aspect ratio and then presents that scene to the unwrapped view with <code class="email">self.scene!.view!.presentScene(scene, transition: transition)</code>.</p><p class="calibre8">Also note that this takes place in the same function as we see in our current project's <code class="email">GameScene.swift</code> class, <code class="email">override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?){}</code>. This is the function that handles touch gestures from the player and checks whether the name of the node touched matches the <code class="email">SceneChangeButton</code> string.</p><p class="calibre8">More on <a id="id153" class="calibre1"/><code class="email">SKTransition</code> and other neat transition effects you can give your games can be found here in the official documentation:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/">https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/</a>
</p><div><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre8">As of Swift 2.0 / iOS 9, this touch delegate function takes in a parameter that is a set of <code class="email">UITouches</code> via <code class="email">touches: Set&lt;UITouch&gt;</code> and an optional <code class="email">UIEvent</code>. This is a change from past Swift iterations and could change in future updates.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec37" class="calibre1"/>A SKScene/storyboard example</h2></div></div></div><p class="calibre8">Here's the <a id="id154" class="calibre1"/>code for a <code class="email">SKScene</code>/storyboard example:</p><div><pre class="programlisting">@IBAction func buttonPressed(button:UIButton)
{
    // Remove button from the view
    button.removeFromSuperview()
    if let scene = GameScene.unarchiveFromFile("GameScene") as? GameScene {
        // Configure the view.
        let skView = self.view as SKView
        skView.showsFPS = false
        skView.showsNodeCount = false

        //used for optimization of SKView
        skView.ignoresSiblingOrder = true

        scene.scaleMode = .AspectFill
        skView.presentScene(scene)
    }
}</pre></div><p class="calibre8">As we saw in the previous chapter, using the visual help of storyboard files can give us great visual road maps to our apps, both game and non-game. The preceding code uses a link to an <code class="email">@IBAction</code> linkage on a storyboard file to set a new scene.</p><p class="calibre8">Storyboards in games can be great for the prototyping phase when we know just the general structure of our game, and can be perfect for the game's menu navigations or even for all individual game scenes<em class="calibre10">*</em>.</p><p class="calibre8">The button itself is removed before the transition via the <code class="email">button.removeFromSuperview()</code> call to prevent a memory leak caused by the new scene being drawn over what could have been an unseen menu button—unseen to the player but not to the game's memory stack.</p><div><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8">
<em class="calibre10">*</em>It's usually the best practice to only use storyboards for overall navigation menus and not for each individual level/scene. The <code class="email">SKScene</code> and <code class="email">SKNode</code> functionality can let us reuse similar scene structures and save much of the coding for similarly structured levels. Games with many levels could turn our storyboards into a web of confusing structures and thus undo their initial purpose. Scenes with the actual gameplay could just be in their own single view controller in the storyboard, and we'd have the pause, share, and other menus be <a id="id155" class="calibre1"/>controlled by storyboard segues.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec38" class="calibre1"/>SKScene transitions with SKS files</h2></div></div></div><p class="calibre8">A <code class="email">.sks</code> file is a special SpriteKit scene file that can allow the creation of a scene as well as the <a id="id156" class="calibre1"/>placement of the player, particles, enemies, and level assets in a visual, drag and drop way. Transitioning to a visually <a id="id157" class="calibre1"/>designed <code class="email">.sks</code> file in Swift is the same as our initial <code class="email">SKTransition</code> example.</p><div><pre class="programlisting">override func touchesBegan(touches: Set&lt;NSObject&gt;, withEvent event: UIEvent) {
    /* Called when a touch begins */
    let introNode = childNodeWithName("introNode")

    if (introNode != nil) {
        let fadeAway = SKAction.fadeOutWithDuration(1.0)

        introNode?.runAction(fadeAway, completion: {
            let doors = SKTransition.doorwayWithDuration(1.0)
            let gameScene = GameScene(fileNamed: "GameScene")
            self.view?.presentScene(gameScene, transition: doors)
        })
    }
}</pre></div><p class="calibre8">The creation of the <code class="email">gameScene</code> constant with the <code class="email">SKScene</code> initializer <code class="email">fileNamed</code> and then presenting that scene to the view works the same with either the <code class="email">.swift</code> file or <code class="email">.sks</code> file. This gives us the flexibility to both code and/or visually design our game scenes. In the case of <code class="email">SwiftSweeper</code>, we will do the more code-centric methodology, but feel free to build on this game on your own if you wish with either more code, Storyboards, and/or with visually designed <code class="email">SpriteKitScene</code> (<code class="email">.sks</code>) files.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec39" class="calibre1"/>Assets, sprites, and icons</h2></div></div></div><p class="calibre8">As of Xcode 7, game <a id="id158" class="calibre1"/>assets are placed in the <code class="email">Assets.xcassets</code> <a id="id159" class="calibre1"/>folder. Previous versions of Xcode might have had an <a id="id160" class="calibre1"/><code class="email">Images.xcassets</code> folder for the game's icons and sprites, but this has changed and might continue to change with each new iOS release.</p><div><img src="img/00026.jpeg" alt="Assets, sprites, and icons" class="calibre11"/><div><p class="calibre15">An image from Apple's WWDC15 conference</p></div></div><p class="calibre12"> </p><p class="calibre8">Starting with iOS 9 <a id="id161" class="calibre1"/>and Xcode 7, the <code class="email">assets</code> folder was given even more <a id="id162" class="calibre1"/>flexibility with the ability to handle the various app icon sizes, the launch image, sets of images, and sprite atlases. This also allows us to develop with <a id="id163" class="calibre1"/>various memory saving capabilities introduced in <a id="id164" class="calibre1"/>iOS 9 like <strong class="calibre9">app slicing</strong> / <strong class="calibre9">app thinning</strong> and on-demand resources. The <a id="id165" class="calibre1"/>app slicing/thinning feature makes sure that only the assets relevant to the device are downloaded, which saves space on the player's iPhone or iPad. On-demand resources let us tag assets that are available in the device's memory only during certain parts of our games. This way, we can create even larger games for our players to experience without taxing the sometimes-limited space in the Apple family of devices.</p><p class="calibre8">You can find <a id="id166" class="calibre1"/>more on app slicing/thinning at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html">https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html</a>.</p><p class="calibre8">When setting up <a id="id167" class="calibre1"/>your game for on-demand services, something that could be great to know in the initial planning of your games, can be found in the official documentation at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/">https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/</a>.</p><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec10" class="calibre1"/>Sprite atlases and animating sprites</h3></div></div></div><p class="calibre8">SwiftSweeper <a id="id168" class="calibre1"/>actually doesn't use animating sprites; as we'll see, it <a id="id169" class="calibre1"/>simply uses Unicode emoticon characters to animate the screen. Yet, we can't discuss SpriteKit and 2D game development without mentioning sprites, animating and optimizing them with texture atlases/sprite sheets, could we? A sprite atlas is a collection of images bundled into a single image, also known as a <strong class="calibre9">sprite sheet</strong> or <strong class="calibre9">texture atlas</strong>. While developing 2D games, it is highly recommended to <a id="id170" class="calibre1"/>use texture atlases as opposed to various image sets because to the <a id="id171" class="calibre1"/>renderer, texture atlases will equate to far fewer draw calls and thus can make sure that your game runs at that needed 60 fps. The <code class="email">Collectables.atlas</code> folder in <code class="email">Assets.xcassets</code> could hold all of your game's collectables and with the <code class="email">SKTextureAtlas</code> class, efficiently draw those collectables to the screen. When storing the images to say the player's idle, walking, and jumping animations, we use texture atlases to store them.</p><p class="calibre8">Creating a texture <a id="id172" class="calibre1"/>atlas is very simple and is presented as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Simply click <a id="id173" class="calibre1"/>on your <code class="email">Assests.xcassets</code> folder and right-click on an empty part of the folder's hierarchy.<div><img src="img/00027.jpeg" alt="Sprite atlases and animating sprites" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">Click on <strong class="calibre9">New Sprite Atlas</strong> and just like this, we have a folder where we can store various sprites for our game.<div><img src="img/00028.jpeg" alt="Sprite atlases and animating sprites" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">Make sure to name the folder based on how you wish to categorize the groups of sprites. You'd need this name when referencing them in code.</li></ol><div></div><p class="calibre8">To create a reference <a id="id174" class="calibre1"/>to this atlas in code and animate the <a id="id175" class="calibre1"/>sprites, we use <code class="email">SKTextureAtlas</code> as follows:</p><div><pre class="programlisting">let PlayerAtlas = SKTextureAtlas(named:"Player.atlas")

let textures = map(1...4) { number in       
            PlayerAtlas.textureNamed("player_sprite_normal_\(number)")
            } 
            let anim = SKAction.animateWithTextures(textures, timePerFrame: self.animationRefreshRate_)
            let idleAnimation = SKAction.repeatActionForever(anim)
            self.runAction(idleAnimation)</pre></div><p class="calibre8">First, this code creates an <code class="email">SKTextureAtlas</code> reference to the player's sprite atlas using the initializer <code class="email">SKTextureAtlas(named:"Player.atlas")</code>. Then, we create an array of textures using one of Swift's orders block <code class="email">map(NSRange){…}</code>. This is a closure block that iterates through the textures in the sprite atlas based on the range specified in the map call. The <code class="email">number</code> object is a simple index object we can use to represent the index of the mapping. </p><p class="calibre8">This is done because our player has these sprite names for the normal/idle animation:</p><div><pre class="programlisting">"player_sprite_normal_1", "player_sprite_normal_2", "player_sprite_normal_3", "player_sprite_normal_4"</pre></div><p class="calibre8">Since we know that the sprite animations are named with an indexed naming structure, it's better to use Swift's functional programming tools, such as <code class="email">map()</code>, here to simplify the code. 2D Sprites with many frame-by-frame animations (games such as Metal Slug) could be iterated through in such a fashion.</p><p class="calibre8">
<code class="email">SKTextureAtlas</code> also has a class function named <code class="email">preloadTextureAtlases</code> we can use to preload an array of texture atlases:</p><div><pre class="programlisting">SKTextureAtlas.preloadTextureAtlases([PIKIATLAS,BGATLAS,COLLECTABLESATLAS,HUDATLAS, OBSTACLESATLAS])
{
  //perform other tasks while loading TextureAtlases
}</pre></div><p class="calibre8">This is great to make <a id="id176" class="calibre1"/>sure that a stage's sprites are loaded before <a id="id177" class="calibre1"/>entering the stage.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec31" class="calibre1"/>Creating our game logic</h1></div></div></div><p class="calibre8">For the sake of <a id="id178" class="calibre1"/>simplicity, MineSweeper won't have many different assets or any sprite textures. It instead uses Swift's Unicode emoticon character capabilities and <code class="email">UIView</code> calls to design the game's graphics in a rather old-fashioned, very MineSweeper-like way.</p><p class="calibre8">Not only do we do this to give us a somewhat simplistic starting point, but to show how Swift code and SpriteKit classes can let us create the entire game's logic and flow without the initial need of sprite assets. This way, if developing as a team or by yourself, the game can be made before doing the sometimes grueling process of making wonderful visual assets. Thinking with code and structure first can ensure that you have a working prototype that you can polish later with sprites, music, and atmosphere.</p><p class="calibre8">We've so far left SwiftSweeper waiting as just a shell of the SpriteKit game template. It's about time we get to the game's model:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, let's add our <a id="id179" class="calibre1"/>image assets. For more information, visit <a class="calibre1" href="https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo">https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo</a>.<p class="calibre14">This is a link to the <code class="email">Assets.xcassets</code> folder of <code class="email">SwiftSweeper</code>. We can add these individually, but the simplest way is to just replace your project's <code class="email">Assets.xcassets</code> folder directly in your computer where your project's folder is located. You can have Xcode open while you do this, it'll automatically update from the original template files.</p></li><li class="listitem" value="2">Next, let's add the sound files from the following URL:<p class="calibre14">
<a class="calibre1" href="https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY">https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY</a>
</p></li><li class="listitem" value="3">Add the sounds <a id="id180" class="calibre1"/>by doing the following:<div><ol class="orderedlist1"><li class="listitem" value="1">Right-click on the <code class="email">SwiftSweeperExample</code> folder that holds the Swift files and then go to <strong class="calibre9">New</strong> | <strong class="calibre9">Group</strong> from the menu.<div><img src="img/00029.jpeg" alt="Creating our game logic" class="calibre11"/></div><p class="calibre12"> </p></li><li class="listitem" value="2">Name this folder <code class="email">Sounds</code> and drag it to the bottom of the files within the same <code class="email">SwiftSweeperExample</code> folder.<div><img src="img/00030.jpeg" alt="Creating our game logic" class="calibre11"/></div><p class="calibre12"> </p></li><li class="listitem" value="3">Right-click the <code class="email">Sounds</code> folder and select <code class="email">Add Files To "SwiftSweeperExample"</code>.<div><img src="img/00031.jpeg" alt="Creating our game logic" class="calibre11"/></div><p class="calibre12"> </p></li><li class="listitem" value="4">Add the sounds <a id="id181" class="calibre1"/>from the <code class="email">SwiftSweeperSounds</code> folder, and they should now be in your project.</li></ol><div></div><div><img src="img/00032.jpeg" alt="Creating our game logic" class="calibre11"/></div><p class="calibre16"> </p></li></ol><div></div><p class="calibre8">All of the assets should be now in the project, so now we can build our game. Let's first start with the actual tiles.</p><p class="calibre8">Now create a new <a id="id182" class="calibre1"/>Swift file, name it <code class="email">Tile</code>, and paste the following code into the file:</p><div><pre class="programlisting">class Tile{
    //Properties 
//(1)
    let row : Int
    let column : Int 
//(2)    
    var isTileDown = false
    var isFlagged = false
    var isAMine = false
//(3)
    //Mines counter
    var nearbyMines:Int = 0
//(4)
    init(row:Int, col: Int){
        self.row = row
        self.column = col  
    }
}</pre></div><p class="calibre8">Here are some stepwise logic we adhere to while creating tiles:</p><div><ol class="orderedlist"><li class="listitem" value="1">While building any code logic, we usually place the properties about this object at the top. We know that each tile in a game of MineSweeper will be part of a row and a column. The number of the row and the column this tile will have during gameplay won't change during the course of a single round, so we make them constants with the keyword <code class="email">let</code> and set them with the type <code class="email">Int</code> as we know that you can't have fractions of a row or a column, at least in terms of the tile objects.</li><li class="listitem" value="2">A tile can <a id="id183" class="calibre1"/>have a few different states. It could be already tapped, it could have a flag placed on it, and if it's a a mine. Since these are true/false properties, we set them with as Boolean variables <code class="email">isTileDown</code>, <code class="email">isFlagged</code>, and <code class="email">isAMine</code>. We set them to <code class="email">false</code> initially.</li><li class="listitem" value="3">Tiles in MineSweeper count how many tiles around them are mines, so we create the integer counter <code class="email">nearbyMines</code> to hold that information.</li><li class="listitem" value="4">When an instance of a tile object is created, we want the game to set its row and column number placement on the <code class="email">GameBoard</code>, so we create the default initializer, <code class="email">init</code>, to have two parameter inputs for both the row and column.</li></ol><div></div><p class="calibre8">That's all we need for the <code class="email">Tile</code> objects, so let's move on to setting the button functionality of these <code class="email">Tile</code> objects with the <code class="email">MineTileButton</code> class.</p><p class="calibre8">Create a new Swift file and name it <code class="email">MineTileButton</code> and paste the following code into it:</p><div><pre class="programlisting">//(1)
import UIKit
class MineTileButton : UIButton {
//(2)
    var tile:Tile
    let tileSize:CGFloat
//(3)
    init(tileButton:Tile, size:CGFloat) {
        self.tile = tileButton
        self.tileSize = size

        let x = CGFloat(self.tile.column) * tileSize
        let y = CGFloat(self.tile.row) * tileSize
        let tileBoundingFrame = CGRectMake(x, y, tileSize, tileSize)  
        super.init(frame: tileBoundingFrame)
    } 
//(4)
    required init(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
//(5)
    //button text;
    //replace button with an SKSprite for better GUI interface?
    func getTileLabelText() -&gt; String {
        if !self.tile.isAMine {
            if self.tile.nearbyMines == 0 {
                return "0"
            }else {
                return "\(self.tile.nearbyMines)"
            }
        }
//(6)
        return "ðŸ’¥"
    }
}</pre></div><p class="calibre8">Here's the <a id="id184" class="calibre1"/>explanation of the code:</p><div><ol class="orderedlist"><li class="listitem" value="1">Since we are creating a <code class="email">UIButton</code> object, we import the UIKit framework for this object.</li><li class="listitem" value="2">These are the properties of this button object. We need a <code class="email">Tile</code> object named <code class="email">tile</code> to reference, a <code class="email">CGFloat</code> size named <code class="email">tileSize</code> to represent the rectangle this button will occupy.</li><li class="listitem" value="3">The initializer for this class takes in a <code class="email">Tile</code> object named <code class="email">tileButton</code> and a <code class="email">CGFloat</code> named <code class="email">size</code>. We assign the class's own tile to <code class="email">tileButton</code> and <code class="email">tileSize</code> to <code class="email">size</code> and then we make a square named <code class="email">tileBoundingFrame</code> with the <code class="email">CGRectMake()</code> method. This is done just after we set an <em class="calibre10">x</em> and <em class="calibre10">y</em> value of <code class="email">CGFloat</code> to the square based on the <code class="email">tileSize</code>. The <code class="email">UIButton</code> parent <code class="email">init(frame: )</code> initializer uses the <code class="email">tileBoundingFrame</code> as the parameter via <code class="email">super.init(frame: tileBoundingFrame)</code>.</li><li class="listitem" value="4">Since Xcode 5, the <code class="email">init</code> function is needed mainly to keep the compiler happy while dealing with UI objects.</li><li class="listitem" value="5">The function <code class="email">getTileLabelText()</code> returns a string based on the status of the <code class="email">tile</code> object. If the tile is not a mine, we know that we have to either place something for there being no tiles; traditionally, this is just a blank space or an empty <code class="email">""</code> string, but for now, we are just placing <code class="email">0</code> there, leaving the logic open for customization. Honestly, we could simply return the nested if-else statement's return <code class="email">\(self.tile.nearbyMines)</code>, and it'd return the same result. As we see, it's returning the particular <code class="email">Tile</code> object's <code class="email">nearbyMines</code> property.</li><li class="listitem" value="6">If the tile is a mine, then we return the collision Unicode emoji character. The <code class="email">getTileLabelText()</code> function is called when the player taps an <code class="email">unflagged</code> tile.</li><li class="listitem" value="7">Swift's ability to use Unicode character symbols can be a great visual aid in the planning process of your games. The collision Unicode emoji used in line <code class="email">(6)</code> is <code class="email">U+1F4A5 (128165)</code>. If you see only a square box and not the red explosion-like character, it can be seen in the full project download mentioned earlier in the chapter or at the following link.</li></ol><div></div><div><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre8">Find more <a id="id185" class="calibre1"/>information <a id="id186" class="calibre1"/>on this emoji at <a class="calibre1" href="http://www.charbase.com/1f4a5-unicode-collision-symbol">http://www.charbase.com/1f4a5-unicode-collision-symbol</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec40" class="calibre1"/>GameBoard</h2></div></div></div><p class="calibre8">Now that we have <a id="id187" class="calibre1"/>our tile object and button logic that will represent each tile object named <code class="email">MineTileButton</code>, we need to create an object representing the collection of these objects, that is, <code class="email">GameBoard</code>.</p><p class="calibre8">The full <code class="email">GameBoard.swift</code> code is a bit too large to show here in its entirety, so we will summarize <a id="id188" class="calibre1"/>its main features and segments.</p><p class="calibre8">We can view the entire code either in the full project link mentioned earlier in the chapter, or directly below in order to copy to your current game project file:</p><p class="calibre8">
<a class="calibre1" href="https://mega.co.nz/#!X8FB2aAK">https://mega.co.nz/#!X8FB2aAK</a>
</p><p class="calibre8">For our <code class="email">GameBoard</code>, we are looking to create a tiled board of 10x10 size that also has three levels of difficulty: easy, medium, and hard. To create the difficulty, we simply use an enumerator named <code class="email">difficulty</code> to store the game's difficulty levels.</p><p class="calibre8">The most important properties of <code class="email">GameBoard</code> include <code class="email">boardSize_</code> (which is set to <code class="email">10</code> in this case), a variable that will represent the number of mines that will be placed named <code class="email">mineRandomizer</code>, the number of mines active on the board named <code class="email">mineCount</code>, and the Tile objects that will populate the board named <code class="email">tiles</code>.</p><p class="calibre8">Make a note of the syntax used for the <code class="email">tiles</code> property:</p><div><pre class="programlisting">var tiles:[[Tile]] = []</pre></div><p class="calibre8">In this way, we can create an ordered 2D array (or matrix) in Swift*. The <code class="email">GameBoard</code> object will basically store an array of an array of <code class="email">Tile</code> type objects.</p><div><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre8">*Swift does have more ways to express matrices, for example, we can use Structs to define our own unique matrices. As at the time of this publication, Swift does not have its own true functionality for fixed length arrays, as we see in various C languages. However, using the nested braces <code class="email">[[]]</code> is fine for what we are trying to accomplish.</p></div><p class="calibre8">The initializer for <code class="email">GameBoard</code>, <code class="email">init(selectedDifficulty:difficulty){}</code>, takes in the player-selected difficulty as it's single parameter then builds the board based on the <code class="email">boardSize</code> property <a id="id189" class="calibre1"/>and then uses the following nested for-in loop to <a id="id190" class="calibre1"/>populate the entire board with <code class="email">Tile</code> objects:</p><div><pre class="programlisting">        for row in 0 ..&lt; boardSize_ {
            var tilesRow:[Tile] = []
            for col in 0 ..&lt; boardSize_ {
                let tile = Tile(row: row, col: col)
                tilesRow.append(tile)
            }
            tiles.append(tilesRow)
        }</pre></div><p class="calibre8">Since the <code class="email">tiles</code> object is a 2D array, we first need to perform this nested loop that first creates a 1D array of <code class="email">Tile</code> objects (named <code class="email">tilesRow</code>) for each row and then add a tile for each column in that row with the <code class="email">.append</code> function. The main tiles 2D array is then appended that <code class="email">tilesRow</code> array.</p><div><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8">If you wish to make a <code class="email">GameBoard</code> instance that is a rectangle or of another shape, you'd have to take into account the differing column and row amounts. This would make the nested for-loop have more complexity by needing a separate <code class="email">columnSize</code> and <code class="email">rowSize</code> property. Many puzzle games will make their boards look complex to the player but might still keep their internal structures simple to either squares or rectangles by instead filling in that tile with a nonplayable section or background/transparent tile.</p><p class="calibre8">It's a way for a developer to cut corners while at the same time allowing complex functionality and design. It's why we built this game with separate classes representing the Tiles, the tile button functionalities, and the game board layout.</p><p class="calibre8">Using inheritance, we can continue to customize what each tile does and thus allow a myriad of features based on a simple foundation.</p><p class="calibre8">It's why video games have always been the poster children to make the most out of object-oriented design.</p></div><p class="calibre8">Don't worry if at first it's tough to get a full understanding of this, as nested loops tend to be brain twisters. Just observe how the interior for-loop won't exit until it's done filling in columns based on the <code class="email">boardSize</code>_ property. This kind of loop is made easier with the fact that the rows and columns are all equal at 10.</p><p class="calibre8">The initializer then calls the <code class="email">resetBoard()</code> function, which resets the <code class="email">mineCount</code> to <code class="email">0</code>, and does two more nested for-loops:</p><div><pre class="programlisting">for row in 0 ..&lt; boardSize_ {
            for column in 0 ..&lt; boardSize_ {
                self.createRandomMineTiles(tiles[row][column])
                tiles[row][column].isTileDown = false  
            }
        }</pre></div><p class="calibre8">This board-iterating for-loop randomly sets which tiles are mines using the <code class="email">createRandomMineTiles()</code> function as well as resets the tiles to being untouched with the <code class="email">tiles[row][column].isTileDown = false</code> call. The <code class="email">createRandomMineTiles()</code> function works off the current difficulty level, particularly the <code class="email">mineRandomizer</code> property that is determined in the <code class="email">implementDifficulty()</code> function. The higher the <code class="email">mineRandomizer</code> value, the less of a chance the iterated tile will be made into a mine.</p><p class="calibre8">The next nested for-loop in <code class="email">resetBoard()</code> is the following:</p><div><pre class="programlisting">for row in 0 ..&lt; boardSize_ {
            for column in 0 ..&lt; boardSize_ {
                self.calculateNearbyMines(tiles[row][column])
            }
        }</pre></div><p class="calibre8">This iterates through every tile on the board and sets the number the player will see if tapped. That number of course being the number of mines surrounding a non-mine tile, that is, the <code class="email">nearbyMines</code> property of the <code class="email">Tile</code> class.</p><p class="calibre8">This rather complex <a id="id191" class="calibre1"/>chain of calculations begins with the <code class="email">calculateNearbyMines()</code> function and runs through the array/tile index calculating functions, <code class="email">getNearbyTiles()</code> and <code class="email">getAdjacentTileLocation()</code>. We provided various detailed <a id="id192" class="calibre1"/>comments in each of these functions to get a better understanding on how they work. It's advised that you read the intricate details on how it's done but to not muddy an already complex game logic explanation, take notes on the following line in <code class="email">getNearbyTiles()</code>:</p><div><pre class="programlisting">let nearbyTileOffsets =     
   [(-1,-1), //bottom left corner from selected tile
            (0,-1),  //directly below
            (1,-1),  //bottom right corner
            (-1,0),  //directly left
            (1,0),   //directly right
            (-1,1),  //top left corner
            (0,1),   //directly above
            (1,1)]  //top right corner</pre></div><p class="calibre8">If any line in these three complex functions is to be understood, it's this one. The <code class="email">nearbyTileOffset</code> object is an explicitly written array of tuples, which contains every offset that could exist around a single 2D tile. Actually, it's best to think of each member of this array as an (<em class="calibre10">x</em>,<em class="calibre10">y</em>) 2D Vector.</p><p class="calibre8">Thus, as commented in the preceding code, the offset of (<code class="email">-1</code>,<code class="email">-1</code>) would be to the bottom left of the tile since <code class="email">x = -1</code> (left 1) and <code class="email">y = -1</code> (down 1). Similarly, (<code class="email">1</code>,<code class="email">0</code>) is to the right, (<code class="email">1</code>,<code class="email">1</code>) is the top-right corner.</p><p class="calibre8">We also have to take into account that some tiles are on the edge and/or column of the board, thus some of the <a id="id193" class="calibre1"/>tile offsets won't return the reference to another <a id="id194" class="calibre1"/>tile; they'll instead return nil.</p><div><pre class="programlisting">for (rowOffset,columnOffset) in nearbyTileOffsets {
            
 //optional since tiles in the corners/edges could have less than 8 surrounding tiles and thus could have a nil value
            let ajacentTile:Tile? = getAjacentTileLocation(selectedTile.row+rowOffset, col: selectedTile.column+columnOffset)
            //if validAjacentTile isn't nil, add the Tile object to the nearby Tile array
            if let validAjacentTile = ajacentTile {
                nearbyTiles.append(validAjacentTile)
            }
        }</pre></div><p class="calibre8">This for-loop in <code class="email">getNearbyTiles()</code> not only checks the offsets of every tile, but also, using the call to <code class="email">getAjacentTileLocation()</code>, accounts for edge or corner tiles.</p><p class="calibre8">Again, these three functions are rather complex, even in a less line-by-line / semi-generic explanation of their functionality. So, don't worry if you don't understand the flow/order at first.</p><p class="calibre8">Finally, for <code class="email">resetBoard()</code>, we can't win the game without knowing if the player got every non-mine tile, so we get that information with the line:</p><div><pre class="programlisting">numOfTappedTilesToWin_ = totalTiles_ - mineCount</pre></div><p class="calibre8">When the player's number of completed moves (counted in the <code class="email">GameScene</code> class) equals <code class="email">numOfTappedTilesToWin</code>, the player wins!</p><p class="calibre8">This is all done before the player makes the first move! This is done in order to have the values already predetermined. Yes, we could make some of these calculations during the player's touch, but dealing with boilerplate game logic is usually fast enough to prepare the game at load time so that we can use the game play to focus on effects, sequences, and other visual notifications during the game loop.</p><p class="calibre8">This functionality is <a id="id195" class="calibre1"/>controlled by the <code class="email">GameScene.swift</code> file, which <a id="id196" class="calibre1"/>we will summarize next.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec41" class="calibre1"/>Putting it all together in GameScene.swift</h2></div></div></div><p class="calibre8">We now have the <a id="id197" class="calibre1"/>core of SwiftSweeper's logic set up, but now it's time to present it in our <code class="email">SKScene</code> provided by the game template, <code class="email">GameScene</code>. This scene uses the game/rendering loop functions that we mentioned at the beginning of the chapter.</p><p class="calibre8">The SwiftSweeper version of <code class="email">GameScene.swift</code> is rather large at about 800 lines of code, so like <code class="email">GameBoard</code>, we won't be going over it line by line but instead we'll be summarizing some of the important aspects of the scene. As stated previously, every update to Xcode and iOS brings more visual ways of setting up these scenes, so getting to know every line of code in this example isn't necessary, but still recommended if you really wish to dive deep into how to use code to present SpriteKit game scenes.</p><p class="calibre8">The full code can be found in the full project link mentioned earlier in the chapter or (if you've been building it from scratch throughout the chapter) at the link mentioned here:</p><p class="calibre8">
<a class="calibre1" href="https://mega.co.nz/#!PgljBL7b">https://mega.co.nz/#!PgljBL7b</a>
</p><p class="calibre8">We used various <code class="email">//MARK:</code> comments to section off parts of this code, so you can navigate easier. After copying the code into your project, you could build and run the app. As long as everything was placed into the project correctly, you should have a working version of SwiftSweeper running on your phone or in the phone simulators. Play through it a bit to get an idea what is being done in GameScene to present the game. Sometimes, seeing a game in action lets us see the code behind it better. If any errors pop up, something went wrong and if all else fails, you <a id="id198" class="calibre1"/>can download the completed project from <a class="calibre1" href="https://github.com/princetrunks/SwiftSweeper">https://github.com/princetrunks/SwiftSweeper</a>.</p><p class="calibre8">The first visual entry point in GameScene, <code class="email">didMoveToView()</code>, is actually rather small as follows:</p><div><pre class="programlisting">override func didMoveToView(view: SKView){
        self.backgroundColor = UIColor.whiteColor()
        stageView_ = view
        loadInstructions()
    }</pre></div><p class="calibre8">We simply set the background color to white and load the instructions. Again, we didn't say that this was meant to be a beautiful-looking game.</p><p class="calibre8">The <code class="email">loadInstructions()</code> function manually places the instructions sprite on the screen and sets the <code class="email">currentGameState_ enum to .Instructions</code>. A <strong class="calibre9">game state</strong> or <strong class="calibre9">state machine</strong> is common <a id="id199" class="calibre1"/>game development methodology that instructs characters, the <a id="id200" class="calibre1"/>player, and the game itself what state it is in. This could be used to make sure that certain parts of the gameplay don't happen in parts they aren't suppose to. iOS 9 / Xcode 7 introduced the framework; we'll dive into more later chapters named GamePlayKit, which, among other game logic functions, works with state machines that can be modular and independent from a specific scene. Components from the class <code class="email">SKComponents</code> and more modern usage of <code class="email">SKAction</code>, also introduced in iOS 9, work in the same way, independent from OOP inheritance. Think of more dynamic/usable versions of protocols.</p><p class="calibre8">The next overall step in the GameScene is the <code class="email">chooseDifficultyMenu()</code> that came with the <code class="email">removeInstructions()</code> function, which was called after the player taps the screen. This tap is checked in <a id="id201" class="calibre1"/>the function we mentioned in a few examples prior, <code class="email">touchesBegan()</code>, using the game state as a logic check:</p><div><pre class="programlisting">override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {
       /* Called when a touch begins */
        for touch in touches {
            //flag button Pressed
            if CGRectContainsPoint(flagButton_.frame, touch.locationInNode(self)) {
                flagButtonPressed()
            }
            //instructions removed when tapped
            if CGRectContainsPoint(instructionsSprite_.frame, touch.locationInNode(self)) &amp;&amp; currentGameState_ == .Instructions {
                removeInstructions()
            }
        }
    }</pre></div><p class="calibre8">Note how the <code class="email">touchesBegan</code> function is actually rather simple. It only checks if we tapped the flag button or if we tapped on the instructions. What about the tiles? Well, remember that we made these tiles all members of <code class="email">UIButton</code> with the <code class="email">MineTileButton</code> class. Here's the function that controls this:</p><div><pre class="programlisting">func tileButtonTapped(sender: MineTileButton) {
        //exit function if not playing the game
        if (currentGameState_ != .MineTap &amp;&amp; currentGameState_ != .FlagPlanting){
            return
        }
        //reveals the underlying tile, only if the game is in the main state, aka MineTap
        if (!sender.tile.isTileDown &amp;&amp; currentGameState_ == .MineTap) {
            sender.tile.isTileDown = true
            sender.setTitle("\(sender.getTileLabelText())", forState: .Normal)
            //sender.backgroundColor = UIColor.lightGrayColor() 
            //mine HIT!
            if sender.tile.isAMine {
                //sender.backgroundColor = UIColor.orangeColor()
                self.mineHit()
            }
            //counts the moves; also used in calculating a win
            moves_++
        }
        else if (!sender.tile.isTileDown &amp;&amp; currentGameState_ == .FlagPlanting){  
            self.flagPlant(sender)
        } 
    }</pre></div><p class="calibre8">Members of the <code class="email">UIButton</code> class send out a reference of what has been tapped to the scene. In this game, is an object of the type, <code class="email">MineTileButton</code>. Using the game state to check if it's logical to the scene, we either end the round if a mine is hit with the <code class="email">mineHit()</code> function or we increment the moves performed (used to calculate the win by comparing it to <code class="email">numOfTappedTilesToWin_</code> calculated at the start of the round). If the game state is <code class="email">.FlagPlanting</code>, then we instead deal with the logic behind planting a flag on the tiles. Tiles with flags don't react to <code class="email">.MineTap</code> game state taps and thus, if you put a flag on the wrong tile, you won't get the win until you uncover all of the non-mine tiles.</p><p class="calibre8">Through the rest of the <a id="id202" class="calibre1"/>code, we'll find a timer, alerts for the player based on the outcome, and even the ability to save times per difficulty levels using the class functions of the <code class="email">NSUserDefaults</code> class.</p><p class="calibre8">Again, it's not exactly all that visually elegant, but intricate in code and most importantly a fully functioning game. We advise you to check out more of the code in <code class="email">GameScene.swift</code>, but one major issue to our design one might have caused in the beginning is that this only works with iPhones. </p><p class="calibre8">Using visual tools such as autolayout, seen briefly in the previous chapter, will allow easier design changes for the entire family of iOS devices. Since many of the visual assets in SwiftSweeper's GameScene were manually placed in the view (particularly the instructions), we'd have to account for every device type in code. This is possible, but as the family of devices grows, manual code used for screen visuals could be broken rather easily in future iOS updates and device announcements. That's why in our next chapter about SceneKit and later, we will mostly diverge from this code-centric structure and embrace the hands-on tools and newer frameworks such as GamePlaykit from Xcode 7 and later.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec32" class="calibre1"/>DemoBots</h1></div></div></div><p class="calibre8">As at the initial <a id="id203" class="calibre1"/>publication of this book, <em class="calibre10">WWDC15</em> recently completed and gave us a great new SpriteKit demo project for iOS 9 and Xcode 7 named <strong class="calibre9">DemoBots</strong>.</p><div><img src="img/00033.jpeg" alt="DemoBots" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">DemoBots is a SpriteKit project provided by Apple that uses components, state machines, on-demand services, GameplayKit, ReplayKit, and more!</p><p class="calibre8">The full project <a id="id204" class="calibre1"/>documentation to DemoBots can be found at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html">https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html</a>.</p><p class="calibre8">To see it in action from <a id="id205" class="calibre1"/><em class="calibre10">WWDC15</em>, see the video and PDF file from the <em class="calibre10">Deeper into GameplayKit with DemoBots</em> keynote:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/videos/wwdc/2015/?id=609">https://developer.apple.com/videos/wwdc/2015/?id=609</a>
</p><p class="calibre8">The SpriteKit <a id="id206" class="calibre1"/>keynote can be found here:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/videos/wwdc/2015/?id=604">https://developer.apple.com/videos/wwdc/2015/?id=604</a>
</p><p class="calibre8">DemoBots's gameplay even has easily editable enemy AI / navigation schemes uses the <code class="email">SKCameraNode</code> introduced in iOS 9 that follows the player and doesn't move the scene around in the view as in past versions of SpriteKit. As we mentioned at the beginning of the chapter, mimicking the tools we see in multiplatform game engines.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec42" class="calibre1"/>Summary</h2></div></div></div><p class="calibre8">We went through a number of topics here in this chapter. We first spoke on why SpriteKit was a welcomed addition to iOS after years of developers only having third-party gaming frameworks, such as Cocos2D and Sparrow. We discussed how SpriteKit fits in the game development ecosystem as rather powerful, multiplatform game engines, such as Unity and Unreal Engine, continue to become more prominent. Next, we went into the SpriteKit game loop and rendering cycle that is used by <code class="email">SKScene</code>. Then, we began to build our demo tile game, <code class="email">SwiftSweeper</code>, and dove more into the basic structure of SpriteKit's most prominent object classes. The iOS 9 <code class="email">assets</code> folder was reviewed in addition to texture atlases and how to animate sprites using these asset tools. Then, we went into the rather complex logic and code that goes into mimicking a tile game such as MineSweeper.</p><p class="calibre8">Next, we move on to iOS's 3D game development framework, SceneKit, where we will diverge more towards the visual tools Apple now brings to us since iOS 8 / iOS 9. We'll take less of a code-centric methodology now that we know the basic scene/code structure that both SceneKit and SpriteKit share. SpriteKit scenes can overlay SceneKit scenes, so we will see some of what we hinted at with Apple's own DemoBots demo shortly.</p></div></div></body></html>