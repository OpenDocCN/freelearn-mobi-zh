- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection with Dagger, Hilt, and Koin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the concept of dependency injection and the benefits it
    provides to an Android application. We will look at how we can perform dependency
    injection manually with the help of container classes. We will also cover some
    of the frameworks available for Android, Java, and Kotlin that can help developers
    when it comes to applying this concept. By the end of this chapter, you will be
    able to use Dagger 2 and Koin to manage your app’s dependencies and know how to
    organize them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to structure code into different components,
    including ViewModels, API components, and persistence components. One of the difficulties
    that always emerged was the dependencies between all of these components, especially
    when it came to how we approached the unit tests for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dagger 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hilt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Koin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/IIQmX](https://packt.link/IIQmX)
  prefs: []
  type: TYPE_NORMAL
- en: The necessity of dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have constantly used the `Application` class to create instances of these
    components and pass them in the constructors of the components one layer above
    (we created the API and Room instances, then the Repository instances, and so
    on). What we were doing was a simplistic version of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModels`). The reason for this is to increase the reusability and testability
    of the code and to shift the responsibility for creating instances from our components
    to the `Application` class.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of DI concerns how objects are created across the code base.
    DI separates the creation of an object from its usage. In other words, one object
    shouldn’t care how another object is created; it should only be concerned with
    the interaction with the other object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze three ways to inject dependencies in Android:
    Manual DI, Dagger, and Koin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual DI**: This is a technique in which developers handle DI manually by
    creating container classes. In this chapter, we will examine how we can do this
    in Android. By studying how we manually manage dependencies, we will get some
    insight into how other DI frameworks operate and get a basis for how we can integrate
    these frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dagger**: This is a DI framework developed for Java. It allows you to group
    your dependencies into different modules. You can also define components, where
    the modules are added to create the dependency graph, and which Dagger automatically
    implements to perform the injection. It relies on annotation processors to generate
    the necessary code to perform the injection. A specialized implementation of Dagger
    called **Hilt** is useful for Android applications because it removes a lot of
    boilerplate code and simplifies the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Koin**: This is a lightweight DI library developed for Kotlin. It doesn’t
    rely on annotation processors; it relies on Kotlin’s mechanisms to perform the
    injection. Here we can also split dependencies into modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explore how both these libraries work and the steps
    required to add them to a simple Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Manual DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how DI works, we can first analyze how we can manually
    inject dependencies into different objects across an Android application. This
    can be achieved by creating container objects containing the dependencies required
    across the app.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create multiple containers representing different scopes required
    across the application. Here, you can define dependencies that will only be required
    as long as a particular screen is displayed, and when the screen is destroyed,
    the instances can also be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample of a container that will hold instances as long as an application
    lives is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An `Application` class using that container looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, the responsibility for creating the
    dependencies shifted from the `Application` class to the `Container` class. Activities
    across the code base can still access the dependencies using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Modules with a limited scope could be used for something such as creating the
    `ViewModel` factories, which, in turn, are used by the framework to create `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An activity or fragment can use this particular container to initialize `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can see here that the responsibility of creating the `Factory` class
    was shifted from the `Activity` class to the `Container` class. `MyContainer`
    could be expanded to provide instances required by `MyActivity` in situations
    where the lifecycle of those instances should be the same as the activity, or
    the constructor could be expanded to provide instances with a different lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s apply some of these examples to an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.01 – manual injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will write an Android application that will apply the concept
    of manual DI. The application will have a Repository, which will generate a random
    number, and a `ViewModel` object with a `LiveData` object responsible for retrieving
    the number generated by the Repository and publishing it in the `LiveData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do so, we will need to create two containers that will manage the
    following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` factory responsible for creating `ViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The app itself will display the randomly generated number each time a button
    is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio Project with an empty activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by adding the `ViewModel` and `LiveData` libraries to the `app/build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s write a `NumberRepository` interface in the `main/java` folder
    in the root package, which will contain a method to retrieve an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will provide the implementation for this in the `main/java` folder
    in the root package. We can use the `java.util.Random` class to generate a random
    number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now move on to the `MainViewModel` class in the `main/java` folder
    in the root package, which will contain a `LiveData` object containing each generated
    number from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s move on to create our `TextView` for displaying the number and
    `Button` for generating the next random number. This will be part of the `res/layout/activity_main.xml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/lr5Fx](https://packt.link/lr5Fx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to add the string for the button to the `res/values/strings.xml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create our `Application` class in the `main/java` folder in the
    root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also add the `Application` class to the `AndroidManifest.xml` file in
    the `application` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create our first container responsible for managing the `NumberRepository`
    dependency in the `main/java` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add this container to the `RandomApplication` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now move on to creating `MainContainer` in the `main/java` folder in the
    root package, which will need a reference to the `NumberRepository` dependency
    and will provide a dependency to the `ViewModel` factory required to create `MainViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can modify `MainActivity` to inject our dependencies from our containers
    and connect the UI elements to display the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the highlighted code, we can see that we are using the repository defined
    in `ApplicationContainer` and injecting it into `MainContainer`, which will then
    inject it into `ViewModel` through `ViewModelProvider.Factory`. The preceding
    example should render the output presented in *Figure 13**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated
    number](img/B19411_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated
    number
  prefs: []
  type: TYPE_NORMAL
- en: Manual DI is an easy way to set up your dependencies in situations where the
    app is small, but it can become extremely difficult as the app grows. Imagine
    if, in *Exercise 13.01*, *Manual injection*, we had two classes that extended
    from `NumberRepository`. How would we handle such a scenario? How would developers
    know which one went in what activity? These types of questions have become very
    common in most of the well-known apps on Google Play, which is why manual DI is
    rarely used. When used, it normally takes the form of a DI framework similar to
    the ones we will look over next.
  prefs: []
  type: TYPE_NORMAL
- en: Dagger 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dagger 2** offers a comprehensive way to organize your application’s dependencies.
    It has the advantage of being adopted first on Android by the developer community
    before Kotlin was introduced. This is one of the reasons that many Android applications
    use Dagger as their DI framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage the framework holds is for Android projects written in Java
    because the library is developed in the same language. The framework was initially
    developed by Square (Dagger 1) and later transitioned to Google (Dagger 2). We
    will cover Dagger 2 in this chapter and describe its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key functionality that Dagger 2 provides is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies grouped in modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components used to generate dependency graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subcomponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Annotations are the key elements when dealing with Dagger because it generates
    the code required to perform the DI through an annotation processor. The main
    annotations can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Module` are responsible for providing an object (dependent object) that can
    be injected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Inject` annotation is used to define a dependency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Component`-annotated interface defines the connection between the provider
    and the consumer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need to add the following dependencies in the `app/build.gradle` file
    to add Dagger to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are dealing with annotation processors, in the same `build.gradle`
    file, you will need to add the plugin for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We should now have an idea of how Dagger 2 goes about performing DI. Next, we
    will look at each group of annotations Dagger 2 offers.
  prefs: []
  type: TYPE_NORMAL
- en: Consumers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dagger uses `javax.inject.Inject` to identify objects that require injection.
    There are multiple ways to inject dependencies, but the recommended ways are through
    constructor injection and field injection. Constructor injection looks similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When constructors are annotated with `@Inject`, Dagger will generate the `Factory`
    classes responsible for instantiating the objects. In the example of `ClassB`,
    Dagger will try to find the appropriate dependencies that fit the signature of
    the constructor, which, in this example, is `ClassA`, which Dagger already created
    an instance for.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want Dagger to manage the instantiation of `ClassB` but still
    have the dependency on `ClassA` injected, you can use field injection, which will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Dagger will generate the necessary code just to inject the dependency
    between `ClassB` and `ClassA`.
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find yourself in situations where your application uses external dependencies.
    That means that you cannot provide instances through constructor injections. Another
    situation where constructor injection is not possible is when interfaces or abstract
    classes are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, Dagger can provide the instance using the `@Provides` annotation.
    You will then need to group the methods where instances are provided into modules
    annotated with `@Module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, `ClassA` and `ClassB` don’t have any
    Dagger annotations. A module was created that will provide the instance for `ClassA`,
    which will then be used to provide the instance for `ClassB`. In this case, Dagger
    will generate a `Factory` class for each of the `@Provides` annotated methods.
  prefs: []
  type: TYPE_NORMAL
- en: Connectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming we will have multiple modules, we must combine them in a graph of dependencies
    that can be used across the application. Dagger offers the `@Component` annotation.
    This is usually used for an interface or an abstract class that will be implemented
    by Dagger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with assembling the dependency graph, components also offer the functionality
    to add methods to inject dependencies into a certain object’s members. In components,
    you can specify provision methods that return dependencies provided in the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding `Component`, Dagger will generate a `DaggerMyComponent` class,
    and we can build it as described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Application` class will create the Dagger dependency graph and component.
    The `inject` method in `Component` allows us to perform DI on the variables in
    the `Application` class annotated with `@Inject`, giving us access to the `ClassB`
    object defined in the module.
  prefs: []
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use qualifiers if you want to provide multiple instances of the same
    class (such as injecting different strings or integers across an application).
    These are annotations that can help you identify instances. One of the most common
    ones is the `@Named` qualifier, as described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create two instances of `ClassA` and give them different
    names. We then use the first instance whenever possible to create `ClassB`. We
    can also create custom qualifiers instead of the `@Named` annotation, as described
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The module can be updated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to keep track of the lifecycle of your components and your dependencies,
    you can use scopes. Dagger offers a `@Singleton` scope. This usually indicates
    that your component will live as long as your application.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping has no impact on the lifecycle of the objects; they are built to help
    developers identify the lifecycles of objects. Giving your components one scope
    and grouping your code to reflect that scope is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common Dagger scopes on Android are related to the activity or fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The annotation can be used in the module where the dependency is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `Component` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example indicates that `Component` can only use objects with the
    same scope. If any of the modules that are part of `Component` contain dependencies
    with different scopes, Dagger will throw an error indicating that there is something
    wrong with the scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Subcomponents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something that goes hand-in-hand with scopes is subcomponents. They allow you
    to organize your dependencies for smaller scopes. One common use case on Android
    is to create subcomponents for activities and fragments. Subcomponents inherit
    dependencies from the parent, and they generate a new dependency graph for the
    scope of the subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a separate module, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Subcomponent` that will generate a dependency graph for that module would
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent component would need to declare the new component, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can inject `ClassC` into your activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this knowledge, let’s move on to the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.02 – Dagger injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will write an Android application that will apply the concept
    of DI with Dagger. The application will have the same `Repository` and `ViewModel`
    defined in *Exercise 13.01*, *Manual injection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to use Dagger to expose the same two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Repository`: This will have the `@Singleton` scope and will be provided by
    `ApplicationModule`. Now, `ApplicationModule` will be exposed as part of `ApplicationComponent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModelProvider.Factory`: This will have the custom-defined scope named
    `MainScope` and will be provided by `MainModule`. Now, `MainModule` will be exposed
    by `MainSubComponent`. Also, `MainSubComponent` will be generated by `ApplicationComponent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The app itself will display a randomly generated number each time a button
    is clicked. To achieve this, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio Project with Empty Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by adding Dagger and the `ViewModel` libraries to the `app/build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need the `kapt` plugin in the `app/build.gradle` module. Attach the
    plugin as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to add the `NumberRepository`, `NumberRepositoryImpl`, `Main` **ViewModel**,
    and `RandomApplication` classes and build our UI with `Main` **Activity**. This
    can be done by following *steps 2–9* from *Exercise 13.01*, *Manual injection*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s move on to `ApplicationModule` in the `main/java` folder in the
    root package, which will provide the `NumberRepository` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create `MainModule` in the `main/java` folder in the root package,
    which will provide the instance of `ViewModel.Factory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create `MainScope` in the `main/java` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need `MainSubcomponent` in the `main/java` folder in the root package,
    which will use the preceding scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will require `ApplicationComponent` in the `main/java` folder in the
    root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we modify the `RandomApplication` class to add the code required to initialize
    the Dagger dependency graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now modify the `MainActivity` class to inject `ViewModelProvider.Factory`
    and initialize `ViewModel` so that we can display the random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/A7ozE](https://packt.link/A7ozE).
  prefs: []
  type: TYPE_NORMAL
- en: We will need to navigate to `Build` and click on `Rebuild project` in Android
    Studio so that Dagger will generate the code for performing the DI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run the preceding code, it will build an application that will display
    a different random output when you click the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated
    number](img/B19411_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated
    number
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.3* shows what the application looks like. You can view the generated
    Dagger code in the `app/build` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.3 – Generated Dagger code for \uFEFFExercise 13.02](img/B19411_13_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Generated Dagger code for Exercise 13.02
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13**.3*, we can see the code that Dagger generated to satisfy the
    relationship between dependencies. For every dependency that needs to be injected,
    Dagger will generate an appropriate `Factory` class (based on the `Factory` design
    pattern), which will be responsible for creating the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Dagger also looks at the places where dependencies will need to be injected
    and generates an `Injector` class, which will have the responsibility of assigning
    the value to the dependency (in this case, it will assign the value to the members
    annotated with `@Inject` in the `MainActivity` class).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Dagger creates implementations for the interfaces that have the `@Component`
    annotation. In the implementation, Dagger will handle how the modules are created
    and also provide a builder in which developers can specify how modules can be
    built.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common setup you will find for Android applications when it comes to organizing
    their dependencies is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationModule`: This is where dependencies common for the entire project
    are defined. Objects such as context, resources, and other Android framework objects
    can be provided here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkModule`: This is where dependencies related to API calls are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StorageModule`: This is where dependencies related to persistence are stored.
    It can be split into `DatabaseModule`, `FilesModule`, `SharedPreferencesModule`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModelsModule`: This is where dependencies to `ViewModels` or the `ViewModel`
    factories are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FeatureModule`: This is where dependencies are organized for a particular
    activity or fragment with their own `ViewModel`. Here, either subcomponents or
    Android injectors are used for this purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve raised some questions about how manual DI can go wrong. Now we have seen
    how Dagger can address these issues. Although it does the job, and it does it
    quickly when it comes to performance, it is also a complex framework with a very
    steep learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: Hilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we use Dagger in an Android application, there is a bit of boilerplate
    code we are forced to write. Some of it is around dealing with the lifecycles
    of objects linked with Activities and Fragments, which leads us to create subcomponents;
    other parts are around the usage of ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: An attempt to simplify Dagger for Android was made with the Dagger-Android library,
    but later on, a new library was developed on top of Dagger called **Hilt**. This
    library simplifies much of the Dagger usage through the usage of new annotations,
    which leads to more boilerplate code that can be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Hilt in a project, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or depending on how your project uses Gradle, you might need to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, you need a plugin to process annotations and a separate plugin
    to process Hilt in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Hilt to your project you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change Hilt makes is in the `Application` class. Instead of needing
    to invoke a particular Dagger component to be initialized, with Hilt, you can
    just use the `@``HiltAndroidApp` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will let Hilt know the entry point into your application
    and it will start generating the dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit of Hilt comes when interacting with Android components such
    as `Activities`, `Fragments`, `Views`, `Services`, and `BroadcastReceivers`. For
    these we can use the `@AndroidEntryPoint` annotation to inject dependencies into
    each of these classes, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above snippet, the usage of `@AndroidEntryPoint` allows Hilt to inject
    `myObject` into `MyActivity`. A similar approach can be used for injecting dependencies
    into `ViewModels`, through the `@``HiltViewModel` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the above snippet, the `@HiltViewModel` annotation allows Hilt to inject
    `myObject` into `MyViewModel`. We can also observe the `@Inject` annotation, carried
    over from Dagger, not requiring the usage of modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to modules, Hilt continues the approach from Dagger with one
    minor addition: the usage of the `@InstallIn` annotation. This associates the
    annotated module with a particular component. Hilt provides a set of prebuilt
    components such as `SingletonComponent`, `ViewModelComponent`, `ActivityComponent`,
    `FragmentComponent`, `ViewComponent`, and `ServiceComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these components links the lifecycle of the dependencies inside the
    annotated module to the lifecycles of the application, `ViewModel`, `Activity`,
    `Fragment`, `View`, and `Service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we can see what a `@Module` looks like in Hilt and
    how we can use the `@InstallIn` annotation to specify that `MyObject` lives as
    long as our application lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to instrumented tests, Hilt provides useful annotations for changing
    the dependencies for the tests. If we want to take advantage of these features,
    then we need the following dependencies for tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then go to our test and introduce Hilt into it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `@HiltAndroid` test and `hiltRule` are used to
    swap the dependencies used in the application with the test dependencies. The
    call to inject is what allows us to inject the `MyObject` dependency into the
    test class. To provide the test dependencies, we can write a new module in the
    `androidTest` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `@TestInstallIn` annotation, which will replace the existing
    `MyModule` from the dependency graph with `MyTestModule`, which can provide a
    different sub-class of the dependency we want to swap.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Hilt to be initialized for the instrumented tests, we will need to define
    a custom test runner to provide a test application from the Hilt library. The
    runner might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This runner will need to be registered in `build.gradle` of the module running
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we studied the Hilt library and its benefits when it comes
    to removing boilerplate code that was required using Dagger.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.03 – Hilt injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify *Exercise 13.02*, *Dagger injection*, such that the `@Component` and
    `@Subcomponent` classes are removed and Hilt is used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Hilt plugin in the top-level `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Hilt plugin in `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, replace the Dagger dependencies with Hilt dependencies and
    add the fragments extension library used for generating `ViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete `ApplicationComponent`, `MainModule`, `MainScope`, and `MainSubcomponent`
    from the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `@InstallIn` annotation to `ApplicationModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove all the code from inside `RandomApplication` and add the `@HiltAndroid``App`
    annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `MainViewModel` to add the `@HiltViewModel` and `@``Inject` annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `MainActivity` to instead inject `MainViewModel`, remove all the component
    dependencies that were deleted previously, and add the `@``AndroidEntryPoint`
    annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/k7hs7](https://packt.link/k7hs7).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, we use the `viewModels` method to obtain the `MainViewModel`
    dependency. This is a mechanism built into the extension functions from `androidx.fragment:fragment-ktx:1.5.5`,
    which will look for factories that will obtain the instance of our `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Output of exercise 13.03](img/B19411_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Output of exercise 13.03
  prefs: []
  type: TYPE_NORMAL
- en: We can see how much we can simplify an application’s code using Hilt instead
    of Dagger. For example, we no longer have to deal with the `@Component` and `@Subcomponent`
    annotated classes and managing subcomponents in the application component, and
    also, we don’t need to manually initialize the dependency graph from the `Application`
    class because Hilt handles this for us. These are some of the main reasons why
    Hilt became the most adopted library for dependency injection in Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Koin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Koin is a lighter framework that is suitable for smaller apps. It requires no
    code generation and is built based on Kotlin’s functional extensions. It is also
    a **domain-specific language** (**DSL**). You may have noticed that when using
    Dagger, a lot of code must be written to set up the DI. Koin’s approach to DI
    solves most of those issues, allowing faster integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Koin can be added to your project by adding the following dependency to your
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up Koin in your application, you need the `startKoin` call with the
    DSL syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can configure what your application context is (in the `androidContext`
    method), specify property files to define Koin configurations (in `androidFileProperties`),
    state the Logger Level for Koin, which will output in `LogCat` results of Koin
    operations depending on the Level (in the `androidLogger` method), and list the
    modules your application uses. A similar syntax is used to create the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the two objects will have two different lifecycles.
    When a dependency is provided using the **single** notation, only one instance
    will be used across the entire application lifecycle. This is useful for repositories,
    databases, and API components, where multiple instances will be costly for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The **factory** notation will create a new object every time an injection is
    performed. This may be useful in situations when an object needs to live as long
    as an activity or fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency can be injected using the `by inject()` method or the `get()`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Koin also offers the possibility of using qualifiers with the help of the `named()`
    method when the module is created. This allows you to provide multiple implementations
    of the same type (for example, providing two or more list objects with different
    content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'One of Koin’s main features for Android applications is scopes for activities
    and fragments, and can be defined as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example connects the lifecycle of the `ClassB` dependency to
    the lifecycle of `MainActivity`. In order for you to inject your instance into
    your activity, you will need to extend the `ScopeActivity` class. This class is
    responsible for holding a reference as long as the activity lives. Similar classes
    exist for other Android components such as Fragments (`ScopeFragment`) and services
    (`ScopeService`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You can inject the instance into your activity using the `inject()` method.
    This is useful when you wish to limit who gets to access the dependency. In the
    preceding example, if another activity had wanted to access the reference to `ClassB`,
    then it wouldn’t be able to find it in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that comes in handy for Android is the `ViewModel` injections.
    To set this up, you will need to add the library to `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recall, `ViewModels` require `ViewModelProvider.Factories` in order
    to be instantiated. Koin automatically solves this, allowing `ViewModels` to be
    injected directly and to handle the factory work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To inject the dependency of `ViewModel` into your activity, you can use the
    `viewModel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the method directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding setup, Koin takes full advantage of Kotlin’s
    language features and reduces the amount of boilerplate required to define your
    modules and their scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.04 – Koin injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will write an Android application that will perform DI using Koin.
    The application will be based on *Exercise 13.01*, *Manual injection*, by keeping
    `NumberRepository`, `NumberRepositoryImpl`, `MainViewModel`, and `MainActivity`.
    The following dependencies will be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Repository`: As part of a module named `appModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainViewModel`: This will rely on Koin’s specialized implementation for `ViewModels`.
    This will be provided as part of a module named `mainModule` and will have the
    `MainActivity` scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will display a randomly generated number each time a button is clicked.
    Let’s start by adding the Koin libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define the `appModule` variable inside the `RandomApplication` class.
    This will have a similar structure to `AppModule` with the Dagger setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add the activity module variable after `appModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s initialize `Koin` in the `onCreate()` method of `RandomApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s inject the dependencies into the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/0Njdv](https://packt.link/0Njdv).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding code, the app should work as per the previous examples.
    However, if you check `LogCat`, you will see a similar output to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In *Figure 13**.5*, we can see the same output as in previous exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated
    number](img/B19411_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated
    number
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this exercise, Koin is much faster and easier to integrate,
    especially with its `ViewModel` library. This comes in handy for small projects,
    but its performance will be impacted once projects grow.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 13.01 – injected repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you are going to create an app in Android Studio that connects
    to a sample API, [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts),
    using the Retrofit library and retrieves a list of posts from the web page, which
    will then be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You will then need to set up a UI test in which you will check whether the data
    is asserted correctly on the screen, but instead of connecting to the actual endpoint,
    you will provide dummy data for the test to display on the screen. You will use
    the DI concept to swap the dependencies using Hilt when the app is executed as
    opposed to when the app is being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, you will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A network component that is responsible for downloading and parsing the JSON
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A repository that accesses the data from the API layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` instance that accesses the Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An activity with `RecycleView` that displays the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One UI test that will assert the rows and use a dummy object to generate the
    API data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Error handling can be avoided for this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, create an application with `Empty Activity` (`MainActivity`)
    and add an `api` package where your API calls are stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a class responsible for the API calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `repository` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `repository` interface with one method, returning `LiveData` with the
    list of posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the implementation for the `repository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ViewModel` instance to call the `repository` to retrieve the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an adapter for the rows of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the activity that will render the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a Hilt module that will initialize the network-related dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Hilt module that will be responsible for defining the dependencies
    required for the activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the UI tests and a test application and provide a separate `RepositoryModule`
    class, which will return a dependency holding dummy data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the UI test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/3xfkt](https://packt.link/3xfkt).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the concept of DI and how it should be applied
    to separate concerns and prevent objects from having the responsibility of creating
    other objects and how this is of great benefit for testing. We started the chapter
    by analyzing the concept of manual DI. This served as a good example of how DI
    works and how it can be applied to an Android application; it served as the baseline
    when comparing the DI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: We also analyzed two of the most popular frameworks that help developers inject
    dependencies. We started with a powerful and fast framework called Dagger 2, which
    relies on annotation processors to generate code to perform an injection. We then
    looked at how Hilt reduced the complexity of Dagger for Android applications.
    We also investigated Koin, a lightweight framework written in Kotlin with slower
    performance but simpler integration and a lot of focus on Android components.
  prefs: []
  type: TYPE_NORMAL
- en: The exercises in this chapter were intended to explore how the same problem
    can be solved using multiple solutions and compare the degrees of difficulty between
    the solutions. In the activities for this chapter, we leveraged Dagger’s, Hilt’s,
    and Koin’s modules to inject certain dependencies when running the app and other
    dependencies when running the tests on an application that uses `ViewModels`,
    repositories, and APIs to load data.
  prefs: []
  type: TYPE_NORMAL
- en: This is designed to show the seamless integration of multiple frameworks that
    achieve different goals. In the chapter’s activity, we looked at how we can use
    Hilt to swap dependencies for testing purposes and inject dummy data that we can
    then assert whether it is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, you will have the opportunity to build upon the knowledge
    acquired thus far by adding concepts related to threading and how to handle background
    operations. In addition, you will get the opportunity to explore libraries such
    as RxJava and its reactive approach to threading, and you will also learn about
    coroutines, which take a different approach to threading.
  prefs: []
  type: TYPE_NORMAL
- en: You will also observe how coroutines and RxJava can combine very effectively
    with libraries such as Room and Retrofit. Finally, you will be able to combine
    all of these concepts in a robust application that will have a high degree of
    scalability for the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Polishing and Publishing an App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will look at how we can load data asynchronously with coroutines
    and flows and how we can integrate them into different architecture patterns,
    which further helps with how we can structure an application’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how we can render animations in the user interface with
    `CoordinatorLayout` and `MotionLayout`. Finally, we will learn about the process
    involved in publishing an application on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following chapters in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19411_14.xhtml#_idTextAnchor751), *Coroutines and Flow*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19411_15.xhtml#_idTextAnchor789), *Architecture Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19411_16.xhtml#_idTextAnchor826), *Animations and Transitions
    with CoordinatorLayout and MotionLayout*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19411_17.xhtml#_idTextAnchor918), *Launching Your App on Google
    Play*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
