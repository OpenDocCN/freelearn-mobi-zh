<html><head></head><body>
		<div><h1 id="_idParaDest-210" class="chapter number"><a id="_idTextAnchor695"/>13</h1>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor696"/>Dependency Injection with Dagger, Hilt, and Koin</h1>
			<p><a id="_idTextAnchor697"/>This chapter covers the concept of dependency injection and the benefits it provides to an Android application. We will look at how we can perform dependency injection manually with the help of container classes. We will also cover some of the frameworks available for Android, Java, and Kotlin that can help developers when it comes to applying this concept. By the end of this chapter, you will be able to use Dagger 2 and Koin to manage your app’s dependencies and know how to organize them efficiently.</p>
			<p><a id="_idTextAnchor698"/>In the previous chapter, we looked at how to structure code into different components, including ViewModels, API components, and persistence components. One of the difficulties that always emerged was the dependencies between all of these components, especially when it came to how we approached the unit tests for them.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Manual DI</li>
				<li>Dagger 2</li>
				<li>Hilt</li>
				<li>Koin</li>
			</ul>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor699"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/IIQmX">https://packt.link/IIQmX</a></p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor700"/>The necessity of dependency injection</h1>
			<p>We have constantly used the <code>Application</code> class to create instances of these components and pass them in the constructors of the components one layer above (we created the API and Room instances, then the Repository instances, and so on). What we were doing was a simplistic version of dependency injection.</p>
			<p><code>ViewModels</code>). The reason for this is to increase the reusability and testability of the code and to shift the responsibility for creating instances from our components to the <code>Application</code> class.</p>
			<p>One of the <a id="_idIndexMarker1124"/>benefits of DI concerns how objects are created across the code base. DI separates the creation of an object from its usage. In other words, one object shouldn’t care how another object is created; it should only be concerned with the interaction with the other object.</p>
			<p>In this chapter, we will analyze three ways to inject dependencies in Android: Manual DI, Dagger, and Koin:</p>
			<ul>
				<li><strong class="bold">Manual DI</strong>: This <a id="_idIndexMarker1125"/>is a technique in which developers handle DI manually by creating container classes. In this chapter, we will examine how we can do this in Android. By studying how we manually manage dependencies, we will get some insight into how other DI frameworks operate and get a basis for how we can integrate these frameworks.</li>
				<li><strong class="bold">Dagger</strong>: This is a DI <a id="_idIndexMarker1126"/>framework developed for Java. It allows you to group your dependencies into different modules. You can also define components, where the modules are added to create the dependency graph, and which Dagger automatically implements to perform the injection. It relies on annotation processors to generate the necessary code to perform the injection. A specialized implementation of Dagger <a id="_idIndexMarker1127"/>called <strong class="bold">Hilt</strong> is useful for Android applications because it removes a lot of boilerplate code and simplifies the process.</li>
				<li><strong class="bold">Koin</strong>: This is a <a id="_idIndexMarker1128"/>lightweight DI library developed for Kotlin. It doesn’t rely on annotation processors; it relies on Kotlin’s mechanisms to perform the injection. Here we can also split dependencies into modules.</li>
			</ul>
			<p>In this chapter, we will explore how both these libraries work and the steps required to add them to a simple Android applica<a id="_idTextAnchor701"/><a id="_idTextAnchor702"/>tion.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor703"/>Manual DI</h1>
			<p>In order to <a id="_idIndexMarker1129"/>understand how DI works, we can first analyze how we can manually inject dependencies into different objects across an Android application. This can be achieved by creating container objects containing the dependencies required across the app.</p>
			<p>You can<a id="_idIndexMarker1130"/> also create multiple containers representing different scopes required across the application. Here, you can define dependencies that will only be required as long as a particular screen is displayed, and when the screen is destroyed, the instances can also be garbage collected.</p>
			<p>A sample of a container that will hold instances as long as an application lives is shown here:</p>
			<pre class="source code">
class AppContainer(applicationContext:Context) {
    val myRepository: MyRepository
    init {
        val retrofit =
            Retrofit.Builder().baseUrl(
            "https://google.com/").build()
        val myService=
            retrofit.create&lt;MyService&gt;(MyService::
            class.java)
        val database =
            Room.databaseBuilder(applicationContext,
            MyDatabase::class.java, "db").build()
        myRepository = MyRepositoryImpl(myService,
            database.myDao())
    }
}</pre>
			<p>An <code>Application</code> class using that container looks something like the following:</p>
			<pre class="source code">
class MyApplication : Application() {
    lateinit var appContainer: AppContainer
    override fun onCreate() {
        super.onCreate()
        appContainer = AppContainer(this)
    }
}</pre>
			<p>As you <a id="_idIndexMarker1131"/>can see in the preceding example, the responsibility for creating the dependencies shifted from the <code>Application</code> class to the <code>Container</code> class. Activities across the code base can still access the dependencies using the following command:</p>
			<pre class="source code">
    override fun onCreate(savedInstanceState: Bundle?) {
        ....
        val myRepository = (application as
        MyApplication).appContainer. myRepository
        ...
}</pre>
			<p>Modules with a limited scope could be used for something such as creating the <code>ViewModel</code> factories, which, in turn, are used by the framework to create <code>ViewModel</code>:</p>
			<pre class="source code">
class MyContainer(private val myRepository: MyRepository) {
    fun geMyViewModelFactory(): ViewModelProvider.Factory {
        return object : ViewModelProvider.Factory {
            override fun &lt;T : ViewModel?&gt;
            create(modelClass: Class&lt;T&gt;): T {
                return MyViewModel(myRepository) as T
            }
        }
    }
}</pre>
			<p>An <a id="_idIndexMarker1132"/>activity or fragment can use this particular container to initialize <code>ViewModel</code>:</p>
			<pre class="source code">
class MyActivity : AppCompatActivity() {
    private lateinit var myViewModel: MyViewModel
    private lateinit var myContainer: MyContainer
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        ....
        val myRepository = (application as
            MyApplication).appContainer. myRepository
        myContainer = MyContainer (myRepository)
        myViewModel = ViewModelProvider(this,
            myContainer.geMyViewModelFactory())
            .get(MyViewModel::class.java)
    }
}</pre>
			<p>Again, we can see here that the responsibility of creating the <code>Factory</code> class was shifted from the <code>Activity</code> class to the <code>Container</code> class. <code>MyContainer</code> could be expanded to provide instances required by <code>MyActivity</code> in situations where the lifecycle of those instances should be the same as the activity, or the constructor could be expanded to provide instances with a different lifecycle.</p>
			<p>Now, let’s apply some of these examples to an <a id="_idTextAnchor704"/><a id="_idTextAnchor705"/>exercise.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor706"/>Exercise 13.01 – manual injection</h2>
			<p>In this exercise, we <a id="_idIndexMarker1133"/>will write an Android application that will apply the concept of manual DI. The application will have a Repository, which will generate a random number, and a <code>ViewModel</code> object with a <code>LiveData</code> object responsible for retrieving the number generated by the Repository and publishing it in the <code>LiveData</code> object.</p>
			<p>In order to do so, we will need to create two containers that will manage the following dependencies:</p>
			<ul>
				<li>Repository</li>
				<li>A <code>ViewModel</code> factory responsible for creating <code>ViewModel</code></li>
			</ul>
			<p>The app itself will display the randomly generated number each time a button is clicked:</p>
			<ol>
				<li>Create a new Android Studio Project with an empty activity.</li>
				<li>Let’s start by adding the <code>ViewModel</code> and <code>LiveData</code> libraries to the <code>app/build.gradle</code> file:<pre class="source code">
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>Next, let’s write a <code>NumberRepository</code> interface in the <code>main/java</code> folder in the root package, which will contain a method to retrieve an integer:<pre class="source code">
interface NumberRepository {
    fun generateNextNumber(): Int
}</pre></li>
				<li>Now, we will provide the implementation for this in the <code>main/java</code> folder in the root package. We can use the <code>java.util.Random</code> class to generate a random number:<pre class="source code">
class NumberRepositoryImpl(private val random: Random)
: NumberRepository {
    override fun generateNextNumber(): Int {
        return random.nextInt()
    }
}</pre></li>
				<li>We will<a id="_idIndexMarker1134"/> now move on to the <code>MainViewModel</code> class in the <code>main/java</code> folder in the root package, which will contain a <code>LiveData</code> object containing each generated number from the repository:<pre class="source code">
class MainViewModel(private val numberRepository:
NumberRepository) : ViewModel() {
    private val _numberLiveData =
        MutableLiveData&lt;Int&gt;()
    val numberLiveData: LiveData&lt;Int&gt; =
        _numberLiveData
    fun generateNextNumber() {
        _numberLiveData.postValue(numberRepository
        .generateNextNumber())
    }
}</pre></li>
				<li>Next, let’s move on to <a id="_idIndexMarker1135"/>create our <code>TextView</code> for displaying the number and <code>Button</code> for generating the next random number. This will be part of the <code>res/layout/activity_main.xml</code> file:<pre class="source code">
    &lt;TextView
        android:id="@+id/activity_main_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
    &lt;Button
        android:id="@+id/activity_main_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/randomize" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/lr5Fx">https://packt.link/lr5Fx</a>.</p>
			<ol>
				<li value="7">Make <a id="_idIndexMarker1136"/>sure to add the string for the button to the <code>res/values/strings.xml</code> file:<pre class="source code">
   &lt;string name="randomize"&gt;Randomize&lt;/string&gt;</pre></li>
				<li>Now, let’s create our <code>Application</code> class in the <code>main/java</code> folder in the root package:<pre class="source code">
class RandomApplication : Application() {
    override fun onCreate() {
        super.onCreate()
    }
}</pre></li>
				<li>Let’s also add the <code>Application</code> class to the <code>AndroidManifest.xml</code> file in the <code>application</code> tag:<pre class="source code">
    &lt;application
        ...
        android:name=".RandomApplication"
.../&gt;</pre></li>
				<li>Now, let’s create our first container responsible for managing the <code>NumberRepository</code> dependency in the <code>main/java</code> folder in the root package:<pre class="source code">
class ApplicationContainer {
    val numberRepository: NumberRepository =
    NumberRepositoryImpl(Random())
}</pre></li>
				<li>Next, let’s <a id="_idIndexMarker1137"/>add this container to the <code>RandomApplication</code> class:<pre class="source code">
class RandomApplication : Application() {
    <strong class="bold">val applicationContainer = ApplicationContainer()</strong>
    override fun onCreate() {
        super.onCreate()
    }
}</pre></li>
				<li>We now move on to creating <code>MainContainer</code> in the <code>main/java</code> folder in the root package, which will need a reference to the <code>NumberRepository</code> dependency and will provide a dependency to the <code>ViewModel</code> factory required to create <code>MainViewModel</code>:<pre class="source code">
class MainContainer(private val numberRepository: NumberRepository) {
    fun getMainViewModelFactory():
    ViewModelProvider.Factory {
        return object : ViewModelProvider.Factory {
            override fun &lt;T : ViewModel&gt;
            create(modelClass: Class&lt;T&gt;): T {
                return MainViewModel(numberRepository)
                as T
            }
        }
    }
}</pre></li>
				<li>Finally, we <a id="_idIndexMarker1138"/>can modify <code>MainActivity</code> to inject our dependencies from our containers and connect the UI elements to display the output:<pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
<strong class="bold">        val mainContainer =</strong>
<strong class="bold">            MainContainer((application as</strong>
<strong class="bold">            RandomApplication).applicationContainer</strong>
<strong class="bold">            .numberRepository)</strong>
<strong class="bold">        val viewModel = ViewModelProvider(this,</strong>
<strong class="bold">            mainContainer.getMainViewModelFactory()</strong>
<strong class="bold">        ).get(MainViewModel::class.java)</strong>
<strong class="bold">        viewModel.numberLiveData.observe(this,</strong>
<strong class="bold">        Observer {</strong>
<strong class="bold">            findViewById&lt;TextView&gt;(</strong>
<strong class="bold">            R.id.activity_main_text_view).text =</strong>
<strong class="bold">            it.toString()</strong>
<strong class="bold">        }</strong>
<strong class="bold">        )</strong>
<strong class="bold">        findViewById&lt;TextView&gt;(</strong>
<strong class="bold">        R.id.activity_main_button).setOnClickListener</strong>
<strong class="bold">        {</strong>
<strong class="bold">            viewModel.generateNextNumber()</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>In the<a id="_idIndexMarker1139"/> highlighted code, we can see that we are using the repository defined in <code>ApplicationContainer</code> and injecting it into <code>MainContainer</code>, which will then inject it into <code>ViewModel</code> through <code>ViewModelProvider.Factory</code>. The preceding example should render the output presented <a id="_idTextAnchor707"/>in <em class="italic">Figure 13</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B19411_13_01.jpg" alt="Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated number"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated number</p>
			<p>Manual DI is <a id="_idIndexMarker1140"/>an easy way to set up your dependencies in situations where the app is small, but it can become extremely difficult as the app grows. Imagine if, in <em class="italic">Exercise 13.01</em>, <em class="italic">Manual injection</em>, we had two classes that extended from <code>NumberRepository</code>. How would we handle such a scenario? How would developers know which one went in what activity? These types of questions have become very common in most of the well-known apps on Google Play, which is why manual DI is rarely used. When used, it normally takes the form of a DI framework similar to the ones we will<a id="_idTextAnchor708"/> <a id="_idTextAnchor709"/>look over<a id="_idTextAnchor710"/> next.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor711"/>Dagger 2</h1>
			<p><strong class="bold">Dagger 2</strong> offers a<a id="_idIndexMarker1141"/> comprehensive way to organize your application’s dependencies. It has the advantage of being adopted first on Android by the developer community before Kotlin was introduced. This is one of the reasons that many Android applications use Dagger as their DI framework.</p>
			<p>Another advantage the framework holds is for Android projects written in Java because the library is developed in the same language. The framework was initially developed by Square (Dagger 1) and later transitioned to Google (Dagger 2). We will cover Dagger 2 in this chapter and describe its benefits.</p>
			<p>Some of the <a id="_idIndexMarker1142"/>key functionality that Dagger 2 provides is listed here:</p>
			<ul>
				<li>Injection</li>
				<li>Dependencies grouped in modules</li>
				<li>Components used to generate dependency graphs</li>
				<li>Qualifiers</li>
				<li>Scopes</li>
				<li>Subcomponents</li>
			</ul>
			<p>Annotations are the key elements when dealing with Dagger because it generates the code required to perform the DI through an annotation processor. The main annotations can be grouped as follows:</p>
			<ul>
				<li><code>@Module</code> are responsible for providing an object (dependent object) that can be injected</li>
				<li><code>@Inject</code> annotation <a id="_idIndexMarker1144"/>is used to define a dependency</li>
				<li><code>@Component</code>-annotated <a id="_idIndexMarker1145"/>interface defines the connection between the provider and the consumer</li>
			</ul>
			<p>You will need to add the following dependencies in the <code>app/build.gradle</code> file to add Dagger to your project:</p>
			<pre class="source code">
implementation 'com.google.dagger:dagger:2.44.2'
kapt 'com.google.dagger:dagger-compiler:2.44.2'</pre>
			<p>Since we are dealing with annotation processors, in the same <code>build.gradle</code> file, you will need to add the plugin for them:</p>
			<pre class="source code">
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
<strong class="bold">apply plugin: 'kotlin-kapt'</strong></pre>
			<p>We should now have an idea of how Dagger 2 goes about performing DI. Next, we will look at each group of annotat<a id="_idTextAnchor712"/><a id="_idTextAnchor713"/>ions Dagger 2 offers.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor714"/>Consumers</h2>
			<p>Dagger<a id="_idIndexMarker1146"/> uses <code>javax.inject.Inject</code> to identify objects that require injection. There are multiple ways to inject dependencies, but the recommended <a id="_idIndexMarker1147"/>ways are through constructor injection and field injection. Constructor injection looks similar to the following code:</p>
			<pre class="source code">
import javax.inject.Inject
<strong class="bold">class ClassA @Inject constructor()</strong>
<strong class="bold">class ClassB @Inject constructor(private val classA:</strong>
<strong class="bold">ClassA)</strong></pre>
			<p>When constructors are annotated with <code>@Inject</code>, Dagger will generate the <code>Factory</code> classes responsible for instantiating the objects. In the example of <code>ClassB</code>, Dagger will try to find the appropriate dependencies that fit the signature of the constructor, which, in this example, is <code>ClassA</code>, which Dagger already created an instance for.</p>
			<p>If you do not want Dagger to manage the instantiation of <code>ClassB</code> but still have the dependency on <code>ClassA</code> injected, you can use field injection, which will look something like this:</p>
			<pre class="source code">
import javax.inject.Inject
class ClassA @Inject constructor()
class ClassB {
<strong class="bold">    @Inject</strong>
    lateinit var classA: ClassA
}</pre>
			<p>In this case, Dagger will generate the necessary code just to inject the dependency bet<a id="_idTextAnchor715"/><a id="_idTextAnchor716"/>ween <code>ClassB</code> and <code>ClassA</code>.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor717"/>Providers</h2>
			<p>You will find<a id="_idIndexMarker1148"/> yourself in situations where your application uses external dependencies. That means that you cannot provide instances through constructor<a id="_idIndexMarker1149"/> injections. Another situation where constructor injection is not possible is when interfaces or abstract classes are used.</p>
			<p>In this situation, Dagger can provide the instance using the <code>@Provides</code> annotation. You will then need to group the methods where instances are provided into modules annotated with <code>@Module</code>:</p>
			<pre class="source code">
import dagger.Module
import dagger.Provides
class ClassA
class ClassB(private val classA: ClassA)
<strong class="bold">@Module</strong>
object MyModule {
<strong class="bold">    @Provides</strong>
    fun provideClassA(): ClassA = ClassA()
<strong class="bold">    @Provides</strong>
    fun provideClassB(classA: ClassA): ClassB =
        ClassB(classA)
}</pre>
			<p>As you can see in the preceding example, <code>ClassA</code> and <code>ClassB</code> don’t have any Dagger annotations. A module was created that will provide the instance for <code>ClassA</code>, which will then be used to provide the instance for <code>ClassB</code>. In this case, Dagger will generate a <code>Factory</code> class for each of the <code>@Pr<a id="_idTextAnchor718"/><a id="_idTextAnchor719"/>ovides</code> annotated methods.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor720"/>Connectors</h2>
			<p>Assuming<a id="_idIndexMarker1150"/> we <a id="_idIndexMarker1151"/>will have multiple modules, we must combine them in a graph of dependencies that can be used across the application. Dagger offers the <code>@Component</code> annotation. This is usually used for an interface or an abstract class that will be implemented by Dagger.</p>
			<p>Along with <a id="_idIndexMarker1152"/>assembling the dependency graph, components also offer the <a id="_idIndexMarker1153"/>functionality to add methods to inject dependencies into a certain object’s members. In components, you can specify provision methods that return dependencies provided in the modules:</p>
			<pre class="source code">
import dagger.Component
<strong class="bold">@Component(modules = [MyModule::class])</strong>
interface MyComponent {
<strong class="bold">    fun inject(myApplication: MyApplication)</strong>
}</pre>
			<p>For the preceding <code>Component</code>, Dagger will generate a <code>DaggerMyComponent</code> class, and we can build it as described in the following code:</p>
			<pre class="source code">
import android.app.Application
import javax.inject.Inject
class MyApplication : Application() {
    @Inject
    lateinit var classB: ClassB
    override fun onCreate() {
        super.onCreate()￼
<strong class="bold">        </strong><strong class="bold">val component = DaggerMyComponent.create()</strong>
        //needs to build the project once to generate
        //DaggerMyComponent.class
        component.inject(this)
    }
}</pre>
			<p>The <code>Application</code> class will create the Dagger dependency graph and component. The <code>inject</code> method in <code>Component</code> allows us to perform DI on the variables in the <code>Application</code> class <a id="_idIndexMarker1154"/>annotated with <code>@Inject</code>, giving us access to the <code>ClassB<a id="_idTextAnchor721"/><a id="_idTextAnchor722"/></code> object defined<a id="_idIndexMarker1155"/> in the module.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor723"/>Qualifiers</h2>
			<p>You can use <a id="_idIndexMarker1156"/>qualifiers <a id="_idIndexMarker1157"/>if you want to provide multiple instances of the same class (such as injecting different strings or integers across an application). These are annotations that can help you identify instances. One of the most common ones is the <code>@Named</code> qualifier, as described in the following code:</p>
			<pre class="source code">
@Module
object MyModule {
<strong class="bold">    @Named("classA1")</strong>
    @Provides
    fun provideClassA1(): ClassA = ClassA()
<strong class="bold">    @Named("classA2")</strong>
    @Provides
    fun provideClassA2(): ClassA = ClassA()
    @Provides
<strong class="bold">    fun provideClassB(@Named("classA1") classA: ClassA):</strong>
<strong class="bold">    ClassB = ClassB(classA)</strong>
}</pre>
			<p>In this example, we create two instances of <code>ClassA</code> and give them different names. We then use the first instance whenever possible to create <code>ClassB</code>. We can also create custom qualifiers instead of the <code>@Named</code> annotation, as described in the following code:</p>
			<pre class="source code">
import javax.inject.Qualifier
@Qualifier
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ClassA1Qualifier
@Qualifier
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ClassA2Qualifier</pre>
			<p>The <a id="_idIndexMarker1158"/>module <a id="_idIndexMarker1159"/>can be updated like this:</p>
			<pre class="source code">
@Module
object MyModule {
<strong class="bold">    @ClassA1Qualifier</strong>
    @Provides
    fun provideClassA1(): ClassA = ClassA()
<strong class="bold">    @ClassA2Qualifier</strong>
    @Provides
    fun provideClassA2(): ClassA = ClassA()
    @Provides
<strong class="bold">    fun provideClassB(@ClassA1Qualifier classA: Clas<a id="_idTextAnchor724"/><a id="_idTextAnchor725"/>sA):</strong>
<strong class="bold">    ClassB = ClassB(classA)</strong>
}</pre>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor726"/>Scopes</h2>
			<p>If you <a id="_idIndexMarker1160"/>want to keep track of the lifecycle of your components and your dependencies, you<a id="_idIndexMarker1161"/> can use scopes. Dagger offers a <code>@Singleton</code> scope. This usually indicates that your component will live as long as your application.</p>
			<p>Scoping has no impact on the lifecycle of the objects; they are built to help developers identify the lifecycles of objects. Giving your components one scope and grouping your code to reflect that scope is recommended.</p>
			<p>Some common <a id="_idIndexMarker1162"/>Dagger scopes on Android are related to the activity or fragment:</p>
			<pre class="source code">
import javax.inject.Scope
@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ActivityScope
@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class FragmentScope</pre>
			<p>The <a id="_idIndexMarker1163"/>annotation can be used in the module where the dependency is provided:</p>
			<pre class="source code">
<strong class="bold">@ActivityScope</strong>
@Provides
fun provideClassA(): ClassA = ClassA()</pre>
			<p>The code for <code>Component</code> will be as follows:</p>
			<pre class="source code">
<strong class="bold">@ActivityScope</strong>
@Component(modules = [MyModule::class])
interface MyComponent {
}</pre>
			<p>The preceding example indicates that <code>Component</code> can only use objects with the same scope. If any of the modules that are part of <code>Component</code> contain dependencies with different scopes, Dagger will throw an error indicating that th<a id="_idTextAnchor727"/><a id="_idTextAnchor728"/>ere is something wrong with the scopes.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor729"/>Subcomponents</h2>
			<p>Something <a id="_idIndexMarker1164"/>that goes hand-in-hand with scopes is subcomponents. They<a id="_idIndexMarker1165"/> allow you to organize your dependencies for smaller scopes. One common use case on Android is to create subcomponents for activities and fragments. Subcomponents inherit dependencies from the parent, and they generate a new dependency graph for the scope of the subcomponent.</p>
			<p>Let’s assume we have a separate module, as shown here:</p>
			<pre class="source code">
class ClassC
@Module
object MySubcomponentModule {
    @Provides
    fun provideClassC(): ClassC = ClassC()
}</pre>
			<p>A <code>Subcomponent</code> that will generate a dependency graph for that module would look something like the following:</p>
			<pre class="source code">
import dagger.Subcomponent
@ActivityScope
<strong class="bold">@Subcomponent(modules = [MySubcomponentModule::class])</strong>
interface MySubcomponent {
    fun inject(mainActivity: MainActivity)
}</pre>
			<p>The parent component would need to declare the new component, as shown in the following code snippet:</p>
			<pre class="source code">
import dagger.Component
@Component(modules = [MyModule::class])
interface MyComponent {
    fun inject(myApplication: MyApplication)
<strong class="bold">    fun createSubcomponent(mySubcomponentModule:</strong>
<strong class="bold">    MySubcomponentModule): MySubcomponent</strong>
}</pre>
			<p>And <a id="_idIndexMarker1166"/>you <a id="_idIndexMarker1167"/>can inject <code>ClassC</code> into your activity as follows:</p>
			<pre class="source code">
@Inject
    lateinit var classC: ClassC
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
<strong class="bold">        (application as MyApplication).component</strong>
<strong class="bold">        .createSubcomponent(MyS<a id="_idTextAnchor730"/>ubcomponentModule)</strong>
<strong class="bold">        .inject(this)</strong>
}</pre>
			<p>With thi<a id="_idTextAnchor731"/><a id="_idTextAnchor732"/>s knowledge, let’s move on to the exercise.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor733"/>Exercise 13.02 – Dagger injection</h2>
			<p>In this exercise, we <a id="_idIndexMarker1168"/>will write an Android application that will apply the concept of DI with Dagger. The application will have the same <code>Repository</code> and <code>ViewModel</code> defined in <em class="italic">Exercise 13.01</em>, <em class="italic">Manual injection</em>.</p>
			<p>We will need to use Dagger to expose the same two dependencies:</p>
			<ul>
				<li><code>Repository</code>: This will have the <code>@Singleton</code> scope and will be provided by <code>ApplicationModule</code>. Now, <code>ApplicationModule</code> will be exposed as part of <code>ApplicationComponent</code>.</li>
				<li><code>ViewModelProvider.Factory</code>: This will have the custom-defined scope named <code>MainScope</code> and will be provided by <code>MainModule</code>. Now, <code>MainModule</code> will be exposed by <code>MainSubComponent</code>. Also, <code>MainSubComponent</code> will be generated by <code>ApplicationComponent</code>.</li>
			</ul>
			<p>The app itself will display a randomly generated number each time a button is clicked. To achieve this, take<a id="_idIndexMarker1169"/> the following steps:</p>
			<ol>
				<li>Create a new Android Studio Project with Empty Activity.</li>
				<li>Let’s start by adding Dagger and the <code>ViewModel</code> libraries to the <code>app/build.gradle</code> file:<pre class="source code">
    implementation 'com.google.dagger:dagger:2.44.2'
    kapt 'com.google.dagger:dagger-compiler:2.44.2'
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>We also need the <code>kapt</code> plugin in the <code>app/build.gradle</code> module. Attach the plugin as shown here:<pre class="source code">
apply plugin: 'kotlin-kapt'</pre></li>
				<li>We now need to add the <code>NumberRepository</code>, <code>NumberRepositoryImpl</code>, <code>Main</code><strong class="source inline">
ViewModel</strong>, and <code>RandomApplication</code> classes and build our UI with <code>Main</code><strong class="source inline">
Activity</strong>. This can be done by following <em class="italic">steps 2–9</em> from <em class="italic">Exercise 13.01</em>, <em class="italic">Manual injection</em>.</li>
				<li>Now, let’s move on to <code>ApplicationModule</code> in the <code>main/java</code> folder in the root package, which will provide the <code>NumberRepository</code> dependency:<pre class="source code">
    @Module
    class ApplicationModule {
        @Provides
        fun provideRandom(): Random = Random()
        @Provides
        fun provideNumberRepository(random: Random):
        NumberRepository =
        NumberRepositoryImpl(random)
}</pre></li>
				<li>Now, let’s create <code>MainModule</code> in the <code>main/java</code> folder in the root package, which will<a id="_idIndexMarker1170"/> provide the instance of <code>ViewModel.Factory</code>:<pre class="source code">
@Module
class MainModule {
    @Provides
    fun provideMainViewModelFactory(numberRepository:
    NumberRepository): ViewModelProvider.Factory {
        return object : ViewModelProvider.Factory {
            override fun &lt;T : ViewModel&gt;
            create(modelClass: Class&lt;T&gt;): T {
                return MainViewModel(numberRepository)
                as T
            }
        }
    }
}</pre></li>
				<li>Now, let’s create <code>MainScope</code> in the <code>main/java</code> folder in the root package:<pre class="source code">
@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention
.RUNTIME)
annotation class MainScope</pre></li>
				<li>We will need <code>MainSubcomponent</code> in the <code>main/java</code> folder in the root package, which will use the preceding scope:<pre class="source code">
@MainScope
@Subcomponent(modules = [MainModule::class])
interface MainSubcomponent {
    fun inject(mainActivity: MainActivity)
}</pre></li>
				<li>Next, we <a id="_idIndexMarker1171"/>will require <code>ApplicationComponent</code> in the <code>main/java</code> folder in the root package:<pre class="source code">
@Singleton
@Component(modules = [ApplicationModule::class])
interface ApplicationComponent {
    fun createMainSubcomponent(): MainSubcomponent
}</pre></li>
				<li>Next, we modify the <code>RandomApplication</code> class to add the code required to initialize the Dagger dependency graph:<pre class="source code">
class RandomApplication : Application() {
    <strong class="bold">lateinit var applicationComponent:</strong>
<strong class="bold">    ApplicationComponent</strong>
    override fun onCreate() {
        super.onCreate()
        <strong class="bold">applicationComponent =</strong>
<strong class="bold">        DaggerApplicationComponent.create()</strong>
    }
}</pre></li>
				<li>We<a id="_idIndexMarker1172"/> now modify the <code>MainActivity</code> class to inject <code>ViewModelProvider.Factory</code> and initialize <code>ViewModel</code> so that we can display the random number:<pre class="source code">
class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var factory: ViewModelProvider.Factory
    override fun onCreate(savedInstanceState: Bundle?)
    {
        <strong class="bold">(application as RandomApplication)</strong>
<strong class="bold">            .applicationComponent</strong>
<strong class="bold">            .createMainSubcomponent()</strong>
<strong class="bold">            .inject(this)</strong>
        super.onCreate(savedInstanceState)
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/A7ozE">https://packt.link/A7ozE</a>.</p>
			<ol>
				<li value="12">We will need to navigate to <code>Build</code> and click on <code>Rebuild project</code> in Android Studio so that Dagger will generate the code for performing the DI.</li>
			</ol>
			<p>If you run the preceding code, it will build an application that will display a dif<a id="_idTextAnchor734"/>ferent random output when you click the button:</p>
			<div><div><img src="img/B19411_13_02.jpg" alt="Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated number"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated number</p>
			<ol>
				<li value="13"><em class="italic">Figure 13</em><em class="italic">.3</em> shows<a id="_idIndexMarker1173"/> what the application looks like. You can view the<a id="_idTextAnchor735"/> generated Dagger code in the <code>app/build</code> folder:</li>
			</ol>
			<div><div><img src="img/B19411_13_03.jpg" alt="Figure 13.3 – Generated Dagger code for ﻿Exercise 13.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Generated Dagger code for Exercise 13.02</p>
			<p>In <em class="italic">Figure 13</em><em class="italic">.3</em>, we can see the code that Dagger generated to satisfy the relationship between dependencies. For every dependency that needs to be injected, Dagger will generate an appropriate <code>Factory</code> class (based on the <code>Factory</code> design pattern), which will be responsible for creating the dependency.</p>
			<p>Dagger also<a id="_idIndexMarker1174"/> looks at the places where dependencies will need to be injected and generates an <code>Injector</code> class, which will have the responsibility of assigning the value to the dependency (in this case, it will assign the value to the members annotated with <code>@Inject</code> in the <code>MainActivity</code> class).</p>
			<p>Finally, Dagger creates implementations for the interfaces that have the <code>@Component</code> annotation. In the implementation, Dagger will handle how the modules are created and also provide a builder in which developers can specify how modules can be built.</p>
			<p>A common setup you will find for Android applications when it comes to organizing their dependencies is as follows:</p>
			<ul>
				<li><code>ApplicationModule</code>: This is where dependencies common for the entire project are defined. Objects such as context, resources, and other Android framework objects can be provided here.</li>
				<li><code>NetworkModule</code>: This is where dependencies related to API calls are stored.</li>
				<li><code>StorageModule</code>: This is where dependencies related to persistence are stored. It can be split into <code>DatabaseModule</code>, <code>FilesModule</code>, <code>SharedPreferencesModule</code>, and so on.</li>
				<li><code>ViewModelsModule</code>: This is where dependencies to <code>ViewModels</code> or the <code>ViewModel</code> factories are stored.</li>
				<li><code>FeatureModule</code>: This is where dependencies are organized for a particular activity or fragment with their own <code>ViewModel</code>. Here, either subcomponents or Android injectors are used for this purpose.</li>
			</ul>
			<p>We’ve raised some questions about how manual DI can go wrong. Now we have seen how Dagger can address these issues. Although it does the job, and it does it quickly when it comes to performance, it is also a complex framework with a very steep learning curve.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor736"/>Hilt</h1>
			<p>When<a id="_idIndexMarker1175"/> we use Dagger in an Android application, there is a bit of boilerplate code we are forced to write. Some of it is around dealing with the lifecycles of objects linked with Activities and Fragments, which leads us to create subcomponents; other parts are around the usage of ViewModels.</p>
			<p>An attempt to simplify Dagger for Android was made with the Dagger-Android library, but later on, a new library was developed on top of Dagger called <strong class="bold">Hilt</strong>. This library simplifies much of the Dagger usage through the usage of new annotations, which leads to more boilerplate code that can be generated.</p>
			<p>To use<a id="_idIndexMarker1176"/> Hilt in a project, we will need the following:</p>
			<pre class="source code">
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
<strong class="bold">apply plugin: 'kotlin-kapt'</strong>
<strong class="bold">apply plugin: 'com.google.dagger.hilt.android'</strong></pre>
			<p>Or depending on how your project uses Gradle, you might need to use the following:</p>
			<pre class="source code">
plugins {
  …
  id 'kotlin-kapt'
  id 'com.google.dagger.hilt.android'
}</pre>
			<p>In both cases, you need a plugin to process annotations and a separate plugin to process Hilt in your project.</p>
			<p>To add Hilt to your project you need the following:</p>
			<pre class="source code">
dependencies {
  implementation "com.google.dagger:hilt-android:2.44.2"
  kapt "com.google.dagger:hilt-compiler:2.44.2"
}</pre>
			<p>The first change Hilt makes is in the <code>Application</code> class. Instead of needing to invoke a particular Dagger component to be initialized, with Hilt, you can just use the <code>@</code><code>HiltAndroidApp</code> annotation:</p>
			<pre class="source code">
@HiltAndroidApp
class MyApplication : Application() {
}</pre>
			<p>The preceding<a id="_idIndexMarker1177"/> snippet will let Hilt know the entry point into your application and it will start generating the dependency graph.</p>
			<p>Another benefit of Hilt comes when interacting with Android components such as <code>Activities</code>, <code>Fragments</code>, <code>Views</code>, <code>Services</code>, and <code>BroadcastReceivers</code>. For these we can use the <code>@AndroidEntryPoint</code> annotation to inject dependencies into each of these classes, which looks like the following:</p>
			<pre class="source code">
@AndroidEntryPoint
class MyActivity : AppCompatActivity() {
    @Inject
    lateinit var myObject: MyObject
}</pre>
			<p>In the above snippet, the usage of <code>@AndroidEntryPoint</code> allows Hilt to inject <code>myObject</code> into <code>MyActivity</code>. A similar approach can be used for injecting dependencies into <code>ViewModels</code>, through the <code>@</code><code>HiltViewModel</code> annotation:</p>
			<pre class="source code">
@HiltViewModel
class MyViewModel @Inject constructor(private val myObject:
MyObject) : ViewModel()</pre>
			<p>In the above snippet, the <code>@HiltViewModel</code> annotation allows Hilt to inject <code>myObject</code> into <code>MyViewModel</code>. We can also observe the <code>@Inject</code> annotation, carried over from Dagger, not requiring the usage of modules.</p>
			<p>When it comes to modules, Hilt continues the approach from Dagger with one minor addition: the usage of the <code>@InstallIn</code> annotation. This associates the annotated module with a particular component. Hilt provides a set of prebuilt components such as <code>SingletonComponent</code>, <code>ViewModelComponent</code>, <code>ActivityComponent</code>, <code>FragmentComponent</code>, <code>ViewComponent</code>, and <code>ServiceComponent</code>.</p>
			<p>Each of these <a id="_idIndexMarker1178"/>components links the lifecycle of the dependencies inside the annotated module to the lifecycles of the application, <code>ViewModel</code>, <code>Activity</code>, <code>Fragment</code>, <code>View</code>, and <code>Service</code>:</p>
			<pre class="source code">
@Module
<strong class="bold">@InstallIn(SingletonComponent::class)</strong>
class MyModule {
    @Provides
    fun provideMyObject(): MyObject = MyObject()
}</pre>
			<p>In the preceding snippet, we can see what a <code>@Module</code> looks like in Hilt and how we can use the <code>@InstallIn</code> annotation to specify that <code>MyObject</code> lives as long as our application lives.</p>
			<p>When it comes to instrumented tests, Hilt provides useful annotations for changing the dependencies for the tests. If we want to take advantage of these features, then we need the following dependencies for tests:</p>
			<pre class="source code">
    androidTestImplementation 'com.google.dagger:
        hilt-android-testing:2.44.2'
    kaptAndroidTest 'com.google.dagger:
        hilt-android-compiler:2.44.2'</pre>
			<p>We can then go to our test and introduce Hilt into it as follows:</p>
			<pre class="source code">
<strong class="bold">@HiltAndroidTest</strong>
class MyInstrumentedTest {
<strong class="bold">    @get:Rule</strong>
<strong class="bold">    var hiltRule = HiltAndroidRule(this)</strong>
    @Inject
    lateinit var myObject: MyObject
    @Before
    fun init() {
<strong class="bold">        hiltRule.inject()</strong>
    }
}</pre>
			<p>In the<a id="_idIndexMarker1179"/> preceding snippet, the <code>@HiltAndroid</code> test and <code>hiltRule</code> are used to swap the dependencies used in the application with the test dependencies. The call to inject is what allows us to inject the <code>MyObject</code> dependency into the test class. To provide the test dependencies, we can write a new module in the <code>androidTest</code> folder as follows:</p>
			<pre class="source code">
@Module
<strong class="bold">@TestInstallIn(</strong>
<strong class="bold">    components = [SingletonComponent::class],</strong>
<strong class="bold">    replaces = [MyModule::class]</strong>
<strong class="bold">)</strong>
class MyTestModule {
    @Provides
    fun provideMyObject(): MyObject = MyTestObject()
}</pre>
			<p>Here, we are using the <code>@TestInstallIn</code> annotation, which will replace the existing <code>MyModule</code> from the dependency graph with <code>MyTestModule</code>, which can provide a different sub-class of the dependency we want to swap.</p>
			<p>For Hilt to be initialized for the instrumented tests, we will need to define a custom test runner to provide a test application from the Hilt library. The runner might look like the following:</p>
			<pre class="source code">
class HiltTestRunner : AndroidJUnitRunner() {
    override fun newApplication(cl: ClassLoader?, name:
    String?, context: Context?): Application {
<strong class="bold">        return super.newApplication(cl,</strong>
<strong class="bold">        HiltTestApplication::class.java.name, context)</strong>
    }
}</pre>
			<p>This runner <a id="_idIndexMarker1180"/>will need to be registered in <code>build.gradle</code> of the module running the test:</p>
			<pre class="source code">
android {
    …
    defaultConfig {
        …
        testInstrumentationRunner "{app_package_name}
            .HiltTestRunner"
    }
}</pre>
			<p>In this section, we studied the Hilt library and its benefits when it comes to removing boilerplate code that was required using Dagger.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor737"/>Exercise 13.03 – Hilt injection</h2>
			<p>Modify <em class="italic">Exercise 13.02</em>, <em class="italic">Dagger injection</em>, such that the <code>@Component</code> and <code>@Subcomponent</code> classes are removed and Hilt is used instead:</p>
			<ol>
				<li>Add the Hilt plugin in the top-level <code>build.gradle</code> file:<pre class="source code">
plugins {
    …
    id 'com.google.dagger.hilt.android' version
    '2.44.2' apply false
}</pre></li>
				<li>Add the <a id="_idIndexMarker1181"/>Hilt plugin in <code>app/build.gradle</code>:<pre class="source code">
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-kapt'
    id 'com.google.dagger.hilt.android'
}</pre></li>
				<li>In the same file, replace the Dagger dependencies with Hilt dependencies and add the fragments extension library used for generating <code>ViewModel</code>:<pre class="source code">
    implementation "com.google.dagger:
        hilt-android:2.44.2"
    kapt "com.google.dagger:hilt-compiler:2.44.2"
    implementation 'androidx.fragment:
        fragment-ktx:1.5.5'</pre></li>
				<li>Delete <code>ApplicationComponent</code>, <code>MainModule</code>, <code>MainScope</code>, and <code>MainSubcomponent</code> from the project.</li>
				<li>Add the <code>@InstallIn</code> annotation to <code>ApplicationModule</code>:<pre class="source code">
@Module
<strong class="bold">@InstallIn(SingletonComponent::class)</strong>
class ApplicationModule {
}</pre></li>
				<li>Remove all the code from inside <code>RandomApplication</code> and add the <code>@HiltAndroid</code><strong class="source inline">
</strong><code>App</code> annotation:<pre class="source code">
@HiltAndroidApp
class RandomApplication : Application()</pre></li>
				<li>Modify <code>MainViewModel</code> to add the <code>@HiltViewModel</code> and <code>@</code><code>Inject</code> annotations:<pre class="source code">
@HiltViewModel
class MainViewModel @Inject constructor(private val
numberRepository: NumberRepository) :
    ViewModel() {
    …
}</pre></li>
				<li>Modify <code>MainActivity</code> to instead inject <code>MainViewModel</code>, remove all the component <a id="_idIndexMarker1182"/>dependencies that were deleted previously, and add the <code>@</code><code>AndroidEntryPoint</code> annotation:<pre class="source code">
<strong class="bold">@AndroidEntryPoint</strong>
class MainActivity : AppCompatActivity() {
<strong class="bold">    private val mainViewModel: MainViewModel by</strong>
<strong class="bold">    viewModels()</strong>
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/k7hs7">https://packt.link/k7hs7</a>.</p>
			<p>In the preceding snippet, we use the <code>viewModels</code> method to obtain the <code>MainViewModel</code> dependency. This is a mechanism built into the extension functions from <code>androidx.fragment:fragment-ktx:1.5.5</code>, which will look for factories that will obtain the instance of our <code>ViewModel</code>.</p>
			<p>If we run the <a id="_idIndexMarker1183"/>code, we should see the following output:</p>
			<div><div><img src="img/B19411_13_04.jpg" alt="Figure 13.4 – Output of exercise 13.03"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Output of exercise 13.03</p>
			<p>We can see how much we can simplify an application’s code using Hilt instead of Dagger. For example, we no longer have to deal with the <code>@Component</code> and <code>@Subcomponent</code> annotated classes and managing subcomponents in the application component, and also, we don’t need to manually initialize the dependency graph from the <code>Application</code> class because Hilt handles this for us. These are some of the main reasons why Hilt became the most adopted l<a id="_idTextAnchor738"/><a id="_idTextAnchor739"/>ibrar<a id="_idTextAnchor740"/>y for dependency injection in Android applications.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor741"/>Koin</h1>
			<p>Koin is a<a id="_idIndexMarker1184"/> lighter framework that is suitable for smaller apps. It requires no code generation and is built based on Kotlin’s <a id="_idIndexMarker1185"/>functional extensions. It is also a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>). You may have noticed that when using Dagger, a lot of code must be written to set up the DI. Koin’s approach to DI solves most of those issues, allowing faster integration.</p>
			<p>Koin can be <a id="_idIndexMarker1186"/>added to your project by adding the following dependency to your <code>build.gradle</code> file:</p>
			<pre class="source code">
implementation "io.insert-koin:koin-core:3.2.2"</pre>
			<p>To set up Koin in your application, you need the <code>startKoin</code> call with the DSL syntax:</p>
			<pre class="source code">
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
<strong class="bold">        startKoin {</strong>
            androidLogger(Level.INFO)
            androidContext(this@MyApplication)
            androidFileProperties()
            modules(myModules)
<strong class="bold">        }</strong>
    }
}</pre>
			<p>Here, you can configure what your application context is (in the <code>androidContext</code> method), specify property files to define Koin configurations (in <code>androidFileProperties</code>), state the Logger Level for Koin, which will output in <code>LogCat</code> results of Koin operations depending on the Level (in the <code>androidLogger</code> method), and list the modules your application uses. A similar syntax is used to create the modules:</p>
			<pre class="source code">
class ClassA
class ClassB(private val classB: ClassA)
<strong class="bold">    val moduleForClassA = module {</strong>
<strong class="bold">        single { ClassA() }</strong>
<strong class="bold">    }</strong>
<strong class="bold">    val moduleForClassB = module {</strong>
<strong class="bold">        factory { ClassB(get()) }</strong>
<strong class="bold">    }</strong>
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidLogger(Level.INFO)
            androidContext(this@MyApplication)
            androidFileProperties()
<strong class="bold">            </strong><strong class="bold">modules(listOf(moduleForClassA,</strong>
<strong class="bold">            moduleForClassB))</strong>
        }
    }</pre>
			<p>In the preceding <a id="_idIndexMarker1187"/>example, the two objects will have two different lifecycles. When a dependency is provided using<a id="_idIndexMarker1188"/> the <strong class="bold">single</strong> notation, only one instance will be used across the entire application lifecycle. This is useful for repositories, databases, and API components, where multiple instances will be costly for the application.</p>
			<p>The <strong class="bold">factory</strong> notation <a id="_idIndexMarker1189"/>will create a new object every time an injection is performed. This may be useful in situations when an object needs to live as long as an activity or fragment.</p>
			<p>The dependency can be injected using the <code>by inject()</code> method or the <code>get()</code> method, as shown in the following code:</p>
			<pre class="source code">
    class MainActivity : AppCompatActivity() {
<strong class="bold">      val classB: ClassB by inject()</strong>
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
<strong class="bold">        val classB: ClassB = get()</strong>
    }</pre>
			<p>Koin also <a id="_idIndexMarker1190"/>offers the possibility of using qualifiers with the help of the <code>named()</code> method when the module is created. This allows you to provide multiple implementations of the same type (for example, providing two or more list objects with different content):</p>
			<pre class="source code">
    val moduleForClassA = module {
<strong class="bold">        single(named("name")) { ClassA() }</strong>
    }</pre>
			<p>One of Koin’s main features for Android applications is scopes for activities and fragments, and can be defined as shown in the following code snippet:</p>
			<pre class="source code">
    val moduleForClassB = module {
<strong class="bold">        scope(named&lt;MainActivity&gt;()) {</strong>
<strong class="bold">            scoped { ClassB(get()) }</strong>
<strong class="bold">        }</strong>
    }</pre>
			<p>The preceding example connects the lifecycle of the <code>ClassB</code> dependency to the lifecycle of <code>MainActivity</code>. In order for you to inject your instance into your activity, you will need to extend the <code>ScopeActivity</code> class. This class is responsible for holding a reference as long as the activity lives. Similar classes exist for other Android components such as Fragments (<code>ScopeFragment</code>) and services (<code>ScopeService</code>):</p>
			<pre class="source code">
class MainActivity : ScopeActivity() {
<strong class="bold">    val classB: ClassB by inject()</strong>
}</pre>
			<p>You can inject the instance into your activity using the <code>inject()</code> method. This is useful when you wish to limit who gets to access the dependency. In the preceding example, if another activity had wanted to access the reference to <code>ClassB</code>, then it wouldn’t be able to find it in the scope.</p>
			<p>Another <a id="_idIndexMarker1191"/>feature that comes in handy for Android is the <code>ViewModel</code> injections. To set this up, you will need to add the library to <code>build.gradle</code>:</p>
			<pre class="source code">
implementation "io.insert-koin:koin-android:3.2.2"</pre>
			<p>If you recall, <code>ViewModels</code> require <code>ViewModelProvider.Factories</code> in order to be instantiated. Koin automatically solves this, allowing <code>ViewModels</code> to be injected directly and to handle the factory work:</p>
			<pre class="source code">
    val moduleForClassB = module {
        factory {
            ClassB(get())
        }
<strong class="bold">        viewModel { MyViewModel(get()) }</strong>
    }</pre>
			<p>To inject the dependency of <code>ViewModel</code> into your activity, you can use the <code>viewModel()</code> method:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
<strong class="bold">    val model: MyViewModel by viewModel()</strong>
}</pre>
			<p>Alternatively, you can use the method directly:</p>
			<pre class="source code">
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
<strong class="bold">        val model : MyViewModel = getViewModel()</strong>
    }</pre>
			<p>As we can see in the preceding setup, Koin takes full advantage of Kotlin’s language features and reduces the amount <a id="_idTextAnchor742"/>of bo<a id="_idTextAnchor743"/>ilerplate required to define your modules and their scopes.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor744"/>Exercise 13.04 – Koin injection</h2>
			<p>Here, we <a id="_idIndexMarker1192"/>will write an Android application that will perform DI using Koin. The application will be based on <em class="italic">Exercise 13.01</em>, <em class="italic">Manual injection</em>, by keeping <code>NumberRepository</code>, <code>NumberRepositoryImpl</code>, <code>MainViewModel</code>, and <code>MainActivity</code>. The following dependencies will be injected:</p>
			<ul>
				<li><code>Repository</code>: As part of a module named <code>appModule</code>.</li>
				<li><code>MainViewModel</code>: This will rely on Koin’s specialized implementation for <code>ViewModels</code>. This will be provided as part of a module named <code>mainModule</code> and will have the <code>MainActivity</code> scope.</li>
			</ul>
			<p>Perform the following steps to complete the exercise:</p>
			<ol>
				<li>The app will display a randomly generated number each time a button is clicked. Let’s start by adding the Koin libraries:<pre class="source code">
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"
    implementation "io.insert-koin:koin-android:3.2.2"
    implementation "io.insert-koin:koin-core:3.2.2"
    testImplementation 'junit:junit:4.13.2'</pre></li>
				<li>Next, define the <code>appModule</code> variable inside the <code>RandomApplication</code> class. This will have a similar structure to <code>AppModule</code> with the Dagger setup:<pre class="source code">
class RandomApplication : Application() {
    <strong class="bold">val appModule = module {</strong>
        single {
            Random()
        }
        single&lt;NumberRepository&gt; {
            NumberRepositoryImpl(get())
        }
}
}</pre></li>
				<li>Now, let’s <a id="_idIndexMarker1193"/>add the activity module variable after <code>appModule</code>:<pre class="source code">
    <strong class="bold">val mainModule = module {</strong>
        scope(named&lt;MainActivity&gt;()) {
            scoped {
                MainViewModel(get())
            }
        }
    }</pre></li>
				<li>Next, let’s initialize <code>Koin</code> in the <code>onCreate()</code> method of <code>RandomApplication</code>:<pre class="source code">
        super.onCreate()
        startKoin {
            androidLogger()
            androidContext(this@RandomApplication)
            modules(listOf(appModule, mainModule))
        }</pre></li>
				<li>Finally, let’s inject the dependencies into the activity:<pre class="source code">
class MainActivity : ScopeActivity() {
    private val mainViewModel: MainViewModel by
    inject()
}</pre></li>
			</ol>
			<p>The <a id="_idIndexMarker1194"/>complete code for this step can be found at <a href="https://packt.link/0Njdv">https://packt.link/0Njdv</a>.</p>
			<ol>
				<li value="6">If you run the preceding code, the app should work as per the previous examples. However, if you check <code>LogCat</code>, you will see a similar output to this:<pre class="source code">
[Koin]: [init] declare Android Context
[Koin]: bind type:'android.content.Context' ~ [type:Single,primary_type:'android.content.Context']
[Koin]: bind type:'android.app.Application' ~ [type:Single,primary_type:'android.app.Application']
[Koin]: bind type:'java.util.Random' ~ [type:Single,primary_type:'java.util.Random']
[Koin]: bind type:'com.android.testable.randomapplication .NumberRepository' ~ [type:Single,primary_type:'com.android .testable.randomapplication.NumberRepository']
[Koin]: total 5 registered definitions
[Koin]: load modules in 0.4638 ms</pre></li>
			</ol>
			<p>In<a id="_idTextAnchor745"/> <em class="italic">Figure 13</em><em class="italic">.5</em>, we can see the same output as in previous exercises:</p>
			<div><div><img src="img/B19411_13_05.jpg" alt="Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated number"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated number</p>
			<p>As we can see from this<a id="_idIndexMarker1195"/> exercise, Koin is much faster and easier to integrate, especially with its <code>ViewModel</code> library. This comes in handy for small<a id="_idTextAnchor746"/> proje<a id="_idTextAnchor747"/>cts, but its performance will be impacted once projects grow.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor748"/>Activity 13.01 – injected repositories</h2>
			<p>In this <a id="_idIndexMarker1196"/>activity, you are going to create an app in Android Studio that connects to a sample API, <a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>, using the Retrofit library and retrieves a list of posts from the web page, which will then be displayed on the screen.</p>
			<p>You will then need to set up a UI test in which you will check whether the data is asserted correctly on the screen, but instead of connecting to the actual endpoint, you will provide dummy data for the test to display on the screen. You will use the DI concept to swap the dependencies using Hilt when the app is executed as opposed to when the app is being tested.</p>
			<p>In order to achieve this, you will need to build the following:</p>
			<ul>
				<li>A network component that is responsible for downloading and parsing the JSON file</li>
				<li>A repository that accesses the data from the API layer</li>
				<li>A <code>ViewModel</code> instance that accesses the Repository</li>
				<li>An activity with <code>RecycleView</code> that displays the data</li>
				<li>One UI test that will assert the rows and use a dummy object to generate the API data</li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Error handling can be avoided for this activity.</p>
			<p>Perform the <a id="_idIndexMarker1197"/>following steps to complete this activity:</p>
			<ol>
				<li>In Android Studio, create an application with <code>Empty Activity</code> (<code>MainActivity</code>) and add an <code>api</code> package where your API calls are stored.</li>
				<li>Define a class responsible for the API calls.</li>
				<li>Create a <code>repository</code> package.</li>
				<li>Define a <code>repository</code> interface with one method, returning <code>LiveData</code> with the list of posts.</li>
				<li>Create the implementation for the <code>repository</code> class.</li>
				<li>Create a <code>ViewModel</code> instance to call the <code>repository</code> to retrieve the data.</li>
				<li>Create an adapter for the rows of the UI.</li>
				<li>Create the activity that will render the UI.</li>
				<li>Set up a Hilt module that will initialize the network-related dependencies.</li>
				<li>Create a Hilt module that will be responsible for defining the dependencies required for the activity.</li>
				<li>Set up the UI tests and a test application and provide a separate <code>RepositoryModule</code> class, which will return a dependency holding dummy data.</li>
				<li>Implement <a id="_idIndexMarker1198"/>the UI test.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/3xfkt">https://packt.link/3xfkt</a>.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor749"/>Summary</h1>
			<p>In this chapter, we analyzed the concept of DI and how it should be applied to separate concerns and prevent objects from having the responsibility of creating other objects and how this is of great benefit for testing. We started the chapter by analyzing the concept of manual DI. This served as a good example of how DI works and how it can be applied to an Android application; it served as the baseline when comparing the DI frameworks.</p>
			<p>We also analyzed two of the most popular frameworks that help developers inject dependencies. We started with a powerful and fast framework called Dagger 2, which relies on annotation processors to generate code to perform an injection. We then looked at how Hilt reduced the complexity of Dagger for Android applications. We also investigated Koin, a lightweight framework written in Kotlin with slower performance but simpler integration and a lot of focus on Android components.</p>
			<p>The exercises in this chapter were intended to explore how the same problem can be solved using multiple solutions and compare the degrees of difficulty between the solutions. In the activities for this chapter, we leveraged Dagger’s, Hilt’s, and Koin’s modules to inject certain dependencies when running the app and other dependencies when running the tests on an application that uses <code>ViewModels</code>, repositories, and APIs to load data.</p>
			<p>This is designed to show the seamless integration of multiple frameworks that achieve different goals. In the chapter’s activity, we looked at how we can use Hilt to swap dependencies for testing purposes and inject dummy data that we can then assert whether it is displayed on the screen.</p>
			<p>In the following chapters, you will have the opportunity to build upon the knowledge acquired thus far by adding concepts related to threading and how to handle background operations. In addition, you will get the opportunity to explore libraries such as RxJava and its reactive approach to threading, and you will also learn about coroutines, which take a different approach to threading.</p>
			<p>You will also observe how coroutines and RxJava can combine very effectively with libraries such as Room and Retrofit. Finally, you will be able to combine all of these concepts in a robust application that will have a high degree of scalability for the future.</p>
		</div>
	

		<div><h1 id="_idParaDest-230"><a id="_idTextAnchor750"/>Part 4: Polishing and Publishing an App</h1>
			<p>In this part, we will look at how we can load data asynchronously with coroutines and flows and how we can integrate them into different architecture patterns, which further helps with how we can structure an application’s code.</p>
			<p>Next, we will look at how we can render animations in the user interface with <code>CoordinatorLayout</code> and <code>MotionLayout</code>. Finally, we will learn about the process involved in publishing an application on Google Play.</p>
			<p>We will cover the following chapters in this section:</p>
			<ul>
				<li><a href="B19411_14.xhtml#_idTextAnchor751"><em class="italic">Chapter 14</em></a>, <em class="italic">Coroutines and Flow</em></li>
				<li><a href="B19411_15.xhtml#_idTextAnchor789"><em class="italic">Chapter 15</em></a>, <em class="italic">Architecture Patterns</em></li>
				<li><a href="B19411_16.xhtml#_idTextAnchor826"><em class="italic">Chapter 16</em></a>, <em class="italic">Animations and Transitions with CoordinatorLayout and MotionLayout</em></li>
				<li><a href="B19411_17.xhtml#_idTextAnchor918"><em class="italic">Chapter 17</em></a>, <em class="italic">Launching Your App on Google Play</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>