<html><head></head><body>
		<div id="_idContainer208">
			<h1 id="_idParaDest-210" class="chapter number"><a id="_idTextAnchor695"/>13</h1>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor696"/>Dependency Injection with Dagger, Hilt, and Koin</h1>
			<p><a id="_idTextAnchor697"/>This chapter covers the concept of dependency injection and the benefits it provides to an Android application. We will look at how we can perform dependency injection manually with the help of container classes. We will also cover some of the frameworks available for Android, Java, and Kotlin that can help developers when it comes to applying this concept. By the end of this chapter, you will be able to use Dagger 2 and Koin to manage your app’s dependencies and know how to organize <span class="No-Break">them efficiently.</span></p>
			<p><a id="_idTextAnchor698"/>In the previous chapter, we looked at how to structure code into different components, including ViewModels, API components, and persistence components. One of the difficulties that always emerged was the dependencies between all of these components, especially when it came to how we approached the unit tests <span class="No-Break">for them.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Manual DI</span></li>
				<li><span class="No-Break">Dagger 2</span></li>
				<li><span class="No-Break">Hilt</span></li>
				<li><span class="No-Break">Koin</span></li>
			</ul>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor699"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/IIQmX"><span class="No-Break">https://packt.link/IIQmX</span></a></p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor700"/>The necessity of dependency injection</h1>
			<p>We have constantly used the <strong class="source inline">Application</strong> class to create instances of these components and pass them in the constructors of the components one layer above (we created the API and Room instances, then the Repository instances, and so on). What we were doing was a simplistic version of <span class="No-Break">dependency injection.</span></p>
			<p><strong class="bold">Dependency injection</strong> (<strong class="bold">DI</strong>) is a <a id="_idIndexMarker1123"/>software technique in which one object (the application) supplies the dependencies of another object (repositories, <strong class="source inline">ViewModels</strong>). The reason for this is to increase the reusability and testability of the code and to shift the responsibility for creating instances from our components to the <span class="No-Break"><strong class="source inline">Application</strong></span><span class="No-Break"> class.</span></p>
			<p>One of the <a id="_idIndexMarker1124"/>benefits of DI concerns how objects are created across the code base. DI separates the creation of an object from its usage. In other words, one object shouldn’t care how another object is created; it should only be concerned with the interaction with the <span class="No-Break">other object.</span></p>
			<p>In this chapter, we will analyze three ways to inject dependencies in Android: Manual DI, Dagger, <span class="No-Break">and Koin:</span></p>
			<ul>
				<li><strong class="bold">Manual DI</strong>: This <a id="_idIndexMarker1125"/>is a technique in which developers handle DI manually by creating container classes. In this chapter, we will examine how we can do this in Android. By studying how we manually manage dependencies, we will get some insight into how other DI frameworks operate and get a basis for how we can integrate <span class="No-Break">these frameworks.</span></li>
				<li><strong class="bold">Dagger</strong>: This is a DI <a id="_idIndexMarker1126"/>framework developed for Java. It allows you to group your dependencies into different modules. You can also define components, where the modules are added to create the dependency graph, and which Dagger automatically implements to perform the injection. It relies on annotation processors to generate the necessary code to perform the injection. A specialized implementation of Dagger <a id="_idIndexMarker1127"/>called <strong class="bold">Hilt</strong> is useful for Android applications because it removes a lot of boilerplate code and simplifies <span class="No-Break">the process.</span></li>
				<li><strong class="bold">Koin</strong>: This is a <a id="_idIndexMarker1128"/>lightweight DI library developed for Kotlin. It doesn’t rely on annotation processors; it relies on Kotlin’s mechanisms to perform the injection. Here we can also split dependencies <span class="No-Break">into modules.</span></li>
			</ul>
			<p>In this chapter, we will explore how both these libraries work and the steps required to add them to a simple <span class="No-Break">Android applica<a id="_idTextAnchor701"/><a id="_idTextAnchor702"/>tion.</span></p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor703"/>Manual DI</h1>
			<p>In order to <a id="_idIndexMarker1129"/>understand how DI works, we can first analyze how we can manually inject dependencies into different objects across an Android application. This can be achieved by creating container objects containing the dependencies required across <span class="No-Break">the app.</span></p>
			<p>You can<a id="_idIndexMarker1130"/> also create multiple containers representing different scopes required across the application. Here, you can define dependencies that will only be required as long as a particular screen is displayed, and when the screen is destroyed, the instances can also be <span class="No-Break">garbage collected.</span></p>
			<p>A sample of a container that will hold instances as long as an application lives is <span class="No-Break">shown here:</span></p>
			<pre class="source code">
class AppContainer(applicationContext:Context) {
    val myRepository: MyRepository
    init {
        val retrofit =
            Retrofit.Builder().baseUrl(
            "https://google.com/").build()
        val myService=
            retrofit.create&lt;MyService&gt;(MyService::
            class.java)
        val database =
            Room.databaseBuilder(applicationContext,
            MyDatabase::class.java, "db").build()
        myRepository = MyRepositoryImpl(myService,
            database.myDao())
    }
}</pre>
			<p>An <strong class="source inline">Application</strong> class using that container looks something like <span class="No-Break">the following:</span></p>
			<pre class="source code">
class MyApplication : Application() {
    lateinit var appContainer: AppContainer
    override fun onCreate() {
        super.onCreate()
        appContainer = AppContainer(this)
    }
}</pre>
			<p>As you <a id="_idIndexMarker1131"/>can see in the preceding example, the responsibility for creating the dependencies shifted from the <strong class="source inline">Application</strong> class to the <strong class="source inline">Container</strong> class. Activities across the code base can still access the dependencies using the <span class="No-Break">following command:</span></p>
			<pre class="source code">
    override fun onCreate(savedInstanceState: Bundle?) {
        ....
        val myRepository = (application as
        MyApplication).appContainer. myRepository
        ...
}</pre>
			<p>Modules with a limited scope could be used for something such as creating the <strong class="source inline">ViewModel</strong> factories, which, in turn, are used by the framework to <span class="No-Break">create </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class MyContainer(private val myRepository: MyRepository) {
    fun geMyViewModelFactory(): ViewModelProvider.Factory {
        return object : ViewModelProvider.Factory {
            override fun &lt;T : ViewModel?&gt;
            create(modelClass: Class&lt;T&gt;): T {
                return MyViewModel(myRepository) as T
            }
        }
    }
}</pre>
			<p>An <a id="_idIndexMarker1132"/>activity or fragment can use this particular container to <span class="No-Break">initialize </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class MyActivity : AppCompatActivity() {
    private lateinit var myViewModel: MyViewModel
    private lateinit var myContainer: MyContainer
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        ....
        val myRepository = (application as
            MyApplication).appContainer. myRepository
        myContainer = MyContainer (myRepository)
        myViewModel = ViewModelProvider(this,
            myContainer.geMyViewModelFactory())
            .get(MyViewModel::class.java)
    }
}</pre>
			<p>Again, we can see here that the responsibility of creating the <strong class="source inline">Factory</strong> class was shifted from the <strong class="source inline">Activity</strong> class to the <strong class="source inline">Container</strong> class. <strong class="source inline">MyContainer</strong> could be expanded to provide instances required by <strong class="source inline">MyActivity</strong> in situations where the lifecycle of those instances should be the same as the activity, or the constructor could be expanded to provide instances with a <span class="No-Break">different lifecycle.</span></p>
			<p>Now, let’s apply some of these examples to <span class="No-Break">an <a id="_idTextAnchor704"/><a id="_idTextAnchor705"/>exercise.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor706"/>Exercise 13.01 – manual injection</h2>
			<p>In this exercise, we <a id="_idIndexMarker1133"/>will write an Android application that will apply the concept of manual DI. The application will have a Repository, which will generate a random number, and a <strong class="source inline">ViewModel</strong> object with a <strong class="source inline">LiveData</strong> object responsible for retrieving the number generated by the Repository and publishing it in the <span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break"> object.</span></p>
			<p>In order to do so, we will need to create two containers that will manage the <span class="No-Break">following dependencies:</span></p>
			<ul>
				<li><span class="No-Break">Repository</span></li>
				<li>A <strong class="source inline">ViewModel</strong> factory responsible for <span class="No-Break">creating </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span></li>
			</ul>
			<p>The app itself will display the randomly generated number each time a button <span class="No-Break">is clicked:</span></p>
			<ol>
				<li>Create a new Android Studio Project with an <span class="No-Break">empty activity.</span></li>
				<li>Let’s start by adding the <strong class="source inline">ViewModel</strong> and <strong class="source inline">LiveData</strong> libraries to the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>Next, let’s write a <strong class="source inline">NumberRepository</strong> interface in the <strong class="source inline">main/java</strong> folder in the root package, which will contain a method to retrieve <span class="No-Break">an integer:</span><pre class="source code">
interface NumberRepository {
    fun generateNextNumber(): Int
}</pre></li>
				<li>Now, we will provide the implementation for this in the <strong class="source inline">main/java</strong> folder in the root package. We can use the <strong class="source inline">java.util.Random</strong> class to generate a <span class="No-Break">random number:</span><pre class="source code">
class NumberRepositoryImpl(private val random: Random)
: NumberRepository {
    override fun generateNextNumber(): Int {
        return random.nextInt()
    }
}</pre></li>
				<li>We will<a id="_idIndexMarker1134"/> now move on to the <strong class="source inline">MainViewModel</strong> class in the <strong class="source inline">main/java</strong> folder in the root package, which will contain a <strong class="source inline">LiveData</strong> object containing each generated number from <span class="No-Break">the repository:</span><pre class="source code">
class MainViewModel(private val numberRepository:
NumberRepository) : ViewModel() {
    private val _numberLiveData =
        MutableLiveData&lt;Int&gt;()
    val numberLiveData: LiveData&lt;Int&gt; =
        _numberLiveData
    fun generateNextNumber() {
        _numberLiveData.postValue(numberRepository
        .generateNextNumber())
    }
}</pre></li>
				<li>Next, let’s move on to <a id="_idIndexMarker1135"/>create our <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) containing <strong class="source inline">TextView</strong> for displaying the number and <strong class="source inline">Button</strong> for generating the next random number. This will be part of the <span class="No-Break"><strong class="source inline">res/layout/activity_main.xml</strong></span><span class="No-Break"> file:</span><pre class="source code">
    &lt;TextView
        android:id="@+id/activity_main_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
    &lt;Button
        android:id="@+id/activity_main_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/randomize" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/lr5Fx"><span class="No-Break">https://packt.link/lr5Fx</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="7">Make <a id="_idIndexMarker1136"/>sure to add the string for the button to the <span class="No-Break"><strong class="source inline">res/values/strings.xml</strong></span><span class="No-Break"> file:</span><pre class="source code">
   &lt;string name="randomize"&gt;Randomize&lt;/string&gt;</pre></li>
				<li>Now, let’s create our <strong class="source inline">Application</strong> class in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
class RandomApplication : Application() {
    override fun onCreate() {
        super.onCreate()
    }
}</pre></li>
				<li>Let’s also add the <strong class="source inline">Application</strong> class to the <strong class="source inline">AndroidManifest.xml</strong> file in the <span class="No-Break"><strong class="source inline">application</strong></span><span class="No-Break"> tag:</span><pre class="source code">
    &lt;application
        ...
        android:name=".RandomApplication"
.../&gt;</pre></li>
				<li>Now, let’s create our first container responsible for managing the <strong class="source inline">NumberRepository</strong> dependency in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
class ApplicationContainer {
    val numberRepository: NumberRepository =
    NumberRepositoryImpl(Random())
}</pre></li>
				<li>Next, let’s <a id="_idIndexMarker1137"/>add this container to the <span class="No-Break"><strong class="source inline">RandomApplication</strong></span><span class="No-Break"> class:</span><pre class="source code">
class RandomApplication : Application() {
    <strong class="bold">val applicationContainer = ApplicationContainer()</strong>
    override fun onCreate() {
        super.onCreate()
    }
}</pre></li>
				<li>We now move on to creating <strong class="source inline">MainContainer</strong> in the <strong class="source inline">main/java</strong> folder in the root package, which will need a reference to the <strong class="source inline">NumberRepository</strong> dependency and will provide a dependency to the <strong class="source inline">ViewModel</strong> factory required to <span class="No-Break">create </span><span class="No-Break"><strong class="source inline">MainViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
class MainContainer(private val numberRepository: NumberRepository) {
    fun getMainViewModelFactory():
    ViewModelProvider.Factory {
        return object : ViewModelProvider.Factory {
            override fun &lt;T : ViewModel&gt;
            create(modelClass: Class&lt;T&gt;): T {
                return MainViewModel(numberRepository)
                as T
            }
        }
    }
}</pre></li>
				<li>Finally, we <a id="_idIndexMarker1138"/>can modify <strong class="source inline">MainActivity</strong> to inject our dependencies from our containers and connect the UI elements to display <span class="No-Break">the output:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
<strong class="bold">        val mainContainer =</strong>
<strong class="bold">            MainContainer((application as</strong>
<strong class="bold">            RandomApplication).applicationContainer</strong>
<strong class="bold">            .numberRepository)</strong>
<strong class="bold">        val viewModel = ViewModelProvider(this,</strong>
<strong class="bold">            mainContainer.getMainViewModelFactory()</strong>
<strong class="bold">        ).get(MainViewModel::class.java)</strong>
<strong class="bold">        viewModel.numberLiveData.observe(this,</strong>
<strong class="bold">        Observer {</strong>
<strong class="bold">            findViewById&lt;TextView&gt;(</strong>
<strong class="bold">            R.id.activity_main_text_view).text =</strong>
<strong class="bold">            it.toString()</strong>
<strong class="bold">        }</strong>
<strong class="bold">        )</strong>
<strong class="bold">        findViewById&lt;TextView&gt;(</strong>
<strong class="bold">        R.id.activity_main_button).setOnClickListener</strong>
<strong class="bold">        {</strong>
<strong class="bold">            viewModel.generateNextNumber()</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>In the<a id="_idIndexMarker1139"/> highlighted code, we can see that we are using the repository defined in <strong class="source inline">ApplicationContainer</strong> and injecting it into <strong class="source inline">MainContainer</strong>, which will then inject it into <strong class="source inline">ViewModel</strong> through <strong class="source inline">ViewModelProvider.Factory</strong>. The preceding example should render the output presented <a id="_idTextAnchor707"/>in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B19411_13_01.jpg" alt="Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated number"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated number</p>
			<p>Manual DI is <a id="_idIndexMarker1140"/>an easy way to set up your dependencies in situations where the app is small, but it can become extremely difficult as the app grows. Imagine if, in <em class="italic">Exercise 13.01</em>, <em class="italic">Manual injection</em>, we had two classes that extended from <strong class="source inline">NumberRepository</strong>. How would we handle such a scenario? How would developers know which one went in what activity? These types of questions have become very common in most of the well-known apps on Google Play, which is why manual DI is rarely used. When used, it normally takes the form of a DI framework similar to the ones we will<a id="_idTextAnchor708"/> <a id="_idTextAnchor709"/>look <span class="No-Break">over<a id="_idTextAnchor710"/> next.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor711"/>Dagger 2</h1>
			<p><strong class="bold">Dagger 2</strong> offers a<a id="_idIndexMarker1141"/> comprehensive way to organize your application’s dependencies. It has the advantage of being adopted first on Android by the developer community before Kotlin was introduced. This is one of the reasons that many Android applications use Dagger as their <span class="No-Break">DI framework.</span></p>
			<p>Another advantage the framework holds is for Android projects written in Java because the library is developed in the same language. The framework was initially developed by Square (Dagger 1) and later transitioned to Google (Dagger 2). We will cover Dagger 2 in this chapter and describe <span class="No-Break">its benefits.</span></p>
			<p>Some of the <a id="_idIndexMarker1142"/>key functionality that Dagger 2 provides is <span class="No-Break">listed here:</span></p>
			<ul>
				<li><span class="No-Break">Injection</span></li>
				<li>Dependencies grouped <span class="No-Break">in modules</span></li>
				<li>Components used to generate <span class="No-Break">dependency graphs</span></li>
				<li><span class="No-Break">Qualifiers</span></li>
				<li><span class="No-Break">Scopes</span></li>
				<li><span class="No-Break">Subcomponents</span></li>
			</ul>
			<p>Annotations are the key elements when dealing with Dagger because it generates the code required to perform the DI through an annotation processor. The main annotations can be grouped <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Provider</strong>: Classes<a id="_idIndexMarker1143"/> that are annotated with <strong class="source inline">@Module</strong> are responsible for providing an object (dependent object) that can <span class="No-Break">be injected</span></li>
				<li><strong class="bold">Consumer</strong>: The <strong class="source inline">@Inject</strong> annotation <a id="_idIndexMarker1144"/>is used to define <span class="No-Break">a dependency</span></li>
				<li><strong class="bold">Connector</strong>: An <strong class="source inline">@Component</strong>-annotated <a id="_idIndexMarker1145"/>interface defines the connection between the provider and <span class="No-Break">the consumer</span></li>
			</ul>
			<p>You will need to add the following dependencies in the <strong class="source inline">app/build.gradle</strong> file to add Dagger to <span class="No-Break">your project:</span></p>
			<pre class="source code">
implementation 'com.google.dagger:dagger:2.44.2'
kapt 'com.google.dagger:dagger-compiler:2.44.2'</pre>
			<p>Since we are dealing with annotation processors, in the same <strong class="source inline">build.gradle</strong> file, you will need to add the plugin <span class="No-Break">for them:</span></p>
			<pre class="source code">
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
<strong class="bold">apply plugin: 'kotlin-kapt'</strong></pre>
			<p>We should now have an idea of how Dagger 2 goes about performing DI. Next, we will look at each group of annotat<a id="_idTextAnchor712"/><a id="_idTextAnchor713"/>ions Dagger <span class="No-Break">2 offers.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor714"/>Consumers</h2>
			<p>Dagger<a id="_idIndexMarker1146"/> uses <strong class="source inline">javax.inject.Inject</strong> to identify objects that require injection. There are multiple ways to inject dependencies, but the recommended <a id="_idIndexMarker1147"/>ways are through constructor injection and field injection. Constructor injection looks similar to the <span class="No-Break">following code:</span></p>
			<pre class="source code">
import javax.inject.Inject
<strong class="bold">class ClassA @Inject constructor()</strong>
<strong class="bold">class ClassB @Inject constructor(private val classA:</strong>
<strong class="bold">ClassA)</strong></pre>
			<p>When constructors are annotated with <strong class="source inline">@Inject</strong>, Dagger will generate the <strong class="source inline">Factory</strong> classes responsible for instantiating the objects. In the example of <strong class="source inline">ClassB</strong>, Dagger will try to find the appropriate dependencies that fit the signature of the constructor, which, in this example, is <strong class="source inline">ClassA</strong>, which Dagger already created an <span class="No-Break">instance for.</span></p>
			<p>If you do not want Dagger to manage the instantiation of <strong class="source inline">ClassB</strong> but still have the dependency on <strong class="source inline">ClassA</strong> injected, you can use field injection, which will look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
import javax.inject.Inject
class ClassA @Inject constructor()
class ClassB {
<strong class="bold">    @Inject</strong>
    lateinit var classA: ClassA
}</pre>
			<p>In this case, Dagger will generate the necessary code just to inject the dependency bet<a id="_idTextAnchor715"/><a id="_idTextAnchor716"/>ween <strong class="source inline">ClassB</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">ClassA</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor717"/>Providers</h2>
			<p>You will find<a id="_idIndexMarker1148"/> yourself in situations where your application uses external dependencies. That means that you cannot provide instances through constructor<a id="_idIndexMarker1149"/> injections. Another situation where constructor injection is not possible is when interfaces or abstract classes <span class="No-Break">are used.</span></p>
			<p>In this situation, Dagger can provide the instance using the <strong class="source inline">@Provides</strong> annotation. You will then need to group the methods where instances are provided into modules annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">@Module</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
import dagger.Module
import dagger.Provides
class ClassA
class ClassB(private val classA: ClassA)
<strong class="bold">@Module</strong>
object MyModule {
<strong class="bold">    @Provides</strong>
    fun provideClassA(): ClassA = ClassA()
<strong class="bold">    @Provides</strong>
    fun provideClassB(classA: ClassA): ClassB =
        ClassB(classA)
}</pre>
			<p>As you can see in the preceding example, <strong class="source inline">ClassA</strong> and <strong class="source inline">ClassB</strong> don’t have any Dagger annotations. A module was created that will provide the instance for <strong class="source inline">ClassA</strong>, which will then be used to provide the instance for <strong class="source inline">ClassB</strong>. In this case, Dagger will generate a <strong class="source inline">Factory</strong> class for each of the <strong class="source inline">@Pr<a id="_idTextAnchor718"/><a id="_idTextAnchor719"/>ovides</strong> <span class="No-Break">annotated methods.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor720"/>Connectors</h2>
			<p>Assuming<a id="_idIndexMarker1150"/> we <a id="_idIndexMarker1151"/>will have multiple modules, we must combine them in a graph of dependencies that can be used across the application. Dagger offers the <strong class="source inline">@Component</strong> annotation. This is usually used for an interface or an abstract class that will be implemented <span class="No-Break">by Dagger.</span></p>
			<p>Along with <a id="_idIndexMarker1152"/>assembling the dependency graph, components also offer the <a id="_idIndexMarker1153"/>functionality to add methods to inject dependencies into a certain object’s members. In components, you can specify provision methods that return dependencies provided in <span class="No-Break">the modules:</span></p>
			<pre class="source code">
import dagger.Component
<strong class="bold">@Component(modules = [MyModule::class])</strong>
interface MyComponent {
<strong class="bold">    fun inject(myApplication: MyApplication)</strong>
}</pre>
			<p>For the preceding <strong class="source inline">Component</strong>, Dagger will generate a <strong class="source inline">DaggerMyComponent</strong> class, and we can build it as described in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
import android.app.Application
import javax.inject.Inject
class MyApplication : Application() {
    @Inject
    lateinit var classB: ClassB
    override fun onCreate() {
        super.onCreate()￼
<strong class="bold">        </strong><strong class="bold">val component = DaggerMyComponent.create()</strong>
        //needs to build the project once to generate
        //DaggerMyComponent.class
        component.inject(this)
    }
}</pre>
			<p>The <strong class="source inline">Application</strong> class will create the Dagger dependency graph and component. The <strong class="source inline">inject</strong> method in <strong class="source inline">Component</strong> allows us to perform DI on the variables in the <strong class="source inline">Application</strong> class <a id="_idIndexMarker1154"/>annotated with <strong class="source inline">@Inject</strong>, giving us access to the <strong class="source inline">ClassB<a id="_idTextAnchor721"/><a id="_idTextAnchor722"/></strong> object defined<a id="_idIndexMarker1155"/> in <span class="No-Break">the module.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor723"/>Qualifiers</h2>
			<p>You can use <a id="_idIndexMarker1156"/>qualifiers <a id="_idIndexMarker1157"/>if you want to provide multiple instances of the same class (such as injecting different strings or integers across an application). These are annotations that can help you identify instances. One of the most common ones is the <strong class="source inline">@Named</strong> qualifier, as described in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
@Module
object MyModule {
<strong class="bold">    @Named("classA1")</strong>
    @Provides
    fun provideClassA1(): ClassA = ClassA()
<strong class="bold">    @Named("classA2")</strong>
    @Provides
    fun provideClassA2(): ClassA = ClassA()
    @Provides
<strong class="bold">    fun provideClassB(@Named("classA1") classA: ClassA):</strong>
<strong class="bold">    ClassB = ClassB(classA)</strong>
}</pre>
			<p>In this example, we create two instances of <strong class="source inline">ClassA</strong> and give them different names. We then use the first instance whenever possible to create <strong class="source inline">ClassB</strong>. We can also create custom qualifiers instead of the <strong class="source inline">@Named</strong> annotation, as described in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
import javax.inject.Qualifier
@Qualifier
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ClassA1Qualifier
@Qualifier
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ClassA2Qualifier</pre>
			<p>The <a id="_idIndexMarker1158"/>module <a id="_idIndexMarker1159"/>can be updated <span class="No-Break">like this:</span></p>
			<pre class="source code">
@Module
object MyModule {
<strong class="bold">    @ClassA1Qualifier</strong>
    @Provides
    fun provideClassA1(): ClassA = ClassA()
<strong class="bold">    @ClassA2Qualifier</strong>
    @Provides
    fun provideClassA2(): ClassA = ClassA()
    @Provides
<strong class="bold">    fun provideClassB(@ClassA1Qualifier classA: Clas<a id="_idTextAnchor724"/><a id="_idTextAnchor725"/>sA):</strong>
<strong class="bold">    ClassB = ClassB(classA)</strong>
}</pre>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor726"/>Scopes</h2>
			<p>If you <a id="_idIndexMarker1160"/>want to keep track of the lifecycle of your components and your dependencies, you<a id="_idIndexMarker1161"/> can use scopes. Dagger offers a <strong class="source inline">@Singleton</strong> scope. This usually indicates that your component will live as long as <span class="No-Break">your application.</span></p>
			<p>Scoping has no impact on the lifecycle of the objects; they are built to help developers identify the lifecycles of objects. Giving your components one scope and grouping your code to reflect that scope <span class="No-Break">is recommended.</span></p>
			<p>Some common <a id="_idIndexMarker1162"/>Dagger scopes on Android are related to the activity <span class="No-Break">or fragment:</span></p>
			<pre class="source code">
import javax.inject.Scope
@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ActivityScope
@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class FragmentScope</pre>
			<p>The <a id="_idIndexMarker1163"/>annotation can be used in the module where the dependency <span class="No-Break">is provided:</span></p>
			<pre class="source code">
<strong class="bold">@ActivityScope</strong>
@Provides
fun provideClassA(): ClassA = ClassA()</pre>
			<p>The code for <strong class="source inline">Component</strong> will be <span class="No-Break">as follows:</span></p>
			<pre class="source code">
<strong class="bold">@ActivityScope</strong>
@Component(modules = [MyModule::class])
interface MyComponent {
}</pre>
			<p>The preceding example indicates that <strong class="source inline">Component</strong> can only use objects with the same scope. If any of the modules that are part of <strong class="source inline">Component</strong> contain dependencies with different scopes, Dagger will throw an error indicating that th<a id="_idTextAnchor727"/><a id="_idTextAnchor728"/>ere is something wrong with <span class="No-Break">the scopes.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor729"/>Subcomponents</h2>
			<p>Something <a id="_idIndexMarker1164"/>that goes hand-in-hand with scopes is subcomponents. They<a id="_idIndexMarker1165"/> allow you to organize your dependencies for smaller scopes. One common use case on Android is to create subcomponents for activities and fragments. Subcomponents inherit dependencies from the parent, and they generate a new dependency graph for the scope of <span class="No-Break">the subcomponent.</span></p>
			<p>Let’s assume we have a separate module, as <span class="No-Break">shown here:</span></p>
			<pre class="source code">
class ClassC
@Module
object MySubcomponentModule {
    @Provides
    fun provideClassC(): ClassC = ClassC()
}</pre>
			<p>A <strong class="source inline">Subcomponent</strong> that will generate a dependency graph for that module would look something like <span class="No-Break">the following:</span></p>
			<pre class="source code">
import dagger.Subcomponent
@ActivityScope
<strong class="bold">@Subcomponent(modules = [MySubcomponentModule::class])</strong>
interface MySubcomponent {
    fun inject(mainActivity: MainActivity)
}</pre>
			<p>The parent component would need to declare the new component, as shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source code">
import dagger.Component
@Component(modules = [MyModule::class])
interface MyComponent {
    fun inject(myApplication: MyApplication)
<strong class="bold">    fun createSubcomponent(mySubcomponentModule:</strong>
<strong class="bold">    MySubcomponentModule): MySubcomponent</strong>
}</pre>
			<p>And <a id="_idIndexMarker1166"/>you <a id="_idIndexMarker1167"/>can inject <strong class="source inline">ClassC</strong> into your activity <span class="No-Break">as follows:</span></p>
			<pre class="source code">
@Inject
    lateinit var classC: ClassC
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
<strong class="bold">        (application as MyApplication).component</strong>
<strong class="bold">        .createSubcomponent(MyS<a id="_idTextAnchor730"/>ubcomponentModule)</strong>
<strong class="bold">        .inject(this)</strong>
}</pre>
			<p>With thi<a id="_idTextAnchor731"/><a id="_idTextAnchor732"/>s knowledge, let’s move on to <span class="No-Break">the exercise.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor733"/>Exercise 13.02 – Dagger injection</h2>
			<p>In this exercise, we <a id="_idIndexMarker1168"/>will write an Android application that will apply the concept of DI with Dagger. The application will have the same <strong class="source inline">Repository</strong> and <strong class="source inline">ViewModel</strong> defined in <em class="italic">Exercise 13.01</em>, <span class="No-Break"><em class="italic">Manual injection</em></span><span class="No-Break">.</span></p>
			<p>We will need to use Dagger to expose the same <span class="No-Break">two dependencies:</span></p>
			<ul>
				<li><strong class="source inline">Repository</strong>: This will have the <strong class="source inline">@Singleton</strong> scope and will be provided by <strong class="source inline">ApplicationModule</strong>. Now, <strong class="source inline">ApplicationModule</strong> will be exposed as part <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">ApplicationComponent</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source inline">ViewModelProvider.Factory</strong>: This will have the custom-defined scope named <strong class="source inline">MainScope</strong> and will be provided by <strong class="source inline">MainModule</strong>. Now, <strong class="source inline">MainModule</strong> will be exposed by <strong class="source inline">MainSubComponent</strong>. Also, <strong class="source inline">MainSubComponent</strong> will be generated <span class="No-Break">by </span><span class="No-Break"><strong class="source inline">ApplicationComponent</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The app itself will display a randomly generated number each time a button is clicked. To achieve this, take<a id="_idIndexMarker1169"/> the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a new Android Studio Project with <span class="No-Break">Empty Activity.</span></li>
				<li>Let’s start by adding Dagger and the <strong class="source inline">ViewModel</strong> libraries to the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
    implementation 'com.google.dagger:dagger:2.44.2'
    kapt 'com.google.dagger:dagger-compiler:2.44.2'
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>We also need the <strong class="source inline">kapt</strong> plugin in the <strong class="source inline">app/build.gradle</strong> module. Attach the plugin as <span class="No-Break">shown here:</span><pre class="source code">
apply plugin: 'kotlin-kapt'</pre></li>
				<li>We now need to add the <strong class="source inline">NumberRepository</strong>, <span class="No-Break"><strong class="source inline">NumberRepositoryImpl</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source inline">Main</strong></span><strong class="source inline">
ViewModel</strong>, and <strong class="source inline">RandomApplication</strong> classes and build our UI <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">Main</strong></span><strong class="source inline">
Activity</strong>. This can be done by following <em class="italic">steps 2–9</em> from <em class="italic">Exercise 13.01</em>, <span class="No-Break"><em class="italic">Manual injection</em></span><span class="No-Break">.</span></li>
				<li>Now, let’s move on to <strong class="source inline">ApplicationModule</strong> in the <strong class="source inline">main/java</strong> folder in the root package, which will provide the <span class="No-Break"><strong class="source inline">NumberRepository</strong></span><span class="No-Break"> dependency:</span><pre class="source code">
    @Module
    class ApplicationModule {
        @Provides
        fun provideRandom(): Random = Random()
        @Provides
        fun provideNumberRepository(random: Random):
        NumberRepository =
        NumberRepositoryImpl(random)
}</pre></li>
				<li>Now, let’s create <strong class="source inline">MainModule</strong> in the <strong class="source inline">main/java</strong> folder in the root package, which will<a id="_idIndexMarker1170"/> provide the instance <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">ViewModel.Factory</strong></span><span class="No-Break">:</span><pre class="source code">
@Module
class MainModule {
    @Provides
    fun provideMainViewModelFactory(numberRepository:
    NumberRepository): ViewModelProvider.Factory {
        return object : ViewModelProvider.Factory {
            override fun &lt;T : ViewModel&gt;
            create(modelClass: Class&lt;T&gt;): T {
                return MainViewModel(numberRepository)
                as T
            }
        }
    }
}</pre></li>
				<li>Now, let’s create <strong class="source inline">MainScope</strong> in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention
.RUNTIME)
annotation class MainScope</pre></li>
				<li>We will need <strong class="source inline">MainSubcomponent</strong> in the <strong class="source inline">main/java</strong> folder in the root package, which will use the <span class="No-Break">preceding scope:</span><pre class="source code">
@MainScope
@Subcomponent(modules = [MainModule::class])
interface MainSubcomponent {
    fun inject(mainActivity: MainActivity)
}</pre></li>
				<li>Next, we <a id="_idIndexMarker1171"/>will require <strong class="source inline">ApplicationComponent</strong> in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
@Singleton
@Component(modules = [ApplicationModule::class])
interface ApplicationComponent {
    fun createMainSubcomponent(): MainSubcomponent
}</pre></li>
				<li>Next, we modify the <strong class="source inline">RandomApplication</strong> class to add the code required to initialize the Dagger <span class="No-Break">dependency graph:</span><pre class="source code">
class RandomApplication : Application() {
    <strong class="bold">lateinit var applicationComponent:</strong>
<strong class="bold">    ApplicationComponent</strong>
    override fun onCreate() {
        super.onCreate()
        <strong class="bold">applicationComponent =</strong>
<strong class="bold">        DaggerApplicationComponent.create()</strong>
    }
}</pre></li>
				<li>We<a id="_idIndexMarker1172"/> now modify the <strong class="source inline">MainActivity</strong> class to inject <strong class="source inline">ViewModelProvider.Factory</strong> and initialize <strong class="source inline">ViewModel</strong> so that we can display the <span class="No-Break">random number:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var factory: ViewModelProvider.Factory
    override fun onCreate(savedInstanceState: Bundle?)
    {
        <strong class="bold">(application as RandomApplication)</strong>
<strong class="bold">            .applicationComponent</strong>
<strong class="bold">            .createMainSubcomponent()</strong>
<strong class="bold">            .inject(this)</strong>
        super.onCreate(savedInstanceState)
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/A7ozE"><span class="No-Break">https://packt.link/A7ozE</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="12">We will need to navigate to <strong class="source inline">Build</strong> and click on <strong class="source inline">Rebuild project</strong> in Android Studio so that Dagger will generate the code for performing <span class="No-Break">the DI.</span></li>
			</ol>
			<p>If you run the preceding code, it will build an application that will display a dif<a id="_idTextAnchor734"/>ferent random output when you click <span class="No-Break">the button:</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B19411_13_02.jpg" alt="Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated number"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated number</p>
			<ol>
				<li value="13"><span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em> shows<a id="_idIndexMarker1173"/> what the application looks like. You can view the<a id="_idTextAnchor735"/> generated Dagger code in the <span class="No-Break"><strong class="source inline">app/build</strong></span><span class="No-Break"> folder:</span></li>
			</ol>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B19411_13_03.jpg" alt="Figure 13.3 – Generated Dagger code for ﻿Exercise 13.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Generated Dagger code for Exercise 13.02</p>
			<p>In <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>, we can see the code that Dagger generated to satisfy the relationship between dependencies. For every dependency that needs to be injected, Dagger will generate an appropriate <strong class="source inline">Factory</strong> class (based on the <strong class="source inline">Factory</strong> design pattern), which will be responsible for creating <span class="No-Break">the dependency.</span></p>
			<p>Dagger also<a id="_idIndexMarker1174"/> looks at the places where dependencies will need to be injected and generates an <strong class="source inline">Injector</strong> class, which will have the responsibility of assigning the value to the dependency (in this case, it will assign the value to the members annotated with <strong class="source inline">@Inject</strong> in the <span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break"> class).</span></p>
			<p>Finally, Dagger creates implementations for the interfaces that have the <strong class="source inline">@Component</strong> annotation. In the implementation, Dagger will handle how the modules are created and also provide a builder in which developers can specify how modules can <span class="No-Break">be built.</span></p>
			<p>A common setup you will find for Android applications when it comes to organizing their dependencies is <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source inline">ApplicationModule</strong>: This is where dependencies common for the entire project are defined. Objects such as context, resources, and other Android framework objects can be <span class="No-Break">provided here.</span></li>
				<li><strong class="source inline">NetworkModule</strong>: This is where dependencies related to API calls <span class="No-Break">are stored.</span></li>
				<li><strong class="source inline">StorageModule</strong>: This is where dependencies related to persistence are stored. It can be split into <strong class="source inline">DatabaseModule</strong>, <strong class="source inline">FilesModule</strong>, <strong class="source inline">SharedPreferencesModule</strong>, and <span class="No-Break">so on.</span></li>
				<li><strong class="source inline">ViewModelsModule</strong>: This is where dependencies to <strong class="source inline">ViewModels</strong> or the <strong class="source inline">ViewModel</strong> factories <span class="No-Break">are stored.</span></li>
				<li><strong class="source inline">FeatureModule</strong>: This is where dependencies are organized for a particular activity or fragment with their own <strong class="source inline">ViewModel</strong>. Here, either subcomponents or Android injectors are used for <span class="No-Break">this purpose.</span></li>
			</ul>
			<p>We’ve raised some questions about how manual DI can go wrong. Now we have seen how Dagger can address these issues. Although it does the job, and it does it quickly when it comes to performance, it is also a complex framework with a very steep <span class="No-Break">learning curve.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor736"/>Hilt</h1>
			<p>When<a id="_idIndexMarker1175"/> we use Dagger in an Android application, there is a bit of boilerplate code we are forced to write. Some of it is around dealing with the lifecycles of objects linked with Activities and Fragments, which leads us to create subcomponents; other parts are around the usage <span class="No-Break">of ViewModels.</span></p>
			<p>An attempt to simplify Dagger for Android was made with the Dagger-Android library, but later on, a new library was developed on top of Dagger called <strong class="bold">Hilt</strong>. This library simplifies much of the Dagger usage through the usage of new annotations, which leads to more boilerplate code that can <span class="No-Break">be generated.</span></p>
			<p>To use<a id="_idIndexMarker1176"/> Hilt in a project, we will need <span class="No-Break">the following:</span></p>
			<pre class="source code">
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
<strong class="bold">apply plugin: 'kotlin-kapt'</strong>
<strong class="bold">apply plugin: 'com.google.dagger.hilt.android'</strong></pre>
			<p>Or depending on how your project uses Gradle, you might need to use <span class="No-Break">the following:</span></p>
			<pre class="source code">
plugins {
  …
  id 'kotlin-kapt'
  id 'com.google.dagger.hilt.android'
}</pre>
			<p>In both cases, you need a plugin to process annotations and a separate plugin to process Hilt in <span class="No-Break">your project.</span></p>
			<p>To add Hilt to your project you need <span class="No-Break">the following:</span></p>
			<pre class="source code">
dependencies {
  implementation "com.google.dagger:hilt-android:2.44.2"
  kapt "com.google.dagger:hilt-compiler:2.44.2"
}</pre>
			<p>The first change Hilt makes is in the <strong class="source inline">Application</strong> class. Instead of needing to invoke a particular Dagger component to be initialized, with Hilt, you can just use the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">HiltAndroidApp</strong></span><span class="No-Break"> annotation:</span></p>
			<pre class="source code">
@HiltAndroidApp
class MyApplication : Application() {
}</pre>
			<p>The preceding<a id="_idIndexMarker1177"/> snippet will let Hilt know the entry point into your application and it will start generating the <span class="No-Break">dependency graph.</span></p>
			<p>Another benefit of Hilt comes when interacting with Android components such as <strong class="source inline">Activities</strong>, <strong class="source inline">Fragments</strong>, <strong class="source inline">Views</strong>, <strong class="source inline">Services</strong>, and <strong class="source inline">BroadcastReceivers</strong>. For these we can use the <strong class="source inline">@AndroidEntryPoint</strong> annotation to inject dependencies into each of these classes, which looks like <span class="No-Break">the following:</span></p>
			<pre class="source code">
@AndroidEntryPoint
class MyActivity : AppCompatActivity() {
    @Inject
    lateinit var myObject: MyObject
}</pre>
			<p>In the above snippet, the usage of <strong class="source inline">@AndroidEntryPoint</strong> allows Hilt to inject <strong class="source inline">myObject</strong> into <strong class="source inline">MyActivity</strong>. A similar approach can be used for injecting dependencies into <strong class="source inline">ViewModels</strong>, through the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">HiltViewModel</strong></span><span class="No-Break"> annotation:</span></p>
			<pre class="source code">
@HiltViewModel
class MyViewModel @Inject constructor(private val myObject:
MyObject) : ViewModel()</pre>
			<p>In the above snippet, the <strong class="source inline">@HiltViewModel</strong> annotation allows Hilt to inject <strong class="source inline">myObject</strong> into <strong class="source inline">MyViewModel</strong>. We can also observe the <strong class="source inline">@Inject</strong> annotation, carried over from Dagger, not requiring the usage <span class="No-Break">of modules.</span></p>
			<p>When it comes to modules, Hilt continues the approach from Dagger with one minor addition: the usage of the <strong class="source inline">@InstallIn</strong> annotation. This associates the annotated module with a particular component. Hilt provides a set of prebuilt components such as <strong class="source inline">SingletonComponent</strong>, <strong class="source inline">ViewModelComponent</strong>, <strong class="source inline">ActivityComponent</strong>, <strong class="source inline">FragmentComponent</strong>, <strong class="source inline">ViewComponent</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">ServiceComponent</strong></span><span class="No-Break">.</span></p>
			<p>Each of these <a id="_idIndexMarker1178"/>components links the lifecycle of the dependencies inside the annotated module to the lifecycles of the application, <strong class="source inline">ViewModel</strong>, <strong class="source inline">Activity</strong>, <strong class="source inline">Fragment</strong>, <strong class="source inline">View</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">Service</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Module
<strong class="bold">@InstallIn(SingletonComponent::class)</strong>
class MyModule {
    @Provides
    fun provideMyObject(): MyObject = MyObject()
}</pre>
			<p>In the preceding snippet, we can see what a <strong class="source inline">@Module</strong> looks like in Hilt and how we can use the <strong class="source inline">@InstallIn</strong> annotation to specify that <strong class="source inline">MyObject</strong> lives as long as our <span class="No-Break">application lives.</span></p>
			<p>When it comes to instrumented tests, Hilt provides useful annotations for changing the dependencies for the tests. If we want to take advantage of these features, then we need the following dependencies <span class="No-Break">for tests:</span></p>
			<pre class="source code">
    androidTestImplementation 'com.google.dagger:
        hilt-android-testing:2.44.2'
    kaptAndroidTest 'com.google.dagger:
        hilt-android-compiler:2.44.2'</pre>
			<p>We can then go to our test and introduce Hilt into it <span class="No-Break">as follows:</span></p>
			<pre class="source code">
<strong class="bold">@HiltAndroidTest</strong>
class MyInstrumentedTest {
<strong class="bold">    @get:Rule</strong>
<strong class="bold">    var hiltRule = HiltAndroidRule(this)</strong>
    @Inject
    lateinit var myObject: MyObject
    @Before
    fun init() {
<strong class="bold">        hiltRule.inject()</strong>
    }
}</pre>
			<p>In the<a id="_idIndexMarker1179"/> preceding snippet, the <strong class="source inline">@HiltAndroid</strong> test and <strong class="source inline">hiltRule</strong> are used to swap the dependencies used in the application with the test dependencies. The call to inject is what allows us to inject the <strong class="source inline">MyObject</strong> dependency into the test class. To provide the test dependencies, we can write a new module in the <strong class="source inline">androidTest</strong> folder <span class="No-Break">as follows:</span></p>
			<pre class="source code">
@Module
<strong class="bold">@TestInstallIn(</strong>
<strong class="bold">    components = [SingletonComponent::class],</strong>
<strong class="bold">    replaces = [MyModule::class]</strong>
<strong class="bold">)</strong>
class MyTestModule {
    @Provides
    fun provideMyObject(): MyObject = MyTestObject()
}</pre>
			<p>Here, we are using the <strong class="source inline">@TestInstallIn</strong> annotation, which will replace the existing <strong class="source inline">MyModule</strong> from the dependency graph with <strong class="source inline">MyTestModule</strong>, which can provide a different sub-class of the dependency we want <span class="No-Break">to swap.</span></p>
			<p>For Hilt to be initialized for the instrumented tests, we will need to define a custom test runner to provide a test application from the Hilt library. The runner might look like <span class="No-Break">the following:</span></p>
			<pre class="source code">
class HiltTestRunner : AndroidJUnitRunner() {
    override fun newApplication(cl: ClassLoader?, name:
    String?, context: Context?): Application {
<strong class="bold">        return super.newApplication(cl,</strong>
<strong class="bold">        HiltTestApplication::class.java.name, context)</strong>
    }
}</pre>
			<p>This runner <a id="_idIndexMarker1180"/>will need to be registered in <strong class="source inline">build.gradle</strong> of the module running <span class="No-Break">the test:</span></p>
			<pre class="source code">
android {
    …
    defaultConfig {
        …
        testInstrumentationRunner "{app_package_name}
            .HiltTestRunner"
    }
}</pre>
			<p>In this section, we studied the Hilt library and its benefits when it comes to removing boilerplate code that was required <span class="No-Break">using Dagger.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor737"/>Exercise 13.03 – Hilt injection</h2>
			<p>Modify <em class="italic">Exercise 13.02</em>, <em class="italic">Dagger injection</em>, such that the <strong class="source inline">@Component</strong> and <strong class="source inline">@Subcomponent</strong> classes are removed and Hilt is <span class="No-Break">used instead:</span></p>
			<ol>
				<li>Add the Hilt plugin in the top-level <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
plugins {
    …
    id 'com.google.dagger.hilt.android' version
    '2.44.2' apply false
}</pre></li>
				<li>Add the <a id="_idIndexMarker1181"/>Hilt plugin <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-kapt'
    id 'com.google.dagger.hilt.android'
}</pre></li>
				<li>In the same file, replace the Dagger dependencies with Hilt dependencies and add the fragments extension library used for <span class="No-Break">generating </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
    implementation "com.google.dagger:
        hilt-android:2.44.2"
    kapt "com.google.dagger:hilt-compiler:2.44.2"
    implementation 'androidx.fragment:
        fragment-ktx:1.5.5'</pre></li>
				<li>Delete <strong class="source inline">ApplicationComponent</strong>, <strong class="source inline">MainModule</strong>, <strong class="source inline">MainScope</strong>, and <strong class="source inline">MainSubcomponent</strong> from <span class="No-Break">the project.</span></li>
				<li>Add the <strong class="source inline">@InstallIn</strong> annotation <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">ApplicationModule</strong></span><span class="No-Break">:</span><pre class="source code">
@Module
<strong class="bold">@InstallIn(SingletonComponent::class)</strong>
class ApplicationModule {
}</pre></li>
				<li>Remove all the code from inside <strong class="source inline">RandomApplication</strong> and add <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">@HiltAndroid</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">App</strong></span><span class="No-Break"> annotation:</span><pre class="source code">
@HiltAndroidApp
class RandomApplication : Application()</pre></li>
				<li>Modify <strong class="source inline">MainViewModel</strong> to add the <strong class="source inline">@HiltViewModel</strong> and <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">Inject</strong></span><span class="No-Break"> annotations:</span><pre class="source code">
@HiltViewModel
class MainViewModel @Inject constructor(private val
numberRepository: NumberRepository) :
    ViewModel() {
    …
}</pre></li>
				<li>Modify <strong class="source inline">MainActivity</strong> to instead inject <strong class="source inline">MainViewModel</strong>, remove all the component <a id="_idIndexMarker1182"/>dependencies that were deleted previously, and add the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">AndroidEntryPoint</strong></span><span class="No-Break"> annotation:</span><pre class="source code">
<strong class="bold">@AndroidEntryPoint</strong>
class MainActivity : AppCompatActivity() {
<strong class="bold">    private val mainViewModel: MainViewModel by</strong>
<strong class="bold">    viewModels()</strong>
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/k7hs7"><span class="No-Break">https://packt.link/k7hs7</span></a><span class="No-Break">.</span></p>
			<p>In the preceding snippet, we use the <strong class="source inline">viewModels</strong> method to obtain the <strong class="source inline">MainViewModel</strong> dependency. This is a mechanism built into the extension functions from <strong class="source inline">androidx.fragment:fragment-ktx:1.5.5</strong>, which will look for factories that will obtain the instance of <span class="No-Break">our </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">.</span></p>
			<p>If we run the <a id="_idIndexMarker1183"/>code, we should see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B19411_13_04.jpg" alt="Figure 13.4 – Output of exercise 13.03"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Output of exercise 13.03</p>
			<p>We can see how much we can simplify an application’s code using Hilt instead of Dagger. For example, we no longer have to deal with the <strong class="source inline">@Component</strong> and <strong class="source inline">@Subcomponent</strong> annotated classes and managing subcomponents in the application component, and also, we don’t need to manually initialize the dependency graph from the <strong class="source inline">Application</strong> class because Hilt handles this for us. These are some of the main reasons why Hilt became the most adopted l<a id="_idTextAnchor738"/><a id="_idTextAnchor739"/>ibrar<a id="_idTextAnchor740"/>y for dependency injection in <span class="No-Break">Android applications.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor741"/>Koin</h1>
			<p>Koin is a<a id="_idIndexMarker1184"/> lighter framework that is suitable for smaller apps. It requires no code generation and is built based on Kotlin’s <a id="_idIndexMarker1185"/>functional extensions. It is also a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>). You may have noticed that when using Dagger, a lot of code must be written to set up the DI. Koin’s approach to DI solves most of those issues, allowing <span class="No-Break">faster integration.</span></p>
			<p>Koin can be <a id="_idIndexMarker1186"/>added to your project by adding the following dependency to your <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
implementation "io.insert-koin:koin-core:3.2.2"</pre>
			<p>To set up Koin in your application, you need the <strong class="source inline">startKoin</strong> call with the <span class="No-Break">DSL syntax:</span></p>
			<pre class="source code">
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
<strong class="bold">        startKoin {</strong>
            androidLogger(Level.INFO)
            androidContext(this@MyApplication)
            androidFileProperties()
            modules(myModules)
<strong class="bold">        }</strong>
    }
}</pre>
			<p>Here, you can configure what your application context is (in the <strong class="source inline">androidContext</strong> method), specify property files to define Koin configurations (in <strong class="source inline">androidFileProperties</strong>), state the Logger Level for Koin, which will output in <strong class="source inline">LogCat</strong> results of Koin operations depending on the Level (in the <strong class="source inline">androidLogger</strong> method), and list the modules your application uses. A similar syntax is used to create <span class="No-Break">the modules:</span></p>
			<pre class="source code">
class ClassA
class ClassB(private val classB: ClassA)
<strong class="bold">    val moduleForClassA = module {</strong>
<strong class="bold">        single { ClassA() }</strong>
<strong class="bold">    }</strong>
<strong class="bold">    val moduleForClassB = module {</strong>
<strong class="bold">        factory { ClassB(get()) }</strong>
<strong class="bold">    }</strong>
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidLogger(Level.INFO)
            androidContext(this@MyApplication)
            androidFileProperties()
<strong class="bold">            </strong><strong class="bold">modules(listOf(moduleForClassA,</strong>
<strong class="bold">            moduleForClassB))</strong>
        }
    }</pre>
			<p>In the preceding <a id="_idIndexMarker1187"/>example, the two objects will have two different lifecycles. When a dependency is provided using<a id="_idIndexMarker1188"/> the <strong class="bold">single</strong> notation, only one instance will be used across the entire application lifecycle. This is useful for repositories, databases, and API components, where multiple instances will be costly for <span class="No-Break">the application.</span></p>
			<p>The <strong class="bold">factory</strong> notation <a id="_idIndexMarker1189"/>will create a new object every time an injection is performed. This may be useful in situations when an object needs to live as long as an activity <span class="No-Break">or fragment.</span></p>
			<p>The dependency can be injected using the <strong class="source inline">by inject()</strong> method or the <strong class="source inline">get()</strong> method, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
    class MainActivity : AppCompatActivity() {
<strong class="bold">      val classB: ClassB by inject()</strong>
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
<strong class="bold">        val classB: ClassB = get()</strong>
    }</pre>
			<p>Koin also <a id="_idIndexMarker1190"/>offers the possibility of using qualifiers with the help of the <strong class="source inline">named()</strong> method when the module is created. This allows you to provide multiple implementations of the same type (for example, providing two or more list objects with <span class="No-Break">different content):</span></p>
			<pre class="source code">
    val moduleForClassA = module {
<strong class="bold">        single(named("name")) { ClassA() }</strong>
    }</pre>
			<p>One of Koin’s main features for Android applications is scopes for activities and fragments, and can be defined as shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source code">
    val moduleForClassB = module {
<strong class="bold">        scope(named&lt;MainActivity&gt;()) {</strong>
<strong class="bold">            scoped { ClassB(get()) }</strong>
<strong class="bold">        }</strong>
    }</pre>
			<p>The preceding example connects the lifecycle of the <strong class="source inline">ClassB</strong> dependency to the lifecycle of <strong class="source inline">MainActivity</strong>. In order for you to inject your instance into your activity, you will need to extend the <strong class="source inline">ScopeActivity</strong> class. This class is responsible for holding a reference as long as the activity lives. Similar classes exist for other Android components such as Fragments (<strong class="source inline">ScopeFragment</strong>) and <span class="No-Break">services (</span><span class="No-Break"><strong class="source inline">ScopeService</strong></span><span class="No-Break">):</span></p>
			<pre class="source code">
class MainActivity : ScopeActivity() {
<strong class="bold">    val classB: ClassB by inject()</strong>
}</pre>
			<p>You can inject the instance into your activity using the <strong class="source inline">inject()</strong> method. This is useful when you wish to limit who gets to access the dependency. In the preceding example, if another activity had wanted to access the reference to <strong class="source inline">ClassB</strong>, then it wouldn’t be able to find it in <span class="No-Break">the scope.</span></p>
			<p>Another <a id="_idIndexMarker1191"/>feature that comes in handy for Android is the <strong class="source inline">ViewModel</strong> injections. To set this up, you will need to add the library <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
implementation "io.insert-koin:koin-android:3.2.2"</pre>
			<p>If you recall, <strong class="source inline">ViewModels</strong> require <strong class="source inline">ViewModelProvider.Factories</strong> in order to be instantiated. Koin automatically solves this, allowing <strong class="source inline">ViewModels</strong> to be injected directly and to handle the <span class="No-Break">factory work:</span></p>
			<pre class="source code">
    val moduleForClassB = module {
        factory {
            ClassB(get())
        }
<strong class="bold">        viewModel { MyViewModel(get()) }</strong>
    }</pre>
			<p>To inject the dependency of <strong class="source inline">ViewModel</strong> into your activity, you can use the <span class="No-Break"><strong class="source inline">viewModel()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
<strong class="bold">    val model: MyViewModel by viewModel()</strong>
}</pre>
			<p>Alternatively, you can use the <span class="No-Break">method directly:</span></p>
			<pre class="source code">
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
<strong class="bold">        val model : MyViewModel = getViewModel()</strong>
    }</pre>
			<p>As we can see in the preceding setup, Koin takes full advantage of Kotlin’s language features and reduces the amount <a id="_idTextAnchor742"/>of bo<a id="_idTextAnchor743"/>ilerplate required to define your modules and <span class="No-Break">their scopes.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor744"/>Exercise 13.04 – Koin injection</h2>
			<p>Here, we <a id="_idIndexMarker1192"/>will write an Android application that will perform DI using Koin. The application will be based on <em class="italic">Exercise 13.01</em>, <em class="italic">Manual injection</em>, by keeping <strong class="source inline">NumberRepository</strong>, <strong class="source inline">NumberRepositoryImpl</strong>, <strong class="source inline">MainViewModel</strong>, and <strong class="source inline">MainActivity</strong>. The following dependencies will <span class="No-Break">be injected:</span></p>
			<ul>
				<li><strong class="source inline">Repository</strong>: As part of a module <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">appModule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source inline">MainViewModel</strong>: This will rely on Koin’s specialized implementation for <strong class="source inline">ViewModels</strong>. This will be provided as part of a module named <strong class="source inline">mainModule</strong> and will have the <span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break"> scope.</span></li>
			</ul>
			<p>Perform the following steps to complete <span class="No-Break">the exercise:</span></p>
			<ol>
				<li>The app will display a randomly generated number each time a button is clicked. Let’s start by adding the <span class="No-Break">Koin libraries:</span><pre class="source code">
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"
    implementation "io.insert-koin:koin-android:3.2.2"
    implementation "io.insert-koin:koin-core:3.2.2"
    testImplementation 'junit:junit:4.13.2'</pre></li>
				<li>Next, define the <strong class="source inline">appModule</strong> variable inside the <strong class="source inline">RandomApplication</strong> class. This will have a similar structure to <strong class="source inline">AppModule</strong> with the <span class="No-Break">Dagger setup:</span><pre class="source code">
class RandomApplication : Application() {
    <strong class="bold">val appModule = module {</strong>
        single {
            Random()
        }
        single&lt;NumberRepository&gt; {
            NumberRepositoryImpl(get())
        }
}
}</pre></li>
				<li>Now, let’s <a id="_idIndexMarker1193"/>add the activity module variable <span class="No-Break">after </span><span class="No-Break"><strong class="source inline">appModule</strong></span><span class="No-Break">:</span><pre class="source code">
    <strong class="bold">val mainModule = module {</strong>
        scope(named&lt;MainActivity&gt;()) {
            scoped {
                MainViewModel(get())
            }
        }
    }</pre></li>
				<li>Next, let’s initialize <strong class="source inline">Koin</strong> in the <strong class="source inline">onCreate()</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">RandomApplication</strong></span><span class="No-Break">:</span><pre class="source code">
        super.onCreate()
        startKoin {
            androidLogger()
            androidContext(this@RandomApplication)
            modules(listOf(appModule, mainModule))
        }</pre></li>
				<li>Finally, let’s inject the dependencies into <span class="No-Break">the activity:</span><pre class="source code">
class MainActivity : ScopeActivity() {
    private val mainViewModel: MainViewModel by
    inject()
}</pre></li>
			</ol>
			<p>The <a id="_idIndexMarker1194"/>complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/0Njdv"><span class="No-Break">https://packt.link/0Njdv</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="6">If you run the preceding code, the app should work as per the previous examples. However, if you check <strong class="source inline">LogCat</strong>, you will see a similar output <span class="No-Break">to this:</span><pre class="source code">
[Koin]: [init] declare Android Context
[Koin]: bind type:'android.content.Context' ~ [type:Single,primary_type:'android.content.Context']
[Koin]: bind type:'android.app.Application' ~ [type:Single,primary_type:'android.app.Application']
[Koin]: bind type:'java.util.Random' ~ [type:Single,primary_type:'java.util.Random']
[Koin]: bind type:'com.android.testable.randomapplication .NumberRepository' ~ [type:Single,primary_type:'com.android .testable.randomapplication.NumberRepository']
[Koin]: total 5 registered definitions
[Koin]: load modules in 0.4638 ms</pre></li>
			</ol>
			<p>In<a id="_idTextAnchor745"/> <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.5</em>, we can see the same output as in <span class="No-Break">previous exercises:</span></p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B19411_13_05.jpg" alt="Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated number"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated number</p>
			<p>As we can see from this<a id="_idIndexMarker1195"/> exercise, Koin is much faster and easier to integrate, especially with its <strong class="source inline">ViewModel</strong> library. This comes in handy for small<a id="_idTextAnchor746"/> proje<a id="_idTextAnchor747"/>cts, but its performance will be impacted once <span class="No-Break">projects grow.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor748"/>Activity 13.01 – injected repositories</h2>
			<p>In this <a id="_idIndexMarker1196"/>activity, you are going to create an app in Android Studio that connects to a sample API, <a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>, using the Retrofit library and retrieves a list of posts from the web page, which will then be displayed on <span class="No-Break">the screen.</span></p>
			<p>You will then need to set up a UI test in which you will check whether the data is asserted correctly on the screen, but instead of connecting to the actual endpoint, you will provide dummy data for the test to display on the screen. You will use the DI concept to swap the dependencies using Hilt when the app is executed as opposed to when the app is <span class="No-Break">being tested.</span></p>
			<p>In order to achieve this, you will need to build <span class="No-Break">the following:</span></p>
			<ul>
				<li>A network component that is responsible for downloading and parsing the <span class="No-Break">JSON file</span></li>
				<li>A repository that accesses the data from the <span class="No-Break">API layer</span></li>
				<li>A <strong class="source inline">ViewModel</strong> instance that accesses <span class="No-Break">the Repository</span></li>
				<li>An activity with <strong class="source inline">RecycleView</strong> that displays <span class="No-Break">the data</span></li>
				<li>One UI test that will assert the rows and use a dummy object to generate the <span class="No-Break">API data</span></li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Error handling can be avoided for <span class="No-Break">this activity.</span></p>
			<p>Perform the <a id="_idIndexMarker1197"/>following steps to complete <span class="No-Break">this activity:</span></p>
			<ol>
				<li>In Android Studio, create an application with <strong class="source inline">Empty Activity</strong> (<strong class="source inline">MainActivity</strong>) and add an <strong class="source inline">api</strong> package where your API calls <span class="No-Break">are stored.</span></li>
				<li>Define a class responsible for the <span class="No-Break">API calls.</span></li>
				<li>Create a <span class="No-Break"><strong class="source inline">repository</strong></span><span class="No-Break"> package.</span></li>
				<li>Define a <strong class="source inline">repository</strong> interface with one method, returning <strong class="source inline">LiveData</strong> with the list <span class="No-Break">of posts.</span></li>
				<li>Create the implementation for the <span class="No-Break"><strong class="source inline">repository</strong></span><span class="No-Break"> class.</span></li>
				<li>Create a <strong class="source inline">ViewModel</strong> instance to call the <strong class="source inline">repository</strong> to retrieve <span class="No-Break">the data.</span></li>
				<li>Create an adapter for the rows of <span class="No-Break">the UI.</span></li>
				<li>Create the activity that will render <span class="No-Break">the UI.</span></li>
				<li>Set up a Hilt module that will initialize the <span class="No-Break">network-related dependencies.</span></li>
				<li>Create a Hilt module that will be responsible for defining the dependencies required for <span class="No-Break">the activity.</span></li>
				<li>Set up the UI tests and a test application and provide a separate <strong class="source inline">RepositoryModule</strong> class, which will return a dependency holding <span class="No-Break">dummy data.</span></li>
				<li>Implement <a id="_idIndexMarker1198"/>the <span class="No-Break">UI test.</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/3xfkt"><span class="No-Break">https://packt.link/3xfkt</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor749"/>Summary</h1>
			<p>In this chapter, we analyzed the concept of DI and how it should be applied to separate concerns and prevent objects from having the responsibility of creating other objects and how this is of great benefit for testing. We started the chapter by analyzing the concept of manual DI. This served as a good example of how DI works and how it can be applied to an Android application; it served as the baseline when comparing the <span class="No-Break">DI frameworks.</span></p>
			<p>We also analyzed two of the most popular frameworks that help developers inject dependencies. We started with a powerful and fast framework called Dagger 2, which relies on annotation processors to generate code to perform an injection. We then looked at how Hilt reduced the complexity of Dagger for Android applications. We also investigated Koin, a lightweight framework written in Kotlin with slower performance but simpler integration and a lot of focus on <span class="No-Break">Android components.</span></p>
			<p>The exercises in this chapter were intended to explore how the same problem can be solved using multiple solutions and compare the degrees of difficulty between the solutions. In the activities for this chapter, we leveraged Dagger’s, Hilt’s, and Koin’s modules to inject certain dependencies when running the app and other dependencies when running the tests on an application that uses <strong class="source inline">ViewModels</strong>, repositories, and APIs to <span class="No-Break">load data.</span></p>
			<p>This is designed to show the seamless integration of multiple frameworks that achieve different goals. In the chapter’s activity, we looked at how we can use Hilt to swap dependencies for testing purposes and inject dummy data that we can then assert whether it is displayed on <span class="No-Break">the screen.</span></p>
			<p>In the following chapters, you will have the opportunity to build upon the knowledge acquired thus far by adding concepts related to threading and how to handle background operations. In addition, you will get the opportunity to explore libraries such as RxJava and its reactive approach to threading, and you will also learn about coroutines, which take a different approach <span class="No-Break">to threading.</span></p>
			<p>You will also observe how coroutines and RxJava can combine very effectively with libraries such as Room and Retrofit. Finally, you will be able to combine all of these concepts in a robust application that will have a high degree of scalability for <span class="No-Break">the future.</span></p>
		</div>
	

		<div id="_idContainer209" class="Content">
			<h1 id="_idParaDest-230"><a id="_idTextAnchor750"/>Part 4: Polishing and Publishing an App</h1>
			<p>In this part, we will look at how we can load data asynchronously with coroutines and flows and how we can integrate them into different architecture patterns, which further helps with how we can structure an <span class="No-Break">application’s code.</span></p>
			<p>Next, we will look at how we can render animations in the user interface with <strong class="source inline">CoordinatorLayout</strong> and <strong class="source inline">MotionLayout</strong>. Finally, we will learn about the process involved in publishing an application on <span class="No-Break">Google Play.</span></p>
			<p>We will cover the following chapters in <span class="No-Break">this section:</span></p>
			<ul>
				<li><a href="B19411_14.xhtml#_idTextAnchor751"><em class="italic">Chapter 14</em></a>, <em class="italic">Coroutines and Flow</em></li>
				<li><a href="B19411_15.xhtml#_idTextAnchor789"><em class="italic">Chapter 15</em></a>, <em class="italic">Architecture Patterns</em></li>
				<li><a href="B19411_16.xhtml#_idTextAnchor826"><em class="italic">Chapter 16</em></a>, <em class="italic">Animations and Transitions with CoordinatorLayout and MotionLayout</em></li>
				<li><a href="B19411_17.xhtml#_idTextAnchor918"><em class="italic">Chapter 17</em></a>, <em class="italic">Launching Your App on Google Play</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer210">
			</div>
		</div>
	</body></html>