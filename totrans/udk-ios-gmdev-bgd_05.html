<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Action Sequences for Urban Warrior</h1></div></div></div><div><blockquote class="blockquote"><p>In the previous chapter, we built up a basic understanding of the lovely tools of Kismet and Matinee and how they can work together in some simple examples. But now that we know the basics can't we do more? Oh yes, we certainly can.</p><p>In this chapter we are going to create a series of sequences and prefabs to set the groundwork, allowing us to easily create our level in the next chapter.</p></blockquote></div><p>In this chapter we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discuss what sequences are and how we use them</li><li class="listitem" style="list-style-type: disc">Spawn an enemy into our level</li><li class="listitem" style="list-style-type: disc">Develop a rudimentary AI system that will shoot at us if we are close</li><li class="listitem" style="list-style-type: disc">Expand upon that system by adding chasing and retreating behavior</li><li class="listitem" style="list-style-type: disc">Import/export subsequences to create additional enemies easily</li><li class="listitem" style="list-style-type: disc">Implement regenerating health using remote events</li><li class="listitem" style="list-style-type: disc">Discuss prefabs and their use in our project</li><li class="listitem" style="list-style-type: disc">Make a door prefab</li><li class="listitem" style="list-style-type: disc">Discuss workflow and things to consider when creating combat scenarios</li></ul></div><p>So with that, let's take a look at what we can do with sequences.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Sequences and you</h1></div></div></div><p>Sequences are UDK's ways of helping you organize your code as well as compartmentalize all of the actions that you want to have happen in a certain area. Events and their associated actions, that you will be re-using, are also prime candidates for being placed inside sequences.<a class="indexterm" id="id296"/>
</p><p>Anyone who works with Kismet has worked with sequences before. You have already been using sequences without even knowing it. UDK provides us with a<strong> LevelName</strong> sequence within the Kismet editor that we have used in the previous chapter.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Life, or something like it</h2></div></div></div><p>Now that we have an idea of what sequences are, let's create one of our own! It will enable us to bring the characters to life, such as enemies, explained in this section.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Time for action—spawning AI into our level</h1></div></div></div><p>As we are creating the building blocks of our game, creating a third person shooter is kind of hard to do without having enemies to fight. Thankfully UDK has helped us out and made it incredibly easy to add enemies into our level!<a class="indexterm" id="id297"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Go into to the<strong> Actor Classes</strong> browser<strong> View</strong> |<strong> Browser Windows</strong> |<strong> Actor Classes</strong>. From there you will see a list of classes that we can place within our level. Type<code class="literal"> Path</code> in the<strong> Search</strong> bar and left-click on the<strong> PathNode</strong> selection. The following screenshot explains this:<div><img alt="Time for action—spawning AI into our level" height="96" src="img/image_1901_05_01.jpg"/></div></li><li class="listitem">Close the<strong> Actor Classes</strong> browser and right-click anywhere in your level. From the menu that pops up select<strong> Add PathNode Here</strong>. This will create an actor on the ground on the spot where you clicked. I have placed my<strong> PathNode</strong> away from the player but still visible from the camera for our opening sequence.</li><li class="listitem">Open the Kismet editor by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar.</li><li class="listitem">Left click-and-drag the background of the workspace to move the graph plane, bringing some open space for us to work with.</li><li class="listitem">Right-click somewhere in the background and select<strong> Create New Sequence: 0 Objs</strong>. A pop-up window should come up asking you for the name of the sequence. Type<code class="literal"> EnemyAI</code> and press<em> Enter</em>. A little box with the name should be created at the position where you right-clicked.</li><li class="listitem">Double-click on the<strong> EnemyAI</strong> sequence. You will notice that we have now moved into this sequence and there is nothing there, and that our Sequences pane on the bottom at right-hand side has the<strong> EnemyAI</strong> sequence highlighted. This is shown in the following screenshot:<a class="indexterm" id="id298"/><div><img alt="Time for action—spawning AI into our level" src="img/image_1901_05_02.jpg" width="230"/></div></li><li class="listitem">Right-click and create a<strong> Sequence Activated</strong> event by choosing<strong> New Event</strong> |<strong> Sequence Activated</strong> from the menu.</li><li class="listitem">Create an<strong> Actor Factory</strong> action by right-clicking and choosing<strong> New Action</strong> |<strong> Actor</strong> |<strong> Actor Factory</strong> from the menu. Go into the Properties pane and click on the blue triangle on the right-hand side of the<strong> Factory</strong> variable and select<strong> UTActorFactoryAI</strong> from the pop-up menu that comes out to create a new<strong> Actor Factory</strong> to use. Inside our new factory's properties set the<strong> Pawn Class</strong> to<strong> UTPawn</strong> and check the<strong> Give Default Inventory</strong> option. Finally, change the<strong> Team Index</strong> to <strong>1</strong>.</li><li class="listitem">Underneath the<strong> Spawn Point</strong> variable create an external object variable by right-clicking and selecting<strong> New Variable</strong> |<strong> External Variable</strong> from the menu. Left-click on the variable and in its properties set<strong> Expected Type</strong> to<strong> SeqVar_Object</strong> and<strong> Variable Label</strong> to<strong> Spawn Point</strong>.</li><li class="listitem">Create a<strong> Finish Sequence</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Misc</strong> |<strong> Finish Sequence</strong>. Under the<strong> Output Label</strong> property type<code class="literal"> Spawned</code>.</li><li class="listitem">Connect the<strong> Out</strong> of the<strong> Sequence Activated "In"</strong> event to the<strong> Spawn Actor</strong> input of the Actor Factory action. Connect the<strong> Spawn Point</strong> link to the<strong> External Object</strong> variable we created. Finally, connect the<strong> Finished</strong> output of the<strong> Actor Factory</strong> to the<strong> Finish Sequence "Spawned"</strong> action. At this point our sequence should look as shown in the following screenshot:<a class="indexterm" id="id299"/><div><img alt="Time for action—spawning AI into our level" height="149" src="img/image_1901_05_03.jpg"/></div></li><li class="listitem">On the bottom right-hand side of our Kismet editor click on the<strong> LevelName</strong> sequence to return to the main level sequence. We should now see the sequence look similar to a Kismet node with inputs, outputs, and variable chains, as shown in the following screenshot:<div><img alt="Time for action—spawning AI into our level" src="img/image_1901_05_04.jpg" width="84"/></div></li><li class="listitem">Right-click and create a<strong> Level Loaded</strong> event by choosing<strong> New Event</strong> |<strong> Level Loaded</strong> from the menu.</li><li class="listitem">Go into our level and left-click on the PathNode that you created earlier and go back into Kismet. Right-click on our Spawn Point link and select<strong> Create New Variable from PathNode_0</strong>. This is shown in the following screenshot:<a class="indexterm" id="id300"/><div><img alt="Time for action—spawning AI into our level" src="img/image_1901_05_05.jpg" width="161"/></div></li><li class="listitem">Build our game by selecting<strong> Build</strong> |<strong> Build All</strong> and pressing Close when finished.</li><li class="listitem">Save your project. Now start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar as shown in following screenshot:<div><img alt="Time for action—spawning AI into our level" src="img/image_1901_05_06.jpg" width="258"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec02"/>What just happened?</h2></div></div></div><p>Upon the level being loaded (via the<strong> Level Loaded</strong> event) we call our<strong> EnemyAI</strong> sequence which spawns an enemy (via an<strong> Actor Factory</strong>) and places him in the level where our<strong> PathNode</strong> is. Putting these events and actions into a sequence will enable us to put code relevant to our AI in one place making it as simple as possible to create new AIs in our future levels.<a class="indexterm" id="id301"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec03"/>It lives! but...</h2></div></div></div><p>As you can now tell, our actor is in the level, but it isn't really doing anything. That is because it lacks<strong> artificial intelligence</strong> (<strong>AI</strong>). Surely we could force the actor to use the<strong> Deathmatch</strong> AI that is included in UDK, but if we had more than one AI they would fight each other. One thing that experienced UDK developers may come to realize is that you lose a lot of functionality when making a game for iOS. For example, if we were creating the game on PC I could just use the<code class="literal"> UTTeamGame</code> type which would take care of not attacking actors other than the player, but that functionality is broken if you were to use the iOS build. Fear not dear reader; I do have a solution and you'll learn about sequences and some advanced Kismet in the process!<a class="indexterm" id="id302"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Time for action—base enemy AI</h1></div></div></div><p>Now we will be creating a rudimentary AI using Kismet and using our sequence we will be able to attach this behavior to every AI that we use.<a class="indexterm" id="id303"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Open the Kismet editor by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar.</li><li class="listitem">Enter the<strong> EnemyAI</strong> sequence by either double-clicking on the sequence in the<strong> Graph</strong> pane or clicking on the<strong> EnemyAI</strong> text in the<strong> Sequences</strong> pane.</li><li class="listitem">Underneath the<strong> Spawned</strong> variable inside the<strong> Actor Factory</strong> create an external object variable by right-clicking and selecting<strong> New Variable</strong> |<strong> External Variable</strong> from the menu. Left-click on the variable and inside of its properties set<strong> Expected Type</strong> to<strong> SeqVar_Object</strong> and<strong> Variable Label</strong> to<strong> Spawned</strong>.</li><li class="listitem">Create an<strong> Is Alive</strong> conditional by right-clicking and selecting<strong> New Condition</strong> |<strong> Is Alive?</strong> Connect the<strong> Spawned</strong> variable link to the<strong> Players</strong> link underneath the conditional.</li><li class="listitem">Create a<strong> Finish Sequence</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Misc</strong> |<strong> Finish Sequence</strong>. Under the<strong> Output Label</strong> property type<code class="literal"> Dead</code>. Connect the<strong> False</strong> output of the<strong> Is Alive</strong> conditional to the<strong> In</strong> of the<strong> Finish</strong> sequence.</li><li class="listitem">Create a<strong> Trace</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Misc</strong> |<strong> Trace</strong>. Connect the<strong> True</strong> output of the<strong> Is Alive</strong> conditional to the In of the<strong> Trace</strong>. Connect the<strong> Start</strong> variable link on the bottom of the trace equal to the<strong> Spawned</strong> variable used previously. Set the<strong> End</strong> variable link to a<strong> Player 0</strong> variable (<strong>New Variable</strong> |<strong> Player</strong> |<strong> Player</strong> with<strong> All Players</strong> unchecked). Right-click under the<strong> Distance</strong> variable link and create a new Float variable. This is shown in the following screenshot:<div><img alt="Time for action—base enemy AI" height="197" src="img/image_1901_05_07.jpg"/></div></li><li class="listitem">Create a<strong> Compare Float</strong> conditional by right-clicking and selecting<strong> New Condition</strong> |<strong> Comparison</strong> |<strong> Compare Float</strong>. Underneath the<strong> A</strong> variable link connect the variable under Distance in our trace. Underneath<strong> B</strong> create a new Float variable and enter a value of<code class="literal"> 600.</code><a class="indexterm" id="id304"/></li><li class="listitem">Create a<strong> Start Firing At</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> AI</strong> |<strong> Start Firing At</strong>. Set the<strong> Target</strong> variable to the Spawned object variable and the<strong> Fire At</strong> link to a<strong> Player 0</strong> object. Connect the<strong> A &lt; B</strong> of the<strong> Compare Float</strong> conditional to the<strong> In</strong> of the<strong> Start Firing At</strong> action.</li><li class="listitem">Create a<strong> Stop Firing</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> AI</strong> |<strong> Stop Firing</strong>. Set the<strong> Target</strong> variable to the Spawned object variable. Connect the<strong> A &gt;= B</strong> of the<strong> Compare Float</strong> conditional to the In of the<strong> Start Firing At</strong> action. We will see the output as shown in the following screenshot:<div><img alt="Time for action—base enemy AI" height="226" src="img/image_1901_05_08.jpg"/></div><p>Now, if our enemy is alive, we will perform a trace on the screen which will create a line between the actor and the player and will see whether there is anything between them that would break <strong>line-of-sight</strong> (<strong>LOS</strong>). If the AI can see the player and he's within a certain distance of the player, he will start fi ring at him. If something is in the way he will stop. Of course, right now this is only called once. So aft er it happens once it won't be called again. What if the player runs away from the fight? We want to have the enemy chase aft er the player.</p></li><li class="listitem">Create a<strong> Compare Bool</strong> conditional by right-clicking and selecting<strong> New Condition</strong> |<strong> Comparison</strong> |<strong> Compare Bool</strong>. Underneath the Bool variable link create a<strong> Bool</strong> variable with a<strong> False</strong> value.</li><li class="listitem">Create a<strong> Move To Actor</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> AI</strong> |<strong> Move To Actor</strong>. Underneath the<strong> Target</strong> variable link connect the Spawned object. Under<strong> Destination</strong> create a Player variable and connect it. Connect the<strong> True</strong> output from the<strong> Compare Bool</strong> conditional to the In input on the<strong> Move To Actor</strong> action.</li><li class="listitem">Create a<strong> Toggle</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Toggle</strong> |<strong> Toggle</strong>. Underneath the<strong> Bool</strong> variable link connect the<strong> Bool</strong> variable we created earlier with<code class="literal"> False</code> as the value. Connect the Out output of the<strong> Start Firing At</strong> action to the<strong> Turn On</strong> input of this<strong> Toggle</strong> action.</li><li class="listitem">Create a<strong> Delay</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Misc</strong> |<strong> Delay</strong>. In the<strong> Properties</strong> pane change the<strong> Duration</strong> to<code class="literal"> 0.20</code>. Connect the<strong> Out</strong> from the<strong> Toggle</strong> and<strong> Move to Actor</strong> actions as well as the<strong> False</strong> output from the Compare Bool conditional to the<strong> Start</strong> input of our<strong> Delay</strong>. Connect the<strong> Finished</strong> output of our<strong> Delay</strong> action to the<strong> In</strong> of the<strong> Is Alive</strong> conditional we created at the beginning of this section.</li><li class="listitem">Build our game by selecting<strong> Build</strong> |<strong> Build All</strong> and pressing<strong> Close</strong> when finished.<a class="indexterm" id="id305"/></li><li class="listitem">Save your project and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar as shown in the following screenshot:<div><img alt="Time for action—base enemy AI" src="img/image_1901_05_09.jpg" width="264"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec04"/>What just happened?</h2></div></div></div><p>Our enemy now responds to what we do in the world! If we come within a distance of<code class="literal"> 600</code> or closer to the enemy, and it has a clear line-of-sight, it will start firing at us. If the player runs a certain distance away or goes behind some cover, it will attempt to travel to us. However there is still a lot of work to do.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec05"/>Improvements to be made</h2></div></div></div><p>Instead of running to the player's position, the enemy we spawned goes towards the spawn point, or rather the place where the character was initially created, rather than where they currently are. It will continue to follow delete us, until it can fire at us again as well. Shouldn't it give up after a while? If we start attacking the enemy at a distance, the player will not react and will just take hits as well. With this basis, we can now extend our AI to be much more robust.<a class="indexterm" id="id306"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Time for action—base enemy AI</h1></div></div></div><p>Now we will be creating a rudimentary AI using Kismet and using our sequence we will be able to attach this behavior to every AI that we use.</p><div><ol class="orderedlist arabic"><li class="listitem">Go into the<strong> Actor Classes</strong> browser<strong> View</strong> |<strong> Browser Windows</strong> |<strong> Actor Classes</strong>. From there, you will see a list of classes that we can place within our level. Type<code class="literal"> Path</code> in the<strong> Search</strong> bar and left-click on the<strong> PathNode_Dynamic</strong> selection. The following screenshot shows this:<div><img alt="Time for action—base enemy AI" height="112" src="img/image_1901_05_10.jpg"/></div></li><li class="listitem">Close the<strong> Actor Classes</strong> browser and right-click anywhere in your level. From the menu that pops up, select<strong> Add PathNode_Dynamic Here</strong>. This will create an actor on the ground in the spot where you clicked. Place it nearby the player's spawn point.</li><li class="listitem">Open the Kismet editor by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar.</li><li class="listitem">Enter the<strong> EnemyAI</strong> sequence by either double-clicking on the sequence in the<strong> Graph</strong> pane or clicking on the<strong> EnemyAI</strong> text in the<strong> Sequences</strong> pane.</li><li class="listitem">Delete the connections to the<strong> Start</strong> input on the<strong> Delay</strong> action by holding<em> Alt</em> and clicking on the black square. Left-click on the<strong> Delay</strong> action, hold<em> Shift</em> and drag it to the right-hand side to give some room for our new additions.</li><li class="listitem">Select the<strong> Move to Actor</strong> action and its attached variables by holding down<em> Ctrl</em> +<em> Alt</em> and left-clicking slightly above and to the left-hand side of the<strong> Move to Actor</strong> action, and drag until the box you create covers all of the items we want to move. Alternatively, hold<em> Ctrl</em> and click on each item. Move the objects to beside the<strong> Delay</strong> position. Delete the connection from the<strong> In</strong> of the<strong> Move To Actor</strong> action and connect the<strong> Out</strong> from the<strong> Move To Actor</strong> action to the<strong> Start</strong> of the<strong> Delay</strong> action. Connect the<strong> Out</strong> of our<strong> Toggle</strong> action to the<strong> Start</strong> of the<strong> Delay</strong> action.<a class="indexterm" id="id307"/></li><li class="listitem">Create a<strong> Compare Float</strong> conditional next to our<strong> Compare Bool</strong> action by right-clicking and selecting<strong> New Condition</strong> |<strong> Conditional</strong> |<strong> Compare Float</strong>. Connect the<strong> True</strong> of the<strong> Compare Bool</strong> conditional to the<strong> In</strong> input of this<strong> Compare Float</strong>. Connect the<strong> False</strong> output of the<strong> Compare Bool</strong> to the<strong> Start</strong> input on the<strong> Delay</strong> action. Create a float variable in both the<strong> A</strong> and<strong> B</strong> section of our<strong> Compare Float</strong> action. Inside the<strong> A</strong> float variable, create a comment saying<strong> timeSinceCaught</strong> with a value of<code class="literal"> 0.0</code>. Set the<strong> B</strong> variable to have a value of<code class="literal"> 2.0</code>. What I'm trying to accomplish in this section, is making it so that if the AI chases after the player and a certain time passes, he will give up and stop where he is.</li><li class="listitem">Create an<strong> Add Float</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Math</strong> |<strong> Add Float</strong>. Connect the<strong> A</strong> and<strong> Float Result</strong> variables of<strong> Add Float</strong> action to the float variable that we placed a comment saying<strong> timeSinceCaught</strong>, which is connected to the<strong> A</strong> link on our<strong> Compare Float</strong>. Connect the<strong> A &lt; B</strong> output of our<strong> Compare Float</strong> to the<strong> In</strong> of our<strong> Add Float</strong> action. Create a float variable below<strong> B</strong> with a value of<code class="literal"> 0.2</code>. The following screenshot shows this:<div><img alt="Time for action—base enemy AI" height="194" src="img/image_1901_05_11.jpg"/></div><p>As this acti on is called every 0.2 seconds (due to our delay), we add 0.2 to our counter if it has been less than 2 seconds since we started chasing the player after seeing them for the fi rst ti me. What do we do if we have waited 2 seconds or more? That's what we're going to do next.</p></li><li class="listitem">Below the<strong> Add Float</strong> action we just created add a<strong> Set Float</strong> action by using<strong> New Action</strong> |<strong> Set Variable</strong> |<strong> Float</strong>. Create a new float with a value of<code class="literal"> 0.0</code> for the<strong> Value</strong> link and connect the<strong> Target</strong> variable to the<strong> timeSinceCaught</strong> float variable. Connect the<strong> A &gt;= B</strong> output from the<strong> Compare Float</strong> conditional to the<strong> In</strong> of our<strong> Set Float</strong> action.</li><li class="listitem">Create a<strong> Toggle</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Toggle</strong> |<strong> Toggle</strong>. Underneath the<strong> Bool</strong> variable link connect the<strong> Bool</strong> variable we created earlier with<strong> False</strong> value. Connect the<strong> Out</strong> output of the<strong> Set Float</strong> action to the<strong> Turn Off</strong> input of this<strong> Toggle</strong> action.</li><li class="listitem">Create a<strong> Modify Property</strong> action by using<strong> New Action</strong> |<strong> Object Property</strong> |<strong> Modify Property</strong>. Go to the<strong> Properties</strong> pane and left-click on the green<strong> +</strong> sign beside the<strong> Properties</strong> variable, to create a new property to change. Click on the black triangle on the left-hand side to expand the options. Inside the<strong> Property Name</strong> property type<code class="literal"> bLockLocation</code>. Click on the checkbox for<strong> Modify Property</strong>. Finally, in the<strong> Property Value</strong> section type<code class="literal"> 1</code>. This is shown in the following screenshot:<div><img alt="Time for action—base enemy AI" height="105" src="img/image_1901_05_12.jpg"/></div><p>The <strong>bLockLocati</strong> on variable is a <strong>Bool</strong> contained within our <strong>Actor</strong> class that will prevent an actor from being moved. With a value other than 0, a <strong>Bool</strong> will treat the value to mean true which will freeze our AI unti l we set the value back to 0. Note that UDK will give us a warning about using the <strong>Modify Property</strong> acti on, but as we are not going to be using UnrealScript for our project it will be fine.</p></li><li class="listitem">Connect the<strong> Out</strong> from the<strong> Toggle</strong> action to the<strong> In</strong> of our<strong> Modify Property</strong> action. Connect the<strong> Target</strong> to the<strong> Spawned</strong> external variable. Connect the<strong> Out</strong> output of the<strong> Modify Property</strong> action to the<strong> Start</strong> on our<strong> Delay</strong> action on the far right-hand side.</li><li class="listitem">Next to the<strong> Add Float</strong> that we created in step 8 create a<strong> Modify Property</strong> action by using<strong> New Action</strong> |<strong> Object Property</strong> |<strong> Modify Property</strong>. Go to the<strong> Properties</strong> pane and left-click on the green<strong> +</strong> sign beside the<strong> Properties</strong> variable to create a new property to change. Click on the black triangle on the left-hand side to expand the options. Inside the<strong> Property Name</strong> property type<code class="literal"> bLockLocation</code>. Click on the checkbox for<strong> Modify Property</strong>. Finally, in the<strong> Property Value</strong> section type<code class="literal"> 0</code>. Connect the<strong> Out</strong> output of the<strong> Add Float</strong> action to the<strong> In</strong> of our new<strong> Modify Property</strong> action.</li><li class="listitem">Go back into the editor and confirm that you have the<strong> PathNode_Dynamic_0</strong> selected.</li><li class="listitem">Back in Kismet create a<strong> Get Location and Rotation</strong> action<strong> New Action</strong> |<strong> Actor</strong> |<strong> Get Location and Rotation</strong>. Set the<strong> Target</strong> variable to<strong> Player 0</strong> by creating a player object variable. Right-click under the<strong> Location</strong> link and select<strong> Create New Vector Variable</strong>.</li><li class="listitem">Delete the<strong> Player</strong> variable under the<strong> Move to Actor</strong> action and right-click under the<strong> Destination</strong> variable and select<strong> New Object Var using PathNode_Dynamic_0</strong>. Create a<strong> Set Actor Location</strong> action<strong> New Action</strong> |<strong> Actor</strong> |<strong> Set Actor Location</strong>. Connect the<strong> Location</strong> variable link to the location that we created in the previous step. Connect the<strong> Target</strong> of the<strong> Set Actor Location</strong> action to the<strong> Destination</strong> variable link on the<strong> Move to Actor</strong>.</li><li class="listitem">Above our<strong> Trace</strong> action create a<strong> Take Damage</strong> event by right-clicking and selecting<strong> New Event</strong> |<strong> Actor</strong> |<strong> Take Damage</strong>. In the<strong> Properties</strong> pane set<strong> Max Trigger Count</strong> to<code class="literal"> 0</code>. Connect the<strong> Instigator</strong> to the<strong> Spawned</strong> object. Connect the<strong> Out</strong> output to the<strong> In</strong> input of the<strong> Start Firing At</strong> action.<a class="indexterm" id="id308"/><p>This will make it so that if the player decides to att ack someone from far away, that the enemy will react in some way by chasing aft er the player. Finally we will see something similar to the following screenshot:</p><div><img alt="Time for action—base enemy AI" height="119" src="img/image_1901_05_13.jpg"/></div></li><li class="listitem">Back in the editor window, click on the<strong> Door</strong> we created in the previous chapter. Open its properties by pressing<em> F4</em> and type<code class="literal"> path</code> in the search box. You will see a box checked for the value<strong> Path Colliding</strong>. Uncheck it. Unchecking the<strong> Path Colliding</strong> value lets the editor know that it is possible for AI to pass through the door, as it will treat the area as being open even though we have a door there. If you intend to not allow enemies to use doors then you'd want to make sure this is checked.</li><li class="listitem">Build our game by selecting<strong> Build</strong> |<strong> Build All</strong> and pressing<strong> Close</strong> when finished.</li><li class="listitem">Save your project and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar as shown in following screenshot:<div><img alt="Time for action—base enemy AI" src="img/image_1901_05_14.jpg" width="299"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec06"/>What just happened?</h2></div></div></div><p>We breathed much more life into the routines of our AIs; they are now reacting to us in a much more believable way, and are good enough for what we are doing in our project. Now the enemies will chase to where you are for a period of time, giving up after a while, and if you attack them from anywhere, they will react to you. We've also been exposed to much more advanced Kismet scripting, showing us how we can manipulate the game environment based on events happening in the world.<a class="indexterm" id="id309"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec07"/>Have a go hero—taking your AI further</h2></div></div></div><p>There are plenty of other things that you can add to your AI, such as different states depending on how close the player is to them (distance of the<strong> Trace</strong> action was discussed in the<em> Base enemy AI</em> section). Right now as long as the<strong> timeSinceCaught</strong> variable is less than 2.0, the<code class="literal"> PathNode_Dynamic</code> is set to your actual position as well. You could make it so that the AI could only know where you were at that point (only setting the position once). You can use the<strong> Bool</strong> (true/false statement) the variable red in color as a way of checking whether it was already set or not.</p><p>Another thing that you can do is use a<strong> Timer</strong> (<strong>Action</strong> |<strong> Misc</strong> |<strong> Timer</strong>) rather than using float comparisons and addition, toggling a timer on and off as necessary to add one other tool to your toolbox.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec08"/>Exporting subsequences</h2></div></div></div><p>After setting up a useful subsequence such as our<strong> EnemyAI</strong> event that we created, we may want to share it between other levels. One way to do this is just copy/pasting; but what if we want to share our sequence with other developers/designers or on different computers? One of the neat things that we can do with sequences is export them so that we can place them inside our levels much in the same way that we place meshes or<strong> Actor Classes</strong>. One thing to note though is that when a sequence is imported it will remove all references to objects within the level that was created, so for that reason having external variables for items is vital to make sure that the sequence performs the way we'd like it to.<a class="indexterm" id="id310"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Time for action—creating a second enemy</h1></div></div></div><p>At this point, it's a good idea to save our<strong> EnemyAI</strong> subsequence as we are going to use it inside our final level. As this is the first time we've exported something to the content editor, I'm going to be very thorough.</p><div><ol class="orderedlist arabic"><li class="listitem">Go into to the<strong> Actor Classes</strong> browser<strong> View</strong> |<strong> Browser Windows</strong> |<strong> Actor Classes</strong>. From there you will see a list of classes that we can place within our level. Type<code class="literal"> Path</code> in the<strong> Search</strong> bar and left-click on the<strong> PathNode</strong> selection.</li><li class="listitem">Close the<strong> Actor Classes</strong> browser and right-click in front of the door we created in the previous chapter. From the menu that pops up, select<strong> Add PathNode Here</strong>. Select the<strong> PathNode</strong>, hold<strong> Option</strong> and drag the object behind the door, creating a copy.</li><li class="listitem">Open the Kismet editor by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar.</li><li class="listitem">Right-click on our<strong> EnemyAI</strong> subsequence and select<strong> Export Sequence to Package</strong>. This is shown in the following screenshot:<div><img alt="Time for action—creating a second enemy" height="206" src="img/image_1901_05_15.jpg"/></div></li><li class="listitem">A prompt will come up asking for the package, group, and name of your object. Under<strong> Package</strong> put<code class="literal"> UrbanWarrior</code>, in<strong> Group</strong> put<code class="literal"> Sequences</code>, and under<strong> Name</strong> put<code class="literal"> EnemyAI</code>.</li><li class="listitem">Open up the<strong> Content Browser</strong>, and in the<strong> Search</strong> bar underneath<strong> Packages</strong> type<code class="literal"> urban</code>. You should see your package come up on top with your sequence being the first item selected.<a class="indexterm" id="id311"/></li><li class="listitem">Right-click on the package (it should have a<strong> *</strong> next to it) and click on<strong> Save</strong>. This is shown in the following screenshot:<div><img alt="Time for action—creating a second enemy" height="113" src="img/image_1901_05_16.jpg"/></div></li><li class="listitem">Left-click on the<strong> EnemyAI</strong> sequence and open up the Kismet editor. Move to the left-hand side of our<strong> EnemyAI</strong> sequence, right-click and select<strong> Import EnemyAI Sequence</strong>.<a class="indexterm" id="id312"/><p>You may not see anything change, but there is a good reason for that.</p></li><li class="listitem">Left-click on the<strong> EnemyAI</strong> subsequence and move it by holding<em> Alt</em> and dragging it to the left-hand side. You will notice that the new subsequence that we imported has the same position as when we exported it.<a class="indexterm" id="id313"/></li><li class="listitem">Left-click on the<strong> PathNode</strong> behind where the player is and go back into Kismet. Underneath the<strong> Spawn Point</strong>, right-click and select<strong> New Object Var using PathNode_2 Here</strong>. Create a new<strong> Object</strong> variable for the<strong> Spawned</strong> variable link. Connect the<strong> Dead</strong> output from the first<strong> EnemyAI</strong> sequence up to the<strong> In</strong> input of this<strong> EnemyAI</strong>.</li><li class="listitem">Create a<strong> Move To Actor</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> AI</strong> |<strong> Move To Actor</strong>. Underneath the<strong> Target</strong> variable link connect the<strong> Spawned</strong> object. Under<strong> Destination</strong> connect it to the<strong> PathNode</strong> in front of the door. Connect the<strong> Spawned</strong> output from the<strong> EnemyAI</strong> subsequence to the<strong> In</strong> input on the<strong> Move To Actor</strong> action. We will see the output as shown in the following screenshot:<div><img alt="Time for action—creating a second enemy" height="116" src="img/image_1901_05_17.jpg"/></div></li><li class="listitem">Build our game by selecting<strong> Build</strong> |<strong> Build All</strong> and pressing<strong> Close</strong> when finished.</li><li class="listitem">Save your project and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar, as shown in the following screenshot:<a class="indexterm" id="id314"/><div><img alt="Time for action—creating a second enemy" src="img/image_1901_05_18.jpg" width="299"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec09"/>What just happened?</h2></div></div></div><p>The world is becoming more and more dynamic. By using an imported subsequence we made it so that if our first enemy died, a second enemy would spawn and rush through the door to see what was going on.<a class="indexterm" id="id315"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec10"/>Remote events</h2></div></div></div><p>As seen in the previous sequence that we created, Kismet can often get quite complex and over time may become quite jumbled up. One possible solution to stop stay connections going all over the place is to use<strong> Remote Events</strong>. Similarly to our<strong> Level Loaded</strong> or<strong> Player Spawned</strong> events, whenever we activate a remote event through the<strong> Activate Remote Event</strong> Kismet action the actions and conditionals connected to it are called.<a class="indexterm" id="id316"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>When we can use a remote event</h3></div></div></div><p>Remote events sound quite amazing, but they can't always be used. Each remote event needs to have a specific name and UDK will get confused if you have multiple versions of the same remote event. This is also why we cannot have variables with the same name. If you are planning on re-using the same sequence for multiple objects, you cannot use them.<a class="indexterm" id="id317"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Creating a remote event</h3></div></div></div><p>To create a<strong> Remote Event</strong> you right-click inside the<strong> Graph</strong> pane in Kismet and select<strong> New Event</strong> |<strong> Remote Event</strong>. After creating the event, go into its<strong> Properties</strong> and under the<strong> Event Name</strong> variable type a unique identifier. When you want the actions associated with the Remote Event to be called you just need to create an<strong> Activate Remote Event</strong> action<strong> New Action</strong> |<strong> Event</strong> |<strong> Activate Remote Event</strong> and in the<strong> Properties</strong> pane find the variable<strong> Event Name</strong> and set it to that same identifier. This is shown in the following screenshot:<a class="indexterm" id="id318"/>
</p><div><img alt="Creating a remote event" height="103" src="img/image_1901_05_19.jpg"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec11"/>Named variables</h2></div></div></div><p>In programming there is such a thing as global variables.<strong> Global variables</strong> are things that you wish to have at all times within the game; for example, a player's gold or the number of enemies currently spawned. This can be very useful if it's a piece of data that you use quite often.<strong> Named variables</strong> are basically Kismet's version of global variables; however, they are only global in terms of the level currently loaded.<a class="indexterm" id="id319"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec03"/>When we can use a named variable</h3></div></div></div><p>A<strong> named variable</strong>, just like a remote event, needs to have unique names which is why we used a comment instead of a variable name for our<strong> timeSinceCaught</strong> variable in our<strong> EnemyAI</strong> sequence. The nice thing about having variables with names is that instead of creating links to the one variable every single time, like we did with the<strong> Spawned</strong> external variable in our<strong> EnemyAI</strong> sequence, we can just create new named variables to hook it up to make our script much more organized.<a class="indexterm" id="id320"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec04"/>Creating a named variable</h3></div></div></div><p>To create a named variable you right-click inside the<strong> Graph</strong> pane in Kismet and select<strong> New Variable</strong> |<strong> Named Variable.</strong> After creating the variable and going into its properties you can set the expected type to what it is and under the<strong> Find Var Name</strong> property just fill in the variable name.<a class="indexterm" id="id321"/>
</p><p>If everything goes correctly, you'll see a green checkmark in its position as shown in the following screenshot:</p><div><img alt="Creating a named variable" src="img/image_1901_05_20.jpg" width="107"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec12"/>Manipulating the player</h2></div></div></div><p>We have worked in such a way to create actions that work with the AIs we are going to place within the world, but there is one thing in the game that is more important that we haven't worked on yet at all: the player! Adding new types of gameplay or new mechanics are often tested out in Kismet before writing in UnrealScript, making it a lot easier to iterate. Make sure that the mechanics are? fun and interesting. Now that we have someone to shoot at us and some smarts, let's add a new mechanics to our player.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Time for action—regenerating player health over time</h1></div></div></div><p>Made popular in<em> Halo</em> and seen in hit games such as<em> Gears of War</em> and<em> Batman: Arkham City</em>, regenerating health is a modern game mainstay that features in many<em> games</em> and are here to stay. Surprisingly, it is not that difficult at all to implement within Kismet, and you may notice some overlap between the behavior we use here and what we did previously.</p><div><ol class="orderedlist arabic"><li class="listitem">Open the Kismet editor and enter our main sequence and drag the screen till you have a large amount of open space.</li><li class="listitem">Create a remote event by selecting<strong> New Event</strong> |<strong> Remote Event</strong>. In the<strong> Properties</strong> pane set the<strong> Event Name</strong> variable to<code class="literal"> RegenHealth</code>.</li><li class="listitem">Directly above the remote event create a<strong> Level Loaded</strong> event by right-clicking and selecting<strong> New Event</strong> |<strong> Level Loaded</strong>.</li><li class="listitem">To the right of the<strong> Level Loaded</strong> event create an<strong> Activate Remote Event</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Event</strong> |<strong> Activate Remote Event</strong>. In the<strong> Properties</strong> pane find the variable<strong> Event Name</strong> and set it to<code class="literal"> RegenHealth</code>.<a class="indexterm" id="id322"/><p>Note that both the <strong>Activate Remote Event</strong> and remote event <strong>RegenHealth</strong> may still have a large red <strong>X</strong> in them. This is either due to a misspelling, or the sequence has not been refreshed. If you exit and enter Kismet again, you will see both of the objects have a green checkmark next to them as shown in the following screenshot:</p><div><img alt="Time for action—regenerating player health over time" src="img/image_1901_05_21.jpg" width="248"/></div></li><li class="listitem">To the right-hand side of the remote event<strong> RegenHealth</strong> create a<strong> Get Property</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Object Property</strong> |<strong> Get Property</strong>. In the<strong> Properties</strong> pane set the<strong> Property Name</strong> variable to<code class="literal"> Health</code>. Underneath the<strong> Target</strong> variable link create a<strong> Player 0</strong> object variable. Underneath the<strong> Int</strong> variable link create a new<strong> Int</strong> variable by right-clicking underneath it and selecting<strong> Create New Int Variable</strong>.<a class="indexterm" id="id323"/><p>Inside the UnrealScript file for the <strong>Player</strong> in the <strong>Pawn Class</strong> there exists an integer that has the name of <strong>Health</strong> which stores the player's health. The <strong>Get Property</strong> acti on allows us to see the value that it contains in our target, if it contains that variable.</p></li><li class="listitem">Create a<strong> Compare Int</strong> conditional by right-clicking and selecting<strong> New Condition</strong> |<strong> Comparison</strong> |<strong> Compare Int</strong>. Underneath the<strong> A</strong> variable link connect the variable under<strong> Int</strong> in our<strong> Get Property</strong>. Underneath<strong> B</strong> create a new<strong> Int</strong> variable and put a value of<code class="literal"> 100</code>. Connect the<strong> Out</strong> from the<strong> Get Property</strong> action to the<strong> In</strong> input of the<strong> Compare Int</strong> conditional.<p>Basically, we're going to compare whether our <strong>Health</strong> is lower than <strong>100</strong> (the maximum value it can be at the moment) or not.</p></li><li class="listitem">Create a<strong> Modify Property</strong> action by using<strong> New Action</strong> |<strong> Object Property</strong> |<strong> Modify Property</strong>. Go to the<strong> Properties</strong> pane and left-click on the green<strong> +</strong> sign beside the<strong> Properties</strong> variable to create a new property to change. Click on the black triangle on the left-hand side to expand the options. Inside the<strong> Property Name</strong> property type<code class="literal"> Health</code>. Click on the checkbox for<strong> Modify Property</strong>. Finally, in the<strong> Property Value</strong> section type<code class="literal"> 100</code>. Under the<strong> Target</strong> variable link place a<strong> Player 0</strong> object. Connect the<strong> A &gt;= B</strong> from the<strong> Compare Int</strong> conditional to the<strong> In</strong> of the<strong> Modify Property</strong> that we just created.<a class="indexterm" id="id324"/></li><li class="listitem">Create a<strong> Compare Float</strong> conditional by right-clicking and selecting<strong> New Condition</strong> |<strong> Comparison</strong> |<strong> Compare Float</strong>. Underneath the<strong> A</strong> variable link create a new<strong> Float</strong> variable and put a value of<code class="literal"> 0.0</code> with the<strong> Var Name</strong> of<strong> TimeSinceDamaged</strong>. Underneath<strong> B</strong> create a new<strong> Float</strong> variable with a Float Value of<code class="literal"> 2.0</code> and<strong> Obj Comment of TimeSinceLastDamaged</strong>. Connect the<strong> A &lt; B</strong> output of the<strong> Compare Int</strong> conditional to the<strong> In</strong> input of this<strong> Compare Float</strong> conditional.</li><li class="listitem">Add a<strong> Set Float</strong> action by using<strong> New Action</strong> |<strong> Set Variable</strong> |<strong> Float</strong>. Create a new float with a value of<code class="literal"> 0.0</code> for the<strong> Value</strong> link.</li><li class="listitem">Create a named variable with an<strong> Expected Type of SeqVar_Float</strong> and a<strong> Find Var Name of TimeSinceDamaged</strong> and connect the<strong> Target</strong> variable link from the<strong> Set Float</strong> action to it. Connect the<strong> Out</strong> of the<strong> Modify Property</strong> (<strong>Health</strong>) to the<strong> In</strong> input of our<strong> Set Float</strong> action.</li><li class="listitem">Create an<strong> Activate Remote Event</strong> action<strong> New Action</strong> |<strong> Event</strong> |<strong> Activate Remote Event</strong> and in the<strong> Properties</strong> pane, find the variable<strong> Event Name</strong> and set it to<strong> RegenHealth</strong>. Connect the<strong> Out</strong> output of our<strong> Set Float</strong> action to the<strong> In</strong> of our<strong> Activate Remote Event</strong> variable<strong> RegenHealth</strong>. This is shown in the following screenshot:<a class="indexterm" id="id325"/><div><img alt="Time for action—regenerating player health over time" height="176" src="img/image_1901_05_22.jpg"/></div></li><li class="listitem">Create a<strong> Modify Health</strong> action<strong> New Action</strong> |<strong> Actor</strong> |<strong> Modify Health</strong>. Under the<strong> Target</strong> variable link create a<strong> Player 0</strong> object variable. Under amount create a<strong> Float</strong> variable with a value of<code class="literal"> 1.0</code>. Inside the<strong> Properties</strong> pane check the<strong> Heal</strong> checkbox and connect the<strong> A &gt;= B</strong> from our<strong> Compare Float</strong> conditional to the<strong> In</strong> of this action.<a class="indexterm" id="id326"/><p>You may noti ce that we are not using <strong>Modify Property</strong> like we did in the previous example; this is merely to show you that there are oft en multi ple ways of doing the exact same thing within Kismet and by experimenti ng you can discover all sorts of things that you can do.</p></li><li class="listitem">Copy (<em>Ctrl</em> +<em> C</em>) and Paste (<em>Ctrl</em> +<em> V</em>) the<strong> Activate Remote Event</strong> variable<strong> RegenHealth</strong> that we created earlier. Drag the action till it is beside the<strong> Modify Health</strong> action we just created. Delete this one's connection to its<strong> In</strong> input by left-clicking while holding the<em> Alt</em> key. Copy and paste another one with the<strong> In</strong> removed and place it above this one. Hook the<strong> Out</strong> from our<strong> Modify Health</strong> to the one beside it.<a class="indexterm" id="id327"/></li><li class="listitem">Create an<strong> Add Float</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Math</strong> |<strong> Add Float</strong>. Connect the<strong> A</strong> and<strong> Float Result</strong> variables of<strong> Add Float</strong> to a named variable with the value of<strong> TimeSinceDamaged</strong> like we did in step 10. Connect the<strong> A &lt; B</strong> output of our<strong> Compare Float</strong> to the<strong> In</strong> of our<strong> Add Float</strong> action. Create a<strong> Float</strong> variable below<strong> B</strong> with a value of<code class="literal"> 0.2</code>. Finally, connect the<strong> Out</strong> output of this<strong> Add Float</strong> to the extra<strong> Activate Remote Event</strong> variable<strong> RegenHealth</strong> we created in the previous step.<div><img alt="Time for action—regenerating player health over time" height="191" src="img/image_1901_05_23.jpg"/></div></li><li class="listitem">Save your project and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar as shown in the following screenshot:<a class="indexterm" id="id328"/><div><img alt="Time for action—regenerating player health over time" src="img/image_1901_05_24.jpg" width="249"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec13"/>What just happened?</h2></div></div></div><p>You can't tell by a still image, but we're one step closer to having a fully featured game, with the fantastic addition of a regenerating health system. When our health is not at maximum, we wait for a period of time and if we are not hit within that time period, we will slowly increase our health over time. We've also gained a good knowledge of how to use named variables, getting and setting object properties in Kismet, as well as experience in using remote events.<a class="indexterm" id="id329"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec14"/>Have a go hero—regenerating player health over time</h2></div></div></div><p>With this base system, there are plenty of things that you can do to extend the functionality. It would be easy to do something similar to<em> Halo's</em> shield recovery, by having the recovery go faster than the lower health you have, by changing the float value under the<strong> Modify Health</strong> action. You could also use the same sequence with a few changes to make it into something that will damage you if you spend too much time in it like with the water in<em> Sonic: The Hedgehog</em>.<a class="indexterm" id="id330"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>Prefabs</h2></div></div></div><p>Quite often when constructing a level, you want to create some arrangement of actors and associated Kismet, and then re-use that collection in the same or other levels, like the door we created. Prefabs allow you to create an object once, and then save it in a package as a prefab. You can then select the<strong> Prefab</strong> in the<strong> Content Browser</strong>, and add it as many times as you like throughout the level.<a class="indexterm" id="id331"/>
</p><p>Note that prefabs can cause problems in UDK and may break and/or stop working for seemingly no reason so SAVE OFTEN after making sure that things work.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Time for action—door prefab</h1></div></div></div><p>Right now we have one single door, and while it is an awesome door, we would probably like to have more than one inside our game. To make it easier to work with and place in new areas of our game, let's make a door prefab!<a class="indexterm" id="id332"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">In Kismet, go to the door behavior that we wrote in the previous chapter. Hold<em> Alt+Ctrl</em> and drag from the top left-hand side of the objects to the bottom, to select all of the items used in the creation. Right-click and select<strong> Create New Sequence</strong>. In the following menu name the sequence<code class="literal"> Door</code>. This is shown in the following screenshot:<a class="indexterm" id="id333"/><div><img alt="Time for action—door prefab" height="256" src="img/image_1901_05_25.jpg"/></div></li><li class="listitem">Similarly in the regular editor window, select all of the objects used to create our door, including the walls surrounding it and the trigger volume used in its creation. Right-click and select<strong> Create Prefab</strong>.<div><img alt="Time for action—door prefab" height="245" src="img/image_1901_05_26.jpg"/></div></li><li class="listitem">In the popup that is created under<strong> Packages</strong> use the name<code class="literal"> UrbanWarrior</code> and inside the<strong> Name</strong> use<code class="literal"> Door.</code><a class="indexterm" id="id334"/></li><li class="listitem">Another popup will come up telling you that it detected a Kismet sequence using items of this prefab and wants to confirm that we want it to be part of the prefab. Click on<strong> Yes</strong>.<p>Note that a prefab can only have one sequence associated with it, and you cannot use the main sequence as your sequence that uses that prefab. Unlike the subsequences that we exported/imported earlier, these objects will have the variable links in the sequence corresponding to the new copies made inside the prefab, which is a really neat thing.</p></li><li class="listitem">Finally the popup will ask if you'd like to convert your door to an instance of the prefab; this is a good idea so click on<strong> Yes</strong>. You will now notice a red<strong> P</strong> symbol next to our door letting us know that it is a prefab.</li><li class="listitem">Left-click on the prefab object and hold<em> Alt</em> while dragging it along an axis to create a copy of the door a distance away from the base point. You should see a second prefab being created and moved, as you drag along making another door in the process.</li><li class="listitem">The walls will not appear inside the perspective view until you build the game, due to it not being able to render changes in BSP at runtime.</li><li class="listitem">Build our game by selecting<strong> Build</strong> |<strong> Build All</strong> and pressing<strong> Close</strong> when finished.<a class="indexterm" id="id335"/></li><li class="listitem">Save your project and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar, saying<strong> Yes</strong> when it asks you to save the package. The following screenshot shows the modified views:<a class="indexterm" id="id336"/><div><img alt="Time for action—door prefab" src="img/image_1901_05_27.jpg" width="216"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec16"/>What just happened?</h2></div></div></div><p>We have now quickly and easily created a second door inside our level. The same functionality included in our previous door is still there, allowing us to enter and exit through both of them quite easily with the sound effects and everything. Using the prefab, it will be trivial to make new doors, and as they aren't forced to be the same (like Unity) we can change anything about each individual prefab without worrying about how it will affect the others.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Building combat sequences</h2></div></div></div><p>As someone who enjoys playing games can attest to, there are always moments in gameplay that stand out from others. We've also played games where it just seemed that you were going through corridor after corridor, with little to no exciting things happening, with the game turning into a bore. Crafting a satisfying combat experience is something that every designer strives to do, and here are some suggestions on my end as to ways of doing just that.<a class="indexterm" id="id337"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec18"/>Layouts</h2></div></div></div><div><blockquote class="blockquote"><p>By failing to prepare, you are preparing to fail. - Benjamin Franklin</p></blockquote></div><p>A good layout is the basis of a solid foundation for the creation of your level, and as such is probably the most important thing to consider when beginning a level. This is one of the numerous reasons why pre-production on game projects is so important. It may go against your initial thoughts, but it is not a good idea to just go in the editor and try to make something. While every once in a while you may stumble into something, it is far more likely that if you plan something out that the resulting level will be much better. That's not to say that what you plan in pre-production will be the same as how you planned it. Playtesting your level may teach you that certain things in the layout are confusing and/or too easy or hard which are important things to take note of. One of the most important things to keep in mind when working on a layout is making it easy to read at a first glance. Keep action in the player's<strong> field of view</strong> (<strong>FOV</strong>) when creating action.<a class="indexterm" id="id338"/>
</p><p>You may have already noticed how in our current version of our layout our door is not in the player's view when spawned, making it confusing to where the player should continue in the game. This sends mixed signals, which is never a good thing.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec19"/>Spawning and enemy placement</h2></div></div></div><p>Of course, having a great layout is good, but if there is nothing to do in the environment, players will soon grow bored and as such we spawn opponents to face them. It is terribly important that enemies get spawned out of sight of the player, because seeing an enemy suddenly appear out of nowhere will suddenly break the suspension of disbelief that our player should be feeling, unless of course it is known as an ability of an enemy such as the Houdini splicers in<em> Bioshock</em>.<a class="indexterm" id="id339"/>
</p><p>Of course, we also don't always want our enemies to be static; which is why we will often have enemies walking according to a path, or coming in from an area. This movement should give our player a visual cue, as just like the real world there is usually a reason why something is where it is. If your game has stealth elements, the player may wait to see a pattern emerging in the enemy's path to avoid conflict. If your game is an action based shooter, our player will be likely travel to where they see things come from. Another thing to keep in mind is to know your engine's limitations, especially working within the mobile gamespace, as mobile platforms are much more demanding on the hardware when spawning enemies.<a class="indexterm" id="id340"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec20"/>Environment</h2></div></div></div><p>Pretty art is pretty, but it can't make up for poor design. For artistic people, like me, it can be incredibly easy to fall into the trap of starting to polish up an area before finishing it. After doing preproduction by designing a layout, build your level using BSP additive brushes at first. At this point, the focus in the level is creating an environment that is fun, and has some semblance to the environment that we want the level to take place in. It is important to do whatever we can, to exploit the type of gameplay that we want to occur as well. For example, we could give the player places to hide from enemies and take pot shots, making the player feel smart for outsmarting the enemies.<a class="indexterm" id="id341"/>
</p><p>One of the most important things you can do as a designer is empowering the players as they are not your enemies, they're your best friends, and are ultimately who gives you your pay check, so it's important to respect them. Aside from the actual physical environment, an environment's lighting can be used in many different ways to affect players. Primarily, light draws focus to things and leads players to travel towards it. Darkness and the unknown are uncomfortable areas for players to be in and not lighting areas as much as others adds to the foreboding nature that an area could have.<em> Monolith's</em> F.E.A.R. does this quite nicely by turning a regular everyday office into an intense and dangerous place to be in, even though you are fully armed and equipped to handle anything that may come by your way.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec21"/>Scripting</h2></div></div></div><p>As important as the placement and spawning of an enemy is, if the enemy doesn't do anything the game will get old quickly. We've created a basic AI for what an enemy could do to enemies, and there are a lot of ways to expand upon it and create unique situations based on what is going on in the game. In large open areas, as long as the player does something resembling intelligence, things seem to go well to which our AI, though limited, can be used to good effect. In general, the tighter the environment, the more you'll want to hand-script the enemy's behavior.<a class="indexterm" id="id342"/>
</p><p>Flanking is a type of behavior in which an enemy is able to come at a target from its sides or behind it, catching it off guard. Flanking in games can be both good and bad. If done well, it can make the player improvise and feel a rush of excitement. If done poorly however, it will make player think AI is cheating, and cause the player to resent the encounter. If you do decide to implement flanking, wait and let the player engage the area before attempting to flank, and make the first shot miss and let the player notice where the shot came from so they can adjust.</p><p>Another tool that designers can utilize is the idea of waves in an environment where you spawn different enemies at different times, in order to extend the gameplay and time spent in a certain area. However, each wave should be unique or else the player will get bored easily.<em> Dungeon Defenders</em> does this in a good way by incrementing difficulty over time making sure that things don't get boring.<a class="indexterm" id="id343"/>
</p><p>Keep in mind the difficulty of your waves and encounters in general, and modify the elements that you can in order to curve up the difficulty in each encounter, but also give the player a chance to take a breather once in a while to reflect on how powerful he has become.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>Playtesting</h2></div></div></div><p>In my opinion, a game designer is the player's advocate and in that role, their main responsibility is to make a game that your target audience will love. Because of this, playtesters are a game designer's best friend. They are the voice of how a normal person is going to react to your game, and as such it is important that you take what they say seriously. They are the people that are going to find and exploit anything they can get their hands on within your world as well and you will find things you never thought of possible in your game. They are going to suggest changes and it will be your decision whether or not those changes are really worth having or not.<a class="indexterm" id="id344"/>
</p><p>It is also very important that you have people to play your game without your input. Most designers believe that they have covered every possible thing a player can do, but it is almost guaranteed that something has been forgotten. In level design, it is important to see what directions players go in, and whether they are being guided in the correct way.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Summary</h1></div></div></div><p>We now have all of the pieces that we need to create our game and have learned a lot of things in the process. By using the same principles given in this chapter it is possible to expand and create many different types of enemies and behaviors.</p><p>In this short period of time we managed to cover quite a lot of things. We specifically learned the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What sequences are and how we use them</li><li class="listitem" style="list-style-type: disc">How to spawn an enemy into our level</li><li class="listitem" style="list-style-type: disc">What we can do to develop a rudimentary AI system that will shoot at us if we are close to it</li><li class="listitem" style="list-style-type: disc">How to expand upon that system by adding chasing and retreating behavior</li><li class="listitem" style="list-style-type: disc">How to create additional enemies using import/export subsequences</li><li class="listitem" style="list-style-type: disc">How to implement regenerating health using remote events</li><li class="listitem" style="list-style-type: disc">What prefabs are and how we can and their use them in our project</li><li class="listitem" style="list-style-type: disc">How to make a door prefab</li><li class="listitem" style="list-style-type: disc">Things to consider when creating combat scenarios</li></ul></div><p>Now we've learned how to build all of the base elements that we will need to implement our game.</p><p>In the next chapter, we will be bringing all of these pieces together to create our full-fledged game by discussing a workflow for creating levels using<strong> Geometry Mode</strong>, how to use modular pieces to create our level quickly, and advice on building levels on</p></div></body></html>