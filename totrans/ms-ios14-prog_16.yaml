- en: '*Chapter 16*: Creating Your First Widget'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：创建你的第一个部件'
- en: With iOS 14, Apple introduced WidgetKit. Users are now able to use widgets on
    their home screens. By displaying small amounts of useful information on the home
    screen, widgets provide a key functionality to users that was long-awaited. Some
    examples are checking stock market prices, weather or traffic conditions, the
    next meeting on your calendar, and so on with just a glance at the home screen.
    The use cases are limitless!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着iOS 14的推出，苹果引入了WidgetKit。现在，用户可以在主屏幕上使用部件。通过在主屏幕上显示少量有用的信息，部件为用户提供了一个长期期待的关键功能。一些例子包括查看股市价格、天气或交通状况、日历上的下一次会议等，只需在主屏幕上扫一眼即可。用例是无限的！
- en: 'In this chapter, you will learn about the basic foundations of WidgetKit, as
    well as the key aspects of widget design and their limitations. Then, we will
    build a widget from scratch. Starting with a very simple, small-sized widget,
    we will extend its capabilities by creating new sizes, network calls, dynamic
    configurations, placeholder views, and much more! We will discuss all these topics
    in the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解WidgetKit的基本原理，以及部件设计和它们的限制性关键方面。然后，我们将从头开始构建一个部件。从一个非常简单、小尺寸的部件开始，我们将通过创建新尺寸、网络调用、动态配置、占位符视图等来扩展其功能！我们将在接下来的章节中讨论所有这些主题：
- en: Introducing widgets and WidgetKit
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍部件和WidgetKit
- en: Developing your first widget
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发你的第一个部件
- en: By the end of this chapter, you will be able to create your own widgets to enable
    your apps to provide a unique new feature so that users will download your app
    and engage with it much more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建自己的部件，使你的应用能够提供独特的全新功能，从而吸引用户下载并更积极地使用你的应用。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code bundle for this chapter includes a starter project called `CryptoWidget_1_small_start`
    and subsequent parts. You can find them in the code bundle repository:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包括一个名为`CryptoWidget_1_small_start`的入门项目及其后续部分。你可以在代码包仓库中找到它们：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Introducing widgets and WidgetKit
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍部件和WidgetKit
- en: In this section, we are going to learn about the basics of WidgetKit and the
    options and guidelines for widgets in iOS 14.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习WidgetKit的基础知识以及iOS 14中部件的选项和指南。
- en: 'Users and developers have been requesting a particular feature for years: they
    all wanted to have widgets on their home screen. Widgets allow users to configure,
    personalize, and consume little pieces of relevant data from their home screen.
    They also enable developers to offer users glanceable content and create added
    value to their apps.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和开发者多年来一直在请求一个特定的功能：他们都想在主屏幕上拥有部件。部件使用户能够配置、个性化并在主屏幕上消费相关的小数据块。它们还使开发者能够提供可快速查看的内容，并为他们的应用增加价值。
- en: 'Here is a preview of what a **widget** (in this case, the Calendar and Reminders
    widgets) looks like on the home screen of the iPhone:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是部件（在本例中为日历和提醒事项部件）在iPhone主屏幕上的预览：
- en: '![Figure 16.1 – iOS home screen with widgets'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 – 带有部件的iOS主屏幕'
- en: '](img/Figure_16.01_B14717.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.01_B14717.jpg)'
- en: Figure 16.1 – iOS home screen with widgets
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 带有部件的iOS主屏幕
- en: This is now possible on iOS 14 and macOS 11 and later. Developers can create
    widgets across iOS, iPadOS, and macOS using **WidgetKit** and the new **widget
    API** for SwiftUI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在iOS 14和macOS 11及更高版本中可以实现这一点。开发者可以使用**WidgetKit**和SwiftUI的新**部件API**在iOS、iPadOS和macOS上创建部件。
- en: '**Smart Stack** on iOS 14 contains a set of different widgets, including ones
    that the user opens frequently. If the user enables **Smart Rotate**, Siri can
    highlight relevant widgets within custom stacks.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 14中的**智能堆叠**包含一组不同的部件，包括用户经常打开的部件。如果用户启用**智能旋转**，Siri可以在自定义堆叠中突出显示相关的部件。
- en: Widgets created on iOS 13 and earlier
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 13及更早版本创建的部件
- en: Widgets created before iOS 14 can't be placed on the home screen, but they are
    still available on the Today view and in the macOS Notification Center.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 14之前创建的部件无法放置在主屏幕上，但它们仍然可在今日视图和macOS通知中心中访问。
- en: After this intro to the new widget feature, let's see what options we have when
    building a widget and what the design guidelines from Apple are.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍新部件功能之后，让我们看看在构建部件时有哪些选项，以及苹果的设计指南是什么。
- en: Widget options
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部件选项
- en: Users can place widgets on the home screen or the Today view on iOS, the Today
    view on iPad, or the Notification Center on macOS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在iOS的主屏幕或Today视图、iPad的Today视图或macOS的通知中心上放置小部件。
- en: 'Widgets come in three sizes: small, medium, and large. Each size should have
    a different purpose; a bigger version of a widget should not just be the same
    as the small one but with bigger font and images. The idea behind having different
    sizes for a widget is that the bigger the size, the more information it should
    contain. For example, a weather widget will provide just the current temperature
    in the small-sized version, but it will also include the weekly forecast in the
    medium-sized one.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件有三种尺寸：小、中、大。每种尺寸应有不同的用途；小部件的大版本不应只是小尺寸版本字体和图像的放大，而是应该包含更多信息。小部件不同尺寸背后的理念是，尺寸越大，包含的信息应该越多。例如，天气小部件在小尺寸版本中只提供当前温度，但在中尺寸版本中还将包括每周天气预报。
- en: Users can arrange widgets on different parts of their screen, and even create
    stacks of widgets to group them up.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在屏幕的不同部分排列小部件，甚至创建小部件堆叠来分组它们。
- en: 'In order to develop a widget, developers need to create a new extension for
    their app: a **widget extension**. They can configure the widget with a timeline
    provider. A timeline provider updates the widget information when needed.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发一个小部件，开发者需要为他们应用创建一个新的扩展：一个**小部件扩展**。他们可以使用时间线提供者来配置小部件。时间线提供者在需要时更新小部件信息。
- en: Suppose a widget needs some configuration (for example, selecting a default
    city in a weather app, or multiple cities to display in a large-sized weather
    widget). In that case, developers should add a custom Siri intent to the widget
    extension. Creating a custom Siri intent automatically provides the widget with
    a customization interface for the user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个小部件需要一些配置（例如，在天气应用中选择默认城市，或在大型天气小部件中显示多个城市）。在这种情况下，开发者应在小部件扩展中添加自定义Siri意图。创建自定义Siri意图会自动为小部件提供用户定制的界面。
- en: Widget guidelines
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件指南
- en: 'When creating a widget for iOS 14 or macOS 11, take into account the following
    design guidelines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当为iOS 14或macOS 11创建小部件时，请考虑以下设计指南：
- en: Focus your widget on the main feature of your app. For example, if your app
    is about the stock market, your widget could display the user portfolio's total
    value.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的小部件聚焦于你应用的主要功能。例如，如果你的应用是关于股市的，你的小部件可以显示用户投资组合的总价值。
- en: Each widget size should display a different amount of information. If your cycling
    tracker widget displays the current calories burned today in the small size, it
    can also display the week's calories per day in the medium size, and add extra
    info such as the number of km/miles traveled on the big size.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个小部件的大小应显示不同数量的信息。如果你的骑行追踪小部件在小尺寸下显示今天燃烧的卡路里，它也可以在中尺寸下显示每天的周卡路里，并在大尺寸下添加额外的信息，例如行驶的公里数/英里数。
- en: Prefer dynamic information that changes during the day to fixed information;
    it will make your widget more appealing to the user.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于固定信息，更倾向于动态信息，这些信息在一天中会变化；这将使你的小部件对用户更具吸引力。
- en: Prefer simple widgets with fewer configuration options to the opposite.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于配置选项更多的小部件，更倾向于简单的小部件。
- en: Widgets offer tap target and detection, letting the user select and tap on them
    to open detailed information in the app. Small-sized widgets support a single
    tap target; medium- and big-sized widgets support multiple targets. Try to keep
    it simple.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件提供点击目标和检测功能，使用户能够点击它们以在应用中打开详细信息。小型小部件支持单个点击目标；中型和大型小部件支持多个目标。尽量保持简单。
- en: Support dark mode. Also consider using SF Pro as the font and SF Symbols if
    needed.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持深色模式。如有需要，还可以考虑使用SF Pro作为字体和SF Symbols。
- en: In this section, we learned about the new widget feature and WidgetKit. We covered
    the different options available and the design guidelines when building a widget.
    In the next section, we will start building a simple widget from scratch, and
    we will add more features step by step.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了新的小部件功能和WidgetKit。我们涵盖了构建小部件时可用选项和设计指南。在下一节中，我们将从头开始构建一个简单的小部件，并逐步添加更多功能。
- en: Developing your first widget
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发你的第一个小部件
- en: In this section, we will use an existing app to create a widget on top of it
    step by step.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个现有应用，逐步创建其上的小部件。
- en: The app that we will work on is a crypto ticker, in which the user can check
    the latest prices of different cryptocurrencies. We will create a widget that
    will allow users to glance at crypto prices from their home screen, so they don't
    have to open the app itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的这款应用是一款加密货币行情应用，用户可以查看不同加密货币的最新价格。我们将创建一个小部件，让用户可以直接从主屏幕上查看加密货币的价格，这样他们就不必打开应用本身。
- en: Go ahead and open the project named `CryptoWidget_start` from the code bundle
    of this chapter. This is the base project on top of which we will build our widget.
    Before jumping into the task, let's do a quick review of the base project itself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请打开本章代码包中名为 `CryptoWidget_start` 的项目。这是我们构建小部件的基础项目。在开始任务之前，让我们快速回顾一下基础项目本身。
- en: 'Build and launch the project. The app displays a list of cryptocurrencies''
    prices:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并发布项目。应用显示加密货币价格列表：
- en: '![Figure 16.2 – Base app'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2 – 基础应用'
- en: '](img/Figure_16.02_B14717.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.02_B14717.jpg)'
- en: Figure 16.2 – Base app
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 基础应用
- en: 'You can also go into a detailed view of each coin, but just for demo purposes,
    it doesn''t contain additional info. As we are going to work with an existing
    code base, let''s highlight some key points before modifying it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进入每个硬币的详细视图，但仅出于演示目的，它不包含额外的信息。由于我们将使用现有的代码库，在修改它之前，让我们突出一些关键点：
- en: 'The project is structured into three groups of files (apart from the default-generated
    files and app delegates): `Views`, `Model`, and `Network`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目被组织成三个文件组（除了默认生成的文件和应用代理）：`Views`、`Model` 和 `Network`。
- en: The `Views` folder contains the `UIView` files of the project. The views have
    been created using SwiftUI. SwiftUI is the recommended way to go when building
    widgets with WidgetKit. Don't worry if you are not familiar with SwiftUI; we will
    only use basic views in this project.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Views` 文件夹包含项目的 `UIView` 文件。视图是使用 SwiftUI 创建的。当使用 WidgetKit 构建小部件时，SwiftUI
    是推荐的方式。如果你不熟悉 SwiftUI，不要担心；在这个项目中，我们只会使用基本的视图。'
- en: 'Inside the `Network` folder, we have a class named `DataManager.swift`. This
    class contains the `getData()` method, which is responsible for fetching the crypto
    prices from the API of CoinMarketCap. You can create a free developer account
    on their website to get up-to-date prices. Otherwise, the demo app uses a demo
    key that gives us historical prices for the cryptos that we are using. If you
    create your own account, you just need to substitute the value of this key with
    your own key: `let apiKeyValue = "b54bcf4d-1bca-4e8e-9a24-22ff2c3d462c"`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Network` 文件夹内部，我们有一个名为 `DataManager.swift` 的类。这个类包含 `getData()` 方法，负责从 CoinMarketCap
    的API中获取加密货币价格。你可以在他们的网站上创建一个免费的开发者账户以获取最新的价格。否则，演示应用使用一个演示密钥，为我们提供的加密货币提供历史价格。如果你创建自己的账户，你只需要用你自己的密钥替换这个密钥的值：`let
    apiKeyValue = "b54bcf4d-1bca-4e8e-9a24-22ff2c3d462c"`。
- en: 'The `Model` folder contains basic structs to work with the `getData()` method
    results: `Coin` and `CoinList`. These structs will contain information about the
    crypto symbols and prices from the API.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model` 文件夹包含与 `getData()` 方法结果一起工作的基本结构体：`Coin` 和 `CoinList`。这些结构体将包含来自API的加密货币符号和价格信息。'
- en: 'Now, let''s take a look at the main view of the project, located in the `ContentView.swift`
    file inside the `Views` folder. The `ContentView` struct contains `@ObservedObject
    var dataManager = DataManager()`. The `@ObservedObject` tag indicates that this
    SwiftUI view will observe changes in the `dataManager` struct, and it will refresh/react
    to them. Remember that `dataManager` is the class that we are using to retrieve
    the crypto data from the network, so it makes sense that our main view is observing
    any changes. Check the body of `ContentView`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看项目的主体视图，它位于 `Views` 文件夹内的 `ContentView.swift` 文件中。`ContentView` 结构体包含
    `@ObservedObject var dataManager = DataManager()`。`@ObservedObject` 标签表示这个 SwiftUI
    视图将观察 `dataManager` 结构体的变化，并将刷新/响应这些变化。记住，`dataManager` 是我们用来从网络上检索加密货币数据的类，所以我们的主要视图观察任何变化是有意义的。检查
    `ContentView` 的主体：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The view will display a simple `Loading…` text while `dataManager` is in the
    loading state, and it will display `CoinListView` when `dataManager` finishes
    loading and contains some data. Simple! Now, if you check the implementation of
    `CoinListView.swift`, you will see that it is a simple list displaying the information
    for every coin that it receives as input:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `dataManager` 处于加载状态时，视图将显示简单的 `Loading…` 文本，当 `dataManager` 加载完成并包含一些数据时，将显示
    `CoinListView`。很简单！现在，如果你检查 `CoinListView.swift` 的实现，你会看到它是一个简单的列表，显示它接收到的每个硬币的信息：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing too fancy for now! We have, so far, `dataManager`, which calls `getData()`
    to fetch coin information from an API, and `ContentView`, which displays `Loading…`
    text while the data is being called, and displays a list with coin details when
    the coin's information has been retrieved. Everything was done with a few classes
    and a few lines of code… that is the power of SwiftUI! Now that we have a clear
    view of the base project, let's jump into creating a widget extension to start
    building our awesome crypto coin widget!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有什么太花哨的！到目前为止，我们有 `dataManager`，它调用 `getData()` 从 API 获取代币信息，以及 `ContentView`，在数据被调用时显示
    `Loading…` 文本，并在获取到代币信息时显示代币详情列表。所有这些都是在几个类和几行代码中完成的…这就是 SwiftUI 的力量！现在我们已经对基础项目有了清晰的了解，让我们开始创建小部件扩展，以开始构建我们出色的加密货币小部件！
- en: Creating a widget extension
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建小部件扩展
- en: The first step to add a widget to an app is to create a widget extension. Creating
    a widget extension will provide us with a default implementation of the widget
    protocol, which will help us to get the basic pieces ready.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将小部件添加到应用程序的第一步是创建一个小部件扩展。创建小部件扩展将为我们提供一个默认的小部件协议实现，这将帮助我们准备好基本组件。
- en: 'Before creating the extension, let''s review the parts of a widget extension
    displayed in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建扩展之前，让我们回顾一下以下图中显示的小部件扩展的各个部分：
- en: '![Figure 16.3 – Widget building blocks'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.3 – 小部件构建块'
- en: '](img/Figure_16.03_B14717.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.03_B14717.jpg)'
- en: Figure 16.3 – Widget building blocks
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – 小部件构建块
- en: 'As you can see in the preceding diagram, the following are descriptions of
    the building blocks of a widget extension:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，以下是小部件扩展构建块的解释：
- en: If the widget is configurable by the user, it will need a custom Siri intent
    configuration definition. For example, a widget that displays stocks can ask the
    user for a configuration to choose what stocks to display.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小部件可以被用户配置，它将需要一个自定义 Siri 意图配置定义。例如，显示股票的小部件可以要求用户进行配置以选择要显示的股票。
- en: A provider is needed that will provide the data to display on the widget. The
    provider can generate placeholder data (that is, show when the user is browsing
    the widget gallery or loading), a timeline (to represent data over time), and
    a snapshot (the units that compose a timeline).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个提供者来提供要在小部件上显示的数据。提供者可以生成占位符数据（即在用户浏览小部件画廊或加载时显示），时间线（表示随时间变化的数据），以及快照（组成时间线的单元）。
- en: A SwiftUI view to display the data is needed.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个 SwiftUI 视图来显示数据。
- en: 'When creating a widget target, Xcode will autogenerate placeholders for all
    these classes. Let''s do it now; follow these steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建小部件目标时，Xcode 将自动生成所有这些类的占位符。现在让我们来做这件事；按照以下步骤操作：
- en: In the project named `CryptoWidget_start`, go to **File** | **New** | **Target**
    | **Widget Extension**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `CryptoWidget_start` 的项目中，转到 **文件** | **新建** | **目标** | **小部件扩展**。
- en: You can use `CryptoWidgetExtension` as the product name and check the **Include
    Configuration Intent** option:![Figure 16.4 – Widget extension options
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `CryptoWidgetExtension` 作为产品名称，并勾选 **包含配置意图** 选项：![图 16.4 – 小部件扩展选项
- en: '](img/Figure_16.04_B14717.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_16.04_B14717.jpg)'
- en: Figure 16.4 – Widget extension options
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 16.4 – 小部件扩展选项
- en: Click **Activate** on the following popup.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击以下弹出窗口中的 **激活**。
- en: 'If you have followed the preceding steps, your project should now contain a
    new target with the following folder structure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经按照前面的步骤操作，那么您的项目现在应该包含一个具有以下文件夹结构的新目标：
- en: '![Figure 16.5 – Widget target structure'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.5 – 小部件目标结构'
- en: '](img/Figure_16.05_B14717.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.05_B14717.jpg)'
- en: Figure 16.5 – Widget target structure
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – 小部件目标结构
- en: 'When creating the widget extension, Xcode has autogenerated two important files:
    `CryptoWidgetExtension.swift` and `CryptoWidgetExtension.intentdefinition`. Let''s
    focus for now on `CryptoWidgetExtension.swift`. Open it and let''s take a look.
    Check the following piece of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建小部件扩展时，Xcode 已经自动生成了两个重要的文件：`CryptoWidgetExtension.swift` 和 `CryptoWidgetExtension.intentdefinition`。现在让我们专注于
    `CryptoWidgetExtension.swift`。打开它，让我们看一下。检查以下代码片段：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, and as discussed before, we have the basic building pieces
    of the widget:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，正如之前讨论的那样，我们有小部件的基本构建块：
- en: An intent configuration, to allow the user to configure the widget, named `IntentConfiguration`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `IntentConfiguration` 的意图配置，允许用户配置小部件。
- en: 'A provider to provide data to the widget: `Provider()`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供数据给小部件的提供者：`Provider()`
- en: 'A view to display the data: `CryptoWidgetExtensionEntryView`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示数据的视图：`CryptoWidgetExtensionEntryView`
- en: The `CryptoWidgetExtension` struct is tagged as `@main`, meaning that is the
    entry point of the widget. The body is formed of `IntentConfiguration` and `CryptoWidgetExtensionEntryView`,
    which receives an `entry` instance as input.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`CryptoWidgetExtension` 结构被标记为 `@main`，这意味着它是小部件的入口点。其主体由 `IntentConfiguration`
    和 `CryptoWidgetExtensionEntryView` 组成，该视图接收一个 `entry` 实例作为输入。'
- en: 'In the same file, we also have the autogenerated definitions for the required
    methods of `Provider` (`placeholder()`, `getSnapshot()`, and `getTimeline()`):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，我们还有 `Provider` 所需方法的自动生成定义（`placeholder()`、`getSnapshot()` 和 `getTimeline()`）：
- en: The `placeholder(…)` method will provide the widget with the initial view the
    first time the widget is rendered. The placeholder will give the user a general
    idea of what the widget will look like.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`placeholder(…)` 方法将为小部件提供第一次渲染小部件时的初始视图。占位符将使用户对小部件的外观有一个大致的了解。'
- en: 'The `getSnapshot(…in context…)` method will provide the widget with a value
    (entry) to display when the widget needs to be shown in transient situations.
    The `isPreview` property from `context` indicates that the widget is being shown
    in the widget gallery. In those cases, the snapshot has to be fast: those scenarios
    may require the developer to use dummy data and avoid network calls to return
    the snapshot as fast as possible.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSnapshot(…in context…)` 方法将为小部件提供一个值（输入），当小部件需要在短暂情况下显示时使用。`context` 中的
    `isPreview` 属性表示小部件正在小部件画廊中显示。在这些情况下，快照必须快速：这些场景可能需要开发人员使用占位符数据并避免网络调用，以便尽可能快地返回快照。'
- en: The `getTimeline(…)` method will provide the widget with an array of values
    to display over the current time (and optionally in the future).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTimeline(…)` 方法将为小部件提供一组值，以显示当前时间（以及可选的未来时间）。'
- en: 'There is another important modifier that we will use later. Just after `.description("This
    is an example widget.")`, add the following line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后使用另一个重要的修饰符。在 `.description("这是一个示例小部件。")` 之后，添加以下行：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is where we configure the different sizes available for this widget. Later
    on in the chapter, we will add the medium-sized type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们配置此小部件可用不同大小的位置。在章节的后面部分，我们将添加中等大小的类型。
- en: 'Now, let''s take a look at another part of the code. At the end of the file,
    you will find the `Preview` section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码的另一个部分。在文件末尾，您将找到 `Preview` 部分：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This part of the code will allow us to display a preview with SwiftUI of what
    our widget will look like while developing it. If you launch the preview, you
    will see that right now, it just displays the time (go to **Editor** | **Canvas**
    on the top menu of Xcode if you don''t see the preview tab):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码将允许我们使用 SwiftUI 显示预览，以显示我们在开发小部件时的外观。如果您启动预览，您将看到目前它只显示时间（如果您看不到预览选项卡，请转到
    Xcode 顶部菜单的 **编辑** | **画布**）：
- en: '![Figure 16.6 – Editor canvas preview'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 16.6 – Editor canvas preview]'
- en: '](img/Figure_16.06_B14717.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_16.06_B14717.jpg]'
- en: Figure 16.6 – Editor canvas preview
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – 编辑画布预览
- en: That is great! We can code and see the final results in real time. Let's analyze
    a bit how we are getting this kind of widget view with the time on it. See how
    we are using `CryptoWidgetExtensionEntryView` as the main view of the preview?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们可以实时编码并看到最终结果。让我们分析一下我们是如何获得带有时间的小部件视图的。看看我们是如何使用 `CryptoWidgetExtensionEntryView`
    作为预览的主视图的？
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This view is receiving `SimpleEntry` (with just the date) and a plain, empty
    `ConfigurationIntent`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图接收 `SimpleEntry`（仅包含日期）和一个普通的、空的 `ConfigurationIntent`。
- en: Then, we are applying a modifier to the view by creating `previewContext` and
    assigning `WidgetPreviewContext` as `.systemSmall`. By doing this, we are rendering
    the view inside the preview of a small widget!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过创建 `previewContext` 并将其分配为 `.systemSmall` 来对视图应用修饰符。通过这样做，我们在小部件预览中渲染视图！
- en: 'What is `CryptoWidgetExtensionEntryView` doing with `SimpleEntry`? Let''s check
    the implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`CryptoWidgetExtensionEntryView` 是如何使用 `SimpleEntry` 的？让我们检查实现：'
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Well, it is just displaying text with the date! So, in summary, the preview
    is doing the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它只是显示带有日期的文本！所以，总的来说，预览正在执行以下操作：
- en: Using `SimpleEntry` as the data input for the widget
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SimpleEntry` 作为小部件的数据输入
- en: Using `CryptoWidgetExtensionEntryView` as the main view to display that data
    entry
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CryptoWidgetExtensionEntryView` 作为主视图来显示数据输入
- en: Using the `WidgetPreviewContext` modifier to use a small widget as the canvas
    for the preview
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WidgetPreviewContext` 修饰符来使用小型小部件作为预览的画布
- en: With all these concepts in mind, it is time to start creating our own widget.
    Let's modify the preceding structs to display the value of Bitcoin instead of
    a simple date.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记所有这些概念后，是时候开始创建我们自己的小部件了。让我们修改前面的结构体，以显示比特币的价值而不是简单的日期。
- en: 'First, if we want to display a coin''s value (Bitcoin, for example) in the
    widget, we need an entry to contain that information. Let''s add an array of `Coin`
    to the properties of the `SimpleEntry` struct:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们想在部件中显示一个币的价值（例如比特币），我们需要一个条目来包含这些信息。让我们将`Coin`数组添加到`SimpleEntry`结构的属性中：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By storing the `coins` property, the entry can deliver this information to
    the widget''s view later on. If you try to build the project, you will get an
    error like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过存储`coins`属性，条目可以在稍后向小部件的视图传递此信息。如果你尝试构建项目，你将得到如下错误：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This happens because the `Coin` file is only part of the main app target. We
    need to select `Coin` and all the other files under the `Views`, `Network`, and
    `Model` folders and add them to the widget''s target:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Coin`文件只是主应用目标的一部分。我们需要选择`Coin`以及`Views`、`Network`和`Model`文件夹下的所有其他文件，并将它们添加到小部件的目标中：
- en: '![Figure 16.7 – Sharing files from the main app to the widget target'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7 – 从主应用共享文件到小部件目标'
- en: '](img/Figure_16.07_B14717.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.07_B14717.jpg)'
- en: Figure 16.7 – Sharing files from the main app to the widget target
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – 从主应用共享文件到小部件目标
- en: After adding the files of the previous screenshot to the widget target, you
    will get new, different errors when compiling. The main reason for all these errors
    is that you have added a new property to `Coin`, and now there are parts in the
    `Provider` struct where we are initializing a `Coin` instance without that new
    property. To fix it, we will add some dummy data (for now) into the `Provider`
    implementation to pass it as the coins when creating any `SimpleEntry` instance
    inside `Provider`. Later on, we will use real data from the API instead of that
    dummy one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在将上一张截图中的文件添加到小部件目标后，编译时将出现新的不同错误。所有这些错误的主要原因是你向`Coin`添加了一个新属性，现在在`Provider`结构体中有部分地方我们在初始化`Coin`实例时没有那个新属性。为了修复它，我们将向`Provider`实现中添加一些占位符数据（目前如此），在创建`Provider`内部的任何`SimpleEntry`实例时将其作为币传递。稍后，我们将使用来自API的真实数据而不是这些占位符数据。
- en: 'Add the following code inside the `Provider` struct. Its first line will appear
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Provider`结构体内部添加以下代码。其第一行将如下所示：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are creating some fake data to generate a `Coin` array, containing some
    values for Bitcoin and Litecoin. Now, we can use this `coins` value to inject
    it into the three places in which we are creating `SimpleEntry` inside the `Provider`
    class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一些假数据以生成一个包含比特币和莱特币一些值的`Coin`数组。现在，我们可以使用这个`coins`值将它们注入到`Provider`类内部创建`SimpleEntry`的三个地方：
- en: 'First, we inject it inside the `placeholder(…)` method:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们在`placeholder(…)`方法内部注入它：
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we inject it inside the `getSnapshot(…)` method:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们在`getSnapshot(…)`方法内部注入它：
- en: '[PRE11]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then inject it inside the `getTimeline(…)` method:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们在`getTimeline(…)`方法内部注入它：
- en: '[PRE12]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, you may have the exact same problem inside the `CryptoWidgetExtension_Previews`
    struct. The `previews` property is using `SimpleEntry` to display it in the widget.
    You need to add the `coins` property again. Just use this code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能在`CryptoWidgetExtension_Previews`结构体内部遇到完全相同的问题。`previews`属性正在使用`SimpleEntry`在部件中显示它。你需要再次添加`coins`属性。只需使用此代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Great! The project should compile properly now. Try to render the preview to
    see what happens. Oops! You should still see the date/time in the little widget
    and no coin values! Why? We are passing the coin values into the entry to the
    widget, but the view of the widget is not using it yet. Check the current implementation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！项目现在应该可以正确编译。尝试渲染预览以查看发生了什么。哎呀！你仍然应该在小的部件中看到日期/时间，而没有币值！为什么？我们将币值传递给小部件的条目，但小部件的视图还没有使用它。检查当前的实现：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have `entry` with coins information inside, but we are only displaying the
    date. We need to modify the view to show the new information! In the main app,
    we have a view that, given a coin, displays its name and price. Let''s use it.
    Change the `CryptoWidgetExtensionEntryView` implementation for this (changes are
    highlighted):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内部有包含币信息的`entry`，但我们只显示日期。我们需要修改视图以显示新的信息！在主应用中，我们有一个视图，给定一个币，显示其名称和价格。让我们使用它。更改`CryptoWidgetExtensionEntryView`的实现（更改已突出显示）：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, build and refresh the preview. Great! You should see the price and name
    of Bitcoin on the widget, as in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Widget showing the Bitcoin price'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.08_B14717.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.8 – Widget showing the Bitcoin price
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try it in the simulator, just launch the widget target. Remember
    that you should have launched (at least once) the main app first.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned how to add a widget extension to an app. Then,
    we explored the main components and the relationship between them: the provider,
    the entries, the view of the widget, and the preview system of SwiftUI. Finally,
    we modified all these components to adapt them to our needs and created our first
    small widget. In the next section, we will learn how to add a placeholder preview
    and how to add a medium-sized widget too!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple-size widgets
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we added a widget target to a project and created the
    widget's first view, the small-sized one. Let's do some modifications now in order
    to develop a medium-sized widget, and also a placeholder preview for the widget.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t follow along with the previous section, you can use the project
    named `CryptoWidget_1_small_widget`. Let''s start by adding a placeholder preview
    to the project. When rendering your widget for the first time, WidgetKit will
    render it as a placeholder. In order to render data, it will ask the provider
    for an entry using the following method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But in order to be able to see how it would appear while we develop it, we
    can create a preview of it using SwiftUI. Go ahead and add the following struct
    to the `CryptoWidgetExtension.swift` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'See how we are using the main widget view (`CryptoWidgetExtensionEntryView`)
    as the placeholder view, and we are feeding it with dummy coins data? However,
    the interesting part is the highlighted part: `.redacted(reason: .placeholder)`.
    Now that we have created a placeholder view with dummy data, let''s create a preview
    of it and check what the effect of the `redacted` modifier is.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the implementation of `CryptoWidgetExtension_Previews` and add this
    new one, with the modified code highlighted as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we are encapsulating the previous `CryptoWidgetExtensionEntryView` view
    inside `Group`. This is because now we want to display a group of previews, `CryptoWidgetExtensionEntryView,`
    and the new `Placeholder`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we are adding the newly created `Placeholder` view, and applying to it
    a `previewContext` of a small widget, like before. Compile and resume the preview
    render; you should see the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Placeholder view with a redacted modifier'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.09_B14717.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.9 – Placeholder view with a redacted modifier
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you now see the effect of `.redacted(reason: .placeholder)`? SwiftUI is
    replacing labels with placeholder views of them. It is straightforward to create
    a placeholder view of your widgets like this!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have a small-sized widget and a preview of it. Let's start creating
    a medium-sized version of it. Bigger widgets should use the extra available space
    to provide users with added value. Your medium- or big-sized widget should not
    be a simple, bigger-sized version of the small one. In our case, we are displaying
    the price of Bitcoin in a small size. Now, in the medium size, we will display
    the value of multiple cryptocurrencies at once. The user will get a bigger picture
    of the market with just a glance!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个小型小部件及其预览。让我们开始创建它的中等尺寸版本。更大的小部件应该利用额外的可用空间为用户提供额外的价值。你的中等或大尺寸小部件不应该只是简单的大尺寸版本。在我们的例子中，我们以小尺寸显示比特币的价格。现在，在中等尺寸，我们将一次性显示多种加密货币的价值。用户只需一眼就能获得市场的更大图景！
- en: 'In the previous section, we configured `supportedFamilies` to allow the small
    size of the widget. We need to add the medium size too. You will find it in the
    `CryptoWidgetExtension` struct. Add `.systemMedium` to `supportedFamilies`, so
    the configuration line should look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们配置了`supportedFamilies`以允许小尺寸的小部件。我们还需要添加中等尺寸。你将在`CryptoWidgetExtension`结构体中找到它。将`.systemMedium`添加到`supportedFamilies`中，因此配置行应该看起来像这样：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now create a preview of the medium-sized widget. Go ahead and add a
    new `Group` below the existing one in `CryptoWidgetExtension_Previews`. Add the
    following code just where the existing `Group{ … }` finishes (so you should have
    one group after the other):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为中等尺寸的小部件创建一个预览。请继续在`CryptoWidgetExtension_Previews`中现有小部件下方添加一个新的`Group`。在现有的`Group{
    … }`结束的地方添加以下代码（因此你应该有一个接一个的组）：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'See how this new group of views is the same as the existing one, with the only
    difference being in the highlighted code? We are now displaying the widget and
    its placeholder inside a `systemMedium` preview. If you resume the render, you
    should see these two new previews (apart from the previous small-sized ones):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个新的视图组与现有的视图是否相同，唯一的区别在于高亮的代码？我们现在在`systemMedium`预览中显示小部件及其占位符。如果你恢复渲染，你应该看到这两个新的预览（除了之前的小尺寸预览）：
- en: '![Figure 16.10 – Medium-sized widget and placeholder'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.10 – 中等尺寸小部件和占位符](img/Figure_16.10_B14717.jpg)'
- en: '](img/Figure_16.10_B14717.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.10 – 中等尺寸小部件和占位符](img/Figure_16.10_B14717.jpg)'
- en: Figure 16.10 – Medium-sized widget and placeholder
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 中等尺寸小部件和占位符
- en: 'You can imagine how, for a user, this result would be very disappointing. We
    are displaying the exact same information as in the small widget but taking up
    more space on their home screen (which is very valuable to them!). Let''s improve
    this by changing the layout of our `CryptoWidgetExtensionEntryView` when the system
    is displaying a medium-sized version. We can make use of the extra space to display
    more than just one coin at a time. Remove the implementation of `CryptoWidgetExtensionEntryView`
    and use the following one:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，对于一个用户来说，这个结果将会非常令人失望。我们显示的信息与小型小部件完全相同，但在他们的主页上占据了更多的空间（这对他们来说非常宝贵！）让我们通过更改系统显示中等尺寸版本时我们的`CryptoWidgetExtensionEntryView`的布局来改进这一点。我们可以利用额外的空间一次显示不止一种货币。删除`CryptoWidgetExtensionEntryView`的实现，并使用以下代码：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s discuss the numbered comments in the code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论代码中的编号注释：
- en: We are using the `@Environment(\.widgetFamily)` variable, which allows us to
    know which widget family is being used. Based on that info, we can use different
    layouts for different sizes.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`@Environment(\.widgetFamily)`变量，它允许我们知道正在使用哪个小部件家族。基于这个信息，我们可以为不同尺寸使用不同的布局。
- en: The view has to declare its body with `@ViewBuilder` because the type of view
    it uses varies.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图必须使用`@ViewBuilder`声明其主体，因为它使用的视图类型是可变的。
- en: We use the `family` (`widgetFamily`) property to switch over it and provide
    different views for different widget sizes. For the small-sized widget, we keep
    using the `CoinDetail` view as before.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`family`（`widgetFamily`）属性来切换它，并为不同尺寸的小部件提供不同的视图。对于小型小部件，我们继续使用之前的`CoinDetail`视图。
- en: For the medium-sized widget, we use a combination of views that let us display
    the details of a coin and a list of other coins by its side. In this way, we add
    more value and use the space available to provide extra info to the user.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于中等尺寸的小部件，我们使用一种视图组合，使我们能够显示一种硬币的详细信息及其旁边的其他硬币列表。通过这种方式，我们增加了价值，并利用可用空间为用户提供更多信息。
- en: Finally, we use `Placeholder` for the `default` case of the switch.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`Placeholder`来处理开关的`default`情况。
- en: 'Now you can resume the preview to see the changes. The medium-sized group should
    look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以恢复预览以查看更改。中等尺寸的组应该看起来像这样：
- en: '![Figure 16.11 – Medium-sized widget'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.11_B14717.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.11 – Medium-sized widget
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Great! We now have a different widget for the medium-sized family that provides
    some extra value to the user! We still have one important task ahead. The data
    that we are displaying in both the small and medium sizes is just dummy data.
    Also, we are not letting the user choose which coin they want to display in the
    small-sized widget; we are forcing it to display Bitcoin, and they may not be
    interested in that one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to provide the widget with a dynamic
    configuration (so the user can configure options for the widget) and how to display
    real data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Providing the widget with data and configuration
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have a widget with various sizes and a placeholder view
    that is displaying dummy data about cryptocurrencies. In this section, we will
    swap that dummy data with real data coming from an API, and we will also let the
    user configure some options to personalize the widget even more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't follow along with the previous section, you can use the project
    named `CryptoWidget_2_medium_widget`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by providing the widget with real data. The entity that is providing
    the entries (and therefore the data) to the widget view is `Provider`. Somehow,
    we need `Provider` to be aware of our data source and serve incoming data to the
    views. In our main app, the struct responsible for providing data is `DataManager`.
    Go ahead and add the following property to the `Provider` struct, in the `CryptoWidgetExtension.swift`
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are adding an instance of `DataManager` to the widget's `Provider`. Note
    that we are marking this property with the `@ObservedObject` tag. If you haven't
    used it in SwiftUI before, whenever an observable property wrapped with this tag
    changes, it invalidates any view that depends on it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time that `DataManager` changes, the views that depend on it will invalidate
    and refresh to reflect those changes. Now, we can delete the dummy data from `Provider`
    and use the data manager instead. Remove this line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you build the project, you will get three compile errors—one in each provider's
    method, where we were using the `coins` property that we just deleted. Go ahead
    and use the `dataManager.coins.data` property instead of the deleted coins one.
    This property from `dataManager` contains the real data retrieved from the API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, launch the main app, remove the previous widget from the device, and add
    it again to the home screen. You should see something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12 – Widget gallery'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.12_B14717.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.12 – Widget gallery
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: That is excellent news! This is no longer dummy data; we have up to five coins
    in the list with real values (remember that these values will not be up to date
    if you are using the sandbox endpoint, as discussed at the beginning of the chapter).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Now we have real values showing in the widget. The final step is going to be
    to improve the small-sized widget a little bit. Currently, the small-sized widget
    shows the price of Bitcoin. But the user may be interested in other cryptocurrencies.
    We will use a configuration intent to allow the user to input configuration values
    and make our widgets more dynamic.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the chapter, when we added the widget extension to the main
    app, we selected the `CryptoWidgetExtension.intentdefinition` inside the widget
    extension folder. This is a Siri intent definition file, where we can configure
    the options that our widget will accept as user input. Let's configure the intent
    definition for our specific case. We want the user to be able to select a coin
    from a predefined list of coin names, to display the price of that coin in the
    small-sized widget.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an enum with the following values: `BTC`, `LTC`, and
    `ETH`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `CryptoWidgetExtension.intentdefinition` file. In the `coinSelect`
    and change the type to **Add Enum**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This action will take you forward to creating a new enum. Call the enum `Coin
    Select` and add the following values:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`. `LTC`'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2`. `ETH`'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3`. `BTC`'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It should look like this:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.13 – Coin Select enum configuration'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_16.13_B14717.jpg)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.13 – Coin Select enum configuration
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now go back to the **Configuration** section of the intent. You can uncheck
    the **Siri can ask for value when run** option. Make sure that the other options
    are set as in the following screenshot:![Figure 16.14 – Custom Intent configuration
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.14_B14717.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.14 – Custom Intent configuration
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the custom intent configured like this and the enum created to display
    some list values, we are ready to use this intent in our widget.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go back to the `CryptoWidgetExtension.swift` file and check the `SimpleEntry`
    definition. Inside each entry, we have access to the `configuration` property
    (which is an instance of the `ConfigurationIntent` that we just configured). This
    means that we have access to the custom intent values every time we access an
    entry.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in `CryptoWidgetExtensionEntryView`, we have an `entry` available (of course!
    It is the data that we want to display). Therefore, we have access to the configuration
    intent inside it. Let's make use of it then! We are going to modify the `.systemSmall`
    switch case to use the configuration intent information and display different
    coins, instead of just displaying Bitcoin.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go ahead and locate the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Replace it with this new one:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Go to the main app settings and, under the `ConfigurationIntent` intent under
    the **Supported Intents** section, as in the following screenshot:![Figure 16.15
    – Adding your intent to the Supported Intents section
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.15_B14717.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.15 – Adding your intent to the Supported Intents section
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project again, and the compile errors should be gone.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you still have any errors, try the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您仍然有任何错误，请尝试以下操作：
- en: a) Compile and run the target of the main app.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 编译并运行主应用的目标。
- en: b) Run the target of the widget. Delete the widget from the simulator and add
    it again (the small-sized one).
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 运行小部件的目标。从模拟器中删除小部件并再次添加（小尺寸的那个）。
- en: Now, if you long-press over the small-sized widget on the device (or simulator),
    you should be able to see the **Edit Widget** option. It will display your new
    custom intent, as in the following screenshot:![Figure 16.16 – Widget configuration
    options
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您在设备上的小尺寸小部件（或模拟器）上长按，您应该能够看到“编辑小部件”选项。它将显示您的新自定义意图，如下面的截图所示：![图16.16 –
    小部件配置选项
- en: '](img/Figure_16.16_B14717.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_16.16_B14717.jpg)'
- en: Figure 16.16 – Widget configuration options
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.16 – 小部件配置选项
- en: Try selecting **ETH** or **LTC**. Then, your widget will reload and display
    that coin! This is great; we now have a configurable crypto widget.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试选择**ETH**或**LTC**。然后，您的小部件将重新加载并显示该货币！这太棒了；我们现在有一个可配置的加密货币小部件。
- en: In this section, we learned how to make a widget configurable using a Siri intent,
    so the user is able to select values and edit the widget from the home screen.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Siri意图使小部件可配置，因此用户可以从主屏幕选择值并编辑小部件。
- en: Now, there is another topic that we haven't discussed yet. In the `Provider`
    struct, we learned that the `getTimeline(…)` method will provide the widget with
    an array of values to display over time, to refresh the information being displayed
    and stay up to date. But we didn't discuss how we control when the widget is actually
    refreshing, or even whether we are in control of it. We are going to learn about
    this in the next section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有一个我们尚未讨论的话题。在`Provider`结构体中，我们了解到`getTimeline(…)`方法将为小部件提供一系列值，以在一段时间内显示，以刷新显示的信息并保持最新。但我们没有讨论如何控制小部件实际刷新的时间，甚至是否在我们控制之下。我们将在下一节中学习这一点。
- en: Refreshing the widget's data
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新小部件的数据
- en: Keeping widgets up to date consumes system resources and can require significant
    battery usage. For this reason, the system will limit the number of updates that
    each widget can perform during the day in order to save battery life.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 保持小部件更新需要消耗系统资源，并可能需要大量的电池使用。因此，系统将限制每个小部件在一天内可以执行更新的次数，以节省电池寿命。
- en: With this idea in mind, we have to understand that we don't have full control
    over our widget's refresh time and frequency, and that widgets are not always
    active. We are able to give the system some hints about when would be ideal for
    our widget to refresh, but ultimately, the system will decide it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个想法，我们必须理解我们并没有完全控制我们小部件的刷新时间和频率，并且小部件并不总是处于活跃状态。我们能够给系统一些提示，关于何时对我们的小部件刷新是最理想的，但最终决定权在系统手中。
- en: 'The system uses a budget to distribute reloads over time. That budget is affected
    by the following factors:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用预算在一段时间内分配重新加载。这个预算受以下因素的影响：
- en: How many times has the widget been displayed to the user?
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件被展示给用户的次数有多少？
- en: When was the last time the widget was reloaded?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件上次重新加载是什么时候？
- en: Is the widget's main app active?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件的主要应用是否处于活跃状态？
- en: The allocated budget for a widget lasts 24 hours. A widget that a user visits
    a lot can get up to 70 refreshes per day, meaning it can update once every 15
    minutes or so.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为小部件分配的预算可以持续24小时。用户频繁访问的小部件每天可以刷新高达70次，这意味着它大约每15分钟更新一次。
- en: 'You can help WidgetKit estimate the best budget for your widget by providing
    as much information as you can in your widget''s `Timeline` method. Some examples
    are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在您小部件的`Timeline`方法中提供尽可能多的信息来帮助WidgetKit估算您小部件的最佳预算。以下是一些示例：
- en: 'A cooking widget that follows a recipe can schedule different steps in the
    timeline to show the cooking steps at certain points in time: preheat the oven
    for 15 minutes, cook for 30 minutes, let it rest for 10 minutes, and so on. That
    would result in a timeline with entries separated over time at specific minutes
    (15 – 30 – 10). WidgetKit will try to refresh your widget at those points in time,
    to display the proper entries.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个遵循食谱的烹饪小部件可以在时间线上安排不同的步骤，在特定时间点显示烹饪步骤：预热烤箱15分钟，烹饪30分钟，休息10分钟，等等。这将导致一个在特定分钟（15
    – 30 – 10）上时间间隔分开的条目时间线。WidgetKit将尝试在这些时间点刷新您的 小部件，以显示适当的条目。
- en: For a widget to remind users to drink water every 2 hours, you may produce a
    timeline to remind users about drinking a glass of water every 2 hours. But you
    can also be more efficient and avoid any refreshes during nighttime when the user
    is sleeping. That will produce a more efficient timeline and save some budget
    that WidgetKit can use to refresh your widget more often when it is really needed.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让小部件每两小时提醒用户喝水，你可以生成一个时间线来提醒用户每两小时喝一杯水。但你可以更有效率，避免在用户睡觉的夜间进行任何刷新。这将产生一个更有效率的时间线，并节省一些
    WidgetKit 可以用来在真正需要时更频繁地刷新你的小部件的预算。
- en: 'Now, in our specific example of the crypto ticker widget, let''s modify the
    timeline to ask WidgetKit to refresh our widget every 5 minutes (a very aggressive
    request!). But we know cryptocurrencies are very volatile and for this example,
    we want to refresh the price as much as possible. Follow these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的特定示例中，让我们修改时间线，让 WidgetKit 每隔5分钟刷新我们的小部件（一个非常激进的要求！）！但我们知道加密货币非常波动，对于这个例子，我们希望尽可能多地刷新价格。按照以下步骤操作：
- en: Go ahead and open the project named `CryptoWidget_4_timeline` from the code
    bundle of this chapter. First, let's create a new method inside `DataManager`
    that allows us to fetch the latest crypto data with a completion block.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请打开名为 `CryptoWidget_4_timeline` 的项目，该项目位于本章的代码包中。首先，让我们在 `DataManager` 中创建一个新的方法，允许我们通过完成块获取最新的加密货币数据。
- en: 'Add the following method to the struct:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到结构体中：
- en: '[PRE26]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See how the method is similar to `getData()`, but this one is not `private`
    and it also returns `coins` inside a `completion` handler for us to use on demand.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看这个方法与 `getData()` 的相似之处，但这个方法不是 `private` 的，并且它还返回 `coins`，以便我们可以在需要时在 `completion`
    处理器中使用。
- en: 'Next, go to the file called `CryptoWidgetExtension.swift` and modify the `getTimeline(…)`
    method inside the `Provider` struct to contain the following implementation instead:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到名为 `CryptoWidgetExtension.swift` 的文件，并修改 `Provider` 结构体中的 `getTimeline(…)`
    方法，用以下实现替换：
- en: '[PRE27]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s see what is happening in the method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看方法中发生了什么：
- en: First, we are using the new method that we created, `refresh(…)`, to get the
    latest values of the crypto coins.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们正在使用我们创建的新方法 `refresh(…)` 来获取加密货币的最新值。
- en: Once we have the coins ready in the completion handler, we are creating a future
    date that is 15 minutes into the future.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在完成处理程序中准备好了硬币，我们就在未来创建一个日期，这个日期是15分钟之后。
- en: Then, we create `Timeline` with a `SimpleEntry` that contains the latest values
    for `coins`, and a refresh policy. The refresh policy is set to create a new timeline
    after 15 minutes have passed (`futureDate`). Usually, 15 minutes is the minimum
    time needed for WidgetKit to update your widget again. If you try lower values,
    you may not get any results.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含 `coins` 最新值的 `SimpleEntry` 的 `Timeline`，以及一个刷新策略。刷新策略设置为在15分钟后创建一个新的时间线（`futureDate`）。通常，15分钟是
    WidgetKit 再次更新你的小部件所需的最短时间。如果你尝试更低的值，你可能不会得到任何结果。
- en: So, to wrap this method up, when WidgetKit requests a timeline from us, we are
    calling our API to get the latest crypto values, then we wrap them in an entry
    ready for the widget views to be displayed, and we establish a refresh policy
    of "after 15 minutes have passed."
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，为了总结这个方法，当 WidgetKit 请求我们时间线时，我们调用我们的API来获取最新的加密货币值，然后我们将它们包装在一个准备显示的小部件视图中，并设置一个“15分钟后”的刷新策略。
- en: 'Now try deleting the app and the widget from the simulator or your device.
    Install both the app and the extension and add a small widget to the home screen.
    The moment you add the widget, you should see in the logs the first statement
    of the timeline method, similar to this:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试从模拟器或你的设备中删除应用程序和小部件。安装应用程序和扩展，并在主屏幕上添加一个小部件。当你添加小部件时，你应该在日志中看到时间线方法的第一个语句，类似于以下内容：
- en: '[PRE28]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, after 15 minutes, you should see it appearing again. The refresh policy
    has kicked in, and we have provided a refreshed version with the latest values
    again:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，15分钟后，你应该再次看到它出现。刷新策略已经启动，我们再次提供了一个带有最新值的刷新版本：
- en: '[PRE29]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Great! We know now how to refresh our widgets! Just a last note: there are
    more refresh policies other than `.after`. Here are the options:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在知道如何刷新我们的小部件了！最后提醒一下：除了 `.after` 之外，还有更多的刷新策略。以下是选项：
- en: '`TimelineReloadPolicy.after(Date)`: A new timeline will be generated after
    the specific date has passed.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimelineReloadPolicy.after(Date)`: 在特定日期过后将生成一个新的时间线。'
- en: '`TimelineReloadPolicy.atEnd`: A new timeline will be generated after the last
    entry of the current timeline passes.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimelineReloadPolicy.atEnd`：在当前时间线的最后一条条目通过之后，将生成一个新的时间线。'
- en: '`TimelineReloadPolicy.never`: The widget''s app will be responsible for letting
    WidgetKit know when the next timeline is ready.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimelineReloadPolicy.never`：小部件的应用将负责让WidgetKit知道何时下一个时间线准备就绪。'
- en: In this section, we learned the basics of how WidgetKit decides when to refresh
    your widgets, and how we can provide timelines and refresh policies so that the
    system has a better idea of when we want our widgets to be updated. Now, let's
    wrap up the chapter with a summary.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了WidgetKit如何决定何时刷新您的小部件，以及我们如何提供时间线和刷新策略，以便系统更好地了解我们希望何时更新小部件。现在，让我们通过总结来结束本章。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started the chapter by learning about the basics of widgets and WidgetKit.
    We learned about the general guidelines, the basic options, and their purpose.
    After that intro, we jumped straight into developing our first widget. We started
    by adding a small-sized widget to an existing app.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习小部件和WidgetKit的基础知识开始本章。我们了解了通用指南、基本选项及其目的。在介绍之后，我们直接进入了开发我们的第一个小部件。我们首先向现有应用中添加了一个小型小部件。
- en: Then, we added a placeholder view to the widget so that it gives the user a
    good idea of what the widget would look like the first time it loads. After that,
    we created a bigger, medium-sized widget version that is able to display much
    more information and provide more value than the small-sized widget.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在小部件中添加了一个占位符视图，以便用户对首次加载时小部件的外观有一个良好的概念。之后，我们创建了一个更大、中等大小的版本，它能够显示比小型小部件多得多的信息，并提供更多的价值。
- en: Finally, we learned how to make the widget configurable by the user with the
    help of Siri custom intents. By using a custom intent, users are able to provide
    certain configuration values to the widget to personalize the experience.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何在Siri自定义意图的帮助下使小部件可由用户配置。通过使用自定义意图，用户能够向小部件提供某些配置值以个性化体验。
- en: In this chapter, you learned how to create widgets and make the most out of
    WidgetKit. In the next chapter, we will learn about ARKit, the augmented reality
    framework from Apple.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建小部件并充分利用WidgetKit。在下一章中，我们将学习关于ARKit的知识，这是苹果公司的增强现实框架。
