- en: '*Chapter 16*: Creating Your First Widget'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With iOS 14, Apple introduced WidgetKit. Users are now able to use widgets on
    their home screens. By displaying small amounts of useful information on the home
    screen, widgets provide a key functionality to users that was long-awaited. Some
    examples are checking stock market prices, weather or traffic conditions, the
    next meeting on your calendar, and so on with just a glance at the home screen.
    The use cases are limitless!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the basic foundations of WidgetKit, as
    well as the key aspects of widget design and their limitations. Then, we will
    build a widget from scratch. Starting with a very simple, small-sized widget,
    we will extend its capabilities by creating new sizes, network calls, dynamic
    configurations, placeholder views, and much more! We will discuss all these topics
    in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing widgets and WidgetKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing your first widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create your own widgets to enable
    your apps to provide a unique new feature so that users will download your app
    and engage with it much more.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code bundle for this chapter includes a starter project called `CryptoWidget_1_small_start`
    and subsequent parts. You can find them in the code bundle repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing widgets and WidgetKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about the basics of WidgetKit and the
    options and guidelines for widgets in iOS 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users and developers have been requesting a particular feature for years: they
    all wanted to have widgets on their home screen. Widgets allow users to configure,
    personalize, and consume little pieces of relevant data from their home screen.
    They also enable developers to offer users glanceable content and create added
    value to their apps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a preview of what a **widget** (in this case, the Calendar and Reminders
    widgets) looks like on the home screen of the iPhone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – iOS home screen with widgets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.01_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – iOS home screen with widgets
  prefs: []
  type: TYPE_NORMAL
- en: This is now possible on iOS 14 and macOS 11 and later. Developers can create
    widgets across iOS, iPadOS, and macOS using **WidgetKit** and the new **widget
    API** for SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart Stack** on iOS 14 contains a set of different widgets, including ones
    that the user opens frequently. If the user enables **Smart Rotate**, Siri can
    highlight relevant widgets within custom stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Widgets created on iOS 13 and earlier
  prefs: []
  type: TYPE_NORMAL
- en: Widgets created before iOS 14 can't be placed on the home screen, but they are
    still available on the Today view and in the macOS Notification Center.
  prefs: []
  type: TYPE_NORMAL
- en: After this intro to the new widget feature, let's see what options we have when
    building a widget and what the design guidelines from Apple are.
  prefs: []
  type: TYPE_NORMAL
- en: Widget options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users can place widgets on the home screen or the Today view on iOS, the Today
    view on iPad, or the Notification Center on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Widgets come in three sizes: small, medium, and large. Each size should have
    a different purpose; a bigger version of a widget should not just be the same
    as the small one but with bigger font and images. The idea behind having different
    sizes for a widget is that the bigger the size, the more information it should
    contain. For example, a weather widget will provide just the current temperature
    in the small-sized version, but it will also include the weekly forecast in the
    medium-sized one.'
  prefs: []
  type: TYPE_NORMAL
- en: Users can arrange widgets on different parts of their screen, and even create
    stacks of widgets to group them up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to develop a widget, developers need to create a new extension for
    their app: a **widget extension**. They can configure the widget with a timeline
    provider. A timeline provider updates the widget information when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a widget needs some configuration (for example, selecting a default
    city in a weather app, or multiple cities to display in a large-sized weather
    widget). In that case, developers should add a custom Siri intent to the widget
    extension. Creating a custom Siri intent automatically provides the widget with
    a customization interface for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Widget guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a widget for iOS 14 or macOS 11, take into account the following
    design guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Focus your widget on the main feature of your app. For example, if your app
    is about the stock market, your widget could display the user portfolio's total
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each widget size should display a different amount of information. If your cycling
    tracker widget displays the current calories burned today in the small size, it
    can also display the week's calories per day in the medium size, and add extra
    info such as the number of km/miles traveled on the big size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer dynamic information that changes during the day to fixed information;
    it will make your widget more appealing to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer simple widgets with fewer configuration options to the opposite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets offer tap target and detection, letting the user select and tap on them
    to open detailed information in the app. Small-sized widgets support a single
    tap target; medium- and big-sized widgets support multiple targets. Try to keep
    it simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support dark mode. Also consider using SF Pro as the font and SF Symbols if
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about the new widget feature and WidgetKit. We covered
    the different options available and the design guidelines when building a widget.
    In the next section, we will start building a simple widget from scratch, and
    we will add more features step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Developing your first widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use an existing app to create a widget on top of it
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: The app that we will work on is a crypto ticker, in which the user can check
    the latest prices of different cryptocurrencies. We will create a widget that
    will allow users to glance at crypto prices from their home screen, so they don't
    have to open the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and open the project named `CryptoWidget_start` from the code bundle
    of this chapter. This is the base project on top of which we will build our widget.
    Before jumping into the task, let's do a quick review of the base project itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and launch the project. The app displays a list of cryptocurrencies''
    prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Base app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.02_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – Base app
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also go into a detailed view of each coin, but just for demo purposes,
    it doesn''t contain additional info. As we are going to work with an existing
    code base, let''s highlight some key points before modifying it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is structured into three groups of files (apart from the default-generated
    files and app delegates): `Views`, `Model`, and `Network`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Views` folder contains the `UIView` files of the project. The views have
    been created using SwiftUI. SwiftUI is the recommended way to go when building
    widgets with WidgetKit. Don't worry if you are not familiar with SwiftUI; we will
    only use basic views in this project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `Network` folder, we have a class named `DataManager.swift`. This
    class contains the `getData()` method, which is responsible for fetching the crypto
    prices from the API of CoinMarketCap. You can create a free developer account
    on their website to get up-to-date prices. Otherwise, the demo app uses a demo
    key that gives us historical prices for the cryptos that we are using. If you
    create your own account, you just need to substitute the value of this key with
    your own key: `let apiKeyValue = "b54bcf4d-1bca-4e8e-9a24-22ff2c3d462c"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Model` folder contains basic structs to work with the `getData()` method
    results: `Coin` and `CoinList`. These structs will contain information about the
    crypto symbols and prices from the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the main view of the project, located in the `ContentView.swift`
    file inside the `Views` folder. The `ContentView` struct contains `@ObservedObject
    var dataManager = DataManager()`. The `@ObservedObject` tag indicates that this
    SwiftUI view will observe changes in the `dataManager` struct, and it will refresh/react
    to them. Remember that `dataManager` is the class that we are using to retrieve
    the crypto data from the network, so it makes sense that our main view is observing
    any changes. Check the body of `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The view will display a simple `Loading…` text while `dataManager` is in the
    loading state, and it will display `CoinListView` when `dataManager` finishes
    loading and contains some data. Simple! Now, if you check the implementation of
    `CoinListView.swift`, you will see that it is a simple list displaying the information
    for every coin that it receives as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Nothing too fancy for now! We have, so far, `dataManager`, which calls `getData()`
    to fetch coin information from an API, and `ContentView`, which displays `Loading…`
    text while the data is being called, and displays a list with coin details when
    the coin's information has been retrieved. Everything was done with a few classes
    and a few lines of code… that is the power of SwiftUI! Now that we have a clear
    view of the base project, let's jump into creating a widget extension to start
    building our awesome crypto coin widget!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a widget extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to add a widget to an app is to create a widget extension. Creating
    a widget extension will provide us with a default implementation of the widget
    protocol, which will help us to get the basic pieces ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the extension, let''s review the parts of a widget extension
    displayed in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Widget building blocks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.03_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – Widget building blocks
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding diagram, the following are descriptions of
    the building blocks of a widget extension:'
  prefs: []
  type: TYPE_NORMAL
- en: If the widget is configurable by the user, it will need a custom Siri intent
    configuration definition. For example, a widget that displays stocks can ask the
    user for a configuration to choose what stocks to display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A provider is needed that will provide the data to display on the widget. The
    provider can generate placeholder data (that is, show when the user is browsing
    the widget gallery or loading), a timeline (to represent data over time), and
    a snapshot (the units that compose a timeline).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SwiftUI view to display the data is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When creating a widget target, Xcode will autogenerate placeholders for all
    these classes. Let''s do it now; follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project named `CryptoWidget_start`, go to **File** | **New** | **Target**
    | **Widget Extension**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `CryptoWidgetExtension` as the product name and check the **Include
    Configuration Intent** option:![Figure 16.4 – Widget extension options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.04_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.4 – Widget extension options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Activate** on the following popup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have followed the preceding steps, your project should now contain a
    new target with the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Widget target structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.05_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.5 – Widget target structure
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating the widget extension, Xcode has autogenerated two important files:
    `CryptoWidgetExtension.swift` and `CryptoWidgetExtension.intentdefinition`. Let''s
    focus for now on `CryptoWidgetExtension.swift`. Open it and let''s take a look.
    Check the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, and as discussed before, we have the basic building pieces
    of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: An intent configuration, to allow the user to configure the widget, named `IntentConfiguration`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A provider to provide data to the widget: `Provider()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A view to display the data: `CryptoWidgetExtensionEntryView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CryptoWidgetExtension` struct is tagged as `@main`, meaning that is the
    entry point of the widget. The body is formed of `IntentConfiguration` and `CryptoWidgetExtensionEntryView`,
    which receives an `entry` instance as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file, we also have the autogenerated definitions for the required
    methods of `Provider` (`placeholder()`, `getSnapshot()`, and `getTimeline()`):'
  prefs: []
  type: TYPE_NORMAL
- en: The `placeholder(…)` method will provide the widget with the initial view the
    first time the widget is rendered. The placeholder will give the user a general
    idea of what the widget will look like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `getSnapshot(…in context…)` method will provide the widget with a value
    (entry) to display when the widget needs to be shown in transient situations.
    The `isPreview` property from `context` indicates that the widget is being shown
    in the widget gallery. In those cases, the snapshot has to be fast: those scenarios
    may require the developer to use dummy data and avoid network calls to return
    the snapshot as fast as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getTimeline(…)` method will provide the widget with an array of values
    to display over the current time (and optionally in the future).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another important modifier that we will use later. Just after `.description("This
    is an example widget.")`, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is where we configure the different sizes available for this widget. Later
    on in the chapter, we will add the medium-sized type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at another part of the code. At the end of the file,
    you will find the `Preview` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of the code will allow us to display a preview with SwiftUI of what
    our widget will look like while developing it. If you launch the preview, you
    will see that right now, it just displays the time (go to **Editor** | **Canvas**
    on the top menu of Xcode if you don''t see the preview tab):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Editor canvas preview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.06_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.6 – Editor canvas preview
  prefs: []
  type: TYPE_NORMAL
- en: That is great! We can code and see the final results in real time. Let's analyze
    a bit how we are getting this kind of widget view with the time on it. See how
    we are using `CryptoWidgetExtensionEntryView` as the main view of the preview?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This view is receiving `SimpleEntry` (with just the date) and a plain, empty
    `ConfigurationIntent`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are applying a modifier to the view by creating `previewContext` and
    assigning `WidgetPreviewContext` as `.systemSmall`. By doing this, we are rendering
    the view inside the preview of a small widget!
  prefs: []
  type: TYPE_NORMAL
- en: 'What is `CryptoWidgetExtensionEntryView` doing with `SimpleEntry`? Let''s check
    the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, it is just displaying text with the date! So, in summary, the preview
    is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `SimpleEntry` as the data input for the widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `CryptoWidgetExtensionEntryView` as the main view to display that data
    entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `WidgetPreviewContext` modifier to use a small widget as the canvas
    for the preview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all these concepts in mind, it is time to start creating our own widget.
    Let's modify the preceding structs to display the value of Bitcoin instead of
    a simple date.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if we want to display a coin''s value (Bitcoin, for example) in the
    widget, we need an entry to contain that information. Let''s add an array of `Coin`
    to the properties of the `SimpleEntry` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By storing the `coins` property, the entry can deliver this information to
    the widget''s view later on. If you try to build the project, you will get an
    error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because the `Coin` file is only part of the main app target. We
    need to select `Coin` and all the other files under the `Views`, `Network`, and
    `Model` folders and add them to the widget''s target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Sharing files from the main app to the widget target'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.07_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.7 – Sharing files from the main app to the widget target
  prefs: []
  type: TYPE_NORMAL
- en: After adding the files of the previous screenshot to the widget target, you
    will get new, different errors when compiling. The main reason for all these errors
    is that you have added a new property to `Coin`, and now there are parts in the
    `Provider` struct where we are initializing a `Coin` instance without that new
    property. To fix it, we will add some dummy data (for now) into the `Provider`
    implementation to pass it as the coins when creating any `SimpleEntry` instance
    inside `Provider`. Later on, we will use real data from the API instead of that
    dummy one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code inside the `Provider` struct. Its first line will appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating some fake data to generate a `Coin` array, containing some
    values for Bitcoin and Litecoin. Now, we can use this `coins` value to inject
    it into the three places in which we are creating `SimpleEntry` inside the `Provider`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we inject it inside the `placeholder(…)` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we inject it inside the `getSnapshot(…)` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then inject it inside the `getTimeline(…)` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you may have the exact same problem inside the `CryptoWidgetExtension_Previews`
    struct. The `previews` property is using `SimpleEntry` to display it in the widget.
    You need to add the `coins` property again. Just use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! The project should compile properly now. Try to render the preview to
    see what happens. Oops! You should still see the date/time in the little widget
    and no coin values! Why? We are passing the coin values into the entry to the
    widget, but the view of the widget is not using it yet. Check the current implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have `entry` with coins information inside, but we are only displaying the
    date. We need to modify the view to show the new information! In the main app,
    we have a view that, given a coin, displays its name and price. Let''s use it.
    Change the `CryptoWidgetExtensionEntryView` implementation for this (changes are
    highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and refresh the preview. Great! You should see the price and name
    of Bitcoin on the widget, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Widget showing the Bitcoin price'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.08_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.8 – Widget showing the Bitcoin price
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try it in the simulator, just launch the widget target. Remember
    that you should have launched (at least once) the main app first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned how to add a widget extension to an app. Then,
    we explored the main components and the relationship between them: the provider,
    the entries, the view of the widget, and the preview system of SwiftUI. Finally,
    we modified all these components to adapt them to our needs and created our first
    small widget. In the next section, we will learn how to add a placeholder preview
    and how to add a medium-sized widget too!'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple-size widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we added a widget target to a project and created the
    widget's first view, the small-sized one. Let's do some modifications now in order
    to develop a medium-sized widget, and also a placeholder preview for the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t follow along with the previous section, you can use the project
    named `CryptoWidget_1_small_widget`. Let''s start by adding a placeholder preview
    to the project. When rendering your widget for the first time, WidgetKit will
    render it as a placeholder. In order to render data, it will ask the provider
    for an entry using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But in order to be able to see how it would appear while we develop it, we
    can create a preview of it using SwiftUI. Go ahead and add the following struct
    to the `CryptoWidgetExtension.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'See how we are using the main widget view (`CryptoWidgetExtensionEntryView`)
    as the placeholder view, and we are feeding it with dummy coins data? However,
    the interesting part is the highlighted part: `.redacted(reason: .placeholder)`.
    Now that we have created a placeholder view with dummy data, let''s create a preview
    of it and check what the effect of the `redacted` modifier is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the implementation of `CryptoWidgetExtension_Previews` and add this
    new one, with the modified code highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we are encapsulating the previous `CryptoWidgetExtensionEntryView` view
    inside `Group`. This is because now we want to display a group of previews, `CryptoWidgetExtensionEntryView,`
    and the new `Placeholder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we are adding the newly created `Placeholder` view, and applying to it
    a `previewContext` of a small widget, like before. Compile and resume the preview
    render; you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Placeholder view with a redacted modifier'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.09_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.9 – Placeholder view with a redacted modifier
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you now see the effect of `.redacted(reason: .placeholder)`? SwiftUI is
    replacing labels with placeholder views of them. It is straightforward to create
    a placeholder view of your widgets like this!'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have a small-sized widget and a preview of it. Let's start creating
    a medium-sized version of it. Bigger widgets should use the extra available space
    to provide users with added value. Your medium- or big-sized widget should not
    be a simple, bigger-sized version of the small one. In our case, we are displaying
    the price of Bitcoin in a small size. Now, in the medium size, we will display
    the value of multiple cryptocurrencies at once. The user will get a bigger picture
    of the market with just a glance!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we configured `supportedFamilies` to allow the small
    size of the widget. We need to add the medium size too. You will find it in the
    `CryptoWidgetExtension` struct. Add `.systemMedium` to `supportedFamilies`, so
    the configuration line should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a preview of the medium-sized widget. Go ahead and add a
    new `Group` below the existing one in `CryptoWidgetExtension_Previews`. Add the
    following code just where the existing `Group{ … }` finishes (so you should have
    one group after the other):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'See how this new group of views is the same as the existing one, with the only
    difference being in the highlighted code? We are now displaying the widget and
    its placeholder inside a `systemMedium` preview. If you resume the render, you
    should see these two new previews (apart from the previous small-sized ones):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10 – Medium-sized widget and placeholder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.10_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.10 – Medium-sized widget and placeholder
  prefs: []
  type: TYPE_NORMAL
- en: 'You can imagine how, for a user, this result would be very disappointing. We
    are displaying the exact same information as in the small widget but taking up
    more space on their home screen (which is very valuable to them!). Let''s improve
    this by changing the layout of our `CryptoWidgetExtensionEntryView` when the system
    is displaying a medium-sized version. We can make use of the extra space to display
    more than just one coin at a time. Remove the implementation of `CryptoWidgetExtensionEntryView`
    and use the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the numbered comments in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `@Environment(\.widgetFamily)` variable, which allows us to
    know which widget family is being used. Based on that info, we can use different
    layouts for different sizes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view has to declare its body with `@ViewBuilder` because the type of view
    it uses varies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `family` (`widgetFamily`) property to switch over it and provide
    different views for different widget sizes. For the small-sized widget, we keep
    using the `CoinDetail` view as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the medium-sized widget, we use a combination of views that let us display
    the details of a coin and a list of other coins by its side. In this way, we add
    more value and use the space available to provide extra info to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use `Placeholder` for the `default` case of the switch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can resume the preview to see the changes. The medium-sized group should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11 – Medium-sized widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.11_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.11 – Medium-sized widget
  prefs: []
  type: TYPE_NORMAL
- en: Great! We now have a different widget for the medium-sized family that provides
    some extra value to the user! We still have one important task ahead. The data
    that we are displaying in both the small and medium sizes is just dummy data.
    Also, we are not letting the user choose which coin they want to display in the
    small-sized widget; we are forcing it to display Bitcoin, and they may not be
    interested in that one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to provide the widget with a dynamic
    configuration (so the user can configure options for the widget) and how to display
    real data.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the widget with data and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have a widget with various sizes and a placeholder view
    that is displaying dummy data about cryptocurrencies. In this section, we will
    swap that dummy data with real data coming from an API, and we will also let the
    user configure some options to personalize the widget even more.
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't follow along with the previous section, you can use the project
    named `CryptoWidget_2_medium_widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by providing the widget with real data. The entity that is providing
    the entries (and therefore the data) to the widget view is `Provider`. Somehow,
    we need `Provider` to be aware of our data source and serve incoming data to the
    views. In our main app, the struct responsible for providing data is `DataManager`.
    Go ahead and add the following property to the `Provider` struct, in the `CryptoWidgetExtension.swift`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are adding an instance of `DataManager` to the widget's `Provider`. Note
    that we are marking this property with the `@ObservedObject` tag. If you haven't
    used it in SwiftUI before, whenever an observable property wrapped with this tag
    changes, it invalidates any view that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time that `DataManager` changes, the views that depend on it will invalidate
    and refresh to reflect those changes. Now, we can delete the dummy data from `Provider`
    and use the data manager instead. Remove this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you build the project, you will get three compile errors—one in each provider's
    method, where we were using the `coins` property that we just deleted. Go ahead
    and use the `dataManager.coins.data` property instead of the deleted coins one.
    This property from `dataManager` contains the real data retrieved from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, launch the main app, remove the previous widget from the device, and add
    it again to the home screen. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12 – Widget gallery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.12_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.12 – Widget gallery
  prefs: []
  type: TYPE_NORMAL
- en: That is excellent news! This is no longer dummy data; we have up to five coins
    in the list with real values (remember that these values will not be up to date
    if you are using the sandbox endpoint, as discussed at the beginning of the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Now we have real values showing in the widget. The final step is going to be
    to improve the small-sized widget a little bit. Currently, the small-sized widget
    shows the price of Bitcoin. But the user may be interested in other cryptocurrencies.
    We will use a configuration intent to allow the user to input configuration values
    and make our widgets more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the chapter, when we added the widget extension to the main
    app, we selected the `CryptoWidgetExtension.intentdefinition` inside the widget
    extension folder. This is a Siri intent definition file, where we can configure
    the options that our widget will accept as user input. Let's configure the intent
    definition for our specific case. We want the user to be able to select a coin
    from a predefined list of coin names, to display the price of that coin in the
    small-sized widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an enum with the following values: `BTC`, `LTC`, and
    `ETH`:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `CryptoWidgetExtension.intentdefinition` file. In the `coinSelect`
    and change the type to **Add Enum**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This action will take you forward to creating a new enum. Call the enum `Coin
    Select` and add the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`. `LTC`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2`. `ETH`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3`. `BTC`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.13 – Coin Select enum configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_16.13_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.13 – Coin Select enum configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now go back to the **Configuration** section of the intent. You can uncheck
    the **Siri can ask for value when run** option. Make sure that the other options
    are set as in the following screenshot:![Figure 16.14 – Custom Intent configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.14_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.14 – Custom Intent configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the custom intent configured like this and the enum created to display
    some list values, we are ready to use this intent in our widget.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go back to the `CryptoWidgetExtension.swift` file and check the `SimpleEntry`
    definition. Inside each entry, we have access to the `configuration` property
    (which is an instance of the `ConfigurationIntent` that we just configured). This
    means that we have access to the custom intent values every time we access an
    entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in `CryptoWidgetExtensionEntryView`, we have an `entry` available (of course!
    It is the data that we want to display). Therefore, we have access to the configuration
    intent inside it. Let's make use of it then! We are going to modify the `.systemSmall`
    switch case to use the configuration intent information and display different
    coins, instead of just displaying Bitcoin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go ahead and locate the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with this new one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to the main app settings and, under the `ConfigurationIntent` intent under
    the **Supported Intents** section, as in the following screenshot:![Figure 16.15
    – Adding your intent to the Supported Intents section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.15_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.15 – Adding your intent to the Supported Intents section
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project again, and the compile errors should be gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you still have any errors, try the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Compile and run the target of the main app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Run the target of the widget. Delete the widget from the simulator and add
    it again (the small-sized one).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, if you long-press over the small-sized widget on the device (or simulator),
    you should be able to see the **Edit Widget** option. It will display your new
    custom intent, as in the following screenshot:![Figure 16.16 – Widget configuration
    options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.16_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 16.16 – Widget configuration options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try selecting **ETH** or **LTC**. Then, your widget will reload and display
    that coin! This is great; we now have a configurable crypto widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we learned how to make a widget configurable using a Siri intent,
    so the user is able to select values and edit the widget from the home screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there is another topic that we haven't discussed yet. In the `Provider`
    struct, we learned that the `getTimeline(…)` method will provide the widget with
    an array of values to display over time, to refresh the information being displayed
    and stay up to date. But we didn't discuss how we control when the widget is actually
    refreshing, or even whether we are in control of it. We are going to learn about
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing the widget's data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keeping widgets up to date consumes system resources and can require significant
    battery usage. For this reason, the system will limit the number of updates that
    each widget can perform during the day in order to save battery life.
  prefs: []
  type: TYPE_NORMAL
- en: With this idea in mind, we have to understand that we don't have full control
    over our widget's refresh time and frequency, and that widgets are not always
    active. We are able to give the system some hints about when would be ideal for
    our widget to refresh, but ultimately, the system will decide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system uses a budget to distribute reloads over time. That budget is affected
    by the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: How many times has the widget been displayed to the user?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When was the last time the widget was reloaded?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the widget's main app active?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The allocated budget for a widget lasts 24 hours. A widget that a user visits
    a lot can get up to 70 refreshes per day, meaning it can update once every 15
    minutes or so.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can help WidgetKit estimate the best budget for your widget by providing
    as much information as you can in your widget''s `Timeline` method. Some examples
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A cooking widget that follows a recipe can schedule different steps in the
    timeline to show the cooking steps at certain points in time: preheat the oven
    for 15 minutes, cook for 30 minutes, let it rest for 10 minutes, and so on. That
    would result in a timeline with entries separated over time at specific minutes
    (15 – 30 – 10). WidgetKit will try to refresh your widget at those points in time,
    to display the proper entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a widget to remind users to drink water every 2 hours, you may produce a
    timeline to remind users about drinking a glass of water every 2 hours. But you
    can also be more efficient and avoid any refreshes during nighttime when the user
    is sleeping. That will produce a more efficient timeline and save some budget
    that WidgetKit can use to refresh your widget more often when it is really needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, in our specific example of the crypto ticker widget, let''s modify the
    timeline to ask WidgetKit to refresh our widget every 5 minutes (a very aggressive
    request!). But we know cryptocurrencies are very volatile and for this example,
    we want to refresh the price as much as possible. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and open the project named `CryptoWidget_4_timeline` from the code
    bundle of this chapter. First, let's create a new method inside `DataManager`
    that allows us to fetch the latest crypto data with a completion block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method to the struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See how the method is similar to `getData()`, but this one is not `private`
    and it also returns `coins` inside a `completion` handler for us to use on demand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, go to the file called `CryptoWidgetExtension.swift` and modify the `getTimeline(…)`
    method inside the `Provider` struct to contain the following implementation instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s see what is happening in the method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are using the new method that we created, `refresh(…)`, to get the
    latest values of the crypto coins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have the coins ready in the completion handler, we are creating a future
    date that is 15 minutes into the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create `Timeline` with a `SimpleEntry` that contains the latest values
    for `coins`, and a refresh policy. The refresh policy is set to create a new timeline
    after 15 minutes have passed (`futureDate`). Usually, 15 minutes is the minimum
    time needed for WidgetKit to update your widget again. If you try lower values,
    you may not get any results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, to wrap this method up, when WidgetKit requests a timeline from us, we are
    calling our API to get the latest crypto values, then we wrap them in an entry
    ready for the widget views to be displayed, and we establish a refresh policy
    of "after 15 minutes have passed."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now try deleting the app and the widget from the simulator or your device.
    Install both the app and the extension and add a small widget to the home screen.
    The moment you add the widget, you should see in the logs the first statement
    of the timeline method, similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, after 15 minutes, you should see it appearing again. The refresh policy
    has kicked in, and we have provided a refreshed version with the latest values
    again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! We know now how to refresh our widgets! Just a last note: there are
    more refresh policies other than `.after`. Here are the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TimelineReloadPolicy.after(Date)`: A new timeline will be generated after
    the specific date has passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimelineReloadPolicy.atEnd`: A new timeline will be generated after the last
    entry of the current timeline passes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimelineReloadPolicy.never`: The widget''s app will be responsible for letting
    WidgetKit know when the next timeline is ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned the basics of how WidgetKit decides when to refresh
    your widgets, and how we can provide timelines and refresh policies so that the
    system has a better idea of when we want our widgets to be updated. Now, let's
    wrap up the chapter with a summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by learning about the basics of widgets and WidgetKit.
    We learned about the general guidelines, the basic options, and their purpose.
    After that intro, we jumped straight into developing our first widget. We started
    by adding a small-sized widget to an existing app.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we added a placeholder view to the widget so that it gives the user a
    good idea of what the widget would look like the first time it loads. After that,
    we created a bigger, medium-sized widget version that is able to display much
    more information and provide more value than the small-sized widget.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to make the widget configurable by the user with the
    help of Siri custom intents. By using a custom intent, users are able to provide
    certain configuration values to the widget to personalize the experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create widgets and make the most out of
    WidgetKit. In the next chapter, we will learn about ARKit, the augmented reality
    framework from Apple.
  prefs: []
  type: TYPE_NORMAL
