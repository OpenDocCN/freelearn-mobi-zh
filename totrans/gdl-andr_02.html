<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Basic Build Customization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Basic Build Customization</h1></div></div></div><p>We started out by looking at the uses of Gradle, and creating and converting Android projects. Now it is time to get a better understanding of the build files, to look at some useful tasks, and to explore the possibilities of both Gradle and the Android plugin.</p><p>In this chapter, we will look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the Gradle files</li><li class="listitem" style="list-style-type: disc">Getting started with build tasks</li><li class="listitem" style="list-style-type: disc">Customizing the build</li></ul></div><div class="section" title="Understanding the Gradle files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Understanding the Gradle files</h1></div></div></div><p>When creating a new <a id="id56" class="indexterm"/>project with Android Studio, three Gradle files are generated by default. Two of those files, <code class="literal">settings.gradle</code> and <code class="literal">build.gradle</code>, end up on the top level of the project. Another <code class="literal">build.gradle</code> file is created in the Android app module. This is how the Gradle files are placed in the project:</p><div class="informalexample"><pre class="programlisting">MyApp
├── build.gradle
├── settings.gradle
└── app
    └── build.gradle</pre></div><p>These three files each serve their own purpose, which we will further look into in the upcoming sections.</p><div class="section" title="The settings file"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The settings file</h2></div></div></div><p>For a new <a id="id57" class="indexterm"/>project containing<a id="id58" class="indexterm"/> only an Android app, <code class="literal">settings.gradle</code> looks like this:</p><div class="informalexample"><pre class="programlisting">include ':app'</pre></div><p>The settings file is executed during the initialization phase, and defines which modules should be included in the build. In this example, the <code class="literal">app</code> module is included. Single module projects do not necessarily require a settings file, but multimodule projects do; otherwise, Gradle does not know which modules to include.</p><p>Behind the scenes, Gradle<a id="id59" class="indexterm"/> creates a <code class="literal">Settings</code> object for every settings file, and invokes <a id="id60" class="indexterm"/>the necessary methods from that object. You do not need to know the details of the <code class="literal">Settings</code> class, but it is good to be aware of this.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>A full explanation of the <code class="literal">Settings</code> class<a id="id61" class="indexterm"/> is out of the scope of this book. If you would like to know more, you can find a lot of information in the Gradle documentation (<a class="ulink" href="https://gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html">https://gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html</a>).</p></div></div></div><div class="section" title="The top-level build file"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>The top-level build file</h2></div></div></div><p>The top-level <code class="literal">build.gradle</code> file is where you can configure<a id="id62" class="indexterm"/> options that need to be applied to all <a id="id63" class="indexterm"/>the modules in the project. It contains two blocks by default:</p><div class="informalexample"><pre class="programlisting">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.2.3'
    }
}

allprojects {
    repositories {
        jcenter()
    }
}</pre></div><p>The <code class="literal">buildscript</code> block is where the actual build is configured. We looked at this briefly in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Gradle and Android Studio">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Gradle and Android Studio</em></span>. The <code class="literal">repositories</code> block configures JCenter as a repository. In this case, a repository means a source of dependencies or, in other words, a list of downloadable libraries that we can use in our apps and libraries. JCenter is a well-known Maven repository.</p><p>The <code class="literal">dependencies</code> block is used to configure dependencies for the build process itself. This means that you should not include dependencies that you need for your applications or libraries in the top-level build file. The only dependency that is defined by default is the Android plugin for Gradle. This is required for every Android module, because it is this plugin that makes it possible to execute Android-related tasks.</p><p>The <code class="literal">allprojects</code> block can be used to define properties that need to be applied to all modules. You can take it even <a id="id64" class="indexterm"/>further and create tasks in the <code class="literal">allprojects</code> block. Those <a id="id65" class="indexterm"/>tasks will then be available in all modules.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>As soon as you use <code class="literal">allprojects</code>, the modules are coupled to the project. This means that it will likely be impossible to build the modules separately, without the main project's build file. It might not seem like an issue at first, but later you might decide to separate an internal library into its own project, and then you will need to refactor your build files.</p></div></div></div><div class="section" title="The module build file"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>The module build file</h2></div></div></div><p>The <a id="id66" class="indexterm"/>module-level <code class="literal">build.gradle</code> file contains options that only apply to the <a id="id67" class="indexterm"/>Android app module. It can also override any options from the top-level <code class="literal">build.gradle</code> file. The module build file looks like this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        applicationId "com.gradleforandroid.gettingstarted"
        minSdkVersion 14
        targetSdkVersion 22
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'
}</pre></div><p>We will take a detailed look at the three main blocks.</p><div class="section" title="Plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Plugin</h3></div></div></div><p>The first line applies the<a id="id68" class="indexterm"/> Android application plugin, which is configured as a dependency in the top-level build file, which we discussed earlier. The Android plugin is written and maintained by the Android Tools team at Google, and provides all tasks needed to build, test, and package Android applications and libraries.</p></div><div class="section" title="Android"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Android</h3></div></div></div><p>The biggest <a id="id69" class="indexterm"/>part of the build file is the <code class="literal">android</code> block. This block contains the entire Android-specific configuration, which is available through the Android plugin we applied earlier.</p><p>The only properties that are required are <code class="literal">compileSdkVersion</code> and <code class="literal">buildToolsVersion</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first one, <code class="literal">compileSdkVersion</code>, is the API version of Android that you want to use to compile your app</li><li class="listitem" style="list-style-type: disc">The second one, <code class="literal">buildToolsVersion</code>, is the version of build tools and compilers to use</li></ul></div><p>The build tools contain command-line utilities, such as aapt, zipalign, dx, and renderscript; which are used to produce the various intermediate artifacts that make up your application. You can download the build tools through the SDK Manager.</p><p>The <code class="literal">defaultConfig</code> block configures core properties for the app. The properties in this block override the corresponding entries in the <code class="literal">AndroidManifest.xml</code> manifest file:</p><div class="informalexample"><pre class="programlisting">defaultConfig {
    applicationId "com.gradleforandroid.gettingstarted"
    minSdkVersion 14
    targetSdkVersion 22
    versionCode 1
    versionName "1.0"
}</pre></div><p>The first property in this block is <code class="literal">applicationId</code>. This overrides the package name from the manifest file, but there are some differences between <code class="literal">applicationId</code> and the package name. Before Gradle was used as the default Android build system, the package name in <code class="literal">AndroidManifest.xml</code> had two purposes: it served as the unique identifier of an app, and it was used as the name for the package in the R resource class. Gradle makes it easier to create different versions of your app, using build variants. For example, it is very easy to make a free version and a paid version. These two versions need to have separate identifiers, so they appear as different apps on the Google Play Store, and can both be installed at the same time. The source code and generated R class, however, must retain the same package name at all times. Otherwise, all your source files would need to change, depending on the version you are building. That is why the Android Tools team has decoupled these two different usages of package name. The package, as defined in the manifest file, continues to be used in your source code and your R class, while the package name that is used by the device and Google Play as the unique identifier is now referred to as <span class="emphasis"><em>application id</em></span>. This application ID will become a lot more interesting as we start experimenting with build types.</p><p>The next <a id="id70" class="indexterm"/>two properties in <code class="literal">defaultConfig</code> are <code class="literal">minSdkVersion</code> and <code class="literal">targetSdkVersion</code>. Both of these should look familiar because they have always been defined in the manifest as part of the <code class="literal">&lt;uses-sdk&gt;</code> element. The <code class="literal">minSdkVersion</code> setting is used to configure the minimum API level required to run the app. The <code class="literal">targetSdkVersion</code> setting informs the system that the app is tested on a specific version of Android, and that the operating system does not need to enable any forward-compatibility behavior. This has nothing to do with <code class="literal">compileSdkVersion</code> that we saw earlier.</p><p>The <code class="literal">versionCode</code> and <code class="literal">versionName</code> also have the same function as in the manifest file, and define a version number and a user-friendly version name for your app.</p><p>All values in the build file will override the values in the manifest file. It is therefore not required to define them in the manifest file if you define them in <code class="literal">build.gradle</code>. In case the build file does not contain a value, the manifest values will be used as a fallback.</p><p>The <code class="literal">buildTypes</code> block is where you define how to build and package the different build types of your app. We will take a detailed look at build types in <a class="link" href="ch04.html" title="Chapter 4. Creating Build Variants">Chapter 4</a>, <span class="emphasis"><em>Creating Build Variants</em></span>.</p></div><div class="section" title="Dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Dependencies</h3></div></div></div><p>The <code class="literal">dependencies</code> block<a id="id71" class="indexterm"/> is a part of the standard Gradle configuration (that is why it is placed outside of the <code class="literal">android</code> block) and defines all dependencies for an app or library. By default, a new Android app has a dependency on all the JAR files in the <code class="literal">libs</code> directory. Depending on the options you select in the new project wizard, it might also depend on the <code class="literal">AppCompat</code> library. We will discuss dependencies in <a class="link" href="ch03.html" title="Chapter 3. Managing Dependencies">Chapter 3</a>, <span class="emphasis"><em>Managing Dependencies</em></span>.</p></div></div></div></div>
<div class="section" title="Getting started with tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Getting started with tasks</h1></div></div></div><p>To know which tasks are<a id="id72" class="indexterm"/> available on a project, you can run <code class="literal">gradlew tasks</code>, which prints out a list of all the available tasks. In a newly created Android project, this includes Android tasks, build tasks, build setup tasks, help tasks, install tasks, verification tasks and other tasks. If you want to see not only the tasks, but also their dependencies, you can run <code class="literal">gradlew tasks --all</code>. It is possible to do a dry run of tasks, which prints out all the steps that are executed when running a specific task. This dry run will not actually perform any of these steps, so it is a safe way to see what you can expect to happen when running a certain task. You can do a dry run by adding the parameters <code class="literal">-m</code> or <code class="literal">--dry-run</code>.</p><div class="section" title="Base tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Base tasks</h2></div></div></div><p>The Android plugin for<a id="id73" class="indexterm"/> Gradle makes use of the Java base plugin, which in turn <a id="id74" class="indexterm"/>makes use of the base plugin. These add the standard lifecycle tasks and some common convention properties. The base plugin defines the tasks <code class="literal">assemble</code> and <code class="literal">clean</code>, and the Java base plugin defines the tasks <code class="literal">check</code> and <code class="literal">build</code>. These tasks are not implemented in the base plugin and do not perform any actions; they are used to define a convention for plugins that add the actual tasks that do the work.</p><p>The conventions for <a id="id75" class="indexterm"/>these tasks are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assemble</code> assembles the output(s) of the project</li><li class="listitem" style="list-style-type: disc"><code class="literal">clean</code> cleans the output of the project</li><li class="listitem" style="list-style-type: disc"><code class="literal">check</code> runs all the checks, usually unit tests and instrumentation tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">build</code> runs both <code class="literal">assemble</code> and <code class="literal">check</code></li></ul></div><p>The Java base plugin also adds the concept of source sets. The Android plugin builds on these conventions, and thus exposes tasks that experienced Gradle users are used to seeing. On top of those base tasks, the Android plugin also adds a lot of Android-specific tasks.</p></div><div class="section" title="Android tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Android tasks</h2></div></div></div><p>The <a id="id76" class="indexterm"/>Android plugin extends<a id="id77" class="indexterm"/> the base tasks and implements their behavior. This is what the tasks do in an Android environment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assemble</code> creates an APK for every build type</li><li class="listitem" style="list-style-type: disc"><code class="literal">clean</code> removes all the build artifacts, such as the APK files</li><li class="listitem" style="list-style-type: disc"><code class="literal">check</code> performs Lint checks and can abort the build if Lint detects an issue</li><li class="listitem" style="list-style-type: disc"><code class="literal">build</code> runs both <code class="literal">assemble</code> and <code class="literal">check</code></li></ul></div><p>The <code class="literal">assemble</code> task depends on <code class="literal">assembleDebug</code> and <code class="literal">assembleRelease</code> by default, and more tasks if you add more build types. This means running <code class="literal">assemble</code> will trigger a build for every build type you have.</p><p>Besides extending<a id="id78" class="indexterm"/> these tasks, the Android plugin also adds a few new ones. These <a id="id79" class="indexterm"/>are the most significant new tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">connectedCheck</code> runs tests on a connected device or emulator</li><li class="listitem" style="list-style-type: disc"><code class="literal">deviceCheck</code> is a placeholder task for other plugins to run tests on remote devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">installDebug</code> and <code class="literal">installRelease</code> install a specific version to a connected device or emulator</li><li class="listitem" style="list-style-type: disc">All <code class="literal">install</code> tasks also have <code class="literal">uninstall</code> counterparts</li></ul></div><p>The <code class="literal">build</code> task depends on <code class="literal">check</code>, but not on <code class="literal">connectedCheck</code> or <code class="literal">deviceCheck</code>. This is to make sure that regular checks do not require a connected device or running emulator. Running the check tasks generates a Lint report with a list of all warnings and errors, with a detailed explanation and a link to the related documentation. This report can be found in <code class="literal">app/build/outputs</code> and is called <code class="literal">lint-results.html</code>. It looks like this:</p><div class="mediaobject"><img src="graphics/B01061_02_01.jpg" alt="Android tasks"/></div><p>When you assemble a release, Lint will check for fatal issues that could cause the app to crash. If it finds any issues, it will abort the build and print the errors to the command-line interface. Lint will also generate a report in <code class="literal">app/build/outputs</code> in a file called <code class="literal">lint-results-release-fatal.html</code>. If you have multiple issues, going through the HTML report is more pleasant than scrolling back and forth in the command-line interface. The provided links are also extremely useful, because they take you to detailed explanations of the issues.</p></div><div class="section" title="Inside Android Studio"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Inside Android Studio</h2></div></div></div><p>You do not always have to run Gradle tasks<a id="id80" class="indexterm"/> from the command-line interface. Android<a id="id81" class="indexterm"/> Studio has a tool window that contains a list of all the available tasks. This tool window is called <span class="strong"><strong>Gradle</strong></span> and looks like this:</p><div class="mediaobject"><img src="graphics/B01061_02_02.jpg" alt="Inside Android Studio"/></div><p>From this tool window, you can run a task simply by double-clicking on its name. You can follow the progress of any running task in the <span class="strong"><strong>Gradle Console</strong></span> tool window. If you cannot find these tool windows, you can open them in the <span class="strong"><strong>View</strong></span> menu, under <span class="strong"><strong>Tool Window</strong></span>. This is what the Gradle Console tool window looks like:</p><div class="mediaobject"><img src="graphics/B01061_02_03.jpg" alt="Inside Android Studio"/></div><p>You can also run <a id="id82" class="indexterm"/>tasks from a command-line <a id="id83" class="indexterm"/>interface inside Android Studio, so you can do all app-related work inside the IDE if you like. To run the command, you need to open the <span class="strong"><strong>Terminal</strong></span> tool window. This is a full-blown terminal, so it is possible to run any command from it. You might need to navigate to the top level of the project first, in order to work with the Gradle wrapper.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>
<span class="strong"><strong>Changing the Android Studio terminal</strong></span>
</p><p>It is possible to<a id="id84" class="indexterm"/> configure the terminal inside Android Studio to use a different shell. On Microsoft Windows, for example, the terminal defaults to Command Prompt. If you prefer to use the Git Bash (or any other shell) instead, open the Android Studio settings (under <code class="literal">File</code> and <code class="literal">Settings</code>) and look for <span class="strong"><strong>Terminal</strong></span>. There you can change the shell path. For Git Bash on Microsoft Windows, it looks like this: <code class="literal">C:\Program Files (x86)\Git\bin\sh.exe --login -i</code>.</p></div></div></div></div>
<div class="section" title="Customizing the build"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Customizing the build</h1></div></div></div><p>There are a lot of ways to <a id="id85" class="indexterm"/>customize the build process, and when you are editing the build files in Android Studio, it is recommended to always sync the project with the Gradle files, no matter what you are customizing. This becomes especially important when you start adding dependencies or <code class="literal">BuildConfig</code> fields, which we will talk about soon.</p><p>Android Studio will show a message in the editor as soon as you edit <code class="literal">settings.gradle</code> or <code class="literal">build.gradle</code>, and it is possible to trigger the sync at all times by navigating to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Android</strong></span> | <span class="strong"><strong>Sync Project with Gradle Files</strong></span> or the corresponding button in the toolbar.</p><div class="mediaobject"><img src="graphics/B01061_02_04.jpg" alt="Customizing the build"/></div><p>Under the hood, the Android Studio Sync actually runs the <code class="literal">generateDebugSources</code> task to generate all the necessary classes, based on the configuration in the build files.</p><div class="section" title="Manipulating manifest entries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Manipulating manifest entries</h2></div></div></div><p>We already saw that it is <a id="id86" class="indexterm"/>possible to configure <code class="literal">applicationId</code>, <code class="literal">minSdkVersion</code>, <code class="literal">targetSdkVersion</code>, <code class="literal">versionCode</code>, and <code class="literal">versionName</code> directly from the build files, instead of in the manifest file. There are a few more properties that you can manipulate:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testApplicationId</code> is the application ID for the instrument test APK</li><li class="listitem" style="list-style-type: disc"><code class="literal">testInstrumentationRunner</code> is the name of the JUnit test runner to be used for running your test (see <a class="link" href="ch06.html" title="Chapter 6. Running Tests">Chapter 6</a>, <span class="emphasis"><em>Running Tests</em></span>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">signingConfig</code> (see <a class="link" href="ch04.html" title="Chapter 4. Creating Build Variants">Chapter 4</a>, <span class="emphasis"><em>Creating Build Variants</em></span>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">proguardFile</code> and <code class="literal">proguardFiles</code> (see <a class="link" href="ch09.html" title="Chapter 9. Advanced Build Customization">Chapter 9</a>, <span class="emphasis"><em>Advanced Build Customization</em></span>)</li></ul></div><div class="section" title="Inside Android Studio"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Inside Android Studio</h3></div></div></div><p>Instead of <a id="id87" class="indexterm"/>manually making changes in the<a id="id88" class="indexterm"/> build files, you can also change the basic settings in the <span class="strong"><strong>Project Structure</strong></span> dialog in Android Studio. You can open the dialog from the <span class="strong"><strong>File</strong></span> menu, and it enables you to edit project-wide settings and settings per module. For every Android module, you can change the standard Android plugin properties and all the manifest properties. In the following screenshot, you can see the properties for the release version of the app module in the <span class="strong"><strong>Project Structure</strong></span> dialog:</p><div class="mediaobject"><img src="graphics/B01061_02_05.jpg" alt="Inside Android Studio"/></div><p>Be aware that if <a id="id89" class="indexterm"/>you make any changes in the <a id="id90" class="indexterm"/>
<span class="strong"><strong>Project Structure</strong></span> dialog, Android Studio will write the changes to the Gradle build configuration file.</p></div></div><div class="section" title="BuildConfig and resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>BuildConfig and resources</h2></div></div></div><p>Ever since SDK <a id="id91" class="indexterm"/>tools revision 17, the build tools <a id="id92" class="indexterm"/>generate<a id="id93" class="indexterm"/> a class called <code class="literal">BuildConfig</code>, which contains a <code class="literal">DEBUG</code> constant that is set according to the build type. This is useful if you have code that you only want to run when debugging, such as logging. It is possible through Gradle to extend that file so that you can have constants that contain different values in debug and release.</p><p>These constants are useful for toggling features or setting server URLs, for example:</p><div class="informalexample"><pre class="programlisting">android {
    buildTypes {
        debug {
            buildConfigField "String", "API_URL", "\"http://test.example.com/api\""
            buildConfigField "boolean", "LOG_HTTP_CALLS", "true"
        }
        
        release {
            buildConfigField "String", "API_URL", "\"http://example.com/api\""
            buildConfigField "boolean", "LOG_HTTP_CALLS", "false"
        }
    }
}</pre></div><p>The escaped double quotes around the string value are necessary for it to be generated as an actual string. After adding the <code class="literal">buildConfigField</code> lines, it is possible to use <code class="literal">BuildConfig.API_URL</code> and <code class="literal">BuildConfig.LOG_HTTP</code> in your actual Java code.</p><p>More recently, the Android Tools team has also added the possibility to configure resources in a similar manner:</p><div class="informalexample"><pre class="programlisting">android {
    buildTypes {
        debug {
            resValue "string", "app_name", "Example DEBUG"
        }
        
        release {
            resValue "string", "app_name", "Example"
        }
    }
}</pre></div><p>The escaped <a id="id94" class="indexterm"/>double quotes are not necessary here, because resource values <a id="id95" class="indexterm"/>are always wrapped with <code class="literal">value=""</code> by default.</p></div><div class="section" title="Project-wide settings"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Project-wide settings</h2></div></div></div><p>If you have multiple Android <a id="id96" class="indexterm"/>modules in one project, it can be useful to apply settings to all of them without manually changing the build file for every module. We already saw how the <code class="literal">allprojects</code> block is used in the generated top-level build file to define repositories, and you can use the same strategy to apply Android-specific settings as well:</p><div class="informalexample"><pre class="programlisting">allprojects {
    apply plugin: 'com.android.application'
    
    android {
        compileSdkVersion 22
        buildToolsVersion "22.0.1"
    }
}</pre></div><p>This will only work if all your modules are Android app projects though, because you need to apply the Android plugin to get access to the Android-specific settings. A better way to achieve this behavior is to define the values in the top-level build file, and then apply them in the modules. It is possible in Gradle to add extra ad hoc properties on the <code class="literal">Project</code> object. This means that any <code class="literal">build.gradle</code> file can define extra properties, and this happens in an <code class="literal">ext</code> block.</p><p>You can add an <code class="literal">ext</code> <a id="id97" class="indexterm"/>block with custom properties to the top-level build file:</p><div class="informalexample"><pre class="programlisting">ext {
    compileSdkVersion = 22
    buildToolsVersion = "22.0.1"
}</pre></div><p>This makes it possible to use the properties in module-level build files using <code class="literal">rootProject</code>:</p><div class="informalexample"><pre class="programlisting">android {
    compileSdkVersion rootProject.ext.compileSdkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion
}</pre></div></div><div class="section" title="Project properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Project properties</h2></div></div></div><p>The <code class="literal">ext</code> block in the previous<a id="id98" class="indexterm"/> example is a way of defining extra properties. You can use properties to customize a build process on the fly, and we will make use of them when we start writing custom tasks in <a class="link" href="ch07.html" title="Chapter 7. Creating Tasks and Plugins">Chapter 7</a>, <span class="emphasis"><em>Creating Tasks and Plugins</em></span>. There are several ways to define properties, but we will only look at the three most used ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">ext</code> block</li><li class="listitem" style="list-style-type: disc">The <code class="literal">gradle.properties</code> file</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-P</code> command-line parameter</li></ul></div><p>Here is an example <code class="literal">build.gradle</code> file that incorporates those three ways of adding extra properties:</p><div class="informalexample"><pre class="programlisting">ext {
  local = 'Hello from build.gradle'
}

task printProperties &lt;&lt; {
  println local        // Local extra property
  println propertiesFile        // Property from file
  if (project.hasProperty('cmd')) {
    println cmd        // Command line property
  }
}</pre></div><p>This is the accompanying <code class="literal">gradle.properties</code> file (in the same folder):</p><div class="informalexample"><pre class="programlisting">propertiesFile = Hello from gradle.properties</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>In the example, we create a new task. We will look at tasks and explain the syntax in <a class="link" href="ch07.html" title="Chapter 7. Creating Tasks and Plugins">Chapter 7</a>, <span class="emphasis"><em>Creating Tasks and Plugins</em></span>.</p></div></div><p>If you run the <code class="literal">printProperties</code> task <a id="id99" class="indexterm"/>with a command-line parameter, the output will look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradlew printProperties -Pcmd='Hello from the command line'</strong></span>
<span class="strong"><strong>:printProperties</strong></span>
<span class="strong"><strong>Hello from build.gradle</strong></span>
<span class="strong"><strong>Hello from gradle.properties</strong></span>
<span class="strong"><strong>Hello from the command line</strong></span>
</pre></div><p>Thanks to custom properties, changing the configuration of a build is as easy as changing a single property, or even just adding a command-line parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>It is possible to define properties, both in the top-level build file and in the module build files. If a module defines a property that already exists in the top-level file, it will simply override it.</p></div></div></div><div class="section" title="Default tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Default tasks</h2></div></div></div><p>If you run Gradle without <a id="id100" class="indexterm"/>specifying a task, it runs the <code class="literal">help</code> task, which prints some information on how to work with Gradle. This happens because the help task is set as the default task. It is possible to override the default task and have a very common task, or even multiple tasks, run every time you execute Gradle without explicitly specifying the task.</p><p>To specify default tasks, add this line to the top-level <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">defaultTasks 'clean', 'assembleDebug'</pre></div><p>Now, when you run the Gradle wrapper without any parameters, it will run <code class="literal">clean</code> and <code class="literal">assembleDebug</code>. It is easy to see <a id="id101" class="indexterm"/>which tasks are set as default by running the <code class="literal">tasks</code> task and filtering the output.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradlew tasks | grep "Default tasks"</strong></span>
<span class="strong"><strong>Default tasks: clean, assembleDebug</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we took a detailed look at the different Gradle files that are automatically generated by Android Studio. You are now able to create build files yourself, and add all the required fields and configure the key properties.</p><p>We got started with the basic build tasks, and learned how the Android plugin builds on the base plugin, and extends it with new Android-specific tasks. We also saw how to run build tasks both from the command-line interface, and from inside Android Studio.</p><p>In the final part of the chapter, we looked at several ways to influence the output of the build, and ways to configure parts of the build process itself.</p><p>In the last few years, the Android developer ecosystem has grown immensely, and a lot of interesting libraries have become available for everyone to use. In the next chapter, we will look at several ways to add dependencies to a project, so we can take advantage of this abundance of resources.</p></div></body></html>