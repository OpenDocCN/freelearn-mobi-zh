<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Building Blocks &#x2013; Variables, Collections, and Flow Control"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building Blocks – Variables, Collections, and Flow Control</h1></div></div></div><p>One of the coolest things about programming is the way that concepts build on each other. If you've never programmed anything before, even the most basic app can seem very complex. The reality is that, if you analyze everything going on in an app down to the ones and zeros flowing through the processor, it is incredibly complex. However, every aspect of using a computer is an abstraction. When you use an app, the complexity of the programming is being abstracted away for you. Learning to program is just going one level deeper in making a computer work for you.</p><p>As you learn the basic concepts behind programming, they will become second nature and this will free your mind to grasp even more complex concepts. When you first learn to read, sounding out each word is challenging. However, eventually, you reach a level where you glance at a word and you know the meaning instantaneously. This frees you up to start looking for deeper meaning from the text.</p><p>In this chapter, we will build up your knowledge of the building blocks of programming in Swift. Each of these building blocks is exciting on its own and they will become even more exciting as we start to see the possibilities they open up. No matter how complex programming might seem to you now, I guarantee that one day you will look back and marvel at how all of these concepts have become second nature.</p><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Core Swift types</li><li class="listitem" style="list-style-type: disc">Swift's type system</li><li class="listitem" style="list-style-type: disc">Printing to the console</li><li class="listitem" style="list-style-type: disc">Controlling the flow of your program</li><li class="listitem" style="list-style-type: disc">A comprehensive example of all concepts covered</li></ul></div><div class="section" title="Core Swift types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Core Swift types</h1></div></div></div><p>Every <a class="indexterm" id="id14"/>programming language needs to name a piece of information so that it can be referenced later. This is the fundamental way in which code remains readable after it is written. Swift provides a number of core types that help you represent your information in a very comprehensible way.</p><div class="section" title="Constants and variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Constants and variables</h2></div></div></div><p>Swift <a class="indexterm" id="id15"/>provides two types of information: a <span class="strong"><strong>constant</strong></span> and a <span class="strong"><strong>variable:</strong></span></p><div class="informalexample"><pre class="programlisting">// Constant
let pi = 3.14

// Variable
var name = "Sarah"</pre></div><p>All constants <a class="indexterm" id="id16"/>are defined using the <code class="literal">let</code> keyword followed by a name, and all variables are defined using the <code class="literal">var</code> keyword. Both constants and variables in Swift must contain a value before they are used. This means that, when you define a new one, you will most likely give it an initial value. You do so by using the assignment operator (<code class="literal">=</code>) followed by a value.</p><p>The only <a class="indexterm" id="id17"/>difference between the two is that a constant can never be changed, whereas a variable can be. In the preceding example, the code defines a constant called <code class="literal">pi</code> that stores the information <code class="literal">3.14</code> and a variable called <code class="literal">name</code> that stores the information <code class="literal">"Sarah"</code>. It makes sense to make <code class="literal">pi</code> a constant because <code class="literal">pi</code> will always be <code class="literal">3.14</code>. However, we need to change the value of <code class="literal">name</code> in the future so we defined it as a variable.</p><p>One of the hardest parts <a class="indexterm" id="id18"/>of managing a program is the state of all the variables. As a programmer, it is often impossible to calculate all the different possible values a variable might have, even in relatively small programs. Since variables can often be changed by distant, seemingly unrelated code, more states will cause more bugs that are harder to track down. It is always best to default to using constants until you run into a practical scenario in which you need to modify the value of the information.</p></div><div class="section" title="Containers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Containers</h2></div></div></div><p>It is <a class="indexterm" id="id19"/>often helpful <a class="indexterm" id="id20"/>to give a name to more complex information. We often have to deal with a collection of related information or a series of similar information like lists. Swift provides three main collection types called <span class="strong"><strong>tuples</strong></span>, <span class="strong"><strong>arrays</strong></span>, and <span class="strong"><strong>dictionaries</strong></span>.</p><div class="section" title="Tuples"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Tuples</h3></div></div></div><p>A<a class="indexterm" id="id21"/> tuple is <a class="indexterm" id="id22"/>a fixed sized collection of two or more pieces of information. For example, a card in a deck of playing cards has three properties: <code class="literal">color</code>, <code class="literal">suit</code>, and <code class="literal">value</code>. We could use three separate variables to fully describe a card, but it would be better to express it in one:</p><div class="informalexample"><pre class="programlisting">var card = (color: "Red", suit: "Hearts", value: 7)</pre></div><p>Each piece of information consists of a name and a value separated by a colon (<code class="literal">:</code>) and each is separated by a comma (<code class="literal">,</code>). Finally, the whole thing is surrounded by parentheses (<code class="literal">()</code>).</p><p>Each part of a tuple can be accessed separately by name using a period (<code class="literal">.</code>), otherwise referred to as a dot:</p><div class="informalexample"><pre class="programlisting">card.color // "Red"
card.suit // "Hearts"
card.value // 7</pre></div><p>You are also able to create a tuple with no names for each part of it. You can then access them based on where they are in the list, starting with zero as the first element:</p><div class="informalexample"><pre class="programlisting">var diceRoll = (4, 6)
diceRoll.0 // 4
diceRoll.1 // 6</pre></div><p>Another way to access specific values in a tuple is to capture each of them in a separate variable:</p><div class="informalexample"><pre class="programlisting">let (first, second) = diceRoll
first // 4
second // 6</pre></div><p>If you want to change a value in a tuple, you can assign every value at once or you can update a single value, using the same reference as in the preceding code:</p><div class="informalexample"><pre class="programlisting">diceRoll = (4, 5)
diceRoll.0 = 2</pre></div></div><div class="section" title="Arrays"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Arrays</h3></div></div></div><p>An <a class="indexterm" id="id23"/>array is <a class="indexterm" id="id24"/>essentially a list of information of variable length. For example, we could create a list of people we want to invite to a party, as follows:</p><div class="informalexample"><pre class="programlisting">var invitees = ["Sarah", "Jamison", "Marcos", "Roana"]</pre></div><p>An array always starts and ends with a square bracket and each element is separated by a comma. You can even declare an empty array with open and closing brackets: <code class="literal">[]</code>.</p><p>You can then add values to an array by adding another array to it, like this:</p><div class="informalexample"><pre class="programlisting">invitees += ["Kai", "Naya"]</pre></div><p>Note that<code class="literal"> +=</code> is the shorthand for the following:</p><div class="informalexample"><pre class="programlisting">invitees = invitees + ["Kai", "Naya"]</pre></div><p>You can access values in an array based on their position, usually referred to as their index, as shown:</p><div class="informalexample"><pre class="programlisting">invitees[2] // Marcos</pre></div><p>The <a class="indexterm" id="id25"/>index <a class="indexterm" id="id26"/>is specified using square brackets (<code class="literal">[]</code>) immediately after the name of the array. Indexes start at <code class="literal">0</code> and go up from there like tuples. So, in the preceding example, index <code class="literal">2</code> returned the third element in the array, <code class="literal">Marcos</code>. There is additional information you can retrieve about an array, like the number of elements that you can see as we move forward.</p></div><div class="section" title="Dictionaries"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Dictionaries</h3></div></div></div><p>A <a class="indexterm" id="id27"/>dictionary is<a class="indexterm" id="id28"/> a collection of <a class="indexterm" id="id29"/>
<span class="strong"><strong>keys</strong></span> and <span class="strong"><strong>values</strong></span>. Keys<a class="indexterm" id="id30"/> are used to store and look up specific values in the container. This container type is named after a word dictionary in which you can look up the definition of a word. In that real life example, the word would be the key and the definition would be the value. As an example, we can define a dictionary of television shows organized by their genre:</p><div class="informalexample"><pre class="programlisting">var showsByGenre = [
   "Comedy": "Modern Family",
   "Drama": "Breaking Bad",
]</pre></div><p>A dictionary looks similar to an array but each key and value is separated by a colon (<code class="literal">:</code>). Note that Swift is pretty forgiving with how whitespace is used. The array could be defined with each element on its own line and the dictionary could be defined with every element on a single line. It is up to you to use whitespace to make your code as readable as possible.</p><p>With the dictionary defined as shown above, you would get the value <code class="literal">Modern Family</code> if you looked up the key <code class="literal">Comedy</code>. You access a value in code similar to how you would in an array but, instead of providing an index in the square brackets, you provide the key:</p><div class="informalexample"><pre class="programlisting">showsByGenre["Comedy"] // Modern Family</pre></div><p>You can define an empty dictionary in a similar way to an empty array but with a dictionary you must also include a colon between the brackets: <code class="literal">[:]</code>.</p><p>Adding a value to a dictionary is similar to retrieving a value but you use the assignment operator (<code class="literal">=</code>):</p><div class="informalexample"><pre class="programlisting">showsByGenre["Variety"] = "The Colbert Report"</pre></div><p>As a bonus, this can also be used to change the value for an existing key.</p><p>You might have noticed that all of my variable and constant names begin with a lower case letter and each subsequent word starts with a capital letter. This is called camel case and it is the <a class="indexterm" id="id31"/>widely accepted way of writing variable and constant names. Following this convention makes it easier for other programmers to understand your code.</p><p>Now that we <a class="indexterm" id="id32"/>know about Swift's basic containers, let's explore what they are in a little more detail.</p></div></div></div></div>
<div class="section" title="Swift's type system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Swift's type system</h1></div></div></div><p>Swift is a<a class="indexterm" id="id33"/> strongly typed language, which means that every constant and variable is defined with a specific <span class="strong"><strong>type</strong></span>. Only values of matching types can be assigned to them. So far, we have taken advantage of a feature of Swift <a class="indexterm" id="id34"/>called <span class="strong"><strong>Type Inference. </strong></span>This means that the code does not have to explicitly declare a type if it can be inferred from the value being assigned to it during the declaration.</p><p>Without Type Inference, the <code class="literal">name</code> variable declaration from before would be written as follows:</p><div class="informalexample"><pre class="programlisting">var name: String = "Sarah"</pre></div><p>This code is explicitly declaring <code class="literal">name</code> as the type <code class="literal">String</code> with the value <code class="literal">Sarah</code>. A constant or variable's type can be specified by adding a colon (<code class="literal">:</code>) and a type after its name.</p><p>A string is defined by a series of characters. This is perfect for storing text, as in our name example. The reason that we don't need to specify the type is that <code class="literal">Sarah</code> is a <a class="indexterm" id="id35"/>
<span class="strong"><strong>string literal</strong></span>. Text surrounded by quotation marks is a string literal and can be inferred to be of the type <code class="literal">String</code>. That means that <code class="literal">name</code> must be of the type <code class="literal">String</code> if you make its initial value <code class="literal">Sarah</code>.</p><p>Similarly, if we had not used type inference for our other variable declarations, they would look like this:</p><div class="informalexample"><pre class="programlisting">let pi: Double = 3.14

var invitees: [String] = ["Sarah", "Jamison", "Roana"]

let showsByGenre: [String:String] = [
    "Comedy": "Modern Family",
    "Drama": "Breaking Bad",
]</pre></div><p><code class="literal">Double</code> is a numeric type that can store decimal numbers. An array's type is declared by putting the type of element it stores in square brackets. Finally, a dictionary's type is defined in the form <code class="literal">[KeyType:ValueType]</code>. All of these types can be inferred because each of them is assigned to a value that has an inferable type.</p><p>The code is much <a class="indexterm" id="id36"/>cleaner and easier to understand if we leave the types out as the original examples showed. Just keep in mind that these types are always implied to be there, even if they are not written explicitly. If we tried to assign a number to the <code class="literal">name</code> variable, we would get an error, as shown:</p><div class="mediaobject"><img alt="Swift's type system" src="graphics/B05103_02_01.jpg"/></div><p>Here, we are trying to assign a number, specifically an <code class="literal">Int</code>, to a variable that was inferred to be a <code class="literal">String</code>. Swift does not allow that.</p><p>When dealing with inferred types, it is extremely useful to ask Xcode what type a variable is inferred to be. You can do this by holding down the <span class="emphasis"><em>Option </em></span>key on your keyboard and clicking on the variable name. This will display a pop-up that looks like this:</p><div class="mediaobject"><img alt="Swift's type system" src="graphics/B05103_02_02.jpg"/></div><p>As was expected, the variable was indeed inferred to be of the type <code class="literal">String</code>.</p><p>Types are an integral part of Swift. They are one of the major reasons that Swift is so safe as a programming language. They help the compiler learn more about your code and, because of that, the compiler can warn you about bugs automatically without even running your code.</p></div>
<div class="section" title="Printing to the console"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Printing to the console</h1></div></div></div><p>It is <a class="indexterm" id="id37"/>very useful to write output to a log so that you can trace the behavior of code. As a codebase grows in complexity, it gets hard to follow the order in which things happen and exactly what the data looks like as it flows through the code. Playgrounds help a lot with this but it is not always enough.</p><p>In Swift, this process is called printing to the console. To do this, you use something called <code class="literal">print</code>. It is used by writing <code class="literal">print</code> followed by text surrounded by parentheses. For example, to print <code class="literal">Hello World!</code> to the console, the code would look like this:</p><div class="informalexample"><pre class="programlisting">print("Hello World!")</pre></div><p>If you put that code in a playground, you would see <code class="literal">Hello World!</code> written in the results pane. However, this is not truly the console. To view the console, you can go to <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Debug Area</strong></span> | <span class="strong"><strong>Show Debug Area</strong></span>. A new view will appear at the bottom of the window and it will contain all text the code has printed to the console:</p><div class="mediaobject"><img alt="Printing to the console" src="graphics/B05103_02_03.jpg"/></div><p>Not only can you print static text to the console, you can also print out any variable. For example, if you wanted to print out the <code class="literal">name</code> variable, you would write:</p><div class="informalexample"><pre class="programlisting">print(name)</pre></div><p>You can even use a feature of Swift called <a class="indexterm" id="id38"/>
<span class="strong"><strong>string interpolation</strong></span> to insert variables into a string, like this:</p><div class="informalexample"><pre class="programlisting">print("Hello \(name)!")</pre></div><p>At any point in a <a class="indexterm" id="id39"/>string literal, even when not printing, you can insert the results of the code by surrounding the code with <code class="literal">\(</code> and <code class="literal">)</code>. Normally this would be the name of a variable but it could be any code that returns a value.</p><p>Printing to the console is even more useful when we start using more complex code.</p></div>
<div class="section" title="Control flow"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Control flow</h1></div></div></div><p>A program<a class="indexterm" id="id40"/> wouldn't be very useful if it were a single fixed list of commands that always did the same thing. With a single code path, a calculator app would only be able to perform one operation. There are a number of things we can do to make an app more powerful and collect the data to make decisions as to what to do next.</p><div class="section" title="Conditionals"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Conditionals</h2></div></div></div><p>The most <a class="indexterm" id="id41"/>basic way to control the flow of a program is to specify code that should only be executed if a certain condition is met. In Swift, we do that with an <code class="literal">if</code> statement. Let's look at an example:</p><div class="informalexample"><pre class="programlisting">if invitees.count &gt; 20 {
   print("Too many people invited")
}</pre></div><p>Semantically, the <a class="indexterm" id="id42"/>preceding code reads; if the number of invitees is greater then 20, print 'Too many people invited". This example only executes one line of code if the condition is true, but you can put as much code as you like inside the curly brackets (<code class="literal">{}</code>).</p><p>Anything that can be evaluated as either true or false can be used in an <code class="literal">if</code> statement. You can then chain multiple conditions together using an <code class="literal">else if</code> and/or an <code class="literal">else</code>:</p><div class="informalexample"><pre class="programlisting">if invitees.count &gt; 20 {
    print("Too many people invited")
}
else if invitees.count &lt;= 3 {
    print("Not really a party")
}
else {
    print("Just right")
}</pre></div><p>Each condition is checked from top to bottom until a condition is satisfied. At that point, the code block is executed and the remaining conditions are skipped, including the final <code class="literal">else</code> block.</p><p>As an <a class="indexterm" id="id43"/>exercise, I <a class="indexterm" id="id44"/>recommend adding an additional scenario to the preceding code in which, if there were exactly zero invitees, it would print "One is the loneliest number". You can test out your code by adjusting how many invitees you add to the <code class="literal">invitees</code> declaration. Remember that the order of the conditions is very important.</p><p>As useful as conditionals are, they can become very verbose if you have a lot of them chained together. To solve this type of problem, there is another control structure called a <span class="strong"><strong>switch.</strong></span></p></div><div class="section" title="Switches"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Switches</h2></div></div></div><p>A <a class="indexterm" id="id45"/>switch<a class="indexterm" id="id46"/> is a more expressive way of writing a series of <code class="literal">if</code> statements. A direct translation of the example from the conditionals section would look like this:</p><div class="informalexample"><pre class="programlisting">switch invitees.count {
    case let x where x &gt; 20:
        print("Too many people invited")
    case let x where x &lt;= 3:
        print("Not really a party")
    default:
        print("Just right")
}</pre></div><p>A switch consists of a value and a list of conditions for that value with the code to execute if the condition is true. The value to be tested is written immediately after the <code class="literal">switch</code> command and all of the conditions are contained in curly brackets (<code class="literal">{}</code>). Each condition is called a <a class="indexterm" id="id47"/>
<span class="strong"><strong>case</strong></span>. Using that terminology, the semantics of the preceding code is "Considering the number of invitees, in the case that it is greater than 20, print <code class="literal">"Too many people invited"</code>, otherwise, in the case that it is less than or equal to three, print <code class="literal">"Too many people invited"</code>, otherwise, by default print <code class="literal">"Just right"</code>.</p><p>This works by creating a temporary constant <code class="literal">x</code> that is given the value that the switch is testing. It then performs a test on <code class="literal">x</code>. If the condition passes, it executes the code for that case and then exits the switch.</p><p>Just like in conditionals, each case is only considered if all of the previous cases are not satisfied. Unlike conditionals, all the cases need to be exhaustive. That means that you need to have a case for every possible value that the variable being passed in could be. For example, <code class="literal">invitees.count</code> is an integer, so it could theoretically be any value from negative infinity to positive infinity.</p><p>The <a class="indexterm" id="id48"/>most common way to handle that is by using a default case as designated by the <code class="literal">default</code> keyword. Sometimes, you don't actually want to do anything in the default case, or possibly <a class="indexterm" id="id49"/>even in a specific case. For that, you can use the <code class="literal">break</code> keyword, as shown here:</p><div class="informalexample"><pre class="programlisting">switch invitees.count {
    case let x where x &gt; 20:
        print("Too many people invited")
    case let x where x &lt;= 3:
        print("Not really a party")
    default:
        break
}</pre></div><p>Note that the default case must always be the last one.</p><p>We have seen so far that switches are nice because they enforce the condition of  being exhaustive. This is great for letting the compiler catch bugs for you. However, switches can also be much more concise. We can rewrite the preceding code like this:</p><div class="informalexample"><pre class="programlisting">switch invitees.count {
    case 0...3:
        print("Not really a party")
    case 4...20:
        print("Just right")
    default:
        print("Too many people invited")
}</pre></div><p>Here, we have described each case as a range of possible values. The first case includes all of the values between and including <code class="literal">0</code> and <code class="literal">3</code>. This is way more expressive than using a <code class="literal">where</code> clause. This example also shows a rethinking of the logic. Instead of having a case specific for values over <code class="literal">20</code>, we have cases for the closed ranges that we know and then capture everything for the case above <code class="literal">20</code> in the default case. Note that this version of the code does not properly handle the situation in which the count might be negative, whereas the original version did. In this version, if the count were <code class="literal">-1</code>, it would fall all the way through to the default case and print out <code class="literal">"Too many people invited"</code>. For this use case, it is fine because the count of an array can never be negative.</p><p>Switches don't only work with numbers. They are great for performing any type of test:</p><div class="informalexample"><pre class="programlisting">switch name {
    case "Marcos", "Amy":
       print("\(name) is an honored guest")
    case let x where x.hasPrefix("A"):
        print("\(name) will be invited first")
        fallthrough
    default:
        print("\(name) is someone else")
}</pre></div><p>This <a class="indexterm" id="id50"/>code <a class="indexterm" id="id51"/>shows some other interesting features of switches. The first case is actually made up of two separate conditions. Each case can have any number of conditions separated by commas (<code class="literal">,</code>). This is useful when you have multiple cases that you want to use the same code for.</p><p>The second case uses a custom test on the name to see if it starts with the letter A. This is great for demonstrating the way in which switches are executed. Even though the string <code class="literal">Amy</code> would satisfy the second condition, this code would only print, <code class="literal">Amy is an honored guest</code> because the other cases are not evaluated once the first case is satisfied. For now, don't worry if you don't understand completely how <code class="literal">hasPrefix</code> works.</p><p>Lastly, the second case uses the <code class="literal">fallthrough</code> keyword. This tells the program to execute the code in the following case. Importantly, this bypasses the next case's condition; it does not matter if the value passes the condition, the code is still executed.</p><p>To make sure that you understand how a switch is executed, put the following code into a playground and try to predict what will be printed out with various names:</p><div class="informalexample"><pre class="programlisting">let testName = "Andrew"
switch testName {
    case "Marcos", "Amy":
        print("\(testName) is an honored guest")
    case let x where x.hasPrefix("A"):
        print("\(testName) will be invited first")
        fallthrough
    case "Jamison":
        print("\(testName) will help arrange food")
    default:
        print("\(testName) is someone else")
}</pre></div><p>Some good names to try are <code class="literal">Andrew</code>, <code class="literal">Amy</code>, and <code class="literal">Jamison</code>.</p><p>Now we have full control over which code we want executed in which circumstances. However, a program often requires that we execute the same code more than once. For example, if we want to perform an operation on every element in an array, it would not be viable to copy and paste a bunch of code. Instead, we can use control structures called <span class="strong"><strong>loops</strong></span>.</p></div><div class="section" title="Loops"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Loops</h2></div></div></div><p>There <a class="indexterm" id="id52"/>are <a class="indexterm" id="id53"/>many different types of loops but all of them execute the same code repeatedly until a condition is no longer true. The most basic type of loop is called a <code class="literal">while</code> loop:</p><div class="informalexample"><pre class="programlisting">var index = 0
while index &lt; invitees.count {
    print("\(invitees[index]) is invited")

    index+=1
}</pre></div><p>A <code class="literal">while</code> loop <a class="indexterm" id="id54"/>consists of a condition to test and code to be run until that condition fails. In the preceding example, we have looped through every element in the <code class="literal">invitees</code> array. We used the variable <code class="literal">index</code> to track which invitee we were currently on. To move to the next index, we used a new operator <code class="literal">+=</code> which added one to the existing value. This is the same as writing <code class="literal">index = index + 1</code>.</p><p>There are two important things to note about this loop. Firstly, our index starts at <code class="literal">0</code>, not <code class="literal">1</code>, and it goes on until it is less than the number of invitees, not less than or equal to them. This is because, if you remember, array indexes start at <code class="literal">0</code>. If we started at <code class="literal">1</code> we would miss the first element and, if we included <code class="literal">invitees.count,</code> the code would crash because it would try to access an element beyond the end of the array. Always remember: <span class="emphasis"><em>the last element of an array is at the index one less than the count</em></span>.</p><p>The other thing to note is that, if we were to forget to include <code class="literal">index+=1</code> in the loop, we would have an infinite loop. The loop would continue to run forever because <code class="literal">index</code> would never go beyond <code class="literal">invitees.count</code>.</p><p>This pattern of wanting to loop through a list is so common that there is a more concise and safe loop called a <span class="strong"><strong>for-in</strong></span> loop:</p><div class="informalexample"><pre class="programlisting">for invitee in invitees {
    print("\(invitee) is invited")
}</pre></div><p>Now this is getting pretty cool. We no longer have to worry about indexes. There is no risk of accidentally starting at <code class="literal">1</code> or going past the end. Also, we get to give our own name to the specific element as we go through the array. One thing to note is that we did not declare the <code class="literal">invitee</code> variable with <code class="literal">let</code> or <code class="literal">var</code>. This is particular to a <code class="literal">for-in</code> loop because the constant used there is newly declared each time through the loop.</p><p><code class="literal">for-in</code> loops are great for looping through different types of containers. They can also be used to loop through a dictionary, as shown:</p><div class="informalexample"><pre class="programlisting">for (genre, show) in showsByGenre {
    print("\(show) is a great \(genre) series")
}</pre></div><p>In this case, we get access to both the key and the value of the dictionary. This should look familiar because <code class="literal">(genre, show)</code> is actually a tuple used for each iteration through the loop. It may <a class="indexterm" id="id55"/>be confusing to determine whether or not you have a single value from a <code class="literal">for-in</code> loop like arrays or a tuple like dictionaries. At this point, it would be best for you to remember just these two common cases. The underlying reasons will become clear when we start talking about <a class="indexterm" id="id56"/>
<span class="strong"><strong>sequences</strong></span> in <a class="link" href="ch06.html" title="Chapter 6. Make Swift Work For You – Protocols and Generics">Chapter 6</a>, <span class="emphasis"><em>Make Swift Work For You – Protocols and Generics</em></span>.</p><p>Another <a class="indexterm" id="id57"/>feature of <code class="literal">for-in</code> loops is the ability to only loop through elements that pass a given test. You could achieve this with an <code class="literal">if</code> statement but Swift provides a more concise way of writing it using the <code class="literal">where</code> keyword:</p><div class="informalexample"><pre class="programlisting">for invitee in invitees where invitee.hasPrefix("A") {
    print("\(invitee) is invited")
}</pre></div><p>Now, the loop will only be run for each of the invitees that start with the letter <code class="literal">A</code>.</p><p>These loops are great but sometimes we need access to the index we are currently on and, at other times, we may want to loop through a set of numbers without an array. To do this, we can use a range similar to a <code class="literal">Switch</code>, as shown:</p><div class="informalexample"><pre class="programlisting">for index in 0 ..&lt; invitees.count {
    print("\(index): \(invitees[index])")
}</pre></div><p>This code runs the loop using the variable <code class="literal">index</code> from the value <code class="literal">0</code> up to but not including <code class="literal">invitees.count</code>. There are actually two types of ranges. This one is called a <span class="strong"><strong>half open range</strong></span><a class="indexterm" id="id58"/> because it does not include the last value. The other type of range, which we saw with switches, is called a <a class="indexterm" id="id59"/>
<span class="strong"><strong>closed range</strong></span>:</p><div class="informalexample"><pre class="programlisting">print("Counting to 10:")
for number in 1 ... 10 {
    print(number)
}</pre></div><p>The closed range includes the last value so that the loop will print out every number starting with <code class="literal">1</code> and ending with <code class="literal">10</code>.</p><p>All loops have two special keywords that let you modify their behavior, which are called <code class="literal">continue</code> and <code class="literal">break</code>. <code class="literal">continue</code> is used to skip the rest of the loop and move back to the condition to see whether or not the loop should be run again. For example, if we didn't want to print out invitees whose name began with <code class="literal">A</code>, we would use the following:</p><div class="informalexample"><pre class="programlisting">for invitee in invitees {
    if invitee.hasPrefix("A") {
        continue
    }
    print("\(invitee) is invited")
}</pre></div><p>If the condition <code class="literal">invitee.hasPrefix("A")</code> were satisfied, the continue command would be run and it would skip the rest of the loop, moving onto the next invitee. Because of this, only invitees not starting with <code class="literal">A</code> would be printed.</p><p>The <code class="literal">break</code> keyword is used to immediately exit a loop:</p><div class="informalexample"><pre class="programlisting">for invitee in invitees {
   print("\(invitee) is invited")

   if invitee == "Tim" {
       print("Oh wait, Tim can't come")
       break
   }
}
print("Jumps here")</pre></div><p>As soon <a class="indexterm" id="id60"/>as a break is encountered, the execution jumps to after the loop. In this case, it jumps to the final line.</p><p>Loops are great for dealing with variable amounts of data, like our list of invitees. When writing your code, you probably won't know how many people will be in that list. Using a loop gives you the flexibility to handle a list of any length.</p><p>As an exercise, I recommend you try writing a loop to find the sum of all the multiples of 3 under 10,000. You should get 16,668,333.</p><p>Loops are also a great way of reusing code without duplicating it but they are just the first step towards quality code reuse. Next, we will talk about functions, which opens up a whole new world of writing understandable and reusable code.</p></div></div>
<div class="section" title="Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Functions</h1></div></div></div><p>All of the<a class="indexterm" id="id61"/> code we have explored so far is very linear down the file. Each line is processed one at a time and then the program moves onto the next. This is one of the great things about programming: everything the program does can be predicted by stepping through the program yourself mentally, one line at a time.</p><p>However, as your program gets larger, you will notice that there are places that reuse very similar or identical code that you cannot reuse by using loops. Moreover, the more code you write, the harder it becomes to know exactly what it is doing. Code comments can help with that but there is an even better solution to both of these problems and they're called <span class="strong"><strong>functions</strong></span>. A function is essentially a named collection of code that can be executed and reused by using that name.</p><p>There are various different types of functions but each builds on the previous type.</p><div class="section" title="Basic functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Basic functions</h2></div></div></div><p>The most <a class="indexterm" id="id62"/>basic type of function simply has a name with some<a class="indexterm" id="id63"/> static code to be executed later. Let's look at a simple example. The following code defines a function named <code class="literal">sayHello</code>:</p><div class="informalexample"><pre class="programlisting">func sayHello() {
    print("Hello World!")
}</pre></div><p>Functions are defined using the keyword <code class="literal">func</code> followed by a name and parentheses (<code class="literal">()</code>). The code to be run in the function is surrounded by curly brackets (<code class="literal">{}</code>). Just like in loops, a function can consist of any number of lines of code.</p><p>From our knowledge of printing, we know that this function will print out the text <code class="literal">Hello World!</code>. However, when will it do that? The terminology used for telling a function to execute is "calling a function." You call a function by using its name followed by parentheses (<code class="literal">()</code>):</p><div class="informalexample"><pre class="programlisting">sayHello() // Prints "Hello World!"</pre></div><p>This is a very simple function that is not that useful but we can already see some pretty great benefits of functions. In reality, what happens when you call this function is that the execution moves into the function and, when it has finished executing every line of the function, it exits out and continues on from where the function was called. However, as programmers, we are often not concerned with what is happening inside a function unless something has gone wrong. If functions are named well, they tell you what they will do and that is all you need to know to follow the rest of the code. In fact, well-named functions can almost always take the place of comments in your code. This really reduces clutter without harming the legibility of your code.</p><p>The other advantage this function has over using <code class="literal">print</code> directly is that the code becomes more maintainable. If you use <code class="literal">print</code> in multiple places in your code and then change your mind about how you want to say <code class="literal">Hello</code>, you have to change a lot of code. However, if you use a function like the one above, you can easily change how it says <code class="literal">Hello</code> by changing the function and it will then be changed in each place you use that function.</p><p>You may have noticed some similarity in how we have named our <code class="literal">sayHello</code> function and how we used <code class="literal">print</code>. This is because <code class="literal">print</code> is a function that is built into Swift itself. There is complex code in the <code class="literal">print</code> function that makes printing to the console possible and accessible to all programmers. But hey, <code class="literal">print</code> is able to take in a value and do something with it, how do we write a function like that? The answer is: parameters.</p></div><div class="section" title="Parameterized functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Parameterized functions</h2></div></div></div><p>A function <a class="indexterm" id="id64"/>can take zero or more parameters, which are<a class="indexterm" id="id65"/> input values. Let's modify our <code class="literal">sayHello</code> function to be able to say <code class="literal">Hello</code> to an arbitrary name using string interpolation:</p><div class="informalexample"><pre class="programlisting">func sayHelloToName(name: String) {
    print("Hello \(name)!")
}</pre></div><p>Now our function takes in an arbitrary parameter called <code class="literal">name</code> of the type <code class="literal">String</code> and prints <code class="literal">hello</code> to it. The name of this function is now <code class="literal">sayHelloToName:</code>. We didn't include the parameter name because, when you call the method, you don't use the first parameter's name by default:</p><div class="informalexample"><pre class="programlisting">sayHelloToName("World") // Prints "Hello World!"</pre></div><p>We included a colon (<code class="literal">:</code>) at the end of the name to indicate that it takes a parameter there. This makes it different from a function named <code class="literal">sayHelloToName</code> that does not take a parameter. The naming may seem unimportant and arbitrary but it is very important that we are all able to communicate about our code using common and precise terminology, so that we can more effectively learn from and collaborate with each other.</p><p>As mentioned<a class="indexterm" id="id66"/> before, a function can take more than one parameter. A parameter list looks a lot like a tuple. Each parameter is given a name and a type separated by a colon (<code class="literal">:</code>), and these are then separated by commas (<code class="literal">,</code>). On top of that, functions can not only take in values but can also return values to the calling code.</p></div><div class="section" title="Functions that return values"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Functions that return values</h2></div></div></div><p>The type <a class="indexterm" id="id67"/>of value to be returned from a function is defined after the end of all of the parameters separated by an arrow <code class="literal">-&gt;</code>. Let's write a function that takes a list of invitees and one other person to add to the list. If there are spots available, the function adds the person to the list and returns the new version. If there are no spots available, it just returns the original list, as shown here:</p><div class="informalexample"><pre class="programlisting">func addInviteeToListIfSpotAvailable
    (
    invitees: [String],
    newInvitee: String
    )
    -&gt; [String]
{
    if invitees.count &gt;= 20 {
        return invitees
    }
    return invitees + [newInvitee]
}</pre></div><p>In this function, we tested the number of names on the invitee list and, if it was greater than 20, we <a class="indexterm" id="id68"/>returned the same list as was passed in to the <code class="literal">invitees</code> parameter. Note that <code class="literal">return</code> is used in a function in a similar way to <code class="literal">break</code> in a loop. As soon as the program executes a line that returns, it exits the function and provides that value to the calling code. So, the final <code class="literal">return</code> line is only run if the <code class="literal">if</code> statement does not pass. It then adds the <code class="literal">newinvitee</code> parameter to the list and returns that to the calling code.</p><p>You would call this function like so:</p><div class="informalexample"><pre class="programlisting">var list = ["Sarah", "Jamison", "Marcos"]
var newInvite = "Roana"
list = addInviteeToListIfSpotAvailable(list, newInvite: newInvitee)</pre></div><p>It is important to note that we must assign <code class="literal">list</code> to the value returned from our function because it is possible that the new value will be changed by the function. If we did not do this, nothing would happen to the list.</p><p>If you try typing this code into a playground, you will notice something very cool. As you begin typing the name of the function, you will see a small pop-up that suggests the name of the function you might want to type, as shown:</p><div class="mediaobject"><img alt="Functions that return values" src="graphics/B05103_02_04.jpg"/></div><p>You can use the arrow keys to move up and down the list to select the function you want to type and <a class="indexterm" id="id69"/>then press the <span class="emphasis"><em>Tab </em></span>key to make Xcode finish typing the function for you. Not only that, but it highlights the first parameter so that you can immediately start typing what you want to pass in. When you are done defining the first parameter, you can press <span class="emphasis"><em>Tab </em></span>again to move on to the next parameter. This greatly increases the speed with which you can write your code.</p><p>This is a pretty well-named function because it is clear what it does. However, we can give it a more natural and expressive name by making it read more like a sentence:</p><div class="informalexample"><pre class="programlisting">func addInvitee
    (
    invitee: String,
    ifPossibleToList invitees: [String]
    )
    -&gt; [String]
{
    if invitees.count &gt;= 20 {
        return invitees
    }
    return invitees + [invitee]
}
list = addInvitee(newInvite, ifPossibleToList: list)</pre></div><p>This is a great feature of Swift that allows you to have a function called with <a class="indexterm" id="id70"/>
<span class="strong"><strong>named parameters</strong></span>. We can do this by giving the second parameter two names, separated by a space. The first name is the one to be used when calling the function, otherwise referred to as the <a class="indexterm" id="id71"/>
<span class="strong"><strong>external name</strong></span>. The second name is the one to be used when referring to the constant being passed in from within the function, otherwise referred to as the <a class="indexterm" id="id72"/>
<span class="strong"><strong>internal name</strong></span>. As an exercise, try to change the function so that it uses the same external and internal names and see what Xcode suggests. For more of a challenge, write a function that takes a list of invitees and an index for a specific invitee to write a message to ask them to just bring themselves. For example, it would print <code class="literal">Sarah, just bring yourself</code> for the index <code class="literal">0</code> in the preceding list.</p></div><div class="section" title="Functions with default arguments"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Functions with default arguments</h2></div></div></div><p>Sometimes<a class="indexterm" id="id73"/> we write functions where there is a parameter that commonly has the same value. It would be great if we could provide a value for a parameter to be used if the caller did not override that value. Swift has a feature for this called<a class="indexterm" id="id74"/> <span class="strong"><strong>default arguments</strong></span>. To define a default value for an argument, you simply add an equal sign after the argument, followed by the value. We can add a default argument to the <code class="literal">sayHelloToName:</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">func sayHelloToName(name: String = "World") {
    print("Hello \(name)!")
}</pre></div><p>This means that we can now call this function with or without specifying a name:</p><div class="informalexample"><pre class="programlisting">sayHelloToName("World") // Prints "Hello World!"
sayHelloToName() // Also Print "Hello World!"</pre></div><p>When using<a class="indexterm" id="id75"/> default arguments, the order of the arguments becomes unimportant. We can add default arguments to our <code class="literal">addInvitee:ifPossibleToList: </code>function and then call it with any combination or order of arguments:</p><div class="informalexample"><pre class="programlisting">func addInvitee
    (
    invitee: String = "Default Invitee",
    ifPossibleToList invitees: [String] = []
    )
    -&gt; [String]
{
    // ...
}
list = addInvitee(ifPossibleToList: list, newInvite)
list = addInvitee(newInvite, ifPossibleToList: list)
list = addInvitee(ifPossibleToList: list)
list = addInvitee(newInvite)
list = addInvitee()</pre></div><p>Clearly, the call still reads much better when it is written in the same order but not all functions are designed in that way. The most important part of this feature is that you can specify only the arguments that you want to be different from the defaults.</p></div><div class="section" title="Guard statement"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Guard statement</h2></div></div></div><p>The last <a class="indexterm" id="id76"/>feature of functions that we are going to discuss is another type of conditional called a <a class="indexterm" id="id77"/>
<span class="strong"><strong>guard statement</strong></span>. We have not discussed it until now because it doesn't make much sense unless it is used in a function or loop. A guard statement acts in a similar way to an <code class="literal">if</code> statement but the compiler forces you to provide an <code class="literal">else</code> condition that must exit from the function, loop, or switch case. Let's rework our <code class="literal">addInvitee:ifPossibleToList:</code> function to see what it looks like:</p><div class="informalexample"><pre class="programlisting">func addInvitee
    (
    invitee: String,
    ifPossibleToList invitees: [String]
    )
    -&gt; [String]
{
    guard invitees.count &lt; 20 else {
        return invitees
    }
    return invitees + [newInvitee]
}</pre></div><p>Semantically, the <a class="indexterm" id="id78"/>guard statement instructs us to ensure that the number of invitees is less than 20 or else return the original list. This is a reversal of the logic we used before, when we returned the original list if there were 20 or more invitees. This logic actually makes more sense because we are stipulating a prerequisite and providing a failure path. The other nice thing about using the guard statement is that we can't forget to return out of the <code class="literal">else</code> condition. If we do, the compiler will give us an error.</p><p>It is important to note <a class="indexterm" id="id79"/>that guard statements do not have a block of code that is executed if it passes. Only an <code class="literal">else</code> condition can be specified with the assumption that any code you want to run for the passing condition will simply come after the statement. This is safe only because the compiler forces the <code class="literal">else</code> condition to exit the function and, in turn, ensures that the code after the statement will not run.</p><p>Overall, guard statements are a great way of defining preconditions to a function or loop without having to indent your code for the passing case. This is not a big deal for us yet but, if you have lots of preconditions, it often becomes cumbersome to indent the code far enough to handle them.</p></div></div>
<div class="section" title="Bringing it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Bringing it all together</h1></div></div></div><p>At this point, we<a class="indexterm" id="id80"/> have learned a lot about the basic workings of Swift. Let's take a moment to bring many of these concepts together in a single program. We will also see some new variations on what we have learned.</p><p>The goal of the program is to take a list of invitees and a list of television shows and ask random people to bring a show from each genre. It should also ask the rest to just bring themselves.</p><p>Before we look at the code, I will mention the three small new features that I will use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generating a random number</li><li class="listitem" style="list-style-type: disc">Using a variable to store only true or false</li><li class="listitem" style="list-style-type: disc">Repeat-while loops</li></ul></div><p>The most important feature is the ability to generate a random number. To do this, we have to import the <code class="literal">Foundation</code> framework. This is the most basic framework made available by Apple. As the name suggests, it forms the basis of the framework for both OS X and iOS.</p><p><code class="literal">Foundation</code> includes a function called <code class="literal">rand</code> that returns a random number. Computers are actually not capable of generating truly random numbers and, by default, <code class="literal">rand</code> always returns the same values in the same order. To make it return different values each time the program is run, we use a function called <code class="literal">srand</code> that stands for seed random. Seeding random means that we provide a value for <code class="literal">rand</code> on which to base its first value. A common way of seeding the random number is using the current time. We will use a method called <code class="literal">clock</code> that is also from <code class="literal">Foundation</code>.</p><p>Lastly, <code class="literal">rand</code> returns a <a class="indexterm" id="id81"/>number anywhere from <code class="literal">0</code> to a very large number but, as you will see, we want to restrict the random number to between <code class="literal">0</code> and the number of invitees. To do this, we use the remainder operator (<code class="literal">%</code>). This operator gives you the remainder after dividing the first number by the second number. For example, <code class="literal">14 % 4</code> returns <code class="literal">2</code> because <code class="literal">4</code> goes into <code class="literal">14</code>, <code class="literal">3</code> times with <code class="literal">2</code> left over. The great feature of this operator is that it forces a number of any size to always be between <code class="literal">0</code> and <code class="literal">1</code> less than the number you are dividing by. This is perfect for changing all of the possible random values.</p><p>The full code for generating a random number looks like this:</p><div class="informalexample"><pre class="programlisting">// Import Foundation so that "rand" can be used
import Foundation

// Seed the random number generator
srand(UInt32(clock()))

// Random number between 0 and 9
var randomNumber = Int(rand()) % 10</pre></div><p>You may notice one other thing about this code. We are using new syntax <code class="literal">UInt32()</code> and <code class="literal">Int()</code>. This is a way of changing one type into another. For example, the <code class="literal">clock</code> function returns a value of the type <code class="literal">clock_t</code> but <code class="literal">srand</code> takes a parameter of the type <code class="literal">UInt32</code>. Remember, just like with variables, you can hold the option key and click on a function to see what types it takes and returns.</p><p>The second feature we will use a variable that can store only true or false. This is called a <code class="literal">Bool</code>, which is short for Boolean. We have used this type many times before as it is used in all conditionals and loops but this is the first time that we will store a <code class="literal">Bool</code> directly in a variable. At its most basic level, a Boolean variable is defined and used like this:</p><div class="informalexample"><pre class="programlisting">var someBool = false
if someBool {
    print("Do This")
}</pre></div><p>Note that we can use the Boolean directly in a conditional. This is because a Boolean is the exact type a conditional is expecting. All of our other tests like <code class="literal">&lt;=</code> actually result in a <code class="literal">Bool</code>.</p><p>Lastly, the third feature we will use is a variation of the <code class="literal">while</code> loop called a <span class="strong"><strong>repeat-while </strong></span>loop. The only <a class="indexterm" id="id82"/>difference with a <code class="literal">repeat-while</code> loop is that the condition is checked at the end of the loop instead of at the beginning. This is significant because, unlike with a <code class="literal">while</code> loop, a <code class="literal">repeat-while</code> loop will always be executed at least once, as shown:</p><div class="informalexample"><pre class="programlisting">var inviteeIndex: Int
repeat {
    inviteeIndex = Int(rand()) % 5
} while inviteeIndex != 3</pre></div><p>With this loop, we will continue to generate a random number between <code class="literal">0</code> and <code class="literal">4</code> until we get a number that does not equal <code class="literal">3</code>.</p><p>Everything else in the code builds off the concepts we already know. I recommend that you read through the code and try to understand it. Try to not only understand it from the perspective of how it works but why I wrote it in that way. I included comments to help explain both what the code is doing and why it is written in that way:</p><div class="informalexample"><pre class="programlisting">// Import Foundation so that "rand" can be used
import Foundation

// Seed the random number generator
srand(UInt32(clock()))

// -----------------------------
// Input Data
// -----------------------------

// invitees
//
// Each element is a tuple which contains a name
// that is a String and a Bool for if they have been
// invited yet. It is a variable because we will be
// tracking if each invitee has been invited yet. 
var invitees = [
    (name: "Sarah", alreadyInvited: false),
    (name: "Jamison", alreadyInvited: false),
    (name: "Marcos", alreadyInvited: false),
    (name: "Roana", alreadyInvited: false),
    (name: "Neena", alreadyInvited: false),
]

// showsByGenre
//
// Constant because we will not need to modify
// the show list at all
let showsByGenre = [
    "Comedy": "Modern Family",
    "Drama": "Breaking Bad",
    "Variety": "The Colbert Report",
]</pre></div><p>This first <a class="indexterm" id="id83"/>section of code gives us a localized place in which to put all of our data. We can easily come back to the program and change the data if we want and we don't have to go searching through the rest of the program to update it:</p><div class="informalexample"><pre class="programlisting">// -----------------------------
// Helper functions
// -----------------------------

// inviteAtIndex:toBringShow:
//
// Another function to help make future code
// more comprehensible and maintainable
func inviteAtIndex
    (
    index: Int,
    toBringShow show: (genre: String, name: String)
    )
{
    let name = invitees[index].name
    print("\(name), bring a \(show.genre) show")
    print("\(show.name) is a great \(show.genre)")

    invitees[index].alreadyInvited = true
 }

// inviteToBringThemselvesAtIndex:
//
// Similar to the previous function but this time for
// the remaining invitees
func inviteToBringThemselvesAtIndex(index: Int) {
    let invitee = invitees[index]
    print("\(invitee.name), just bring yourself")

    invitees[index].alreadyInvited = true
 }</pre></div><p>Here, I have provided a number of functions that simplify more complex code later on in the program. Each one is given a meaningful name so that, when they are used, we do not have to go and<a class="indexterm" id="id84"/> look at their code to understand what they are doing:</p><div class="informalexample"><pre class="programlisting">// -----------------------------
// Now the core logic
// -----------------------------

// First, we want to make sure each genre is assigned
// to an invitee
for show in showsByGenre {
    // We need to pick a random invitee that has not
    // already been invited. With the following loop
    // we will continue to pick an invitee until we
    // find one that has not already been invited
    var inviteeIndex: Int
    repeat {
        inviteeIndex = Int(rand()) % invitees.count
    } while invitees[inviteeIndex].alreadyInvited

    // Now that we have found an invitee that has not
    // been invited, we will invite them
    inviteAtIndex(inviteeIndex, toBringShow: (show))
}

// Now that we have assigned each genre, we
// will ask the remaining people to just bring
// themselves
for index in 0 ..&lt; invitees.count {
    let invitee = invitees[index]
    if !invitee.alreadyInvited {
        inviteToBringThemselvesAtIndex(index)
    }
}</pre></div><p>This last section contains the real logic of the program, which is commonly referred to as the <span class="strong"><strong>business logic</strong></span>. The functions from the previous section are just details and the final section is the logic that really defines what the program does.</p><p>This is far from the only way to organize a program. This will become even clearer as we learn more advanced organization techniques. However, this breakdown shows you the general philosophy behind how you should organize your code. You should strive to write every piece of code as if it were going to be published in a book. Many of the comments in this example will become excessive as you get better with Swift but, when in doubt, explain what you are doing using either a comment or a well-named function. Not only will it help others understand your code, it will also help you understand it when you come back to it in six months and you are a stranger to the code again. Not only that, if you force yourself to formalize your thoughts as you write the code, you will find yourself creating a lot less bugs.</p><p>Let's also look at <a class="indexterm" id="id85"/>an interesting limitation of this implementation. This program is going to run into a major problem if the number of invitees is less than the number of shows. The <code class="literal">repeat-while</code> loop will continue forever, never finding an invitee that was not invited. Your program doesn't have to handle every possible input but you should at least be aware of its limitations.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we have developed a great basis for Swift knowledge. We have learned about the various built-in mechanisms Swift has for representing complex information in expressive and accessible ways. We know that, by default, we should declare information as a constant until we find a practical need to change it, and then we should make it a variable. We have explored how every piece of information in Swift has a type associated with it by the compiler, whether it is through type inference or declared explicitly. We are familiar with many of the built-in types, including simple types like <code class="literal">String</code>, <code class="literal">Int</code>, and <code class="literal">Bool</code> as well as containers like tuples, arrays, and dictionaries. We can use the console output to better investigate our programs, especially by using string interpolation for dynamic output. We recognize the power of controlling the flow of our programs with <code class="literal">if</code> statements, conditionals, switches, and loops. We have functions in our skill set to write more legible, maintainable, and reusable code. Finally, we have seen an example of how all of these concepts can be combined to write a full program.</p><p>As a challenge to you, I suggest you fix the final program so that it stops trying to assign shows if there are not enough invitees. When you can do that, you are more than ready to move on to the next topic, which is <span class="strong"><strong>types</strong></span>, <span class="strong"><strong>scopes</strong></span>, and <span class="strong"><strong>projects</strong></span>.</p><p>These are all tools that we can use to write even more organized code and they will become more critical as we write larger and larger projects.</p></div></body></html>