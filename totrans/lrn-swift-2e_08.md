# 第8章. 少有人走的路 - 错误处理

Swift 2 中最大的变化之一是苹果增加了一个名为**错误处理**的功能。处理错误情况通常是编程中最不有趣的部分。处理成功的情况通常更有趣，通常被称为*快乐路径*，因为那里是功能最吸引人的地方。然而，为了制作真正出色的用户体验，因此制作出真正出色的软件，我们必须仔细关注软件在出现错误时做了什么。Swift 的错误处理功能帮助我们简洁地处理这些情况，并阻止我们最初就忽略错误。

在本章中，我们将讨论 Swift 具体的错误处理功能以及它们如何帮助我们编写更好的软件。我们将通过涵盖以下主题来完成：

+   抛出错误

+   处理错误

+   错误情况下的清理

# 抛出错误

在我们讨论如何处理错误之前，我们需要讨论如何首先发出错误已发生的信号。这个术语是*抛出错误*。

## 定义错误类型

抛出错误的第一个部分是定义一个我们可以抛出的错误。任何实现了`ErrorType`协议的类型都可以被抛出，如下所示：

[PRE0]

此协议没有任何要求，因此类型只需将其列为它实现的协议即可。现在它就可以从函数或方法中抛出了。

## 定义一个抛出错误的函数

让我们定义一个函数，它将接受一个字符串并将其重复，直到它至少达到一定的长度。这将非常简单实现，但会有一个问题场景。如果传入的字符串为空，无论我们重复多少次，它都不会变长。在这种情况下，我们应该抛出一个错误。

任何函数或方法都可以抛出错误，只要它被标记为带有`throws`关键字，如下面的代码所示：

[PRE1]

`throws`关键字始终位于参数之后和返回类型之前。

## 实现抛出错误的函数

现在，我们可以测试传入的字符串是否为空，如果为空则抛出一个错误。为此，我们使用`throw`关键字和我们的错误实例：

[PRE2]

这里需要注意的一个重要事情是，当我们抛出一个错误时，它会立即退出函数。在前面的例子中，如果字符串为空，它会跳到抛出行，然后不会执行函数的其余部分。在这种情况下，通常更合适使用`guard`语句而不是简单的`if`语句，如下面的代码所示：

[PRE3]

最终，这与之前的实现没有太大区别，但它重申了如果函数失败，则不会执行函数的其余部分。我们现在可以尝试使用这个函数。

# 处理错误

如果我们尝试调用一个函数，比如正常情况下，Swift 会给我们一个错误，如下面的示例所示：

[PRE4]

为了消除这个错误，我们必须在调用之前添加`try`关键字。然而，在我们继续之前，我建议如果你在游乐场中跟随，将所有代码包裹在一个函数中。这是因为游乐场根级别的错误抛出将不会被正确处理，甚至可能导致游乐场停止工作。要包裹你的代码在函数中，你可以简单地添加以下代码：

[PRE5]

这定义了一个名为`main`的函数，它包含所有在游乐场末尾一次性调用的正常游乐场代码。

现在，让我们回到使用`try`关键字。实际上，它有三种形式：`try`、`try?`和`try!`。让我们先讨论感叹号形式，因为它是最简单的形式。

## 强制尝试

`try!`关键字被称为**强制尝试**。如果你使用它，错误将完全消失，如下所示：

[PRE6]

这种方法的缺点可能基于感叹号及其过去的意义是直观的。就像强制解包和强制转换一样，感叹号是一个标志，表明将会有一个会导致整个程序崩溃的场景。在这种情况下，崩溃将是由函数抛出的错误引起的。有时你可以真正断言从抛出函数或方法的调用中永远不会抛出错误，但一般来说，这不是一个可取的解决方案，考虑到我们正在尝试优雅地处理我们的错误情况。

## 可选尝试

我们还可以使用`try?`关键字，这被称为**可选尝试**。它不会允许崩溃的可能性，而是将函数的结果转换为可选值：

[PRE7]

这里的好处是，如果函数抛出错误，`repeated3`将简单地设置为`nil`。然而，与此相关有几个奇怪的情况。首先，如果函数已经返回了一个可选值，结果将转换为可选的可选值：

[PRE8]

这意味着你将不得不解包可选值两次才能到达真正的值。如果抛出错误，外层的可选值将是`nil`，如果方法返回`nil`，则内层的可选值也将是`nil`。

另一个奇怪的情况是，如果函数根本不返回任何内容。在这种情况下，使用可选的`try`将创建一个可选的空值，如下所示：

[PRE9]

你可以通过检查结果是否为`nil`来确定是否抛出了错误。

这种技术的最大缺点是，无法确定错误抛出的原因。对于我们的`repeatString:untilLongerThan:`函数来说这不是问题，因为只有一个错误场景，但我们会经常遇到可以以多种方式失败的功能或方法。特别是，如果这些是基于用户输入调用的，我们希望能够向用户报告错误发生的确切原因。

为了让我们能够获取关于错误原因的更精确信息，我们可以使用`final`关键字，它简单地就是`try`。

## 捕获错误

为了了解捕获错误的有用性，让我们看看编写一个新函数，该函数将创建一个随机数列表。我们的函数将允许用户配置列表的长度以及可能的随机数的范围。

捕获错误的背后的想法是，你有机会查看抛出的错误。就我们当前的错误类型而言，这不会非常有用，因为没有办法创建不同类型的错误。一个很好的解决方案是使用实现`ErrorType`协议的枚举：

[PRE10]

这个枚举为我们将要抛出的错误提供了两种情况，因此我们现在可以开始实现我们的函数：

[PRE11]

这个函数首先检查错误场景。它首先检查我们是否试图创建一个负长度的列表。然后，它检查范围的高值是否确实大于低值。之后，我们重复将随机数添加到输出数组中，次数与请求的次数相同。

注意，这个实现使用了`rand`函数，我们在[第2章](ch02.html "第2章。构建块 – 变量、集合和流程控制")中使用了它，*构建块 – 变量、集合和流程控制*。要使用它，你需要`import Foundation`，并且再次使用`srand`来初始化随机数。

此外，这种随机数的使用稍微复杂一些。之前，我们只需要确保随机数在零和数组长度之间；现在，我们需要它在两个任意数之间。首先，我们确定可以生成多少个不同的数字，这是高数和低数之差加一，因为我们想包括高数。然后，我们在那个范围内生成随机数，最后，通过将低数加到结果上来将其移到我们想要的实际范围。为了确保这能正常工作，让我们通过一个简单的场景来思考。假设我们想要生成一个介于`4`和`10`之间的数字。这里的范围大小将是`10` `- 4 + 1 = 7`，所以我们将生成介于`0`和`6`之间的随机数。然后，当我们加上`4`时，它将那个范围移动到`4`和`10`之间。

因此，我们现在有一个会抛出几种类型错误的函数。如果我们想捕获这些错误，我们必须在`do`块中嵌入调用，并添加`try`关键字：

[PRE12]

然而，如果我们把它放在playground的`main`函数中，我们仍然会得到一个错误，即这里抛出的错误没有被处理。如果你把它放在playground的根级别，这不会产生错误，因为playground会默认处理任何抛出的错误。要在函数中处理它们，我们需要添加`catch`块。`catch`块的工作方式与`switch`案例相同，就像`switch`是在错误上执行一样：

[PRE13]

`catch` 块是通过关键字 `catch` 后跟情况描述，然后是包含要运行该情况的代码的大括号来定义的。每个 `catch` 块都作为一个独立的 switch case。在我们的前一个例子中，我们定义了两个不同的 `catch` 块：一个用于每个错误，我们打印出用户可理解的错误信息。

然而，如果我们把这段代码添加到我们的游乐场中，我们仍然会得到一个错误，因为所有错误都没有被处理，因为外层的 `catch` 块不是穷尽的。这是因为 `catch` 块就像 switches 一样，必须覆盖所有可能的情况。我们无法说明我们的函数只能抛出随机的列表错误，因此我们需要添加一个最后的 `catch` 块来处理任何其他错误：

[PRE14]

最后的 `catch` 块将错误存储到一个仅类型为 `ErrorType` 的变量中。我们真正能做的只是将其打印出来。根据我们当前的实现，这个块永远不会被调用，但如果我们在以后向函数添加不同的错误并忘记添加新的 `catch` 块，它可能会被调用。

注意，目前没有方法可以指定从特定函数可以抛出哪种类型的错误；因此，在这个实现中，编译器无法确保我们覆盖了错误枚举的每个情况。我们可以在 `catch` 块内执行一个 `switch`，这样编译器至少会强制我们处理每个情况：

[PRE15]

这种技术不会在从我们的函数抛出完全不同类型的错误时让编译器给出错误，但至少如果我们在枚举中添加新的情况，它会给出错误。

我们可以使用的另一种技术是定义一个包含应显示给用户的描述的错误类型：

[PRE16]

我们不是抛出枚举情况，而是创建 `UserError` 类型的实例，并带有问题的文本描述。现在，当我们调用函数时，我们只需捕获错误作为 `UserError` 类型，并打印出其 `userReadableDescription` 属性的值：

[PRE17]

这是一个相当吸引人的技术，但它也有自己的缺点。这不允许我们在发生特定错误时轻松运行某些代码。在仅仅向用户报告错误的情况下，这并不重要，但在我们可能更智能地处理错误的情况下，这非常重要。例如，如果我们有一个上传信息到互联网的应用程序，我们经常会遇到互联网连接问题。我们不仅可以告诉用户稍后再试，还可以将信息本地保存，并自动稍后尝试再次上传，而无需打扰用户。然而，互联网连接问题不会是上传失败的唯一原因。在其他错误情况下，我们可能想要做其他的事情。

一个更健壮的解决方案可能是结合这两种技术。我们可以从定义一个可以直接报告给用户的错误协议开始：

[PRE18]

现在我们可以为我们的特定错误创建一个枚举，该枚举实现了该协议：

[PRE19]

这个枚举被设置为具有原始类型的字符串。这允许我们编写一个更简单的 `userReadableDescription` 属性的实现，它只返回原始值。

这样，我们的函数实现看起来和之前一样：

[PRE20]

然而，我们的错误处理现在可以更高级。我们总是可以捕获任何 `UserErrorType` 并将其显示给用户，但如果我们想在这种情况下做些特别的事情，我们也可以捕获特定的枚举情况：

[PRE21]

请记住，我们的 catch 块的顺序非常重要，就像 switch 情况的顺序一样重要。如果我们把 `UserErrorType` 块放在 `NegativeListLength` 块之前，我们就会总是向用户报告它，因为一旦一个 catch 块被满足，程序就会跳过所有剩余的块。

这是一个相当直接的方法；因此，你可能有时想使用一个更简单的解决方案。你甚至可能在将来想出你自己的解决方案，但这也为你提供了一些可以尝试的选项。

## 传播错误

处理错误的最后一个选项是允许它传播。这只有在包含的函数或方法也被标记为抛出错误时才可能，但如果这是真的，那么实现起来就很简单：

[PRE22]

在这种情况下，`try` 调用不需要被包裹在 do-catch 中，因为 `createRandomListContainingXNumbers:between:and:` 抛出的所有错误都会被 `parentFunction` 重新抛出。实际上，你仍然可以使用 do-catch 块，但是 catch 情况不再需要是详尽的，因为任何未被捕获的错误将简单地被重新抛出。这允许你只捕获与你相关的错误。

然而，虽然这可以是一个有用的技术，但我建议不要过度使用。你处理错误的情况越早，你的代码就越简单。每个可能抛出的错误就像是在高速公路系统中增加了一条新道路；如果有人走错了方向，确定他们走错路的地方就会变得更难。我们处理错误得越早，在父函数中创建额外的代码路径的机会就越少。

# 错误情况下的清理

到目前为止，我们并不需要过于担心在抛出错误后函数中会发生什么。有时，无论是否抛出错误，我们都需要在退出函数之前执行某些操作。

## 发生错误时的执行顺序

抛出错误的一个重要注意事项是当前作用域的执行会退出。如果你把它看作是一个简单的返回调用，那么对于函数来说这很容易理解。在抛出之后的所有代码将不会被执行。在 do-catch 块中这稍微有点不那么直观。一个 do-catch 可以有多个可能抛出错误的函数调用，但是一旦一个函数抛出错误，执行就会跳转到第一个匹配该错误的 catch 块：

[PRE23]

在这里，如果 `function1` 抛出错误，`function2` 和 `function3` 将不会被调用。如果 `function1` 没有抛出错误但 `function2` 抛出了，那么只有 `function3` 不会被调用。此外，请注意，我们可以使用两个其他的 `try` 关键字中的任何一个来防止跳过行为：

[PRE24]

现在，如果 `function1` 抛出错误，整个程序将会崩溃，如果 `function2` 抛出错误，它将直接继续执行 `function3`。

## 延迟执行

现在，正如我之前暗示的，在某些情况下，无论是否抛出错误，我们都需要在退出函数或方法之前执行某些操作。你可以将那种功能放入一个在抛出每个错误之前被调用的函数中，但 Swift 提供了一种更好的方式，称为 **defer 块**。defer 块简单地允许你在退出函数或方法之前运行一些代码。让我们看看一个个人厨师类型的例子，这种类型在尝试烹饪食物后必须始终进行清理：

[PRE25]

在制作焦糖布丁的方法中，我们从一个调用清理方法的 defer 块开始。这不会立即执行；它会在抛出错误或方法退出之前立即执行。这确保了无论焦糖布丁的制作过程如何，个人厨师都会进行清理。

实际上，即使在从函数或方法返回的任何时刻，`defer` 也会起作用：

[PRE26]

在这里，我们定义了一个小的成分类型和一个储藏室类型。储藏室有一个成分列表和一个帮助我们从中获取成分的方法。当我们去获取成分时，我们首先必须打开门，因此我们需要确保无论是否找到成分，我们都要在最后关闭门。这是一个 defer 块的另一个完美场景。

关于 defer 块，还有一点需要注意，你可以定义任意多的 defer 块。每个 defer 块将按照它们定义的相反顺序被调用。因此，最近的延迟块将首先被调用，最旧的延迟块将最后被调用。我们可以看看一个简单的例子：

[PRE27]

在这个例子中，`"A"` 将首先被打印出来，因为它是最晚被延迟的块，而 `"C"` 将最后被打印出来。

最终，在执行任何需要清理操作的动作时使用 `defer` 是一个很好的主意。在最初实现它时，你可能没有额外的返回或抛出，但它将使以后对代码的更新更加安全。

# 概述

错误处理通常不是编程中最有趣的部分，但正如你所见，围绕它绝对可以有一些有趣的设计策略。在开发高质量软件时，它也是绝对关键的。我们喜欢认为我们的用户永远不会遇到任何问题或未预见的场景，但你可能会惊讶于这种情况发生的频率。我们希望尽我们所能让这些场景运行良好，因为如果用户在不可避免的错误情况下陷入困境，他们会对你的产品留下持久的负面印象。

我们看到Swift为我们提供了一个称为错误处理的范式来帮助解决这个问题。函数和方法可以被标记为可能抛出错误，然后我们可以抛出任何实现了`ErrorType`协议的类型。我们可以以不同的方式处理这些抛出的错误。我们可以使用`try!`关键字断言错误永远不会被抛出，我们可以使用`try?`关键字将抛出函数或方法转换为可选，或者我们可以使用do-catch块捕获和检查错误。最后，我们讨论了defer块，它帮助我们确保无论我们是否抛出错误或提前返回，某些操作都会发生。

现在我们已经解决了错误处理的问题，我们可以跳入计算机编程的更具艺术性的方面，即设计模式。
