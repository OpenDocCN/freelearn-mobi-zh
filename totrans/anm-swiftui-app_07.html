<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor095"/>7</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor096"/>Building a Series of Belts and Gears</h1>
<p>In this project, we’re going to explore rotation, and more specifically, how to use the <code>rotation3DEffect</code> modifier to rotate objects on the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axis. We will be doing this by animating a series of gears and belts that will eventually move a fan blade.</p>
<p>As we create this project, we will also explore how to use Groups and Pragma Marks to make your code more organized, and the <code>zIndex</code> property, which changes the depth of views. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Animating our first circular gear</li>
<li>Adding a worm gear using shadows</li>
<li>Using a marching ants effect to create a gear belt</li>
<li>Animating a gear shaft image</li>
<li>Animating a fan image</li>
<li>Bringing everything together in <code>ContentView</code></li>
</ul>
<h1 id="_idParaDest-93"><a id="_idTextAnchor097"/>Technical requirements</h1>
<p>You can download the resources and finished project from the <code>Chapter 7</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor098"/>Animating our first circular gear</h1>
<p>To begin <a id="_idIndexMarker360"/>with, let’s create a new project, which I’m calling <code>Gears and Belts</code>. Then, add the images for the project (which you can find in the GitHub repository provided in the <em class="italic">Technical requirements</em> section) by dragging and dropping the images into Swift’s asset catalog. The images we are using are <code>singleGear</code>, <code>doubleGear</code>, <code>wormGear</code>, <code>motor</code>, <code>shaft</code>, <code>fan</code>, and <code>goldBackground</code>.</p>
<p>In this section, we <a id="_idIndexMarker361"/>are going to start by animating a gear image around the <em class="italic">z</em>-axis, so let’s make a SwiftUI file that will handle creating all the gears we need (as we have done in previous projects, we are going to work on each element for the project in separate files, and then piece them together in <code>ContentView</code> to create the finished animations). </p>
<p>To do this, go to <code>GearView</code> and press <strong class="bold">Create</strong>.</p>
<p>Now, we can fill this file by adding the variables needed to make and animate gears images. Let’s start with a <code>State</code> variable that keeps track of the animation state, the state being whether the animation is in motion or not. Add this <code>@State</code> variable to the file:</p>
<pre class="source-code">
@State private var rotateGear = false</pre>
<p>This variable will help to keep track of whether the gear image is rotating or not, so I have called it <code>rotateGear</code>. It is also set to <code>false</code>, which means the animation will start inactive until this variable is changed to <code>true</code>.</p>
<p>The next variable will be of the <code>String</code> type, which we can use to set the name of the gear image:</p>
<pre class="source-code">
var gearImage: String = ""</pre>
<p>If you look back into the asset catalog, you will see that you placed three different types of gear in there: a single gear, a double gear, and a worm gear. So, when it comes time to use all these files in <code>ContentView</code>, this <code>gearImage</code> variable will help save time, as all we need to do is to type in the name of the gear we want to use. </p>
<p>Next, we need to be able to set the size of the gear; here’s another variable to handle that:</p>
<pre class="source-code">
var gearWidth: CGFloat = 0.0</pre>
<p>You might be wondering why we are setting the width of the gear but not the height. Well, the gear images we are using are circles (except for the worm gear); as you may know, circles only need one dimension, the width or height, because circles have a diameter that is always the same, regardless of which dimension is measured. </p>
<p>Continuing<a id="_idIndexMarker362"/> with the variables needed for this file, let’s add another variable that indicates the number of degrees our gear will turn:</p>
<pre class="source-code">
var gearDegrees: Double = 0.0</pre>
<p>This variable is called <code>gearDegrees</code>. A value of <code>360</code> will turn the gear image for one revolution, but right now, it is initialized as <code>0.0</code>.</p>
<p>We will also place gears all around the screen, so we’ll need to set a couple of variables to handle the location of these gears. We will use two of them to set the <code>X</code> and <code>Y</code> location:</p>
<pre class="source-code">
var offsetGearX: CGFloat = 0.0
var offsetGearY: CGFloat = 0.0</pre>
<p>Next, we need to be able to rotate the gears, and later the belts, to different orientations in relation to their surroundings, so let’s add a variable that will be in charge of setting that value:</p>
<pre class="source-code">
var rotateDegrees: Double = 0.0</pre>
<p>Then, we will add a variable to set the duration of the spinning gear, meaning how long it takes to finish one revolution:</p>
<pre class="source-code">
var duration: Double = 0.0</pre>
<p>The duration variable is set to <code>0</code>, but when it gets set to a value such as <code>7</code>, for example, that means it will take 7 seconds for the gear to turn one full revolution.</p>
<p>Finally, for this file, we need three more variables to set the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axis position of the gear:</p>
<pre class="source-code">
var xAxis: CGFloat = 0.0
var yAxis: CGFloat = 0.0
var zAxis: CGFloat = 0.0</pre>
<p>Each of these variables will control the axis that the gear rotates around. The axis is what allows us to rotate an object in three dimensions, which will help create perspective and the effect of depth in the scene. These variables are appropriately named <code>xAxis</code>, <code>yAxis</code>, and <code>zAxis</code>. </p>
<p>We have all the variables in place, so let’s now add the code into the body of the struct and make our first gear. First, let’s add a <code>ZStack</code> to hold all of the views we need:</p>
<pre class="source-code">
 ZStack {
        }</pre>
<p>Now, inside<a id="_idIndexMarker363"/> the <code>ZStack</code>, we can use the <code>Image</code> initializer, which will place a gear image on the screen:</p>
<pre class="source-code">
ZStack {
    Image(gearImage)
       }</pre>
<p>Remember, we have initialized the preceding <code>gearImage</code> variable to an empty string; this is what we want because it allows us to pass in different string names that represent the gear images in the asset catalog.</p>
<p>Next, we need several modifiers to size and place the gear image, as well as the animation modifiers to make the gear image turn. Add the following code under <code>Image(gearImage)</code>:</p>
<pre class="source-code">
ZStack {
            Image(gearImage)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: gearWidth)
                .rotationEffect(.degrees(rotateGear ?                   gearDegrees : 0))
                .animation(Animation.linear(duration:                   duration).repeatForever(autoreverses: false),                   value: rotateGear)
                .rotation3DEffect(
                    .degrees(rotateDegrees),axis: (x: xAxis, y:                       yAxis, z: zAxis))
                .offset(x: offsetGearX, y: offsetGearY)
        }</pre>
<p>Let’s look at the <a id="_idIndexMarker364"/>modifiers we are using here:</p>
<ul>
<li>Firstly, we know that we need to give the image the ability to resize, which is what the <code>resizable</code> modifier is for. </li>
<li>Then, we want to constrain the gear image dimensions with the <code>fit</code> aspect ratio option; as we have seen before, this mode preserves the content’s aspect ratio and indicates that the object should be scaled to fit within the available space while maintaining its aspect ratio. This means that the object will be scaled down if necessary so that it fits within the space it’s being displayed in, without distorting its shape.</li>
</ul>
<p>The other option is <code>fill</code>; this means that the object will be scaled up or down to fill the space it is being displayed in without distorting its shape. Some parts of the object may be outside of the visible area, but the object will maintain its aspect ratio. We haven’t used this here though.</p>
<ul>
<li>Next, the frame of the image is set with the <code>gearWidth</code> modifer, which has been initialized to <code>0</code>. By doing this, we can pass in whatever value we need to create any size gear.</li>
<li>The next line calls the <code>rotationEffect</code> modifier, which will rotate <code>gearImage</code> by a value we pass in. This modifier will only rotate the gear image when the <code>rotateGear</code> variable becomes <code>true</code>; otherwise, a value of <code>0</code> gets used, meaning no rotation.</li>
<li>After that, we add the <code>animation</code> modifier, which gets a <code>linear</code> animation. The duration of the animation will depend on the value that’s held in the <code>duration</code> variable – here, we have set the duration to <code>repeatForever</code> and <code>autoreverses</code> to <code>false</code>. Then, we have the <code>value</code> parameter, which accepts into its parameter the variable we want to animate and then applies the animation to the view.</li>
<li>The next modifier is an interesting one, it’s called <code>rotation3DEffect</code>. This rotates a view in three dimensions around the given axis; the amount of rotation will <a id="_idIndexMarker365"/>be determined by the <code>degrees</code> modifier that is being used within it. To understand how the view will be rotated, it’s important to know where the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axes exist on an iPhone screen. Look at the following illustration:</li>
</ul>
<div><div><img alt="Figure 7.1: The three axes " src="img/B18674_07_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: The three axes</p>
<p>The <em class="italic">x</em>-axis runs from left to right on the iPhone screen, the <em class="italic">y</em>-axis runs from top to bottom, and the <em class="italic">z</em>-axis runs from back to front. These axes are three different planes of dimensional space that hold views or objects, and when an object rotates, it does so on one, or all, of these axes. Looking at the <code>rotation3DEffect</code> modifier, if we pass a value in one of the axis parameters, the view will then rotate on that axis by the specified number of degrees. </p>
<ul>
<li>Back to the code, lastly, the gear image will need to be placed somewhere on the screen; for that placement, we can use the help of the <code>offset</code> modifier. This modifier has two parameters, <code>x</code> and <code>y</code>, and the values will be determined by the <code>offsetGearX</code> and <code>offsetGearY</code> variables.</li>
</ul>
<p>With the modifiers all in place, we only need to start the animation, so let’s add the following code at the end of ZStack’s closing brace:</p>
<pre class="source-code">
.onAppear() {
            rotateGear.toggle()
        }.shadow(color: .black, radius: 1, x: 0, y: 0)</pre>
<p>The <code>onAppear</code> modifier, as <a id="_idIndexMarker366"/>we have seen before, will run the code in its body when the scene first appears. In the code, we want to toggle the <code>rotateGear</code> variable to <code>true</code> to start the animation. I’m also adding a little bit of black shadow to the gear image, which gives it a nicer look around its border.</p>
<p>Now, with everything we coded so far though, we still don’t see any images in the previews! Let’s fix that and add some values into the <code>Previews</code> struct in order to create a gear. In this example, we’ll use the double gear image, and give it a size. Place the following code in <code>GearView_Previews</code> so we can see the animation work:</p>
<pre class="source-code">
 GearView(gearImage: "doubleGear", gearWidth: 100, gearDegrees:    360, offsetGearX: 0, offsetGearY: 0, duration: 5)
            .previewLayout(.fixed(width: 200, height: 200))</pre>
<p>This code fills out the <code>GearView</code> struct with some values. The first parameter uses the <code>doubleGear</code> image from the asset catalog as the gear to display. Next, the <code>gearWidth</code> and <code>gearDegrees</code> parameters receive values to set the width and turning degree. Then, for the <code>offset</code> parameters, by setting them to zero, the gear will just stay in the middle of the screen. Finally, adding a duration of 5 seconds means it’ll take 5 seconds for the gear to turn for one complete revolution. </p>
<p>With all that in place, now, we can run the previews and check what we have done so far:</p>
<div><div><img alt="Figure 7.2: Adding our first gear " src="img/B18674_07_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Adding our first gear</p>
<p>The gear now <a id="_idIndexMarker367"/>turns, again, at a rate of one revolution in 5 seconds.</p>
<p>Also, notice that I’m setting a fixed width and height for the preview window, as we don’t need a full-size screen to display a small gear; 200 x 200 is more than enough room.</p>
<p>Now, with our gear in place and this file complete, anytime we need to make a gear anywhere in the project, all we have to do is call the <code>gearView</code> struct and pass in some values to create a gear of any size, wherever needed on the screen.</p>
<p>However, despite all that work, there is one gear that we won’t be able to turn in any meaningful way because it’s not a circular shape, and that’s the worm gear image in the asset catalog. In the next section, I’ll explain what a worm gear is, and how to make it turn, or at least make it look like it’s turning.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor099"/>Animating a worm gear using shadows</h1>
<p>Worm gears<a id="_idIndexMarker368"/> look like big screws with spiral threads, but without a screw head on the top. They’re used in equipment and machines where strength is an important factor because they are <a id="_idIndexMarker369"/>very durable and can handle a lot of torque. Here is a typical worm gear:</p>
<div><div><img alt="Figure 7.3: A worm gear " src="img/B18674_07_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: A worm gear</p>
<p>If we add a worm gear image to the project and animate it as we did with the round gear, it wouldn’t work very well, simply because the worm gear image is not a round shape. So, how can we make an irregularly shaped image appear like it’s turning as it would in the real world? </p>
<p>What we can do is place small, shaded rectangles over the shiny parts of the worm gear image and animate those rectangles instead, which will create the illusion that the image is turning or spinning. Clever, right?</p>
<p>First, create a new file, choose the <code>WormGearView</code>. Inside this file, within the <code>WormGear</code> struct, we will start off by adding four <code>State</code> properties, one for each rectangle we need:</p>
<pre class="source-code">
    @State private var rect1 = false
    @State private var rect2 = false
    @State private var rect3 = false
    @State private var rect4 = false</pre>
<p>Now in <a id="_idIndexMarker370"/>our main <code>ZStack</code>, let’s add another <code>ZStack</code> within to display the worm gear image:</p>
<pre class="source-code">
 ZStack {
    ZStack {
                Image("wormGear").resizable().frame(width: 100,                   height: 75)
           }
        }</pre>
<p>The <code>Image</code> initializer declares the image and resizes it to a width and height that we can use.</p>
<p>Next, we will create the first rectangle that we need to place over the shiny part of the worm gear. To do so, add the following code:</p>
<pre class="source-code">
HStack {
                    Rectangle()
                        .frame(width: 4, height: 40)
                        .foregroundColor(.black)
                        .cornerRadius(5)
                        .opacity(rect1 ? 0 : 0.3)
                        .offset(x: 2, y: rect1 ? 14 : -8)
                        .animation(Animation.easeInOut                           (duration: 0.5).repeatForever                           (autoreverses: true), value: rect1)
                        .rotationEffect(.degrees(-4), anchor:                           .top)
                        .onAppear(){
                            rect1.toggle()
                        }
        }</pre>
<p>The<a id="_idIndexMarker371"/> rectangles will be placed in an <code>HStack</code> because we want to put them side by side, going from left to right across the gear. We’re also using familiar modifiers that we’ve used before. We’ve made the rectangles black and given them a slight corner radius. The opacity of the rectangle will depend on whether the animating variable called <code>rect1</code> is <code>true</code> or not: if the <code>rect1</code> property becomes <code>true</code>, then we will give the rectangle a bit of visibility using an <code>opacity</code> of <code>0.3</code>; when the <code>rect1</code> property is <code>false</code>, we’ll remove all opacity and hide it.</p>
<p>The next line of code uses the <code>offset</code> modifier to place this rectangle directly over the first shiny part of this worm gear on the left side. This <code>offset</code> modifier is also responsible for moving the small rectangle up and down on the <em class="italic">y</em>-axis, either up <code>14</code> points when <code>rect1</code> is <code>true</code>, or it will move the rectangle down to <code>-8</code> points when it becomes <code>false</code>. The effect we’re going for here is to animate these tiny rectangles up and down and at the same time, fade them in and out over the shiny part of the worm gear image, creating the illusion that the part is turning.</p>
<p>Now for the <code>animation</code> modifier: this uses an <code>easeInOut</code> timing curve, has a duration of half a second, and is set to <code>repeatForever</code>, with <code>autoreverses</code> set to <code>true</code>.</p>
<p>After that, the <code>rotationEffect</code> modifier is used to rotate this small rectangle exactly where we want it on the worm gear. The rectangle will rotate around the anchor point, which we have set to the top part of the rectangle.</p>
<p>And finally, in the <code>onAppear</code> modifier, we toggled <code>rect1</code> so the animation starts when the view appears.</p>
<p>Now, go ahead and run the project; you can see the results in the preview:</p>
<div><div><img alt="Figure 7.4: A worm gear in our animation " src="img/B18674_07_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: A worm gear in our animation</p>
<p>Looking <a id="_idIndexMarker372"/>at the figure, it’s a bit hard to see the rectangle, but it’s definitely there, a faint thin rectangle just after the third tooth. If you want to see the rectangle better, remove the worm gear by misspelling <code>wormGear</code> in the <code>Image</code> initializer, which will remove the worm gear from the previews (they hate when we misspell something!). When you run the project again, this is what you’ll see:</p>
<div><div><img alt="Figure 7.5: The rectangle that overlays the worm gear " src="img/B18674_07_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: The rectangle that overlays the worm gear</p>
<p>You<a id="_idIndexMarker373"/> should see the rectangle moving up and down, as well as fading in and out. </p>
<p>For the placement of this rectangle, ideally, we want it to be on the left, over the first tooth; however, that will happen when we add the other rectangles into this <code>HStack</code>. Remember, an <code>HStack</code> lines everything up from left to right, but since we only have one rectangle in the <code>HStack</code>, the <code>HStack</code> places it in the middle for now.</p>
<p>So, let’s now add a second rectangle into the <code>HStack</code>, just under the first one:</p>
<pre class="source-code">
                    Rectangle()
                        .frame(width: 4, height: 40)
                        .foregroundColor(.black)
                        .cornerRadius(5)
                        .opacity(rect2 ? 0 : 0.3)
                        .offset(x: 7, y: rect2 ? -15 : -8)
                        .animation(Animation.easeInOut                           (duration: 0.5).repeatForever                           (autoreverses: true), value: rect2)
                        .rotationEffect(.degrees(-8))
                        .onAppear(){
                            rect2.toggle()
                        }</pre>
<p>This code is almost identical to what we’ve just added for the first rectangle. The difference here is we are offsetting the rectangle to a different location over the gear image, and the rotation is slightly different so it can be lined up over the next shiny part of the gear.</p>
<p>Run<a id="_idIndexMarker374"/> the code and you’ll see two animating rectangles. They’re not quite centered over the first and second shiny teeth of the gears yet, because we have two more rectangles to add, and then the <code>HStack</code> will center each animating rectangle perfectly for us.</p>
<p>Before we continue and add the third and fourth rectangles though, take a look at the first three modifiers of these two rectangles that we just added. They both have identical values in them, so we are repeating the code here, which is what we try to avoid when programming. Since the values don’t change in these modifiers and we will use them in all four rectangles, instead, we can make a custom modifier into which we can put these three modifiers and shorten our code a little bit. </p>
<p>To create a custom modifier, we need to create a struct that conforms to the <code>ViewModifier</code> protocol. This protocol has one requirement, which is to implement a method called <code>body content</code> that will accept our content and then must return a view.</p>
<p>We can create a custom modifier at the bottom of the <code>WormGear</code> file. Moving outside of the <code>WormGear</code> struct completely and coming to the bottom of this file, add the following struct:</p>
<pre class="source-code">
struct RectModifiers: ViewModifier {
    func body(content: Content) -&gt; some View {
        content
            .frame(width: 4, height: 40)
            .foregroundColor(.black)
            .cornerRadius(5)
    }
}</pre>
<p>This is a custom modifier struct, which I called <code>RectModifiers</code>; as you can see, we are implementing the <code>body content</code> method inside it, which is the requirement needed to satisfy the <code>ViewModifier</code> protocol. Then, I added the three modifiers that we were repeating in our code (i.e., the ones that weren’t changing in value: <code>frame</code>, <code>foregroundColor</code>, and <code>cornerRadius</code>). </p>
<p>Now, all we have to do is go back to the first rectangle that we created, just after the worm gear creation, remove those three modifiers, and instead, call our custom modifier:</p>
<pre class="source-code">
.modifier(RectModifiers())</pre>
<p>To use it, we <a id="_idIndexMarker375"/>pass into it the name of the custom struct we just made, <code>RectModifiers</code>. This new modifier struct can hold as many modifiers as we want to put in there, so modifiers that don’t change in value are probably a good idea to use here; this reduces the amount of code we need to write, especially if we have many views (for example, if we were to add 30 or 40 rectangles in this file).</p>
<p>Now, we can proceed to add the final two rectangles to help with the illusion that this gear is turning. Here’s what the code looks like:</p>
<pre class="source-code">
                  Rectangle().modifier(RectModifiers())
                        .opacity(rect3 ? 0 : 0.3)
                        .offset(x: 5, y: rect3 ? -5 : -10)
                        .animation(Animation.easeInOut                           (duration: 0.5).repeatForever                           (autoreverses: true), value: rect3)
                        .rotationEffect(.degrees(-8), anchor:                           .top)
                        .onAppear(){
                            rect3.toggle()
                        }
                    Rectangle().modifier(RectModifiers())
                        .opacity(rect4 ? 0 : 0.3)
                        .offset(x: 4, y: rect4 ? -10 : -10)
                        .animation(Animation.easeInOut                           (duration: 0.5).repeatForever                           (autoreverses: true), value: rect4)
                        .rotationEffect(.degrees(-7), anchor:                           .top)
                        .onAppear(){
                            rect4.toggle()</pre>
<p>Before <a id="_idIndexMarker376"/>we try it out, let’s add some shadow to these moving rectangles to help make them a little more pronounced. Add this code at the end of the closing brace of the first <code>ZStack</code>:</p>
<pre class="source-code">
 .shadow(color: .black, radius: 0.4, x: 0.0, y: 1)</pre>
<p>By using the <code>shadow</code> modifier, and passing in a black shadow to go over each rectangle, I have given this shadow <code>4</code> points of radius, and the shadow will be shown on the <em class="italic">y</em>-axis with a value of <code>1</code>. Using a positive number value will move the shadow along the <em class="italic">y</em>-axis, while using a negative number will move the shadow along the <em class="italic">y</em>-axis in the opposite direction. Play around with these numbers so you can see how they affect the shadow’s prominence and location.</p>
<p>And with that code, this file is now complete. Run the project and see what you think:</p>
<div><div><img alt="Figure 7.6: The finished worm gear " src="img/B18674_07_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: The finished worm gear</p>
<p>We have a <a id="_idIndexMarker377"/>worm gear that actually looks like it’s turning. Notice that each rectangle has lined up completely over the teeth of the worm gear, starting from the left and moving to the right. The shiny parts are being covered up and exposed over and over again, at a nice even pace, which is actually about how fast many worm gears work.</p>
<p>Now we have finished animating the worm gears, we’re going to create a marching ants effect that we can use to simulate a moving gear chain. We can accomplish that using the <code>dashPhase</code> initializer.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor100"/>Using a marching ants effect to create a gear belt</h1>
<p>Now that <a id="_idIndexMarker378"/>we have animated our circular and worm gears, next, we need to make some belts that can be used to wrap around those gears and connect them.</p>
<p>What we are<a id="_idIndexMarker379"/> actually doing is creating a marching ants effect. You probably have used this effect before, but without knowing what it was called – anytime you used your mouse or trackpad and outlined a view or created a bounding box around objects to select them, you were using the marching ants effect. You may remember that in <a href="B18674_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a> when we used the <strong class="bold">Lasso Selection</strong> tool in Mac’s Previews app, the little dashes that outlined the portion of the image selected were an example of this effect.</p>
<p>So, to create our gear belt, let’s start this section by adding another new file, which we’ll call <code>BeltView</code>. Then, as we usually do, we’ll add the variables that make everything work first, inside the <code>BeltView</code> struct:</p>
<pre class="source-code">
@State var animateBelt: Bool = false
    var beltWidth: CGFloat = 0.0
    var beltHeight: CGFloat = 0.0
    var offsetBeltX: CGFloat = 0.0
    var offsetBeltY: CGFloat = 0.0
    var dashPhaseValue: CGFloat = 45
    var rotateDegrees: Double = 0.0
    var xAxis: CGFloat = 0.0
    var yAxis: CGFloat = 0.0
    var zAxis: CGFloat = 0.0</pre>
<p>Each one of these variables is in charge of a specific task:</p>
<ul>
<li><code>animateBelt</code> keeps track of the animation for the belt.</li>
<li><code>beltWidth</code> and <code>beltHeight</code> set the width and height of the belt.</li>
<li><code>offsetBeltX</code> and <code>offsetBeltY</code> locate the belt in specific areas on the screen.</li>
<li><code>dashPhaseValue</code> is in charge of designing the belt – for example, how far we want to space the belt segments apart from each other, how thick they should be, and so on.</li>
<li><code>rotateDegrees</code> is used after we position the belt to rotate it either horizontally or vertically by passing in a degree number.</li>
<li><code>xAxis</code>, <code>yAxis</code>, and <code>zAxis</code> orient the belt on the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axes, respectively. You will see these three variables come into play when we start piecing together all these separate files into <code>ContentView</code>.</li>
</ul>
<p>With <a id="_idIndexMarker380"/>the variables in place, we can move into<a id="_idIndexMarker381"/> the <code>body</code> of the struct and start adding the code to create the belt. There’s not a lot of code to make a belt. First, start by adding a <code>ZStack</code> to hold our views:</p>
<pre class="source-code">
 ZStack {
        }</pre>
<p>Next, we want to create the shape of the belt. If you look at most belts or chains that are gear-driven, they have a shape similar to a capsule, and luckily, SwiftUI gives us a capsule shape that we can use. Add the following code, including its modifiers, inside of the <code>ZStack</code>:</p>
<pre class="source-code">
            Capsule()
                .stroke(Color.black, style: StrokeStyle                   (lineWidth: 7, lineJoin: .round, dash:                   [5, 1.4], dashPhase: animateBelt ?                   dashPhaseValue : 0))
                .frame(width: beltWidth, height: beltHeight)
                .animation(Animation.linear(duration:                   3).repeatForever(autoreverses: false).                  speed(3), value: animateBelt)</pre>
<p>This is only about five lines of code, but it does a lot of work here. First, we declare the capsule shape that we need and then use the <code>stroke</code> modifier on it. The <code>stroke</code> modifier does<a id="_idIndexMarker382"/> quite a bit and is also responsible for designing the belt: its first parameter will give the belt a color (we have chosen black), and the second parameter is the <code>strokeStyle</code> parameter, where we pass in a <code>StrokeStyle</code> struct. </p>
<p>This <code>StrokeStyle</code> struct has some parameters of its own that help style the belt:</p>
<ul>
<li>The first one is the <code>lineWidth</code> parameter. This one is fairly self-explanatory; it just means how wide we want to make the belt, which we have set to <code>7</code> points. </li>
<li>There’s also a <code>lineJoin</code> parameter. This is a value that determines how the segments of the belt will join together. There are three options we could use, <code>round</code>, <code>bevel</code>, and <code>miter</code>; I thought the line segments would look best using the <code>round</code> option, however feel free to experiment with all these values and numbers to get the best look for you.</li>
<li>The next parameter is called <code>dash</code>, which is responsible for the length of the segments that’s used to create the belt, and the gap between those segments. The first value of this parameter will determine the length of the segment (a larger number makes the segments bigger, while a smaller number makes the segments smaller); I’m using <code>5</code> points for this value. The second value determines the gap size between the segments (a larger number creates a larger gap, while a smaller number creates a smaller gap); for this value, a <code>1.4</code> point value creates gap that looks really good.</li>
</ul>
<p>After<a id="_idIndexMarker383"/> the <code>strokeStyle</code> struct, the next modifier is the <code>frame</code>, which sets the width and height of the whole belt. Then we added an <code>animation</code> modifier, with a <code>linear</code> animation and a duration of three seconds to complete one revolution, and <code>autoreverses</code> set to <code>false</code> (as we just want the belt to turn in one direction only).</p>
<p>Now we need to add the <code>onAppear</code> modifier so we can start the animation when the app loads up. To do that, add the following code right under the existing code:</p>
<pre class="source-code">
      .onAppear {
                    animateBelt.toggle()
                }</pre>
<p>This code toggles the <code>animateBelt</code> property to <code>true</code>, kicking off the belt animation.</p>
<p>There’s only one last bit of code we need to add to finish off the styling of the belt, and that is to rotate the belt to the proper angle for the gears. Coming out of <code>ZStack</code>, just after its closing brace, add the following code:</p>
<pre class="source-code">
        .shadow(color: .black, radius: 10, x: 1, y: 0)
        .rotationEffect(.degrees(rotateDegrees), anchor:           .center)
        .offset(x: offsetBeltX, y: offsetBeltY)</pre>
<p>This<a id="_idIndexMarker384"/> code will act on everything that is in the <code>ZStack</code> because it’s been put after its closing brace. Here, I added a <code>shadow</code> modifier, setting the <a id="_idIndexMarker385"/>color to black and a radius of <code>10</code> to make the belt more pronounced, and placed the shadow on the <em class="italic">x</em>-axis. You can play around with the colors and these numbers for the shadow: by increasing the radius, you will make the shadow bigger, and by increasing the numbers for the <code>x</code> and <code>y</code> parameters, you can move the shadow up, down, left, and right. Remember, you can use negative numbers to move the shadow in the opposite direction. </p>
<p>The next modifier we are placing on the entire <code>ZStack</code> is <code>rotationEffect</code>. This will rotate the completed belt to the angle we specify; when we call these various methods later in <code>ContentView</code>, we’ll pass in different values that’ll orient the belt and size it just the way we want.</p>
<p>Finally, we added the <code>offset</code> modifier, which allows us to place the belt anywhere on the screen using the <em class="italic">x</em>- and <em class="italic">y</em>-coordinates.</p>
<p>If you try to test out what we’ve done, you won’t see anything in the previews yet because we’ve just added a bunch of different variables into the <code>BeltView</code> struct. However, we’re not using those variables in the <code>Previews</code> struct. To fix this, let’s update the <code>Previews</code> struct to the following:</p>
<pre class="source-code">
struct BeltView_Previews: PreviewProvider {
    static var previews: some View {
        BeltView(animateBelt: true, beltWidth: 380, beltHeight:           48, offsetBeltX: 0, offsetBeltY: 0, rotateDegrees:           90)
            .previewLayout(.fixed(width: 100, height: 400))
    }
}</pre>
<p>When you<a id="_idIndexMarker386"/> run <code>Previews</code> now, you’ll see the belt in action:</p>
<div><div><img alt="Figure 7.7: The finished belt with the marching ants effect " src="img/B18674_07_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: The finished belt with the marching ants effect</p>
<p>It’s turning <a id="_idIndexMarker387"/>clockwise, has a nice style and spacing to fit our gears later, and the shadow makes it really come off the screen a bit.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you notice that the belt is not animating smoothly, meaning it’s rotating but pauses slightly every few seconds or so, what you can do is play around with the <code>dashPhase</code> value, which is used to specify the starting point of the dashes in a dashed or dotted line. I set it to an initial value of <code>45</code> and that removed the pause for me, but if it does not remove it for your project, simply increase or decrease that value by 1, check the animation, and then tweak the value again by 1 until you find the sweet spot. </p>
<p>And that’s <a id="_idIndexMarker388"/>another file under our belt (sorry, couldn’t help myself!). Let’s continue on to the next section, where we’ll add a gear shaft to the mix. This object will turn a belt, which, in turn, will spin a fan.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor101"/>Animating a gear shaft image</h1>
<p>Continuing <a id="_idIndexMarker389"/>on to the next component, we need a gear shaft. A gear shaft is a cylindrical rod that has round gears at each end and is used to attach other gears or belts together, ultimately producing some form of output or work. For example, within the motor in your car, there is a gear shaft that turns due to the gasoline combusting. The output or work produced by that process moves the car forward. Our gear shaft won’t move a car, but instead, will turn a fan. After creating this, as with the worm gear, we will animate the gear shaft by using animating rectangles. Again, this is because the image we are using is not round, so we cannot rotate it on the <em class="italic">z</em>-axis like the other gear images.</p>
<p>Let’s start off by creating a new SwiftUI View file, which we’ll call <code>GearShaftView</code>. Next, let’s add the variables we need for this file; we only need one variable, and that’s to track the animation:</p>
<pre class="source-code">
 @State var animateRect: Bool = false</pre>
<p>After the variable, we just need to add the code for the gear shaft image and animate it. Add the following<a id="_idIndexMarker390"/> code inside the <code>body</code> property:</p>
<pre class="source-code">
var body: some View 
        ZStack {
            ZStack {
                Image("shaft").resizable().frame(width: 160,                   height: 40)
                Rectangle().frame(width: 140, height: 8)
                    .foregroundColor(.black)
                    .cornerRadius(5)
                    .opacity(animateRect ? 0 : 0.5)
                    .animation(Animation.easeInOut(duration:                       0.5).repeatForever(autoreverses: true),                       value: animateRect)
                    .onAppear() {
                        animateRect.toggle()
                    }.offset(x: 0, y: -7)
            }
        }
    }</pre>
<p>We start by bringing the gear shaft image into the scene and setting the width and height dimensions for it. After that, we add a rectangle, which will be the animating shadow moving up and down over the shaft. The color of the shadow is black, with a little bit of a corner radius added on. The opacity will animate from 0, which is invisible, to 0.5, which is 50% visible. This will produce a nice shadowy rectangle that appears and disappears at the same cadence that the gears and shafts are turning.</p>
<p>In the next line of code, the animation is added, with a duration of one-half a second to complete one revolution. It has <code>autoreverses</code> set to <code>true</code> because if we set <code>autoreverses</code> to <code>false</code>, then the animation would look too abrupt (it needs <code>autoreverses</code> in order to slide the rectangle back down).</p>
<p>Then, we <a id="_idIndexMarker391"/>start the animation in the <code>onAppear</code> method and offset the rectangle so it’s neatly placed exactly where we want it, over the shaft image, using the <code>offset</code> modifier set to <code>0</code> for <code>x</code> and <code>–7</code> for <code>y</code>. </p>
<p>We are getting close to putting all these files together, but next up, we’re going to animate the fan image.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor102"/>Animating a fan image</h1>
<p>There are <a id="_idIndexMarker392"/>actually two components left to create, the fan and the motor. However, we will add the motor when we start piecing all of the files together inside <code>ContentView</code>. For that reason, let’s focus on creating the fan now. </p>
<p>Like always, create a new file, select the <code>FanView</code>. In this file, we only need two variables – one for the state of the animation and one to hold the degrees of rotation for the fan; here they are:</p>
<pre class="source-code">
       @State private var rotateFan = false
    var degrees: Double = 360 * 4</pre>
<p>This file is quite short, so just add the following code to complete it:</p>
<pre class="source-code">
var body: some View {
        ZStack {
        Image("fan").resizable().aspectRatio(contentMode:           .fit).frame(width: 200)
            .rotationEffect(.degrees(rotateFan ? degrees : 0),               anchor: .center)
            .animation(Animation.linear(duration: 4)              .repeatForever(autoreverses: false),               value: rotateFan)
        }.onAppear() {
            rotateFan.toggle()
        }.shadow(color: .black, radius: 15)
    }</pre>
<p>Let’s review this code. Inside the <code>ZStack</code>, we added the image of the fan and resized it. Then we used the <code>rotationEffect</code> modifier on it to make it turn. We want the fan to spin around its center, so we set the anchor to <code>center</code>, and then add the animation with a <a id="_idIndexMarker393"/>duration of <code>4</code>, which means it will spin 4 revolutions in 4 seconds. After that, set the animation to <code>repeatForever</code> and set <code>autoreverses</code> to <code>false</code> (reverse because we want the fan to spin only in one direction).</p>
<p>Then, let’s start the animation using the <code>onAppear</code> modifier and add a nice heavy shadow around the fan with a <code>15</code>-point radius.</p>
<p>And that completes the fan. Now, let’s now head over to <code>ContentView</code> to create the final component – the motor – and start bringing all the files together in one view.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor103"/>Bringing everything together in ContentView</h1>
<p>Okay – we have accomplished a lot, including creating files for single and double gears, a worm gear, a gearshift, and a fan. Now, let’s create the final file for the motor and organize all<a id="_idIndexMarker394"/> these files together in <code>ContentView</code>. </p>
<p>We’re going to use a Swift feature <a id="_idIndexMarker395"/>called <strong class="bold">Pragma Marks</strong>; this is a special syntax that labels and delineates blocks of code with a very thin line between them and makes those labels appear in one drop-down menu for easy searching and navigation. That’s very helpful when you have very large files with hundreds or thousands of lines of code.</p>
<p>We will also use a SwiftUI feature called <code>ContentView</code> file by grouping multiple objects together, such as views, scenes, or even commands, into a single unit. We will organize much of the code into groups based on whether it is animated on the <em class="italic">x</em>-, <em class="italic">y</em>-, or <em class="italic">z</em>-axis.</p>
<p>And then we will use the <strong class="bold">ZIndex</strong> modifier. This <a id="_idIndexMarker397"/>modifier works with views that are overlapping each other, so it can be used to force a view either to the front or the back of other views. This is important because sometimes we need a view to be more prominent in the scene and another view to be hidden behind the scene, with only parts of it visible. You’ll see how this works soon. </p>
<p>To help you complete this project, I have also labeled all the views to help you identify their location on the screen, and how they are oriented:</p>
<div><div><img alt="Figure 7.8: Our project with the views labeled " src="img/B18674_07_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Our project with the views labeled</p>
<p><strong class="bold">G</strong> annotations refer to the <a id="_idIndexMarker398"/>gears and <strong class="bold">B</strong> annotations refer to the belts. I numbered each gear and belt according to how it will appear in the code. We will be writing this code sequentially by the numbers – so, <strong class="bold">G1</strong>, then <strong class="bold">G2</strong>, then <strong class="bold">G3</strong>, and so on. The diagram shows the placement of all the parts.</p>
<p>As always, we have the <code>ContentView</code> file already created for us when we started the project, so we don’t need to create any more new files. The first thing we are going to do here in <code>ContentView</code> is to add the motor.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor104"/>Adding the motor</h2>
<p>To <a id="_idIndexMarker399"/>add the motor, move into the <code>body</code> property of <code>ContentView</code> and then add a main <code>ZStack</code> to hold everything. Then, inside that, place another <code>ZStack</code>:</p>
<pre class="source-code">
ZStack {
     ZStack {
            }
       }</pre>
<p>Inside the second <code>ZStack</code>, let’s add our first organizational structure, the Pragma Mark. To make a Pragma Mark, the syntax requires two forward slashes and <code>MARK</code> written in capital letters, followed by a colon. That will create a thin line moving across the file. You can write whatever you want after that for the title.</p>
<p>So, to create a Pragma Mark for the motor, enter the following code:</p>
<pre class="source-code">
 //MARK: - MOTOR</pre>
<p>Now, notice the very thin line that the Pragma Mark creates from one end of the code file to the other within the editor:</p>
<div><div><img alt="Figure 7.9: Our first Pragma Mark " src="img/B18674_07_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: Our first Pragma Mark</p>
<p>The Pragma Mark also does something very useful behind the scenes too. If you look at the top left of your Xcode menu bar, where all the tabs appear, you’ll see a <strong class="bold">MOTOR</strong> tab:</p>
<div><div><img alt="Figure 7.10: The Pragma Mark tab " src="img/B18674_07_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: The Pragma Mark tab</p>
<p>If you click on the tab, a drop-down menu will open up, containing all the Pragma Marks that you created; clicking on any one of them will take you immediately to the code in that part <a id="_idIndexMarker400"/>of the file. You’ll see the usefulness of this when you have dozens or even hundreds of different blocks of code in one file, eliminating the need to scroll through a lengthy file. </p>
<p>Now, let’s add the code that creates the motor in the scene:</p>
<pre class="source-code">
Group {
       Image("motor").resizable().aspectRatio(contentMode:          .fit).frame(width: 140, height: 120)
           .offset(x: -120, y: 90)
                }</pre>
<p>This is our first time using the <code>Group</code> syntax. Looking at the code inside the group, it contains everything that we’ve been doing all along: creating the motor using the image that’s in the Assets catalog, resizing it, setting the aspect ratio so the motor fits on the screen as we want, giving it a frame size, and offsetting on the <em class="italic">x</em>- and <em class="italic">y</em>-axis.</p>
<p>If we run the code, this is what we should have in the previews so far:</p>
<div><div><img alt="Figure 7.11: The motor " src="img/B18674_07_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11: The motor</p>
<p>There’s <a id="_idIndexMarker401"/>only one object in that group, the motor, but that’s perfectly fine – we’ll be adding more objects into further groups as we make them. For now, let’s now add some gears to the scene.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor105"/>Adding the gears along the x-, y-, and z-axes</h2>
<p>In this<a id="_idIndexMarker402"/> section, we will use the <code>GearView</code> struct to add the gears. Remember, we already designed and animated the gears in the <code>GearView</code> file, so all we need to do is call the <code>GearView</code> struct here in <code>ContentView</code> and pass in some values.</p>
<p>This is where we will also be rotating the gears and belts on the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axes, so to recap how each axis operates on the screen (shown back in <em class="italic">Figure 7</em><em class="italic">.1</em>):</p>
<ul>
<li>The <em class="italic">y</em>-axis runs from top to bottom and bottom to top.</li>
<li>The <em class="italic">x</em>-axis runs from left to right and right to left.</li>
<li>The <em class="italic">z</em>-axis moves from back to front or <a id="_idIndexMarker403"/>front to back. Holding an object in your hand and moving closer to your eyes is an example of moving that object along the <em class="italic">z</em>-axis.</li>
</ul>
<p>With that understanding, let’s start adding components. Put the following code in right after the closing brace of the motor group:</p>
<pre class="source-code">
      //MARK: - GEARS ANIMATING ON THE Z AXIS
                Group {
                    ///Gear 1
                    GearView(gearImage: "doubleGear",                       gearWidth: 40, gearDegrees: 360,                       offsetGearX: -124, offsetGearY: 102,                       duration: 5)
                    ///Gear 2
                    GearView(gearImage: "doubleGear",                       gearWidth: 100, gearDegrees: 360,                       offsetGearX: -124, offsetGearY: -280,                       duration: 7)
                    ///Gear 3
                    GearView(gearImage: "doubleGear",                       gearWidth: 100, gearDegrees: 360,                       offsetGearX: 124, offsetGearY: -280,                       duration: 7)
                    ///Gear 4
                    GearView(gearImage: "doubleGear",                       gearWidth: 100, gearDegrees: 360,                       offsetGearX: 124, offsetGearY: -70,                       duration: 7)
                    ///Gear 5
                    GearView(gearImage: "doubleGear",                       gearWidth: 80, gearDegrees: -360,                       offsetGearX: 49, offsetGearY: -113,                       duration: 5)
                    ///Gear 6
                    GearView(gearImage: "doubleGear",                       gearWidth: 100, gearDegrees: 360,                       offsetGearX: -6, offsetGearY: -80,                       duration: 7)
                }</pre>
<p>I titled this<a id="_idIndexMarker404"/> group <code>GEARS ANIMATING ON THE Z AXIS</code>. Here, I’m calling the <code>GearView</code> struct six times, which creates six gears that are turning on the <em class="italic">z</em>-axis. Let’s just look at <code>Gear 1</code>, as they are pretty similar, just with different values.</p>
<p>So, in <code>Gear 1</code>, I set the gear’s width to <code>40</code> points, which makes a small gear, and positioned it directly over the front of the motor using the <code>offsetGearX</code> and <code>offsetGearY</code> parameters. The amount of degrees passed into the <code>gearDegrees</code> parameter is <code>360</code>; that’s one revolution of a circle, as we want these gears to turn for a full revolution.</p>
<p>Since these are 2D images and not 3D images of gears, the depth is not really perceivable, and the gears will lie flat and be animated clockwise. The <code>duration</code> parameter controls the amount of time it takes the gear to turn one full revolution; I’m using a value of <code>7</code> for the larger gears, and a value of <code>5</code> for the smaller ones. The small and larger gears are made using the <code>gearWidth</code> parameter.</p>
<p>Looking at the <code>gearDegrees</code> parameter, the values I’m using are all set to <code>360</code> (a positive number) to move them clockwise. Well, that is except for <code>Gear 5</code>, which is set to <code>-360</code> (a negative), as that gear will move counterclockwise.</p>
<p>This is what the previous code we just wrote should look like:</p>
<div><div><img alt="Figure 7.12: The gears rotating on the z-axis " src="img/B18674_07_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12: The gears rotating on the z-axis</p>
<p>If you run <a id="_idIndexMarker405"/>this in the simulator, all of those gears will now be turning because we set the animation up already in the <code>GearView</code> file. </p>
<p>Let’s continue and add another group of gears that animate on the <em class="italic">y</em>-axis this time. Add the following code right under the closing brace of the previous group:</p>
<pre class="source-code">
                //MARK: - GEARS ANIMATING ON THE Y AXIS
                Group {
                    ///Gear 7
                    GearView(gearImage: "singleGear",                       gearWidth: 100, gearDegrees: -360,                       offsetGearX: -62, offsetGearY: -85,                       rotateDegrees: 76, duration: 7, xAxis: 0,                       yAxis: 1, zAxis: 0)
                    ///Gear 8
                    GearView(gearImage: "singleGear",                       gearWidth: 25, gearDegrees: -360,                       offsetGearX: -59, offsetGearY: 19,                       rotateDegrees: 76, duration: 7, xAxis: 0,                       yAxis: 1, zAxis: 0)
                    ///Gear 10
                    GearView(gearImage: "singleGear",                       gearWidth: 100, gearDegrees: -360,                       offsetGearX: 160, offsetGearY: 94,                       rotateDegrees: 76, duration: 7, xAxis: 0,                       yAxis: 1, zAxis: 0)
                    ///Gear 11
                    GearView(gearImage: "singleGear",                       gearWidth: 25, gearDegrees: -360,                       offsetGearX: 163, offsetGearY: 252,                       rotateDegrees: 76, duration: 7, xAxis: 0,                       yAxis: 1, zAxis: 0)
                }</pre>
<p>Again, we <a id="_idIndexMarker406"/>start off this group of code by adding our organizational Pragma Mark called <code>GEARS ANIMATING ON THE Y AXIS</code>. Here, we call the <code>GearView</code> struct four times, creating four gears that will rotate on the <em class="italic">y</em>-axis.</p>
<p>Looking at <code>Gear 7</code> as an example, this has a width of <code>100</code> points, and <code>gearDegrees</code> is set to <code>-360</code> (which means the gear rotates counterclockwise). Next, the code repositions the gears using the <code>offsetGearX</code> and <code>offsetGearY</code> parameters. And by using the <code>rotateDegrees</code> parameter, and passing in a value of <code>76</code>, we can rotate this gear on the <em class="italic">y</em>-axis.</p>
<p>The other three gears are almost exactly the same, except their size and offset locations vary, but they will all turn on the <em class="italic">y</em>-axis.</p>
<p>After adding this group of code, this is what your previews should look like:</p>
<div><div><img alt="Figure 7.13: The gears rotating on the y-axis " src="img/B18674_07_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13: The gears rotating on the y-axis</p>
<p>Now, when you run the simulator, all these gears will <a id="_idIndexMarker407"/>be turning on their set axis.</p>
<p>Let’s continue and add another group that will make a gear animate on the <em class="italic">x</em>-axis. Add the following code right after the closing brace of the previous group:</p>
<pre class="source-code">
  //MARK: - GEAR ANIMATING ON THE X AXIS
   Group {
                    ///Gear 9
                    GearView(gearImage: "singleGear",                       gearWidth: 175, gearDegrees: 360,                       offsetGearX: 60, offsetGearY: 39,                       rotateDegrees: 84, duration: 7,  xAxis:                       1, yAxis: 0, zAxis: 0)
                }</pre>
<p>The <code>GEAR ANIMATING ON THE X AXIS</code> group just has one gear here and it’s the biggest gear <a id="_idIndexMarker408"/>so far, with a width of <code>175</code> points. This gear will mesh up with two other gears – the gear to its right in the scene and the worm gear.</p>
<p>This is similar to the code we’ve already placed for the other gears in that we use the <code>GearView</code> initializer to create it and use the same parameters to size and locate it in the scene, but the difference here is that we’re using the <code>xAxis</code> parameter, and passing in a value of <code>1</code>. The <code>xAxis</code> parameter will rotate this gear on the <em class="italic">x</em>-axis, a completely different angle than for the <em class="italic">y</em>-axis or <em class="italic">z</em>-axis. The amount of rotation is <code>84</code> degrees.</p>
<p>Before we run this and check things out, let’s add the worm gear to see how everything fits together. </p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor106"/>Adding the worm gear</h2>
<p>To add the<a id="_idIndexMarker409"/> worm gear to our <code>ContentView</code>, add the following code:</p>
<pre class="source-code">
 //MARK: - WORM GEAR
                Group {
                    WormGearView().offset(x: 60, y: 30).                      zIndex(-1)
                }</pre>
<p>This grouping is labeled <code>WORM GEAR</code> and is placed using the <code>offset</code> modifier. Something new here though is the <code>zIndex</code> modifier. The <code>zIndex</code> modifier places a view in front of or behind other views, which allows us to position our views from front to back or vice versa.</p>
<p>I’ve talked<a id="_idIndexMarker410"/> about the <em class="italic">z</em>-axis already, which relates to depth and objects moving closer to and farther away from us. Why would we want to move a view closer or further away from our perspective? Well, let’s look at an example of what happens if we don’t use the <code>zIndex</code> modifier in our code:</p>
<div><div><img alt="Figure 7.14: Adding the worm gear without zIndex " src="img/B18674_07_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14: Adding the worm gear without zIndex</p>
<p>From the illustration, you can see that the worm gear has now moved to the front, which is not the placement that I want. I want the worm gear to mesh up from behind <code>Gear 9</code>.</p>
<p>Let’s now add the <code>zIndex</code> modifier back into our code and look at the results:</p>
<div><div><img alt="Figure 7.15: Adding the worm gear with zIndex " src="img/B18674_07_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15: Adding the worm gear with zIndex</p>
<p>All views in<a id="_idIndexMarker411"/> SwiftUI have a default <code>zIndex</code> of <code>0</code>, so when I passed in a negative number, the worm gear was placed behind <code>Gear 9</code>. As you can see, this can be an important modifier when trying to organize your views regarding how close or far away you want them to be. </p>
<p>And with that, we have finished all the gears, so now we can move on to adding the belts into the scene. </p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor107"/>Adding the belts</h2>
<p>Continuing <a id="_idIndexMarker412"/>with the building out of our scene, let’s add the belts. Add the following grouping, which contains three belts that move on the <em class="italic">z</em>-axis:</p>
<pre class="source-code">
//MARK: - BELTS ON THE Z AXIS
                Group {
                    ///Belt 1
                    BeltView(animateBelt: true, beltWidth:                       425, beltHeight: 48, offsetBeltX: -124,                       offsetBeltY: -90, rotateDegrees: 90)
                    ///Belt 2
                    BeltView(animateBelt: true, beltWidth:                       352, beltHeight: 100, offsetBeltX: 0,                       offsetBeltY: -280, rotateDegrees: 0)
                    ///Belt 3
                    BeltView(animateBelt: true, beltWidth:                       258, beltHeight: 48, offsetBeltX: 124,                       offsetBeltY: -175, rotateDegrees: 90)
                }</pre>
<p>Here, we called the <code>BeltView</code> struct, set the <code>animateBelt</code> properties to <code>true</code>, and then gave each belt an appropriate width and height so it could connect to its corresponding gears using the <code>beltWidth</code> and <code>beltHeight</code> parameters. After that, we place the belts where they need to be using the <code>offsetBelt</code> parameters. Finally, we rotated the belts either by <code>90</code> degrees, which places the belt vertically, or by <code>0</code> degrees, which places the other belt horizontally. Here’s what they look like in relation to the gears they mesh with:</p>
<div><div><img alt="Figure 7.16: The belts on the z-axis " src="img/B18674_07_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16: The belts on the z-axis</p>
<p>Now, let’s <a id="_idIndexMarker413"/>take a look at rotating belts on the <em class="italic">y</em>-axis. As before, add the following code after the closing brace of the previous group:</p>
<pre class="source-code">
  //MARK: - BELTS ON THE Y AXIS
                Group {
                    ///Belt 4
                    BeltView( beltWidth: 32, beltHeight: 125)
                        .rotation3DEffect(.degrees(75), axis:                           (x: 0, y: 1, z: 0))
                        .offset(x: -60, y: -33)
                    ///Belt 5
                    BeltView(beltWidth: 28, beltHeight: 180,                       offsetBeltY: -10)
                        .rotation3DEffect(.degrees(75), axis:                           (x: 0, y: 1, z: 0))
                        .offset(x: 162, y: 185)
                }</pre>
<p>Calling the <code>BeltView</code> struct again, we have set these two belts to a width and height appropriate for the gear they<a id="_idIndexMarker414"/> will be meshed with. Then, we used the <code>rotation3DEffect</code> modifier and rotated these belts on the <em class="italic">y</em>-axis. The rotation happens when we pass a value of <code>1</code> into the <code>y</code> parameter, and they will rotate by <code>75</code> degrees. As with the other belts, we offset them so that they line up with their corresponding gears using the <code>offset</code> modifier. </p>
<p>Now, your previews should look like this:</p>
<div><div><img alt="Figure 7.17: The belts on the y-axis " src="img/B18674_07_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17: The belts on the y-axis</p>
<p>All those<a id="_idIndexMarker415"/> belts and gears will be fully animated if you run the project in the simulator. That leaves us with only two more groups to go – the gear shaft and fan, and a background.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor108"/>Adding the gear shafts</h2>
<p>To<a id="_idIndexMarker416"/> bring the shafts into the scene, add the following code next:</p>
<pre class="source-code">
//MARK: - GEAR SHAFTS
                Group{
                    ///Shaft 1
                    GearShaftView().offset(x: 5, y: 28).                      zIndex(-1)
                    ///Shaft 2
                    GearShaftView().offset(x: 95, y: 260).                      zIndex(-1)
                }</pre>
<p>This is <a id="_idIndexMarker417"/>our <code>GEAR SHAFT</code> group. Here, I’m calling the <code>GearShaftView</code> struct twice, to create two gear shafts. Then, all we have to do is simply offset them to the proper locations, and call <code>zIndex</code> on them, passing in a negative value. This will position them behind the other views, creating the illusion that the shaft is actually part of the worm gear. Here’s what the previous code produced:</p>
<div><div><img alt="Figure 7.18: The gear shafts " src="img/B18674_07_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18: The gear shafts</p>
<p>The<a id="_idIndexMarker418"/> worm gear and the gear shaft are the two objects that we could not animate with conventional methods because that would not look good, and it wouldn’t be an accurate representation of how they turn in the physical world. So, we created our shadow boxes and placed them strategically over these two shafts. When you run this in the simulator, you’ll notice these rectangles appear to make the worm gear and two shafts turn.</p>
<p>Remember, these are just images that are sitting on the screen doing nothing, but because of a little trickery, they actually appear like they’re turning!</p>
<p>Now, let’s add the final group – the fan.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor109"/>Adding the fan</h2>
<p>It<a id="_idIndexMarker419"/> would be nice if all of these gears and belts would produce some sort of output, so in this project, that output will be to spin a fan. Let’s now add the final grouping of code right under the existing group:</p>
<pre class="source-code">
  //MARK: - FAN
                Group {
                    ///Fan
                    FanView().offset(x: 0, y: 250).frame(width: 140, height: 140)
                }</pre>
<p>All we have done is called the <code>FanView</code> struct, offset it to the bottom of the scene, and set a width for it (since it’s round, we don’t need to set a height). </p>
<p>Nearly there, just one last task: adding a background. </p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor110"/>Adding the background</h2>
<p>I have a nice <a id="_idIndexMarker420"/>gold background that’ll look great with all the objects against it, so let’s come out of the main <code>ZStack</code>, and after its closing brace, add the following code:</p>
<pre class="source-code">
 //MARK: - BACKGROUND
.background(Image("goldBackground").resizable().aspectRatio(contentMode: .fill)
            .frame(width: 400, height: 1000))</pre>
<p>This sets the gold background to a frame width and height of <code>400</code> x <code>1000</code>, sitting nicely on an iPhone. </p>
<p>Finally, run that in the simulator and see what you think:</p>
<div><div><img alt="Figure 7.19: The completed project " src="img/B18674_07_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19: The completed project</p>
<p>Feel <a id="_idIndexMarker421"/>free to play around with all the parameters and settings, changing the colors of the belts or objects, changing the angles of rotation, and so on. This will allow you to really understand what these parameters and functions all do, and how they synergistically work together!</p>
<p>Also, notice that we continued to use Pragma Marks throughout the project. Let’s see how handy they are; so, come back up to the menu bar and click on the last tab (this tab doesn’t have a name, but you can <em class="italic">always</em> find the Pragma Marks in the last tab of the menu bar):</p>
<div><div><img alt="Figure 7.20: Viewing the Pragma Marks of the project " src="img/B18674_07_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20: Viewing the Pragma Marks of the project</p>
<p>Every<a id="_idIndexMarker422"/> Pragma Mark indicates a different area of code based on the title we gave it, which makes it very easy to jump to in an instant, regardless of how big the file is.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor111"/>Summary</h1>
<p>In summary, through creating this project, we’ve accomplished quite a bit. As before, you saw how to create separate files – in this case, gears and chains – how to make a marching ants effect, how to combine everything into <code>ContentView</code>, and how to organize the code neatly using Pragma Marks and Groups. You also learned how to animate objects on all three axes, <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-, and saw how to use <code>zIndex</code> to place views more dynamically, from back to front, and vice versa.</p>
<p>In the next project, we will look at animating a flower and its petals so that it appears to be breathing, and creating some snow in the background.</p>
</div>
<div><div></div>
</div>
</body></html>