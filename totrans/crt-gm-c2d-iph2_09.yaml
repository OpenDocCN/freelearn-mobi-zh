- en: Chapter 9. Running and Running and Running...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will be exploring randomly generated landscapes, how to create
    a lot of different enemies with very little code, parallax scrolling, and using
    particle effects for extra visual flair. We've covered a lot of the smaller housekeeping
    details several times, so for this project we will be focusing on the new, interesting
    code and not re-covering old ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Randomizing terrain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endless scrolling parallax backgrounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your own sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation made simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time around we will be designing a side scrolling endless runner. The
    endless runner game style has really taken off in the mobile gaming world, and
    it is a fun game style to implement using Cocos2d. Basic gameplay will be a simple
    two-touch control method: touches on the left half of the screen make the hero
    jump and touches on the right half of the screen will make the hero shoot. The
    game will scroll continuously, leaving no time for the player to stop and rest.
    As the game progresses, it will steadily increase the scrolling speed, so it gets
    harder the longer you play. For all of our graphics (except for the background
    images), we will be using the Planet-X graphics created by James Macanufo at [http://tintanker.com](http://tintanker.com),
    used here with the creator''s permission. You can find his original images at
    [http://tintanker.com/makegameswithus](http://tintanker.com/makegameswithus).
    If you enjoy the graphics, James deserves full credit for this fun and whimsical
    set.'
  prefs: []
  type: TYPE_NORMAL
- en: Design review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are designing a side-scrolling endless runner, there are two primary
    design approaches. Some will use a physics engine like Box2D or Chipmunk to help
    control all of the object interactions. We will be taking the other approach by
    building our own lightweight physics engine for the game. All of our ground will
    use square tiles, so we can easily identify the surfaces our hero can walk on
    safely. We will build sensors on the top of all walkable surfaces, as well as
    building sensors underneath each of our walking characters (hero and enemies).
    The hero will be in a fixed x coordinate on the screen, and the world will scroll
    past the hero. We will have two types of enemies: flying and walking. Both will
    have similar behavior, but the walkers will have the sensors we mentioned to allow
    them to walk back and forth on their platforms. Enemies will not be allowed to
    walk off the platforms to their death. We will also implement a two level endless
    parallax background from scratch. Finally, we want some fun effects when enemies
    (or the hero) die. We will be using particle effects, built using Particle Designer.
    We will only measure the player''s success in the game with one metric: distance
    travelled. That about covers the basics of the design, so let''s take a peek at
    the finished game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design review](img/9007_9_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the ground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by building the random ground tiles. For our game, we have three
    types of ground, with three ground images for each type, so we can build stacks
    with them. For organization, the image that has a gradient color (the bottom)
    will be identified as `1`, the middle as `2`, and the top (with the grassy surface)
    as `3`. Let's take a look at the code to build the ground, in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m` (`addGround…`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We start this method by randomizing the width, the height, and the type (graphic
    set) for the platform. The width and height are both expressed in terms of how
    many tiles we will use for this platform. You will notice that the width adds
    `2` to the result of the `arc4random()` call. This is because we want the platform
    to be a minimum of 2 tiles wide. Anything smaller is too challenging to land on,
    once we add enemies into the mix. We then move into a big `switch` statement,
    passing it the `platformHeight` variable. We have designed "stacks" for the different
    elevations to be more playable. The tile type 3 is the only type of walkable tile,
    so we need to make sure there is a walkable tile on top. This predefined stack
    approach guarantees we will have something that looks more pleasant and is playable.
    You will notice that the case 4 has two uses of tile type 3 (the walkable tile)
    in the stack. This will give that "stack" two separate platforms for the hero
    to walk on. We do this for variety, but also to make sure we don't have an impossible
    arrangement, if the terrain goes directly from an elevation 1 to an elevation
    4\. The lower surface gives the hero something else to land on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m` (`addGround…`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a stack defined, we iterate through the number of tiles wide
    we need. The `maxTileX` variable is populated with the `x` position we need for
    the current stack of tiles. Once that is updated for the current stack, we enter
    another loop, based on the `platformHeight` variable. We get the next tile from
    the `platformStack` array, and build the sprite name in the `tileNm` variable.
    This is a case where the consistent naming convention of the files really helps
    out. We then create a new `ERTile` object. `ERTile` is a subclass of the `CCSprite`
    class, which we will look at in just a few moments. We set the anchor point to
    center bottom so we can easily build the tiles from the bottom of the screen,
    and we define the `y` value by multiplying times the `tileSize` variable we define
    in our `init` method (50, the size in points of the square tiles). We then check
    to see if the tile is type 3\. Remember, tile 3 is a walkable surface. If it is
    a walkable surface, we set the tile's `isTop` value to `YES`. (We also try to
    generate an enemy on the walkable surface some percentage of the time.) Finally,
    we set the position of the tile, add it to the `grndArray` array, and add the
    tile as a child of the `runnersheet` (our `CCSpriteBatchNode` which houses all
    of our foreground images). The last thing we do here is to remove all objects
    from the `platformStack` array, so it will be ready for the next time we add ground.
  prefs: []
  type: TYPE_NORMAL
- en: ERTile class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said that `ERTile` is a subclass of the `CCSprite` class, but for most purposes
    it acts like a normal sprite. Let's take a look at the implementation file to
    see why we need it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERTile.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These two methods are the only methods included in the `ERTile` class. We define
    variables and properties for the `topSensor` and `isTop`, but that's it for this
    class. The main piece we need to understand is the sensor. The `topSensor` is
    a `CGRect` we define in relation to the bounding box of the tile. As you can see,
    this `topSensor` is the full width of the sprite and is `5` points high, a few
    points inside the top of the sprite. This is the level at which "ground" will
    be defined for this tile. To use this, we also override the `setPosition` method.
    When the `setPosition` method is called, it sends the same command to the `super`
    version of itself (that is, `CCSprite` class), and if the `isTop` value is `YES`,
    then it calls to the `defineSensors` method. We have to keep redefining it because
    the `CGRect` will otherwise stay exactly where you put it on screen, even if the
    sprite itself moves. By redefining it with every `setPosition` call, we guarantee
    it is exactly where we need it, relative to the tile.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways we could have accomplished this same effect, including
    invisible child sprites under the `ERTile` class. We have chosen this approach
    because a `CGRect` is a lot less resource intensive than defining another sprite
    for every tile (and character). For our purposes, this `CGRect` implementation
    is fast, reliable, and because we tie it into the overridden `setPosition` method,
    it is invisible to any other methods that manipulate the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Adding gap tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't want end-to-end ground, since we need the ability for our hero to fall
    to his death. We build these gap tiles in much the same fashion as the ground
    tiles, except the gap tiles are only one tile high.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The structure of this method is pretty similar to the ground tile method. We
    start by using a randomizer to determine if we need a gap or not. We have a three
    in five chance that we will build a gap (if the `gapRnd` value is greater than
    `1`). This lets us have some ground-to-ground passages for more variety. We control
    the width of the gaps a little differently. We take the `MIN` value of the `scrollSpeed`
    variable or `5`, so when the game is scrolling slower, the gaps will also be smaller.
    But as the game ramps up in speed, we don't want any tile gaps larger than 5\.
    The loop in this method is virtually identical to the one in the ground method,
    except these tiles are never walkable. We also randomize the creation of flying
    enemies over the gaps. The chance is lower than with walking enemies, and we randomize
    their starting elevation between `y` values of 250 and 289\. Finally, whenever
    we build a gap, we immediately call the method to build the ground tiles. This
    ensures that we don't have to worry about which method to call later on. We simply
    call the `addGapTiles` method, and it takes care of both of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling the tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our game, there is a lot that needs to be updated, so we have broken out
    our `update` method into individual methods for each type of update. Let's take
    a look at how we update the tiles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first callout here is that we have a variable in our layer called `isScrolling`
    that controls whether or not the world is scrolling. It is a simple Boolean variable,
    used to start or stop the scrolling as we see fit. We also have a `scrollSpeed`
    variable, which controls the speed of the scroll. In our `init` method we start
    this at a value of `2.5f`. In this method, we go through every tile in the `grndArray`
    array, and add the negative of the `scrollSpeed` value (to move everything left)
    to the current position of each tile. We then update our distance travelled, and
    call out to the HUD to update the display. (Note: we will not be discussing the
    HUD layer here. It is structurally the same as how we built the HUD in [Chapter
    8](ch08.html "Chapter 8. Shoot, Scroll, Shoot Again"), *Shoot, Scroll, Shoot Again*,
    so flip back there for a refresher, if needed). We also increase the scroll speed
    a little bit each time this method is called, so the speed will slowly increase
    as the game progresses.'
  prefs: []
  type: TYPE_NORMAL
- en: After we move everything, we need to do some tile maintenance. We look for any
    tiles whose `x` value is less than `-100`, and remove them. At the same time,
    we reset the `maxTileX` value to the `x` position of the rightmost tile we find.
    If that `maxTileX` value is less than `1.1` times the width of the screen, we
    call to the `addGapTiles` method to build some gaps and ground. That's all it
    takes to make a scrolling, randomly generated ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one slight issue, however. There will be visible seams between the
    tiles. Fortunately, this has a simple fix. In the cocos2d source files, there
    is a file called `ccConfig.h`. Open this file and find the line (line 85, in the
    2.0 version) that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ccConfig.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Change the value of `0` to `1`, and the seams disappear. How easy is that?
  prefs: []
  type: TYPE_NORMAL
- en: Parallax background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to our hero, let''s turn our attention to the other endless
    element of the game: the background. We want to have a two-layer parallax background
    that is endlessly scrolling. A parallax background is simply one that has multiple
    layers that scroll at different rates, to simulate the way that distant terrain
    looks like it is moving slower than closer terrain. We simulate this by throttling
    the scrolling speed of each layer of the background to a relative speed. Let''s
    look at our background class and see how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERBackground.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ERBackground` class is a subclass of the `CCLayer` class. Here we simply
    add two sprites to the layer using the `bg_mtns.png` image. You will notice we
    aren't using a sprite sheet here. Since it is a single image, there would be minimal
    performance gains using a sprite sheet here. We position one at (`0,0`) and the
    other at (`1001,0`). The image itself is 1000 points wide, so this will put them
    one after the other. We flip the second sprite to add some variety to the landscape,
    even though we are using the same image twice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERBackground.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the same image for both of the parallax layers, so we want
    to make one seem farther away. The `useDarkBG` method call will darken the image
    by about half when this method is called. Now we need to be able to move the background
    and make it endless.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERBackground.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the `update` method is called, we move both images to the left by their
    designated `bgScrollSpeed` value. Then each background is checked to see if it
    is off-screen by 1000 points. If it is, then that sprite is repositioned to the
    right side of the other sprite. This means that every time one sprite is completely
    off-screen to the left, it is moved to the far right, so it will scroll through
    again. We obviously have a few parameters that need to be set from outside this
    class. Let's see how we set this up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m` (inside `init`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you see that the `background1` object calls the `useDarkBG` method, and
    sets a `bgScrollSpeed` value of `0.025`, which is nice and slow. These are the
    mountains in the distance. The other layer, `background2`, sets its initial offset
    to be `200` to the right (and sets the corresponding position), so the mountains
    do not start exactly on top of each other. It also uses a faster scrolling rate
    of `0.1`. That is all it takes to establish the mountains. The one piece that
    is left to complete the parallax is how to call the `update` method. We do not
    set any schedules in the `ERBackground` class. Instead, we call this `update`
    method manually from the playfield''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On each iteration of the playfield's `update` method, it calls out the background
    layers, and they take care of themselves with nothing else needed.
  prefs: []
  type: TYPE_NORMAL
- en: Our hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can turn our attention to our hero, the little spaceman. Let's start
    by looking through the `ERHero` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ERHero` class is a subclass of `CCSprite` class. Because we need a custom
    `init` method for the sprite, we have overridden the `spriteWithSpriteFrameName`
    class method and the corresponding `init` method. As the `_state` variable might
    lead you to guess, the hero will be operating as a simple state machine. Let''s
    see what states are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERDefinitions.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now we can look at how the states are changed for our hero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking to make sure we are not trying to reassign to the same
    state. If we are, we exit. We then stop all actions, because most of the actions
    are related to animations, so we want to stop the prior ones before running the
    new animation. The `isFlashing` check relates to when the hero gets hit (he flashes
    red for a brief moment). We put this check in here to see if the hero was flashing
    when the state is changed. If he is flashing, then we force the hero back to normal
    color. We do this because the `stopAllActions` method will also stop all actions,
    including the "tint color" actions. The end result is that without this clause,
    the hero would get stuck with a red tint if his state changed when he got hit.
  prefs: []
  type: TYPE_NORMAL
- en: The core of the `stateChangeTo` method is the switch statement at the bottom.
    It evaluates the state and calls the appropriate animation method. Finally, it
    defines the sensors, to make sure we have current sensors in place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see the same type of `defineSensors` method we saw in the `ERTile`
    class. The difference for the hero is that he has two sensors: one on his feet,
    and one below his feet. The `footSensor` variable will be used to identify state
    changes, and the `fallSensor` variable will be used to determine if the hero should
    be falling. We also use the same `setPosition` override method, for exactly the
    same reason: to keep the sensors in place during movement. Let''s see how the
    game looks with the sensors visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our hero](img/9007_9_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Animation loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have talked about playing animations, but we haven't actually created any
    yet. We will be using a helper method to load our animations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we see our two helper methods. The first takes quite a few parameters to
    build the animation. We pass it the name we want the animation stored as, the
    root of the filename, the extensions of the filename, the number of frames for
    the animation, and the time delay between frames. This assumes that any animations
    loaded will have an incremental number in their filenames. It then goes through
    the process of loading each frame and adding it to the frames array. Finally,
    it builds the animation and stores it in the `CCAnimationCache` under the `AnimName`
    string specified. Once it is loaded, you can simply request the animation by name
    from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The code needed to load an animation from the cache is a fairly long line of
    code, so we have also built a helper method to assist with retrieving the frames,
    `getAnim`. It returns a `CCAnimate` object to the caller. If we were not using
    this helper method, we would have to repeat the same line of code found inside
    that method every time we wanted an animation. Combined, these two methods save
    us from writing a lot of repetitive code. Now let's get back to our hero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This method is all we need to load the hero's animations. We call this method
    from the playfield after we have created the hero, because we need to reference
    the playfield in order to call the helper method (which we assign to the variable
    `pf`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the fruits of our animation coding labor. When the state changes
    to `kHeroRunning`, this method is called. We use our helper method to get the
    animation, and set it up to repeat forever. This will keep him running until the
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The landing animation is similar, except we only play it once.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The jumping animation is the most complex of the three. We play the animation
    once, and then state change the `kHeroInAir`, and play a jumping sound. The state
    `kHeroInAir` is used for the time the hero is airborne, but no special animation
    is playing. The sprite will remain as the last frame of the previous animation.
  prefs: []
  type: TYPE_NORMAL
- en: That covers everything in the hero class except for methods related to shooting
    and getting hit. We will come back to those when we discuss bullets and collisions
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier with the tile updates, we have also broken out the updates
    for the hero into a separate method in the playfield layer. Let's take a look
    at that method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this method we parse through all the different states that we may need to
    trigger or react to. If the hero is jumping, we decrease the `jumpTimer` variable
    by the current delta value. The `jumpTimer` variable controls how long the hero
    can be in the air in a single jump. When the timer reaches zero, the hero's state
    changes to `kHeroIsFalling`. If the timer is still greater than zero, we increase
    the hero's `y` position by 3 points. (As you may recall, the hero is always at
    the same `x` position, so we only have to concern ourselves with the y axis).
    If the hero is falling, then we apply our gravity by decreasing his `y` position
    by 3 points.
  prefs: []
  type: TYPE_NORMAL
- en: We then begin to make use of our sensors. We check to see if the hero's `footSensor`
    is touching any tile's `topSensor`. If it is, we push the hero up by 1 point,
    and change his state to `kHeroRunning`. We also check each tile to see if there
    is any contact between the hero's `fallSensor` and the tile's `topSensor`. If
    there is contact with any tile's sensor, then the `isFalling` local Boolean variable
    is set to `NO`. If there is no contact with any tile sensors, then the `isFalling`
    variable will still have the original `YES` we assigned to it, so we know the
    hero should be falling. We then check to see if the hero is currently running
    and if the `isFalling` variable is `YES`, then we change his state to `kHeroFalling`.
    After all of that, we actually set the new position to the hero. The last check
    is to see if the hero has fallen off the screen. If he has, we call the `gameOver`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Touch controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a hero to control, we need to look at the control methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After checking whether touches should be prevented or whether game over conditions
    have been met, we compare the locations of the touch to the left or right half
    of the screen. If the touch is on the left and the hero is currently running,
    we change state to `kHeroJumping`. We set the `jumpTimer` variable to the value
    of the `maxJumpTimer` variable (defined in the `init` method as 0.85), and we
    also set the `allowDoubleJump` variable to `YES`. This state change will trigger
    the correct movement behavior (moving up) in the `updateHero` method we just saw.
    We set the `allowDoubleJump` variable to give the player a little extra help.
    As you can see, the `allowDoubleJump` variable is only evaluated if the hero is
    not currently in the `kHeroRunning` state. Most of the code is the same as the
    first clause of the `if` statement, except we reset the `allowDoubleJump` to `NO`.
    Combined, this will allow the player to double-jump in mid-air, but it will prevent
    air-jumping a third time. (If you allow unlimited jumps from mid-air, the hero
    can actually fly forever!)
  prefs: []
  type: TYPE_NORMAL
- en: The final `else` clause will catch any touches on the right-hand side of the
    screen, and send the message to the hero to shoot.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We wrap up the touch handler by looking at the `ccTouchEnded` method. Here we
    must first check to make sure we are not in a game over condition. Without this
    check, if the hero died while a touch was still occurring, the game would crash
    as soon as the finger was lifted (since the hero sprite would be dead and gone).
  prefs: []
  type: TYPE_NORMAL
- en: Most of this is concerned with jumping, as you could probably assume. If the
    touch was on the left-hand side (jumping side), then we change the state to `kHeroFalling`,
    so gravity can take over.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we turn our attention to the bullets and allowing our hero to shoot. Let's
    look at the simple `ERBullet` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERBullet.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `ERBullet` class is nothing more than a subclass of the `CCSprite` class
    with a couple of extra Boolean variables to track. The `isShootingRight` Boolean
    variable helps us keep track of direction of travel for the bullet. Since we are
    only designing the game to allow flat trajectories for the bullets, we really
    just need to know if it is going left or right. We also use the `isHeroBullet`
    variable so we can keep track of whose bullet it is, for collision detection purposes.
    We will not allow "friendly fire", so enemies won't kill other enemies in this
    game. Now we can look at what the hero does when instructed to shoot.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We create a new bullet at the hero's position, give it a nice blue color, and
    set our two Boolean variables to `YES`. The hero is only travelling to the right,
    so that's the only direction his bullets will travel. We then call out to the
    playfield to the `addBullet` method. We wrap it up by playing a nice shooting
    sound. Let's turn to that `addBullet` method next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Not much here, either. We add the bullet to the batch node, and we add the bullet
    to the `bulletArray` array. So why did we do this here, and not in the hero's
    `shoot` method? For one, we will be using this same method when adding enemy bullets.
    The other reason is that we don't want to have the `bulletArray` array accessible
    outside of the playfield layer itself, so it is much easier to use this method
    to insert the bullet into that array.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, there is also a separate update method for the bullets.
    Let's go there now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This method style should be familiar by now. We iterate through all the bullets
    in the `bulletArray` array, and move each bullet either left or right, depending
    on the value of `isShootingRight` variable. If the bullet goes off-screen, it
    is added to the `bulletsToDelete` array, which is then used after the loop to
    remove the bullets from the `bulletArray`. Of course, at this point the bullets
    won't interact with anything, but we need to have some enemies to shoot at before
    we deal with collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Enemies everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to have enemies in our game. A lot of enemies. We need to have flying
    enemies as well as walking enemies. With the wonderful Planet-X graphics we are
    using, the designer created six types of creatures in six colors. We are using
    all but one type of creature (the swimming creature didn't fit this game), so
    we have 12 flying enemy types and 18 walking enemy types. In our game there is
    no difference in the behavior of the creatures, but it does give more of a visual
    flair to the game to have this much variety. Because we will be randomly creating
    enemies throughout the game, we don't want to be reloading the animations into
    the cache every time a new creature is spawned, so we build all of the enemy animations
    when the playfield is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because we have kept our naming convention consistent (that is, `walk1_1.png`,
    `walk1_2.png`, and so on) we can easily construct our names in a loop. We first
    load the walking enemies in a loop, and we assemble two strings to help us. The
    `root` parameter is the first part of the file name before the incremental frame
    numbers. The `anim` variable will add the word "move" to the end of the `root`
    name, to load the animation under that name. So the fifth walker's animation will
    be named `walk5_move`. We then call the same helper method we used for the hero
    to load the animation frames for all of the walkers. The second half of the method
    repeats the same process, except it loads the flying creatures' animations.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start to look at the `EREnemy` class, which will look very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `EREnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We define a `fallSensor` variable for the enemy, using the same structure as
    we did for the hero. We also override the `setPosition` method for this class
    to refresh the `fallSensor` every time it is repositioned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `EREnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The enemy's `shoot` method is very similar to the hero's `shoot` method. Obviously,
    the `isHeroBullet` Boolean variable is set to `NO` here. Also, the `isShootingRight`
    variable sets itself to one of the new variables that is contained in the `EREnemy`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `EREnemy.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These variables help us keep better track of the enemies. The `isFlying` and
    `isMovingRight` Boolean variables are self-explanatory. The `shootTimer` for the
    enemies is kept in this class, where the hero's is kept as part of the playfield
    layer itself. Now that we have seen all of the `EREnemy` class (except for getting
    hit), we can look at how we create the enemies in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we did when we created the ground tiles, we randomize the selection of the
    `enemyNo`, and use that to build the correct initial frame name for the new `EREnemy`
    object. When we set the position, we add the requested position (`pos`) to half
    of the content size of the enemy itself. We do this because the enemy has a default
    center `anchorPoint`, and the position passed is the top of the tile we want the
    enemy to be standing on. So by adding half of the height, we position the enemy
    perfectly standing on the tile below. (We don't want to change the `anchorPoint`,
    because then we would have to do this type of adjustment for all bullets fired
    by the enemies.) All enemies will start by facing to the left, and since these
    are walking enemies, they will have `isFlying` set to `NO`. After adding the enemy
    to the batch node and to the `enemyArray` array, we get the animation we loaded
    for this particular enemy, and set it to repeat forever. That's all we need to
    create the walking enemies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we look at how we add flying enemies, you will notice this is the same basic
    code structure as the walking enemy. The only real differences are that the names
    of the sprite frames begin with `fly` instead of `walk`, and we don't have to
    change the starting position for the flying enemies, because they will not interact
    with the ground at all. Now we can move to the enemy `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We begin the `updateEnemies` method by making sure the playfield is scrolling.
    If not we exit, because we don't want the enemies to move. Then we iterate through
    all the enemies in the `enemyArray` and move them left or right, according to
    how their `isMovingRight` Boolean variable is set. The middle section of the update
    is concerned only with walking enemies. For each walking enemy, we iterate through
    all tiles to see if their `fallSensor` is touching any tiles. This is exactly
    the same as what we did for the hero with the `isFalling` Boolean variable the
    `updateHero` method. If there is no ground, instead of making in the enemy fall,
    we flip the graphic to face the opposite direction, and change the `isMovingRight`
    Boolean to the opposite value. If an enemy reaches the edge of a ledge, this will
    make it turn around.
  prefs: []
  type: TYPE_NORMAL
- en: We then have a simple `shootTimer` loop for the enemies. Each enemy will shoot
    every 2 seconds. Because we have non-intelligent enemies (they move back and forth,
    but never pursue the player), it makes sense to have this form of blind shooting
    for the enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check to see if any enemies are off-screen to the left, and remove
    them in the usual fashion. Now our enemies can move and everybody can shoot, we
    need some collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to be able to check for three different types of collisions. We need
    to be able to have bullets hit the enemies. We need the hero to get hit. We also
    need to react when the hero runs into an enemy. Let's look at the method for this,
    which is in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m` (`checkCollisions`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We start by iterating through all bullets in the array. If the bullet is an
    enemy bullet (`isHeroBullet == NO`), then we check the `boundingBox` of the bullet
    with the `boundingBox` of the hero. If they intersect, we add the bullet to the
    `bulletsToDelete` array, remove the bullet, and set the `isHeroHit` Boolean to
    `YES`. We use a Boolean variable for the hero hit here because we will be doing
    another hero collision check within this method. Since the hero's death causes
    the hero to be removed, the game would crash if the hero was shot and ran into
    an enemy at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: If the bullet is a "hero bullet", we iterate through all enemies to determine
    if the bullet is intersecting with an enemy `boundingBox`. If it is, we add the
    bullet to the `bulletsToDelete` array, remove the bullet, add the enemy to the
    `enemiesToDelete` array, and send the message to the enemy that it got shot.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERPlayfieldLayer.m` (`checkCollisions`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the second half of this method, we start by iterating through all the enemies.
    For each enemy, we check to see if the enemy's `boundingBox` intersects with the
    hero's `boundingBox`. If they intersect, we register a collision for both hero
    and enemy in the same manner as we did with the bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have resolved the collisions, we check the `isHeroHit` variable to
    see if he got shot. If he got shot, we send the `gotShot` message to the hero.
    As the final bit of cleanup, we handle the `bulletsToDelete` and `enemiesToDelete`
    arrays the same as usual: we use them to remove the deleted objects from the `bulletArray`
    and `EnemyArray`, and then use the `removeAllObjects` method to empty the deletion
    arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting shot with particles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last unresolved bits of code that we need to look at are the `gotShot` routines
    for both the enemy and the hero. The enemies die after a single hit, so their
    method is a simpler place to start.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `EREnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When an enemy gets shot, the first thing we do is to create a particle system.
    Particles can be coded in one of two ways. The first would be to manually set
    all of the parameters regarding the particle system by hand, and test and retest
    until you achieve the desired effect. The alternate approach (one that is more
    widely used) is to use a commercially available tool, Particle Designer, available
    at [http://particledesigner.71squared.com](http://particledesigner.71squared.com).
    Particle Designer allows you to see the results of changing every parameter in
    real time, so you can experiment until you achieve the desired result. Once you
    have what you want, you can save it as a `.plist` file, and use it as we have
    done here. We created a `CCParticleSystemQuad` object using the plist file, set
    the position, and added it to the layer. That's all we needed to do for this one-shot
    particle. (If you want to know how much manual coding we are avoiding by using
    Particle Designer, open the `enemydie.plist` file in Xcode and see all the values
    stored in it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'After we trigger the particle, we simply remove the enemy from its parent and
    play a nice death sound. Let''s see the aftermath when an enemy is shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting shot with particles](img/9007_9_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Death of hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hero getting hit adds a little complexity, because the hero can take five
    hits before he dies. If he doesn't die, we want him to flash red briefly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `ERHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We first reduce the hero's health by one. Then we check if the hero should be
    dead or not. If his health is zero, we spawn a new particle system centered on
    the hero, remove the hero, play a death sound, and then call the `gameOver` method.
    It should be noted that the `ExplodingRing.plist` file we use here is actually
    a particle that ships with Cocos2d, and is used as part of the Particle test.
  prefs: []
  type: TYPE_NORMAL
- en: If the hero is not dead, then we check the value of the hero's `isFlashing`
    variable. If he isn't currently flashing, we build a small action sequence that
    will tint the hero red for a duration of 0.05, then tint it back to normal (all
    max values return the sprite color to its original color). Then we play a sound
    effect, and call it done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have put a lot of interesting pieces together in this game. We have dynamic
    terrain, randomized enemies, shooting, jumping, endless backgrounds, and (hopefully)
    some fun while building and playing it. You will notice that there are a few less
    interesting bits we have not covered in depth. Please, consult the code bundle
    to explore the other pieces of the game, like the "Dramatic Entrance" when the
    hero starts the game by being dropped off by a space ship. There is also some
    helpful debugging code we used for the sensors (commented out) in the bottom of
    the `ERPlayfieldLayer.m` file. By enabling that code, you can see the sensor boxes
    drawn while the game is playing.
  prefs: []
  type: TYPE_NORMAL
- en: It is our sincere hope that these projects have instructed, entertained, and
    perhaps even inspired you in your own pursuits. Each of the games, designed with
    a "bare bones" approach, gives plenty of room for exploration and expansion. If
    you create something wonderful as a result of having been inspired by these projects,
    please let us know! We look forward to hearing from you.
  prefs: []
  type: TYPE_NORMAL
