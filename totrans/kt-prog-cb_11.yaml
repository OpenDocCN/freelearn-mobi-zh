- en: Networking and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和并发
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: How to fetch data over network
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过网络获取数据
- en: How to create data class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建数据类
- en: How to copy data class with modifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何修改后复制数据类
- en: How to parse JSON data from network to data class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从网络解析 JSON 数据到数据类
- en: How to download a file in Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中下载文件
- en: How to use RxJava and Retrofit with Kotlin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中使用 RxJava 和 Retrofit
- en: How to make an endless list using RecyclerView
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 RecyclerView 制作无限列表
- en: How to use Anko to run background tasks with Kotlin in Android
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Android 中使用 Kotlin 运行后台任务
- en: How to use coroutines to achieve multithreading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用协程实现多线程
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: You will probably find it hard to get an app that doesn't communicate over the
    network. Communication with the internet is used in almost all the apps, be it
    a file-sharing app, streaming app, social network apps, or something else, the
    list goes on and on. There are many variables that you need to think about when
    you want to add network communication features to your Android apps. For example,
    you can't run it on the main thread, and network requests are always performed
    on background threads. Apart from that, you also need to detect when the network
    request fails, so as to give feedback to the user about what went wrong. In this
    chapter, we will address how to efficiently make network requests in Kotlin.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现很难找到一个不通过网络进行通信的应用程序。在几乎所有的应用程序中，无论是文件共享应用程序、流媒体应用程序、社交网络应用程序还是其他什么，列表可以一直继续。当你想要向你的
    Android 应用程序添加网络通信功能时，你需要考虑许多变量。例如，你不能在主线程上运行它，网络请求总是在后台线程上执行。除此之外，你还需要检测网络请求失败的情况，以便向用户反馈出了什么问题。在本章中，我们将讨论如何在
    Kotlin 中高效地进行网络请求。
- en: How to fetch data over network
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何通过网络获取数据
- en: 'Making a network request in Android is very cumbersome unless you use any third-party
    library. For example, let''s take a look at how network requests in Android used
    to be:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中进行网络请求非常繁琐，除非你使用任何第三方库。例如，让我们看看 Android 中的网络请求过去是如何的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, the preceding code is ugly. Kotlin eases out our pain to make a network
    request. In this recipe, we will learn how to make network requests in Kotlin.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的代码很丑陋。Kotlin 简化了我们的痛苦，使我们能够进行网络请求。在本食谱中，我们将学习如何在 Kotlin 中进行网络请求。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0\. Ensure that you have its latest version.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0。请确保你有其最新版本。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s take look at the following steps required to make network requests in
    Kotlin:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Kotlin 中进行网络请求所需的以下步骤：
- en: 'Remember the huge pile of code we saw at the start of this recipe, just for
    performing a network request? All that can be replaced by just one line of Kotlin
    code. Let''s take a look at the following code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得我们在本食谱开始时看到的那些用于执行网络请求的大量代码？所有这些都可以用一行 Kotlin 代码来替换。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will just return the `response` fetched from the network request that you
    made. You just need to provide your URL as the parameter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅返回从网络请求中获取的 `response`。你只需提供你的 URL 作为参数。
- en: While using this on Android, ensure that you have pushed this task in the background,
    or else you will get a `NetworkOnMainThread` exception.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Android 上使用此方法时，请确保你已经将此任务推送到后台，否则你将得到一个 `NetworkOnMainThread` 异常。
- en: 'The code that we want to execute asynchronously is wrapped under the `doAsync`
    block. Wrapping the code inside an async task is also very simple. Let''s take
    a look at the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要异步执行的代码被包装在 `doAsync` 块下。将代码包装在异步任务中也非常简单。让我们看看以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have wrapped the network request into an async block, and then we have a
    `uiThread` method from where we can touch the UI elements of the app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将网络请求包装在一个异步块中，然后我们有一个 `uiThread` 方法，我们可以从中触摸应用程序的 UI 元素。
- en: 'The `uiThread` method is provided by Anko library, which you can include in
    your project by adding these lines in your `build.gradle`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`uiThread` 方法由 Anko 库提供，你可以通过在你的 `build.gradle` 文件中添加以下行将它们包含到你的项目中：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more…
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Check out the *How to use Anko to run background tasks with Kotlin in Android* recipe
    of this chapter to learn more about how to create background tasks in Kotlin.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章的 *如何使用 Anko 在 Android 中使用 Kotlin 运行后台任务* 食谱，了解更多关于如何在 Kotlin 中创建后台任务的信息。
- en: How to create data class in Kotlin
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中创建数据类
- en: 'Are you sick and tired of creating long boilerplate code just for storing data?
    Do you feel that the following code is too much just to define a `Student` model?:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '你是否厌倦了仅仅为了存储数据而编写冗长的样板代码？你是否觉得以下代码只是为了定义一个`Student`模型而显得过于繁琐？:'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you agree, then Kotlin's data class is just for you. So let's dive into it
    in this recipe and get to know it more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同意，那么Kotlin的数据类正是你所需要的。所以让我们在这个菜谱中深入探讨，了解更多。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write our code. You can use any IDE that is
    capable of executing Kotlin code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用IntelliJ IDEA来编写我们的代码。你可以使用任何能够执行Kotlin代码的IDE。
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In every real-world project, you create classes that don''t have any use except
    for storing data, like in the case of the `Student` class we described earlier.
    The number of these types of classes can be way too high in a complex project
    having many roles and models. This results in a lot of boilerplate code. Kotlin
    has a great solution for it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一个现实世界的项目中，你都会创建一些没有其他用途，仅仅用于存储数据的类，就像我们之前描述的`Student`类。在一个具有许多角色和模型的复杂项目中，这些类型的类的数量可能会非常高，这会导致大量的样板代码。Kotlin为这个问题提供了一个很好的解决方案：
- en: 'The code mentioned at the start of the recipe can be reduced to just one line:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜谱开头提到的代码可以简化为仅仅一行：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'Now, let''s try to use the data class we just created:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用我们刚刚创建的数据类：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we didn't need any getter setter, which saved us a lot of boilerplate
    code. The getter setters are already included in the Kotlin property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不需要任何getter setter，这节省了我们大量的样板代码。getter setters已经包含在Kotlin属性中。
- en: 'Let''s check the `toString()` method (which we haven''t even defined):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查`toString()`方法（我们甚至还没有定义）：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is better than what you'd get from Java's `toString()` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这比Java的`toString()`方法返回的结果要好。
- en: 'Data class also offers a lot of flexibility. For example, if you don''t want
    setter for a property, you can make the property `val`. This will make the property
    read-only:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据类还提供了很多灵活性。例如，如果你不想要属性的setter，你可以将属性设置为`val`。这将使属性为只读：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One of the cool things that you can do with data class is that you can destructure
    the object to obtain the property. Check out the following code to understand
    more:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用数据类做的酷事情之一是你可以解构对象以获取属性。查看以下代码以了解更多信息：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also have default values of property in the class. Let''s take a look
    at the next example:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在类中为属性设置默认值。让我们看看下一个例子：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more…
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Data class has a few restrictions. According to Kotlin documentation, those
    are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类有一些限制。根据Kotlin文档，这些限制如下：
- en: The primary constructor needs to have at least one parameter
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要构造函数需要至少有一个参数
- en: All primary constructor parameters need to be marked as `val` or `var`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有主要构造函数参数都需要标记为`val`或`var`
- en: Data classes cannot be abstract, open, sealed, or inner
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类不能是抽象的、开放的、密封的或内部的
- en: Data classes may not extend other classes (but may implement interfaces)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类可能不能扩展其他类（但可以实现接口）
- en: How to copy data class with modifications
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何修改后复制数据类
- en: In the last recipe, we learned how to use data class and how it reduces a lot
    of boilerplate code. In this recipe, we will see how data class makes it easy
    to copy another data class, even if you have to modify the property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们学习了如何使用数据类以及它如何减少大量的样板代码。在这个菜谱中，我们将看到数据类如何使复制另一个数据类变得容易，即使你需要修改属性。
- en: A brute-force mechanism to copy a data class can be to just create a data class
    by duplicating all the properties, but using the `copy` method will make it much
    easier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数据类的暴力机制可以通过复制所有属性来创建一个数据类，但使用`copy`方法会更容易。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write our code. You can use any IDE that is
    capable of executing Kotlin code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用IntelliJ IDEA来编写我们的代码。你可以使用任何能够执行Kotlin代码的IDE。
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will be using the `copy` method, which takes in named arguments and creates
    a copy of the object with changed values of named arguments. Let''s look at an
    example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`copy`方法，该方法接受命名参数并创建一个具有更改的命名参数值的对象副本。让我们看看一个例子：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more…
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'People usually get confused between the `copy()` and `apply()` functions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常会在`copy()`和`apply()`函数之间感到困惑：
- en: '`apply()`: It accepts a function and sets its scope to that of the object on
    which it has been invoked. It is a transformation function that can also be used
    to evaluate complex logic before returning. At the end, it just returns the same
    object with changes (if performed).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply()`: 它接受一个函数并将其作用域设置为被调用的对象。它是一个转换函数，也可以用来在返回之前评估复杂逻辑。最后，它只是返回一个经过更改（如果进行了更改）的相同对象。'
- en: '`copy()`: The `apply` function is not thread-safe and mutates the object. The `copy()` function,
    on the other hand, returns a new object (without modifying the original object).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`: `apply` 函数不是线程安全的，并且会修改对象。另一方面，`copy()` 函数返回一个新的对象（不会修改原始对象）。'
- en: How to parse JSON data from network to data class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从网络解析 JSON 数据到数据类
- en: JSON is one of the most widely used formats of response. Usually, the APIs provide
    outputs in the form of JSON response and in Android development also they are
    used widely as we communicate with network. Parsing JSON response to a data class
    helps us work with them as a Java object. You can also parse it using JSONObject,
    but it results in dirty code. In this recipe, we will learn how to parse JSON
    data into data class. We are using data class because they are preferred when
    the sole purpose of class is to save data. So let's get started!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是最广泛使用的响应格式之一。通常，APIs 以 JSON 响应的形式提供输出，在 Android 开发中，它们也被广泛使用，因为我们与网络进行通信。将
    JSON 响应解析到数据类中可以帮助我们像 Java 对象一样处理它们。你也可以使用 JSONObject 来解析它，但结果会是代码很脏。在这个菜谱中，我们将学习如何将
    JSON 数据解析到数据类中。我们使用数据类，因为当类的唯一目的是保存数据时，它们是首选的。那么，让我们开始吧！
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using Android Studio 3.0; ensure that you have its latest version.
    We will be using the GSON library, an open source library by Google for parsing
    the JSON response. GSON is very easy to use and is one of the most popular JSON
    parsing libraries out there. To include GSON in your project, just add the following
    lines to your `build.gradle` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0；请确保你有其最新版本。我们将使用 GSON 库，这是谷歌开源的一个用于解析 JSON 响应的库。GSON
    非常易于使用，并且是市面上最受欢迎的 JSON 解析库之一。要将 GSON 包含到你的项目中，只需将以下行添加到你的 `build.gradle` 文件中：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to understand how to parse JSON data from network:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解如何从网络解析 JSON 数据：
- en: 'Usually, we get a JSON response after making a network request, so for simplifying,
    we will assume that we get the given JSON response after making some network request:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们在发起网络请求后都会得到一个 JSON 响应，所以为了简化，我们将假设在发起一些网络请求后得到了给定的 JSON 响应：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'IntelliJ IDEA provides a plugin that can help convert JSON response into Kotlin
    object. We will be using the `RoboPojoGenerator` plugin. Carry out the following
    steps to install it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 提供了一个插件，可以帮助将 JSON 响应转换为 Kotlin 对象。我们将使用 `RoboPojoGenerator` 插件。执行以下步骤来安装它：
- en: 'Go to Settings | Plugins:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往设置 | 插件：
- en: '![](img/426ea480-ff4a-4664-bade-7018ccdcd6d9.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/426ea480-ff4a-4664-bade-7018ccdcd6d9.png)'
- en: Click on Install JetBrains plugin; it will open a dialog. Search Robopojo in
    it, and you will see a RoboPOJOGenerator plugin. Click on Install and restart
    the Android Studio.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Install JetBrains plugin；它将打开一个对话框。在其中搜索 Robopojo，你将看到一个 RoboPOJOGenerator
    插件。点击 Install 并重新启动 Android Studio。
- en: '![](img/5d4fe4d1-1143-4ad4-9d5a-058f8af4abd7.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d4fe4d1-1143-4ad4-9d5a-058f8af4abd7.png)'
- en: Once you've done that, to generate classes based on JSON response, first create
    an empty package where you would want to keep the classes. I have created it by
    the name `InstagramCommentsResponse` (because we have used Instagram API for fetching
    latest comments).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，为了根据 JSON 响应生成类，首先创建一个空的包，你将在这里保存这些类。我已经创建了一个名为 `InstagramCommentsResponse`
    的包（因为我们使用了 Instagram API 来获取最新的评论）。
- en: Now, right-click on the package, and select New | Generate POJO from JSON. You
    will then see a dialog by the RoboPOJO generator, where you need to paste your
    JSON response. After you've done that, check the Kotlin and Gson box and click
    on Generate.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击包，选择 New | Generate POJO from JSON。然后，你将看到一个由 RoboPOJO 生成器提供的对话框，你需要将你的
    JSON 响应粘贴进去。完成之后，勾选 Kotlin 和 Gson 复选框，然后点击 Generate。
- en: 'Now you will see a bunch of classes created inside that package, as illustrated:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将看到在该包内部创建了许多类，如图所示：
- en: '![](img/f19590a3-2b85-455e-8e66-f9fb04d3bdf0.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f19590a3-2b85-455e-8e66-f9fb04d3bdf0.png)'
- en: 'Let''s take a look at these classes. The first class is the outer holder of
    JSON response:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这些类。第一个类是 JSON 响应的外部容器：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s try to parse the JSON received from the network call. We will try
    to get the first comment received and access it as we do in Kotlin:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试解析从网络调用中接收到的 JSON。我们将尝试获取收到的第一个评论并像在 Kotlin 中那样访问它：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we can use it as a plain Kotlin object, without needing to use
    `JSONObject` to parse it using keys, which makes JSON parsing very easy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以将其用作普通的 Kotlin 对象，而无需使用`JSONObject`通过键来解析它，这使得 JSON 解析变得非常简单。
- en: How to download a file in Kotlin
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中下载文件
- en: We often need to download files in our Android application. The most basic way
    of doing this will be opening a URL connection and using `InputStream` to read
    the content of the file and storing it in a local file using `FileOutputStream`; all
    this is in a background thread using `AsyncTask`. However, we don’t want to reinvent
    the wheel. There are a lot of libraries out there that handle all this stuff very
    nicely for us and make our work super easy, helping us create clean code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Android 应用程序中，我们经常需要下载文件。最基本的方法将是打开 URL 连接并使用`InputStream`读取文件的内容，然后使用`FileOutputStream`将其存储在本地文件中；所有这些都在后台线程中使用`AsyncTask`完成。然而，我们不想重新发明轮子。有许多库可以为我们处理所有这些事情，使我们的工作变得非常简单，帮助我们创建干净的代码。
- en: We can use **Volley** ([https://developer.android.com/training/volley/index.html](https://developer.android.com/training/volley/index.html)),
    a networking library by developers at Google, which makes network communication
    very easy and fast. Another one we can use is **OkHttp** (by *Square*), which
    is very efficient, and we can use it along with **Retrofit** (for HTTP API).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用由谷歌开发者开发的网络库**Volley**([https://developer.android.com/training/volley/index.html](https://developer.android.com/training/volley/index.html))，它使得网络通信变得非常简单快捷。另一个我们可以使用的是**OkHttp**（由*Square*提供），它非常高效，并且我们可以与**Retrofit**（用于HTTP
    API）一起使用。
- en: For this recipe, we will be using a networking library called **Fuel**, which
    is written in Kotlin.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用一个名为**Fuel**的网络库，它是用 Kotlin 编写的。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new Android project and add an activity. Now, add fuel dependencies
    to your project dependencies by adding the following lines in your `build.gradle`
    and syncing the project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Android 项目并添加一个活动。现在，通过在您的`build.gradle`中添加以下行并将项目同步，将 fuel 依赖项添加到您的项目依赖项中：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `$fuel_version` is the latest version of fuel library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$fuel_version`是 fuel 库的最新版本。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to download a file in Kotlin:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在 Kotlin 中下载文件：
- en: 'Let''s start with a button in our view with an `onClickListener` attached to
    it. I am also adding a `progressBar` to the view to be able to see the progress
    of our download. This is my view:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从视图中添加一个带有`onClickListener`的按钮开始。我还添加了一个`progressBar`到视图中，以便能够看到下载的进度。这是我的视图：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s start by downloading a temporary file. We will be using [https://httpbin.org/](https://httpbin.org/)
    for mocking download file API. The following is the code for downloading a temporary
    file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从下载一个临时文件开始。我们将使用[https://httpbin.org/](https://httpbin.org/)来模拟下载文件 API。以下是为下载临时文件编写的代码：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how our UI looks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 UI 看起来的样子：
- en: '![](img/4a22aefa-a71f-4f98-b73f-52fa9b93ab7d.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a22aefa-a71f-4f98-b73f-52fa9b93ab7d.jpg)'
- en: 'Now, as we mentioned earlier, we will be using the `Fuel` library to download
    the file; here''s how the code looks:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们之前提到的，我们将使用`Fuel`库来下载文件；以下是代码的示例：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I suggest that you play around with downloading files in Fuel, with and without
    progress, to get a better grasp of this. You can read all the other functionalities
    that Fuel provides at [https://github.com/kittinunf/Fuel](https://github.com/kittinunf/Fuel).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你尝试在 Fuel 中下载文件，包括有进度和无进度的情况，以更好地掌握这一点。你可以在[https://github.com/kittinunf/Fuel](https://github.com/kittinunf/Fuel)上阅读
    Fuel 提供的所有其他功能。
- en: Also, try to use Volley and other networking libraries in Android to get an
    understanding of what are the differentiating points and use cases of each.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以尝试在 Android 中使用 Volley 和其他网络库，以了解每个库的不同点和用例。
- en: How to use RxJava and Retrofit with Kotlin
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中使用 RxJava 和 Retrofit
- en: '**Retrofit** is one of the most widely used networking libraries in Android.
    It is an open source library created by *Jake Wharton*. RxJava is the open source
    implementation of ReactiveX in Java. RxJava is a great way to do reactive-programming
    or event-driven programming. This recipe won''t teach you about reactive programming
    ( [https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)
    ), so if you aren''t comfortable with it, you can learn about it through the documentation
    ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)).
    Rather, in this recipe, you will learn how to use Retrofit and RxJava together.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Retrofit**是Android中最广泛使用的网络库之一。它是由*Jake Wharton*创建的开源库。RxJava是Java中ReactiveX的开源实现。RxJava是进行响应式编程或事件驱动编程的绝佳方式。本菜谱不会教你关于响应式编程（[https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)），所以如果你不熟悉它，你可以通过文档（[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)）来学习。相反，在本菜谱中，你将学习如何一起使用Retrofit和RxJava。'
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using Android Studio 3.0\. Ensure that you have its latest version.
    We also need to add the following dependencies:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0。请确保您拥有其最新版本。我们还需要添加以下依赖项：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `adapter-rxjava2` library helps us return observables as response, which
    can be subscribed by observers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`adapter-rxjava2`库帮助我们返回作为响应的`Observable`，可以被观察者订阅。'
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Using RxJava with Retrofit is quite simple; let''s take a look at the following
    steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Retrofit中使用RxJava非常简单；让我们看看以下步骤：
- en: 'An instance of Retrofit (which is used to communicate with network) will be
    created as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Retrofit（用于与网络通信）的实例将按照以下方式创建：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is an example of interface where we define all of our Retrofit
    calls. You may note, we are returning the `Observable`, and that''s the only thing
    that has changed:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的示例是一个接口，我们在这里定义了所有的Retrofit调用。你可能注意到，我们返回的是`Observable`，这是唯一的变化：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you need to create an instance of your aforementioned service, as shown:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要创建您之前提到的服务实例，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you just need to call the method, and you need a subscriber object that
    will subscribe to it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你只需要调用该方法，并且你需要一个订阅者对象来订阅它：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have pushed the network call on a separate thread in the background. When
    the call/task is complete, the result will be observed on the main thread.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在后台的另一个线程上推送了网络调用。当调用/任务完成时，结果将在主线程上被观察。
- en: How to make an endless list using RecyclerView
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用RecyclerView制作无限列表
- en: What do the Facebook, Instagram, and Twitter feeds have in common? They all
    have virtually infinite content to show you while you keep on scrolling down and
    down for more. There's no doubt that this is a great way to engage users on your
    platform.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook、Instagram和Twitter的动态有什么共同点？它们都几乎有无穷无尽的内容在你不断向下滚动时展示给你。毫无疑问，这是在您的平台上吸引用户的绝佳方式。
- en: In this recipe, we will see how to make an endless list using `RecyclerView`.
    There are many use cases of it, for example, social media, e-commerce application,
    or any content-based apps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何使用`RecyclerView`制作无限列表。它有许多用例，例如社交媒体、电子商务应用程序或任何基于内容的应用程序。
- en: We will create a simple app, which will load a small set of data in the beginning,
    but once the user scrolls to the bottom of the content, we will fetch another
    set of data and append to it, giving an illusion of infinite content to the user.
    So let's get started!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，它最初将加载一小部分数据，但一旦用户滚动到内容的底部，我们将获取另一组数据并将其附加到它，给用户一种无限内容的感觉。所以让我们开始吧！
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0; ensure that you have its latest version.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0；请确保您拥有其最新版本。
- en: 'You''ll also need to include `RecyclerView` in your `build.gradle` file, which
    you can add as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在`build.gradle`文件中包含`RecyclerView`，你可以按照以下方式添加：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also find the source code in the `https://gitlab.com/aanandshekharroy/Anko-examples/`
    repository by checking out the `6-endless-list-using-recycler-view` branch.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`https://gitlab.com/aanandshekharroy/Anko-examples/`存储库中找到源代码，通过检出`6-endless-list-using-recycler-view`分支。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will be creating a simple app that will show numbers in the list. As you
    scroll down, the list will keep growing infinitely:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，该程序将在列表中显示数字。当你向下滚动时，列表将无限增长：
- en: '![](img/25f505db-92e4-4404-b9d6-f0acc60b40e8.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25f505db-92e4-4404-b9d6-f0acc60b40e8.jpeg)'
- en: 'Here''s how the list is created:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的创建方式如下：
- en: 'First, we will create an item that will be placed inside the list. The following
    is the code for that row item `recycler_row.xml`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个将放置在列表中的项。以下是该行项 `recycler_row.xml` 的代码：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will create a `RecyclerView` in the main activity layout file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在主活动布局文件中创建一个 `RecyclerView`：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we will create a simple `RecyclerView` adapter:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的 `RecyclerView` 适配器：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s create a simple function, which when called, will append 30 data
    items to the list. This is essentially what is done in apps. Once the user reaches
    the bottom of the list, a network call is made, which appends data to the previous
    list:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的函数，当调用它时，将 30 个数据项追加到列表中。这正是应用程序中所做的。一旦用户到达列表底部，就会发起一个网络调用，将数据追加到之前的列表中：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s set up the recycler view in the activity:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在活动中设置回收视图：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we have to intercept when the user has reached the bottom of the list,
    we have added a `ScrollListener`. We have overridden the `onScroll` method, and
    we are using the `canScrollVertically` method. The `canScrollVertically` method
    was added in API level 14, and it is used to check whether this view can be scrolled
    vertically in a certain direction. It takes an integer argument (negative to check
    scrolling up and positive to check scrolling down) and returns a boolean (`true`
    if possible, `false` if not). In our example, we have supplied a positive integer,
    which will return `true` if the view can be scrolled down and false if it can't
    be. If it can't be further scrolled down (meaning that the data is exhausted),
    we will add data to the list and update the list by calling the `notifyItemRangeInserted`
    method of the adapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须拦截用户到达列表底部的情况，我们添加了一个 `ScrollListener`。我们重写了 `onScroll` 方法，并使用了 `canScrollVertically`
    方法。`canScrollVertically` 方法是在 API 级别 14 中添加的，它用于检查此视图是否可以在某个方向上垂直滚动。它接受一个整数参数（负数用于检查向上滚动，正数用于检查向下滚动）并返回一个布尔值（如果可能则为
    `true`，否则为 `false`）。在我们的例子中，我们提供了一个正整数，如果视图可以向下滚动，则返回 `true`，如果不能则返回 `false`。如果不能进一步向下滚动（意味着数据已耗尽），我们将向列表中添加数据，并通过调用适配器的
    `notifyItemRangeInserted` 方法来更新列表。
- en: How to use Anko to run background tasks with Kotlin in Android
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 Anko 在 Android 中用 Kotlin 运行后台任务
- en: '**Anko** is a library created by the JetBrains team, which makes Android development
    quite easy with the help of many helper functions that abstract a lot of complexity
    and provides you easy-to-use methods. One such thing is to deal with background
    tasks. Using Anko, we can work with background tasks very easily. In this recipe,
    we will learn how to work with background tasks using Anko.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Anko** 是由 JetBrains 团队创建的一个库，它通过许多辅助函数抽象了很多复杂性，使得 Android 开发变得相当容易。其中之一就是处理后台任务。使用
    Anko，我们可以非常容易地处理后台任务。在这个菜谱中，我们将学习如何使用 Anko 来处理后台任务。'
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using Android Studio 3.0 for coding purposes; ensure that you have
    its latest version. You need to add Anko to your `build.gradle` file, as shown:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0 进行编码；确保你有其最新版本。你需要将 Anko 添加到你的 `build.gradle` 文件中，如下所示：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Doing a task in the background is very easy in Kotlin. Let''s take a look at
    the next example. In this example, we will make a network request (which is required
    to do in the background or else you will get a `NetworkOnMainThread` exception);
    once the network request is complete, we will show the Success message using toast.
    Since we can''t touch the UI element from a background thread, we need to come
    to UI thread in order to do it. We will use the `uiThread` method provided by
    Anko, which will be called once the background task is over:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中在后台执行任务非常简单。让我们看看下一个例子。在这个例子中，我们将发起一个网络请求（这需要在后台执行，否则你会得到一个 `NetworkOnMainThread`
    异常）；一旦网络请求完成，我们将使用 toast 显示成功消息。由于我们不能从后台线程触摸 UI 元素，我们需要回到 UI 线程来完成它。我们将使用 Anko
    提供的 `uiThread` 方法，该方法将在后台任务完成后被调用：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, `URL().readText()` is a long processing task, hence we've put
    it in the background task.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`URL().readText()` 是一个长时间处理任务，因此我们将其放在后台任务中。
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作…
- en: You must have used async tasks for executing tasks in the background, but it
    wasn't a very efficient way to do it. It has its problem of handling them when
    the screen rotates, because it doesn't pay attention to the activity's lifecycle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须已经使用过异步任务来在后台执行任务，但这并不是一个很有效的方法来做这件事。它处理屏幕旋转时的它们时存在问题，因为它没有注意到活动生命周期。
- en: The `doAsync` method was called by an activity,  and if the activity is destroying,
    the `uiThread` will not be executed. This ensures that you get to touch the UI
    only till it is present.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAsync` 方法是由活动调用的，如果活动正在销毁，则 `uiThread` 不会执行。这确保了你只能触摸 UI 直到它存在。'
- en: How to use coroutines to achieve multithreading
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用协程实现多线程
- en: '**Coroutines** are a great language feature in Kotlin. Here''s an apt definition
    of coroutines according to the documentation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程** 是 Kotlin 中的一项优秀语言特性。以下是文档中对协程的一个恰当的定义：'
- en: '"Coroutines are a new way of writing asynchronous, non-blocking code (and much
    more)."'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '"协程是编写异步、非阻塞代码（以及更多）的新方法。"'
- en: It's not just the ease of use, it's much more powerful than threads, especially
    in the case of a mobile environment where even milliseconds of performance gain
    is appreciated. Spawning multiple threads can cause performance issues, which
    isn't the case with coroutines since there can be thousands of those running without
    much drop in performance levels.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅使用起来方便，而且比线程更强大，尤其是在移动环境中，即使是一毫秒的性能提升也值得赞赏。启动多个线程可能会引起性能问题，但协程不会，因为即使有成千上万的协程运行，性能水平也不会有太大下降。
- en: 'The following is what the official documentation of Kotlin says:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容是 Kotlin 官方文档中所述：
- en: '"One can think of a coroutine as a lightweight thread. Like threads, coroutines
    can run in parallel, wait for each other, and communicate. The biggest difference
    is that coroutines are very cheap, almost free; we can create thousands of them,
    and pay very little in terms of performance. True threads, on the other hand,
    are expensive to start and keep around. A thousand threads can be a serious challenge
    for a modern machine."'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '"可以将协程想象为一个轻量级的线程。像线程一样，协程可以并行运行，互相等待，并进行通信。最大的区别是协程非常便宜，几乎是免费的；我们可以创建成千上万的协程，而在性能方面付出的代价非常小。另一方面，真正的线程启动和保持的成本很高。一千个线程对于一个现代机器来说可能是一个严重的挑战。”'
- en: This fact makes it very powerful, and Kotlin's team has provided easy syntax
    to make it easy to use. In this recipe, we will learn how to use coroutines. So
    let's get started!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实使得它非常强大，Kotlin 团队也提供了简单的语法来使其易于使用。在这个菜谱中，我们将学习如何使用协程。那么，让我们开始吧！
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using Android Studio 3.0 for coding purposes. Coroutines are provided
    as a library that abstracts all the complexities and lets the library handle it.
    You need to add the library to the `build.gradle` file, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0 进行编码。协程作为一个库提供，它抽象了所有复杂性，并让库来处理。你需要在 `build.gradle`
    文件中添加这个库，如下所示：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This library is published to the Bintray JCenter repository, so you need to
    add `jcenter()` in your repositories, as shown:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库发布到了 Bintray JCenter 仓库，所以你需要在你的仓库中添加 `jcenter()`，如下所示：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One thing to note is that coroutines are experimental in Kotlin 1.1, so you
    need to explicitly tell the compiler that you know it and you are game for it.
    To do so, you need to add the following lines to your `build.gradle` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，在 Kotlin 1.1 中协程是实验性的，所以你需要明确告诉编译器你知道这一点，并且你愿意使用它。为此，你需要在你的 `build.gradle`
    文件中添加以下行：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that everything is set up, you can start using coroutines in your project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，你可以在你的项目中开始使用协程。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s follow the given steps to understand how coroutines work in Kotlin:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照给定的步骤来了解 Kotlin 中协程的工作原理：
- en: 'There are two functions to start the coroutine:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个函数可以启动协程：
- en: '`launch{}`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch{}`'
- en: '`async{}`'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async{}`'
- en: 'Let''s try to write our first simple coroutine function:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试编写我们的第一个简单的协程函数：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding function will print "Hello" in the Android Studio console after
    a duration of 10 seconds. Note that we have used the `launch` function to start
    a coroutine, which returns a Job, but it does not carry any resulting value. It
    starts a new coroutine on a given thread pool (by default, coroutines are run
    on a shared pool of threads). Threads still exist in a program based on coroutines,
    but one thread can run on many coroutines, hence we don't need too many threads.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将在 10 秒后打印 "Hello" 到 Android Studio 控制台。请注意，我们使用了 `launch` 函数来启动一个协程，它返回一个
    Job，但它不携带任何结果值。它在一个给定的线程池上启动一个新的协程（默认情况下，协程是在一个共享的线程池上运行的）。尽管基于协程的程序中仍然存在线程，但一个线程可以运行多个协程，因此我们不需要太多线程。
- en: 'The key to coroutines are suspending functions. We can create a suspending
    function just by adding the `suspend` modifier on the function. Consider this
    example:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程的关键在于挂起函数。我们只需在函数上添加`suspend`修饰符就可以创建一个挂起函数。考虑以下示例：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Suspend functions are only allowed to be called from a coroutine or another
    suspend function. If you try to call them from somewhere else, your code won't
    even compile.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂起函数只能从协程或另一个挂起函数中调用。如果你尝试从其他地方调用它们，你的代码甚至无法编译。
- en: 'Antonio Leiva explains a suspending function as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 安东尼奥·利瓦（Antonio Leiva）将挂起函数解释如下：
- en: '**"...functions that can stop the execution** when they are called and make
    it continue once it has finished running their own task."'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**“...当它们被调用时可以停止执行，一旦它们完成自己的任务就会继续执行。”**'
- en: Coroutines needs to have at least one suspending function (in the last example,
    `delay` was a suspending function).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 协程至少需要有一个挂起函数（在上一个示例中，`delay`是一个挂起函数）。
- en: Next, we will see the `async` function. Conceptually, it is quite similar to
    the launch function, except the fact that `async` returns a deferred—a lightweight
    non-blocking future that represents a promise to provide a result later (much
    like Java's `Future`). To get the result from that deferred, you use `.await()`
    and since a deferred is also a `Job`,  you can cancel it if needed. Let's check
    out an example of `async`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将看到`async`函数。从概念上讲，它与启动函数非常相似，除了`async`返回一个延迟的——一个轻量级的非阻塞未来，它代表了一个承诺，稍后提供结果（类似于Java的`Future`）。要从该延迟中获取结果，你使用`.await()`，由于延迟也是一个`Job`，因此如果需要，你可以取消它。让我们看看`async`的一个示例。
- en: 'First, we will create two suspending functions and execute them concurrently,
    then will add the results from both functions:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个挂起函数并并发执行它们，然后将从两个函数中添加结果：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, we got the deferred objects, which is a `Future` object.
    To get the result out of it, we have used the `await` function. The `await` function
    is itself a suspending function; that's why we have wrapped it inside an `async`
    block.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们得到了延迟对象，这是一个`Future`对象。要从其中获取结果，我们使用了`await`函数。`await`函数本身就是一个挂起函数；这就是为什么我们将其包裹在一个`async`块中的原因。
- en: A key thing to note is that both the jobs have run asynchronously and concurrently
    and hence are non-blocking.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个需要注意的关键点是，这两个作业都是异步和并发运行的，因此是非阻塞的。
- en: 'If you want to run it in a blocking way, you need to use the `runBlocking`
    method. Here''s the same example, but it will block the main thread while it gets
    the result:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要以阻塞的方式运行它，你需要使用`runBlocking`方法。以下是相同的示例，但它将在获取结果时阻塞主线程：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more…
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Whenever in doubt, whether using thread or coroutines, remember these lines
    by Roman (an engineer from the JetBrains team):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时在考虑使用线程还是协程时，请记住罗马（来自JetBrains团队的工程师）的这些话：
- en: '"Coroutines are for asynchronous tasks that **wait** for something most of
    the time. Threads are for CPU-intensive tasks."'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: “协程适用于大多数时候都在等待某些事情异步任务。线程适用于CPU密集型任务。”
- en: 'In Android''s context, you always want to update the UI, but you can''t do
    it from background thread. Coroutines have a solution for this. Let''s take a
    look at the next example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android的上下文中，你总是想更新UI，但你不能从后台线程中这样做。协程为此提供了一个解决方案。让我们看看下一个示例：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, not only can we compute two jobs in the background without
    blocking the main thread, we can also touch the UI thread for updating views.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们不仅可以在不阻塞主线程的情况下在后台计算两个作业，我们还可以触摸UI线程来更新视图。
