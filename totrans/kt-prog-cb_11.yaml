- en: Networking and Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to fetch data over network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to copy data class with modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to parse JSON data from network to data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to download a file in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use RxJava and Retrofit with Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make an endless list using RecyclerView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Anko to run background tasks with Kotlin in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use coroutines to achieve multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will probably find it hard to get an app that doesn't communicate over the
    network. Communication with the internet is used in almost all the apps, be it
    a file-sharing app, streaming app, social network apps, or something else, the
    list goes on and on. There are many variables that you need to think about when
    you want to add network communication features to your Android apps. For example,
    you can't run it on the main thread, and network requests are always performed
    on background threads. Apart from that, you also need to detect when the network
    request fails, so as to give feedback to the user about what went wrong. In this
    chapter, we will address how to efficiently make network requests in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: How to fetch data over network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making a network request in Android is very cumbersome unless you use any third-party
    library. For example, let''s take a look at how network requests in Android used
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the preceding code is ugly. Kotlin eases out our pain to make a network
    request. In this recipe, we will learn how to make network requests in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0\. Ensure that you have its latest version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take look at the following steps required to make network requests in
    Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the huge pile of code we saw at the start of this recipe, just for
    performing a network request? All that can be replaced by just one line of Kotlin
    code. Let''s take a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will just return the `response` fetched from the network request that you
    made. You just need to provide your URL as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: While using this on Android, ensure that you have pushed this task in the background,
    or else you will get a `NetworkOnMainThread` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that we want to execute asynchronously is wrapped under the `doAsync`
    block. Wrapping the code inside an async task is also very simple. Let''s take
    a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have wrapped the network request into an async block, and then we have a
    `uiThread` method from where we can touch the UI elements of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `uiThread` method is provided by Anko library, which you can include in
    your project by adding these lines in your `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check out the *How to use Anko to run background tasks with Kotlin in Android* recipe
    of this chapter to learn more about how to create background tasks in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: How to create data class in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Are you sick and tired of creating long boilerplate code just for storing data?
    Do you feel that the following code is too much just to define a `Student` model?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you agree, then Kotlin's data class is just for you. So let's dive into it
    in this recipe and get to know it more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write our code. You can use any IDE that is
    capable of executing Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In every real-world project, you create classes that don''t have any use except
    for storing data, like in the case of the `Student` class we described earlier.
    The number of these types of classes can be way too high in a complex project
    having many roles and models. This results in a lot of boilerplate code. Kotlin
    has a great solution for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code mentioned at the start of the recipe can be reduced to just one line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to use the data class we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we didn't need any getter setter, which saved us a lot of boilerplate
    code. The getter setters are already included in the Kotlin property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the `toString()` method (which we haven''t even defined):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is better than what you'd get from Java's `toString()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data class also offers a lot of flexibility. For example, if you don''t want
    setter for a property, you can make the property `val`. This will make the property
    read-only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the cool things that you can do with data class is that you can destructure
    the object to obtain the property. Check out the following code to understand
    more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have default values of property in the class. Let''s take a look
    at the next example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data class has a few restrictions. According to Kotlin documentation, those
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The primary constructor needs to have at least one parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All primary constructor parameters need to be marked as `val` or `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data classes cannot be abstract, open, sealed, or inner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data classes may not extend other classes (but may implement interfaces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to copy data class with modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we learned how to use data class and how it reduces a lot
    of boilerplate code. In this recipe, we will see how data class makes it easy
    to copy another data class, even if you have to modify the property.
  prefs: []
  type: TYPE_NORMAL
- en: A brute-force mechanism to copy a data class can be to just create a data class
    by duplicating all the properties, but using the `copy` method will make it much
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write our code. You can use any IDE that is
    capable of executing Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the `copy` method, which takes in named arguments and creates
    a copy of the object with changed values of named arguments. Let''s look at an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'People usually get confused between the `copy()` and `apply()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply()`: It accepts a function and sets its scope to that of the object on
    which it has been invoked. It is a transformation function that can also be used
    to evaluate complex logic before returning. At the end, it just returns the same
    object with changes (if performed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`: The `apply` function is not thread-safe and mutates the object. The `copy()` function,
    on the other hand, returns a new object (without modifying the original object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to parse JSON data from network to data class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is one of the most widely used formats of response. Usually, the APIs provide
    outputs in the form of JSON response and in Android development also they are
    used widely as we communicate with network. Parsing JSON response to a data class
    helps us work with them as a Java object. You can also parse it using JSONObject,
    but it results in dirty code. In this recipe, we will learn how to parse JSON
    data into data class. We are using data class because they are preferred when
    the sole purpose of class is to save data. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using Android Studio 3.0; ensure that you have its latest version.
    We will be using the GSON library, an open source library by Google for parsing
    the JSON response. GSON is very easy to use and is one of the most popular JSON
    parsing libraries out there. To include GSON in your project, just add the following
    lines to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to understand how to parse JSON data from network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, we get a JSON response after making a network request, so for simplifying,
    we will assume that we get the given JSON response after making some network request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'IntelliJ IDEA provides a plugin that can help convert JSON response into Kotlin
    object. We will be using the `RoboPojoGenerator` plugin. Carry out the following
    steps to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Settings | Plugins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/426ea480-ff4a-4664-bade-7018ccdcd6d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Install JetBrains plugin; it will open a dialog. Search Robopojo in
    it, and you will see a RoboPOJOGenerator plugin. Click on Install and restart
    the Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d4fe4d1-1143-4ad4-9d5a-058f8af4abd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you've done that, to generate classes based on JSON response, first create
    an empty package where you would want to keep the classes. I have created it by
    the name `InstagramCommentsResponse` (because we have used Instagram API for fetching
    latest comments).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the package, and select New | Generate POJO from JSON. You
    will then see a dialog by the RoboPOJO generator, where you need to paste your
    JSON response. After you've done that, check the Kotlin and Gson box and click
    on Generate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you will see a bunch of classes created inside that package, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f19590a3-2b85-455e-8e66-f9fb04d3bdf0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at these classes. The first class is the outer holder of
    JSON response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to parse the JSON received from the network call. We will try
    to get the first comment received and access it as we do in Kotlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use it as a plain Kotlin object, without needing to use
    `JSONObject` to parse it using keys, which makes JSON parsing very easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to download a file in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to download files in our Android application. The most basic way
    of doing this will be opening a URL connection and using `InputStream` to read
    the content of the file and storing it in a local file using `FileOutputStream`; all
    this is in a background thread using `AsyncTask`. However, we don’t want to reinvent
    the wheel. There are a lot of libraries out there that handle all this stuff very
    nicely for us and make our work super easy, helping us create clean code.
  prefs: []
  type: TYPE_NORMAL
- en: We can use **Volley** ([https://developer.android.com/training/volley/index.html](https://developer.android.com/training/volley/index.html)),
    a networking library by developers at Google, which makes network communication
    very easy and fast. Another one we can use is **OkHttp** (by *Square*), which
    is very efficient, and we can use it along with **Retrofit** (for HTTP API).
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will be using a networking library called **Fuel**, which
    is written in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Android project and add an activity. Now, add fuel dependencies
    to your project dependencies by adding the following lines in your `build.gradle`
    and syncing the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$fuel_version` is the latest version of fuel library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to download a file in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a button in our view with an `onClickListener` attached to
    it. I am also adding a `progressBar` to the view to be able to see the progress
    of our download. This is my view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by downloading a temporary file. We will be using [https://httpbin.org/](https://httpbin.org/)
    for mocking download file API. The following is the code for downloading a temporary
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how our UI looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a22aefa-a71f-4f98-b73f-52fa9b93ab7d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, as we mentioned earlier, we will be using the `Fuel` library to download
    the file; here''s how the code looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I suggest that you play around with downloading files in Fuel, with and without
    progress, to get a better grasp of this. You can read all the other functionalities
    that Fuel provides at [https://github.com/kittinunf/Fuel](https://github.com/kittinunf/Fuel).
  prefs: []
  type: TYPE_NORMAL
- en: Also, try to use Volley and other networking libraries in Android to get an
    understanding of what are the differentiating points and use cases of each.
  prefs: []
  type: TYPE_NORMAL
- en: How to use RxJava and Retrofit with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Retrofit** is one of the most widely used networking libraries in Android.
    It is an open source library created by *Jake Wharton*. RxJava is the open source
    implementation of ReactiveX in Java. RxJava is a great way to do reactive-programming
    or event-driven programming. This recipe won''t teach you about reactive programming
    ( [https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)
    ), so if you aren''t comfortable with it, you can learn about it through the documentation
    ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)).
    Rather, in this recipe, you will learn how to use Retrofit and RxJava together.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using Android Studio 3.0\. Ensure that you have its latest version.
    We also need to add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `adapter-rxjava2` library helps us return observables as response, which
    can be subscribed by observers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using RxJava with Retrofit is quite simple; let''s take a look at the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of Retrofit (which is used to communicate with network) will be
    created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of interface where we define all of our Retrofit
    calls. You may note, we are returning the `Observable`, and that''s the only thing
    that has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to create an instance of your aforementioned service, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you just need to call the method, and you need a subscriber object that
    will subscribe to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have pushed the network call on a separate thread in the background. When
    the call/task is complete, the result will be observed on the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to make an endless list using RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do the Facebook, Instagram, and Twitter feeds have in common? They all
    have virtually infinite content to show you while you keep on scrolling down and
    down for more. There's no doubt that this is a great way to engage users on your
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to make an endless list using `RecyclerView`.
    There are many use cases of it, for example, social media, e-commerce application,
    or any content-based apps.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a simple app, which will load a small set of data in the beginning,
    but once the user scrolls to the bottom of the content, we will fetch another
    set of data and append to it, giving an illusion of infinite content to the user.
    So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0; ensure that you have its latest version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also need to include `RecyclerView` in your `build.gradle` file, which
    you can add as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can also find the source code in the `https://gitlab.com/aanandshekharroy/Anko-examples/`
    repository by checking out the `6-endless-list-using-recycler-view` branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be creating a simple app that will show numbers in the list. As you
    scroll down, the list will keep growing infinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25f505db-92e4-4404-b9d6-f0acc60b40e8.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s how the list is created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create an item that will be placed inside the list. The following
    is the code for that row item `recycler_row.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a `RecyclerView` in the main activity layout file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create a simple `RecyclerView` adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a simple function, which when called, will append 30 data
    items to the list. This is essentially what is done in apps. Once the user reaches
    the bottom of the list, a network call is made, which appends data to the previous
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set up the recycler view in the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have to intercept when the user has reached the bottom of the list,
    we have added a `ScrollListener`. We have overridden the `onScroll` method, and
    we are using the `canScrollVertically` method. The `canScrollVertically` method
    was added in API level 14, and it is used to check whether this view can be scrolled
    vertically in a certain direction. It takes an integer argument (negative to check
    scrolling up and positive to check scrolling down) and returns a boolean (`true`
    if possible, `false` if not). In our example, we have supplied a positive integer,
    which will return `true` if the view can be scrolled down and false if it can't
    be. If it can't be further scrolled down (meaning that the data is exhausted),
    we will add data to the list and update the list by calling the `notifyItemRangeInserted`
    method of the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to use Anko to run background tasks with Kotlin in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Anko** is a library created by the JetBrains team, which makes Android development
    quite easy with the help of many helper functions that abstract a lot of complexity
    and provides you easy-to-use methods. One such thing is to deal with background
    tasks. Using Anko, we can work with background tasks very easily. In this recipe,
    we will learn how to work with background tasks using Anko.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using Android Studio 3.0 for coding purposes; ensure that you have
    its latest version. You need to add Anko to your `build.gradle` file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Doing a task in the background is very easy in Kotlin. Let''s take a look at
    the next example. In this example, we will make a network request (which is required
    to do in the background or else you will get a `NetworkOnMainThread` exception);
    once the network request is complete, we will show the Success message using toast.
    Since we can''t touch the UI element from a background thread, we need to come
    to UI thread in order to do it. We will use the `uiThread` method provided by
    Anko, which will be called once the background task is over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `URL().readText()` is a long processing task, hence we've put
    it in the background task.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must have used async tasks for executing tasks in the background, but it
    wasn't a very efficient way to do it. It has its problem of handling them when
    the screen rotates, because it doesn't pay attention to the activity's lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: The `doAsync` method was called by an activity,  and if the activity is destroying,
    the `uiThread` will not be executed. This ensures that you get to touch the UI
    only till it is present.
  prefs: []
  type: TYPE_NORMAL
- en: How to use coroutines to achieve multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coroutines** are a great language feature in Kotlin. Here''s an apt definition
    of coroutines according to the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Coroutines are a new way of writing asynchronous, non-blocking code (and much
    more)."'
  prefs: []
  type: TYPE_NORMAL
- en: It's not just the ease of use, it's much more powerful than threads, especially
    in the case of a mobile environment where even milliseconds of performance gain
    is appreciated. Spawning multiple threads can cause performance issues, which
    isn't the case with coroutines since there can be thousands of those running without
    much drop in performance levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what the official documentation of Kotlin says:'
  prefs: []
  type: TYPE_NORMAL
- en: '"One can think of a coroutine as a lightweight thread. Like threads, coroutines
    can run in parallel, wait for each other, and communicate. The biggest difference
    is that coroutines are very cheap, almost free; we can create thousands of them,
    and pay very little in terms of performance. True threads, on the other hand,
    are expensive to start and keep around. A thousand threads can be a serious challenge
    for a modern machine."'
  prefs: []
  type: TYPE_NORMAL
- en: This fact makes it very powerful, and Kotlin's team has provided easy syntax
    to make it easy to use. In this recipe, we will learn how to use coroutines. So
    let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using Android Studio 3.0 for coding purposes. Coroutines are provided
    as a library that abstracts all the complexities and lets the library handle it.
    You need to add the library to the `build.gradle` file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This library is published to the Bintray JCenter repository, so you need to
    add `jcenter()` in your repositories, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that coroutines are experimental in Kotlin 1.1, so you
    need to explicitly tell the compiler that you know it and you are game for it.
    To do so, you need to add the following lines to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that everything is set up, you can start using coroutines in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the given steps to understand how coroutines work in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions to start the coroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`launch{}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async{}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to write our first simple coroutine function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will print "Hello" in the Android Studio console after
    a duration of 10 seconds. Note that we have used the `launch` function to start
    a coroutine, which returns a Job, but it does not carry any resulting value. It
    starts a new coroutine on a given thread pool (by default, coroutines are run
    on a shared pool of threads). Threads still exist in a program based on coroutines,
    but one thread can run on many coroutines, hence we don't need too many threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to coroutines are suspending functions. We can create a suspending
    function just by adding the `suspend` modifier on the function. Consider this
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Suspend functions are only allowed to be called from a coroutine or another
    suspend function. If you try to call them from somewhere else, your code won't
    even compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Antonio Leiva explains a suspending function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"...functions that can stop the execution** when they are called and make
    it continue once it has finished running their own task."'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines needs to have at least one suspending function (in the last example,
    `delay` was a suspending function).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see the `async` function. Conceptually, it is quite similar to
    the launch function, except the fact that `async` returns a deferred—a lightweight
    non-blocking future that represents a promise to provide a result later (much
    like Java's `Future`). To get the result from that deferred, you use `.await()`
    and since a deferred is also a `Job`,  you can cancel it if needed. Let's check
    out an example of `async`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will create two suspending functions and execute them concurrently,
    then will add the results from both functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we got the deferred objects, which is a `Future` object.
    To get the result out of it, we have used the `await` function. The `await` function
    is itself a suspending function; that's why we have wrapped it inside an `async`
    block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A key thing to note is that both the jobs have run asynchronously and concurrently
    and hence are non-blocking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to run it in a blocking way, you need to use the `runBlocking`
    method. Here''s the same example, but it will block the main thread while it gets
    the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever in doubt, whether using thread or coroutines, remember these lines
    by Roman (an engineer from the JetBrains team):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Coroutines are for asynchronous tasks that **wait** for something most of
    the time. Threads are for CPU-intensive tasks."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android''s context, you always want to update the UI, but you can''t do
    it from background thread. Coroutines have a solution for this. Let''s take a
    look at the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, not only can we compute two jobs in the background without
    blocking the main thread, we can also touch the UI thread for updating views.
  prefs: []
  type: TYPE_NORMAL
