["```swift\n#import \"SNSnakeSegment.h\"\n\n@class SNPlayfieldLayer;\n\n@interface SNSnake : CCNode {\n\n    SNPlayfieldLayer *parentLayer; // Parent layer\n    NSMutableArray *snakebody; // Contains the snake\n    NSInteger headRow; // Starting row for snake head\n    NSInteger headColumn; // Starting col for snake head\n\n    SnakeHeading _snakeDirection;  // Direction facing\n    float _snakeSpeed; // Current rate of movement\n}\n\n@property (nonatomic, retain) NSMutableArray *snakebody;\n@property (nonatomic, assign) SnakeHeading snakeDirection;\n@property (nonatomic, assign) float snakeSpeed;\n\n+(id) createWithLayer:(SNPlayfieldLayer*)myLayer\n           withLength:(NSInteger)startLength;\n\n-(void) addSegment;\n-(void) move;\n-(void) turnLeft;\n-(void) turnRight;\n-(void) deathFlash;\n\n@end\n```", "```swift\ntypedef enum {\n    kUp = 1,\n    kRight,\n    kLeft,\n    kDown\n} SnakeHeading;\n```", "```swift\n@interface SNSnakeSegment : CCSprite {\n    CGPoint _priorPosition; \n    SNSnakeSegment *_parentSegment; \n}\n\n@property (nonatomic, assign) CGPoint priorPosition;\n@property (nonatomic, assign) SNSnakeSegment *parentSegment;\n\n@end\n```", "```swift\n@implementation SNSnakeSegment\n\n@synthesize priorPosition = _priorPosition;\n@synthesize parentSegment = _parentSegment;\n\n-(void) setPosition:(CGPoint)position {\n    // override the method to let us keep the prior position\n    self.priorPosition = self.position;\n    [super setPosition:position];\n}\n\n@end\n```", "```swift\n+(id) createWithLayer:(SNPlayfieldLayer*)myLayer\n           withLength:(NSInteger)startLength {\n    return [[[self alloc] initWithLayer:myLayer\n            withLength:startLength] autorelease];\n}\n\n-(id) initWithLayer:(SNPlayfieldLayer*)myLayer\n                withLength:(NSInteger)startLength {\n    if (self = [super init]) {\n\n        // Keep a reference to the parent, so we can use\n        // the parent layer's positioning method\n        parentLayer = myLayer;\n\n        // Set up the snakebody array\n        snakebody = [[NSMutableArray alloc]\n                     initWithCapacity:30];\n\n        // Set the starting defaults\n        headRow = 2;\n        headColumn = 2;\n        self.snakeSpeed = 0.3;\n        self.snakeDirection = kUp;\n\n        // Add the head\n        [self addHead];\n\n        // Add the requested number of body segments\n        for (int i = 1; i < startLength; i++) {\n            [self addSegment];\n        }\n    }\n    return self;\n}\n```", "```swift\n-(void) addHead {\n    // Create the snake head\n    SNSnakeSegment *newSeg = [SNSnakeSegment\n            spriteWithSpriteFrameName:@\"snakehead.png\"];\n\n    // We use the parent layer's positioning method, so we \n    // will still be in lockstep with the other objects\n    CGPoint newPos = [parentLayer positionForRow:headRow\n                                andColumn:headColumn];\n\n    // Set up the snake's initial head position\n    [newSeg setPosition:newPos];\n    [newSeg setPriorPosition:newSeg.position];\n\n    // The head has no parent segment\n    [newSeg setParentSegment:nil];\n\n    // Add the head to the array and parent\n    [snakebody addObject:newSeg];\n    [parentLayer addChild:newSeg z:100];\n}\n```", "```swift\n-(void) addSegment {\n    // Create a new segment\n    SNSnakeSegment *newSeg = [SNSnakeSegment\n            spriteWithSpriteFrameName:@\"snakebody.png\"];\n\n    // Get a reference to the last segment of the snake\n    SNSnakeSegment *priorSeg = [snakebody objectAtIndex:\n                                ([snakebody count] - 1)];\n\n    // The new segment is positioned at the prior\n    // position as stored in priorSeg\n    [newSeg setPosition:[priorSeg position]];\n\n    // We start with same position for both variables\n    [newSeg setPriorPosition:[newSeg position]];\n    // Connect this segment to the one in front of it\n    [newSeg setParentSegment:priorSeg];\n    // Add the segment to the array and layer\n    [snakebody addObject:newSeg];\n    [parentLayer addChild:newSeg z:100-[snakebody count]];\n}\n```", "```swift\n#define gridSize 22\n```", "```swift\n-(void) move {\n    CGPoint moveByCoords;\n    // Based on the direction, set the coordinate change\n    switch (self.snakeDirection) {\n        case kUp:\n            moveByCoords = ccp(0,gridSize);\n            break;\n        case kLeft:\n            moveByCoords = ccp(-gridSize,0);\n            break;\n        case kDown:\n            moveByCoords = ccp(0,-gridSize);\n            break;\n        case kRight:\n            moveByCoords = ccp(gridSize,0);\n            break;\n        default:\n            moveByCoords = ccp(0,0);\n            break;\n    }\n\n    // Iterate through each segment and move it\n    for (SNSnakeSegment *aSeg in snakebody) {\n        if (aSeg.parentSegment == nil) {\n            // Move the head by the specified amount\n            [aSeg setPosition:ccpAdd(aSeg.position,\n                                     moveByCoords)];\n        } else {\n            // Body segments move to the prior position \n            // of the segment ahead of it\n            [aSeg setPosition:\n                    aSeg.parentSegment.priorPosition];\n        }\n    }\n}\n```", "```swift\n-(void) turnLeft {\n    switch (self.snakeDirection) {\n        case kUp:\n            self.snakeDirection = kLeft;\n            break;\n        case kLeft:\n            self.snakeDirection = kDown;\n            break;\n        case kDown:\n            self.snakeDirection = kRight;\n            break;\n        case kRight:\n            self.snakeDirection = kUp;\n            break;\n        default:\n            break;\n    } \n}\n```", "```swift\n-(void) deathFlash {\n    // Establish a flashing/swelling animation of head\n    CCTintTo *flashA = [CCTintTo actionWithDuration:0.2\n                        red:255.0 green:0.0 blue:0.0];\n    CCTintTo *flashB = [CCTintTo actionWithDuration:0.2\n                        red:255.0 green:255.0 blue:255.0];\n    CCScaleBy *scaleA = [CCScaleBy actionWithDuration:0.3\n                        scale:2.0];\n    CCScaleBy *scaleB = [CCScaleBy actionWithDuration:0.3\n                        scale:0.5];\n\n    SNSnakeSegment *head = [snakebody objectAtIndex:0];\n\n    [head runAction:[CCRepeatForever actionWithAction:\n            [CCSequence actions:flashA, flashB, nil]]];\n    [head runAction:[CCRepeatForever actionWithAction:\n            [CCSequence actions:scaleA, scaleB, nil]]];\n}\n```", "```swift\n-(CGPoint) positionForRow:(NSInteger)rowNum\n                andColumn:(NSInteger)colNum {\n    float newX = (colNum * gridSize) - 2;\n    float newY = (rowNum * gridSize) - 4;\n    return ccp(newX, newY);\n}\n```", "```swift\n-(void) createOuterWalls {\n    // Left and Right edges of screen\n    for (int row = 0; row <= size.height/gridSize+1; row++) {\n        // Build a new wall on the left edge\n        CGPoint newPosLeft = [self positionForRow:row\n                                    andColumn:0];\n        CCSprite *newWallLeft = [CCSprite\n                spriteWithSpriteFrameName:@\"wall.png\"];\n        [newWallLeft setPosition:newPosLeft];\n        [self addChild:newWallLeft];\n        [wallsOnField addObject:newWallLeft];\n\n        // Build a new wall on the right edge\n        CGPoint newPosRight = [self positionForRow:row\n                andColumn:(size.width/gridSize)+1];\n        CCSprite *newWallRight = [CCSprite\n                spriteWithSpriteFrameName:@\"wall.png\"];\n        [newWallRight setPosition:newPosRight];\n        [self addChild:newWallRight];\n        [wallsOnField addObject:newWallRight];\n    }\n    // Top and Bottom edges of screen\n    for (int col = 1; col < size.width/gridSize; col++) {\n        // Build a new wall at bottom edge of screen\n        CGPoint newPosBott = [self positionForRow:0\n                                    andColumn:col];\n        CCSprite *newWallBottom = [CCSprite\n                spriteWithSpriteFrameName:@\"wall.png\"];\n        [newWallBottom setPosition:newPosBott];\n        [self addChild:newWallBottom];\n        [wallsOnField addObject:newWallBottom];\n\n        // Build a new wall at the top edge of screen\n        CGPoint newPosTop = [self positionForRow:\n                (size.height/gridSize)+1 andColumn:col];\n        CCSprite *newWallTop = [CCSprite\n                spriteWithSpriteFrameName:@\"wall.png\"];\n        [newWallTop setPosition:newPosTop];\n        [self addChild:newWallTop];\n        [wallsOnField addObject:newWallTop];\n    }\n}\n```", "```swift\n-(void) createWall {\n    BOOL approvedSpot = YES;\n    SNSnakeSegment *head = [[snake snakebody]\nobjectAtIndex:0];\n\n    CGRect snakeline = CGRectMake(head.boundingBox.origin.x - \n        head.contentSize.width/2, 0,\n        head.boundingBox.origin.x + head.contentSize.width/2, \n        size.height);\n\n    // Randomly generate a position\n    NSInteger newRow = CCRANDOM_0_1()*(size.height/gridSize);\n    NSInteger newCol = CCRANDOM_0_1()*(size.width/gridSize);\n    CGPoint newPos = [self positionForRow:newRow\n                                andColumn:newCol];\n\n    // Build a new wall, add it to the layer\n    CCSprite *newWall = [CCSprite\n                spriteWithSpriteFrameName:@\"wall.png\"];\n    [newWall setPosition:newPos];\n    [self addChild:newWall];\n\n    // Check to make sure we aren't on top of the snake\n    for (SNSnakeSegment *aSeg in [snake snakebody]) {\n        if (CGRectIntersectsRect([newWall boundingBox],\n                                 [aSeg boundingBox])) {\n            approvedSpot = NO;\n            break;\n        }\n    }\n    // Checks for a clear path in front of the snake\n    // Assumes the snake is facing up\n    if (CGRectIntersectsRect([newWall boundingBox],\n                             snakeline)) {\n        approvedSpot = NO;\n    }\n    // Check to make sure there are no walls overlapping\n    for (CCSprite *aWall in wallsOnField) {\n        if (CGRectIntersectsRect([newWall boundingBox],\n                                 [aWall boundingBox])) {\n            approvedSpot = NO;\n            break;\n        }\n    }\n    // Check to make sure there are no mice in the way\n    for (CCSprite *aMouse in miceOnField) {\n        if (CGRectIntersectsRect([newWall boundingBox],\n                                 [aMouse boundingBox])) {\n            approvedSpot = NO;\n            break;\n        }\n    }\n    // If we passed everything, keep the wall\n    if (approvedSpot) {\n        [wallsOnField addObject:newWall];\n    // If we detected an overlap, build a replacement\n    } else {\n        [self removeChild:newWall cleanup:YES];\n        [self createWall];\n        return;\n    }\n}\n```", "```swift\n+(id) spriteWithSpriteFrameName:(NSString *)spriteFrameName {\n    return [[[self alloc] initWithSpriteFrameName:\n             spriteFrameName] autorelease];\n}\n-(id) initWithSpriteFrameName:(NSString*)spriteFrameName {\n    if (self = [super initWithSpriteFrameName:spriteFrameName]) {\n        // Lifespan is between 10 and 20\n        lifespan = 10 + (CCRANDOM_0_1() * 10);\n    }\n    return self;\n}\n```", "```swift\n-(void) createMouse {\n    BOOL approvedSpot = YES;\n\n    // Randomly generate a position\n    NSInteger newRow = CCRANDOM_0_1()*(size.height/gridSize);\n    NSInteger newCol = CCRANDOM_0_1()*(size.width/gridSize);\n    CGPoint newPos = [self positionForRow:newRow\n                                andColumn:newCol];\n    // Build a new mouse, add it to the layer\n    SNMouse *newMouse = [SNMouse\n                spriteWithSpriteFrameName:@\"mouse.png\"];\n    [newMouse setPosition:newPos];\n    [self addChild:newMouse];\n    // Check to make sure we aren't on top of the snake\n    for (SNSnakeSegment *aSeg in [snake snakebody]) {\n        if (CGRectIntersectsRect([newMouse boundingBox],\n                                 [aSeg boundingBox])) {\n            approvedSpot = NO;\n            break;\n        }\n    }\n    // Check to make sure there are no walls here\n    for (CCSprite *aWall in wallsOnField) {\n        if (CGRectIntersectsRect([newMouse boundingBox],\n                                 [aWall boundingBox])) {\n            approvedSpot = NO;\n            break;\n        }\n    }\n    // Check to make sure there are no mice in the way\n    for (SNMouse *aMouse in miceOnField) {\n        if (CGRectIntersectsRect([newMouse boundingBox],\n                                 [aMouse boundingBox])) {\n            approvedSpot = NO;\n            break;\n        }\n    }\n    // If we passed everything, keep the mouse\n    if (approvedSpot) {\n        [miceOnField addObject:newMouse];\n    // If we detected an overlap, build a replacement\n    } else {\n        [self removeChild:newMouse cleanup:YES];\n        [self createMouse];\n        return;\n    }\n}\n```", "```swift\n-(void) checkForCollisions {\n    // Get the head\n    SNSnakeSegment *head = [[snake snakebody]\n                                        objectAtIndex:0];\n    // Check for collisions with the snake's body\n    for (SNSnakeSegment *bodySeg in [snake snakebody]) {\n        if (CGRectIntersectsRect([head boundingBox],\n            [bodySeg boundingBox]) && head != bodySeg) {\n            [self snakeCrash];\n            break;\n        }\n    }\n    // Check for collisions with the walls\n    for (CCSprite *aWall in wallsOnField) {\n        if (CGRectIntersectsRect([aWall boundingBox],\n                                 [head boundingBox])) {\n            [self snakeCrash];\n            break;\n        }\n    }\n```", "```swift\n    // Check for mice eaten\n    CCSprite *mouseToEat;\n    BOOL isMouseEaten = NO;\n    for (CCSprite *aMouse in miceOnField) {\n        if (CGRectIntersectsRect([head boundingBox],\n                                 [aMouse boundingBox])) {\n            isMouseEaten = YES;\n            mouseToEat = aMouse;\n            [[SimpleAudioEngine sharedEngine]\n                                playEffect:SND_GULP];\n            break;\n        }\n    }\n    if (isMouseEaten) {\n        // Replace the mouse, longer snake, score\n        [mouseToEat removeFromParentAndCleanup:YES];\n        [miceOnField removeObject:mouseToEat];\n        [self createMouse];\n        [snake addSegment];\n        [self incrementScore];\n    }\n}\n```", "```swift\n+(id) initForLevel:(NSInteger)startLevel\n     andDifficulty:(SNSkillLevel)skillLevel {\n            return [[[self alloc]initForLevel:startLevel\n                  andDifficulty:skillLevel] autorelease];\n}\n\n-(id) initForLevel:(NSInteger)startLevel\n     andDifficulty:(SNSkillLevel)skillLevel {\n\n    if (self = [super init]) {\n      levelNum = startLevel;\n        currentSkill = skillLevel;\n\n  // See code bundle for complete initForLevel method\n```", "```swift\n-(void) createSnake {\n    NSInteger snakeLength = 4 + currentSkill;\n    snake = [[SNSnake createWithLayer:self\n                        withLength:snakeLength] retain];\n    snake.snakeSpeed = .3 -((levelNum+currentSkill)*0.02);\n\n    wallCount = 3 + (levelNum * currentSkill);\n    mouseCount = currentSkill;\n}\n```", "```swift\ntypedef enum {\n    kSkillEasy = 1,\n    kSkillMedium,\n    kSkillHard\n} SNSkillLevel;\n```", "```swift\n-(void)update:(ccTime)dt {\n  stepTime += dt;\n  if (stepTime > snake.snakeSpeed) {\n        stepTime = 0;\n      [snake move];\n      [self checkForCollisions];\n    }\n```", "```swift\n    if (playerScore >= 8) {\n        [self showLevelComplete];\n    }\n```", "```swift\n    [[CCDirector sharedDirector] replaceScene:\n        [SNPlayfieldScene sceneForLevel:levelNum + 1\n                          andDifficulty:currentSkill]];\n```", "```swift\n  for (SNMouse *aMouse in miceOnField) {\n        aMouse.lifespan = aMouse.lifespan - dt;\n\n      if (aMouse.lifespan <= 0) {\n            [deadMice addObject:aMouse];\n            [aMouse removeFromParentAndCleanup:YES];\n        }\n    }\n    [miceOnField removeObjectsInArray:deadMice];\n\n    // Add new mice as replacements\n    for (int i = 0; i < [deadMice count]; i++) {\n        [self createMouse];\n    }\n\n    [deadMice removeAllObjects];\n}\n```", "```swift\n-(BOOL) ccTouchBegan:(UITouch *)touch\n           withEvent:(UIEvent *)event {\n\n    CGPoint location = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:location];\n\n    if (convLoc.x < size.width/2) {\n        // Touched left half of the screen\n        [snake turnLeft];\n        return YES;\n    } else {\n        // Touched right half of the screen\n        [snake turnRight];\n        return YES;\n    }\n\n    // If we did not claim the touch.\n    return NO;\n}\n```"]