<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Continuous Integration</h1></div></div></div><p>
<strong>Continuous Integration</strong> is one agile technique for software engineering that aims to improve the software quality and to reduce the time taken to integrate changes by continuously applying integration and testing frequently, opposed to the more traditional approach of integrating and testing by the end of the development cycle. The original article was written by Martin Fowler back in 2000 (<a class="ulink" href="http://www.martinfowler.com/articles/continuousIntegration.html">http://www.martinfowler.com/articles/continuousIntegration.html</a>), and describes the experience of putting together Continuous Integration on a large software project.<a class="indexterm" id="id419"/>
</p><p>Continuous Integration has received a broad adoption in recent years, and a proliferation of commercial tools and Open Source projects is a clear demonstration of its success. That is not very difficult to understand, as anybody who during their professional career has participated in a software development project using a traditional approach, is very likely to have experienced the so called<em> integration hell</em>, where the time it takes to integrate the changes exceeds the time it took to make the changes. Does this remind you of anything?</p><p>On the contrary, Continous Integration is the practice to integrate changes frequently and in small steps. These steps are negligible and usually no errors as a product of the integration can arise without beign noticed immediately. The most common practice is to trigger the build process after every commit to the source code repository.<a class="indexterm" id="id420"/>
</p><p>This practice also implies other requirements, beside the source code being maintained by a Version Control System (VCS):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Builds should be automated by running a single command. This feature has been supported for a very long time by tools like<code class="literal"> make</code> and more recently by<code class="literal"> ant</code> and<code class="literal"> maven</code>.</li><li class="listitem" style="list-style-type: disc">The build should be self tested to confirm that the newly built software meets the expectations of the developers, and this has been the subject of this book so far.</li><li class="listitem" style="list-style-type: disc">The artifacts and results of the tests should be easy to find and view.</li></ul></div><p>In previous chapters, we have written some tests for our Android projects and now we would like to take Continuous Integration into account. To achieve this we want to create a model that coexists with the traditional Eclipse and Android ADT environments, so both alternatives are supported from the source tree.</p><p>In this chapter we are going to discuss:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Automating the build process</li><li class="listitem" style="list-style-type: disc">Introducing Version Control Systems to the process</li><li class="listitem" style="list-style-type: disc">Continuous Integration with Hudson</li><li class="listitem" style="list-style-type: disc">Automating tests</li></ul></div><p>After this chapter you will be able to apply Continuous Integration to your own project no matter its size, whether it is a medium or large software project employing dozens of developers or it is just you programming solo.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Building Android applications manually using Ant</h1></div></div></div><p>If we aim to incorporate<strong> Continuous Integration</strong> in our development process, the first step will be building Android applications manually, as we can combine it with this technique to automate the procedure.<a class="indexterm" id="id421"/>
</p><p>In doing this we intend to keep our project compatible with the Eclipse and ADT plugin building process, and this is what we are going to do. As I understand, this is a great advantage and speeds up the development process by automatically building and eventually showing the errors that may exist in your project immediately. This is an invaluable tool too when editing resources or other files that generate intermediate classes, otherwise some simple errors would be discovered too late in the building process.</p><p>Fortunately, Android supports this alternative with the existing tooling and not much effort is needed to merge both approaches in the same project. In such cases, building manually with<strong> ant</strong> is supported. However, other options exist too, though not supported<em> out-of-the-box</em>, like using<strong> maven</strong> or even<strong> make</strong>.</p><div><h3 class="title"><a id="note21"/>Note</h3><p>Ant is a software command-line tool and a Java library to automate software build process by describing it in XML files containing targets and dependencies.</p><p>More information can be found at its home page,<a class="ulink" href="http://ant.apache.org/"> http://ant.apache.org/</a>.</p><p>The Android Ant based build system requires at least Ant 1.8 or newer versions.</p></div><p>Here it is worth noting that the entire Android platform is built by an incredibly complex structure of makefiles and this method is used even for building the applications that are included by the platform like Calculator, Contacts, Browser, and so on.</p><p>If you are already building a project with Eclipse, you can convert it using the<code class="literal"> android</code> tool.<code class="literal"> android</code> is available in the tools directory of the Android SDK. If you are using Microsoft Windows you should adapt the following examples to use valid Windows paths and replace the variables that are not available, like PWD in the following example, by their values.<a class="indexterm" id="id422"/>
</p><p>Firstly, we change our current directory to the project; though not strictly necessary, this simplifies things a bit.</p><p>Then using the<code class="literal"> android</code> command we convert the project to be built with<code class="literal"> ant</code> and the<code class="literal"> build.xml</code> buildfile is created:</p><div><pre class="programlisting"><strong>$ cd &lt;path/to&gt;/TemperatureConverter
$ android update project --path $PWD --name TemperatureConverter</strong>
</pre></div><p>This is the output obtained:</p><p>
<strong>Updated local.properties</strong>
</p><p>
<strong>Added file &lt;path/to&gt;/TemperatureConverter/build.xml</strong>
</p><p>
<strong>Updated file &lt;path/to&gt;/TemperatureConverter/proguard.cfg</strong>
</p><p>Immediately after finishing this step we are ready to build the project manually from the command line. This buildfile features the following targets:<a class="indexterm" id="id423"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Target</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>help</p>
</td><td style="text-align: left" valign="top">
<p>Displays a short help.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>clean</p>
</td><td style="text-align: left" valign="top">
<p>Removes output files created by other targets.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>compile</p>
</td><td style="text-align: left" valign="top">
<p>Compiles project's<code class="literal"> .java</code> files into<code class="literal"> .class</code> files.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>debug</p>
</td><td style="text-align: left" valign="top">
<p>Builds the application and signs it with a debug key.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>release</p>
</td><td style="text-align: left" valign="top">
<p>Builds the application. The generated<code class="literal"> .apk</code> file must be signed before it is published.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>install</p>
</td><td style="text-align: left" valign="top">
<p>Installs/reinstalls the debug package onto a running emulator or device.</p>
<p>If the application was previously installed, the signatures must match.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>uninstall</p>
</td><td style="text-align: left" valign="top">
<p>Uninstalls the application from a running emulator or device.</p>
</td></tr></tbody></table></div><p>Some of these targets operate on a device or emulator. If there are several devices or emulators connected to the build machine we need to specify the specific target on the command line. For this reason the targets uses a variable named<code class="literal"> adb.device.arg</code> for us to specify the target:<a class="indexterm" id="id424"/>
</p><div><pre class="programlisting"><strong>$ ant -Dadb.device.arg='-s emulator-5554' install</strong>
</pre></div><p>This is the output generated:</p><p>
<strong>Buildfile: build.xml</strong>
</p><p>
<strong>[setup] Android SDK Tools Revision 9</strong>
</p><p>
<strong>[setup] Project Target: Android 2.3.1</strong>
</p><p>
<strong>[setup] API level: 9</strong>
</p><p>
<strong>[setup] Importing rules file: platforms/android-8/ant/ant_rules_r2.xml</strong>
</p><p>
<strong>-compile-tested-if-test:</strong>
</p><p>
<strong>-dirs:</strong>
</p><p>
<strong>[echo] Creating output directories if needed..</strong>.</p><p>
<strong>[mkdir] Created dir: TemperatureConverter/bin/classes</strong>
</p><p>
<strong>-resource-src:</strong>
</p><p>
<strong>[echo] Generating R.java / Manifest.java from the resources..</strong>.</p><p>
<strong>-aidl:</strong>
</p><p>
<strong>[echo] Compiling aidl files into Java classes..</strong>.</p><p>
<strong>compile:</strong>
</p><p>
<strong>[javac] Compiling 6 source files to TemperatureConverter/bin/classes</strong>
</p><p>
<strong>-dex:</strong>
</p><p>
<strong>[echo] Converting compiled files and external libraries into TemperatureConverter/bin/classes.dex..</strong>.</p><p>
<strong>-package-resources:</strong>
</p><p>
<strong>[echo] Packaging resources</strong>
</p><p>
<strong>[aaptexec] Creating full resource package..</strong>.</p><p>
<strong>-package-debug-sign:</strong>
</p><p>
<strong>[apkbuilder] Creating TemperatureConverter-debug-unaligned.apk and signing it with a debug key..</strong>.</p><p>
<strong>[apkbuilder] Using keystore: .android/debug.keystore</strong>
</p><p>
<strong>debug:</strong>
</p><p>
<strong>[echo] Running zip align on final apk..</strong>.</p><p>
<strong>[echo] Debug Package: TemperatureConverter/bin/TemperatureConverter-debug.apk</strong>
</p><p>
<strong>install:</strong>
</p><p>
<strong>[echo] Installing TemperatureConverter/bin/TemperatureConverter-debug.apk onto default emulator or device..</strong>.</p><p>
<strong>[exec] 371 KB/s (18635 bytes in 0.049s)</strong>
</p><p>
<strong>[exec] pkg: /data/local/tmp/TemperatureConverter-debug.apk</strong>
</p><p>
<strong>[exec] Success</strong>
</p><p>
<strong>BUILD SUCCESSFUL</strong>
</p><p>
<strong>Total time: 6 seconds</strong>
</p><p>That is, running the command line mentioned, the following steps are executed:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Environment setup, including the specific rules for the version used</li><li class="listitem" style="list-style-type: disc">Create the output directories if needed</li><li class="listitem" style="list-style-type: disc">Compile the sources, including resources, aidl, and Java files</li><li class="listitem" style="list-style-type: disc">Convert the compiled files into<code class="literal"> dex</code></li><li class="listitem" style="list-style-type: disc">Package creation and signing</li><li class="listitem" style="list-style-type: disc">Installation onto the given device or emulator</li></ul></div><p>Once we have the APK installed, and because we are now doing everything from the command line, we can even start the<code class="literal"> TemperatureConverterActivity</code>. Using the<code class="literal"> am start</code> command and an<code class="literal"> Intent</code> using the action<code class="literal"> MAIN</code> and the<code class="literal"> Activity</code> we are interested to launch as the component, we can create a command line as follows:<a class="indexterm" id="id425"/>
</p><div><pre class="programlisting"><strong>$ adb -s emulator-5554 shell am start -a android.intent.action.MAIN -n com.example.aatg.tc/.TemperatureConverterActivity</strong>
</pre></div><p>The Activity is started as you can verify in the emulator. Then, we can proceed in a similar way for the test project:</p><div><pre class="programlisting"><strong>$ cd &lt;/path/to&gt;/TemperatureConverterTest
$ android update test-project --path $PWD --main &lt;path/to&gt;/TemperatureConverter</strong>
</pre></div><p>Running this command, we will obtain output similar to the following if everything goes well:</p><p>
<strong>Updated default.properties</strong>
</p><p>
<strong>Updated local.properties</strong>
</p><p>
<strong>Added file &lt;path/to&gt;/TemperatureConverterTest/build.xml</strong>
</p><p>
<strong>Updated file &lt;path/to&gt;/TemperatureConverterTest/proguard.cfg</strong>
</p><p>
<strong>Updated build.properties</strong>
</p><p>Also as we did before with the main project, we can build and install the tests. To do it, once we have our test project converted we can build it using<code class="literal"> ant</code> as we did for the main project. To build and install it on a running emulator, use:</p><div><pre class="programlisting"><strong>$ ant -Dadb.device.arg='-s emulator-5554' install</strong>
</pre></div><p>It is worth noting that to be able to build the project successfully we need the libraries used to reside in the<code class="literal"> libs</code> directory inside the project. You can create symbolic links to their original location to avoid copying them if you prefer.</p><p>Also, it is a good practice to keep the Eclipse and Ant build processes synchronized, so if you add the required libraries to the<code class="literal"> libs</code> directory you can also replace the locations of the libraries in the Eclipse project using<strong> Properties | Java Build Path | Libraries</strong>.</p><p>Now we can run the tests from the command line as we already discussed in previous chapters:</p><div><pre class="programlisting"><strong>$ adb -e shell am instrument -w com.example.aatg.tc.test/android.test.InstrumentationTestRunner</strong>
</pre></div><p>Running the command we will obtain the tests results:</p><p>
<strong>com.example.aatg.tc.test.EditNumberTests:.......</strong>.</p><p>
<strong>com.example.aatg.tc.test.TemperatureConverterActivityTests:.........</strong>.</p><p>
<strong>com.example.aatg.tc.test.TemperatureConverterApplicationTests:....</strong>.</p><p>
<strong>com.example.aatg.tc.test.TemperatureConverterTests:...</strong>.</p><p>
<strong>Test results for InstrumentationTestRunner=..........................</strong>.</p><p>
<strong>Time: 12.125</strong>
</p><p>
<strong>OK (28 tests)</strong>
</p><p>We have done everything from the command line by just invoking some simple commands, which is what we were looking for in order to feed this into a<strong> Continuous Integration</strong> process.<a class="indexterm" id="id426"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Git—the fast version control system</h1></div></div></div><p>
<strong>Git</strong> is a free and Open Source, distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It is very simple to setup so I strongly recommend its use even for personal projects. There is no project simpler enough that could not benefit from the application of this tool. You can find information and downloads at<a class="ulink" href="http://git-scm.com/."> http://git-scm.com/.</a>
<a class="indexterm" id="id427"/>
</p><p>On the other hand, a version control system or VCS (also known as<strong> Source Code Management</strong> or<strong> SCM)</strong> is an unavoidable element for development projects where more than one developer is involved. Furthermore, even if it is possible to apply continuous integration with no VCS in place, as it is not a requisite clearly, is not a reasonable practice.<a class="indexterm" id="id428"/>
</p><p>Other, and probably more traditional, options exist in the VCS arena such as Subversion or CVS that you are free to use if you feel more comfortable. Anyway, Git is used extensively by the Android project so it is worth investing some time to at least understand the basics.</p><p>Having said that and remembering that this is a very broad subject to justify a book in itself (and certainly there are some good books about it) we are discussing here the most basic topics and supplying examples to get you started if you haven't embraced this practice yet.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec01"/>Creating a local git repository</h2></div></div></div><p>These are the simplest possible commands to create a local repository and populate it with the initial source code for our projects. In this case again we are using<code class="literal"> TemperatureConverter</code> and<code class="literal"> TemperatureConverterTest</code> projects created and used in previous chapters. We are selecting a directory named<code class="literal"> git-repos</code> as the parent for both projects and copying the code we used in the previous section, where we built manually:<a class="indexterm" id="id429"/>
</p><div><pre class="programlisting"><strong>$ cd &lt;path/to&gt;/git-repos
$ mkdir TemperatureConverter
$ cd TemperatureConverter
$ git init
$ cp -a &lt;path/to&gt;/TemperatureConverter/. .
$ ant clean
$ rm local.properties
$ git add .
$ git commit -m "Initial commit"</strong>
</pre></div><p>That is, we create the parent for the repositories, create the project directory, initialize the git repository, copy the initial content, clean our previous built, remove the<code class="literal"> local.properties</code> file, add everything to the repository, and commit.</p><div><h3 class="title"><a id="tip07"/>Tip</h3><p>The<code class="literal"> local.properties</code> file must never be checked in a Version Control System as it contains information specific to your local configuration.</p></div><p>Then, the same should be done for the<code class="literal"> TemperatureConverterTest</code> project:</p><div><pre class="programlisting"><strong>$ cd &lt;path/to&gt;/git-repos
$ mkdir TemperatureConverterTest
$ cd TemperatureConverterTest
$ git init
$ cp -a &lt;path/to&gt;/TemperatureConverterTest/. .
$ ant clean
$ rm local.properties
$ git add .
$ git commit -m "Initial commit"</strong>
</pre></div><p>At this point we have two project repositories containing the initial source code for the<code class="literal"> TemperatureConverter</code> and<code class="literal"> TemperatureConverterTest</code> projects. We haven't altered their structure so they are also compatible with<strong> Eclipse</strong> and the<strong> Android ADT</strong> plugin to build while we develop in an IDE.<a class="indexterm" id="id430"/>
</p><p>The next step is to have both projects built and tested automatically every time we commit a change to the source code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Continuous Integration with Hudson</h1></div></div></div><p>
<strong>Hudson</strong> is an Open Source, extensible<strong> Continuous Integration</strong> server which has the ability to build and test software projects or to monitor the execution of external jobs. Hudson has an easy installation and configuration and does a very decent job and this is the reason why we are basing our example on it.<a class="indexterm" id="id431"/>
</p><div><h3 class="title"><a id="note22"/>Note</h3><p>Recently (January 2011) a proposal was made to change the name from Hudson to Jenkins to avoid future legal problems as Oracle has submitted a trademark registration. Consequently now two different forked projects exist. Though these examples are based on Hudson you should monitor the evolution of the individual projects to find the one that better suites your needs.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec02"/>Installing and configuring Hudson</h2></div></div></div><p>We mentioned easy installation as one of Hudson's advantages and installation could not be any easier.<a class="indexterm" id="id432"/>
</p><p>Download the native package for the operating system of your choice from<a class="ulink" href="http://hudson-ci.org/"> http://hudson-ci.org/</a>. There are native packages for Debian/Ubuntu, RedHat/Fedora/Centos, openSUSE, OpenSolaris/Nevada, and FreeBSD or download the latest generic<code class="literal"> hudson.war</code> (which will work on Mac and Windows as well). In the following examples we will be using version 2.0. We will show the latter as it is the one that does not require administrative privileges to install, configure, and run.<a class="indexterm" id="id433"/>
</p><p>Once finished, copy it into a selected directory, let's say<code class="literal"> ~/hudson</code>, and then run the following:</p><div><pre class="programlisting"><strong>$ java -jar hudson-2.0.0.war</strong>
</pre></div><p>This expands and starts Hudson.</p><p>The default configuration uses port 8080 as the HTTP listener port, so pointing your browser of choice to<code class="literal"> http://localhost:8080</code> should present you with the Hudson home page.</p><p>You can verify and change Hudson's operating parameter if required, by accessing the<strong> Manage Hudson</strong> screen. We should add to this configuration the plugins needed for Git integration and support for Android emulator during builds. These plugins are named<strong> Hudson GIT plugin</strong> and<strong> Android Emulator Plugin</strong> respectively.<a class="indexterm" id="id434"/>
</p><p>This screenshot displays the information you can obtain about the plugins following the hyperlinks available on the Hudson administration page:</p><div><img alt="Installing and configuring Hudson" src="img/3500_08_01.jpg"/></div><p>After installing and restarting Hudson these plugins will be available for use. Our next step is to create the jobs necessary to build the projects.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec03"/>Creating the jobs</h2></div></div></div><p>Let's start by creating the<code class="literal"> TemperatureConverter</code> job using<strong> New Job in the Hudson home page</strong>. Different kind of jobs can be created; in this case we are selecting<strong> Build a free-style software project</strong>, allowing you to connect any SCM with any build system.<a class="indexterm" id="id435"/>
</p><p>After clicking on the OK button you will be presented with the specific job options, which that are described in the following table. This is the job properties page:</p><div><img alt="Creating the jobs" src="img/3500_08_02.jpg"/></div><p>All of the options in the<strong> New Job</strong> screen have a help text associated, so here we are only explaining the ones we are entering:<a class="indexterm" id="id436"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Project name</p>
</td><td style="text-align: left" valign="top">
<p>The name given to the project.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Description</p>
</td><td style="text-align: left" valign="top">
<p>Optional description.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Discard Old Builds</p>
</td><td style="text-align: left" valign="top">
<p>This helps you save on disk consumption by managing how long to keep records of the builds (such as console output, build artifacts, and so on.)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>This build is parameterized</p>
</td><td style="text-align: left" valign="top">
<p>This allows you to configure parameters that are passed to the build process to create parameterized builds.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Disable Build (No new builds will be executed until the project is re-enabled.)</p>
</td><td style="text-align: left" valign="top">
<p>Temporarily disable the project.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Execute concurrent builds if necessary (beta)</p>
</td><td style="text-align: left" valign="top">
<p>This permits the execution of several builds concurrently.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Source Code Management</p>
</td><td style="text-align: left" valign="top">
<p>Also know as VCS.</p>
<p>Where is the source code for the project? In this case we are using git and a repository where the URL is the absolute path of the repository we created earlier. For example,<code class="literal"> /home/diego/aatg/git-repos/TemperatureConverter</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build Triggers</p>
</td><td style="text-align: left" valign="top">
<p>How this project is automatically built. In this case we want that every change in the source code triggers the automatic build so we are selecting<strong> Poll SCM</strong>. The other option is to use<strong> Build periodically</strong>. This feature is primarily for using Hudson as a<code class="literal"> cron</code> replacement, and it is not ideal for continuously building software projects. When people first start continuous integration, they are often so used to the idea of regularly scheduled builds like nightly/weekly that they use this feature. However, the point of continuous integration is to start a build as soon as a change is made, to provide a quick feedback to the change.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Schedule</p>
</td><td style="text-align: left" valign="top">
<p>This field follows the syntax of<code class="literal"> cron</code> (with minor differences). Specifically, each line consists of five fields separated by TAB or whitespace:<code class="literal"> MINUTE HOUR DOM MONTH DOW</code>.</p>
<p>For example if we want to poll continuously at thirty minutes past the hour specify:<code class="literal"> 30 * * * *</code>
</p>
<p>Check the documentation for a complete explanation of all the options.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build environment</p>
</td><td style="text-align: left" valign="top">
<p>Lets you specify different options for the build environment and for the Android emulator that may run during the build.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build</p>
</td><td style="text-align: left" valign="top">
<p>This describes the build steps. We are selecting<strong> Invoke Ant</strong> as we are reproducing the steps we did before to manually build the project.</p>
<p>The target we use here is<code class="literal"> debug</code> as we only want to compile the project and generate the APK, and not install or run it. Additionally, using the<strong> Advanced..</strong>. options we need to specify the Android SDK directory and the Android target version<strong> Properties</strong>.</p>
<p>
<code class="literal">sdk.dir=/opt/android-sdk target=android-9</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Post build actions</p>
</td><td style="text-align: left" valign="top">
<p>These are a series of actions we can do after the build is done. We are interested in saving the APKs so we are enabling<strong> Archive the artifacts</strong> and then defining the path for them as<strong> Files to archive</strong>; in this precise case it is<code class="literal"> **/*-debug.apk</code>.</p>
</td></tr></tbody></table></div><p>Now there are two options: you can force a build using<strong> Build now</strong>, or introduce some changes to the source code through Git and wait for them to be detected by our polling strategy. Either way, we would get our project built and our artifacts ready to be used for other purposes, such as dependency projects or QA.</p><p>So far we haven't run any tests and this is just what we are presenting now. Hudson has the ability to handle dependencies between projects, so we are now creating a Hudson job,<code class="literal"> TemperatureConverterTest</code> depending on<code class="literal"> TemperatureConverter</code>.<a class="indexterm" id="id437"/>
</p><p>Proceed in the same way as before. We are only pinpointing the differences in setting up this project against the previous setup.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Build Triggers</p>
</td><td style="text-align: left" valign="top">
<p>This is how we trigger the build of this project.<strong> Built after other projects are built</strong> is selected so that when some other projects finish building, a new build is scheduled for this project. We need this to be built after<code class="literal"> TemperatureConverter</code>.</p>
<p>This is convenient for running an extensive test after a build is complete as in this example.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build environment</p>
</td><td style="text-align: left" valign="top">
<p>Our intention is to install and run the tests on an emulator so for our build environment we use the facilities provided by the<strong> Android Emulator Plugin</strong>. This comes in handy if you wish to automatically start an Android emulator of your choice before the build steps execute, with the emulator being stopped after building is complete.</p>
<p>You can choose to start a pre-defined, existing Android emulator instance (AVD).</p>
<p>Alternatively, the plugin can automatically create a new emulator on the build slave with properties you specify here.</p>
<p>In any case, the<code class="literal"> logcat</code> output will automatically be captured and archived.</p>
<p>Then select<code class="literal"> 2.3</code> for the<strong> Android OS version</strong>,<code class="literal"> 240</code> DPI for the<strong> Screen density</strong> and<code class="literal"> WVGA</code> for<strong> Screen resolution</strong>.</p>
<p>Feel free to experiment and select the options that better suit your needs.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Common emulator options</p>
</td><td style="text-align: left" valign="top">
<p>We would like to<strong> Reset emulator state at start-up</strong> to wipe user data and disable<strong> Show emulator window</strong>, so the emulator window is not displayed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build</p>
</td><td style="text-align: left" valign="top">
<p>Select<strong> Invoke ant</strong> as the build step and<code class="literal"> install</code> as the<strong> Target</strong>. Here again, as we did in<code class="literal"> TemperatureConverter</code>, we have to set some variables to build and install the current job. Using the<strong> Advanced..</strong>. options set:</p>
<p>
<code class="literal">sdk.dir=/opt/android-sdk</code>
</p>
<p>
<code class="literal">target=android-9</code>
</p>
<p>
<code class="literal">tested.project.dir=../../TemperatureConverter/workspace/</code>
</p>
<p>
<code class="literal">adb.device.arg=-s $ANDROID_AVD_DEVICE</code>
</p>
<p>As before, we specified the Android SDK directory and the target version. Additionally, here we should specify the target project directory, that is the SUT, and the device where we want to install the APK. We are using a special variable set by the<strong> Android Emulator Plugin</strong> to identify the ADV that was chosen as the target.</p>
</td></tr></tbody></table></div><p>After configuring and building this project, we have the APK installed on the target emulator. Some steps are still needed as we still miss running the tests and obtaining the results to be displayed in Hudson.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec04"/>Obtaining Android test results</h2></div></div></div><p>To be able to display test results we should store raw XML results in the test runner. The default<code class="literal"> android.test.InstrumentationTestRunner</code> does not support storing raw XML so the solution here is to extend it to provide the missing functionality.<a class="indexterm" id="id438"/>
</p><p>I found the<code class="literal"> nbandroid-utils</code> (<a class="ulink" href="http://code.google.com/p/nbandroid-utils/">http://code.google.com/p/nbandroid-utils/</a>) project hosted in Google code that provides almost the same functionality that we need.</p><p>The<code class="literal"> com.neenbedankt.android.test.InstrumentationTestRunner</code> class extends the Android one so that an XML of the test results is written to the device when running the tests.</p><p>We also want the ability to specify the filename from the test arguments and be able to store files in external storage just in case test results become very large, so we are slightly modifying the class to support these features. Also, to make these changes evident we are naming the new class<code class="literal"> XMLInstrumentationTestRunner:</code>
<a class="indexterm" id="id439"/>
</p><div><pre class="programlisting">package com.neenbedankt.android.test;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import org.xmlpull.v1.XmlPullParserFactory;
import org.xmlpull.v1.XmlSerializer;
import android.os.Bundle;
import android.util.Log;
/*
* Copyright (C) 2010 Diego Torres Milano
*
* Base on previous work by
* Copyright (C) 2007 Hugo Visser
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
* either express or implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*/
/**
* This test runner creates an xml in the files directory of
* the application under test. The output is compatible with
* that of the junitreport ant task, the format that is
* understood by Hudson. Currently this implementation does not
* implement the all aspects of the junitreport format, but
* enough for Hudson to parse the test results.
*/
public class XMLInstrumentationTestRunner extends android.test.InstrumentationTestRunner {
private Writer mWriter;
private XmlSerializer mTestSuiteSerializer;
private long mTestStarted;
</pre></div><p>Here we are providing the field to keep the name of the output file as well as its default value.<a class="indexterm" id="id440"/>
</p><p>We are also defining the name of the argument our test runner will use to receive this value:</p><div><pre class="programlisting"><strong>/**
* Output file name.
*/
private String mOutFileName;
/**
* Outfile argument name.
* This argument can be passed to the instrumentation using &lt;code&gt;-e&lt;/code&gt;.
*/
private static final String OUT_FILE_ARG = "outfile";
/**
* Default output file name.
*/
private static final String OUT_FILE_DEFAULT = "test-results.xml";</strong>
</pre></div><p>In our<code class="literal"> onCreate()</code> method we verify if the argument has been provided and if so we store it in the previously defined field:</p><div><pre class="programlisting"><strong>@Override
public void onCreate(Bundle arguments) {
if ( arguments != null ) {
mOutFileName = arguments.getString(OUT_FILE_ARG);
}
if ( mOutFileName == null ) {
mOutFileName = OUT_FILE_DEFAULT;
}
super.onCreate(arguments);
}</strong>
</pre></div><p>In the<code class="literal"> onStart()</code> method we create the file and we use it as the JUnit output:<a class="indexterm" id="id441"/>
</p><div><pre class="programlisting"><strong>@Override
public void onStart() {
try {
File dir = getTargetContext().getExternalFilesDir(null);
if ( dir == null ) {
dir = getTargetContext().getFilesDir();
}
final File outFile = new File(dir, mOutFileName);
startJUnitOutput(new FileWriter(outFile));
} catch (IOException e) {
throw new RuntimeException(e);
}
super.onStart();
}</strong>
</pre></div><p>The following code is the original code for this test runner:<a class="indexterm" id="id442"/>
</p><div><pre class="programlisting">void startJUnitOutput(Writer writer) {
try {
mWriter = writer;
mTestSuiteSerializer = newSerializer(mWriter);
mTestSuiteSerializer.startDocument(null, null);
mTestSuiteSerializer.startTag(null, "testsuites");
mTestSuiteSerializer.startTag(null, "testsuite");
} catch (Exception e) {
throw new RuntimeException(e);
}
}
private XmlSerializer newSerializer(Writer writer) {
try {
XmlPullParserFactory pf = XmlPullParserFactory.newInstance();
XmlSerializer serializer = pf.newSerializer();
serializer.setOutput(writer);
return serializer;
} catch (Exception e) {
throw new RuntimeException(e);
}
}
@Override
public void sendStatus(int resultCode, Bundle results) {
super.sendStatus(resultCode, results);
switch (resultCode) {
case REPORT_VALUE_RESULT_ERROR:
case REPORT_VALUE_RESULT_FAILURE:
case REPORT_VALUE_RESULT_OK:
try {
recordTestResult(resultCode, results);
} catch (IOException e) {
throw new RuntimeException(e);
}
break;
case REPORT_VALUE_RESULT_START:
recordTestStart(results);
default:
break;
}
}
void recordTestStart(Bundle results) {
mTestStarted = System.currentTimeMillis();
}
void recordTestResult(int resultCode, Bundle results) throws IOException {
float time = (System.currentTimeMillis() - mTestStarted) / 1000.0f;
String className = results.getString(REPORT_KEY_NAME_CLASS);
String testMethod = results.getString(REPORT_KEY_NAME_TEST);
String stack = results.getString(REPORT_KEY_STACK);
int current = results.getInt(REPORT_KEY_NUM_CURRENT);
int total = results.getInt(REPORT_KEY_NUM_TOTAL);
mTestSuiteSerializer.startTag(null, "testcase");
mTestSuiteSerializer.attribute(null, "classname", className);
mTestSuiteSerializer.attribute(null, "name", testMethod);
if (resultCode != REPORT_VALUE_RESULT_OK) {
mTestSuiteSerializer.startTag(null, "failure");
if (stack != null) {
String reason = stack.substring(0, stack.indexOf('\n'));
String message = "";
int index = reason.indexOf(':');
if (index &gt; -1) {
message = reason.substring(index+1);
reason = reason.substring(0, index);
}
mTestSuiteSerializer.attribute(null, "message", message);
mTestSuiteSerializer.attribute(null, "type", reason);
mTestSuiteSerializer.text(stack);
}
mTestSuiteSerializer.endTag(null, "failure");
} else {
mTestSuiteSerializer.attribute(null, "time", String.format("%.3f", time));
}
mTestSuiteSerializer.endTag(null, "testcase");
if (current == total) {
mTestSuiteSerializer.startTag(null, "system-out");
mTestSuiteSerializer.endTag(null, "system-out");
mTestSuiteSerializer.startTag(null, "system-err");
mTestSuiteSerializer.endTag(null, "system-err");
mTestSuiteSerializer.endTag(null, "testsuite");
mTestSuiteSerializer.flush();
}
}
@Override
public void finish(int resultCode, Bundle results) {
endTestSuites();
super.finish(resultCode, results);
}
void endTestSuites() {
try {
if ( mTestSuiteSerializer != null ) {
mTestSuiteSerializer.endTag(null, "testsuites");
mTestSuiteSerializer.endDocument();
mTestSuiteSerializer.flush();
}
if ( mWriter != null) {
mWriter.flush();
mWriter.close();
}
} catch (IOException e) {
throw new RuntimeException(e);
}
}
}
</pre></div><p>There are still a few steps required to achieve our objective. The first is to add this test runner to our project using the combination<code class="literal"> git add/git commit</code>.<a class="indexterm" id="id445"/>
</p><p>You can simply use these commands:</p><div><pre class="programlisting"><strong>$ git add src/com/neenbedankt/
$ git commit -a -m "Added XMLInstrumentationTestRunner"</strong>
</pre></div><p>Then we need to declare the instrumentation using the test runner in<code class="literal"> AndroidManifest.xml</code>. That is use the recently created test runner<code class="literal"> com.neenbedankt.android.test.XMLInstrumentationTestRunner</code> as the instrumentation for the<code class="literal"> com.example.aatg.tc</code> package:<a class="indexterm" id="id446"/>
</p><div><pre class="programlisting">&lt;instrumentation
android:targetPackage="com.example.aatg.tc"
android:label="TemperatureConverter tests"<strong>
android:name="com.neenbedankt.android.test. XMLInstrumentationTestRunner"</strong>
/&gt;
</pre></div><p>Also, add it to the repository as we did before with other files.</p><p>And finally, as we have the ability to add a step in the build process by using<strong> Add build step</strong> that executes arbitrary commands in a shell script, we add this as an<strong> Execute shell</strong> step in the job configuration page. We are using some shell variables to be able to re-utilize this step for other projects:</p><div><pre class="programlisting">PKG=com.example.aatg.tc
OUTDIR=/data/data/${PKG}/files/
OUTFILE=test-results.xml
ADB=/opt/android-sdk/platform-tools/adb
$ADB -s $ANDROID_AVD_DEVICE install -r "$WORKSPACE/../../ TemperatureConverter/lastSuccessful/ archive/bin/TemperatureConverter-debug.apk"
$ADB -s $ANDROID_AVD_DEVICE shell am instrument -w -e outfile "$OUTFILE" $PKG.test/com.neenbedankt.android.test.XMLInstrumentationTestRunner
$ADB -s $ANDROID_AVD_DEVICE pull "$OUTDIR/$OUTFILE" "$WORKSPACE/$OUTFILE"
</pre></div><p>Let us explain these steps in greater detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We assign a specific project package name to PKG variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OUTDIR</code> is the name of the directory where the test runner will leave the file<code class="literal"> OUTFILE</code>. Note that this is a directory on the emulator or device, not a local directory.</li><li class="listitem" style="list-style-type: disc">Install the package under test onto the emulator or device.</li><li class="listitem" style="list-style-type: disc">Run the instrumentation from the command line, as we have seen previously, but in this case adding an extra argument<code class="literal"> -e outfile</code> with the name of the file we are expecting to receive.</li><li class="listitem" style="list-style-type: disc">Get the test results from that file, pulling from the device to the local workspace.</li></ul></div><p>Almost everything is in place. The only thing left is to tell Hudson where to expect these test results. In this scenario we use the<strong> Post Build Actions also in the job configuration page</strong>.<a class="indexterm" id="id447"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Publish Junit test results report</p>
</td><td style="text-align: left" valign="top">
<p>When this option is configured, Hudson can provide useful information about test results, such as historical test result trends, a web UI for viewing test reports, tracking failures, and so on.</p>
<p>To use this feature, first set up your build to run tests, then use<code class="literal"> com.neenbedankt.android.test.XMLInstrumentationTestRunner</code> as the test runner, specify the output using<code class="literal"> -e outfile</code> in the instrumentation, and use this same name to tell Hudson where to find the results. Ant glob syntax, such as<code class="literal"> **/build/test-reports/*.xml</code>, can also be used.</p>
<p>Be sure not to include any non-report files into this pattern.</p>
<p>In simple terms, this is simply<code class="literal"> test-results.xml</code> as we specified in the<code class="literal"> OUTFILE</code> variable before.</p>
<p>Once there are a few builds running with test results, you should start seeing some trend charts displaying the evolution of tests.</p>
</td></tr></tbody></table></div><p>Having done all of the steps described before, only forcing a build is left to see the results. Press<strong> Build now</strong> as usual and after a few moments you will see your test results and statistics displayed in a similar way as the following screenshot depicts:<a class="indexterm" id="id448"/>
</p><div><img alt="Obtaining Android test results" src="img/3500_08_03.jpg"/></div><p>From here we can easily understand our project status, knowing how many tests failed and why. Digging through the failed tests we can also find the extensive<strong> Error message</strong> and<strong> Stack trace</strong>.</p><p>It is also really helpful to understand the evolution of a project through the evaluation of different trends and Hudson is able to provide such information. Every project presents the current trends using weather-like icons from sunny, when the health of the project increases 80%, and to thunderstorm when the health lies bellow 20%. In addition, for every project the evolution of the trend of the tests success versus failure ratio is displayed in a chart that is reproduced here:</p><div><img alt="Obtaining Android test results" src="img/3500_08_04.jpg"/></div><p>In this case we can see how since the last build, one test started to fail.<a class="indexterm" id="id449"/>
</p><p>To see how a project status changes by forcing a failure let's add a failing test like the following:</p><div><pre class="programlisting">public final void testForceFailure1() {
fail("Forced fail");
}
</pre></div><p>Yet another very interesting feature that is worth mentioning is the ability of Hudson to keep and display the Timeline and Build Time Trend, as shown in the following screenshot:</p><div><img alt="Obtaining Android test results" src="img/3500_08_05.jpg"/></div><p>This page presents the build history with hyperlinks to every particular build that you can follow to see the details.</p><p>Now we have less concern to be worried about and every time somebody in the developer team commits changes to the repository we know that these changes will be immediately integrated and the whole project will be built and tested and if we further configure Hudson we can even receive the status by e-mail. To achieve this, in the job configuration page enable<strong> E-mail Notification</strong> and enter the desired<strong> Recipients</strong>.<a class="indexterm" id="id450"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Summary</h1></div></div></div><p>This chapter has introduced<strong> Continuous Integration</strong> in practice providing valuable information to start applying it soon to your projects no matter what their size is, whether you are developing solo or on a big company team.</p><p>The techniques presented focus on the particularities of Android projects maintaining and supporting widely used development tools like Eclipse and Android ADT.</p><p>We introduced real-world examples with real-world tools available from the vast Open Source arsenal. We employed Ant to automate the building process, git to create a simple version control system repository to store our source code and manage the changes, and finally installed and configured Hudson as the Continuous Integration of choice.</p><p>In this course we detailed the creation of jobs for automating the creation of<code class="literal"> TemperatureConverter</code> and its tests and we emphasized on the relationship between the projects.</p><p>Finally, we analyzed a way of getting XML results from Android tests and implemented this to obtain an attractive interface to monitor the running of tests, their results, and the existing trends.</p><p>The next chapter deals with a different aspect of testing concentrating on performance and profiling which is probably the natural step to follow after we have our application behaving correctly and according to our specifications.</p></div></body></html>