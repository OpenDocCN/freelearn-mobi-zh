<html><head></head><body>
        

                            
                    <h1 class="header-title">Reactive Programming</h1>
                
            
            
                
<div><div><p>Reactive programming is an asynchronous approach to event handling. We encounter asynchronous events, such as user interactions with the interface or the delivery of long-term operation results, all the time. There are also libraries, such as <a href="https://github.com/ReactiveX/RxJava">RxJava</a> and <a href="https://github.com/reactor/reactor-core">Reactor</a><a href="https://github.com/reactor/reactor-core">,</a> <a href="https://github.com/reactor/reactor-core">that allow us to write reactive code in Kotlin or Java. </a></p>
<p>In this chapter, you will learn about the Observer pattern, and how to transform asynchronous events from one type to another. You will also learn how to use the Mono, Single, Observable, and Flux classes that implement the reactive programming concepts.</p>
<p> This chapter will cover the following topics:</p>
<ul>
<li>Reactive programming with Spring Reactor</li>
<li>Blocking and non-blocking</li>
<li>RxJava</li>
<li>RxJava in Android</li>
</ul>
<p>By the end of this chapter, you will be able to apply reactive programming to your applications, using the RxJava and Reactor libraries.</p>
</div>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>You can find the examples from this chapter on GitHub, at the following link: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8</a>.</p>
<p>To integrate the Reactor library into your project, add the following line to the repositories section of the <kbd>build.gradle</kbd> file:</p>
<pre>maven { url 'https://repo.spring.io/libs-milestone' }</pre>
<p class="mce-root"/>
<p>Add the following line to the dependencies section:</p>
<pre>implementation "io.projectreactor:reactor-core:3.2.2.RELEASE"</pre>
<p>The Reactor library works with a version of the <strong>Java Development Kit</strong> (<strong>JDK</strong>), 8 or above. So, we should add the following line to the Android section:</p>
<pre>compileOptions {<br/>    sourceCompatibility JavaVersion.VERSION_1_8<br/>    targetCompatibility JavaVersion.VERSION_1_8<br/>}</pre>
<p>To integrate the RxJava library, add the following line to the dependencies section:</p>
<pre>implementation "io.reactivex.rxjava2:rxjava:2.2.3"</pre>
<p>To integrate the RxAndroid library, add the following line to the dependencies section:</p>
<pre>implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'</pre>
<p>To integrate the RxBinding library, you should add the following line to the dependencies section:</p>
<pre>implementation 'com.jakewharton.rxbinding3:rxbinding:3.0.0-alpha1'</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reactive programming with Spring Reactor</h1>
                
            
            
                
<p><strong>Reactor</strong> is a library that implements reactive programming concepts for the JVM. This approach is based on the Observer pattern, and it provides types that can emit <em>zero</em>, <em>one</em>, or a sequence of values.</p>
<p>In this section, you will learn the following:</p>
<ul>
<li>How to implement the Observer pattern</li>
<li>How to use the Flux publisher</li>
<li>How to use the Mono publisher</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Observer pattern</h1>
                
            
            
                
<p>The <em>Observer pattern</em> assumes that there is an object that sends a message, and another object that receives it. The following diagram shows how a class hierarchy can be organized to implement this approach:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c728260a-1d64-439a-a06e-070d957d0511.png"/></p>
<p>The <kbd>Activity</kbd> class implements the <kbd>OnClickListener</kbd> interface and contains an instance of the <kbd>Button</kbd> class, while the <kbd>Button</kbd> class contains the <kbd>performClick</kbd> method that invokes the <kbd>onClick</kbd> method of an instance of the <kbd>OnClickListener</kbd> class, if it is not null. The <kbd>onClick</kbd> method of the activity will then be invoked. In this way, an instance of the <kbd>Activity</kbd> class will be notified when a user clicks on the button.</p>
<p>The following example code shows how this approach works.</p>
<p>The <kbd>ObserverActivity</kbd> contains an instance of the <kbd>Button</kbd> class and invokes the <kbd>setOnClickListener</kbd> method:</p>
<pre>class ObserverActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_observer)<br/>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener {<br/>            Toast.makeText(this, "Clicked!", Toast.LENGTH_LONG).show()<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>The <kbd>setOnClickListener</kbd> method looks as follows:</p>
<pre>public void setOnClickListener(@Nullable OnClickListener l) {<br/>    if (!isClickable()) {<br/>        setClickable(true);<br/>    }<br/>    getListenerInfo().mOnClickListener = l;<br/>}</pre>
<p>The <kbd>performClick</kbd> method invokes the <kbd>onClick</kbd> function, as follows:</p>
<pre>public boolean performClick() {<br/>    ////......<br/>    final boolean result;<br/>    final ObserverInfo li = mObserverInfo;<br/> if (li != null &amp;&amp; li.mOnClickObserver != null) {<br/> playSoundEffect(SoundEffectConstants.CLICK);<br/> li.mOnClickObserver.onClick(this);<br/> result = true;<br/> } else {<br/> result = false;<br/> }<br/> ///........<br/> return result;<br/>}</pre>
<p>This shows that the <kbd>performClick</kbd> method invokes the <kbd>onClick</kbd> method if a reference of the <kbd>OnClickObserver</kbd> type is not <kbd>null</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Flux publisher</h1>
                
            
            
                
<p>The <kbd>Flux</kbd> class represents a stream of values. This means that an instance of the Flux type can emit values, and a subscriber can receive them. This class contains a lot of functions that can be divided into two groups:</p>
<ul>
<li>Static factories that allow us to create a new instance of the Flux type from different sources, such as callbacks or arrays.</li>
<li>Operators that allow us to process emitted values</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following example code shows how this works:</p>
<pre>fun fluxTest() {<br/>    Flux.fromArray(arrayOf(1, 2, 3))<br/>            .map { it * it }<br/>            .subscribe { println(it) }<br/>}</pre>
<p>The <kbd>fromArray</kbd> function creates a new instance of the Flux type that emits values from passed arrays, one by one. The <kbd>map</kbd> method allows us to modify a value from the upstream, and the <kbd>subscribe</kbd> method is needed to pass an Observer that takes the resulting values.</p>
<p>The output of this example looks as follows:</p>
<pre> 1<br/> 4<br/> 9</pre>
<p>The <kbd>Flux</kbd> provides a lot of operators that can be used to process the emitted values. The following example code demonstrates this:</p>
<pre>Flux.fromArray(arrayOf(1, 2, 3))<br/>        .filter { it % 2 == 1 }<br/>        .map { it * it }<br/>        .reduce { sum, item -&gt; sum + item }<br/>        .subscribe { println(it) }</pre>
<p>The <kbd>.filter</kbd>, <kbd>.map</kbd>, <kbd>.reduce</kbd>, and <kbd>.subscribe</kbd> operators are provided by the flux. We will look at each one of them in detail in just a bit. </p>
<p>From the operator point of view, a stream is divided into <strong>upstream</strong> and <strong>downstream</strong>. An <strong>operator</strong> takes a value from the <strong>upstream</strong>, modifies it, and passes the result to the <strong>downstream</strong>. The following diagram shows how operators work:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3ae8fa34-3e97-4c59-8d24-10f3c7666035.png" style="width:27.08em;height:15.17em;"/></p>
<p class="mce-root"/>
<p>From the <kbd>map</kbd> operator point of view, the values emitted from the <kbd>filter</kbd> function belong to the <strong>upstream</strong><strong>,</strong> and  the items that are taken by <kbd>reduce</kbd> belong to the <strong>downstream</strong>.</p>
<p>The result of the preceding example looks as follows:</p>
<pre>1<br/>9</pre>
<p>The output shows that after all of the transformations, an instance of the <kbd>Flux</kbd> class emits only two numbers.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The filter operator</h1>
                
            
            
                
<p>The <kbd>filter</kbd> method takes a predicate, and if a value from the upstream doesn't meet a condition of the predicate, it isn't passed to the downstream.</p>
<div><em>A predicate</em> is a function that takes parameters and returns a Boolean value.</div>
<p>The following diagram shows how the <kbd>filter</kbd> method works in the previous example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/172c9c74-f27b-416e-a21a-8acb847c508f.png" style="width:30.67em;height:12.67em;"/></p>
<p>In this example, the <kbd>filter</kbd> operator is only used to receive odd numbers.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The map operator</h1>
                
            
            
                
<p>The <kbd>map</kbd> operator takes a lambda that applies a transformation for each value from the upstream. The <kbd>map</kbd> function can be used to change the values of the primitive values, or to transform an instance from one type to another.</p>
<p>The following diagram shows how this works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ad94afcb-6f3e-4dd0-82eb-557a1a9b7f45.png" style="width:28.75em;height:11.58em;"/></p>
<p>The <kbd>map</kbd> function takes another function that describes how an element from the upstream should be transformed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The flatMap operator</h1>
                
            
            
                
<p>The <kbd>flatMap</kbd> operator works in a similar way to the map, but works <em>asynchronously</em>. This means that it should return an instance that can return a value in the future, such as <kbd>Flux</kbd> or <kbd>Mono</kbd>. The following example code shows how it can be used:</p>
<pre>Flux.fromArray(arrayOf(1, 2, 3))<br/>        .flatMap { Mono.just(it).delayElement(Duration.ofSeconds(1)) }<br/>        .subscribe { println(it) }</pre>
<p>The output of this example looks as follows:</p>
<pre> 1<br/> 2<br/> 3</pre>
<p class="mce-root"><strong>Mono</strong> is similar to Flux, but it can emit one or zero elements. In this example, we use the <kbd>delayElement</kbd> function, which is why each element is received by a subscriber with a one-second delay.</p>
<p>The following diagram shows how it works:</p>
<div><img src="img/8a8f859d-7726-434a-9a0f-3cbfa74cca68.png" style="width:28.17em;height:11.33em;"/></div>
<p>This shows that each <kbd>flatMap</kbd> operator passes each value to the downstream asynchronously, with a one-second delay.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The reduce operator</h1>
                
            
            
                
<p>The <kbd>reduce</kbd> function takes an instance of the <kbd>BiFunction</kbd> type, which contains the <kbd>apply</kbd> function, taking two values and returning a single one. The <kbd>this</kbd> operator can be used to combine all items from the upstream into a single value, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/95b7ff37-6c44-4513-aa81-125f09741db6.png" style="width:30.42em;height:12.58em;"/></p>
<p>The preceding diagram shows that the upstream contains two values, and the <kbd>reduce</kbd> function passes a sum of them to the downstream.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The from static method</h1>
                
            
            
                
<p>The <kbd>fromArray</kbd> function is one of many static factory methods that are provided by the <kbd>Flux</kbd> class. If we want to create our own source of events, we can use the <kbd>from</kbd> function. Let's create an instance of the <kbd>Flux</kbd> class that emits the <kbd>Unit</kbd> object when a user clicks on the button.</p>
<p>We can implement this case as follows:</p>
<pre>Flux.from&lt;Unit&gt; { subscriber -&gt;<br/>    findViewById&lt;Button&gt;(R.id.button).setOnClickListener {<br/>        subscriber.onNext(Unit)<br/>    }<br/>}.subscribe {<br/>    Toast.makeText(this, "Clicked!", Toast.LENGTH_LONG).show()<br/>}</pre>
<p>The preceding snippet shows how to wrap an Observer into an instance of the <kbd>Flux</kbd> class. This example illustrates using the <kbd>from</kbd> function to create a new instance of the <kbd>Flux</kbd> class.</p>
<p>Let's run an application and press the THE OBSERVER PATTERN button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/013c5fe3-ed61-471d-97ee-7d4f86d951cd.png" style="width:24.08em;height:38.67em;"/></p>
<p>The preceding screenshot shows how an example works. When a user clicks the button, the <kbd>onNext</kbd> method is invoked and the <kbd>Observable</kbd> emits a value. The lambda that we passed to the <kbd>subscribe</kbd> method is invoked, and it shows a message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cancellation</h1>
                
            
            
                
<p class="mce-root">Instances of the <kbd>Activity</kbd> or <kbd>Fragment</kbd> class have life cycles that are represented by methods, such as <kbd>onCreate</kbd> and <kbd>onDestroy</kbd>. We should clean all resources by using the <kbd>onDestroy</kbd> method, in order to avoid memory leaks.</p>
<p>The <kbd>subscribe</kbd> method returns an instance of the <kbd>Disposable</kbd> type, as follows:</p>
<pre>public final Disposable subscribe(Consumer&lt;? super T&gt; consumer) {<br/>   Objects.requireNonNull(consumer, "consumer");<br/>   return subscribe(consumer, null, null);<br/>}</pre>
<p>The <kbd>Disposable</kbd> interface contains two methods, as follows:</p>
<ul>
<li class="mce-root"><kbd>dispose</kbd> cancels a publisher</li>
<li><kbd>isDisposed</kbd> returns <kbd>true</kbd> if a publisher has already been cancelled</li>
</ul>
<p>The following example code shows how to cancel a publisher when the <kbd>onDestroy</kbd> method is invoked:</p>
<pre>class ObserverActivity : AppCompatActivity() {<br/>    <br/>    private var disposable: Disposable? = null<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_observer)<br/>        disposable = Flux.from&lt;Unit&gt; { subscriber -&gt;<br/>            findViewById&lt;Button&gt;(R.id.button).setOnClickListener {<br/>                subscriber.onNext(Unit)<br/>            }<br/>        }.subscribe {<br/>            Toast.makeText(this, "Clicked!", Toast.LENGTH_LONG).show()<br/>        }<br/>    }<br/><br/>    override fun onDestroy() {<br/>        super.onDestroy()<br/>        disposable?.dispose()<br/>    }<br/>}<br/></pre>
<p>As you can see, the <kbd>onDestroy</kbd> method invokes the <kbd>dispose</kbd> method to unsubscribe from an instance of the <kbd>Flux</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Mono publisher</h1>
                
            
            
                
<p>The <em>Mono</em> publisher works in a similar way to Flux, but can only emit no values or a single value. We can use this to perform a request to a server and return the result.</p>
<p>The following example code makes a request and receives an instance of the <kbd>Comic</kbd> class, loading an instance of the <kbd>Bitmap</kbd> class and displaying the retrieved image:</p>
<pre>Mono.fromDirect&lt;Comic&gt; { subscriber -&gt; subscriber.onNext(loadComic()) }<br/>        .map { comic -&gt; comic.img }<br/>        .flatMap { path -&gt; Mono.fromDirect&lt;Bitmap&gt; { subscriber -&gt; subscriber.onNext(loadBitmap(path)) } }<br/>        .subscribeOn(Schedulers.single())<br/>        .subscribe { bitmap -&gt;<br/>            Handler(Looper.getMainLooper()).post {<br/>                findViewById&lt;ImageView&gt;(R.id.imageView).setImageBitmap(bitmap)<br/>            }<br/>        }</pre>
<p class="mce-root"/>
<p>The <kbd>subscribeOn</kbd> method is used to specify a scheduler for long-term tasks. Let's run this example, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ccdc8149-79fb-47e2-8256-2abea4f4de2b.png" style="width:27.75em;height:44.50em;"/></p>
<p>The preceding snippet retrieves an instance of the <kbd>Comic</kbd> class, transforms it to a path to an image, loads the image, and then shows a downloaded image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blocking and non-blocking</h1>
                
            
            
                
<p>When we work with Android, we should remember that we have a main thread that is responsible for a user interface. First, it is not a good idea to invoke long-term operations in the main thread, because in that case, a user interface freezes. Secondly, when we invoke a synchronous method, this blocks a thread. Our user interface is unresponsive until a function that is invoked from the main thread returns the result. That is why we should invoke a long-term operation asynchronously, and reactive programming can help us to do just that.</p>
<p>The <kbd>Mono</kbd> and <kbd>Flux</kbd> classes contain the <kbd>publishOn</kbd> and <kbd>subscribeOn</kbd> methods that can switch threads when operators are invoked. The <kbd>subscribeOn</kbd> method is used to specify a scheduler that produces emitted values, and the <kbd>publishOn</kbd> is used to specify a thread scheduler for the downstream of an <kbd>observable</kbd>.</p>
<p>Scheduler is an abstraction over thread pool. The following example code creates our own scheduler that uses the main thread:</p>
<pre>val UIScheduler = Schedulers.fromExecutor { runnable -&gt;     Handler(Looper.getMainLooper()).post(runnable) <br/>}</pre>
<p>Now, we can rewrite an example from the Mono publisher section, in the following way:</p>
<pre>Mono.fromDirect&lt;Comic&gt; { subscriber -&gt; subscriber.onNext(loadComic()) }<br/>        .map { comic -&gt; comic.img }<br/>        .flatMap { path -&gt; Mono.fromDirect&lt;Bitmap&gt; { subscriber -&gt; subscriber.onNext(loadBitmap(path)) } }<br/>        .subscribeOn(Schedulers.single())<br/>        .publishOn(UIScheduler)<br/>        .subscribe { bitmap -&gt; findViewById&lt;ImageView&gt;(R.id.imageView).setImageBitmap(bitmap) }</pre>
<p>The single function of the <kbd>Schedulers</kbd> class returns an instance of the <kbd>Scheduler</kbd> type that creates and uses a single thread under the hood. The <kbd>subscribeOn</kbd> method specifies that all operators from the upstream have to use a scheduler that is returned by the <kbd>single()</kbd> function.</p>
<p>We pass our own scheduler that uses <strong>the main thread</strong> under the hood. For this reason, the lambda that is passed to the <kbd>subscribe</kbd> method is performed on <strong>the main thread</strong>.</p>
<p class="mce-root"/>
<p>The following diagram shows how this works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3aa52423-0a10-4ee4-add9-a75f074422fe.png" style="width:30.83em;height:11.08em;"/></p>
<p>The diagram shows that <strong>the main thread</strong> is not blocked, and runs with a background, in parallel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RxJava</h1>
                
            
            
                
<p><strong>RxJava</strong> is another popular library that implements the concept of reactive programming. It also provides types, such as Observable or Single, that emit values. All of these classes also provide static factories and operators.</p>
<p>In this section, we will cover the following:</p>
<ul>
<li>How to use the Flowable class</li>
<li>How to use the Observable class</li>
<li>How to use the Single class</li>
<li>How to use the Maybe class</li>
<li>How to use the Completable class</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Flowable</h1>
                
            
            
                
<p>The <kbd>Flowable</kbd> class was introduced in the second version of the RxJava library. This class represents a stream of events, such as Flux from Reactor.</p>
<p>You should consider using <kbd>Flowable</kbd> when you read data from a file, database, or network. The following example code shows how to create and use <kbd>Flowable</kbd>:</p>
<pre>Flowable.fromIterable(listOf(1, 2, 3))<br/>        .subscribe { println(it) }<br/></pre>
<p>This shows how to create an instance of the <kbd>Flowable</kbd> class that emits values.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Observable</h1>
                
            
            
                
<p>The <kbd>Observable</kbd> class is similar to <kbd>Flowable</kbd>, but it can throw a <kbd>MissingBackpressureException</kbd>.</p>
<div><strong>Backpressure</strong> is a case when an observable produces values faster than a subscriber can consume them. In this case, a <kbd>MissingBackpressureException</kbd> is thrown.</div>
<p>An example use case is as follows:</p>
<pre>Observable.fromIterable(listOf(1, 2, 3))<br/>        .subscribe { println(it) }</pre>
<p>The preceding snippet shows how to create an instance of the <kbd>Observable</kbd> class that emits values.</p>
<p>It is worth mentioning that <kbd>Observable</kbd> has lower overhead than <kbd>Flowable</kbd>. You should consider using <kbd>Observable</kbd> when you handle user interface events.</p>
<p>There are operators that can help you to deal with backpressure, such as <em>debounce</em> or <em>throttle</em>. Let's take a look at each one of them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The debounce operator</h1>
                
            
            
                
<p>The <kbd>debounce</kbd> method takes a duration and returns an instance of the <kbd>Observable</kbd> class that only emits a value if a time frame that is equal to the passed time from the moment when the previous value was emitted. The following diagram explains how this works: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ece06aa2-c584-4858-a7bf-cff9f5acff35.png" style="width:38.75em;height:15.25em;"/></p>
<p class="mce-root"/>
<p>The preceding diagram shows how the <kbd>debounce</kbd> method reduces events. The debounce method takes a time frame and returns a new instance of the <kbd>Observable</kbd> type that only emits the last value that was produced during this timeframe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The throttle operator</h1>
                
            
            
                
<p>The <kbd>throttle</kbd> operator returns an instance of the <kbd>Observable</kbd> that only emits one item from the upstream during the sequential time window that has passed. The throttle is a family of methods, such as <kbd>throttleFirst</kbd> or <kbd>throttleLast</kbd>. </p>
<p>The following diagram shows how the <kbd>throttleFirst</kbd> method works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e702ec52-aa91-4f9c-abdf-c139accd427e.png" style="width:28.25em;height:13.50em;"/></p>
<p>The <kbd>throttleLast</kbd> method works as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/91a1c65d-c65a-40a5-afda-80dfc4aad7c7.png" style="width:30.08em;height:14.33em;"/></p>
<p>The preceding diagrams shows that the <kbd>throttleFirst</kbd> and <kbd>throttleLast</kbd> methods can be used to reduce the emitted values.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Single</h1>
                
            
            
                
<p>The <kbd>Single</kbd> class works in a similar way to <kbd>Mono</kbd> from the Reactor library. This can also be used to perform a request to a server. We should consider using <kbd>Flowable</kbd> when a source returns only one item. </p>
<p>The following example code shows how <kbd>Single</kbd> can be used:</p>
<pre>Single.just(1).subscribe(Consumer&lt;Int&gt; { println(it) })</pre>
<p>This snippet contains an instance of the <kbd>Single</kbd> class that emits one value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maybe</h1>
                
            
            
                
<p>An instance of the <kbd>Maybe</kbd> type can emit no value, or a single value. The following example code shows how to use <kbd>Maybe</kbd> and the <kbd>test</kbd> method:</p>
<pre>Maybe.just(1)<br/>        .map { item -&gt; item + 1 }<br/>        .filter { item -&gt; item == 1 }<br/>        .defaultIfEmpty(4)<br/>        .test()<br/>        .assertResult(4)</pre>
<p>The <kbd>test</kbd> method returns an instance of the <kbd>TestObservable</kbd> that is used for testing and contains methods such as <kbd>assertResult</kbd>. The <kbd>defaultIfEmpty</kbd> method of the <kbd>Maybe</kbd> class allows us to specify a default value that can be emitted if an instance of the <kbd>Maybe</kbd> class is empty.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Completable</h1>
                
            
            
                
<p>An instance of the <kbd>Completable</kbd> class doesn't emit a value at all. It can be used to notify the user of task completion. In addition, it can be used when we delete an item from a database, for instance.</p>
<p>The following example code shows a case of deleting an item from a database:</p>
<pre>Completable.fromAction { Database.delete() }<br/>        .test()<br/>        .assertComplete()</pre>
<p>The <kbd>test</kbd> method returns an instance of the <kbd>TestObservable</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RxJava in Android</h1>
                
            
            
                
<p>RxJava is a very popular library for Android development, and there are a lot of other libraries that are based on RxJava, such as RxAndroid and RxBinding.</p>
<p>This section will cover the following topics:</p>
<ul>
<li>The RxAndroid library</li>
<li>The RxBinding library</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The RxAndroid library</h1>
                
            
            
                
<p>The RxAndroid library provides a scheduler that uses the main thread. The following example code shows how to use this scheduler:</p>
<pre>Flowable.fromIterable(listOf(1, 2, 3))<br/>        .subscribeOn(Schedulers.computation())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe { println(it) }</pre>
<p>The preceding snippet shows how to use the <kbd>observeOn</kbd> method to handle emitted values on the main thread.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The RxBinding library</h1>
                
            
            
                
<p>The RxBinding library provides a reactive application programming interface. Let's imagine that we want to observe an input of <kbd>EditText</kbd> and display this text in <kbd>TextView</kbd>.</p>
<p>The RxBinding library provides extension functions for user interface components, such as <kbd>textChanges</kbd>:</p>
<pre>fun TextView.textChanges(): InitialValueObservable&lt;CharSequence&gt; {<br/>    return TextViewTextChangesObservable(this)<br/>}</pre>
<p>We can implement our example by using the <kbd>textChanges</kbd> function, as follows:</p>
<pre>class RxActivity : AppCompatActivity() {<br/><br/>    private val editText by lazy(LazyThreadSafetyMode.NONE) {<br/>        findViewById&lt;EditText&gt;(R.id.editText)<br/>    }<br/><br/>    private val textView by lazy(LazyThreadSafetyMode.NONE) {<br/>        findViewById&lt;TextView&gt;(R.id.textView)<br/>    }<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_rx)<br/>        editText<br/>                .textChanges()<br/>                .subscribe { textView.text = it }<br/><br/>    }<br/>}</pre>
<p>In the preceding snippet, we invoked the <kbd>textChanges</kbd> function and subscribed to a retrieved subscriber. The <kbd>textChanges</kbd> method returns an instance of the <kbd>Observable</kbd> class that emits the text from the input. </p>
<p class="mce-root"/>
<p>The result looks as follows, and shows that the text from the input immediately appears on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f82913ad-fc10-497b-93e3-39d42e582950.png" style="width:32.17em;height:52.33em;"/><br/></p>
<p>The RxBinding library also contains the <kbd>clicks</kbd> extension function, which looks as follows:</p>
<pre>fun View.clicks(): Observable&lt;Unit&gt; {<br/>    return ViewClickObservable(this)<br/>}</pre>
<p>The <kbd>clicks</kbd> extension function returns an instance of the <kbd>ViewClickObservable</kbd> class.</p>
<p>Furthermore, the <kbd>ViewClickObservable</kbd> looks as follows:</p>
<pre>private class ViewClickObservable(<br/>        private val view: View<br/>) : Observable&lt;Unit&gt;() {<br/><br/>    override fun subscribeActual(observer: Observer&lt;in Unit&gt;) {<br/>        if (!checkMainThread(observer)) {<br/>            return<br/>        }<br/>        val observer = Observer(view, observer)<br/>        observer.onSubscribe(observer)<br/>        view.setOnClickListener(observer)<br/>    }<br/>  }</pre>
<p>It uses the <kbd>subscribeActual</kbd> method to pass an instance of the <kbd>Observer</kbd> class to the <kbd>setOnClickListener</kbd> of an instance of the <kbd>View</kbd> class.<br/>
The <kbd>ViewClickObservable</kbd> class inherits from the <kbd>Observable</kbd> class and overrides the <kbd>subscribeActual</kbd> method.<br/>
Finally, the <kbd>Observer</kbd> class looks as follows:</p>
<pre> private class Observer(<br/>            private val view: View,<br/>            private val observer: Observer&lt;in Unit&gt;<br/>    ) : MainThreadDisposable(), OnClickObserver {<br/><br/>       override fun onClick(v: View) {<br/>           if (!isDisposed) {<br/>               observer.onNext(Unit)<br/>           }<br/>       }<br/><br/>       override fun onDispose() {<br/>           view.setOnClickListerner(null)<br/>       }<br/>}</pre>
<p>The preceding snippet invokes the <kbd>onNext</kbd> method when the <kbd>onClick</kbd> method is invoked.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we looked at reactive programming and how it can help us to handle asynchronous events. We also introduced the React and RxJava libraries that provide classes such as <kbd>Mono</kbd>, <kbd>Flux</kbd>, <kbd>Single</kbd>, and <kbd>Observable</kbd>, which follow reactive programming concepts. </p>
<p class="mce-root">Reactive programming allows us to use different thread schedulers to process and transform events with multithreading. The Blocking and Non-Blocking section showed us how to work with thread schedulers. You also learned that reactive programming is based on the Observer pattern. </p>
<p class="mce-root">Modern Android applications handle a lot of different asynchronous events, such as user interactions and push notifications. Learning about Reactive programming is important, because it can help us to better manage our resources through asynchronous processing, allowing us to build more complex applications that are capable of multitasking.</p>
<p class="mce-root">In the next chapter, you will learn how to create the <kbd>Application</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ul>
<li>What is reactive programming?</li>
<li>What is the Mono class?</li>
<li>What is the Observable class?</li>
<li>What is a scheduler?</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>To gain more comprehensive knowledge about applying reactive programming with Reactor, I recommend reading <em>Hands-On Reactive Programming with Reactor</em> (<a href="https://www.packtpub.com/application-development/hands-reactive-programming-reactor">https://www.packtpub.com/application-development/hands-reactive-programming-reactor</a>), by Rahul Sharma.</li>
</ul>


            

            
        
    </body></html>