<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Resource Management and Extending RxKotlin</h1>
                </header>
            
            <article>
                
<p>So far, you've learned about Observables, Flowables, Subjects, processors, operators, combining producers, testing, and many more things. We have gained most of the necessary knowledge to start coding our applications. The only remaining topic to look at is resource management—the technique of creating, accessing, and cleaning up resources. Also if you're one of the developers who is hungry for a challenge, then you'll always look for ways to customize everything. So far in this book, we've seen how to use operators in their prescribed way. We did nothing innovative and didn't try to customize the operators. So, this chapter is dedicated to resource management and extending RxKotlin through custom operators.</p>
<p>The following list contains the topics we will cover in this chapter:</p>
<ul>
<li>Resource management with the <kbd>using</kbd> method</li>
<li>Creating custom operators with the <kbd>lift</kbd> operator</li>
<li>Creating custom transformers (transforming operators) with the <kbd>compose</kbd> operator</li>
</ul>
<p>So, first things first, let's get started with resource management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource management</h1>
                </header>
            
            <article>
                
<p>Resource management, what does it mean? Why should we care about it? If you've a little experience in application development with Java,Kotlin,JavaScript, or any other language, then you're probably familiar with the fact that while developing applications, we often need to access resources, and we must close them when we are done.</p>
<p>If you're not experienced with that phrase, resource management, then let's break things down. We will be starting from the ground by exploring the definition of a resource.</p>
<p>So, what is resource? When developing applications, you may often need to access an API (through an HTTP connection), access a database, read from/write to a file, or you may even need to access any I/O ports/sockets/devices. All these things are considered <strong>resources</strong> in general.</p>
<p>Why do we need to manage/close them? Whenever we are accessing a resource, especially to write, the system often locks it for us, and blocks its access to any other program. If you don't release or close a resource when you're done, system performance may degrade and there may even be a deadlock. Even if the system doesn't lock the resource for us, it will keep it open for us until we release or close it, resulting in poor performance.</p>
<p>So, we must close or release a resource whenever we are done working with it.</p>
<p>Generally, on the JVM, we access resources through a class. Often, that class implements the <kbd>Closable</kbd> interface, making releasing a resource easy for us by calling its <kbd>close</kbd> method. It's quite easy in imperative programming, but you're probably wondering how to do it in reactive programming.</p>
<p>You're probably thinking of mixing imperative programming with reactive programming and making the resources global properties, and then, inside the <kbd>subscribe</kbd> method, you'll dispose them after using. This is basically what we did in <a href="e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml" target="_blank">Chapter 5</a>, <br/>
<em>Asynchronous Data Operators and Transformations</em> HTTP Request.</p>
<p>Sorry to break your heart, but that is the wrong procedure; in <a href="e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml" target="_blank">Chapter 5</a>, <br/>
<em>Asynchronous Data Operators and Transformations</em>, we did it to avoid further complexities in order to make you understand the code better, but we should learn the correct approach now.</p>
<p>To make things less complex, we will create a dummy resource with a custom implementation of the <kbd>Closable</kbd> interface. So, no more suspense; take a look at the following code snippet:</p>
<pre>    class Resource():Closeable { 
      init { 
        println("Resource Created") 
      } 
 
      val data:String = "Hello World" 
 
      override fun close() { 
        println("Resource Closed") 
      } 
    } </pre>
<p>In the preceding code, we created a <kbd>Resource</kbd> class and implemented <kbd>Closeable</kbd> in this class (just to mock a typical Java resource class). We also created a <kbd>val</kbd> property named <kbd>data</kbd> inside that class, which will be used to mock data fetching from <kbd>Resource</kbd>.</p>
<p>Now, how do we use it in a reactive chain? RxKotlin provides a very convenient way to deal with disposable resources. To save your life with disposable resources, RxKotlin has a gift for you—the <kbd>using</kbd> operator.</p>
<p>The <kbd>using</kbd> operator lets you create a resource that'll exist only during the life span of the <kbd>Observable</kbd>, and it will be closed as soon as the <kbd>Observable</kbd> completes.</p>
<p>The following diagram describes the relation of lifespans of <kbd>Observable</kbd> created with the <kbd>using</kbd> operator and the resource attached to it, which has been taken from ReactiveX documentation (<a href="http://reactivex.io/documentation/operators/using.html">http://reactivex.io/documentation/operators/using.html</a>):</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="297" width="475" src="assets/4d3cbc5c-51f8-4262-acc1-774c6ff94963.jpg"/></div>
<p>The preceding image clearly displays that the resource will live during the lifespan of the <kbd>Observable</kbd> only—a perfect life partner, wouldn't you say?</p>
<p>Here is the definition of the <kbd>using</kbd> operator:</p>
<pre>    fun &lt;T, D&gt; using(resourceSupplier: Callable&lt;out D&gt;, sourceSupplier:    <br/>    Function&lt;in D, out ObservableSource&lt;out T&gt;&gt;, <br/>     disposer: Consumer&lt;in D&gt;): Observable&lt;T&gt; { 
       return using(resourceSupplier, sourceSupplier, disposer, true) 
     } </pre>
<p>It looks confusing, but it's easy when we break it down. The <kbd>using</kbd> method accepts a <kbd>Callable</kbd> instance, which will create a resource and return it (<kbd>out D</kbd> is for that purpose). And, the last one is to release/close the resource. The <kbd>using</kbd> operator will call the first lambda before creating the <kbd>Resource</kbd> instance. Then, it'll pass the <kbd>Resource</kbd> instance to the second lambda for you to create <kbd>Observable</kbd> and return it so that you can subscribe. Finally, when the <kbd>Observable</kbd> calls its <kbd>onComplete</kbd> event, it will call the third lambda to close the <kbd>resource</kbd>.</p>
<p>You're now dying to see the example, right? The following is the example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.using({//(1) 
        Resource() 
      },{//(2) 
        resource:Resource-&gt; 
        Observable.just(resource) 
      },{//(3) 
        resource:Resource-&gt; 
        resource.close() 
      }).subscribe { 
        println("Resource Data ${it.data}") 
      } 
    } </pre>
<p>In the preceding program, we passed three lambdas to the <kbd>using</kbd> operator. In the first lambda (comment one), we created an instance of <kbd>Resource</kbd> and returned it (in a lambda, the last statement works as return, you don't have to write it).</p>
<p>The second lambda will take <kbd>resource</kbd> as parameter and will create the <kbd>Observable</kbd> from it to return.</p>
<p>The third lambda will again take <kbd>resource</kbd> as a parameter and close it.</p>
<p>The <kbd>using</kbd> operator will return the <kbd>Observable</kbd> you created in the second lambda for you to apply the RxKotlin chain to it.</p>
<p>So, here is a screenshot of the output, if you're curious:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="108" width="404" src="assets/0b49b1e1-6b76-4526-8040-4f4c838a6f24.jpg"/></div>
<p>So, that is resource management made easy. Also note that you can create and pass as many resources as you want to the <kbd>using</kbd> operator. We implemented the <kbd>Closable</kbd> interface for ease of understanding, but it's not mandatory; you can easily create and pass an array of resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your own operators</h1>
                </header>
            
            <article>
                
<p>So far, we have used lots of operators, but are we sure they will meet all our needs? Or, can we always find a fitting operator for each requirement we face? No, that's not possible. Sometimes, we may have to create our own operators for our own needs, but how?</p>
<p>RxKotlin is always there to make your life easier. It has an operator just for this purpose—the <kbd>lift</kbd> operator. The <kbd>lift</kbd> operator receives an instance of <kbd>ObservableOperator</kbd>; so, to create your own operator, you have to implement that interface.</p>
<p>In my opinion, the best way to learn something is by doing it. What about creating a custom operator that would add a sequential number to every emission? Let's create it as per the following list of requirements:</p>
<ul>
<li>The operator should emit a pair, with an added sequential number as the first element. The second element of the pair should be the actual emission.</li>
<li>The operator should be generic and should work with any type of Observable.</li>
<li>As with other operators, the operator should work concurrently with other operators.</li>
</ul>
<p>The preceding points are our basic requirements; and, as per the preceding requirement, we must use <kbd>AtomicInteger</kbd> for the counter (which will count the emissions, and we will pass that count as a sequential number) so that the operator will work seamlessly with any <kbd>Scheduler</kbd>.</p>
<p>Every custom operator should implement the <kbd>ObservableOperator</kbd> interface, which looks like this:</p>
<pre>    interface ObservableOperator&lt;Downstream, Upstream&gt; { 
      /** 
      * Applies a function to the child Observer and returns a new<br/>       parent Observer. 
      * @param observer the child Observer instance 
      * @return the parent Observer instance 
      * @throws Exception on failure 
      */ 
      @NonNull 
      @Throws(Exception::class) 
      fun apply(@NonNull observer: Observer&lt;in Downstream&gt;): <br/>      Observer&lt;in Upstream&gt;; 
    } </pre>
<p><kbd>Downstream</kbd> and <kbd>Upstream</kbd> are two generic types here. <kbd>Downstream</kbd> specifies the type that will be passed to the Downstream of the operator, and <kbd>Upstream</kbd> specifies the type that the operator will receive from <kbd>upstream</kbd>.</p>
<p>The <kbd>apply</kbd> function has a parameter called the <kbd>Observer</kbd> that should be used to pass the emission to the <kbd>Downstream</kbd>, and the function should return another <kbd>Observer</kbd> that will be used to listen to the <kbd>upstream</kbd> emissions.</p>
<p>Enough theory. The following is the definition of our <kbd>AddSerialNumber</kbd> operator. Take a careful look at it here:</p>
<pre>    class AddSerialNumber&lt;T&gt; : ObservableOperator&lt;Pair&lt;Int,T&gt;,T&gt; { 
      val counter:AtomicInteger = AtomicInteger() 
 
      override fun apply(observer: Observer&lt;in Pair&lt;Int, T&gt;&gt;):<br/>      Observer&lt;in T&gt; { 
        return object : Observer&lt;T&gt; { 
          override fun onComplete() { 
             observer.onComplete() 
          } 
 
          override fun onSubscribe(d: Disposable) { 
              observer.onSubscribe(d) 
          } 
 
          override fun onError(e: Throwable) { 
              observer.onError(e) 
          } 
 
          override fun onNext(t: T) { 
              observer.onNext(Pair(counter.incrementAndGet(),t)) 
          } 
 
         } 
      } 
    } </pre>
<p>Let's start describing this from the very first feature—the definition of the <kbd>AddSerialNumber</kbd> class. This implements the <kbd>ObservableOperator</kbd> interface. As per our requirement, we kept the class generic, that is, we specified the <kbd>Upstream</kbd> type to be generic <kbd>T</kbd>.</p>
<p>We used an <kbd>AtomicInteger</kbd> as a <kbd>val</kbd> property of the class, which should be initialized within the <kbd>init</kbd> block (as we are declaring and defining the property within the class, it would be automatically initialized within <kbd>init</kbd> while creating instances of the class). That <kbd>AtomicInteger</kbd>, <kbd>counter</kbd> should increment on each emission and should return the emitted value as the serial number of the emission.</p>
<p>Inside the <kbd>apply</kbd> method, I created and returned an <kbd>Observer</kbd> instance, which would be used to listen to the <kbd>upstream</kbd> as described earlier. Basically, every operator passes an <kbd>Observer</kbd> to <kbd>upstream</kbd> by which it should receive the events.</p>
<p>Inside that <kbd>observer</kbd>, whenever we receive any event, we echoed that to the <kbd>Observer</kbd> downstream (where it is received as a parameter).</p>
<p>Inside the <kbd>onNext</kbd> event of the <kbd>Upstream</kbd> <kbd>Observer</kbd>, we incremented the <kbd>counter</kbd>, added it as the <kbd>first</kbd> element to a <kbd>Pair</kbd> instance, added the item we received (as a parameter in <kbd>onNext</kbd>) as the <kbd>second</kbd> value, and, finally, passed it to the <kbd>onNext</kbd>—<kbd>observer.onNext(Pair(counter.incrementAndGet(),t))</kbd> downstream.</p>
<p>So, what now? We created a class that can be used as an operator, but how do we use it? It's easy, take a look at this piece of code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(10,20) 
       .lift(AddSerialNumber&lt;Int&gt;()) 
        .subscribeBy ( 
           onNext = { 
             println("Next $it") 
           }, 
           onError = { 
             it.printStackTrace() 
           }, 
           onComplete = { 
             println("Completed") 
           } 
       ) 
    } </pre>
<p>You just have to create an instance of your operator and pass it to the <kbd>lift</kbd> operator; that's all you need, we have now created our first operator.</p>
<p>Look at the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="408" width="369" src="assets/18f26427-7539-420e-abc8-cc68dbfb6c64.jpg"/></div>
<p>We have created our first operator, and, frankly, that was super easy. Yes, it seemed a bit confusing at the start, but as we moved forward, it became easier.</p>
<p>As you may have noticed, the <kbd>ObservableOperator</kbd> interface has only one method, so we can obviously replace the class declaration and everything with just a lambda, as shown here:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      listOf("Reactive","Programming","in","Kotlin",<br/>      "by Rivu Chakraborty","Packt") 
         .toObservable() 
         .lift&lt;Pair&lt;Int,String&gt;&gt; { 
            observer -&gt; 
            val counter = AtomicInteger() 
            object :Observer&lt;String&gt; { 
              override fun onSubscribe(d: Disposable) { 
              observer.onSubscribe(d) 
            } 
 <br/>            override fun onNext(t: String) { 
              observer.onNext(Pair(counter.incrementAndGet(), t)) 
            } 
 
            override fun onComplete() { 
              observer.onComplete() 
            } 
 
            override fun onError(e: Throwable) { 
               observer.onError(e) 
            } 
 
          } 
      } 
      .subscribeBy ( 
         onNext = { 
           println("Next $it") 
         }, 
         onError = { 
           it.printStackTrace() 
         }, 
         onComplete = { 
           println("Completed") 
          } 
            ) 
    } </pre>
<p>In this example, we used a list of <kbd>String</kbd> to create <kbd>Observable</kbd> instead of an <kbd>Int</kbd> range.</p>
<p>The following is the output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="175" width="366" src="assets/6c36b770-b159-4877-b008-1f1e8d7a921a.jpg"/></div>
<p>The program is almost similar to the previous one, except that we used a lambda and used <kbd>Pair&lt;Int,String&gt;</kbd> as the type of downstream <kbd>Observer</kbd>.</p>
<p>As we have gained our grip in creating our custom operators, let's move forward by learning how to create transformers—no, not the autobot like the movie series; they are just RxKotlin transformers. What are they? Let's see.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing operators with transformer</h1>
                </header>
            
            <article>
                
<p>So, you have learned how to create custom operators, but think of a situation when you want to create a new operator by combining multiple operators. For instance, I often wanted to combine the functionality of the <kbd>subscribeOn</kbd> and <kbd>observeOn</kbd> operators so that all the computations can be pushed to computation threads, and, when the results are ready, we can receive them on the main thread.</p>
<p>Yes, it's possible to get the benefits of both operators by adding both operators one after the other to the chain, as shown here:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,10) 
        .map { 
           println("map - ${Thread.currentThread().name} $it") 
           it 
         } 
         .subscribeOn(Schedulers.computation()) 
         .observeOn(Schedulers.io()) 
         .subscribe { 
            println("onNext - ${Thread.currentThread().name} $it") 
         } 
 
        runBlocking { delay(100) } 
     } </pre>
<p>Though you're already aware of the output, the following is the screenshot if you need a refresher:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="388" width="389" src="assets/1fcf1da2-b3cf-4995-8144-ed50a5d6107e.jpg"/></div>
<p>Now, say we have this combination of the <kbd>subscribeOn</kbd> and <kbd>observeOn</kbd> operator throughout our project, so we want a shortcut. We want to create our own operator where we would pass the two <kbd>Scheduler</kbd>'s where we want <kbd>subscribeOn</kbd> and <kbd>observeOn</kbd>, and everything should work perfectly.</p>
<p>RxKotlin provides the <kbd>Transformer</kbd> interfaces (<kbd>ObservableTransformer</kbd> and <kbd>FlowableTransformer</kbd> are two <kbd>Transformer</kbd> interfaces) for that purpose. Just like the <kbd>operator</kbd> interfaces, it has only one method—<kbd>apply</kbd>. The only difference is that here, instead of <kbd>Observers</kbd>, you have the <kbd>Observable</kbd>. So, instead of operating on individual emits and their items, here, you work directly on the source.</p>
<p>Here is the signature of the <kbd>ObservableTransformer</kbd> interface:</p>
<pre>    interface ObservableTransformer&lt;Upstream, Downstream&gt; { 
       /** 
       * Applies a function to the upstream Observable <br/>       and returns an ObservableSource with 
       * optionally different element type. 
       * @param upstream the upstream Observable instance 
       * @return the transformed ObservableSource instance 
       */ 
       @NonNull 
      fun apply(@NonNull upstream: Observable&lt;Upstream&gt;):   <br/>      ObservableSource&lt;Downstream&gt; 
    } </pre>
<p>The interface signature is almost the same. Unlike the <kbd>apply</kbd> method of <kbd>ObservableOperator</kbd>, here, the <kbd>apply</kbd> method receives <kbd>Upstream</kbd> <kbd>Observable</kbd> and should return the <kbd>Observable</kbd> that should be passed to the <kbd>Downstream</kbd>.</p>
<p>So, back to our topic, the following code block should fulfill our requirements:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,10) 
        .map { 
           println("map - ${Thread.currentThread().name} $it") 
           it 
         } 
         .compose(SchedulerManager(Schedulers.computation(), 
             Schedulers.io())) 
             .subscribe { 
               println("onNext - ${Thread.currentThread().name} $it") 
             } 
 
            runBlocking { delay(100) } 
    } 
 
    class SchedulerManager&lt;T&gt;(val subscribeScheduler:Scheduler,<br/>    val   observeScheduler:Scheduler):ObservableTransformer&lt;T,T&gt; { 
      override fun apply(upstream: Observable&lt;T&gt;): <br/>      ObservableSource&lt;T&gt; { 
        return upstream.subscribeOn(subscribeScheduler) 
        .observeOn(observeScheduler) 
      } 
 
    } </pre>
<p>In the preceding code, we created a class for our requirement—<kbd>SchedulerManager</kbd>—that would take two <kbd>Scheduler</kbd> as parameters. The first one is to be passed to the <kbd>subscribeOn</kbd> operator and the second one is for the <kbd>observeOn</kbd> operator.</p>
<p>Inside the <kbd>apply</kbd> method, we returned the <kbd>Observable</kbd> <kbd>Upstream</kbd>, after applying two operators to it.</p>
<p>We are omitting the screenshot of the output, as it is the same as the previous one.</p>
<p>Like the <kbd>lift</kbd> operator, the <kbd>compose</kbd> operator can also be implemented using a lambda. Let's have another example where we will transform an <kbd>Observable&lt;Int&gt;</kbd> to an <kbd>Observable&lt;List&gt;</kbd>. Here is the code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,10) 
        .compose&lt;List&lt;Int&gt;&gt; { 
           upstream: Observable&lt;Int&gt; -&gt; 
           upstream.toList().toObservable() 
         } 
         .first(listOf()) 
         .subscribeBy { 
            println(it) 
         } 
    } </pre>
<p>In the preceding code, we used <kbd>upstream.toList().toObservable()</kbd> as the <kbd>Observable$toList()</kbd> operator converts an <kbd>Observable&lt;T&gt;</kbd> to <kbd>Single&lt;List&lt;T&gt;&gt;</kbd>, so we need the <kbd>toObservable()</kbd> operator to convert it back to <kbd>Observable</kbd>.</p>
<p>Here is the screenshot of the output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="70" width="378" src="assets/8c25986e-9fd2-4eac-81d8-d9f5f2c4fb38.jpg"/></div>
<p>Composing multiple operators to create a new one is also super easy in RxKotlin; just add a bit extension function to it to see how things become more delightful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This was a short chapter about resource management and custom operators in RxKotlin. You learned how you can (or should) create, use, and dispose resources. You learned to create custom operators. You also learned how to compose multiple operators to create your desired one.</p>
<p>This was the last chapter on the fundamentals of RxKotlin. From the next chapter onward, we will start applying our gained knowledge to real-life scenarios and projects.</p>
<p>In today's app-driven era, writing APIs is a primary requirement; in the next chapter, you will start learning Spring in Kotlin so that you can develop your own API for your projects.</p>


            </article>

            
        </section>
    </body></html>