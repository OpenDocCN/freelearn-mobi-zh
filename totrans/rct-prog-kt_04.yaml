- en: Introduction to Backpressure and Flowables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背压和 Flowables 简介
- en: So far, we were trying to understand the push-based architecture of reactive
    programming. By now, we have gained a good understanding of `Observables`. We
    now understand that an `Observable` emits items to be consumed by an `Observer`
    for further processing. However, while going through previous chapters, did you
    ever think of a situation where the `Observable` emits items faster than the `Observer`
    can consume them? This whole chapter is devoted to this problem. We will start
    by trying to understand how and when this problem may occur, and then we will
    try to solve the problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在尝试理解基于推的响应式编程架构。到目前为止，我们已经对 `Observables` 有了一个很好的理解。我们现在明白，`Observable`
    会发出项目供 `Observer` 消费以进行进一步处理。然而，在阅读前面的章节时，你是否曾经想过这样一个情况：`Observable` 发出项目的速度比
    `Observer` 消费它们的速度快？整章都致力于这个问题。我们将首先尝试理解这个问题何时以及如何发生，然后我们将尝试解决这个问题。
- en: 'So, in this chapter, we will focus on the following topics, and by the end
    of the chapter we should have a solution to the problem mentioned earlier:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将重点关注以下主题，并在本章结束时，我们应该有解决前面提到的问题的解决方案：
- en: Understanding backpressure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解背压
- en: Flowables and Subscriber
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flowables 和 Subscriber
- en: Creating Flowables with `Flowable.create()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Flowable.create()` 创建 Flowables
- en: Using Observable and Flowables together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起使用 Observable 和 Flowables
- en: Backpressure operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背压操作符
- en: An `Flowable.generate()` operator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flowable.generate()` 操作符'
- en: So, now, let's start with backpressure—the problem with Observables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从背压——Observables 的问题开始。
- en: Understanding backpressure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解背压
- en: 'The only problem with `Observable` is when an `Observer` cannot cope with the
    pace of an `Observable`. An `Observable`, by default, chains work by pushing items
    synchronously to the `Observer`, one at a time. However, if the `observer` has
    to perform some time-consuming computations, this may take longer than the interval
    of each item emission of `Observable`. Confused? Let''s consider this example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 的唯一问题是当 `Observer` 无法跟上 `Observable` 的节奏时。默认情况下，`Observable` 通过将项目同步推送到
    `Observer`，一次一个，来链式工作。然而，如果 `observer` 必须执行一些耗时的计算，这可能会比 `Observable` 每个项目发射间隔更长。困惑吗？让我们考虑这个例子：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code is quite simple. We created `Observable` on comment `(1)`, then, we
    created `BehaviorSubject`, and then, on comment `(3)` and `(6)`, we `subscribe`
    to `BehaviorSubject`. On comment `(7)`, after subscribing to `BehaviorSubject`,
    we will use `BehaviorSubject` to subscribe to the `Observable` so that `Observers`
    of `BehaviorSubject` should get all the emissions. On comment `(4)`, inside the
    first subscription, we used the `delay` method to simulate a time-taking subscriber.
    There is a new code on comment `(2)` and `(6)`, `subject.observeOn(Schedulers.computation())`;
    we will discuss this method in detail in the later chapters, but, for now, just
    keep in mind that this `observeOn` method helps us specify a thread to run the
    subscription, and `Scheduler.computation()` provides us a with a thread to perform
    computations. On comment `(8)`, we used the `delay` method to wait for the execution,
    as the execution will occur in the background.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。我们在注释 `(1)` 上创建了 `Observable`，然后，我们创建了 `BehaviorSubject`，然后在注释 `(3)`
    和 `(6)` 上，我们订阅了 `BehaviorSubject`。在注释 `(7)` 上，在订阅 `BehaviorSubject` 之后，我们将使用 `BehaviorSubject`
    来订阅 `Observable`，这样 `BehaviorSubject` 的 `Observers` 就应该接收到所有的发射。在注释 `(4)` 的第一个订阅中，我们使用了
    `delay` 方法来模拟一个耗时订阅者。在注释 `(2)` 和 `(6)` 上有新的代码，`subject.observeOn(Schedulers.computation())`；我们将在后面的章节中详细讨论这个方法，但现在，只需记住这个
    `observeOn` 方法帮助我们指定运行订阅的线程，而 `Scheduler.computation()` 提供了一个用于执行计算的线程。在注释 `(8)`
    上，我们使用了 `delay` 方法来等待执行，因为执行将在后台进行。
- en: 'Based on the knowledge we gathered from previous chapters, we can easily say
    that subscriptions should print all the numbers from `1`-`9` in an interleaved
    manner, or shouldn''t they? Let''s see the output first:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们从前面章节中获得的知识，我们可以说订阅应该以交错的方式打印出 `1` 到 `9` 的所有数字，对吗？让我们先看看输出：
- en: '![](img/4ac5b382-cfbb-4287-852b-1563caf72f32.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac5b382-cfbb-4287-852b-1563caf72f32.png)'
- en: Shocked to see the output? Instead of working in an interleaved manner, subscription
    `2` completes printing all the numbers before subscription `1` prints even the
    second number, even though it starts printing first. So, why did it break the
    behavior of `Hot Observables`? Why didn't both the `Observers` work in an interleaved
    manner? Let's inspect. The program actually didn't break the behavior of `Hot
    Observables`, the `subject` actually emitted once for both of the `observers`;
    however, as for the first `observer`, each computation took long, **the emissions
    got queued**; and this is obviously not any good, as this could lead to a lot
    of problems, including the `OutOfMemoryError` exceptions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对输出感到震惊吗？订阅`2`并没有像预期的那样交错工作，它在订阅`1`打印第二个数字之前就已经完成了所有数字的打印，尽管它先开始打印。那么，为什么它打破了`Hot
    Observables`的行为？为什么两个`Observer`没有以交错的方式工作？让我们来检查一下。实际上，程序并没有打破`Hot Observables`的行为，`subject`实际上为两个`observer`各发射了一次；然而，对于第一个`observer`来说，每次计算都很长，**排放被排队**；这显然不是什么好事，因为这可能导致很多问题，包括`OutOfMemoryError`异常。
- en: 'Still have doubts? Let''s look at another example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有疑问？让我们看看另一个例子：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we eliminated the `Subject` and multiple `Subscribers` to make
    the program simpler and easier to understand. We have already introduced the `map`
    operator in the previous chapter that we used on comment `(2)` to convert the
    `Int` items to the `MyItem` object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们消除了`Subject`和多个`Subscribers`，使程序更简单、更容易理解。我们已经在上一章中介绍了`map`操作符，我们使用它来在注释`(2)`中将`Int`项目转换为`MyItem`对象。
- en: If you forgot the `map` operator from the previous chapter, it takes a source
    observable, processes items emitted by them on runtime, and creates another observable
    to observe on. Put simply, the `map` operator sits before subscribe to process
    each item emitted by `observable` before passing the new generated item to `observer`.
    We will also take a closer look at the `map` operator in the later chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了上一章中的`map`操作符，它接受一个源可观察对象，在运行时处理它们发出的项目，并创建另一个可观察对象来观察。简单来说，`map`操作符位于`subscribe`之前，用于在将新生成的项目传递给`observer`之前处理`observable`发出的每个项目。我们将在后面的章节中更详细地了解`map`操作符。
- en: Here, we used it to keep track of each emission. Whenever an emission will occur,
    it will be passed instantly to the `map` operator, where we are creating an object
    of the `MyItem` class. In the `init` block of the `MyItem` class, we are printing
    the value passed to it; so, as soon as an item is emitted, it will be printed
    by the `MyItem` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用它来跟踪每次排放。每当发生排放时，它将立即传递给`map`操作符，在那里我们创建`MyItem`类的对象。在`MyItem`类的`init`块中，我们打印传递给它的值；因此，一旦有项目被排放，它就会被`MyItem`类打印出来。
- en: Here, the `MyItem` class is a `data class`, that is, it will have the getter
    of `val id` and `toString` methods by default.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyItem`类是一个`data class`，即它将默认拥有`val id`和`toString`方法的getter。
- en: 'The remaining part of the program is almost the same; let''s take a look at
    the output, then we will continue to discuss:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的剩余部分几乎相同；让我们看看输出，然后我们继续讨论：
- en: '![](img/e134d6db-0b28-4a7b-8a19-bf392981c0af.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e134d6db-0b28-4a7b-8a19-bf392981c0af.png)'
- en: As we can see in the output, the creation of many `MyItem`, as known as emissions
    was quite fast, and completed even before the `Observer` as known as consumer
    can even start printing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在输出中看到的那样，许多`MyItem`（即排放）的创建非常快，甚至在`Observer`（即消费者）开始打印之前就已经完成了。
- en: So, the problem is that the emissions get queued in the consumer, while the
    consumer is busy processing previous emissions by the producer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是排放被消费者排队，而消费者正忙于处理生产者之前处理的排放。
- en: A solution to this problem could be a feedback channel from consumer to producer,
    through which the consumer can tell the producer to wait until it completes processing
    the previous emission. This way, consumers or messaging middleware will not become
    saturated and unresponsive under high load; instead, they may request fewer messages,
    letting the producer decide how to slow down. This feedback channel is called
    **backpressure**. Backpressure is not supported in `Observables` and `Observers`,
    the solution could be using `Flowables` and `Subscribers` instead. Let's learn
    what those are.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是消费者到生产者的反馈通道，通过这个通道，消费者可以告诉生产者等待它完成处理之前的排放。这样，消费者或消息中间件就不会在高负载下变得饱和和无响应；相反，它们可能会请求更少的消息，让生产者决定如何减速。这个反馈通道被称为**背压**。在`Observables`和`Observers`中不支持背压，解决方案可能是使用`Flowables`和`Subscribers`。让我们学习这些是什么。
- en: Flowable
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flowable
- en: We may call Flowables a backpressured version of Observables. Probably, the
    only difference between Flowables and Observables is that Flowable takes backpressure
    into consideration. Observable does not. That's it. Flowable hosts the default
    buffer size of 128 elements for operators, so, when the consumer is taking time,
    the emitted items may wait in the buffer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Flowables称为Observables的带背压版本。可能Flowables和Observables之间唯一的区别就是Flowable考虑了背压，而Observable没有。就是这样。Flowable为操作符提供了默认的128个元素的缓冲区大小，因此，当消费者花费时间时，发出的项目可能会在缓冲区中等待。
- en: Note that Flowables were added in ReactiveX 2.x (RxKotlin 2.X), and the previous
    versions don't include them. Instead, in previous versions, Observables was retrofitted
    to support backpressure that caused many unexpected `MissingBackpressureException`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Flowables是在ReactiveX 2.x（RxKotlin 2.X）中添加的，而之前的版本不包括它们。相反，在之前的版本中，Observables被修改以支持背压，这导致了许多意外的`MissingBackpressureException`。
- en: 'Here is the release note if you are interested:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对发布说明感兴趣，请看以下内容：
- en: '[https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#observable-and-flowable](https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#observable-and-flowable)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#observable-and-flowable](https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#observable-and-flowable)'
- en: 'We had a long discussion so far; let''s now try our hands on code. At first,
    we will try a code with Observable, and then we will do the same with Flowables
    to see and understand the difference:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进行了长时间的讨论；现在让我们动手写代码。首先，我们将尝试使用Observable的代码，然后我们将使用Flowables来做同样的事情，以观察和理解它们之间的区别：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A simple code with the `Observable.range()` operator, which should emit numbers
    from `1` to `1000`. On comment `(2)`, we used the `map` operator to create the
    `MyItem3` object from `Int`. On comment `(3)`, we subscribed to `Observable`.
    On comment `(4)`, we ran a blocking delay to simulate a long running subscription
    code. On comment `(5)`, we, again, ran a blocking delay code to wait for the consumer
    to complete processing of all items before the program stops execution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的使用`Observable.range()`操作符的代码示例，该操作符应该从`1`到`1000`发出数字。在注释`(2)`中，我们使用了`map`操作符将`Int`转换为`MyItem3`对象。在注释`(3)`中，我们订阅了`Observable`。在注释`(4)`中，我们运行了一个阻塞延迟来模拟长时间运行的订阅代码。在注释`(5)`中，我们再次运行了一个阻塞延迟代码，等待消费者完成所有项目的处理后再停止程序执行。
- en: 'The whole output will take some space, so we will put parts of outputs as screenshots
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 整个输出将占用一些空间，因此我们将部分输出作为截图展示：
- en: '![](img/8f03dbe5-272a-4067-aa5a-6f41a368da45.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f03dbe5-272a-4067-aa5a-6f41a368da45.jpg)'
- en: 'If you take a closer look at the output (screenshots), you will notice that
    the Observable (producer) continued to emit items, though the Observer (consumer)
    was not at all in pace with it. Until the time Observer (producer) finished emitting
    all the Items, the Observer (consumer) processed only the very first item (item
    1). As mentioned earlier, this could lead to a lot of problems, including the
    `OutOfMemory` error. Now, let''s replace `Observable` with `Flowable` in this
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察输出（截图），你会注意到Observable（生产者）继续发出项目，尽管观察者（消费者）根本跟不上它的节奏。直到观察者（生产者）完成所有项目的发出，观察者（消费者）才处理了第一个项目（项目1）。如前所述，这可能导致很多问题，包括`OutOfMemory`错误。现在，让我们将代码中的`Observable`替换为`Flowable`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code is exactly the same as the previous one, just the single difference
    is that we wrote `Flowable.range()` instead of `Observable`. Now, let''s see the
    output and note the difference:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一个完全相同，唯一的区别是我们将`Observable`写成了`Flowable`。现在，让我们看看输出并注意区别：
- en: '![](img/72fa4363-b05c-457c-93c3-05e2f646d968.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72fa4363-b05c-457c-93c3-05e2f646d968.jpg)'
- en: Have you noted the difference? Flowable, instead of emitting all the items,
    emitted few items in a chunk, waited for the consumer to coup up then again continued,
    and completed in an interleaved manner. This reduces a lot of problems itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到区别了吗？Flowable不是一次性发出所有项目，而是分批发出少量项目，等待消费者处理完毕后再继续，并以交错的方式完成。这本身就能减少很多问题。
- en: When to use Flowables and Observables
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Flowables和Observables
- en: By now, you may think Flowable is a handy tool to use, so you could replace
    Observable everywhere. However, this may not always be the case. Although Flowable
    provides us with backpressure strategies, Observables are here for a reason, and
    both of them have their own advantages and disadvantages. So, when to use which?
    Let's see.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能认为Flowable是一个方便的工具，所以你可以在任何地方替换Observable。然而，这并不总是如此。尽管Flowable为我们提供了背压策略，但Observables的存在是有原因的，它们各自都有优势和劣势。那么，何时使用哪一个？让我们看看。
- en: When to use Flowables?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Flowables？
- en: 'The following are the situations when you should consider using Flowables.
    Remember, Flowables are slower than Observables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你应该考虑使用Flowables的情况。记住，Flowables比Observables慢：
- en: Flowables and backpressure are meant to help deal with larger amounts of data.
    So, use flowable if your source may emit 10,000+ items. Especially when the source
    is asynchronous so that the consumer chain may ask the producer to limit/regulate
    emissions when required.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flowables和背压旨在帮助处理大量数据。所以，如果你的源可能排放10,000+项，请使用Flowable。特别是当源是异步的，这样消费者链可以在需要时要求生产者限制/调节排放。
- en: If you are reading from/parsing a file or database.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在读取/解析文件或数据库。
- en: When you want to emit from network IO operations/Streaming APIs that support
    blocking while returning results, which is how many IO sources work.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想从支持阻塞并返回结果的网络IO操作/流式API中发射时，这是许多IO源的工作方式。
- en: When to use Observables?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Observables？
- en: 'Now you know when to use Flowables, take a look at the conditions where you
    should prefer Observables:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了何时使用Flowables，让我们看看你应该优先考虑Observables的条件：
- en: When you are dealing with a smaller amount of data (less than 10,000 emissions)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你处理的数据量较小（少于10,000个排放量）时
- en: When you are performing strictly synchronous operations or operations with limited
    concurrency
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你执行严格同步操作或有限并发操作时
- en: When you are emitting UI events (while working with Android, JavaFX, or Swing)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你正在发射UI事件（在处理Android、JavaFX或Swing时）
- en: Also, keep in mind that Flowables are slower in comparison to Observables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，与Observables相比，Flowables较慢。
- en: Flowable and Subscriber
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式处理和订阅者
- en: Instead of Observer, Flowable uses Subscriber, which is backpressure compatible.
    However, if you use lambda expressions, then you will not notice any differences.
    So, why use Subscriber instead of Observer? Because Subscriber supports some extra
    operations and backpressure. For instance, it can convey how many items it wishes
    to receive as a message to upstream. Or rather, we can say while using Subscriber;
    you must specify how many items you want to receive (request) from upstream; if
    you don't specify it, you will not receive any emissions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于Observer，Flowable使用的是支持背压的Subscriber。然而，如果你使用lambda表达式，那么你将不会注意到任何区别。那么，为什么使用Subscriber而不是Observer呢？因为Subscriber支持一些额外的操作和背压。例如，它可以向上游传达它希望接收多少项作为消息。或者，更确切地说，当我们使用Subscriber时；你必须指定你想要从上游接收（请求）多少项；如果你不指定它，你将不会收到任何排放。
- en: As we already mentioned, using lambda with `Subscriber` is similar to Observe;
    this implementation will automatically request an unbounded number of emissions
    from the upstream. As with our last code, we didn't specify how many emissions
    we want, but it internally requested unbounded number of emissions, and that's
    why we received all the items emitted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用`Subscriber`的lambda表达式与Observe类似；这种实现将自动从上游请求无界数量的排放。就像我们最后的代码一样，我们没有指定我们想要多少排放，但它内部请求了无界数量的排放，这就是为什么我们收到了所有排放的项目。
- en: 'So, let''s try replacing the previous program with a `Subscriber` instance:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试用`Subscriber`实例替换之前的程序：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output of the preceding program will be the same as for the previous one,
    so we are skipping the output here. Instead, let's understand the code. The program
    is almost identical to the previous one, until comment `(3)`, where we created
    an instance of `Subscriber`. The methods of `Subscriber` are identical with `Observer`;
    however, as I mentioned earlier, on the `subscribe` method, you have to request
    for the number of emissions that you want initially. We did the same on comment
    `(4)`; however, as we want to receive all emissions, we requested it with `Long.MAX_VALUE`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序输出的结果将与之前的相同，所以我们在这里省略输出。相反，让我们理解代码。程序几乎与上一个相同，直到注释（3）处，我们创建了一个`Subscriber`实例。`Subscriber`的方法与`Observer`相同；然而，正如我之前提到的，在`subscribe`方法上，你必须请求你想要初始的排放数量。我们在注释（4）处也做了同样的事情；然而，因为我们想要接收所有排放，所以我们用`Long.MAX_VALUE`请求。
- en: So, how does the `request` method work? The `request()` method will request
    the number of emissions the `Subscriber` should listen on from the upstream, counting
    after the method is called. The `Subscriber` will ignore any further emissions
    after the requested emissions until you request for more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`request` 方法是如何工作的？`request()` 方法将请求 `Subscriber` 应该监听的上游发射的数量，从方法调用后开始计数。`Subscriber`
    将忽略请求的发射之后的任何发射，直到你请求更多。
- en: 'So, let''s modify this program to understand the `request` method better:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改这个程序以更好地理解 `request` 方法：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, what are the tweaks we made in this program? Let''s go through it. On comment
    `(1)`, we declared a `lateinit` variable of type `Subscription`, we initialized
    that subscription inside the `onSubscribe` method, just before comment `(2)`.
    On comment `(2)`, we requested for `5` items with `subscription.request(5)`. Then,
    inside `onNext`, on comment `(3)`, we checked if the received item is the `5`^(th)
    one (as we are using a range, the `5`^(th) item''s value will be `5`); if the
    item is the `5`^(th) one, then we are again requesting for `2` more. So, the program
    should print seven items instead of the `1`-`15` range. Let''s check the following
    output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在程序中做了哪些调整？让我们逐个检查。在注释 `(1)` 中，我们声明了一个 `lateinit` 类型的 `Subscription` 变量，并在注释
    `(2)` 之前在 `onSubscribe` 方法中初始化了这个订阅。在注释 `(2)` 中，我们使用 `subscription.request(5)`
    请求了 `5` 个项目。然后，在 `onNext` 中，注释 `(3)`，我们检查接收到的项目是否是第 `5` 个（因为我们使用的是范围，第 `5` 个项目的值将是
    `5`）；如果项目是第 `5` 个，那么我们再次请求 `2` 个。所以，程序应该打印出七个项目，而不是 `1` 到 `15` 的范围。让我们检查以下输出：
- en: '![](img/aca45d47-71bd-43fd-ac4a-74f430a1cfe6.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aca45d47-71bd-43fd-ac4a-74f430a1cfe6.png)'
- en: So, although `Flowable` emitted all the items for the range, it was never passed
    to `Subscriber` after `7`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管 `Flowable` 发射了该范围内的所有项目，但它们在 `7` 之后从未传递给 `Subscriber`。
- en: Note that the `request()` method just not goes all the way upstream, it just
    conveys to the latest preceding operator, which, in turn, decides on whether to/how
    to relay that information to further upstream.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`request()` 方法并不是直接向上游传递，它只是将信息传递给最近的先前的操作符，该操作符随后决定是否以及如何将信息进一步传递到上游。
- en: So, we got some understanding on `Flowable` and `Subscriber`. Now, it's time
    to explore them in depth. We will start with creating a `Flowable` instance from
    scratch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对 `Flowable` 和 `Subscriber` 有了一些了解。现在，是时候深入探索它们了。我们将从从头创建一个 `Flowable`
    实例开始。
- en: Creating Flowable from scratch
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头创建 Flowable
- en: 'We learned about the `Observable.create` method in the previous chapter, but
    to make things less complicated, let''s have a quick recap, and then we can continue
    with `Flowable.create`. Take a look at the following piece of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 `Observable.create` 方法，但为了使事情更简单，让我们快速回顾一下，然后我们可以继续使用 `Flowable.create`。看看以下代码片段：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, in this program, we created `Observable` with the `Observable.create` operator.
    This operator let''s define our own custom `Observable`. We can write our own
    rules to emit items from `Observable`. It provides really great freedom, but the
    problem with `Observable` is here as well. It doesn''t support backpressure. Wouldn''t
    it be great if we could create a similar version with backpressure support? We
    will do it, but let''s see the output first:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们使用 `Observable.create` 操作符创建了 `Observable`。这个操作符允许我们定义自己的自定义 `Observable`。我们可以为
    `Observable` 编写自己的规则来发射项目。它提供了极大的自由度，但 `Observable` 的问题也在这里。它不支持背压。如果我们可以创建一个具有背压支持的类似版本，那岂不是很好？我们将这样做，但让我们先看看输出：
- en: '![](img/b3578992-ead2-4a0c-aa26-51914541504d.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3578992-ead2-4a0c-aa26-51914541504d.jpg)'
- en: 'So, as expected, it prints all the numbers from `1` through `10`. Now, as discussed
    earlier, let''s try with `Flowable`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如预期的那样，它打印了从 `1` 到 `10` 的所有数字。现在，如前所述，让我们尝试使用 `Flowable`：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, on comment `(1)`, we created an instance of `Subscriber`. Then, on comment
    `(2)`, we created an instance of `Flowable` with the `Flowable.create()` method,
    and, on comment `(3)`, we subscribed to it. However, focus on comment `(2)`—along
    with the `lambda`, we also passed another argument to the `Flowable.create` method,
    which is `BackpressureStrategy.BUFFER`. So, what is it? And what purpose does
    `BackpressureStrategy.BUFFER` serve? Let's inspect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在注释 `(1)` 中，我们创建了一个 `Subscriber` 实例。然后，在注释 `(2)` 中，我们使用 `Flowable.create()`
    方法创建了一个 `Flowable` 实例，并在注释 `(3)` 中订阅了它。然而，请注意注释 `(2)`——除了 `lambda` 之外，我们还向 `Flowable.create`
    方法传递了另一个参数，即 `BackpressureStrategy.BUFFER`。那么，这是什么？`BackpressureStrategy.BUFFER`
    有什么作用？让我们检查一下。
- en: '`Flowable.create()` takes two parameters to create an instance of `Flowable`.
    The following is the definition of the `Flowable.create()` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable.create()`接受两个参数来创建一个`Flowable`实例。以下是`Flowable.create()`方法的定义：'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First parameter is the source from where the emissions will generate, and the
    second one is `BackpressureStrategy`; it is an `enum` that helps supporting backpressure
    (it basically helps choosing which strategy to follow for backpressure) by caching/buffering
    or dropping some of the emissions if the downstream can''t keep up. The `enum
    BackpressureStrategy` has five underlying options for different kinds of implementations
    of backpressure. In this example, `BackpressureStrategy.BUFFER` buffers all the
    emissions until they are consumed by the downstream. This, obviously, is not an
    optimal implementation of backpressure and can cause `OutOfMemoryError` while
    handling too many emissions, but, at least it prevents `MissingBackpressureException`
    and can make your custom `Flowable` workable to a small degree. We will learn
    about a more robust way to implement backpressure later in this chapter using
    `Flowable.generate()`; however, for now, let''s know about the options we can
    choose from `BackpressureStrategyenum`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是排放生成的源，第二个参数是`BackpressureStrategy`；它是一个`enum`，通过缓存/缓冲或丢弃一些排放来帮助支持背压（它基本上帮助选择遵循哪种策略进行背压）。`enum
    BackpressureStrategy`有五种底层选项，用于不同类型的背压实现。在这个例子中，`BackpressureStrategy.BUFFER`将所有排放缓冲在无界缓冲区中，直到下游能够消费它们。显然，这不是一个最优的背压实现，在处理大量排放时可能会导致`OutOfMemoryError`，但至少它可以防止`MissingBackpressureException`，并使你的自定义`Flowable`在一定程度上可行。我们将在本章后面使用`Flowable.generate()`学习实现背压的更稳健的方法；然而，现在，让我们了解一下可以从`BackpressureStrategyenum`中选择哪些选项：
- en: '`BackpressureStrategy.MISSING`: This leads to no backpressure implementation
    at all; downstream has to deal with backpressure overflows. This option is helpful
    while using the `onBackpressureXXX()` operator. We will learn this example later
    in this chapter.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackpressureStrategy.MISSING`: 这将导致完全没有背压实现；下游必须处理背压溢出。当使用`onBackpressureXXX()`操作符时，此选项很有帮助。我们将在本章后面学习这个例子。'
- en: '`BackpressureStrategy.ERROR`: This, again, leads to no backpressure implementation
    and signals `MissingBackpressureException` the very moment the downstream cannot
    keep up with the source.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackpressureStrategy.ERROR`: 这同样会导致没有背压实现，并且当下游无法跟上源生时，立即发出`MissingBackpressureException`。'
- en: '`BackpressureStrategy.BUFFER`: This buffers all the emissions in an unbounded
    buffer until the downstream is able to consume them. This can lead to `OutOfMemoryError`
    if there are a lot of emissions to buffer.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackpressureStrategy.BUFFER`: 这将在无界缓冲区中缓冲所有排放，直到下游能够消费它们。如果有很多排放需要缓冲，这可能会导致`OutOfMemoryError`。'
- en: '`BackpressureStrategy.DROP`: This strategy will let you drop all the emissions
    while the downstream is busy and can''t keep up; when the downstream finishes
    the previous operation, it''ll get the very first emission after its finishing
    time, and will miss any emissions in between. For example, say the source is emitting
    five values, `1`, `2`, `3`, `4`, and `5` respectively, the downstream got busy
    after receiving `1` and while the source emitted `2`, `3`, and `4`, it got ready
    just before the source emitted `5`; the downstream will receive `5` only and will
    miss all remaining.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackpressureStrategy.DROP`: 这种策略会在下游忙碌且无法跟上时丢弃所有排放；当下游完成之前的操作后，它将在完成时间后立即获得第一个排放，并错过任何在此之间的排放。例如，假设源生发出五个值，分别是`1`、`2`、`3`、`4`和`5`，下游在接收到`1`后变得忙碌，而源生在发出`2`、`3`和`4`时，下游在源生发出`5`之前刚好准备好；下游只会接收到`5`，并错过所有剩余的排放。'
- en: '`BackpressureStrategy.LATEST`: This strategy will let you drop all the emissions,
    but keeps the latest one while the downstream is busy and can''t keep up; when
    the downstream finishes the previous operation it''ll get the last emission just
    before it finished, and will miss any emissions in between. For example, say the
    source is emitting five values `1`, `2`, `3`, `4`, and `5` respectively, the downstream
    got busy after receiving 1 and while the source emitted `2`, `3`, and `4`, it
    got ready just before the source emitted `5`; the downstream will receive both
    of them (if it didn''t again get busy after receiving `4`, that it can''t receive
    `5`).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackpressureStrategy.LATEST`：这个策略将允许你在下游忙碌且无法跟上时丢弃所有排放，但保留最新的一个；当下游完成之前的操作时，它将获得它完成之前的最后一个排放，并且会错过之间的任何排放。例如，假设源依次发射五个值
    `1`、`2`、`3`、`4` 和 `5`，下游在收到 `1` 后变得忙碌，而此时源发射了 `2`、`3` 和 `4`，下游在源发射 `5` 之前变得准备好；下游将接收这两个值（如果它在收到
    `4` 后没有再次变得忙碌，那么它将无法接收 `5`）。'
- en: Let's implement some of these backpressure strategies as operators while creating
    Flowables from Observables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在从 Observables 创建 Flowables 的过程中实现一些这些背压策略作为操作符。
- en: Creating Flowable from Observable
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Observable 创建 Flowable
- en: 'The `Observable.toFlowable()` operator provides you with another way to implement
    `BackpressureStrategy` into non-backpressured source. This operator turns any
    `Observable` into a `Flowable`, so let''s get our hands dirty, and, first, let''s
    try converting an `Observable` into `Flowable` with the buffering strategy, then
    we will try out a few other strategies in the same example to understand it better.
    Please refer to the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.toFlowable()` 操作符为你提供了另一种将 `BackpressureStrategy` 实现到非背压源的方法。这个操作符将任何
    `Observable` 转换为 `Flowable`，所以让我们动手实践，首先，让我们尝试将一个 `Observable` 转换为使用缓冲策略的 `Flowable`，然后我们将在同一个例子中尝试其他一些策略，以更好地理解它。请参考以下代码：'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, on comment `(1)`, we created an `Observable` with the `Observable.range()`
    method. On comment `(2)`, we converted it to `Flowable` with `BackpressureStrategy.BUFFER`.
    Then, we subscribed to it with a lambda as the `Subscriber`. Let''s see some portions
    of the output as a screenshot (as the complete output will be too long to paste
    here):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在注释 `(1)` 中，我们使用 `Observable.range()` 方法创建了一个 `Observable`。在注释 `(2)` 中，我们使用
    `BackpressureStrategy.BUFFER` 将其转换为 `Flowable`。然后，我们使用 lambda 作为 `Subscriber`
    订阅它。让我们看看输出的一部分作为截图（因为完整的输出太长，无法粘贴在这里）：
- en: '![](img/76e322cc-775e-4395-bfac-e072f3fea9cc.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76e322cc-775e-4395-bfac-e072f3fea9cc.jpg)'
- en: So, as expected, the downstream here processes all the emissions, as the `BackpressureStrategy.BUFFER`
    buffers all the emissions until the downstream consumes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如预期的那样，下游在这里处理了所有的排放，因为 `BackpressureStrategy.BUFFER` 会将所有的排放缓冲到下游消费为止。
- en: 'So, now, let''s try with `BackpressureStrategy.ERROR` and check what happens:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，让我们尝试使用 `BackpressureStrategy.ERROR` 并查看会发生什么：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/0d2e1672-ba50-4507-9990-f8c79e39bd9f.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d2e1672-ba50-4507-9990-f8c79e39bd9f.jpg)'
- en: It showed an error as the downstream couldn't keep up with the upstream, as
    we described it earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了一个错误，因为下游无法跟上上游，正如我们之前所描述的。
- en: 'What would happen if we use the `BackpressureStrategy.DROP` option? Let''s
    check:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `BackpressureStrategy.DROP` 选项会发生什么？让我们检查：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Everything is the same as in the previous example, except, here, we used the
    `BackpressureStrategy.DROP` option. Let''s check the output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都和上一个例子一样，只是这里我们使用了 `BackpressureStrategy.DROP` 选项。让我们检查输出：
- en: '![](img/00d470ae-c820-4628-b4eb-783c975c50d8.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00d470ae-c820-4628-b4eb-783c975c50d8.jpg)'
- en: So, as we can see in the preceding output, `BackpressureStrategy.DROP` stopped
    `Flowable` from emitting after `128`, as the downstream couldn't keep up with,
    just as we described earlier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们可以在前面的输出中看到的那样，`BackpressureStrategy.DROP` 在 `128` 之后停止了 `Flowable` 的排放，因为下游无法跟上，正如我们之前所描述的。
- en: Now, as we have gained some grip on the options available in `BackpressureStrategy`,
    let's focus on the `BackpressureStrategy.MISSING` option and how to use them with
    the `onBackpressureXXX()` operators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对 `BackpressureStrategy` 中可用的选项有了些了解，让我们专注于 `BackpressureStrategy.MISSING`
    选项，以及如何使用 `onBackpressureXXX()` 操作符来使用它们。
- en: BackpressureStrategy.MISSING and onBackpressureXXX()
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BackpressureStrategy.MISSING 和 onBackpressureXXX()
- en: '`BackpressureStrategy.MISSING` implies that it''ll not implement any backpressure
    strategy, so you need to explicitly tell `Flowable` which backpressure strategy
    to follow. The `onBackpressureXXX()` operators help you achieve the same, while
    providing you with some additional configuration options.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackpressureStrategy.MISSING`意味着它不会实现任何背压策略，所以你需要明确告诉`Flowable`要遵循哪种背压策略。`onBackpressureXXX()`操作符可以帮助你实现这一点，同时为你提供一些额外的配置选项。'
- en: 'There are mainly three types of `onBackpressureXXX()` operators available:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的`onBackpressureXXX()`操作符主要有三种类型：
- en: '`onBackpressureBuffer()`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureBuffer()`'
- en: '`onBackpressureDrop()`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureDrop()`'
- en: '`onBackpressureLatest()`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureLatest()`'
- en: Operator onBackpressureBuffer()
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onBackpressureBuffer()`操作符'
- en: This operator serves the purpose of `BackpressureStrategy.BUFFER`; except that
    here, you'll get some extra configuration options, such as buffer size, bounded
    or unbounded, and more. You may omit the configurations as well to use the default
    behavior.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的作用类似于`BackpressureStrategy.BUFFER`；不同之处在于，这里你会得到一些额外的配置选项，例如缓冲区大小、有界或无界等。你也可以省略配置以使用默认行为。
- en: 'So, let''s look at some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看一些例子：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, we are using the previous program with little tweaks. On comment `(1)`,
    we created the `Flowable` instance with the `BackpressureStrategy.MISSING` option.
    On comment `(2)`, to deal with backpressure, we used `onBackpressureBuffer`; the
    output is similar to the one in the `BackpressureStrategy.BUFFER` example, so
    we are omitting this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用之前的程序，但做了一些小的调整。在注释`(1)`中，我们使用`BackpressureStrategy.MISSING`选项创建了`Flowable`实例。在注释`(2)`中，为了处理背压，我们使用了`onBackpressureBuffer`；输出与`BackpressureStrategy.BUFFER`示例中的输出类似，所以我们省略了这一点。
- en: 'You can specify the buffer size by using `onBackpressureBuffer()`. So let''s
    modify the `onBackpressureBuffer()` method call with `onBackpressureBuffer(20)`.
    The following is the output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`onBackpressureBuffer()`来指定缓冲区大小。所以让我们将`onBackpressureBuffer()`方法调用修改为`onBackpressureBuffer(20)`。以下是输出：
- en: '![](img/0cda2981-c206-4f9f-8d0e-aabdc3e0c08d.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cda2981-c206-4f9f-8d0e-aabdc3e0c08d.jpg)'
- en: Yes, that change resulted in an error—the buffer is full. We defined `20` to
    be the buffer size, but `Flowable` needed a lot more size. This could be avoided
    by implementing the `onError` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个更改导致了错误——缓冲区已满。我们定义`20`为缓冲区大小，但`Flowable`需要更多的空间。这可以通过实现`onError`方法来避免。
- en: Operator onBackpressureDrop()
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onBackpressureDrop()`操作符'
- en: Like `onBackpressureBuffer` matches with `BackpressureStrategy.BUFFER`, `onBackpressureDrop`
    matches with `BackpressureStrategy.DROP` in terms of backpressure strategy, with
    some configuration options.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`onBackpressureBuffer`与`BackpressureStrategy.BUFFER`匹配，`onBackpressureDrop`在背压策略方面与`BackpressureStrategy.DROP`匹配，并提供了一些配置选项。
- en: 'So, let''s now try this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一下：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As shown in the previous program, we used `BackpressureStrategy.MISSING` on
    comment `(1)`. On comment `(2)`, we used the `onBackpressureDrop()` operator.
    This operator provides a configuration option to pass a consumer instance, which
    will, in turn, consume the dropped emissions so you can further process it. We
    used this configuration and passed a lambda, which will print the dropped emissions,
    as shown in this screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个程序所示，我们在注释`(1)`中使用了`BackpressureStrategy.MISSING`。在注释`(2)`中，我们使用了`onBackpressureDrop()`操作符。这个操作符提供了一个配置选项来传递一个消费者实例，该实例将消费丢弃的排放，以便你可以进一步处理它。我们使用了这个配置并传递了一个lambda，它将打印丢弃的排放，如截图所示：
- en: '![](img/f97e804e-3a46-44ba-9946-b35e2a3cb8ca.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f97e804e-3a46-44ba-9946-b35e2a3cb8ca.jpg)'
- en: As we can see from the output, `Flowable` dropped emissions after `128` (as
    it has an internal buffer for `128` emissions). The consumer instance of `onBackpressureDrop`
    completed processing even before the `Subscriber` instance started.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`Flowable`在`128`之后丢弃了排放（因为它有一个用于`128`排放的内部缓冲区）。`onBackpressureDrop`的消费者实例在`Subscriber`实例开始之前就完成了处理。
- en: Operator onBackpressureLatest()
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onBackpressureLatest()`操作符'
- en: This operator works exactly the same as the `BackpressureStrategy.LATEST`-it
    drops all the emissions keeping the latest one when the downstream is busy and
    can't keep up. When the downstream finishes the previous operation, it'll get
    the last emission just before it finished. Unfortunately, this doesn't provide
    any configurations; you will probably not need it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的工作方式与`BackpressureStrategy.LATEST`完全相同——当下游忙碌且无法跟上时，它会丢弃所有排放，只保留最新的一个。当下游完成之前的操作后，它将获得它完成之前的最后一个排放。不幸的是，这并不提供任何配置；你可能不需要它。
- en: 'Let''s take a look at this code example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个代码示例：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/24916162-a378-4542-a0c7-1be9b2dbea9a.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24916162-a378-4542-a0c7-1be9b2dbea9a.jpg)'
- en: As we can see, the `Flowable` dropped all emissions after `128`, keeping only
    the last one (`1,000`).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Flowable` 在 `128` 之后丢弃了所有发射，只保留了最后一个（`1,000`）。
- en: Generating Flowable with backpressure at source
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在源头处带有背压的生成Flowable
- en: So far, we have learned to use standard libraries that handle backpressure at
    the downstream. However, is this optimal? Is it always desirable to cache and
    drop emissions whenever the downstream can't keep up? The answer to both questions
    is simply NO. Instead, the better policy would be to backpressure the source at
    the first place.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了使用处理下游背压的标准库。然而，这是否是最优的？是否总是希望在下游无法跟上时缓存和丢弃发射？这两个问题的答案都是简单的“不”。相反，更好的策略是在源头处进行背压。
- en: '`Flowable.generate()` serves the exact same purpose. It''s somewhat similar
    to `Flowable.create()`, but with a little difference. Let''s take a look at an
    example, and then we will try to understand how it works and what are the differences
    between `Flowable.create()` and `Flowable.generate()`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable.generate()` 具有完全相同的目的。它与 `Flowable.create()` 有一些相似之处，但有一些区别。让我们看看一个例子，然后我们将尝试理解它是如何工作的，以及
    `Flowable.create()` 和 `Flowable.generate()` 之间的区别是什么。'
- en: Note that use `Flowable.fromIterable()` as it respects backpressure. So, consider
    using `Flowable.fromIterable()` whenever you can convert your source to an `Iterator`.
    Use `Flowable.generate()` only where you need something more specific, as it is
    way more complex.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `Flowable.fromIterable()`，因为它尊重背压。所以，考虑在可以将源转换为 `Iterator` 的情况下使用 `Flowable.fromIterable()`。仅在你需要更具体的东西时使用
    `Flowable.generate()`，因为它要复杂得多。
- en: 'Consider the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In that program, we created `Flowable` with the `Flowable.generate()` method.
    Unlike `Flowable.create()`, where `Flowable` emits items and `Subscriber` receives/waits
    for/buffers/drops them, `Flowable.generate()` generates items on request and emits
    them. `Flowable.generate()` accepts a lambda to use as the source, which may seem
    similar to `Flowable.create`, and calls it every time you request an item (unlike
    `Flowable.create`). So, for example, if you call the `onComplete` method inside
    the lambda, `Flowable` will emit only once. Also, you can't call `onNext` multiple
    times inside the lambda. If you called `onError`, then you will get an error on
    the very first call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个程序中，我们使用 `Flowable.generate()` 方法创建了 `Flowable`。与 `Flowable.create()` 不同，在
    `Flowable.create()` 中 `Flowable` 发射项目，而 `Subscriber` 接收/等待/缓冲/丢弃它们，`Flowable.generate()`
    在请求时生成项目并发射。`Flowable.generate()` 接受一个 lambda 作为源，这看起来与 `Flowable.create` 类似，并且每次请求项目时都会调用它（与
    `Flowable.create` 不同）。所以，例如，如果你在 lambda 中调用 `onComplete` 方法，`Flowable` 将只发射一次。此外，你无法在
    lambda 中多次调用 `onNext`。如果你调用了 `onError`，那么你将在第一次调用时得到错误。
- en: In this program, we created `object`, `GenerateFlowableItem`, with `var item`;
    the `var item` will automatically increment its value every time you access it
    (using a custom getter). So, the program should work like `Flowable.range(1, Int.MAX_VALUE)`,
    except that once the item reaches `Int.MAX_VALUE` instead of calling `onComplete`,
    it'll again repeat itself, starting from `Int.MIN_VALUE`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了 `object`，`GenerateFlowableItem`，使用 `var item`；每次你访问它时（使用自定义获取器），`var
    item` 将自动增加其值。所以，程序应该像 `Flowable.range(1, Int.MAX_VALUE)` 一样工作，除了当项目达到 `Int.MAX_VALUE`
    时，而不是调用 `onComplete`，它将再次重复，从 `Int.MIN_VALUE` 开始。
- en: In the output (omitted here as it is too large), `Flowable` emitted `128` items
    on the first go, then waited for the downstream to process `96` items, then `Flowable`
    again emitted `128` items, and the cycle continued. Until you unsubscribe from
    `Flowable` or the program execution stops, it will continue emitting items.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出（此处省略，因为它太大）中，`Flowable` 首次发射了 `128` 个项目，然后等待下游处理 `96` 个项目，然后 `Flowable`
    再次发射了 `128` 个项目，循环继续。直到你从 `Flowable` 取消订阅或程序执行停止，它将继续发射项目。
- en: ConnectableFlowable
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可连接的Flowable
- en: So far, in this chapter, we've dealt with `Cold Observables`. What if we want
    to deal with hot source? Every type of Observable has their counterpart in Flowable.
    In the previous chapter, we started hot source with `ConnectableObservable`, so
    let's start with `ConnectableFlowable`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们处理了 `Cold Observables`。如果我们想处理热源怎么办？每种类型的 Observable 在 Flowable
    中都有对应的类型。在前一章中，我们使用 `ConnectableObservable` 开始了热源，所以让我们从 `ConnectableFlowable`
    开始。
- en: 'As with Observable, `ConnectableFlowable` resembles an ordinary Flowable, except
    that it does not begin emitting items when it is subscribed, but only when its
    `connect()` method is called. In this way, you can wait for all intended `Subscribers`
    to `Flowable.subscribe()`, before `Flowable` begins emitting items. Please refer
    to the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Observable`类似，`ConnectableFlowable`类似于普通`Flowable`，不同之处在于它不是在订阅时开始发出项目，而是在其`connect()`方法被调用时才发出。这样，你可以在`Flowable`开始发出项目之前等待所有预期的`Subscribers`调用`Flowable.subscribe()`。请参考以下代码：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We tweaked the first example of `ConnectableObservable` from the previous chapter.
    As with `Observable`, you can use the `Iterable<T>.toFlowable()` extension function
    in the place of `Flowable.fromIterable()`. `Flowable.publish()` turns an ordinary
    `Flowable` into a `ConnectableFlowable`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对上一章中`ConnectableObservable`的第一个例子进行了调整。与`Observable`一样，你可以在`Flowable.fromIterable()`的位置使用`Iterable<T>.toFlowable()`扩展函数。`Flowable.publish()`将普通`Flowable`转换为`ConnectableFlowable`。
- en: In this example, on comment `(1)`, we used the `Iterable<T>.toFlowable()` extension
    function to create `Flowable` from `List`, and on comment `(2)`, we used the `Flowable.publish()`
    operator to create `ConnectableFlowable` from `Flowable`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在注释（1）处，我们使用`Iterable<T>.toFlowable()`扩展函数从`List`创建`Flowable`，在注释（2）处，我们使用`Flowable.publish()`运算符从`Flowable`创建`ConnectableFlowable`。
- en: 'The following is the output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![](img/dcd29fcc-c333-4ed8-8ce5-3c680797db81.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcd29fcc-c333-4ed8-8ce5-3c680797db81.png)'
- en: As we used `Flowable.fromIterable` (`Iterable<T>.toFlowable()` calls `Flowable.fromIterable`
    internally), which respects backpressure at the source, we can see `Flowable`
    waited for all the downstream to complete processing, then emitted the next item
    so that the downstreams can work in an interleaved manner.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`Flowable.fromIterable`（`Iterable<T>.toFlowable()`内部调用`Flowable.fromIterable`），它尊重源头的背压，因此我们可以看到`Flowable`等待所有下游完成处理，然后发出下一个项目，这样下游可以以交错的方式工作。
- en: By now, you may have been thinking of `Subjects`. It is a great tool, but, like
    `Observable`, `Subjects` also lack backpressure support. So, what is the counterpart
    for `Subjects` in Flowable?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经在想`Subjects`了。这是一个很好的工具，但与`Observable`一样，`Subjects`也缺乏背压支持。那么，Flowable中`Subjects`的对立面是什么？
- en: Processor
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: Processors are the counterparts for `Subjects` in Flowable. Every type of `Subject`
    has its counterpart as processor with backpressure support.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是Flowable中`Subjects`的对立面。每种类型的`Subject`都有一个对应的处理器，并支持背压。
- en: In the previous chapter ([Chapter 3](135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml), *Observables,
    Observers, and Subjects*), we started exploring `Subject`, with the `PublishSubject`;
    so, let's do the same here. Let's get started with `PublishProcessor`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（[第3章](135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml)，*Observables, Observers,
    and Subjects*），我们开始探索`Subject`，使用`PublishSubject`；因此，让我们在这里也这样做。让我们从`PublishProcessor`开始。
- en: 'The following is an example of `PublishProcessor`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`PublishProcessor`的示例：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, in this example, on comment `(1)`, we created a `Flowable` with the `Iterable<T>.toFlowable()`
    method. On comment `(2)`, we created a `processor` instance with the `PublishProcessor.create()`
    method. On comment `(3)` and `(4)`, we subscribed to the `processor` instance,
    and, on comment `(5)`. we subscribed to the `Flowable` with the `processor` instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，在注释（1）处，我们使用`Iterable<T>.toFlowable()`方法创建了一个`Flowable`。在注释（2）处，我们使用`PublishProcessor.create()`方法创建了一个`processor`实例。在注释（3）和（4）处，我们订阅了`processor`实例，在注释（5）处，我们使用`processor`实例订阅了`Flowable`。
- en: 'The following is the output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![](img/d71c8b78-b195-42c4-b863-7a6a22243b94.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d71c8b78-b195-42c4-b863-7a6a22243b94.jpg)'
- en: The `processor` is waiting for all its `Subscribers` to complete before pushing
    the next emission.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`processor`在推送下一个发射之前正在等待所有其`Subscribers`完成。'
- en: Learning Buffer, Throttle, and Window operators
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Buffer、Throttle和Window运算符
- en: So far, we have learned about backpressure. We slowed down the source, dropped
    items, or used buffer, which will hold items until the consumer consumes it; however,
    will all these suffice? While handling backpressure at the downstream is not a
    good solution always, we cannot always slow down the source as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了背压。我们减缓了源头的速度，丢弃了项目，或者使用了缓冲区，它将持有项目直到消费者消费它；然而，这些是否足够？在下游处理背压并不是总是好的解决方案，我们也不能总是减缓源头。
- en: While using `Observable.interval`/`Flowable.interval`, you cannot slow down
    the source. A stop gap could be some operators that would somehow allow us to
    process the emissions simultaneously.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Observable.interval`/`Flowable.interval` 时，你不能减慢源的速度。一个临时的解决方案可能是某些操作符，它们可以以某种方式允许我们同时处理发射。
- en: 'There are the three operators that could help us in that way:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个操作符可以帮助我们实现这一点：
- en: '`Buffer`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buffer`'
- en: '`Throttle`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Throttle`'
- en: '`Window`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Window`'
- en: The buffer() operator
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`buffer()` 操作符'
- en: Unlike the `onBackPressureBuffer()` operator, which buffers emissions until
    the consumer consumes, the `buffer()` operator will gather emissions as a batch
    and will emit them as a list or any other collection type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `onBackPressureBuffer()` 操作符不同，后者缓冲发射直到消费者消费，`buffer()` 操作符将收集发射并将它们作为一批发射，作为列表或其他任何集合类型。
- en: 'So, let''s look at this example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看这个例子：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On comment `(1)`, we created a `Flowable` instance with the `Flowable.range()`
    method, which emits integers from `1` to `111`. On comment `(2)`, we used the
    `buffer` operator with `10` as the buffer size, so the `buffer` operator gathers
    `10` items from the `Flowable` and emits them as a list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 上，我们使用 `Flowable.range()` 方法创建了一个 `Flowable` 实例，它发射从 `1` 到 `111` 的整数。在注释
    `(2)` 上，我们使用了带有缓冲区大小 `10` 的 `buffer` 操作符，因此 `buffer` 操作符从 `Flowable` 中收集 `10`
    项并将它们作为列表发射。
- en: 'The following is the output, which satisfies the understanding:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果，它满足了理解的需求：
- en: '![](img/bc9ec64a-71c6-4d5f-9485-400fd44bd238.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc9ec64a-71c6-4d5f-9485-400fd44bd238.png)'
- en: The `buffer` operator has quite good configuration options, such as the `skip`
    parameter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer` 操作符有相当好的配置选项，例如 `skip` 参数。'
- en: It accepts a second integer parameter as the `skip` count. It works in a really
    interesting way. If the value of the `skip` parameter is exactly the same as the
    `count` parameter, then it will do nothing. Otherwise, it will first calculate
    the positive difference between the `count` and `skip` parameters as `actual_numbers_to_skip`,
    and, then, if the value of the `skip` parameter is greater than the value of the
    `count` parameter, it will skip the `actual_numbers_to_skip` items after the last
    item of each emission. Otherwise, if the value of the `count` parameter is greater
    than the value of the `skip` parameter, you'll get rolling buffers, that is, instead
    of skipping the items, it will skip the counts from the previous emissions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个整数参数作为 `skip` 计数。它以一种非常有趣的方式工作。如果 `skip` 参数的值与 `count` 参数的值完全相同，那么它将不执行任何操作。否则，它将首先计算
    `count` 和 `skip` 参数之间的正差值作为 `actual_numbers_to_skip`，然后，如果 `skip` 参数的值大于 `count`
    参数的值，它将在每个发射的最后一项之后跳过 `actual_numbers_to_skip` 项。否则，如果 `count` 参数的值大于 `skip` 参数的值，你将得到滚动缓冲区，也就是说，不是跳过项，而是跳过之前发射的计数。
- en: 'Confused? Let''s look at this example to clear things up:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我们看看这个例子来澄清：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On comment `(1)`, we used buffer with count `10`, skip `15`, for the first
    subscription. On comment `(2)`, we used it as `count 15`, `skip 8`, for the second
    subscription. The following is the output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 上，我们使用了带有计数 `10`、跳过 `15` 的 `buffer`。在注释 `(2)` 上，我们将其用作第二次订阅的 `count
    15`、`skip 8`。以下为输出结果：
- en: '![](img/555b2f1d-2c34-47aa-b7fa-b29f10d1631b.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/555b2f1d-2c34-47aa-b7fa-b29f10d1631b.png)'
- en: For the first subscription, it skipped `5` items after each subscription (`15`-`10`).
    However, for the second one, it repeated items from the `8`^(th) item in each
    emission (`15`-`7`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次订阅，它在每次订阅后跳过了 `5` 项（`15`-`10`）。然而，对于第二次订阅，它从每个发射的 `8`^(th) 项开始重复项（`15`-`7`）。
- en: 'If the preceding uses of the `buffer` operator were not enough for you, then
    let me tell you the `buffer` operator also lets you do time-based buffering. Put
    simply, it can gather emissions from a source and emit them at a time interval.
    Interesting right? Let''s explore it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面使用的 `buffer` 操作符不足以满足你的需求，那么让我告诉你，`buffer` 操作符还允许你进行基于时间的缓冲。简单来说，它可以收集来自源的发射并在时间间隔内发射。有趣吧？让我们来探索一下：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To understand things better, we used `Flowable.interval` in this example to
    create a `Flowable` instance on comment `(1)`. On comment `(2)`, we used the `buffer(timespan:Long,
    unit:TimeUnit)` overload to instruct the operator to buffer all emissions for
    a second and emit them as a list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们在本例中使用了 `Flowable.interval` 来创建一个在注释 `(1)` 上的 `Flowable` 实例。在注释 `(2)`
    上，我们使用了 `buffer(timespan:Long, unit:TimeUnit)` 重载来指示操作符缓冲所有发射并在一秒后将它们作为列表发射。
- en: 'This is the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![](img/a2c36cf3-831d-4050-8c67-f7ebd8393791.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2c36cf3-831d-4050-8c67-f7ebd8393791.png)'
- en: As you can see in the example, each of the emissions contains `10` items as `Flowable.interval()`
    is emitting one each `100` milliseconds and `buffer` is gathering emissions within
    a second timeframe (1 second = 1000 milliseconds, emission with a 100 milliseconds
    interval would result in 10 emissions in one second).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例中看到的，每次排放都包含 `10` 个项目，因为 `Flowable.interval()` 每 `100` 毫秒发射一个，而 `buffer`
    在一秒的时间框架内收集排放（1 秒 = 1000 毫秒，100 毫秒间隔的排放会在一秒内产生 10 次排放）。
- en: Another exciting feature of the buffer operator is that it can take another
    producer as the boundary, that is, the `buffer` operator will gather all the emissions
    of the source producer between two emissions of the boundary producer, and will
    emit the list on each boundary producer's emission.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲操作符的另一个令人兴奋的特性是它可以接受另一个生产者作为边界，也就是说，`buffer` 操作符将收集源生产者在边界生产者两次排放之间的所有排放，并在每个边界生产者的排放时发出列表。
- en: 'Here is an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the following is the output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是输出结果：
- en: '![](img/9ce6ae07-a8ca-4e01-af81-c1f7aecbcbb8.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ce6ae07-a8ca-4e01-af81-c1f7aecbcbb8.png)'
- en: The `buffer` operator emits a gathered list whenever `boundaryFlowable` emits.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer` 操作符在 `boundaryFlowable` 发射时发出一个收集到的列表。'
- en: The window() operator
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`window()` 操作符'
- en: The `window()` operator works almost the same, except that, instead of buffering
    items in a `Collection` object, it buffers items in another producer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`window()` 操作符几乎以相同的方式工作，除了它不是在 `Collection` 对象中缓冲项目，而是在另一个生产者中缓冲项目。'
- en: 'Here is an example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s first see the output, as shown here, before we try to understand it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试理解它之前，让我们先看看输出结果，如下所示：
- en: '![](img/4f3538c8-9afa-4578-9f38-8b8cc88388b2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f3538c8-9afa-4578-9f38-8b8cc88388b2.png)'
- en: The `window` operator buffers `10` emissions in a new `Flowable` instance, which
    we will again subscribe to inside the `flowable.subscribe` lambda, and print them
    with a comma as a suffix.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`window` 操作符在一个新的 `Flowable` 实例中缓冲 `10` 次排放，我们将在 `flowable.subscribe` lambda
    中再次订阅它，并以逗号作为后缀打印它们。'
- en: The `window` operator also has same functionality as the other overloads of
    the `buffer` operator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`window` 操作符也具有与 `buffer` 操作符的其他重载相同的函数功能。'
- en: The throttle() operators
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`throttle()` 操作符'
- en: 'The `buffer()` and `window()` operators gather emissions. The `throttle` operators
    omit emissions. We will discuss it in greater detail in the later chapters, but
    we will take a look at it right now:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()` 和 `window()` 操作符收集排放。`throttle` 操作符省略排放。我们将在后面的章节中更详细地讨论它，但现在我们先看看：'
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![](img/6b13b98b-d740-4457-8bdd-6a09f049b4ae.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b13b98b-d740-4457-8bdd-6a09f049b4ae.png)'
- en: The `throttleFirst` skips the first emissions in every `200` milliseconds.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleFirst` 跳过了每 `200` 毫秒内的第一次排放。'
- en: There are `throttleLast` and `throttleWithTimeout` operators as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有 `throttleLast` 和 `throttleWithTimeout` 操作符。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about backpressure. We learned how to support backpressure
    and Flowables as well as `processors`. We also learned how to support backpressure
    from consumers and producers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了背压。我们学习了如何支持背压以及 `Flowables` 和 `processors`。我们还学习了如何从消费者和生产者那里支持背压。
- en: Although we gained some grip on producers while working on real-time projects,
    we need to do asynchronous operations. In the next chapter, we will focus on the
    same. We will learn about asynchronous data operations, and we will learn more
    about the `map` operator, which we are already using.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在处理实时项目时对生产者有了更多的了解，但我们还需要进行异步操作。在下一章中，我们将专注于同样的事情。我们将学习异步数据操作，并且我们将更多地了解我们已经在使用的
    `map` 操作符。
- en: Curious? Turn to [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml), *Asynchronous
    Data Operators and Transformations* right now.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇吗？现在就翻到 [第五章](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml)，*异步数据操作符和转换*。
