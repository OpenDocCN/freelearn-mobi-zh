- en: Implementing the Place Reviewer Frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we continued our exploration of Kotlin as a viable
    language for the creation of web applications by commencing the building of the
    Place Reviewer website. We began the chapter by discussing the Model-View-Controller
    design pattern and taking a high-level look at the primary components at play
    in MVC applications: the model, the view, and the controller. Once we had a clear
    understanding of the MVC design pattern and how it works, we commenced with the
    design and implementations of the backend for the *Place Reviewer* application.'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we identified and clearly stated the anticipated use cases
    for our application. Next, we identified the data required to build an application
    that facilitates the use cases identified. After identification of the data to
    be catered for, we went full steam ahead with the development of the backend.
    We set up a Postgres database with which our application will communicate, then
    implemented the necessary entities and models for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Further into the chapter, we discovered how to secure our application—authentication-wise—with
    Spring Security, this time without the use of JWTs. Finally, we learned how to
    create controllers for Spring MVC-based applications, as well as how to manage
    server logs with the ELK stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall finish up the creation of the *Place Reviewer* application
    by implementing its frontend. In the process of doing this, we shall learn about
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Google Places API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying web applications to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get straight into this chapter by implementing the views for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating views with Thymeleaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously defined, a view is a representation of data that exists in and
    is generated by an application. Views are the primary points of interaction that
    a user has with an application built with the MVC pattern. The view layer may
    utilize different technologies to render information to a user. Spring supports
    a number of view options. These view options are also referred to as templates.
    Template support in a Spring application is provided by a template engine. Simply
    put, a template engine enables the utilization of static template files with the
    view layer of an application. A template engine may also be referred to as a template
    library. The following template libraries are available for use with Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: Thymeleaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP/JSTL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freemaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This list is by no means intended to be exhaustive. There are a number of other
    template libraries available for use with Spring. We shall be relying on Thymeleaf
    to provide template processing support for our application. If you recall, we
    included templating support with Thymeleaf upon initial creation of our project.
    Inspecting the dependencies section of our project''s `pom.xml` file will reveal
    the addition of Thymeleaf to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At this juncture, you may desire a more formal definition of what exactly Thymeleaf
    is. As stated on Thymeleaf's official website, *Thymeleaf is a modern server-side
    Java template engine for both web and standalone environments. Thymeleaf's main
    goal is to bring elegant natural templates to your development workflow - HTML
    that can be correctly displayed in browsers and also work as static prototypes,
    allowing for stronger collaboration in development teams.* If you require a deeper
    understanding of Thymeleaf and its goals, you can find more information about
    it at [http://thymeleaf.org](http://thymeleaf.org).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we took a simple example of view creation in Spring
    by implementing a `hello.html` view for the `HelloController`. However, the view
    we created only displayed a `Hello world!` message to its viewers. We will be
    creating slightly more complex views in this chapter. We shall start by creating
    a view facilitating user registration on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user registration view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to accomplish two tasks. Firstly, we are going
    to create a view layer that facilitates the registration of new users on the Place
    Reviewer platform. Secondly, we are going to create suitable controllers and actions
    to present the user with the registration view and handle registration form submissions.
    Simple enough right? Glad you think so! Go ahead and create a `register.html`
    template in the `Place Reviewer` project. Recall that all template files belong
    in the templates directory under resources. Now, add the following template HTML
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we utilized HTML to create a template for the user registration
    page. The web page in itself is simple. It contains a navigation bar and a form
    in which a user will input the required registration details for submission. As
    this is a Thymeleaf template, it should come as no surprise that we utilized some
    Thymeleaf-specific attributes. Let''s take a look at some of these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`th:href`: This is an attribute modifier attribute. When it is processed by
    the templating engine, it computes the link URL to be utilized and sets it in
    the appropriate tag in which it is used. Examples of tags that this attribute
    can be used in are `<a>` and `<link>`. We used the `th:href` attribute in the
    code snippet, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`th:action`: This attribute works just like the HTML action attribute. It specifies
    where to send the form data when a form is submitted. The following code snippet
    specifies that the form data should be sent to an endpoint with the path `/users/registrations`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`th:text`: This attribute is used to specify the text held by a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`th:if`: This attribute can be used to specify whether an HTML tag should be
    rendered based on the result of a conditional test:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, if a model attribute error exists and its value is not
    equal to null, then the `span` tag is rendered on the HTML page; otherwise, it
    is not rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also made use of `th:if` in our navigation bar to specify when it should
    display a button permitting a user to log out of their account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the `principal` model attribute is set in the template and it is not `null`,
    then the sign out button is displayed. The `principal` will always be null unless
    the user is logged in to their account.
  prefs: []
  type: TYPE_NORMAL
- en: How we added the navigation bar to our template directly may appear to be all
    right at first glance but it is important we put more thought into what we did.
    It is not uncommon to make use of a navigation bar DOM element more than once
    within an application. In fact, this is done very often! We do not want to have
    to keep rewriting this same code for a navigation bar over and over again in our
    templates. To avoid this unnecessary repetition, we need to implement the navigation
    bar as a fragment that can be included at any time within a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `fragments` directory within `templates` and add a `navbar.html` file
    with the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we defined a navigation bar fragment available for inclusion
    in templates with the `th:fragment` attribute. A defined fragment can be inserted
    at any time within a template with the use of `th:insert`. Modify the inner HTML
    of the `<body>` tag in `register.html` to make use of the newly defined fragment
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As can already be seen, the separation of our navigation bar HTML into a fragment
    has made our code more succinct and will contribute positively to the quality
    of our developed templates.
  prefs: []
  type: TYPE_NORMAL
- en: Having created the necessary template for the user registration page, we need
    to create a controller that will render this template to a visitor of the site.
    Let's create an application controller. Its job will be to render the web pages
    of the *Place Reviewer* application to a user upon request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ApplicationController` class, shown here, to the controller package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special is being done in the code snippet here. We created an MVC controller
    with a single action that handles a HTTP `GET` request to the `/register` path
    by rendering the `register.html` view to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost ready to view our newly created registration page. Before we
    check it out, we must add the `app.css` file required by `register.html`. Static
    resources such as CSS files should be added to the `static` directory within the
    application `resource` directory. Add a `css` directory within the `static` directory
    and add an `app.css` file containing the code shown here to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Great work! Now, go ahead and run the *Place Reviewer* application. Upon starting
    the app, open your favorite browser and access the web page residing at `http://localhost:5000/register`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must implement the logic involved in registering the user. To do this,
    we must declare an action that accepts the form data sent by the registration
    form and appropriately processes the data, with the goal of registering the user
    successfully on the platform. If you recall, we specified that the form data should
    be sent via `POST` to `/users/registrations`. Consequently, we need an action
    that handles such a HTTP request. Add a `UserController` class to the `com.example.placereviewer.controller`
    package with the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`create()` handles HTTP `POST` requests sent to `/users/registrations`. It
    takes three arguments. The first is form, which is an object of the `User` class.
    `@ModelAttribute` is used to annotate `form`. `@ModelAttribute` indicates that
    the argument should be retrieved by the model. The form model attribute is populated
    by data submitted by the form to the endpoint. The `username`, `email`, and `password`
    parameters are all submitted by the registration form. All objects of type `User`
    have `username`, `email`, and `password` properties, hence the data submitted
    by the form is assigned to the corresponding model properties.'
  prefs: []
  type: TYPE_NORMAL
- en: The second argument of the function is an instance of `BindingResult`. `BindingResult`
    serves as a result holder for `DataBinder`. In this case, we used it to bind results
    of the validation process done by a `UserValidator`, which we are going to create
    in a bit. The third argument is a `Model`. We use this to add attributes to our
    model for subsequent access by the view layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding further with explanations pertaining to the logic implemented
    in the `create()` action, we must implement both `UserValidator` and `SecurityService`.
    `UserValidator` has the sole task of validating user information submitted to
    the backend. Create a `com.example.placereviewer.component` package and include
    the `UserValidator` class here to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Validating that submitted user parameters are not empty. An empty parameter
    is rejected with an error code and error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Validating the length of a submitted username. A username whose length is less
    than 6 is rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Validating the submitted username does not already exist. A username already
    taken by a user is rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Validating the length of a submitted password. Passwords less than 8 characters
    in length are rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`UserValidator` implements the `Validator` interface, which is used to validate
    objects. As such, it overrides two methods: `supports(Class<*>?)` and `validate(Any?,
    Errors)`. `supports()` is used to assert that the validator can validate the object
    supplied to it. In the case of `UserValidator`, `supports()` asserts that the
    supplied object is an instance of the `User` class. Hence, all objects of type
    `User` are supported for validation by `UserValidator`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate()` validates the provided objects. In cases where validation rejections
    occur, it registers the error with the provided `Error` object. Ensure you read
    through the comments placed within the body of the `validate()` method to get
    a better grasp of what is going on within the method.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we shall work on `SecurityService`. We will implement a `SecurityService`
    to facilitate the identification of the currently logged in user and the automatic
    login of a user after their registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `SecurityService` interface here to `com.example.placereviewer.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a `SecurityServiceImpl` class to `com.example.placereviewer.service`.
    As the name suggests, `SecurityServiceImpl` implements `SecurityService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`findLoggedInUser()` returns the username of the currently logged in user.
    `Username` retrieval is done with the help of Spring Framework''s `SecurityContextHolder`
    class. An instance of `UserDetails` is retrieved by accessing the logged in user''s
    authentication details with a call to `SecurityContextHolder.getContext().authentication.details`.
    It is important to note that `SecurityContextHolder.getContext().authentication.details`
    returns an `Object` and not an instance of `UserDetails`. As such, we must do
    a type check to assert that the object retrieved conforms to the type `UserDetails`
    as well. If it does, we return the username of the currently logged in user. Otherwise,
    we return null.'
  prefs: []
  type: TYPE_NORMAL
- en: The `autoLogin()` method will be used for the simple task of authenticating
    a user after registering on the platform. The submitted username and password
    of the user are passed as arguments to `autoLogin()`, after which an instance
    of `UsernamePasswordAuthenticationToken` is created for the registered user. Once
    an instance of `UsernamePasswordAuthenticationToken` is created, we utilize `AuthenticationManager`
    to authenticate the user's token. If `UsernamePasswordAuthenticationToken` is
    successfully authenticated, we set the authentication property of the current
    user to `UsernamePasswordAuthenticationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having made our necessary class additions, let''s return to our `UserController`
    to finish up our explanation of the create action. Within `create()`, first and
    foremost the submitted form input is validated with an instance of `UserValidator`.
    Errors arising during the course of form data validation are all bound to the
    instance of `BindingResult` injected into our controller by Spring. Consider these
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`bindingResult` is first checked to assert whether any errors occurred during
    form data validation. If errors occurred, we retrieve the message of the first
    error detected and set a `model` attribute error to hold the error message for
    later access by the view. In addition, we create `model` attributes to hold each
    input submitted by the user. Lastly, we re-render the registration view to the
    user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we made multiple method invocations for the same `Model` instance
    in the previous code snippet. There is a much cleaner way we can do this. This
    involves the use of Kotlin''s `with` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See how easy and convenient the function is to use? Go ahead and modify `UserController`
    to make use of `with`, as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we decided to store a user's submitted data in model
    attributes. We did this to have a way to reset the data contained in the registration
    form to what was originally submitted after the re-rendering of the registration
    view. It will certainly be frustrating for a user to have to input all form data
    over and over, even if only one form input entered is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'When no input submitted by the user is invalid, the following code runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, when the data submitted by a user is valid, he is registered on
    the platform and logged in to his account automatically. Lastly, he is redirected
    to his home page. Before we try out our registration form, we must do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilize the model attributes specified in `register.html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `home.html` template and a controller to render the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luckily for us, both are rather simple to do. First, to utilize the `model`
    attributes. Modify the form contained in `register.html` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you spot the changes we made? If you said we used Thymeleaf''s `th:value`
    template attribute to preset the value held by form inputs to their respective
    `model` attribute values, you are right. Now, let''s make a simple `home.html`
    template. Add the `home.html` template here to the `templates` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update `ApplicationController` to include an action handling GET requests
    to `/home`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `home` action retrieves a list of all reviews stored within the database.
    In addition, the home action sets a model attribute that holds a principal containing
    information on the currently logged in user. Lastly, the home action renders the
    home page to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Having done what's necessary, let's register a user on the Place Reviewer platform.
    Build and run the application, and access the registration page from your browser
    (`http://localhost:5000/register`). Firstly, we want to check whether our form
    validations work by inputting and submitting invalid form data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f81ca59e-618a-4099-a07a-0489a4c34d36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen, the error was detected by `UserValidator` and was successfully
    bound to `BindingResult`, then rendered appropriately as an error in the view.
    Feel free to enter invalid data for other form inputs and ensure the other validations
    we implemented work as expected. Now to verify that our registration logic works.
    Input `king.kevin`, `king.k@gmail.com`, and `Kingsman406` in the username, email,
    and password fields, then click Sign Up! A new account will be created and you
    will be presented with the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c56c444-e7e3-4a30-a9de-9b7a7ff1242e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will come as no surprise to you that we are going to make serious modifications
    to the home page over the course of this chapter. However, for now let's turn
    our attention towards creating a suitable user login page.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to how we went about implementing the user registration view, first
    and foremost we must work on the view template. The template required for the
    login view must possess a form that takes the username and password of the user
    to be logged in as input. We must also provide a button that facilitates the submission
    of the login form—after all, there is no point having a form if it cannot be submitted.
    In addition, we must have a means of alerting the user if something goes wrong
    with the login process, such as in a scenario where the user enters an invalid
    username and password combination. Lastly, we should provide a link to the account
    registration page for situations where the viewer of the login page does not already
    possess an account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having identified what is needed from the template to be implemented, let''s
    go ahead with creating it. Add a `login.html` file to the template directory.
    Now, it is time to work on the template. As always, we must first include the
    necessary stylesheets and scripts to the template. This is done in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added the style and JavaScript includes necessary for the template,
    we can now work on the `<body>` of the template. As we have said before, the body
    of an HTML template contains the DOM elements that will be rendered to the user
    upon page load. Add the following code within the `<body>` tag of `login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the body added, the HTML we have created sufficiently describes the required structure
    of our login page. Along with adding the required form, we added the navigation
    bar fragment created earlier to the page—no need to write boilerplate code. We
    also added a means by which a user can be provided feedback pertaining to errors
    that may arise in the login process. This was done with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When `param.error` is set, it signifies that an error has occurred during user login,
    so an Invalid username and password combination message is shown to the user.
    Something to keep in mind is that besides the login page often being the first
    point of contact a user has with a web application, it can also be a user''s last
    point of contact with the app during an interaction session. This is particularly
    true in the case of user logouts. After a user is done interacting with an application
    and logs out, they should be redirected to a login screen. As a result of such
    a possibility, we added some text to notify a user that they''ve been logged out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<div>` tag is displayed to a user after a successful logout from their
    account. At this point, ideally we should implement a controller to render `login.html`
    but if you recall, we have already done so with the use of a custom Spring MVC
    configuration via our implemented `MvcConfig` class, specifically in the section
    of code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We made use of a `ViewControllerRegistry` instance to add a view controller
    that handles requests to `/login` and set the view to be used to the just-implemented
    login template. Build and run the application to view the newly implemented view.
    The web page can be accessed via `http:localhost:5000/login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1abef211-e0f7-47fc-bcbd-6111ec85f1ae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Trying to log in with invalid user credentials will present us with a nice
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e84dfa3-3a45-450a-9faa-239f89217747.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, attempting to log in with valid credentials takes us to the
    application's home page. Speaking of the home page, we need to work on completing
    its view layer. We are going to need to work directly with the Google Places API
    from this point onward. As such, we must set up our application to do so before
    proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Place Reviewer app with the Google Places API web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of setting up a web application with the Google Places API is quick
    and painless and can be completed in well under five minutes. All in all, the
    setup can be done in two easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an API key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the Google Places API in your web application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting an API key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An API key can be gotten by visiting [https://developers.google.com/places/web-service/get-api-key](https://developers.google.com/places/web-service/get-api-key),
    scrolling to the Get an API key section, and clicking the GET A KEY button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f55d2dd7-061f-4079-8ecc-d0be79e2cd85.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon clicking the button, you will be presented with a modal from which you
    can select or create a project to be integrated with the Google Places API Web
    Service. Click on the dropdown and select Create a new project. You will be requested
    to provide a project name. Input `Place Reviewer` as the project name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91ef273c-e70e-4de6-a602-22e43f3a2e84.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After providing a project name, click NEXT to proceed. Your project will be
    set up for use with the API and you will be presented with an API key to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af8f5a3a-672d-4f18-92d7-f7c5d31b017a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an API key, let's have a look at how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Including Google Places API in your web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Utilizing an API key for the Google Places API Web Service is just as easy—if
    not easier—as generating the API key. To make use of a generated API key in your
    web application, all that is necessary is the inclusion of the following line
    of HTML in the markup of the page you want to make use of the web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Ensure you replace  `{{API_KEY}}` with your generated API key.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the home view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As expected, at this point it will be required of us to do a bit of coding.
    In keeping with practices we have adhered to in previous chapters, it will be
    wise of us to firstly make a barebones graphical mockup of the view we want to
    create before commencing with coding. This will save a significant amount of time
    in the long run by providing a clear direction regarding what we want to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the home page we are creating to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the latest place reviews posted on the platform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide direct access to a web page for review creation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a means by which a user can sign out of their account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable a user to view the exact location of a reviewed place with the help of
    a map
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keeping all these requirements in mind, we can draw a rough sketch of our final
    template that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c83f661-e849-49e5-a7a7-91635775d9fd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are aiming for functionality over flash in our layout design. You can see
    that layout requirements one through four are immediately satisfied by this sketch.
    Clicking on View location will present the user of the application with a modal
    within which a map showing the exact place reviewed will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having clearly stated the template we will be creating, let us code. As always,
    first and foremost we need to include external stylesheets and scripts to our
    template. Open up `home.html` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice work! In addition to external stylesheets, we are going to make use of
    internal styles in this template. To define internal stylesheets in HTML files,
    simply add a `<style>` tag within the head of the HTML and input your desired
    CSS rules. Add the following style to `home.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, lets work on the body of the page. As you already know, all elements that
    make up the body of an HTML template must exist in a `<body>`  tag. With that
    in mind, we can work on `home.html`. Start by adding the following HTML to the
    template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Great job! Do not worry too much about what the preceding code block does as
    of now. We shall explain everything in due time. Moving on continue the body of
    `home.html` by adding the following lines of code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code declares a modal that will hold a map displaying the exact
    location a review was created—upon the request of the user. We are not done with
    the home template yet. Continue work on the `<body>`  further by adding the following
    lines of code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add internal JavaScript for the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function initializes and displays a map showing the location
    where a review was written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Load place marker creates a map marker on the reviewed location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite a lot has been done on `home.html`, so let''s talk a bit about what exactly
    is going on in the view, starting with the `<head>` tag. We included stylesheets
    and scripts required by the home page from lines 4 through 16 of the `<head>`
    tag. The CSS included is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These are external stylesheet inclusions for our application's CSS; Toastr,
    a library for the creation of JavaScript toast notifications; Bootstrap, a powerful
    library for designing websites and web applications; **Font Awesome**, an icon
    toolkit for websites and web applications; and buttons, a powerful and highly
    customizable web and CSS buttons library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after the CSS inclusions, we have a number of external JavaScript inclusions
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The script inclusions in their respective order are for: JQuery, a JavaScript
    library designed specifically to simplify the client-side HTML scripting process;
    Toastr; Popper, a library used to manage poppers in web applications; Bootstrap;
    buttons; and the Google Places API web service. Once again, ensure you replace
    the `{{API_KEY}}` with your API key for the Google Places API web service—this
    is important.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the JavaScript inclusions, we defined an internal stylesheet
    for the web page. Unfortunately, an explanation of stylesheets and their creation
    is beyond the scope of this book. However, it will be a good idea to brush up
    on CSS in your spare time. Further down `home.html`, we added a `<body>` tag as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`th:onload` in this is used to specify JavaScript that must be run after the
    page has been completely loaded. In short, it specifies code to be executed after
    an `onload` event occurs. In this case, the script to be run is a JavaScript function
    we defined further down the template, `showNoReviewNotification(boolean)`.  The
    function shows a toast message indicating that no reviews are available to be
    viewed when the reviews list provided by the model is empty. `showNoReviewNotification(boolean)`
    is declared in our template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`showNoReviewNotification(boolean)` takes a single `Boolean` argument, `show`.
    When `show` is true, a toast notification with the message `No reviews to see` is
    rendered to the user. The display of toast notifications to a user is made possible
    by the Toastr library we are utilizing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When there are reviews available to be shown to the user, then a container
    is created for each review item as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Each review container displays the username of the reviewer, the name of the
    place reviewed, the review title, the review body and a button enabling the user
    to view the reviewed location. Thymeleaf''s `th:each` attribute was used to iterate
    over each review in the `reviews` list, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A good way to understand the iteration process is by reading `th:each="review:
    ${reviews}"` as `For each review in reviews`. The review currently being iterated
    upon is held by the `review` variable. Hence, the data held by the review being
    iterated upon can be accessed like any other object. This is the case here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`th:text` sets the text held by the `<div>` to the value assigned to `review.placeName`.
    It is also necessary to explain the process by which location maps are shown to
    the user. Take a close look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This code block defines a button that does two things when a click event occurs
    on it. Firstly, it displays a modal identified by the ID `mapModal` to the user.
    Secondly, it initializes and renders a map displaying the exact location that
    was reviewed. The rendering of the map is made possible by the `showLocation()`
    JavaScript function we defined in our template file.
  prefs: []
  type: TYPE_NORMAL
- en: '`showLocation()` takes three parameters as its arguments. The first is the
    longitudinal coordinate, the second a latitudinal coordinate, and the third the
    unique identifier of the location reviewed—a place ID. The place ID for the location
    is provided by the Google Places API. Firstly, `showLocation()` retrieves a central
    point for the locational coordinates provided. This is done by utilizing the Google
    Places API''s `google.maps.LatLng` class. Simply defined, a `LatLng` is a point
    in geographical coordinates (longitude and latitude). Upon retrieving the central
    point, a new map is created with the use of the `Map` class (again, provided by
    the Google Places API) as shown in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The created map is placed within a DOM container element with an ID `map`. After
    creating the necessary map, we create a location marker at the exact location
    with the help of the `loadPlaceMarker()` function. `loadPlaceMarker()` takes instances
    of `google.maps.places.PlacesService`, `Map`, and a place id as its three arguments.
    `PlacesService` is a class that possesses methods for the retrieval of place information
    and searching places.
  prefs: []
  type: TYPE_NORMAL
- en: The instance of `google.maps.places.PlacesService` is firstly used to retrieve
    the details of the place with the specified place ID (the reviewed location).
    If the details of the place are successfully retrieved, `status === google.maps.places.PlacesServiceStatus.OK`
    evaluates to true and a marker for the location is placed on the map. The marker
    is created with the `google.maps.Marker` class. `Marker()` takes an optional options
    object as a its sole argument. When the options object is present, the place marker
    is created with the options specified. In this case, we specified a map in the
    options object. As such, the marker is added to the map upon its creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we added a form to our template that sends a `GET` request to the `/reviews/new`
    path upon its submission, and added a button that submits the form upon clicking.
    This was done in the lines shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need to do regarding the home page, so go ahead and check it
    out! Rebuild and run the application, register an account, and view the home page
    you just created!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ff0f079-ffd8-4674-9023-6ee04e65ddb2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, no reviews have been created on the platform for viewing. We
    must now work on a web page that allows the creation of reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the review creation web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far, we have created views for user registration and login, as well as
    a homepage for logged in users to peruse reviews posted on the platform. We must
    now work on the view that facilitates the creation of these reviews. As always,
    first, before creating the view, let us work on an action that will be in charge
    of rendering our to-be-developed view to users. Open up the `ApplicationController`
    class and add the following method to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `createReview()` action handles HTTP `GET` requests to the `/create-review`
    request path by returning a `create-review.html` template to the client for rendering.
    Go ahead and add a `create-review.html` file to the project `template` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we did before, let''s begin by adding external styles and scripts
    to `create-review.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add our required internal stylesheet for the webpage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing on our agenda is the creation of the necessary form for the
    input of review data. Continue the `create-review.html` template with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us add a modal that will enable the user to select the review location
    from a map. Do not worry too much about the details of the selection process as
    of now. We shall talk more on it shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we finish up the template by including its internal JavaScript,
    as shown in the code snippets that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we created references to important DOM elements
    that exist on the page. These references include references to place specific
    input fields (the fields for the address, name, ID, and latitudinal and longitudinal
    coordinates of a place). In addition, we added references for the containers displaying
    the details of a selected place, such as the place name and place address. At
    this juncture, we will declare a few functions. These functions are `initialize()`,
    `getPlaceDetailsById()`, `updateViewData()`, `setFormValues()`, `showSelectionsStatusContainer()`,
    and `setContainerText()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `initialize()` and `getPlaceDetailsById()` functions shown
    here to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the function below to enable us to get the details of a particular
    place from the Google Places API Invoked to retrieve the details of a place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add `updateView()` and `setFormValues()` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The function below is called to update view form data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, finish up the template by adding the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous template, we begin `create-review.html`  with the addition
    of both external and internal CSS and JavaScript required by the template in the
    HTML `<head>` tag. Further into the template, we create a form that takes the
    following form data as its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: A user defined title for the review being created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: The body of the review. This is the main review text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeAddress`: The address of the place being reviewed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeName`: The name of the place being reviewed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeId`: The unique ID of the location being reviewed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`latitude`: The latitudinal coordinate of the reviewed location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longitude`: The longitudinal coordinate of the reviewed location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There will be no need for the user to provide form input for `placeAddress`,
    `placeName`, `placeId`, `latitude`, and `longitude`. As such, we have hidden the
    parent `<div>` of the aforementioned input elements. We shall utilize the Google
    Places API to retrieve place-specific information. Make sure to note that in the
    template we are using a modal to display a map for location selection. The modal
    is toggled by a `button` we added in our template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on the button will display the map modal to the user. Upon rendering
    the map, a user can click on their desired review location from the map. Performing
    such a click action will trigger the map''s click event, which in turn will be
    handled by the listener we defined in the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`getPlacesDetailsById()` takes two arguments: an instance of `google.maps.places.PlacesService`
    and the ID of the place whose information is to be retrieved. The `PlacesService`
    instance is then used to retrieve the information of the place. After this information
    retrieval, the view is duly updated with the information retrieved: place-specific
    form data is set, the place name and address container within the map modal is
    updated, and a message indicating that a location has successfully been selected
    is shown to the user. Upon selection of a location and the input of all required
    form data, the user can then submit their review.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost ready to try out the review creation page. Before we do, we must
    create a review validator, as well as a controller action that handles `POST`
    requests sent to the `/reviews` path. Let''s start with `ReviewValidator`. Add
    the `ReviewValidator` class shown here to `com.example.placereviewer.component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have previously explained the workings of custom validators, there is
    little need to explain how this validator works. Without taking time, let us implement
    a controller class for HTTP requests pertaining to reviews. Create a `ReviewController`
    class in `com.example.placereviewer.controller` and add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Having added the `ReviewValidator` and `ReviewController` classes, build and
    run the project, log in as a user, and navigate to `http://localhost:5000/create-review`
    from your favorite browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon page load, you will be presented with a form you can use to add a new
    review:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/328b5242-6ab0-492f-8e79-0c31b07afb00.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Users are required to select a review location before a review can be submitted.
    To select a review location, click the Select Location button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4f022ca-b8fd-47f7-898a-08634042614d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking the Select Location button will present the user with a modal containing
    a map from which they can select a location of choice to review. Clicking on a
    location from the map will bring up an information window on the map containing
    data pertaining to the clicked location. In addition, the modal container for
    holding the selected place name and address will be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48c3b312-dc65-4fac-9835-9e30d0568600.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After a user selects their review location of choice, they can close the modal
    by clicking Done and proceed to filling in the title and body of their review:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcfa41a3-f9e3-46e4-a4a9-694dce9e6357.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the review form now indicates that a review location has been selected
    successfully. Once the user fills in all the necessary review information, they
    can proceed to submit the review by clicking Submit Review:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d48c136d-3edb-43f0-b341-e547064d7ac9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After review submission, the user is redirected to their home page, from which
    they can now see the review submitted. Clicking on the View location button of
    any review displayed on the home page will render a modal containing a map displaying
    the exact location reviewed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb72bff1-204f-4192-86ef-4479b26c4fa5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The map displayed to the user possesses a marker indicating the exact location
    reviewed by the reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have concluded all the core functionality of the *Place Reviewer*
    application. Before we wrap up this chapter, let us explore how to test Spring
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Spring application testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier on in this book, we discussed application testing and why it is necessary
    in creating reliable software. We must now explore the process of testing Spring
    applications. A Spring application can be tested in four easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add necessary testing dependencies to the project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a configuration class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure test class to use custom configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write required tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We shall look at each of these steps one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding necessary testing dependencies to the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This involves the inclusion of suitable testing dependencies in your project.
    Open the `Place Reviewer` project''s `pom.xml` file and add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the coming sections, we are going to learn how to write tests with jUnit
    and Hamcrest. JUnit is a testing framework for the Java programming language and
    Hamcrest is a library that provides matchers, which can be combined to create
    meaningful expressions of intent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a configuration class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The creation of a test configuration class aids the proper running of written
    tests. Within the `src/test/kotlin` directory of the `Place Reviewer` project,
    add a `config` package to `com.example.placereviewer`. Add the `TestConfig` class
    shown here to the package created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a test class to use custom configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, open the Spring application''s test class and use an `@ContextConfiguration`
    annotation to specify the configuration classes to be used by the test class.
    Open `PlaceReviewerApplicationTests.kt` (located in the `com.example.placereviewer`
    package of your project''s `src/test/kotlin` directory). Now, set its configuration
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Great work! You are now ready to write some application tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code for application tests is like writing code for any other part of
    a Spring application. You can make use of components and services as you would
    in any other part of your application. Let us demonstrate this, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `TestUserService` interface to `com.example.placereviewer.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following `TestUserServiceImpl` class to the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Return to the `PlaceReviewerApplicationTests.kt` file and modify it to reflect
    these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `testUserRetrieval()` method is a test that, when run, makes use of the
    stub method we defined in `TestUserServiceImpl` to retrieve a user and asserts
    that the object returned by the function is an instance of the `User` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a written test, click the Run Test button to the right of the created
    test in the IDE window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b744466f-c30b-404f-a000-949e4d533bf3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`testUserRetrieval` will be run and the result of the test run will be displayed
    at the bottom of the IDE window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbd3c160-eb73-4507-bc4a-78e68630162a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the test we wrote passed. That's a great thing. However, as you
    develop larger and more complex applications and write tests for application modules,
    you will discover that more often than not, written tests fail. When this happens,
    do not fret; simply stay calm and debug your application. As time passes, you
    will learn to create more reliable software.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we wrapped up our journey through Kotlin by finishing up the
    *Place Reviewer* application. In the process, we explored—in depth—the creation
    of view layers for Spring MVC-based applications. Furthermore, we learned how
    to integrate an application with Google Places API Web Services with the goal
    of making an application location-aware.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned about form input validation with the help of `Validator`
    classes and `BindingResult`. Finally, we covered how to configure for testing
    and write tests for Spring-based applications.
  prefs: []
  type: TYPE_NORMAL
