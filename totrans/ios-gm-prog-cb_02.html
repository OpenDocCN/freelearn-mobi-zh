<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. SpriteKit</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Learning the basics of SpriteKit – The FlyingSpaceship tutorial</li><li class="listitem">Understanding scenes, nodes, and sprites</li><li class="listitem">Anatomy of game projects</li><li class="listitem">Applying actions on Sprites</li><li class="listitem">Adding infinite scrolling</li><li class="listitem">Moving characters</li></ul></div><p class="calibre8">This chapter explains SpriteKit in detail. We'll start from a discussion on the basics of SpriteKit, and then we will be learning about the anatomy of the game project. Moving ahead, we will learn about scenes, sprites, and nodes. This will provide us a deeper understanding about the basic structure model of the SpriteKit. Then we will be exploring the depth of SpriteKit by adding some actions to the sprites. Moving ahead, we will be adding infinite scrolling to the game that will be created during the chapter.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec12" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">SpriteKit<a id="id35" class="calibre1"/> is a graphics rendering and animation framework with features for animating arbitrary textured images called Sprites. It has a rendering loop that renders the contents of the frame. As a process, the content of each frame (that is, input) is given, processed, and then finally rendered by the rendering loop.</p><p class="calibre8">Basically, your game identifies the content of the frame and how the content has to be changed in that frame.</p><p class="calibre8">Being a new player in the game industry, SpriteKit is doing really well as it has adopted the basics of cocos2d, which is a heavily used game engine for 2D games. It's really well written, documented, and deeply integrated with iOS. However, if you are new to the game development domain, even then this book will serve you as a starter development guide. Each chapter is baked with a recipe to make sure that you learn all the concepts of game development.</p><p class="calibre8">Now here are<a id="id36" class="calibre1"/> the two most basic concepts: scenes and sprites. iOS games are made up of scenes and scenes in turn hold sprites.</p><p class="calibre8">To get started with the SpriteKit, we will be creating a small game that will guide us to understand all the concepts of the SpriteKit.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>Learning the basics of SpriteKit – The FlyingSpaceship tutorial</h1></div></div></div><p class="calibre8">In this section we <a id="id37" class="calibre1"/>will learn and explore basic concepts of SpriteKit. We will also develop a mini game, which will help in understanding the concepts with some <a id="id38" class="calibre1"/>robust implementation. The best way to learn SpriteKit is to see it in action.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec19" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To build a <a id="id39" class="calibre1"/>SpriteKit game, firstly you need to understand the basic structure of a SpriteKit project. You can get started with a starter project having a <code class="email">SKScene</code> and an <code class="email">SKNode</code> placed on it. This would equip you with the setup to build your basic game.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec20" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">To understand the basic concepts of game programming, let's create a new project with the SpriteKit game template with project name <code class="email">FlyingSpaceship</code>. The project will demonstrate the structure of a SpriteKit project. The end goal of the project is that a Spaceship is visible on the screen and in the upcoming topics we can make it fly.</p><p class="calibre8">We will follow some of the same steps we performed in <a class="calibre1" title="Chapter 1. iOS Game Development" href="part0015_split_000.html#page">Chapter 1</a>, <em class="calibre9">iOS Game Development</em> and finally add the Spaceship to the screen:</p><div><ol class="orderedlist"><li class="listitem" value="1">Start your Xcode and navigate to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> | <strong class="calibre2">Project</strong>. Then from the prompt window navigate to <strong class="calibre2">iOS</strong> | <strong class="calibre2">Application</strong> | <strong class="calibre2">SpriteKit Game</strong> and click on <strong class="calibre2">Next</strong>.<div><img src="img/00016.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Fill all<a id="id40" class="calibre1"/> the project details in the prompt window and provide <code class="email">FlyingSpaceship</code> as the project name with your <strong class="calibre2">Organization Name</strong>, <strong class="calibre2">Devices</strong> as <strong class="calibre2">iPhone</strong>, and <strong class="calibre2">Class Prefix</strong> as <code class="email">FS</code>. Click on <strong class="calibre2">Next</strong> as shown in the following screenshot:<div><img src="img/00017.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Select a<a id="id41" class="calibre1"/> location on drive to save the project and click on <strong class="calibre2">Create</strong>.</li><li class="listitem" value="4">As a result, the <code class="email">FSViewController</code> and <code class="email">FSMyScene</code> files will be created in the project having a <code class="email">Spaceship.png</code> file also. The project directory should look something similar to the following screenshot:<div><img src="img/00018.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">Go to the <strong class="calibre2">General</strong> tab, uncheck <strong class="calibre2">Portrait</strong> from the device orientation so that the final orientation is landscape.</li><li class="listitem" value="6">Cut the code of typecasting <code class="email">UIView</code> to <code class="email">SKView</code> and presenting <code class="email">FSMyScene</code> to <code class="email">SKView</code> from <code class="email">(void)viewDidLoad</code> of <code class="email">FSViewController</code>.</li><li class="listitem" value="7">Implement <code class="email">- (void)viewWillLayoutSubviews</code> and copy the code from <code class="email">viewDidLoad</code> to <code class="email">viewWillLayoutSubviews</code>.</li><li class="listitem" value="8">Finally, the code will look like this:<div><img src="img/00019.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="9">Now, let's <a id="id42" class="calibre1"/>go to <code class="email">FSMyScene.m</code>, remove the default code added in the <code class="email">init</code> method and also the method for touch detection.</li><li class="listitem" value="10">Make a property for a <code class="email">SKSpriteNode</code> called spaceship in the private interface:<div><pre class="programlisting">@interface FSMyScene()
@property (nonatomic, strong) SKSpriteNode*     spaceShipSprite;
@end</pre></div></li><li class="listitem" value="11">Add this <code class="email">spaceShipSprite</code> to the <code class="email">FSMyScene</code> file in its <code class="email">init</code> method:<div><pre class="programlisting">self.spaceShipSprite = [SKSpriteNode spriteNodeWithImageNamed:@"Spaceship"];
self.spaceShipSprite.position = CGPointMake(self.spaceShipSprite.size.width, size.height/2);        
[self addChild:self.spaceShipSprite];</pre></div><p class="calibre15">The default <code class="email">Spaceship.png</code> provided is appropriate, so delete and add <code class="email">Spaceship.png</code> provided in the <code class="email">Resources</code> folder of the Starter kit.</p></li><li class="listitem" value="12">Now if you run the app, the spaceship doesn't look good on a black background, so give the sky color background color to <code class="email">FSMyScene</code> file in its <code class="email">init</code> method.<div><pre class="programlisting">self.backgroundColor = [UIColor colorWithRed:135.0/255.0 green:206.0/255.0 blue:235.0/255.0 alpha:1.0];</pre></div><p class="calibre15">So finally we have reached the goal and have placed a spaceship in the sky.</p><p class="calibre15">The final <code class="email">FSMyScene</code> class looks like this:</p><div><img src="img/00020.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li></ol><div></div><p class="calibre8">In the preceding <a id="id43" class="calibre1"/>screenshot, you will observe an <code class="email">update: method</code> in the <code class="email">.m</code> file. This method is automatically invoked while rendering each frame on the screen. If the frame rate of the game is 60, then this method will be executed 60 times in a second. Any real-time calculations can be performed in this method, so actions such as calculating the player's location in real time can be handled in this method.</p><p class="calibre8">And the starter kit game, <code class="email">FlyingSpaceship</code>, looks like this:</p><div><img src="img/00021.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec21" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The<a id="id44" class="calibre1"/> structure of SpriteKit is fundamentally derived and inherited from the UIKit framework. The operating system offers a smooth transition from UIKit to SpriteKit by just typecasting the UIKit view controller's view to a SpriteKit view called SKView. After this, you are ready to play with the SpriteKit stuff. As shown in the following block diagram, create a scene, add some nodes (that is Sprites as players, background stuff, and so on) to it and you have the game environment built. You can also make the environment more live by applying some actions (rotate, move, scale, and many more) to the nodes added.</p><p class="calibre8">Hence, in combination, this scene has different kinds of nodes with some actions applied, that make the basic structure of your SpriteKit and also the game you thought of building.</p><div><img src="img/00022.jpeg" alt="How it works..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec22" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">SpriteKit can<a id="id45" class="calibre1"/> be used for game development on iOS and OS X platforms. The available graphics hardware of the hosting device is used to render composite 2D images at high frame rates. There are several other features<a id="id46" class="calibre1"/> of SpriteKit, which support the following kinds of content, including:</p><div><ul class="itemizedlist"><li class="listitem">Sprites that can be of any form such as untextured or textured rectangles</li><li class="listitem">Text</li><li class="listitem">Arbitrary CGPath-based shapes</li><li class="listitem">Video</li></ul></div><p class="calibre8">If you are curious to know more, then visit Apple's developer link <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html</a>.</p><p class="calibre8">You can also play around with the sample you have just created by trying to change the location of the spaceship and applying various colors to its background.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Understanding scenes, nodes, and sprites</h1></div></div></div><p class="calibre8">The<a id="id47" class="calibre1"/> whole <a id="id48" class="calibre1"/>game is organized into scenes, which have the content represented by <code class="email">SKScene</code> objects.</p><p class="calibre8">A scene is an entity that holds all the content, that is, nodes and sprites that are to be rendered. It also implements the setup or anatomy of content processing and updating each frame.</p><p class="calibre8">The <a id="id49" class="calibre1"/>
<code class="email">SKScene</code> class<a id="id50" class="calibre1"/> is a subclass of SKNode, which is the fundamental building block of SpriteKit. Every entity in SpriteKit is inherited or derived from the node (SKNode). So <code class="email">SKScene</code> is the root node for other nodes, which are used to populate the content over a scene.</p><p class="calibre8">Similar to UIKit, each <a id="id51" class="calibre1"/>node's <a id="id52" class="calibre1"/>position is specified according to the coordinate system of its parent. A node also has the basic properties that a content item or entity should have such as moving, rotating, scaling, fading out, and many more. And most important, all node objects are responder objects that respond to the delegates of UIResponder. This is used to detect input touches to the scene for moving objects and some other stuff depending on one's gameplay.</p><p class="calibre8">Now, sprites <a id="id53" class="calibre1"/>are <a id="id54" class="calibre1"/>represented by SKSpriteNode objects. They are nodes with images on them. We can specify content or a textured image to them as we have to make some player or enemies in a game. SKSpriteNode is also inherited from SKNode. Additionally, its content can be changed and animated. The sprites are created and added on scenes with some actions to make the game scene more alive.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec23" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To understand these elements of SpriteKit, we need to create a blank project just as we did in the starter project of this chapter. As in this starter kit, a basic <code class="email">SKScene</code> and <code class="email">SKNode</code> are shown. So we will now go through these terminologies and their sample code snippets.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec24" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">As we did in the <a id="id55" class="calibre1"/>starter kit, follow the same steps to create a <code class="email">SKScene</code> and add a <code class="email">SKSpriteNode</code> method to it:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create the SpriteKit Game Template from Xcode.</li><li class="listitem" value="2">A default ViewController and scene will be created for you.</li><li class="listitem" value="3">Typecast the ViewController view to <code class="email">SKView</code> by enabling the <code class="email">showsFPS</code> and <code class="email">showsNodeCount</code> properties to <code class="email">YES</code>.<div><pre class="programlisting">// Configure the view.
SKView * skView = (SKView *)self.view;
skView.showsFPS = YES;
skView.showsNodeCount = YES;</pre></div></li><li class="listitem" value="4">Create a <a id="id56" class="calibre1"/>scene using a class method of <code class="email">SKScene</code> specifying the size of the scene also, and then present that scene on the <code class="email">SKView</code> typecasted before.<div><pre class="programlisting">// Create and configure the scene.
SKScene * scene = [SKScene sceneWithSize:skView.bounds.size];
scene.scaleMode = SKSceneScaleModeAspectFill;
    
// Present the scene.
[skView presentScene:scene];</pre></div><p class="calibre15">All this should be done in the <code class="email">- (void)viewWillLayoutSubviews</code> method.</p></li><li class="listitem" value="5">Now we have to add some sprite to the scene we created earlier. Create an object of SKSpriteNode by calling a class method and specifying an image of the sprite. Now assign the location where it has to be placed and lastly add it to the scene.<div><pre class="programlisting">SKSpriteNode * spriteNode = [SKSpriteNode spriteNodeWithImageNamed:@"Spaceship.png"];
spriteNode.position = CGPointMake(100,100);
[self addChild:spriteNode];</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec25" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">As explained in the structural block diagram of the <em class="calibre9">How it works...</em> section of the <em class="calibre9">Learning the basics of SpriteKit – The FlyingSpaceship tutorial </em>recipe, it's deeply linked with the UIKit framework. For building a game, we should have an environment, which is our scene, and some entities visible over the environment, which are the sprites. So to make it work, or should I say to make something visible on the screen, an environment (that is, scene) is created and on it entities (that is, sprites) are added, as follows:</p><div><ul class="itemizedlist"><li class="listitem">When we typecast UIView in to <code class="email">SKView</code>, we enter the arena of SpriteKit:<div><pre class="programlisting">SKView * skView = (SKView *)self.view;</pre></div></li><li class="listitem">For debugging purposes, we enable two Boolean parameters to show FPS (Frames per second) and NodesCount (the number of nodes added to the scene):<div><pre class="programlisting">    skView.showsFPS = YES;
    skView.showsNodeCount = YES;</pre></div></li><li class="listitem">When creating a scene, we need to specify the size of the scene that is exactly the content size and the scale mode so that the scene fits in <code class="email">SKView</code> (that is, scale perspective), here the <code class="email">SKSceneScaleModeAspectFill</code> mode is used so that it fits as per the aspect ratio of the <code class="email">SKView</code>:<div><pre class="programlisting">    SKScene * scene = [SKScene sceneWithSize:skView.bounds.size];
    scene.scaleMode = SKSceneScaleModeAspectFill;</pre></div></li><li class="listitem">To make the scene content visible on the view, we present the scene on <code class="email">SKView</code>:<div><pre class="programlisting">    // Present the scene.
    [skView presentScene:scene];</pre></div></li><li class="listitem">Now about how the sprites work. A sprite object is created by a class method that instantiates a node having an image as its content:<div><pre class="programlisting">    SKSpriteNode * spriteNode = [SKSpriteNode spriteNodeWithImageNamed:@"Spaceship.png"];</pre></div></li><li class="listitem">The following line of code specifies the position where exactly the sprite needs to be placed:<div><pre class="programlisting">    spriteNode.position = CGPointMake(100,100);
Lastly, to make the sprite visible, it is added to <code class="email">SKScene</code> as a child:
    [self addChild:spriteNode];</pre></div></li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Anatomy of game projects</h1></div></div></div><p class="calibre8">In this<a id="id57" class="calibre1"/> section we will see the basics of a game project. This<a id="id58" class="calibre1"/> includes understanding the basic architecture and work flow of game projects. Here we will learn about the scene and layers and their importance in games.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec26" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Complete game development is dependent on three core components: scenes, nodes, and sprites mentioned earlier. We need to have a command over these components to effectively start on game development.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec27" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Internally, the life cycle is executed as per the scenes—nodes are added and actions applied on these nodes. It also includes attaching some physics bodies to the nodes, support for cropping, applying animation and effects to all or a part of the content, detecting forces and collision, drawing in OpenGL, and many more things.</p><p class="calibre8">Apart from all this, there is an overridden update method in <code class="email">SKScene</code>, which is called for each frame of the <a id="id59" class="calibre1"/>game with the current time interval as a parameter. There you can add your actual game logic specifying what to do at what time and many more things as it is called by every frame that is rendered.</p><p class="calibre8">For an example, we can track the difference in time between the current time and the last updated time.</p><div><ol class="orderedlist"><li class="listitem" value="1">As the current time interval is received in the update method, define the properties for difference in time and last updated time.<div><pre class="programlisting">@property (nonatomic, assign) NSTimeInterval lastUpdatedTime;
@property (nonatomic, assign) NSTimeInterval    diffTime;</pre></div></li><li class="listitem" value="2">Now <a id="id60" class="calibre1"/>calculate difference in time by subtracting the last updated time from the current time and updating the lastUpdatedTime to the current time.<div><pre class="programlisting">self.diffTime = currentTime - self.lastUpdatedTime;    
self.lastUpdatedTime = currentTime;</pre></div></li><li class="listitem" value="3">At last the update method looks like this:<div><pre class="programlisting">- (void)update:(CFTimeInterval)currentTime
{
    /* Called before each frame is rendered */
    self.diffTime = currentTime - self.lastUpdatedTime;    
    self.lastUpdatedTime = currentTime;
}</pre></div></li></ol><div></div><p class="calibre8">Now this is the place where we are going add our maximum game logic—all the adding, removing, animating, updating all nodes, sprites, and actions will take place inside this method. We can also take the help of <code class="email">currentTime</code> to maintain some timers simply using float variables (updating them by the <code class="email">diffTime</code> and firing time events whenever required according to our game design or logic).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec28" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">All that we see running on the screen are just frames added by a time interval, which is driven by a <code class="email">SKScene</code> added as a child on the <code class="email">SKView</code> that serves as the main scene of the game.</p><p class="calibre8">As shown in the following diagram, a frame circle is present, which depicts the execution cycle of the game project for each frame:</p><div><img src="img/00023.jpeg" alt="How it works..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Some of the methods from<a id="id61" class="calibre1"/> the preceding diagram are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem">An update method of <code class="email">SKScene</code> is called where we can add, remove, animate, and update different kinds of nodes and actions.</li><li class="listitem"><code class="email">SKScene</code> evaluates its actions that are running for the current frame following some life cycle calls such as <code class="email">didEvaluateActions</code>.</li><li class="listitem"><code class="email">SKScene</code> has its own physics simulation, so if some bodies are added to it, the physics simulation is also evaluated such as collision detection, applying forces, and so on.</li><li class="listitem">All the methods mentioned earlier contribute to the final rendering of SKView, which is displayed as a frame to the user. Hence, regular running of these frames makes the game appear as an environment.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Applying actions on sprites</h1></div></div></div><p class="calibre8">Sprites are just <a id="id62" class="calibre1"/>static images with no life. So actions add that life <a id="id63" class="calibre1"/>to the sprites that make your game. Actions help in<a id="id64" class="calibre1"/> building the gameplay by moving sprites and animating them differently. An action is an object that makes the scene look alive.</p><p class="calibre8">Actions are applied on nodes and sprites, for example, we want to move some object that is a sprite, so we create a move action and run it on that sprite. SpriteKit automatically changes the sprite's position in a form of animation until the action is over.</p><p class="calibre8">All actions are<a id="id65" class="calibre1"/> implemented using a class called <code class="email">SKAction</code> and different<a id="id66" class="calibre1"/> types of actions are instantiated using the class methods of the <code class="email">SKAction</code> class provided for various animation functionality.</p><p class="calibre8">Here are the most common actions available in SpriteKit:</p><div><ul class="itemizedlist"><li class="listitem">Applying transformation (translation, rotation, and scaling)</li><li class="listitem">Changing visibility (fading in and fading out)</li><li class="listitem">Changing the content of the sprite</li><li class="listitem">Changing the colors of sprites</li><li class="listitem">Removing sprites</li><li class="listitem">Calling a block or a selector</li><li class="listitem">Repeating and sequencing actions</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec29" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To apply<a id="id67" class="calibre1"/> different actions on sprites and see them animating, we need to know scenes, sprites, and the overall life cycle of a SpriteKit project. We also need to know about some fundamental actions that are applied on any entity such as move, rotate, scale, and there are many more special effects to explore.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec30" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">There is a wide variety of actions to be applied on nodes and sprites, some of which are listed next.</p><p class="calibre8">To understand this, we will take the spaceship as a sprite to apply different actions.</p><p class="calibre8">There are several individual actions provided by the SpriteKit framework. A few of them are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Move Action</strong>: To move a sprite, call the class method shown below, specifying the location where the sprite has to be moved and in what time. And then call the <code class="email">runAction</code> method on the sprite with the move action created.<div><pre class="programlisting">SKAction* moveAction = [SKAction moveTo:CGPointMake(100,100) duration:1.0];
[self.spaceShipSprite runAction:moveAction];</pre></div></li><li class="listitem"><strong class="calibre2">Rotate Action</strong>: To rotate a sprite, we have to specify an angle in radians, which will make the sprite rotate by or to that angle in a specified time. So specify the angle in degrees, convert to radians, and then feed it to the function thereby applying that action to the sprite.<div><pre class="programlisting">CGFloat angleInDegree = 90.0;
CGFloat angleInRadian = angleInDegree * M_PI/180.0; 
SKAction* rotateAction = [SKAction rotateByAngle:angleInRadian duration:2.0];
[self.spaceShipSprite runAction:rotateAction];</pre></div></li><li class="listitem"><strong class="calibre2">Scale Action</strong>: To scale <a id="id68" class="calibre1"/>a sprite, we have to specify a scale factor, which will increase or decrease the size of the sprite, depending on the scale factor given in a time.<div><pre class="programlisting">SKAction* scaleAction = [SKAction scaleBy:2.0 duration:2.0];
[self.spaceShipSprite runAction:scaleAction];</pre></div></li><li class="listitem"><strong class="calibre2">Fade Action</strong>: To make a sprite visible or invisible through animation, there are methods for fading out and fading in a sprite. For now, fading out is shown in the following code, which takes a parameter or the time over which to fadeout.<div><pre class="programlisting">SKAction* fadeOutAction = [SKAction fadeOutWithDuration:1.0];
[self.spaceShipSprite runAction:fadeOutAction];</pre></div></li></ul></div><p class="calibre8">In <a id="id69" class="calibre1"/>SpriteKit, there <a id="id70" class="calibre1"/>are many more actions for giving delays, changing content, invoking an object or selector, calling blocks, and many special effects.</p><p class="calibre8">Similar to the individual actions, there are sequence and repeat actions, which fall under a different category of actions provided by SpriteKit. The sequence action is meant for running actions in a particular sequence we want. As shown in the following code, two actions are created—one for fading out and the other for fading in the sprite. So, both the actions are fed to the sequence action in the order we want and it would run the sequence we asked for:</p><div><pre class="programlisting">SKAction* fadeOutAction = [SKAction fadeOutWithDuration:1.0];
SKAction* fadeInAction = [SKAction fadeInWithDuration:1.0];
SKAction* sequenceAction = [SKAction sequence:@[fadeOutAction, fadeInAction]];
[self.spaceShipSprite runAction:sequenceAction];</pre></div><p class="calibre8">The repeat action allows actions to be repeated for a fixed number of time or to be repeated forever. So using the preceding sequence action, we do both.</p><div><ul class="itemizedlist"><li class="listitem">Animating the sequence for three times regularly:<div><pre class="programlisting">SKAction* repeatThreeTimesAction = [SKAction repeatAction:sequenceAction count:3];
[self.spaceShipSprite runAction:repeatThreeTimesAction];</pre></div></li><li class="listitem">Animating the sequence repeatedly forever:<div><pre class="programlisting">SKAction* repeatForeverAction = [SKAction repeatActionForever:sequenceAction];
[self.spaceShipSprite runAction:repeatForeverAction];</pre></div></li></ul></div><p class="calibre8">Another type of action is the group action. Several times in games we may need to repeat a sequence of actions, which<a id="id71" class="calibre1"/> means running actions in a particular sequence <a id="id72" class="calibre1"/>for any interval of time. As shown previously, two <a id="id73" class="calibre1"/>actions were created, one for fading out and second for fading in the sprite. So, both the actions were fed to the sequence action in the order we wanted and it would run the sequence we asked for.</p><p class="calibre8">Group actions are used when we have to run many actions at the same point of time. So we can make a group function that moves a sprite by fading out also:</p><div><pre class="programlisting">SKAction* moveAction = [SKAction moveTo:CGPointMake(100,100) duration:1.0];
SKAction* fadeOutAction = [SKAction fadeOutWithDuration:1.0];
SKAction *groupAction = [SKAction group:@[moveAction, fadeOutAction]];
[self.spaceShipSprite runAction:groupAction];</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec31" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">All the actions we have discussed earlier will be working in the same flow. Here is the basic anatomy of all actions, which we apply on sprites:</p><div><ul class="itemizedlist"><li class="listitem">Decide the actions we want to apply, in what sequence they are to be executed, and whether some action needs to be repeated or not.</li><li class="listitem">For each action, whatever the type is, specify its respective parameters and the time duration for it.</li><li class="listitem">After finalizing the action, just call <code class="email">runAction</code> on the sprite to be animated with the action constructed.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Adding infinite scrolling</h1></div></div></div><p class="calibre8">Now we <a id="id74" class="calibre1"/>are all ready with our <a id="id75" class="calibre1"/>spaceship. It's time to add some more in the game. So our next target is to add infinite scrolling to the game, so that we can make our spaceship move infinitely in space. In this recipe, we will be learning about the ways to add infinite scrolling to games.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec32" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">For an infinite scrolling background you need to know about the anatomy of SpriteKit shown earlier. You should be aware of the rendering loop, how in a particular frame the update method functions, and how <code class="email">SKScene</code> evaluates the actions and physics simulation thereby rendering all the stuff in the <code class="email">SKView</code>. Now using this loop, you implement sky scrolling infinitely giving the feel of a spaceship flying.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec33" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Now is the <a id="id76" class="calibre1"/>time for action; perform<a id="id77" class="calibre1"/> the following steps to add the infinite scrolling background to your game.</p><div><ol class="orderedlist"><li class="listitem" value="1">Import the <code class="email">SpaceBackground.png</code> file provided in the <code class="email">Resources</code> folder.</li><li class="listitem" value="2">Add a function in <code class="email">FSMyScene</code> for initializing the infinite background.</li><li class="listitem" value="3">In order to enable scrolling, we have to add two identical background sprite nodes one after the other.</li><li class="listitem" value="4">In the function, run a <code class="email">for</code> loop for two background nodes specifying the position, a name (tag), and then adding to <code class="email">SKMyScene</code>.</li><li class="listitem" value="5">Hence, the <code class="email">initalizingScrollingBackground </code>function looks like this:<div><pre class="programlisting">- (void)initalizingScrollingBackground
{
    for (int index = 0; index &lt; 2; index++)
    {
        SKSpriteNode *spaceBGNode =
        [SKSpriteNode spriteNodeWithImageNamed:@"SpaceBackground.png"];
        {
            spaceBGNode.position =
            CGPointMake(index * spaceBGNode.size.width, 0);
            spaceBGNode.anchorPoint = CGPointZero;
            spaceBGNode.name = @"SpaceBG";
            
            [self addChild:spaceBGNode];
        }
    }
}</pre></div></li><li class="listitem" value="6">Add this method into the <code class="email">init</code> method and also move the code to add a spaceship into a different method called <code class="email">addSpaceship</code>.<div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">In game programming, the layers of objects are made by the sequence they are added in. So for the preceding example, the Spaceship should be added after <code class="email">SpaceBackground</code> giving an appearance that the ship is above the background.</p></div></li></ol><div></div><p class="calibre8">The sequence of the views presented on the screen can be changed by altering their <em class="calibre9">z</em> coordinate; the view having highest <em class="calibre9">z</em> coordinate will always be on the top. This means we can explicitly define <a id="id78" class="calibre1"/>which layer we want to keep on top and which we want to keep at the bottom, which is explained in the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">The initial background is added but it's not scrolling. This could be accomplished by the update method discussed in the <em class="calibre9">Anatomy of game projects</em> recipe.</li><li class="listitem" value="2">For this, some <a id="id79" class="calibre1"/>math is required to implement this functionality. Build some inline functions and constants to be used for infinitely moving the background. This is the code needed:<div><pre class="programlisting">static const float SPACE_BG_VELOCITY = 100.0;
static inline CGPoint CGPointAdd(const CGPoint a, const CGPoint b)
{
    return CGPointMake(a.x + b.x, a.y + b.y);
}
static inline CGPoint CGPointMultiplyScalar(const CGPoint a, const CGFloat b)
{
    return CGPointMake(a.x * b, a.y * b);
}</pre></div></li><li class="listitem" value="3">Just add these line of code preceding to the implementation of <code class="email">FSMyScene</code>.</li><li class="listitem" value="4">Now the real way to do it is, in the update method, iterate all nodes added in <code class="email">FSMyScene</code>, identify the <code class="email">SpaceBackground</code> node by its name assigned in the initialization function, and adjust its position to enable infinite scrolling. Do all of this in a function named <code class="email">moveSpaceBackground</code>.<div><pre class="programlisting">- (void)moveSpaceBackground
{
    [self enumerateChildNodesWithName:@"SpaceBG"
                           usingBlock: ^(SKNode *node, BOOL *stop)
     {
         SKSpriteNode * spaceBGNode = (SKSpriteNode *) node;
         
         CGPoint bgVelocity = CGPointMake(-SPACE_BG_VELOCITY, 0);
         
         CGPoint amtToMove = CGPointMultiplyScalar(bgVelocity,self.diffTime);
         
         spaceBGNode.position = CGPointAdd(spaceBGNode.position, amtToMove);
         
         //Checks if Background node is completely scrolled of the screen, if yes then put it at the end of the other node
         
         if (spaceBGNode.position.x &lt;= -spaceBGNode.size.width)
         {
             spaceBGNode.position =
             CGPointMake(spaceBGNode.position.x + spaceBGNode.size.width*2,
                         spaceBGNode.position.y);
         }
     }];
}</pre></div></li><li class="listitem" value="5">Lastly, call this<a id="id80" class="calibre1"/> method every time in the update method of the game scene. After that, you should see the spaceship flying in the sky with some nice white clouds.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec34" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Implementation<a id="id81" class="calibre1"/> of infinite scrolling is divided into three parts. We need to follow the following steps to accomplish infinite scrolling for our game:</p><div><ul class="itemizedlist"><li class="listitem">Initializing the SpaceBackground: Two space backgrounds are added one after the other so that they are moved at the same time to give a feel of an infinite scrolling background.</li><li class="listitem">SpaceBackground move code: Here, a block method of SKScene is used to iterate all nodes of the scene.<div><pre class="programlisting">[self enumerateChildNodesWithName:@"SpaceBG"
                           usingBlock: ^(SKNode *node, BOOL *stop)
     {

     }];</pre></div></li></ul></div><p class="calibre8">In this iteration, the SpaceBGNode is identified by its name so that its position can be updated.</p><div><pre class="programlisting">SKSpriteNode * spaceBGNode = (SKSpriteNode *) node;</pre></div><p class="calibre8">The amount of distance to be moved is calculated using the <code class="email">CGPointMultiplyScalar</code> inline function that is fed with the constant value <code class="email">SPACE_BG_VELOCITY</code> and the difference of time obtained from the update method in each frame.</p><div><pre class="programlisting">CGPoint bgVelocity = CGPointMake(-SPACE_BG_VELOCITY, 0);
CGPoint amtToMove = CGPointMultiplyScalar(bgVelocity,self.diffTime);</pre></div><p class="calibre8">After that, the <a id="id82" class="calibre1"/>calculated distance is added in the current position of SpaceBGNode.</p><div><pre class="programlisting">spaceBGNode.position = CGPointAdd(spaceBGNode.position, amtToMove);</pre></div><p class="calibre8">The last but the most <a id="id83" class="calibre1"/>important step to enable scrolling, is to set the position of <code class="email">SpaceBGNode</code> to the right edge of the screen whenever it reaches the left edge of the screen.</p><div><pre class="programlisting">if (spaceBGNode.position.x &lt;= -spaceBGNode.size.width)
{
  	spaceBGNode.position =
             CGPointMake(spaceBGNode.position.x + spaceBGNode.size.width*2,
                         spaceBGNode.position.y);
  }</pre></div><p class="calibre8">The next task is to update each frame to move it infinitely over the scene. Now to make it move regularly, the <code class="email">moveSpaceBackground</code> method is called in the update method of <code class="email">FSMyScene</code> in each frame.</p><div><pre class="programlisting">- (void)update:(CFTimeInterval)currentTime
{
    /* Called before each frame is rendered */
    self.diffTime = currentTime - self.lastUpdatedTime;
    
    self.lastUpdatedTime = currentTime;
    
    [self moveSpaceBackground];
}</pre></div><p class="calibre8">The update loop will be executed in every frame. So to move our background in every step, we have called the <code class="email">moveSpaceBackground</code> method inside the update loop. Using this approach of infinite scrolling, we can also implement parallax gaming, which is very common nowadays. In parallax scrolling game, there will be background and player in separate layers and they will be moving at the same time at different speeds. This will give the user a perception of some real-time movement of the player against the background.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Moving characters</h1></div></div></div><p class="calibre8">The most interesting part<a id="id84" class="calibre1"/> is making some character live, which we are going to do in this part. We will be detecting a touch on the screen and then applying some cool actions on some nodes, that is, moving the spaceship up and down.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec35" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To make the character move, you should know the basic actions (<code class="email">SKAction</code>) that can be applied on nodes (<code class="email">SKNode</code>).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec36" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Now, as we have got the spaceship moving in infinite space, it's time to add some more fun in the game. We will now be adding the up-down motion to our spaceship. Perform the following steps to add the up-down motion to the spaceship:</p><div><ol class="orderedlist"><li class="listitem" value="1">Declare some properties for actions, namely up and down actions in <code class="email">FSMyScene</code>.<div><pre class="programlisting">@property (nonatomic, strong) SKAction*         moveUpAction;
@property (nonatomic, strong) SKAction*         moveDownAction;</pre></div></li><li class="listitem" value="2">Define the distance and over what time the spaceship will move on a screen touch just above the implementation of <code class="email">FSMyScene</code>.<div><pre class="programlisting">static const float SPACE_BG_ONE_TIME_MOVE_DISTANCE = 30.0;
static const float SPACE_BG_ONE_TIME_MOVE_TIME = 0.2;</pre></div></li><li class="listitem" value="3">Assign up and down actions to their respective properties in the <code class="email">addSpaceShip</code> method as added in the starter kit project.<div><pre class="programlisting">    self.moveUpAction = [SKAction moveByX:0
                        y:SPACE_BG_ONE_TIME_MOVE_DISTANCE
                        duration:SPACE_BG_ONE_TIME_MOVE_TIME];
    self.moveDownAction = [SKAction moveByX:0
                          y:-SPACE_BG_ONE_TIME_MOVE_DISTANCE
                          duration:SPACE_BG_ONE_TIME_MOVE_TIME];</pre></div></li><li class="listitem" value="4">Now implement a delegate method of <code class="email">UIResponder</code>, which detects touches and UI Events. The method inputs touches as <code class="email">NSSet</code> from which any touch is taken and converted into a position with respect to the scene on which the touch event occurred.<div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    UITouch *touch = [touches anyObject];
    
    CGPoint touchLocation = [touch locationInNode:self.scene];
}</pre></div></li></ol><div></div><p class="calibre8">Now, using this <code class="email">touchLocation</code> and <code class="email">SpaceShip</code> position, the code decides when to apply an up or a <a id="id85" class="calibre1"/>down action on the spaceship. It also checks the bounds of the screen so that the spaceship does not move outside the screen.</p><p class="calibre8">This is what the code looks like:</p><div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    UITouch *touch = [touches anyObject];
    
    CGPoint touchLocation = [touch locationInNode:self.scene];
    
    CGPoint spaceShipPosition = self.spaceShipSprite.position;
    CGFloat minYLimitToMove = SPACE_BG_ONE_TIME_MOVE_DISTANCE;
    CGFloat maxYLimitToMove =
    self.frame.size.height - SPACE_BG_ONE_TIME_MOVE_DISTANCE;
    if(touchLocation.y &gt; spaceShipPosition.y)
    {
        if (spaceShipPosition.y &lt; maxYLimitToMove)
        {
            [self.spaceShipSprite runAction:self.moveUpAction];
        }
    }
    else
    {
        if (spaceShipPosition.y &gt; minYLimitToMove)
        {
            [self.spaceShipSprite runAction:self.moveDownAction];
        }
    }
}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec37" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Whenever the user taps on the screen, a delegate method of <code class="email">UIResponder</code> is called.</p><div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
}</pre></div><p class="calibre8">In this method, the position of the touch is converted into local coordinates of <code class="email">SKScene</code>. Based on the location detected, it is compared to the spaceship location and up or down action is applied on it.</p><p class="calibre8">Finally, as an <a id="id86" class="calibre1"/>outcome of this chapter, you have a small fundamental game with an environment of blue sky with white clouds moving with an infinite scroll and a spaceship flying up and down in a linear motion.</p><p class="calibre8">This is what the game looks like now:</p><div><img src="img/00024.jpeg" alt="How it works..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec38" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">There can be a lot of other animation that can be used to animate the ship. All the previously discussed animation actions can be used over the ship. A consolidated result of these actions can be used in several places in the games. In the next chapter, we will learn about the animations in more detail and about effects.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec39" class="calibre1"/>See also</h2></div></div></div><p class="calibre8">The chapter has already given you insights about the animation that can be done on sprites and nodes. You can also visit Apple's developer documentation for more details. You have learned enough in the chapter to get you started with the animation and actions on the sprites.</p></div></div></body></html>