<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Exploring SELinuxFS</h1></div></div></div><p>In the last few chapters, we saw SELinuxFS surface on numerous occasions. From its entry in <code class="literal">/proc/filesystems</code> to the policy load in the init daemon, it sees frequent use in an SELinux-enabled system. SELinuxFS is the kernel-to-userspace interface and the foundation on which higher userspace idioms and <code class="literal">libselinux</code> are built. In this chapter, we will explore the capabilities of this filesystem for a deeper understanding of how the system works. Specifically, we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determine how to find the mount point of the SELinux filesystem</li><li class="listitem" style="list-style-type: disc">Extract status information about our current SELinux system</li><li class="listitem" style="list-style-type: disc">Modify our SELinux system status on the fly from the shell and through code</li><li class="listitem" style="list-style-type: disc">Investigate ProcFS interfaces</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Locating the filesystem</h1></div></div></div><p>The <a id="id137" class="indexterm"/>first thing we need to do is locate the mount point for the filesystem. <code class="literal">libselinux</code> mounts the filesystem in either of two places: <code class="literal">/selinux</code> (by default) or <code class="literal">/sys/fs/selinux</code>. However, this is not a strict requirement and can be altered with a call to void <code class="literal">set_selinuxmnt(char *mnt)</code>, which sets the SELinux mount point location. However, this should happen and should not need any adjustment in most circumstances.</p><p>The best way to find the mount point in the system is by running the mount command and finding the location of the filesystem. From the serial console, issue the following commands:</p><div><pre class="programlisting">
<strong>root@udoo:/ # mount | grep selinux</strong>
<strong>selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</strong>
</pre></div><p>As you can see, the mount point is <code class="literal">/sys/fs/selinux</code>. Let's go to that directory by issuing the following command at the serial terminal prompt:</p><div><pre class="programlisting">
<strong>root@udoo:/ # cd /sys/fs/selinux</strong>
<strong>root@udoo:/sys/fs/selinux #</strong>
</pre></div><p>You are<a id="id138" class="indexterm"/> now in the root of the SELinux filesystem.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Interrogating the filesystem</h1></div></div></div><p>You <a id="id139" class="indexterm"/>can interrogate SELinuxFS to find out what the kernel's highest supported policy version is. This is useful when you begin to work with systems you did not build from source. It is also useful when you do not have direct access to the KConfig file. It is important to note that both DAC and MAC permissions apply to this filesystem. With respect to MAC and SELinux, the access vectors for this are enumerated in class security in the policy file located at <code class="literal">external/sepolicy/access_vectors</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # echo 'cat policyvers'</strong>
<strong>23</strong>
</pre></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>In the previous command, and in several commands to follow, we do not just print the files with the <code class="literal">cat</code> command. This is because these files do not have a trailing newline at the end of the file. Without the newline, the command prompt following the command's execution would be at the end of the last line of the output. Wrapping the <code class="literal">cat</code> command with <code class="literal">echo</code> guarantees a newline. An alternate way to get the same effect is by using <code class="literal">cat policyvers ; echo</code>.</p></div></div><p>As we expected, the supported version is 23. As you recall, we set this value in <a class="link" href="ch04.html" title="Chapter 4. Installation on the UDOO">Chapter 4</a>, <em>Installation on the UDOO</em> while configuring the kernel to enable SELinux using <code class="literal">make menuconfig</code> from the <code class="literal">kernel_imx</code> directory. This is also accessible by the <code class="literal">libselinux</code> API:</p><div><pre class="programlisting">
<strong>int security_policyvers(void);</strong>
</pre></div><p>It should not require any elevated permissions and is readable by anyone on the system.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec16"/>The enforce node</h2></div></div></div><p>In previous<a id="id140" class="indexterm"/> chapters, we discussed that SELinux operates in two <a id="id141" class="indexterm"/>modes, <strong>enforcing</strong> and <strong>permissive</strong>. Both modes log policy violations, however, enforcing <a id="id142" class="indexterm"/>mode causes the kernel to deny access to<a id="id143" class="indexterm"/> the resource and return an error to the calling userspace process (for example, <code class="literal">EACCESS</code>). SELinuxFS has an interface to query this status—the file node <code class="literal">enforce</code>. Reading from this file returns the status <code class="literal">0</code> or <code class="literal">1</code> depending on whether we are running in permissive or enforcing mode, respectively:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # echo 'cat enforce' </strong>
<strong>0</strong>
</pre></div><p>As you can see, our system is in permissive mode. Android has a toolbox command for printing this as well. This command returns the status <code class="literal">Permissive</code> or <code class="literal">Enforcing</code> depending on whether we are running in a permissive or enforcing mode, respectively:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # getenforce</strong>
<strong>Permissive</strong>
</pre></div><p>You<a id="id144" class="indexterm"/> can also write to the <code class="literal">enforce</code> file. The DAC permissions<a id="id145" class="indexterm"/> for this filesystem are:</p><div><pre class="programlisting">
<strong>Owner: root read, write</strong>
<strong>Group: root read</strong>
<strong>Others: read</strong>
</pre></div><p>Anyone can get the enforcing status, but to set it, you must be the root user. The MAC permission required for this is:</p><div><pre class="programlisting">
<strong>class: security </strong>
<strong>vector: setenforce</strong>
</pre></div><p>A command called <code class="literal">setenforce</code> can change the status:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # setenforce 0</strong>
</pre></div><p>To see what the command does, run it in <code class="literal">strace</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # strace setenforce 0</strong>

<strong>...</strong>
<strong>open("/proc/self/task/3275/attr/current", O_RDONLY) = 4</strong>
<strong>brk(0x41d80000) = 0x41d80000</strong>
<strong>read(4, "u:r:init_shell:s0\0", 4095) = 18</strong>
<strong>close(4) = 0</strong>
<strong>open("/sys/fs/selinux/enforce", O_RDWR) = 4</strong>
<strong>write(4, "0", 1) </strong>
<strong>...</strong>
</pre></div><p>As we can see, the interface to <code class="literal">enforce</code> is as simple as writing <code class="literal">0</code> or <code class="literal">1</code>. The function in <code class="literal">libselinux</code> to do this is <code class="literal">int security_setenforce(int value)</code>. Another interesting artifact of the preceding command is we can see <code class="literal">procfs</code> was accessed. SELinux has some additional entries in <code class="literal">procfs</code> as well. Those will be covered further in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec17"/>The disable file interface</h2></div></div></div><p>SELinux<a id="id146" class="indexterm"/> can also be disabled at runtime using<a id="id147" class="indexterm"/> the <code class="literal">disable</code> file interface. However, the kernel must be built with <code class="literal">CONFIG_SECURITY_SELINUX_DISABLE=y</code>. Our kernel was not built with this option. This file is write only by owner and has no specific MAC permission associated with it. We recommend keeping this option disabled. Additionally, SELinux can be disabled before a policy is loaded. Even when the option is enabled, once a policy is loaded, it is disabled.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec18"/>The policy file</h2></div></div></div><p>The <code class="literal">policy</code> file <a id="id148" class="indexterm"/>lets you read the current SELinux policy file that<a id="id149" class="indexterm"/> was loaded into the kernel. This can be read and saved to disk:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # cat policy &gt; /sdcard/policy</strong>
</pre></div><p>By enabling the <code class="literal">adb</code> interface, you can now extract it from the device and analyze it on the host with the standard SELinux tools. The DAC permissions on this file are owner: <code class="literal">root</code>, <code class="literal">read</code>. There is no SELinux permission specific to this file.</p><p>The inverse to the <code class="literal">policy</code> file is the <code class="literal">load</code> file. We have seen this file appear when the policy file is loaded by init using the <code class="literal">libselinux</code> API:</p><div><pre class="programlisting">
<strong>int security_load_policy(void *data, size_t len);</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec19"/>The null file</h2></div></div></div><p>The <code class="literal">null</code> file<a id="id150" class="indexterm"/> is used by SELinux to redirect unauthorized file accesses <a id="id151" class="indexterm"/>when domain transitions occur. Remember that a domain transition is when you transition from one context to another. In most cases, this occurs when a program performs a fork and exec function, but this could happen programmatically. In either case, the process has file references it can no longer access, and to help keep processes from crashing, they just write/read from the SELinux null device.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec20"/>The mls file</h2></div></div></div><p>One of the <a id="id152" class="indexterm"/>capabilities our system has is that our current policy<a id="id153" class="indexterm"/> is using <strong>multilevel security</strong> (<strong>MLS</strong>) support. This is either <code class="literal">0</code> or <code class="literal">1</code>, based on <a id="id154" class="indexterm"/>whether the loaded policy file is using it. Since we have it enabled, we would expect to see <code class="literal">1</code> from this file:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # echo 'cat mls'</strong>
<strong>1</strong>
</pre></div><p>The <code class="literal">mls</code> file is readable by all and has a corresponding SELinux API:</p><div><pre class="programlisting">
<strong>int is_selinux_mls_enabled(void)</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec21"/>The status file</h2></div></div></div><p>The <code class="literal">version</code> file <a id="id155" class="indexterm"/>allows a mechanism by which you can be informed <a id="id156" class="indexterm"/>of updates that occur within SELinux. One such example would be when a policy reload occurs. A <strong>userspace object manager</strong> could cache decision<a id="id157" class="indexterm"/> results and use the <code class="literal">reload</code> event as a trigger to flush their cache. The <code class="literal">status</code> file is read only by everyone and has no specific MAC permissions. The <code class="literal">libselinux</code> API interface is:</p><div><pre class="programlisting">
<strong>int selinux_status_open(int fallback);</strong>
<strong>void selinux_status_close();</strong>
<strong>int selinux_status_updated(void);</strong>
<strong>int selinux_status_getenforce(void);</strong>
<strong>int selinux_status_policyload(void);</strong>
<strong>int selinux_status_deny_unknown(void);</strong>
</pre></div><p>By checking the status structure, you can detect changes and flush the cache. Currently, however, you are missing this API in your <code class="literal">libselinux</code>, but we'll correct that in <a class="link" href="ch07.html" title="Chapter 7. Utilizing Audit Logs">Chapter 7</a>, <em>Utilizing Audit Logs</em>.</p><p>There are many SELinuxFS files in the file tree; our intent here was only to cover several files because of their importance or pertinence to what we've done and where we're going. We did not cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">access</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">checkreqprot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">commit_pending_bools</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">context</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">create</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">deny_unknown</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">member</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">reject_unknown</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">relabel</code></li></ul></div><p>The use of these files is not simple and is typically done by userspace object managers that are using the <code class="literal">libselinux</code> API to abstract the complexities.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec22"/>Access Vector Cache</h2></div></div></div><p>SELinuxFS<a id="id158" class="indexterm"/> also has some directories you can explore. The <a id="id159" class="indexterm"/>first is <code class="literal">avc</code>. This stands for "Access Vector Cache" and can be used to get statistics about the security server in the kernel:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux # cd avc/</strong>
<strong>root@udoo:/sys/fs/selinux/avc # ls</strong>
<strong>cache_stats</strong>
<strong>cache_threshold</strong>
<strong>hash_stats</strong>
</pre></div><p>All these files can be read with the <code class="literal">cat</code> command:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/avc # cat cache_stats</strong>
<strong>lookups hits misses allocations reclaims frees</strong>
<strong>285710 285438 272 272 128 128</strong>
<strong>245827 245409 418 418 288 288</strong>
<strong>267511 267227 284 284 192 193</strong>
<strong>214328 213883 445 445 288 298</strong>
</pre></div><p>The <code class="literal">cache_stats</code> file is readable by all and requires no special MAC permissions.</p><p>The next <a id="id160" class="indexterm"/>file to look at is <code class="literal">hash_stats</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/avc # cat hash_stats</strong>
<strong>entries: 512</strong>
<strong>buckets used: 284/512</strong>
<strong>longest chain: 7</strong>
</pre></div><p>The <a id="id161" class="indexterm"/>underlying data structure for the Access Vector Cache is a hash table; <code class="literal">hash_stats</code> lists the current properties. As we can see in the output of the preceding command, we have 512 slots in the table, with 284 of them in use. For collisions, we have the longest chain at 7 entries. This file is world readable and requires no special MAC permissions. You can modify the number of entries in this table through the <code class="literal">cache_threshold</code> file.</p><p>The <code class="literal">cache_threshold</code> file<a id="id162" class="indexterm"/> is used to tune the number of entries in the <code class="literal">avc</code> hash table. It is world readable and owner writeable. It requires the SELinux permission <code class="literal">setsecparam</code>, and can be written to and read from with the following simple commands, respectively:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/avc # echo "1024" &gt; cache_threshold </strong>
<strong>root@udoo:/sys/fs/selinux/avc # echo 'cat cache_threshold'</strong>
<strong>1024</strong>
</pre></div><p>You can disable the cache by writing <code class="literal">0</code>. However, outside the benchmarking tests, this is not encouraged.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec23"/>The booleans directory</h2></div></div></div><p>The second <a id="id163" class="indexterm"/>directory to look into is <code class="literal">booleans</code>. An SELinux <code class="literal">boolean</code> allows policy statements to change dynamically via <code class="literal">boolean</code> conditions. By<a id="id164" class="indexterm"/> changing the <code class="literal">boolean</code> state, you can affect the behavior of the loaded policy. The current policy does not define any booleans; so this directory is empty. In policies that define booleans, the directory would be populated with files named after each boolean. You can then read and write to these files to change the <code class="literal">boolean</code> state. The Android toolbox has been modified to include the <code class="literal">getsebool</code> and <code class="literal">setsebool</code> commands. The <code class="literal">libselinux</code> API also exposes these capabilities:</p><div><pre class="programlisting">
<strong>int security_get_boolean_names(char ***names, int *len);</strong>
<strong>int security_get_boolean_pending(const char *name);</strong>
<strong>int security_get_boolean_active(const char *name);</strong>
<strong>int security_set_boolean(const char *name, int value);</strong>
<strong>int security_commit_booleans(void);</strong>
<strong>int security_set_boolean_list(size_t boolcnt, SELboolean * boollist, int permanent);</strong>
</pre></div><p>Booleans <a id="id165" class="indexterm"/>are transactional. This means it is an all or <a id="id166" class="indexterm"/>nothing set. When you use <code class="literal">security_set_boolean*</code>, you must call <code class="literal">security_commit_booleans()</code> to make it take effect. Unlike Linux desktop systems, permanent booleans are not supported. Changing the runtime value does not persist across reboots. Also, on Android, if you are attempting Android <strong>Compatibility Test Suite</strong> (<strong>CTS</strong>) compliance, booleans will cause the tests to fail. Booleans<a id="id167" class="indexterm"/> can have varying DAC permissions based on the target, but they always require the SELinux permission, <code class="literal">setbool</code>.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>You<a id="id168" class="indexterm"/> must pass the Android Compatability Test Suite for Android branding. More on CTS can be found at <a class="ulink" href="https://source.android.com/compatibility/cts-intro.html">https://source.android.com/compatibility/cts-intro.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec24"/>The class directory</h2></div></div></div><p>The<a id="id169" class="indexterm"/> next directory to look at is <code class="literal">class</code>. The <code class="literal">class</code> directory <a id="id170" class="indexterm"/>contains all the classes defined in the <code class="literal">access_vectors</code> SELinux policy file or via the <code class="literal">class</code> keyword in the SELinux policy language. For each class defined in the policy, a directory exists with the same name. For instance, run the following on the serial terminal:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/class # ls -la</strong>
<strong>...</strong>
<strong>dr-xr-xr-x root root 1970-01-02 01:58 peer</strong>
<strong>dr-xr-xr-x root root 1970-01-02 01:58 process</strong>
<strong>dr-xr-xr-x root root 1970-01-02 01:58 property_service</strong>
<strong>dr-xr-xr-x root root 1970-01-02 01:58 rawip_socket</strong>
<strong>dr-xr-xr-x root root 1970-01-02 01:58 security</strong>
<strong>...</strong>
</pre></div><p>As you can see from the preceding command, there are quite a few directories. Let's examine the <code class="literal">property_service</code> directory. This directory was chosen because it is only one defined on Android. However, the files present in each directory are the same and include <code class="literal">index</code> and <code class="literal">perms</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/class/property_service # ls</strong>
<strong>index</strong>
<strong>perms</strong>
</pre></div><p>The mapping between string and some arbitrary integer that is defined in the SELinux kernel<a id="id171" class="indexterm"/> module is <code class="literal">index</code>. A directory that contains all the <a id="id172" class="indexterm"/>permissions possible for that class is <code class="literal">perms</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/class/property_service # cd perms/</strong>
<strong>root@udoo:/sys/fs/selinux/class/property_service/perms # ls</strong>
<strong>set</strong>
</pre></div><p>As you can see, the <code class="literal">set</code> access vector is available for the <code class="literal">property_service</code> class. The <code class="literal">class</code> directory can be very beneficial to observe a policy file already loaded in a system.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec25"/>The initial_contexts directory</h2></div></div></div><p>The<a id="id173" class="indexterm"/> next directory entry to peer into is <code class="literal">initial_contexts</code>. This is the static mapping of the initial security contexts, better known <a id="id174" class="indexterm"/>as <strong>security identifier</strong> (<strong>sid</strong>). This map tells the SELinux <a id="id175" class="indexterm"/>system which context should be used to start each kernel object:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/initial_contexts # ls</strong>
<strong>any_socket</strong>
<strong>devnull</strong>
<strong>file</strong>
<strong>...</strong>
</pre></div><p>We can see what the initial sid for <code class="literal">file</code> is by performing:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/initial_contexts # echo 'cat file'</strong>
<strong>u:object_r:unlabeled:s0</strong>
</pre></div><p>This corresponds to the entry in <code class="literal">external/sepolicy/initial_sid_contexts</code>:</p><div><pre class="programlisting">...
sid file u:object_r:unlabeled:s0
...</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec26"/>The policy_capabilities directory</h2></div></div></div><p>The last<a id="id176" class="indexterm"/> directory to look into is <code class="literal">policy_capabilities</code>. This directory defines any additional capabilities the policy might have. For <a id="id177" class="indexterm"/>our current setup, we should have:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/policy_capabilities # ls</strong>
<strong>network_peer_controls</strong>
<strong>open_perms</strong>
</pre></div><p>Each file entry contains a boolean indicating whether the feature is enabled:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/policy_capabilities # echo 'cat open_perms'</strong>
<strong>1</strong>
</pre></div><p>The entries are readable by all and writeable by none.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec27"/>ProcFS</h2></div></div></div><p>We alluded to <a id="id178" class="indexterm"/>some of the procfs interfaces that are being exported. Much<a id="id179" class="indexterm"/> of what is discussed is the security contexts, so that means the shell should have some security context associated with it... but how do we achieve this? Since this is a general mechanism that all LSMs use, the security contexts are both read and written through procfs:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/policy_capabilities # echo 'cat /proc/self/attr/current'</strong>
<strong>u:r:init_shell:s0</strong>
</pre></div><p>You can also get per-thread contexts as well:</p><div><pre class="programlisting">
<strong>root@udoo:/sys/fs/selinux/policy_capabilities # echo '/proc/self/task/2278/attr/current'</strong>
<strong>u:r:init_shell:s0</strong>
</pre></div><p>Just replace <code class="literal">2278</code> with the thread ID you want.</p><p>The DAC permissions on the current file are read and write for everyone, but those files are typically very restricted by MAC permissions. Typically, only the process that owns the procfs entry can read the files, and you must have both standard write permissions and a combination of <code class="literal">setcurrent</code>. Note that the "from" and "to" domains must be allowed <a id="id180" class="indexterm"/>using a <strong>dyntransition</strong>. To read, you must have <code class="literal">getattr</code>. All of these permissions are attained from the security class, <code class="literal">process</code>. The <code class="literal">libselinux</code> API functions <code class="literal">getcon</code> and <code class="literal">setcon</code> allow you to manipulate <code class="literal">current</code>.</p><p>The <code class="literal">prev</code> file can be used to find the previous context you switched from. This file is not writeable:</p><div><pre class="programlisting">
<strong>root@udoo:/proc/self/attr # echo 'cat prev'</strong>
<strong>u:r:init:s0</strong>
</pre></div><p>Our serial terminal's former domain or security context was <code class="literal">u:r:init:s0</code>.</p><p>The <code class="literal">exec</code> file is used to set the label for children processes. This is set before running an exec. All the permissions on these files are the same with respect to the MAC permissions used to actually set them. The caller attempting to set this must also hold <code class="literal">setexec</code> from the <code class="literal">process</code> class. The libselinux API <code class="literal">int setexeccon(security_context_t context)</code> and <code class="literal">int getexeccon(security_context_t *context)</code> can be used for setting and retrieving the label.</p><p>The <code class="literal">fscreate</code>, <code class="literal">keycreate</code>, and <code class="literal">sockcreate</code> files do similar things. When a process creates any one of the corresponding objects, <code class="literal">fs</code> objects (files, named pipes, or other objects), keys, or sockets, the values set here are used. The caller must also hold <code class="literal">setfscreate</code>, <code class="literal">setsockcreate</code>, and <code class="literal">setkeycreate</code> from the <code class="literal">process</code> class. The following SELinux API is used to alter these:</p><div><pre class="programlisting">
<strong>int set*createcon(security_context_t context);</strong>
<strong>int get*createcon(security_context_t *con);</strong>
</pre></div><p>Where <code class="literal">*</code> can be <code class="literal">fs</code>, <code class="literal">key</code>, or <code class="literal">socket</code>.</p><p>It's important<a id="id181" class="indexterm"/> to note that these special <code class="literal">process</code> class permissions<a id="id182" class="indexterm"/> give you the ability to change the <code class="literal">proc/attr</code> file. You still need to get through the DAC permissions and any SELinux permissions set on the file objects themselves. Then and only then do you need the additional permission, such as <code class="literal">setfscreate</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Java SELinux API</h1></div></div></div><p>Similar <a id="id183" class="indexterm"/>APIs to the C APIs discussed previously exist for Java as well. In this case, it is assumed you will build the code with the platform, as these are not public APIs shipped with the Android SDK. The API is located at <code class="literal">frameworks/base/core/java/android/os/SELinux.java</code>. However, this is a very limited subset of the API.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we explored the interface between the kernel and userspace with respect to SELinux, and reinforced the concepts of access vector class and security context. In the next chapter, we will perform some upgrades to our system and look at the audit logs getting one step closer to our ultimate goal—an operable device in SELinux enforcing mode. We say operable because we can put it in enforcing mode now. However, if you do it now via <code class="literal">setenforce 1</code> on a UDOO, your device will become unstable. On our system, for example, the browser fails to launch if we do this.</p></div></body></html>