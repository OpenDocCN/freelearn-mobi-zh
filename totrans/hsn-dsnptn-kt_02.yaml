- en: Working with Creational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover how classical creational patterns are implemented
    in Kotlin. These patterns deal with *how* and *when* you create your objects. Mastering
    these patterns will allow you to manage your objects better, adapt well to changes,
    and write code that is easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most popular single guy in the neighborhood. Everybody knows him,
    everybody talks about him, and anybody can find him easily.
  prefs: []
  type: TYPE_NORMAL
- en: Even people who will frown when other design patterns are mentioned will know
    it by name. At some point, it was even proclaimed an anti-pattern, but only because
    of its wide popularity. So, for those who are hearing about it for the first time,
    what is this pattern about?
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, if you have an object, you can create as many of its instances as
    you want. Say, for example, you have the `Cat` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can produce as many of its instances (cats, to be precise), as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And there's no problem with that.
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted to disallow such behavior? Clearly, we have to create an object
    in some way for the first time. But from the second time on, we need to recognize
    that this object was initialized once already, and returns its instance instead.
    That's the main idea behind being a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: In Java and some other languages, this task is quite complex. It's not enough
    to simply make the constructor private and *remember* that the object was initialized
    at least once already. We also need to prevent race conditions, where two separate
    threads try to initialize it exactly at the same time. If we allowed that, it
    would break the entire concept of a Singleton, as two threads would hold references
    to two instances of the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving this problem in Java requires doing one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting that a Singleton will initialize eagerly when your application starts,
    and not when it is first accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing some smart code to prevent such race conditions and still stay performant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a framework that already solves it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kotlin just introduces a reserved keyword for that. Behold, an object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You don't need curly brackets there. They're just for visual consistency.
  prefs: []
  type: TYPE_NORMAL
- en: This combines declaration and initialization in one keyword. From now on, `MySingleton`
    can be accessed from anywhere in your code, and there'll be exactly one instance
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this object doesn''t do anything interesting. Let''s make it count
    the number of invocations instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t test it for thread safety yet this is a topic that will be covered
    in [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7), *Threads
    and Coroutines*, which deals with threads. For now, we test it only to see how
    we call our Singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will print numbers between 1 and 10, as expected. As you can see, we don't
    need the `getInstance()` method at all.
  prefs: []
  type: TYPE_NORMAL
- en: The `object` keyword is used for more than just creating Singletons. We'll discuss
    it in depth later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects can''t have constructors. If you want some kind of initialization logic
    for your Singleton, such as loading data from the database or over the network
    for the first time, you can use the `init` block instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is also demonstrated that Singletons in Kotlin are initialized lazily, and
    not eagerly, as some could suspect from the ease of their declaration. Just like
    regular classes, objects can extend other classes and implement interfaces. We'll
    come back to this in [Chapter 10](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7),
    *Idioms and Anti-Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory Method is all about creating objects. But why do we need a method
    to create objects? Isn't it what constructors are all about?
  prefs: []
  type: TYPE_NORMAL
- en: Well, constructors have their inherent limitations, which we're about to discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start with the Factory Method formalized in the book *Design Patterns* by Gang of Four.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the first patterns I teach my students. They're usually very
    anxious about the whole concept of design patterns, since it has an aura of mystery
    and complexity.  So, what I do is ask them the following question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you have some class declaration, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Could you write a function that returns a new instance of the class? Most of
    them would succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that everything works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Well, that's really simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: Now, based on the argument we provide it, can this method create one of two
    objects?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we now have a `Dog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Choosing between two types of objects to instantiate would require only passing
    an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can''t always return a `Cat` now. So we create a common interface
    to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left is to use the `when` expression to return an instance of the correct
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s what Factory Method is all about:'
  prefs: []
  type: TYPE_NORMAL
- en: Get some value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return one of the objects that implement the common interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This pattern is very useful when creating objects from a configuration. Imagine
    we have a text file with the following contents that came from a veterinary clinic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we would like to create an empty profile for each animal. Assuming we''ve
    already read the file contents and split them into a list, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`listOf` is a function that comes from the Kotlin standard library that creates
    an immutable list of provided objects.'
  prefs: []
  type: TYPE_NORMAL
- en: If your Factory Method doesn't need to have a state, we can leave it as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to assign a unique sequential identifier for each animal?
    Take a look at the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can override values inside the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our factory becomes a proper class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So we''ll have to initialize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This was a pretty straightforward example. We provided a common interface for
    our objects (`Animal`, in this case), then based on some arguments, we decided
    which concrete class to instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we decided to support different breeds? Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like the `downTo` function we saw in [Chapter 1](part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7),
    *Getting Started with Kotlin*, it looks like an operator, but it''s a function
    that creates a pair of objects: (`cat`, `siamese`, in our case). We''ll come back
    to it when we discuss the `infix` function in depth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can delegate the actual object instantiation to other factories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The factory repeats the same pattern again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can make sure that you understand this example by implementing `Beagle`,
    `Bulldog`, `CatFactory`, and all the different breeds of cats by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last point to note is how we''re now calling our `AnimalFactory` with a
    pair of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is called a **destructuring declaration**, and is useful especially when
    dealing with such pairs of data.
  prefs: []
  type: TYPE_NORMAL
- en: Static Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Static Factory Method was popularized by Joshua Bloch in his book *Effective
    Java*. To understand it better, let''s look at the examples from Java standard
    library itself, the `valueOf()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Both the constructor and the `valueOf()` method receive `String` as input and
    produce `Long` as output.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is the Static Factory Method sometimes better than a constructor?
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the Static Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the advantages of a Static Factory Method over constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a better name for the constructor, what it expects, and, sometimes,
    what it produces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We usually don't expect exceptions from a constructor. Exceptions from a regular
    method, on the other hand, are totally valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaking of expectations, we expect the constructor to be fast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But those are more psychological advantages. There are also some technological
    advantages to this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Static Factory Method may provide caching, as `Long` actually does. Instead
    of always returning a new instance for any value, `valueOf()` checks in-cache
    whether this value was already parsed. If it is, it returns a cached instance.
    Repeatedly calling the Static Factory Method with the same values may produce
    less garbage for collection than using constructors all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When calling the constructor, we always instantiate the class we specify. On
    the other hand, calling a Static Factory Method may produce either instance of
    the class, or one of its subclasses. We'll come to this after discussing the implementation
    of this design pattern in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Static Factory Method in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already discussed the `object` keyword earlier in the *Singleton* section.
    Now we'll see another use of it is a `companion` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, Static Factory Methods are declared `static`. But in Kotlin, there''s
    no such keyword. Instead, methods that don''t belong to an instance of a class
    can be declared inside a `companion` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Companion objects may have a name: companion object Parser, for example. But
    this is only for clarity of what the goal of this object is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a `companion` object doesn''t require instantiating a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, calling it on an instance of a class simply won''t work, unlike Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The class may have only one companion object.
  prefs: []
  type: TYPE_NORMAL
- en: Companion object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, Static Factory Methods are declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'They are called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: But in Kotlin, there's no such keyword as Static. Instead, methods that don't
    belong to an instance of a class can be declared inside a companion object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed the `object` keyword earlier, in the section *Singletons*. Now,
    we''ll look at another use of this important keyword using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, inside our class, we have declared an object that is prefixed
    by the keyword `companion`.
  prefs: []
  type: TYPE_NORMAL
- en: This object has its own set of functions. What's the benefit of this? You may
    wonder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like a Java Static method, calling a `companion` object doesn''t require
    the instantiation of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, calling it on an instance of a class simply won''t work, which is
    not the case with Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A `companion` object may have a name-Parser, for example. But this is only for
    clarity of what the goal of this object is.
  prefs: []
  type: TYPE_NORMAL
- en: The class may have only one `companion` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a `companion` object, we can achieve exactly the same behavior that
    we see in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now instantiate our object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin proves itself a very practical language. Every keyword in it has a down-to-earth
    meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract Factory is a greatly misunderstood pattern. It has a notorious reputation
    for being very complex and bizarre but actually, it's quite simple. If you understood
    the Factory Method, you'll understand this one in no time. This is because Abstract
    Factory is a factory of factories. That's all there is to it, really. The factory
    is a function or class that's able to create other classes. Abstract Factory is
    a class that creates factories.
  prefs: []
  type: TYPE_NORMAL
- en: You may understand that and still wonder what the usages of such a pattern may
    be. The main usage of Abstract Factory in the real world would probably be frameworks,
    most notably Spring Framework, which uses the notion of Abstract Factory to create
    its components out of annotations and XML files. But since creating our own framework
    may be quite tiresome, let's take another example where this pattern will be very
    useful—a strategy game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call it *CatsCraft 2: Revenge of the Dogs*.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our strategy game will consist of buildings and units. Let''s start with declaring
    what all buildings share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All buildings should implement the `build()` function. Here we see generics
    in Kotlin for the first time, so let's discuss them a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to generics in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are a way to specify the relationships between types. Well, that didn't
    help explain much, did it? Let's try again. Generics are an abstraction of types.
    Nope, still awful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll try an example, then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Ok, that's easy; we've covered it a lot of times. This code simply creates a
    list of strings. But what does it actually mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This line doesn''t compile. That''s because the `mutableListOf()` function
    uses generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Generics create an expectation. No matter which type we use to create our list,
    from now on we can only put that type in it. It's a great language feature because,
    on the one hand, we can generalize our data structures or algorithms. No matter
    what types they hold, they'll still work in exactly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we still have type safety. The `listOfStrings`. `first()` function
    is guaranteed to return a `String` (in this case) and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of generics, Kotlin uses an approach that is similar to, but slightly
    different from, Java. We won't cover all the aspects of generics in this section,
    but will only provide some guidance to better understand this example. As we go
    on, we'll encounter more uses of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a class called `Box`. Boring, I know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s great about this box, though, is that by using generics, I can put
    just about anything in it, for example, a cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When I create an instance of a box, I specify what it can hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At compile time, the generics will make sure that it will only hold objects
    of the correct type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you may know, Java uses the wildcards `?` extends, and super keywords to
    specify read-only and write-only types.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin uses the concepts of `in`, `out`, and `where`.
  prefs: []
  type: TYPE_NORMAL
- en: A type that is marked as `in` can be used as a parameter but not as a return
    value. This is also called covariance. In fact, it means that we can return `ProducedUnit` or
    something that inherits from it, but not something that is above `ProducedUnit` in
    the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Types that are marked as `out` can be used only as a return value, not as a
    parameter. This is called contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we may introduce constraints on types using the `where` keyword.
    In our case, we require that the first type implements the `Type` interface, while
    the second type implements the `Unit` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The names of the types themselves, `UnitType` and `ProducedUnit`, could be anything
    we want, `T` and `P`, for example. But for the sake of clarity, we'll use more
    verbose names.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our bases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HQ is a special building that can produce other buildings. It keeps track of
    all the buildings it had built up until now. The same type of building can be
    built more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering what the star (`*`) means as regards generics. It's called
    a star projection, and it means *I don't know anything about this type*. It's
    similar to Java's raw types, but it's type safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'All other buildings produce units. Units can be either infantry or armored
    vehicle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Infantry can be either riflemen or rocket soldier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see the `enum` keyword for the first time. Vehicles are either tanks
    or **armored personnel carriers** (**APCs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A barracks is a building that produces infantry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We don't need the `else` block in our `when`. That's because we use `enum`,
    and Kotlin makes sure that `when` on `enum` is exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vehicle factory is a building that produces different types of armored vehicles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make sure that we can build different units now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And now on to producing units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We've already seen the `listOf()` function from the standard library. It will
    create a read-only list of different units that our buildings produce. You can
    iterate over this list and make sure that those are indeed the units we require.
  prefs: []
  type: TYPE_NORMAL
- en: Making improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One may claim that having the `VehicleFactory` and `Barracks` classes is too
    cumbersome. They don't have any state, after all. Instead, we can replace them
    with objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the previous implementation of `buildBarracks()`, we can have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen two different usages of the `object` keyword: once in the Singleton
    design pattern, and another time in the Factory Method design pattern. Here is
    the third way we can use it: for creating anonymous classes on the fly. After
    all, `Barracks` is a building that, given `InfantryUnitType`, produces `Infantry`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If our logic is straightforward, we can even shorten the declaration a bit
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's go to the beginning of this chapter. We said that Abstract Factory combines
    a number of related factories. So, what's common to all factories in our case?
    They're all buildings and they all produce units.
  prefs: []
  type: TYPE_NORMAL
- en: Having that principle in mind, you could apply it to many different cases. If
    you're familiar with strategy games, usually they have at least two different
    factions. Each may have different structures and units. To achieve that, you can
    repeat this pattern as many times as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume we have two different factions now, cats and dogs, and Tanks and
    Rocket Infantry are only prerogatives of this faction. Dogs have Heavy Tanks and
    Grenadiers instead. What changes do we need to make in our system?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `HQ` becomes an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'What was `HQ` previously now becomes `CatHQ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And `DogHQ` will have to repeat the same steps, but with a different construction
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to accommodate big changes is what makes Abstract Factory so powerful
    in some use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, our objects are very simple, and have only one constructor, be it
    an empty or non-empty one. But sometimes, their creation is very complex, and
    based on a lot of parameters. We've seen one pattern already that provides *a
    better constructor*—the Static Factory Method design pattern. Now, we'll discuss
    Builder design pattern, which is somewhat similar and somewhat different.
  prefs: []
  type: TYPE_NORMAL
- en: Composing an email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a software architect, one of my main channels of communication is email.
    Probably this is true of most software development roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'An email has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An address (at least one is mandatory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CC (zero or more, optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attachment (zero or more, optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's assume I'm really lazy, and would like to schedule emails to be sent while
    I'm actually biking around the neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual scheduling logic will be postponed to [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7),
    *Threads and Coroutines*, and [Chapter 9](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7),
    *Designed for Concurrency*, which discuss scheduling and concurrency. For now,
    let''s see what our `Mail` class may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So, we've already seen `data class` in action in the previous chapters. We've
    also discussed nullable and non-nullable types, such as `String?` versus `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to discuss how collections work in Kotlin, since this is
    the first time we have a class that deals with them directly.
  prefs: []
  type: TYPE_NORMAL
- en: Collection types in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main Kotlin goals is Java interoperability. So it's no wonder that
    Kotlin collections are interoperable with Java. When you specify that your functions
    receives `List<T>`, it is actually the same Java `List<T>` you're familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: But Kotlin differentiates between mutable and immutable collections. The `listOf()` function
    is delegated to `Arrays.asList()`, and produces an immutable list, while `mutableListOf()`
    simply calls `ArrayList()`.
  prefs: []
  type: TYPE_NORMAL
- en: On top of data, Kotlin collection has many useful extension methods, which we'll
    discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an email – first attempt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, at 10 A.M., I plan to drink a coffee in my local cafe. But I also want
    to contact my manager, since my payslip didn''t arrive yesterday. I attempt to
    create my first email like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This may have worked in Java, but in Kotlin this wouldn''t compile, since we
    cannot pass `null` to `List<String>`. Null-safety is very important in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that since our constructor receives a lot of arguments, I had to put in
    some comments, so I wouldn't get lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin compiler is smart enough to infer the type of list that we pass.
    Since our constructor receives `List<String>`, it''s enough to pass `listOf()`
    for an empty list. We don''t need to specify the type like so: `listOf<String>()`.
    In Java, Diamond Operator serves the same purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, but I forgot about attachments. Let''s change our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'But then our instantiation stops compiling again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This clearly becomes a mess.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an email – second attempt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try a fluent setter approach instead. We''ll have only mandatory fields
    in our constructor, and all others will become setters, so the creation of a new
    email would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a lot nicer for many reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The order of fields can now be arbitrary, unlike with the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's clearer which field is being set, no need for comments anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional fields don't need to be set at all. As an example, the CC field is
    set, while the BCC field is omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see one way of implementing this approach. There are other convenient
    ways to do it, which we''ll discuss in [Chapter 10](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7),
    *Idioms and Anti-Patterns*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Using underscores for private variables is a common convention in Kotlin. It
    allows us to avoid repeating `this.message = message` and mistakes such as `message
    = message`.
  prefs: []
  type: TYPE_NORMAL
- en: This is nice, and very similar to what we may achieve in Java. Although we did
    have to make our message mutable now. But Kotlin provides two other ways that
    you may find even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an email – the Kotlin way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like some other modern languages, Kotlin provides us with the ability to set
    *default values* for function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you would like to send an email without CC, you can do it like that
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'But what about the case where you want to send an email with BCC? Also, not
    having to specify order with fluent setters was very handy. Kotlin has *named
    arguments* for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining default parameters with named arguments makes creating complex objects
    in Kotlin a lot easier than before. There''s another way to achieve somewhat similar
    behavior: the `apply()` function. This is one of the extension functions that
    every object in Kotlin has. In order to use this approach, though, we''ll need
    to make all the optional fields variables instead of values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can create our email like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `apply()` function is the only one out of the family of **scoping functions**.
    We'll discuss how scoping functions work and are their uses in later chapters.
    Now, while my boss thinks I'm working hard sending all these emails, I can go
    back to my coffee. It's getting cold now!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an email – the Kotlin way – second attempt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try a fluent setter approach, instead. We''ll have only mandatory fields
    in our constructor, and all of the others will become setters. So to create a
    new email, we no longer need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Fluent setters allow us to chain one set call to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a lot nicer for a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The order of fields can now be arbitrary, unlike the order used with the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's clearer which field is being set; no more need for comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional fields don't need to be set at all. As an example, the CC field is
    set while the BCC field is omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at one way of implementing this approach. There are other convenient
    ways to do this, which we''ll discuss in [Chapter 10](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7), *Idioms
    and Anti-Patterns*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Using underscores for private variables is a common convention in Kotlin. It
    allows us to avoid repeating the phrase `this.message = message` and mistakes,
    such as `message = message`.
  prefs: []
  type: TYPE_NORMAL
- en: This is nice and is very similar to what we may achieve in Java, although we
    did have to make our message mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also implement a full-blown builder design pattern, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use it to create your email in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: But Kotlin provides two other ways that you may find even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern is all about customization and creating objects that are
    similar but slightly different. To understand it better, we'll start with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own PC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have a shop where you sell PCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular PC consists of the foll:'
  prefs: []
  type: TYPE_NORMAL
- en: Motherboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of your customers don't actually care what components you put in this PC.
    What they do care about is whether this PC will be able to run *Magnificent Pilfering
    Car 7* at 60fps (which is frame per second).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you decide to build it like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'So when a new customer comes in wanting to try out this game everybody is talking
    about in the neighborhood, you just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: And they are already off toward home, ready to share their newest experiences
    from MPC7\. Actually, your business goes so well that you have one PC just sitting
    there, ready for the next customer to come in.
  prefs: []
  type: TYPE_NORMAL
- en: But then another customer arrives. And this one is tech savvy. So, frankly,
    they think that for the games they play, a *nKCF 8100TZ graphic card* wouldn't
    be enough at all. They've also read that there's now *BBR6 RAM* available and
    they want *16 GB* of it. And of course, they want it right away. But they're willing
    to pay in cash.
  prefs: []
  type: TYPE_NORMAL
- en: That's the moment you wish that you could just modify this PC that's sitting
    in your warehouse a little, instead of assembling a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole idea of a prototype is to be able to clone an object easily. There
    are a number of reasons you may want to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your object is very expensive. You need to fetch it from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You create objects that are similar but different from one another, and you
    don't want to repeat similar parts over and over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also more advanced reasons to use this pattern. JavaScript language,
    for example, uses prototypes to implement inheritance-like behavior without having
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Kotlin fixes the *broken* Java `clone()` method. For data classes,
    there''s the `copy()` method, which takes an existing data class, and creates
    a new copy of it, optionally changing some of its attributes in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `clone()` method creates a shallow copy, which may be unexpected
    for less experienced developers. It's very hard to implement the `clone()` method
    correctly in Java. You can read about the various pitfalls at [https://dzone.com/articles/shallow-and-deep-java-cloning](https://dzone.com/articles/shallow-and-deep-java-cloning).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to what we've seen in the Builder design pattern, named arguments allow
    us to specify attributes that we can change in any order.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that's left is for you to count the cash and buy some more of
    those *nKCF graphic cards*. Just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned when and how to use design patterns from the Creational
    family. We learned about different usages of the `object` keyword: as Singleton,
    as a container for the Static Factory Methods, and as an anonymous implementation
    of an interface. We then saw the workings of the destructuring declaration and
    generics in Kotlin with the use of the `in`, `out`, and `where` keywords. We also
    learned about the default parameter values and named arguments, followed by the
    `copy()` function for data classes.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the second family of design patterns, Structural
    patterns. Those patterns help extend the functionality of our objects.
  prefs: []
  type: TYPE_NORMAL
