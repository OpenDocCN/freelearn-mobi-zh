- en: Working with Creational Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与创建型模式一起工作
- en: In this chapter, we'll cover how classical creational patterns are implemented
    in Kotlin. These patterns deal with *how* and *when* you create your objects. Mastering
    these patterns will allow you to manage your objects better, adapt well to changes,
    and write code that is easy to maintain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何在Kotlin中实现经典创建型模式。这些模式处理*如何*和*何时*创建你的对象。掌握这些模式将使你能够更好地管理对象，适应变化，并编写易于维护的代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Singleton
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Factory Method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Abstract Factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Builder
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造器
- en: Prototype
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: Singleton
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: This is the most popular single guy in the neighborhood. Everybody knows him,
    everybody talks about him, and anybody can find him easily.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是邻里的最受欢迎的单个男孩。每个人都认识他，每个人都谈论他，任何人都可以轻易找到他。
- en: Even people who will frown when other design patterns are mentioned will know
    it by name. At some point, it was even proclaimed an anti-pattern, but only because
    of its wide popularity. So, for those who are hearing about it for the first time,
    what is this pattern about?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使那些在其他设计模式被提及时会皱眉的人也会知道它的名字。在某个时候，它甚至被宣布为反模式，但这仅仅是因为它的广泛流行。所以，对于那些第一次听说它的人来说，这个模式是关于什么的？
- en: 'Usually, if you have an object, you can create as many of its instances as
    you want. Say, for example, you have the `Cat` class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你有一个对象，你可以创建尽可能多的其实例。比如说，你有一个`Cat`类：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can produce as many of its instances (cats, to be precise), as you want:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以生产尽可能多的其实例（具体来说，是猫），你想要多少就有多少：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And there's no problem with that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何问题。
- en: What if we wanted to disallow such behavior? Clearly, we have to create an object
    in some way for the first time. But from the second time on, we need to recognize
    that this object was initialized once already, and returns its instance instead.
    That's the main idea behind being a Singleton.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要禁止这种行为呢？显然，我们第一次必须以某种方式创建一个对象。但从第二次开始，我们需要认识到这个对象已经被初始化过一次，并返回其实例。这就是单例背后的主要思想。
- en: In Java and some other languages, this task is quite complex. It's not enough
    to simply make the constructor private and *remember* that the object was initialized
    at least once already. We also need to prevent race conditions, where two separate
    threads try to initialize it exactly at the same time. If we allowed that, it
    would break the entire concept of a Singleton, as two threads would hold references
    to two instances of the same object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和一些其他语言中，这个任务相当复杂。仅仅将构造函数设为私有并*记住*该对象已经被初始化至少一次是不够的。我们还需要防止竞态条件，即两个不同的线程试图同时初始化它。如果我们允许这样做，就会破坏单例的整个概念，因为两个线程将持有同一对象的两个实例的引用。
- en: 'Solving this problem in Java requires doing one of the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中解决此问题需要执行以下操作之一：
- en: Accepting that a Singleton will initialize eagerly when your application starts,
    and not when it is first accessed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受单例将在应用程序启动时立即初始化，而不是在首次访问时初始化
- en: Writing some smart code to prevent such race conditions and still stay performant
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一些智能代码来防止这种竞态条件，同时保持性能
- en: Using a framework that already solves it
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已经解决这个问题的框架
- en: 'Kotlin just introduces a reserved keyword for that. Behold, an object as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin只是为这个引入了一个保留关键字。看，一个如下所示的对象：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You don't need curly brackets there. They're just for visual consistency.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要那里的大括号。它们只是为了视觉一致性。
- en: This combines declaration and initialization in one keyword. From now on, `MySingleton`
    can be accessed from anywhere in your code, and there'll be exactly one instance
    of it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将声明和初始化结合在一个关键字中。从现在起，`MySingleton`可以从你的代码的任何地方访问，并且将只有一个实例。
- en: 'Of course, this object doesn''t do anything interesting. Let''s make it count
    the number of invocations instead:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个对象并没有做任何有趣的事情。让我们让它计算调用次数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We won''t test it for thread safety yet this is a topic that will be covered
    in [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7), *Threads
    and Coroutines*, which deals with threads. For now, we test it only to see how
    we call our Singleton:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会测试它的线程安全性，这是一个将在[第8章](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7)中讨论的主题，即*线程和协程*，它涉及到线程。现在，我们只测试它是如何调用我们的单例的：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will print numbers between 1 and 10, as expected. As you can see, we don't
    need the `getInstance()` method at all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按预期打印出1到10之间的数字。正如你所看到的，我们根本不需要`getInstance()`方法。
- en: The `object` keyword is used for more than just creating Singletons. We'll discuss
    it in depth later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`关键字不仅用于创建Singleton。我们稍后会深入讨论。'
- en: 'Objects can''t have constructors. If you want some kind of initialization logic
    for your Singleton, such as loading data from the database or over the network
    for the first time, you can use the `init` block instead:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不能有构造函数。如果你想为你的Singleton添加一些初始化逻辑，比如第一次从数据库或网络上加载数据，你可以使用`init`块代替：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is also demonstrated that Singletons in Kotlin are initialized lazily, and
    not eagerly, as some could suspect from the ease of their declaration. Just like
    regular classes, objects can extend other classes and implement interfaces. We'll
    come back to this in [Chapter 10](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7),
    *Idioms and Anti-Patterns*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还演示了Kotlin中的Singleton是延迟初始化的，而不是像一些人从其声明的简便性所怀疑的那样是立即初始化的。就像常规类一样，对象可以扩展其他类并实现接口。我们将在第10章中回到这一点，*惯用和反模式*。
- en: Factory Method
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: The Factory Method is all about creating objects. But why do we need a method
    to create objects? Isn't it what constructors are all about?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法完全是关于创建对象。但为什么我们需要一个方法来创建对象？这不是构造函数的全部内容吗？
- en: Well, constructors have their inherent limitations, which we're about to discuss.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，构造函数有其固有的局限性，我们即将讨论。
- en: Factory
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: We'll start with the Factory Method formalized in the book *Design Patterns* by Gang of Four.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从《设计模式》这本书中Gang of Four提出的工厂方法开始。
- en: This is one of the first patterns I teach my students. They're usually very
    anxious about the whole concept of design patterns, since it has an aura of mystery
    and complexity.  So, what I do is ask them the following question.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我教给学生们的第一个模式之一。他们通常对设计模式的整体概念非常焦虑，因为它有一种神秘和复杂的氛围。所以，我通常会问他们以下问题。
- en: 'Assume you have some class declaration, for example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些类声明，例如：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Could you write a function that returns a new instance of the class? Most of
    them would succeed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你能写一个函数返回该类的新实例吗？大多数人都能成功：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check that everything works:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一切是否正常工作：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Well, that's really simple, right?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这真的很简单，对吧？
- en: Now, based on the argument we provide it, can this method create one of two
    objects?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于我们提供的参数，这个方法能否创建两个对象之一？
- en: 'Let''s say we now have a `Dog`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在有一个`Dog`：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Choosing between two types of objects to instantiate would require only passing
    an argument:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个类型的对象之间进行实例化选择只需要传递一个参数：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of course, we can''t always return a `Cat` now. So we create a common interface
    to be returned:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在不能总是返回一个`Cat`。因此，我们创建一个公共接口来返回：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What''s left is to use the `when` expression to return an instance of the correct
    class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是使用`when`表达式返回正确类的实例：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s what Factory Method is all about:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是工厂方法的核心：
- en: Get some value.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一些值。
- en: Return one of the objects that implement the common interface.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回实现公共接口的其中一个对象。
- en: 'This pattern is very useful when creating objects from a configuration. Imagine
    we have a text file with the following contents that came from a veterinary clinic:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当从配置创建对象时，这个模式非常有用。想象一下，我们有一个文本文件，其内容如下，来自兽医诊所：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we would like to create an empty profile for each animal. Assuming we''ve
    already read the file contents and split them into a list, we can do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望为每种动物创建一个空配置文件。假设我们已经读取了文件内容并将它们分割成一个列表，我们可以做以下操作：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`listOf` is a function that comes from the Kotlin standard library that creates
    an immutable list of provided objects.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`listOf`是一个来自Kotlin标准库的函数，它创建了一个不可变列表，包含提供的对象。'
- en: If your Factory Method doesn't need to have a state, we can leave it as a function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的工厂方法不需要状态，我们可以将其留为一个函数。
- en: 'But what if we want to assign a unique sequential identifier for each animal?
    Take a look at the following code block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想为每个动物分配一个唯一的顺序标识符呢？看看下面的代码块：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we can override values inside the constructor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们可以在构造函数内部覆盖值。
- en: 'Our factory becomes a proper class now:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂现在成为一个合适的类：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So we''ll have to initialize it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要初始化它：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output for the preceding code is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This was a pretty straightforward example. We provided a common interface for
    our objects (`Animal`, in this case), then based on some arguments, we decided
    which concrete class to instantiate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的例子。我们为我们的对象提供了一个公共接口（在这个例子中是`Animal`），然后根据一些参数，我们决定实例化哪个具体类。
- en: 'What if we decided to support different breeds? Take a look at the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定支持不同的品种呢？看看下面的代码：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Much like the `downTo` function we saw in [Chapter 1](part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7),
    *Getting Started with Kotlin*, it looks like an operator, but it''s a function
    that creates a pair of objects: (`cat`, `siamese`, in our case). We''ll come back
    to it when we discuss the `infix` function in depth.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第1章](part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7)“Kotlin入门”中看到的`downTo`函数一样，它看起来像是一个操作符，但实际上是一个创建一对对象的函数：在我们的例子中是(`cat`,
    `siamese`)。当我们深入讨论`infix`函数时，我们还会回到它。
- en: 'We can delegate the actual object instantiation to other factories:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将实际的对象实例化委托给其他工厂：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The factory repeats the same pattern again:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂重复相同的模式：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can make sure that you understand this example by implementing `Beagle`,
    `Bulldog`, `CatFactory`, and all the different breeds of cats by yourself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过自己实现`Beagle`、`Bulldog`、`CatFactory`以及所有不同的猫品种来确保你理解这个例子。
- en: 'The last point to note is how we''re now calling our `AnimalFactory` with a
    pair of arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点要注意的是我们现在如何使用一对参数调用我们的`AnimalFactory`：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is called a **destructuring declaration**, and is useful especially when
    dealing with such pairs of data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**解构声明**，在处理这样的数据对时特别有用。
- en: Static Factory Method
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态工厂方法
- en: 'The Static Factory Method was popularized by Joshua Bloch in his book *Effective
    Java*. To understand it better, let''s look at the examples from Java standard
    library itself, the `valueOf()` methods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法是由Joshua Bloch在他的书《Effective Java》中推广的。为了更好地理解它，让我们看看Java标准库本身的例子，即`valueOf()`方法：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both the constructor and the `valueOf()` method receive `String` as input and
    produce `Long` as output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和`valueOf()`方法都接收`String`作为输入，并产生`Long`作为输出。
- en: So, why is the Static Factory Method sometimes better than a constructor?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么静态工厂方法有时比构造函数更好？
- en: Advantages of the Static Factory Method
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态工厂方法的优点
- en: 'Here are some of the advantages of a Static Factory Method over constructors:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是静态工厂方法相对于构造函数的一些优点：
- en: It provides a better name for the constructor, what it expects, and, sometimes,
    what it produces.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为构造函数提供了一个更好的名称，它期望的，有时甚至是什么它产生的。
- en: We usually don't expect exceptions from a constructor. Exceptions from a regular
    method, on the other hand, are totally valid.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通常不期望构造函数抛出异常。另一方面，常规方法抛出的异常是完全有效的。
- en: Speaking of expectations, we expect the constructor to be fast.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说到期望，我们期望构造函数是快速的。
- en: But those are more psychological advantages. There are also some technological
    advantages to this approach.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些都是心理上的优势。这种方法还有一些技术上的优势。
- en: Caching
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: The Static Factory Method may provide caching, as `Long` actually does. Instead
    of always returning a new instance for any value, `valueOf()` checks in-cache
    whether this value was already parsed. If it is, it returns a cached instance.
    Repeatedly calling the Static Factory Method with the same values may produce
    less garbage for collection than using constructors all the time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法可能提供缓存，就像`Long`类那样。它不是为任何值总是返回一个新的实例，而是`valueOf()`方法会检查缓存中是否已经解析了这个值。如果是，它将返回缓存的实例。反复使用相同的值调用静态工厂方法可能产生的垃圾回收量比始终使用构造函数要少。
- en: Subclassing
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类化
- en: When calling the constructor, we always instantiate the class we specify. On
    the other hand, calling a Static Factory Method may produce either instance of
    the class, or one of its subclasses. We'll come to this after discussing the implementation
    of this design pattern in Kotlin.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用构造函数时，我们总是实例化我们指定的类。另一方面，调用静态工厂方法可能产生类的实例，或者其子类之一。在讨论了在Kotlin中实现这种设计模式的实现之后，我们再回到这一点。
- en: Static Factory Method in Kotlin
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的静态工厂方法
- en: We've already discussed the `object` keyword earlier in the *Singleton* section.
    Now we'll see another use of it is a `companion` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*单例*部分中讨论了`object`关键字。现在我们将看到它的另一个用途是`companion`对象。
- en: 'In Java, Static Factory Methods are declared `static`. But in Kotlin, there''s
    no such keyword. Instead, methods that don''t belong to an instance of a class
    can be declared inside a `companion` object:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，静态工厂方法是声明为`static`的。但在Kotlin中，没有这样的关键字。相反，不属于类实例的方法可以声明在`companion`对象内部：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Companion objects may have a name: companion object Parser, for example. But
    this is only for clarity of what the goal of this object is.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象可以有名称：例如，companion object Parser。但这只是为了清晰说明这个对象的目标。
- en: 'Calling a `companion` object doesn''t require instantiating a class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`companion`对象不需要实例化一个类：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Moreover, calling it on an instance of a class simply won''t work, unlike Java:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，直接在类的实例上调用它将不起作用，这与Java不同：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The class may have only one companion object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该类可能只有一个伴侣对象。
- en: Companion object
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴侣对象
- en: 'In Java, Static Factory Methods are declared like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，静态工厂方法声明如下：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'They are called like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被这样称呼：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But in Kotlin, there's no such keyword as Static. Instead, methods that don't
    belong to an instance of a class can be declared inside a companion object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Kotlin中，没有这样的关键字叫做静态。相反，不属于类实例的方法可以在`companion`对象内部声明。
- en: 'We discussed the `object` keyword earlier, in the section *Singletons*. Now,
    we''ll look at another use of this important keyword using the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在*单例*部分讨论了`object`关键字，现在我们将通过以下示例来探讨这个重要关键字的其他用法：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, inside our class, we have declared an object that is prefixed
    by the keyword `companion`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在我们的类中，我们声明了一个以`companion`关键字为前缀的对象。
- en: This object has its own set of functions. What's the benefit of this? You may
    wonder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有一套自己的函数。这样的好处是什么？你可能想知道。
- en: 'Just like a Java Static method, calling a `companion` object doesn''t require
    the instantiation of a class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java中的静态方法一样，调用`companion`对象不需要实例化一个类：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Moreover, calling it on an instance of a class simply won''t work, which is
    not the case with Java:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，直接在类的实例上调用它将不起作用，这与Java不同：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A `companion` object may have a name-Parser, for example. But this is only for
    clarity of what the goal of this object is.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`companion`对象可能有一个名称解析器，例如。但这只是为了清晰说明这个对象的目标。'
- en: The class may have only one `companion` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该类可能只有一个`companion`对象。
- en: 'By using a `companion` object, we can achieve exactly the same behavior that
    we see in Java:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`companion`对象，我们可以实现与Java中完全相同的行为：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now instantiate our object, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像以下代码所示那样实例化我们的对象：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Kotlin proves itself a very practical language. Every keyword in it has a down-to-earth
    meaning.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin证明了自己是一种非常实用的语言。它里面的每一个关键字都有接地气的含义。
- en: Abstract Factory
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Abstract Factory is a greatly misunderstood pattern. It has a notorious reputation
    for being very complex and bizarre but actually, it's quite simple. If you understood
    the Factory Method, you'll understand this one in no time. This is because Abstract
    Factory is a factory of factories. That's all there is to it, really. The factory
    is a function or class that's able to create other classes. Abstract Factory is
    a class that creates factories.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂是一个被广泛误解的模式。它因非常复杂和奇特而臭名昭著，但实际上，它相当简单。如果你理解了工厂方法，你很快就会理解这个模式。这是因为抽象工厂是工厂的工厂。实际上就是这样。工厂是一个能够创建其他类的函数或类。抽象工厂是一个创建工厂的类。
- en: You may understand that and still wonder what the usages of such a pattern may
    be. The main usage of Abstract Factory in the real world would probably be frameworks,
    most notably Spring Framework, which uses the notion of Abstract Factory to create
    its components out of annotations and XML files. But since creating our own framework
    may be quite tiresome, let's take another example where this pattern will be very
    useful—a strategy game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经理解了这一点，但仍想知道这种模式的用途可能是什么。在现实世界中，抽象工厂的主要用途可能是框架，特别是Spring框架，它使用抽象工厂的概念通过注解和XML文件创建其组件。但鉴于创建我们自己的框架可能相当繁琐，让我们看看另一个这个模式非常有用的例子——战略游戏。
- en: 'We''ll call it *CatsCraft 2: Revenge of the Dogs*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将其称为*CatsCraft 2: 狗的复仇*。'
- en: Abstract Factory in action
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂的实际应用
- en: 'Our strategy game will consist of buildings and units. Let''s start with declaring
    what all buildings share:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的战略游戏将包括建筑和单位。让我们从声明所有建筑共有的内容开始：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All buildings should implement the `build()` function. Here we see generics
    in Kotlin for the first time, so let's discuss them a bit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有建筑都应该实现`build()`函数。在这里，我们第一次看到了Kotlin中的泛型，所以让我们稍微讨论一下。
- en: Introduction to generics in Kotlin
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin泛型简介
- en: Generics are a way to specify the relationships between types. Well, that didn't
    help explain much, did it? Let's try again. Generics are an abstraction of types.
    Nope, still awful.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是指定类型之间关系的一种方式。嗯，这并没有帮助解释多少，对吧？让我们再试一次。泛型是类型的抽象。不，仍然很糟糕。
- en: 'We''ll try an example, then:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试一个示例，然后：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Ok, that's easy; we've covered it a lot of times. This code simply creates a
    list of strings. But what does it actually mean?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单；我们已经多次覆盖了它。这段代码只是创建了一个字符串列表。但它实际上意味着什么？
- en: 'Let''s try the following line of code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下代码行：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This line doesn''t compile. That''s because the `mutableListOf()` function
    uses generics:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码无法编译。那是因为 `mutableListOf()` 函数使用了泛型：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Generics create an expectation. No matter which type we use to create our list,
    from now on we can only put that type in it. It's a great language feature because,
    on the one hand, we can generalize our data structures or algorithms. No matter
    what types they hold, they'll still work in exactly the same way.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型创建了一个期望。无论我们使用什么类型来创建我们的列表，从现在起我们只能放那种类型进去。这是一个伟大的语言特性，因为一方面，我们可以泛化我们的数据结构或算法。无论它们包含什么类型，它们都会以完全相同的方式工作。
- en: On the other hand, we still have type safety. The `listOfStrings`. `first()` function
    is guaranteed to return a `String` (in this case) and nothing else.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们仍然有类型安全。`listOfStrings` 的 `first()` 函数保证返回一个 `String`（在这种情况下）而不是其他任何东西。
- en: In terms of generics, Kotlin uses an approach that is similar to, but slightly
    different from, Java. We won't cover all the aspects of generics in this section,
    but will only provide some guidance to better understand this example. As we go
    on, we'll encounter more uses of generics.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛型的方面，Kotlin 使用一种类似于 Java 但略有不同的方法。我们不会在本节中涵盖泛型的所有方面，但将只提供一些指导，以便更好地理解这个例子。随着我们的深入，我们将遇到更多泛型的用法。
- en: Let's look at another example.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。
- en: 'We''ll create a class called `Box`. Boring, I know:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `Box` 的类。我知道这很无聊：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What''s great about this box, though, is that by using generics, I can put
    just about anything in it, for example, a cat:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个盒子的好处是，通过使用泛型，我可以把它几乎任何东西放进去，例如，一只猫：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When I create an instance of a box, I specify what it can hold:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我创建一个盒子的实例时，我指定它可以容纳什么：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At compile time, the generics will make sure that it will only hold objects
    of the correct type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，泛型将确保它只会持有正确类型的对象：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you may know, Java uses the wildcards `?` extends, and super keywords to
    specify read-only and write-only types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Java 使用 `?` extends 和 super 关键字来指定只读和只写类型。
- en: Kotlin uses the concepts of `in`, `out`, and `where`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 使用 `in`、`out` 和 `where` 的概念。
- en: A type that is marked as `in` can be used as a parameter but not as a return
    value. This is also called covariance. In fact, it means that we can return `ProducedUnit` or
    something that inherits from it, but not something that is above `ProducedUnit` in
    the hierarchy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为 `in` 的类型可以用作参数，但不能用作返回值。这也被称为协变。实际上，这意味着我们可以返回 `ProducedUnit` 或从它继承的类型，但不能返回在层次结构中高于
    `ProducedUnit` 的类型。
- en: Types that are marked as `out` can be used only as a return value, not as a
    parameter. This is called contravariance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为 `out` 的类型只能用作返回值，不能用作参数。这被称为逆变。
- en: Furthermore, we may introduce constraints on types using the `where` keyword.
    In our case, we require that the first type implements the `Type` interface, while
    the second type implements the `Unit` interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用 `where` 关键字对类型引入约束。在我们的情况下，我们要求第一个类型实现 `Type` 接口，而第二个类型实现 `Unit`
    接口。
- en: The names of the types themselves, `UnitType` and `ProducedUnit`, could be anything
    we want, `T` and `P`, for example. But for the sake of clarity, we'll use more
    verbose names.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类型本身的名称，`UnitType` 和 `ProducedUnit`，可以是任何我们想要的，例如 `T` 和 `P`。但为了清晰起见，我们将使用更冗长的名称。
- en: Back to our bases
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的基地
- en: 'HQ is a special building that can produce other buildings. It keeps track of
    all the buildings it had built up until now. The same type of building can be
    built more than once:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: HQ 是一个可以生产其他建筑的特殊建筑。它记录了它至今为止所建造的所有建筑。同类型的建筑可以建造多次：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You may be wondering what the star (`*`) means as regards generics. It's called
    a star projection, and it means *I don't know anything about this type*. It's
    similar to Java's raw types, but it's type safe.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道关于泛型，星号 (`*`) 的含义是什么。它被称为星投影，意味着 *我对这个类型一无所知*。它与 Java 的原始类型类似，但它具有类型安全性。
- en: 'All other buildings produce units. Units can be either infantry or armored
    vehicle:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他建筑都会生产单位。单位可以是陆军或装甲车辆：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Infantry can be either riflemen or rocket soldier:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 陆军可以是有步枪兵或火箭兵：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here we see the `enum` keyword for the first time. Vehicles are either tanks
    or **armored personnel carriers** (**APCs**):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们第一次看到 `enum` 关键字。车辆可以是坦克或**装甲人员运输车**（**APCs**）：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A barracks is a building that produces infantry:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个兵营是一个生产步兵的建筑：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We don't need the `else` block in our `when`. That's because we use `enum`,
    and Kotlin makes sure that `when` on `enum` is exhaustive.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在 `when` 中使用 `else` 块。这是因为我们使用了 `enum`，Kotlin 确保了 `enum` 上的 `when` 是穷尽的。
- en: 'A vehicle factory is a building that produces different types of armored vehicles:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个车辆工厂是一个生产不同类型装甲车辆的建筑：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can make sure that we can build different units now:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以确保能够构建不同的单元：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And now on to producing units:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是单元的生成：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've already seen the `listOf()` function from the standard library. It will
    create a read-only list of different units that our buildings produce. You can
    iterate over this list and make sure that those are indeed the units we require.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了标准库中的 `listOf()` 函数。它将创建一个只读列表，其中包含我们建筑生产的不同单元。你可以遍历这个列表，确保这些确实是所需的单元。
- en: Making improvements
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行改进
- en: One may claim that having the `VehicleFactory` and `Barracks` classes is too
    cumbersome. They don't have any state, after all. Instead, we can replace them
    with objects.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会说，拥有 `VehicleFactory` 和 `Barracks` 类太繁琐了。毕竟，它们没有任何状态。相反，我们可以用对象来替换它们。
- en: 'Instead of the previous implementation of `buildBarracks()`, we can have the
    following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用之前的 `buildBarracks()` 实现方式，而是有以下方式：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ve already seen two different usages of the `object` keyword: once in the Singleton
    design pattern, and another time in the Factory Method design pattern. Here is
    the third way we can use it: for creating anonymous classes on the fly. After
    all, `Barracks` is a building that, given `InfantryUnitType`, produces `Infantry`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `object` 关键字的不同用法：一次是在单例设计模式中，另一次是在工厂方法设计模式中。这里是我们使用 `object` 的第三种方式：用于动态创建匿名类。毕竟，`Barracks`
    是一个建筑，给定 `InfantryUnitType`，它会产生 `Infantry`。
- en: 'If our logic is straightforward, we can even shorten the declaration a bit
    more:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的逻辑简单，我们甚至可以进一步缩短声明：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's go to the beginning of this chapter. We said that Abstract Factory combines
    a number of related factories. So, what's common to all factories in our case?
    They're all buildings and they all produce units.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章的开头。我们提到抽象工厂结合了多个相关的工厂。那么，在我们的案例中，所有工厂的共同点是什么？它们都是建筑，并且都生产单元。
- en: Having that principle in mind, you could apply it to many different cases. If
    you're familiar with strategy games, usually they have at least two different
    factions. Each may have different structures and units. To achieve that, you can
    repeat this pattern as many times as needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个原则，你就可以将其应用于许多不同的场景。如果你熟悉策略游戏，通常它们至少有两个不同的派系。每个派系可能都有不同的结构和单位。为了实现这一点，你可以根据需要重复这个模式。
- en: Let's assume we have two different factions now, cats and dogs, and Tanks and
    Rocket Infantry are only prerogatives of this faction. Dogs have Heavy Tanks and
    Grenadiers instead. What changes do we need to make in our system?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在有两个不同的派系，猫和狗，坦克和火箭步兵是这个派系的特权。狗有重型坦克和掷弹兵。我们需要在我们的系统中做出哪些改变？
- en: 'First, `HQ` becomes an interface:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`HQ` 变成了一个接口：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What was `HQ` previously now becomes `CatHQ`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `HQ` 的功能现在变成了 `CatHQ`：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And `DogHQ` will have to repeat the same steps, but with a different construction
    logic.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`DogHQ` 将需要重复相同的步骤，但使用不同的构建逻辑。'
- en: This ability to accommodate big changes is what makes Abstract Factory so powerful
    in some use cases.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种适应大变化的能力使得抽象工厂在某些用例中非常强大。
- en: Builder
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器
- en: Sometimes, our objects are very simple, and have only one constructor, be it
    an empty or non-empty one. But sometimes, their creation is very complex, and
    based on a lot of parameters. We've seen one pattern already that provides *a
    better constructor*—the Static Factory Method design pattern. Now, we'll discuss
    Builder design pattern, which is somewhat similar and somewhat different.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们的对象非常简单，只有一个构造函数，无论是空的还是非空的。但有时，它们的创建非常复杂，基于很多参数。我们已经看到了一个提供 *更好的构造函数*
    的模式——静态工厂方法设计模式。现在，我们将讨论构建器设计模式，它在某些方面相似，在某些方面不同。
- en: Composing an email
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写电子邮件
- en: As a software architect, one of my main channels of communication is email.
    Probably this is true of most software development roles.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，我主要的沟通渠道之一是电子邮件。这可能对大多数软件开发角色都适用。
- en: 'An email has the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一封电子邮件包含以下内容：
- en: An address (at least one is mandatory)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址（至少一个必填）
- en: CC (zero or more, optional)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CC（零个或多个，可选）
- en: Title (optional)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题（可选）
- en: Body (optional)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文（可选）
- en: Attachment (zero or more, optional)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附件（零个或多个，可选）
- en: Let's assume I'm really lazy, and would like to schedule emails to be sent while
    I'm actually biking around the neighborhood.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我真的很懒，并且想在我在街区骑自行车的时候安排发送电子邮件。
- en: 'The actual scheduling logic will be postponed to [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7),
    *Threads and Coroutines*, and [Chapter 9](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7),
    *Designed for Concurrency*, which discuss scheduling and concurrency. For now,
    let''s see what our `Mail` class may look like:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的调度逻辑将被推迟到第8章[线程和协程](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7)和第9章[设计用于并发](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7)，这两章讨论了调度和并发。现在，让我们看看我们的
    `Mail` 类可能看起来像什么：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, we've already seen `data class` in action in the previous chapters. We've
    also discussed nullable and non-nullable types, such as `String?` versus `String`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在前面的章节中已经看到了 `data class` 的实际应用。我们还讨论了可空和非可空类型，例如 `String?` 与 `String`。
- en: Now is a good time to discuss how collections work in Kotlin, since this is
    the first time we have a class that deals with them directly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论 Kotlin 中集合如何工作的好时机，因为这是我们第一次直接处理它们的类。
- en: Collection types in Kotlin
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的集合类型
- en: One of the main Kotlin goals is Java interoperability. So it's no wonder that
    Kotlin collections are interoperable with Java. When you specify that your functions
    receives `List<T>`, it is actually the same Java `List<T>` you're familiar with.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的主要目标之一是Java互操作性。所以 Kotlin 集合与 Java 兼容也就不足为奇了。当你指定你的函数接收 `List<T>` 时，实际上是你所熟悉的相同的
    Java `List<T>`。
- en: But Kotlin differentiates between mutable and immutable collections. The `listOf()` function
    is delegated to `Arrays.asList()`, and produces an immutable list, while `mutableListOf()`
    simply calls `ArrayList()`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Kotlin 区分可变和不可变集合。`listOf()` 函数委托给 `Arrays.asList()`，并生成一个不可变列表，而 `mutableListOf()`
    简单地调用 `ArrayList()`。
- en: On top of data, Kotlin collection has many useful extension methods, which we'll
    discuss later.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据之外，Kotlin 集合还有许多有用的扩展方法，我们将在后面讨论。
- en: Creating an email – first attempt
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电子邮件 - 第一次尝试
- en: 'So, at 10 A.M., I plan to drink a coffee in my local cafe. But I also want
    to contact my manager, since my payslip didn''t arrive yesterday. I attempt to
    create my first email like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上午10点，我计划在我当地的咖啡馆喝咖啡。但我也想联系我的经理，因为我的工资条昨天没有到达。我尝试创建我的第一个电子邮件如下：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This may have worked in Java, but in Kotlin this wouldn''t compile, since we
    cannot pass `null` to `List<String>`. Null-safety is very important in Kotlin:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在 Java 中有效，但在 Kotlin 中不会编译，因为我们不能将 `null` 传递给 `List<String>`。空安全在 Kotlin
    中非常重要：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that since our constructor receives a lot of arguments, I had to put in
    some comments, so I wouldn't get lost.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们的构造函数接收了很多参数，我不得不添加一些注释，这样我就不会迷路了。
- en: 'The Kotlin compiler is smart enough to infer the type of list that we pass.
    Since our constructor receives `List<String>`, it''s enough to pass `listOf()`
    for an empty list. We don''t need to specify the type like so: `listOf<String>()`.
    In Java, Diamond Operator serves the same purpose.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译器足够智能，可以推断我们传递的列表类型。由于我们的构造函数接收 `List<String>`，传递 `listOf()` 对于空列表就足够了。我们不需要像这样指定类型：`listOf<String>()`。在
    Java 中，菱形运算符起到相同的作用。
- en: 'Oh, but I forgot about attachments. Let''s change our constructor:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，但我忘了附件。让我们改变我们的构造函数：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But then our instantiation stops compiling again:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们的实例化又停止编译了：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This clearly becomes a mess.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然变得一团糟。
- en: Creating an email – second attempt
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电子邮件 - 第二次尝试
- en: 'Let''s try a fluent setter approach instead. We''ll have only mandatory fields
    in our constructor, and all others will become setters, so the creation of a new
    email would look something like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一种流畅的设置方法。在我们的构造函数中，我们只有必填字段，其他所有字段都将成为设置器，因此创建一个新电子邮件看起来可能像这样：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That''s a lot nicer for many reasons:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很多方面都好多了：
- en: The order of fields can now be arbitrary, unlike with the constructor.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段的顺序现在可以是任意的，与构造函数不同。
- en: It's clearer which field is being set, no need for comments anymore.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个字段被设置现在更清晰，不再需要注释。
- en: Optional fields don't need to be set at all. As an example, the CC field is
    set, while the BCC field is omitted.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选字段根本不需要设置。例如，CC 字段被设置，而 BCC 字段被省略。
- en: 'Let''s see one way of implementing this approach. There are other convenient
    ways to do it, which we''ll discuss in [Chapter 10](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7),
    *Idioms and Anti-Patterns*:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这种方法的一种方式。还有其他方便的方法来做这件事，我们将在第10章[惯用和反模式](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7)中讨论：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using underscores for private variables is a common convention in Kotlin. It
    allows us to avoid repeating `this.message = message` and mistakes such as `message
    = message`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，使用下划线作为私有变量的命名约定是一种常见做法。这允许我们避免重复 `this.message = message` 和像 `message
    = message` 这样的错误。
- en: This is nice, and very similar to what we may achieve in Java. Although we did
    have to make our message mutable now. But Kotlin provides two other ways that
    you may find even more useful.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，非常类似于我们可能在 Java 中实现的效果。尽管我们现在不得不使我们的消息可变。但 Kotlin 提供了两种其他方法，你可能觉得它们更有用。
- en: Creating an email – the Kotlin way
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电子邮件——Kotlin 方式
- en: 'Like some other modern languages, Kotlin provides us with the ability to set
    *default values* for function parameters:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他一些现代语言一样，Kotlin 提供了为函数参数设置 *默认值* 的能力：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'So, if you would like to send an email without CC, you can do it like that
    now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想要发送一个没有 CC 的电子邮件，现在可以这样操作：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But what about the case where you want to send an email with BCC? Also, not
    having to specify order with fluent setters was very handy. Kotlin has *named
    arguments* for that:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想要发送带有 BCC 的电子邮件怎么办？而且，使用流畅设置器不需要指定顺序，这非常方便。Kotlin 提供了 *命名参数* 来实现这一点：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Combining default parameters with named arguments makes creating complex objects
    in Kotlin a lot easier than before. There''s another way to achieve somewhat similar
    behavior: the `apply()` function. This is one of the extension functions that
    every object in Kotlin has. In order to use this approach, though, we''ll need
    to make all the optional fields variables instead of values:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将默认参数与命名参数结合使用，使得在 Kotlin 中创建复杂对象比以前容易得多。还有另一种实现类似行为的方法：`apply()` 函数。这是 Kotlin
    中每个对象都有的扩展函数之一。不过，为了使用这种方法，我们需要将所有可选字段改为变量而不是值：
- en: 'Then we can create our email like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样创建我们的电子邮件：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `apply()` function is the only one out of the family of **scoping functions**.
    We'll discuss how scoping functions work and are their uses in later chapters.
    Now, while my boss thinks I'm working hard sending all these emails, I can go
    back to my coffee. It's getting cold now!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()` 函数是 **作用域函数** 家族中唯一的函数。我们将在后面的章节中讨论作用域函数的工作原理及其用途。现在，虽然我的老板认为我正在努力发送所有这些电子邮件，但我可以回到我的咖啡那里。现在它已经凉了！'
- en: Creating an email – the Kotlin way – second attempt
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电子邮件——Kotlin 方式——第二次尝试
- en: 'Let''s try a fluent setter approach, instead. We''ll have only mandatory fields
    in our constructor, and all of the others will become setters. So to create a
    new email, we no longer need to do the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一种流畅的设置方法，而不是这样。在我们的构造函数中，我们只有必填字段，其余的都将变成设置器。因此，要创建一个新的电子邮件，我们不再需要做以下操作：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Instead, we will do the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将这样做：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Fluent setters allow us to chain one set call to another.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅设置器允许我们将一个设置调用链接到另一个。
- en: 'That''s a lot nicer for a couple of reasons:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很多方面都更加方便：
- en: The order of fields can now be arbitrary, unlike the order used with the constructor.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段的顺序现在可以是任意的，与构造函数中使用的顺序不同。
- en: It's clearer which field is being set; no more need for comments.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在更清楚哪个字段正在被设置；不再需要注释。
- en: Optional fields don't need to be set at all. As an example, the CC field is
    set while the BCC field is omitted.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选字段根本不需要设置。例如，CC 字段被设置，而 BCC 字段被省略。
- en: 'Let''s look at one way of implementing this approach. There are other convenient
    ways to do this, which we''ll discuss in [Chapter 10](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7), *Idioms
    and Anti-Patterns*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这种方法的一种方式。还有其他方便的方法来做这件事，我们将在第10章[第236部分](part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7)“惯用句和反模式”中讨论：
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using underscores for private variables is a common convention in Kotlin. It
    allows us to avoid repeating the phrase `this.message = message` and mistakes,
    such as `message = message`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，使用下划线作为私有变量的命名约定是一种常见做法。这允许我们避免重复短语 `this.message = message` 和错误，例如
    `message = message`。
- en: This is nice and is very similar to what we may achieve in Java, although we
    did have to make our message mutable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，并且非常类似于我们可能在 Java 中实现的效果，尽管我们现在不得不使我们的消息可变。
- en: 'We can also implement a full-blown builder design pattern, of course:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以实现一个完整的构建器设计模式：
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can use it to create your email in the following way:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下方式创建你的电子邮件：
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: But Kotlin provides two other ways that you may find even more useful.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Kotlin 提供了两种其他方法，你可能觉得它们更有用。
- en: Prototype
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: This design pattern is all about customization and creating objects that are
    similar but slightly different. To understand it better, we'll start with an example.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式完全是关于定制和创建相似但略有不同的对象。为了更好地理解它，我们将从一个例子开始。
- en: Building your own PC
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的电脑
- en: Imagine that you have a shop where you sell PCs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个卖电脑的商店。
- en: 'Regular PC consists of the foll:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 普通电脑由以下组成：
- en: Motherboard
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主板
- en: CPU
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: Graphical card
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形卡
- en: RAM
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Most of your customers don't actually care what components you put in this PC.
    What they do care about is whether this PC will be able to run *Magnificent Pilfering
    Car 7* at 60fps (which is frame per second).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数顾客实际上并不关心你在这台电脑中放入了什么组件。他们真正关心的是这台电脑是否能够在60fps（每秒帧数）下运行*《壮丽盗车7》*。
- en: 'So, you decide to build it like that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你决定这样构建它：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'So when a new customer comes in wanting to try out this game everybody is talking
    about in the neighborhood, you just do:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当一位新顾客进来，想要尝试在邻里中大家都在谈论的这个游戏时，你只需这样做：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: And they are already off toward home, ready to share their newest experiences
    from MPC7\. Actually, your business goes so well that you have one PC just sitting
    there, ready for the next customer to come in.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 他们已经朝着家的方向出发，准备分享他们从MPC7获得的新经验。实际上，你的生意做得如此好，以至于你有一台电脑就放在那里，随时准备迎接下一个顾客的到来。
- en: But then another customer arrives. And this one is tech savvy. So, frankly,
    they think that for the games they play, a *nKCF 8100TZ graphic card* wouldn't
    be enough at all. They've also read that there's now *BBR6 RAM* available and
    they want *16 GB* of it. And of course, they want it right away. But they're willing
    to pay in cash.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后又来了一位顾客。这位顾客很懂技术。所以，坦白说，他们认为对于他们玩的游戏来说，*nKCF 8100TZ图形卡*根本不够。他们也了解到现在有*BBR6内存*可用，他们想要*16GB*。当然，他们希望立即得到。但他们愿意用现金支付。
- en: That's the moment you wish that you could just modify this PC that's sitting
    in your warehouse a little, instead of assembling a new one.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是你想对仓库里坐着的这台电脑稍作修改的时候，而不是组装一台新的。
- en: Starting from a prototype
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从原型开始
- en: 'The whole idea of a prototype is to be able to clone an object easily. There
    are a number of reasons you may want to do this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的整个想法是能够轻松地克隆一个对象。你可能有很多原因想要这样做：
- en: Creating your object is very expensive. You need to fetch it from the database.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的对象非常昂贵。你需要从数据库中检索它。
- en: You create objects that are similar but different from one another, and you
    don't want to repeat similar parts over and over again.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建的对象彼此相似但不同，你不想一遍又一遍地重复相似的部分。
- en: There are also more advanced reasons to use this pattern. JavaScript language,
    for example, uses prototypes to implement inheritance-like behavior without having
    classes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模式还有更多高级的理由。例如，JavaScript语言使用原型来实现类似于类的继承行为，而不使用类。
- en: 'Luckily, Kotlin fixes the *broken* Java `clone()` method. For data classes,
    there''s the `copy()` method, which takes an existing data class, and creates
    a new copy of it, optionally changing some of its attributes in the process:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kotlin修复了*损坏的*Java `clone()` 方法。对于数据类，有`copy()`方法，它接受一个现有的数据类，并创建它的一个新副本，在此过程中可以选择更改一些属性：
- en: '[PRE74]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: By default, the `clone()` method creates a shallow copy, which may be unexpected
    for less experienced developers. It's very hard to implement the `clone()` method
    correctly in Java. You can read about the various pitfalls at [https://dzone.com/articles/shallow-and-deep-java-cloning](https://dzone.com/articles/shallow-and-deep-java-cloning).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`clone()`方法创建一个浅拷贝，这可能对经验不足的开发者来说是不预期的。在Java中正确实现`clone()`方法非常困难。你可以在[https://dzone.com/articles/shallow-and-deep-java-cloning](https://dzone.com/articles/shallow-and-deep-java-cloning)上阅读关于各种陷阱的文章。
- en: Similar to what we've seen in the Builder design pattern, named arguments allow
    us to specify attributes that we can change in any order.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在Builder设计模式中看到的情况类似，命名参数允许我们以任意顺序指定可以更改的属性。
- en: The only thing that's left is for you to count the cash and buy some more of
    those *nKCF graphic cards*. Just in case.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是数现金，再买一些那些*nKCF图形卡*。以防万一。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned when and how to use design patterns from the Creational
    family. We learned about different usages of the `object` keyword: as Singleton,
    as a container for the Static Factory Methods, and as an anonymous implementation
    of an interface. We then saw the workings of the destructuring declaration and
    generics in Kotlin with the use of the `in`, `out`, and `where` keywords. We also
    learned about the default parameter values and named arguments, followed by the
    `copy()` function for data classes.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了何时以及如何使用创建型家族中的设计模式。我们了解了`object`关键字的不同用法：作为单例、作为静态工厂方法的容器，以及作为接口匿名实现的实现。然后，我们通过使用`in`、`out`和`where`关键字，在
    Kotlin 中看到了解构声明和泛型的工作原理。我们还学习了默认参数值和命名参数，随后是数据类的`copy()`函数。
- en: In the next chapter, we'll cover the second family of design patterns, Structural
    patterns. Those patterns help extend the functionality of our objects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍设计模式的第二组，即结构型模式。这些模式有助于扩展我们对象的功能。
