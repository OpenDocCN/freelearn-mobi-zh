- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Error Handling and Availability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和可用性
- en: When I first started writing applications with Objective-C, one of the most
    noticeable deficiencies was the lack of exception handling. Most modern programming
    languages, such as Java and C#, use `try...catch` blocks, or something similar,
    for exception handling. While Objective-C did have the `try...catch` block, it
    wasn't used within the Cocoa framework itself, and it never really felt like a
    true part of the language. I have significant experience in C, so I was able to
    understand how Apple's frameworks received and responded to errors. To be honest,
    I sometimes preferred this method, even though I had grown accustomed to exception
    handling with Java and C#. When Swift was first introduced, I was hoping that
    Apple would put true error handling into the language so that we would have the
    option of using it; however, it was not in the initial release of Swift. It wasn't
    until Swift 2 was released that Apple added error handling to Swift. While this
    kind of error handling may look similar to exception handling in Java and C#,
    there are some very significant differences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始用 Objective-C 编写应用程序时，最明显的不足之一是缺乏异常处理。大多数现代编程语言，如 Java 和 C#，使用 `try...catch`
    块或类似的结构进行异常处理。虽然 Objective-C 确实有 `try...catch` 块，但它并没有在 Cocoa 框架内部使用，而且它从未真正感觉像是语言的一部分。我有丰富的
    C 语言经验，因此我能够理解苹果的框架如何接收和响应错误。说实话，我有时甚至更喜欢这种方法，尽管我已经习惯了 Java 和 C# 中的异常处理。当 Swift
    首次推出时，我希望能看到苹果将真正的错误处理加入语言中，这样我们就有选择使用它的选项；然而，它并没有在 Swift 的初始版本中。直到 Swift 2 发布，苹果才将错误处理添加到
    Swift 中。虽然这种错误处理看起来可能类似于 Java 和 C# 中的异常处理，但它们之间有一些非常显著的不同之处。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: How to represent errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何表示错误
- en: How to use the `do-catch` block in Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Swift 中使用 `do-catch` 块
- en: How to use the `defer` statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `defer` 语句
- en: How to use the availability attribute
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用可用性属性
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Native error handling
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生错误处理
- en: Languages such as Java and C# generally refer to the error handling process
    as exception handling. Within the Swift documentation, Apple refers to this process
    as error handling. While on the outside, Java and C# exception handling may look
    somewhat similar to Swift's error handling, there are some significant differences
    that those familiar with exception handling in other languages will notice throughout
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Java 和 C# 这样的语言通常将错误处理过程称为异常处理。在 Swift 文档中，苹果将这个过程称为错误处理。虽然从外表上看，Java 和
    C# 的异常处理可能看起来与 Swift 的错误处理有些相似，但那些熟悉其他语言中异常处理的人会在本章中注意到一些显著的差异。
- en: Representing errors
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示错误
- en: Before we can really understand how error handling works in Swift, we must see
    how we can represent an error. In Swift, errors are represented by values of types
    that conform to the `Error` protocol. Swift's enumerations are very well suited
    to modeling error conditions because we generally have a finite number of error
    conditions to represent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正理解 Swift 中的错误处理工作原理之前，我们必须看看我们如何表示一个错误。在 Swift 中，错误由符合 `Error` 协议的类型值表示。Swift
    的枚举非常适合建模错误条件，因为我们通常有有限数量的错误条件需要表示。
- en: 'Let''s look at how we would use an enumeration to represent an error. For this,
    we will define a fictitious error named `MyError` with three error conditions,
    `Minor`, `Bad`, and `Terrible`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用枚举来表示错误。为此，我们将定义一个虚构的错误 `MyError`，它有三个错误条件：`Minor`、`Bad` 和 `Terrible`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we defined that the `MyError` enumeration conforms to the
    `Error` protocol and also defined three error conditions: `Minor`, `Bad`, and
    `Terrible`. That is all there is to defining basic error conditions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了 `MyError` 枚举符合 `Error` 协议，并且定义了三个错误条件：`Minor`、`Bad` 和 `Terrible`。这就是定义基本错误条件所需要做的全部。
- en: 'We can also use the associated values with our error conditions to add more
    details about the error condition. Let''s say that we want to add a description
    to the `Terrible` error condition. We would do so like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用与我们的错误条件关联的值来添加有关错误条件的更多详细信息。比如说，我们想要向 `Terrible` 错误条件添加一个描述。我们会这样做：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Those who are familiar with exception handling in Java and C# can see that representing
    errors in Swift is a lot cleaner and easier, because we do not need to create
    a lot of boilerplate code or a full class. With Swift, it can be as simple as
    defining an enumeration with our error conditions. Another advantage is that it
    is very easy to define multiple error conditions and group them together so that
    all the related error conditions are of one type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉Java和C#中异常处理的人会发现，在Swift中表示错误要干净得多，也容易得多，因为我们不需要创建大量的样板代码或一个完整的类。在Swift中，它可能只需要定义一个包含我们的错误条件的枚举。另一个优点是，定义多个错误条件并将它们分组在一起非常容易，这样所有相关的错误条件都是同一类型的。
- en: Now, let's learn how to model errors in Swift. For this example, we'll look
    at how we would assign numbers to players on a baseball team. For a baseball team,
    every new player who is called up is assigned a unique number. This number must
    also be within a certain range, because only two numbers fit on a baseball jersey.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在Swift中建模错误。为了这个例子，我们将看看我们如何为一个棒球队分配球员号码。对于一个棒球队，每个被召回的新球员都会被分配一个唯一的号码。这个号码也必须在一定的范围内，因为只有两个号码可以放在棒球球衣上。
- en: 'Therefore, we would have three error conditions: the number is too large, the
    number is too small, and the number is not unique. The following example shows
    how we might represent these error conditions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将有三个错误条件：号码太大，号码太小，以及号码不唯一。以下示例显示了我们可以如何表示这些错误条件：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the `PlayerNumberError` type, we define three very specific error conditions
    that tell us exactly what went wrong. These error conditions are also grouped
    together in one type since they are all related to assigning the players' numbers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PlayerNumberError`类型，我们定义了三种非常具体的错误条件，这些条件确切地告诉我们出了什么问题。由于这些错误条件都与分配球员号码相关，因此它们也被组合在一个类型中。
- en: This method of defining errors allows us to define very specific errors that
    let our code know exactly what went wrong if an error condition occurs. It also
    lets us group the errors so that all related errors can be defined in the same
    type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义错误的方法允许我们定义非常具体的错误，这样当发生错误条件时，我们的代码可以确切地知道出了什么问题。它还允许我们将错误分组，这样所有相关的错误都可以定义在同一个类型中。
- en: Now that we know how to represent errors, let's look at how to throw errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何表示错误，让我们看看如何抛出错误。
- en: Throwing errors
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出错误
- en: When an error occurs in a function, the code that called the function must be
    made aware of it; this is called **throwing an error**. When a function throws
    an error, it assumes that the code that called the function, or some code further
    up the chain, will catch and recover appropriately from the error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数中发生错误时，调用该函数的代码必须知道这一点；这被称为**抛出错误**。当函数抛出错误时，它假设调用该函数的代码，或者链中的某些代码，将捕获并适当地从错误中恢复。
- en: To throw an error from a function, we use the `throws` keyword. This keyword
    lets the code that called it know that an error may be thrown from the function.
    Unlike exception handling in other languages, we do not list the specific error
    types that may be thrown.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要从函数中抛出错误，我们使用`throws`关键字。这个关键字让调用它的代码知道函数可能会抛出错误。与其他语言的异常处理不同，我们不需要列出可能抛出的具体错误类型。
- en: Since we do not list the specific error types that may be thrown from a function
    within the function's definition, it would be good practice to list them in the
    documentation and comments for the function. This allows other developers who
    use the function to know what error types to catch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不在函数定义中列出可能从函数中抛出的具体错误类型，因此在函数的文档和注释中列出它们是一种良好的实践。这允许使用该函数的其他开发者知道应该捕获哪些错误类型。
- en: Soon, we will look at how to throw errors. But first, let's add a fourth error
    to the `PlayerNumberError` type that we defined earlier. This demonstrates how
    easy it is to add error conditions to our error types. This error condition is
    thrown if we are trying to retrieve a player by their number, but no player has
    been assigned that number.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将看看如何抛出错误。但首先，让我们向之前定义的`PlayerNumberError`类型添加一个第四个错误。这展示了如何轻松地向我们的错误类型添加错误条件。这个错误条件是在我们尝试通过号码检索球员，但没有球员被分配该号码时抛出的。
- en: 'The new `PlayerNumberError` type will now look similar to this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`PlayerNumberError`类型现在看起来将类似于以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To demonstrate how to throw errors, let''s create a `BaseballTeam` structure
    that will contain a list of players for a given team. These players will be stored
    in a dictionary object named `players`. We will use the player''s number as the
    key because we know that each player must have a unique number. The `BaseballPlayer`
    type, which will be used to represent a single player, will be a `typealias` for
    a tuple type, and is defined like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何抛出错误，让我们创建一个包含给定球队球员列表的 `BaseballTeam` 结构。这些球员将被存储在一个名为 `players` 的字典对象中。我们将使用球员的号码作为键，因为我们知道每个球员都必须有一个唯一的号码。用于表示单个球员的
    `BaseballPlayer` 类型将是一个元组类型的 `typealias`，定义如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this `BaseballTeam` structure, we will have two methods. The first one will
    be named `addPlayer()`. This method will accept one parameter of the `BaseballPlayer`
    type and attempt to add the player to the team. This method can also throw one
    of three error conditions: `NumberTooHigh`, `NumberTooLow`, or `NumberAlreadyExists`.
    Here is how we would write this method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `BaseballTeam` 结构中，我们将有两个方法。第一个方法将被命名为 `addPlayer()`。这个方法将接受一个 `BaseballPlayer`
    类型的参数，并尝试将球员添加到球队中。这个方法也可以抛出三种错误条件之一：`NumberTooHigh`、`NumberTooLow` 或 `NumberAlreadyExists`。以下是这个方法的写法：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that the `throws` keyword is added to the method's definition. The
    `throws` keyword lets any code that calls this method know that it may throw an
    error and that the error must be handled. We then use the three `guard` statements
    to verify that the number is not too large, not too small, and is unique in the
    `players` dictionary. If any of these conditions are not met, we throw the appropriate
    error using the `throw` keyword. If we make it through all three checks, the player
    is then added to the `players` dictionary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`throws` 关键字被添加到了方法的定义中。`throws` 关键字让任何调用此方法的代码知道它可能会抛出错误，并且必须处理这个错误。然后我们使用三个
    `guard` 语句来验证数字不是太大，不是太小，并且在 `players` 字典中是唯一的。如果这些条件中的任何一个不满足，我们将使用 `throw` 关键字抛出适当的错误。如果我们通过了所有三个检查，那么球员就会被添加到
    `players` 字典中。
- en: 'The second method that we will be adding to the `BaseballTeam` structure is
    the `getPlayerByNumber()` method. This method will attempt to retrieve the baseball
    player that has been assigned a given number. If no player is assigned that number,
    this method will throw a `NumberDoesNotExist` error. The `getPlayerByNumber()`
    method will look similar to this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到 `BaseballTeam` 结构中的第二个方法是 `getPlayerByNumber()` 方法。这个方法将尝试检索被分配了给定数字的棒球运动员。如果没有球员被分配了该数字，这个方法将抛出
    `NumberDoesNotExist` 错误。`getPlayerByNumber()` 方法将看起来像这样：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have added the `throws` keyword to this method definition as well; however,
    this method also has a return type. When we use the `throws` keyword with a return
    type, it must be placed before the return type in the method's definition.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也把这个 `throws` 关键字添加到了这个方法定义中；然而，这个方法还有一个返回类型。当我们使用 `throws` 关键字与返回类型一起时，它必须放在方法定义中的返回类型之前。
- en: Within the method, we attempt to retrieve the baseball player with the number
    that is passed into the method. If we can retrieve the player, we return it; otherwise,
    we throw the `NumberDoesNotExist` error. Note that if we throw an error from a
    method that has a return type, a return value is not required.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们尝试检索传递给方法的具有该数字的棒球运动员。如果我们能检索到球员，我们就返回它；否则，我们抛出 `NumberDoesNotExist`
    错误。注意，如果我们从具有返回类型的方法中抛出错误，则不需要返回值。
- en: Now, let's learn how to catch an error with Swift.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 Swift 捕获错误。
- en: Catching errors
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'When an error is thrown from a function, we need to catch it in the code that
    called it; this is done using the `do-catch` block. We use the `try` keyword,
    within the `do-catch` block, to identify the places in the code that may throw
    an error. The `do-catch` block with a `try` statement has the following syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数抛出错误时，我们需要在调用它的代码中捕获它；这是通过使用 `do-catch` 块来完成的。我们在 `do-catch` 块中使用 `try`
    关键字来标识代码中可能抛出错误的地方。带有 `try` 语句的 `do-catch` 块具有以下语法：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If an error is thrown, it is propagated out until it is handled by a `catch`
    clause. The `catch` clause consists of the `catch` keyword, followed by a pattern
    to match the error against. If the error matches the pattern, the code within
    the `catch` block is executed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出了错误，它将传播出去，直到被 `catch` 子句处理。`catch` 子句由 `catch` 关键字组成，后面跟着一个用于匹配错误的模式。如果错误与模式匹配，则执行
    `catch` 块内的代码。
- en: 'Let''s look at how to use the `do-catch` block by calling both the `getPlayerByNumber()`
    and `addPlayer()` methods of the `BaseballTeam` structure. Let''s look at the
    `getPlayerByNumber()` method first, since it only throws one error condition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用 `BaseballTeam` 结构的 `getPlayerByNumber()` 和 `addPlayer()` 方法来查看如何使用 `do-catch`
    块。首先让我们看看 `getPlayerByNumber()` 方法，因为它只抛出一个错误条件：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within this example, the `do-catch` block calls the `getPlayerByNumber()` method
    of the `BaseballTeam` structure. This method will throw the `NumberDoesNotExist`
    error condition if no player on the team has been assigned this number; therefore,
    we attempt to match this error in the `catch` statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`do-catch` 块调用了 `BaseballTeam` 结构的 `getPlayerByNumber()` 方法。如果没有球员被分配这个号码，该方法将抛出
    `NumberDoesNotExist` 错误条件；因此，我们尝试在 `catch` 语句中匹配这个错误。
- en: Any time an error is thrown within a `do-catch` block, the remainder of the
    code within the block is skipped and the code within the `catch` block that matches
    the error is executed. Therefore, in our example, if the `NumberDoesNotExist`
    error is thrown by the `getPlayerByNumber()` method, the first `print` statement
    is never reached.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在 `do-catch` 块内抛出错误时，块内的剩余代码将被跳过，并且将执行匹配该错误的 `catch` 块内的代码。因此，在我们的示例中，如果 `getPlayerByNumber()`
    方法抛出 `NumberDoesNotExist` 错误条件，第一个 `print` 语句永远不会被执行。
- en: 'We do not have to include a pattern after the `catch` statement. If a pattern
    is not included after the `catch` statement, or if we put in an underscore, the
    `catch` statement will match all the error conditions. For example, either one
    of the following two `catch` statements will catch all errors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在 `catch` 语句后面包含一个模式。如果 `catch` 语句后面没有包含模式，或者我们放入一个下划线，`catch` 语句将匹配所有错误条件。例如，以下两个
    `catch` 语句中的任何一个都将捕获所有错误：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we want to capture the error, we can use the `let` keyword, as shown in
    the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要捕获错误，我们可以使用 `let` 关键字，如下面的示例所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s look at how to use the `catch` statement, similar to a `switch`
    statement, to catch different error conditions. To do this, we will call the `addPlayer()`
    method of the `BaseballTeam` structure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `catch` 语句，类似于 `switch` 语句，来捕获不同的错误条件。为此，我们将调用 `BaseballTeam` 结构的
    `addPlayer()` 方法：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we have three `catch` statements. Each `catch` statement has
    a different pattern to match; therefore, they will each match a different error
    condition. As you may recall, the `NumberTooHigh` and `NumberToLow` error conditions
    have associated values. To retrieve the associated values, we use the `let` statement
    within parentheses, as shown in the preceding example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有三个 `catch` 语句。每个 `catch` 语句都有一个不同的模式来匹配；因此，它们将分别匹配不同的错误条件。如您所回忆的，`NumberTooHigh`
    和 `NumberToLow` 错误条件有相关值。要检索相关值，我们使用括号内的 `let` 语句，如前例所示。
- en: 'It is always good practice to make your last `catch` statement an empty `catch`
    statement so that it will catch any errors that did not match any of the patterns
    in the previous `catch` statements. Therefore, the previous example should be
    rewritten like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总是好的做法是将你的最后一个 `catch` 语句留空，这样它就会捕获之前 `catch` 语句中所有模式未匹配的错误。因此，前面的示例应该重写如下：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also let the errors propagate out rather than immediately catching them.
    To do this, we just need to add the `throws` keyword to the function definition.
    For instance, in the following example, rather than catching the error, we could
    let it propagate out to the code that called the function, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让错误传播出去而不是立即捕获它们。为此，我们只需在函数定义中添加 `throws` 关键字。例如，在以下示例中，我们不是捕获错误，而是让它传播到调用函数的代码中，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we are certain that an error will not be thrown, we can call the function
    using a forced-try expression, which is written as `try!`. The forced-try expression
    disables error propagation and wraps the function call in a runtime assertion
    so no error will be thrown from this call. If an error is thrown, you will get
    a runtime error, so be very careful when using this expression.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定不会抛出错误，我们可以使用强制尝试表达式来调用函数，该表达式写作 `try!`。强制尝试表达式禁用了错误传播，并将函数调用包装在一个运行时断言中，因此不会从这个调用中抛出错误。如果抛出错误，您将得到运行时错误，所以使用这个表达式时要非常小心。
- en: It is highly recommended that you avoid using the forced-try expression in production
    code since it can cause a runtime error and cause your application to crash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你在生产代码中避免使用强制尝试表达式，因为它可能导致运行时错误并导致你的应用程序崩溃。
- en: 'When I work with exceptions in languages such as Java and C#, I see a lot of
    empty `catch` blocks. This is where we need to catch the exception, because one
    might be thrown; however, we do not want to do anything with it. In Swift, the
    code would look something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 Java 和 C# 等语言中处理异常时，我看到很多空的 `catch` 块。这就是我们需要捕获异常的地方，因为可能会抛出异常；然而，我们不想对它做任何事情。在
    Swift 中，代码看起来可能像这样：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code like this is one of the things that I dislike about exception handling.
    Well, the Swift developers have an answer for this: `try?`. This attempts to perform
    an operation that may throw an error and converts it into an optional value; therefore,
    the result of the operation will be either `nil` if an error is thrown, or the
    result of the operation if no error is thrown.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码是我不喜欢异常处理的地方之一。嗯，Swift 开发者对此有一个答案：`try?`。这尝试执行可能会抛出错误的操作，并将其转换为可选值；因此，操作的结果将是如果抛出错误则为
    `nil`，如果没有抛出错误则为操作的结果。
- en: 'Since the results of `try?` are returned in the form of an optional, we would
    normally use this with optional binding. We could rewrite the previous example
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `try?` 的结果以可选形式返回，我们通常会与可选绑定一起使用它。我们可以将前面的示例重写如下：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, this makes our code much cleaner and easier to read.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这使得我们的代码更加整洁且易于阅读。
- en: 'If we need to perform a cleanup action, regardless of whether we had any errors,
    we can use a `defer` statement. We use `defer` statements to execute a block of
    code just before the code execution leaves the current scope. The following example
    shows how we can use the `defer` statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行清理操作，无论是否发生错误，我们都可以使用 `defer` 语句。我们使用 `defer` 语句在代码执行离开当前作用域之前执行一段代码。以下示例显示了我们可以如何使用
    `defer` 语句：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we called this function, the first line to be printed to the console would
    be `Function started`. The code''s execution would skip over the `defer` block,
    and `Function finished` would then be printed to the console. Finally, the `defer`
    block of code would be executed just before we leave the function''s scope, and
    we would see the `In defer block` message. The following is the output of this
    function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用这个函数，控制台首先打印的将是 `Function started`。代码的执行将跳过 `defer` 块，然后控制台将打印 `Function
    finished`。最后，在离开函数的作用域之前，将执行 `defer` 块的代码，我们会看到 `In defer block` 的消息。以下是这个函数的输出：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `defer` block will always be called before the execution leaves the current
    scope, even if an error is thrown. The `defer` statement is very useful when we
    want to make sure we perform all the necessary cleanup, even if an error is thrown.
    For example, if we successfully open a file to write to, we will always want to
    make sure we close that file, even if we encounter an error during the write operation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 块将在执行离开当前作用域之前始终被调用，即使抛出了错误。当我们需要确保执行所有必要的清理操作，即使抛出了错误时，`defer` 语句非常有用。例如，如果我们成功打开一个文件进行写入，我们总是想确保关闭该文件，即使我们在写入操作中遇到错误。'
- en: In this case, we could put the file-closed functionality in a `defer` block
    to make sure that the file is always closed prior to leaving the current scope.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以将文件关闭功能放在 `defer` 块中，以确保在离开当前作用域之前文件总是被关闭。
- en: Multi-pattern catch clauses
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多模式捕获子句
- en: 'In the previous section, we had code that looked like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们有一些看起来像这样的代码：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will notice that the `catch` clause for the `PlayerNmberError.NumberTooHigh`
    and `PlayerNumberError.NumberTooLow` errors contains duplicate code. When you
    are developing, it is always good to find a way to eliminate duplicate code like
    this. However, prior to Swift 5.3, we did not have a choice. Swift introduced
    multi-pattern `catch` clauses with SE-0276 in Swift 5.3 to help reduce duplicate
    code like this. Let''s take a look at this by rewriting the previous code to use
    a multi-pattern `catch` clause:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，对于 `PlayerNmberError.NumberTooHigh` 和 `PlayerNumberError.NumberTooLow`
    错误的 `catch` 子句包含重复的代码。在开发过程中，总是好的找到一种方法来消除这样的重复代码。然而，在 Swift 5.3 之前，我们没有选择。Swift
    通过 Swift 5.3 中的 SE-0276 引入了多模式 `catch` 子句，以帮助减少这种重复代码。让我们通过重写前面的代码来使用多模式 `catch`
    子句来查看这一点：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that in the first `catch` clause, we are now catching both the `PlayerNmberError.NumberTooHigh`
    and `PlayerNumberError.NumberTooLow` errors and that the errors are separated
    by a comma.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一个 `catch` 子句中，我们现在正在捕获 `PlayerNmberError.NumberTooHigh` 和 `PlayerNumberError.NumberTooLow`
    两个错误，并且错误之间用逗号分隔。
- en: Next, we'll look at how to use the new availability attribute with Swift.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用新的可用性属性与 Swift 一起使用。
- en: The availability attribute
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性属性
- en: Developing our applications for the latest **Operating System** (**OS**) version
    gives us access to all the latest features for the platform that we are developing
    for. However, there are times when we want to also target older platforms. Swift
    allows us to use the availability attribute to safely wrap code to run only when
    the correct version of the operating system is available. This was first introduced
    in Swift 2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为最新的 **操作系统**（**OS**）版本开发我们的应用程序使我们能够访问我们正在开发平台的所有最新功能。然而，有时我们还想针对旧平台。Swift
    允许我们使用可用性属性安全地包装代码，以便仅在操作系统正确版本可用时运行。这最初是在 Swift 2 中引入的。
- en: The availability attribute is only available when we use Swift on Apple platforms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性属性仅在我们在 Apple 平台上使用 Swift 时才可用。
- en: The availability block essentially lets us, if we are running the specified
    version of the operating system or higher, run this code or otherwise run some
    other code. There are two ways in which we can use the availability attribute.
    The first way allows us to execute a specific block of code that can be used with
    an `if` or a `guard` statement. The second way allows us to mark a method or type
    as available only on certain platforms.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性代码块本质上允许我们，如果我们正在运行指定的操作系统版本或更高版本，运行此代码或运行其他代码。我们可以使用可用性属性有两种方式。第一种方式允许我们执行一个特定的代码块，该代码块可以与
    `if` 或 `guard` 语句一起使用。第二种方式允许我们将方法或类型标记为仅在特定平台上可用。
- en: 'The availability attribute accepts up to six comma-separated arguments, which
    allow us to define the minimum version of the operating system or application
    extension needed to execute our code. These arguments are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性属性接受最多六个以逗号分隔的参数，这允许我们定义执行我们的代码所需的操作系统的最低版本或应用扩展。这些参数如下：
- en: '`iOS`: This is the minimum iOS version that is compatible with our code.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iOS`：这是我们代码兼容的最低 iOS 版本。'
- en: '`OSX`: This is the minimum OS X version that is compatible with our code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OSX`：这是我们代码兼容的最低 OS X 版本。'
- en: '`watchOS`: This is the minimum watchOS version that is compatible with our
    code.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watchOS`：这是我们代码兼容的最低 watchOS 版本。'
- en: '`tvOS`: This is the minimum tvOS version that is compatible with our code.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tvOS`：这是我们代码兼容的最低 tvOS 版本。'
- en: '`iOSApplicationExtension`: This is the minimum iOS application extension that
    is compatible with our code.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iOSApplicationExtension`：这是我们代码兼容的最低 iOS 应用扩展。'
- en: '`OSXApplicationExtension`: This is the minimum OS X application extension that
    is compatible with our code.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OSXApplicationExtension`：这是我们代码兼容的最低 OS X 应用扩展。'
- en: 'After the argument, we specify the minimum version that is required. We only
    need to include the arguments that are compatible with our code. As an example,
    if we are writing an iOS application, we only need to include the iOS argument
    in the availability attribute. We end the argument list with an `*` (asterisk)
    as it is a placeholder for future versions. Let''s look at how we would execute
    a specific block of code only if we met the minimum requirements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数之后，我们指定所需的最低版本。我们只需要包含与我们的代码兼容的参数。例如，如果我们正在编写 iOS 应用程序，我们只需要在可用性属性中包含 iOS
    参数。我们以一个 `*`（星号）结束参数列表，因为它代表未来的版本。让我们看看如何仅在我们满足最低要求时执行特定的代码块：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, the `if #available(iOS 9.0, OSX 10.10, watchOS 2, *)` line
    of code prevents the block of code from executing when the application is run
    on a system that does not meet the specified minimum operating system version.
    In this example, we also use the `else` statement to execute a separate block
    of code if the operating system does not meet the minimum requirements.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，`if #available(iOS 9.0, OSX 10.10, watchOS 2, *)` 这行代码防止在运行在不符合指定最低操作系统版本的系统上时执行代码块。在这个例子中，我们还使用了
    `else` 语句，如果操作系统不符合最低要求，将执行另一段代码。'
- en: 'We can also restrict access to a function or a type. In the previous code,
    the `available` attribute was prefixed with the `#` (pound, also known as **octothorpe**
    and **hash**) character. To restrict access to a function or type, we prefix the
    `available` attribute with an `@` (at) character. The following example shows
    how we could restrict access to a type and function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以限制对函数或类型的访问。在前面的代码中，`available` 属性前面加了 `#`（井号，也称为 **octothorpe** 和 **hash**）字符。为了限制对函数或类型的访问，我们需要在
    `available` 属性前加上一个 `@`（在）字符。以下示例展示了我们如何限制对类型和函数的访问：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous example, we specified that the `testAvailability()` function
    and the `testStruct()` type could only be accessed if the code was run on a device
    that has iOS version 9 or newer. In order to use the `@available` attribute to
    block access to a function or type, we must wrap the code that calls that function
    or type with the `#available` attribute.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们指定了只有在代码在具有 iOS 9 或更高版本的设备上运行时，`testAvailability()` 函数和 `testStruct()`
    类型才能被访问。为了使用 `@available` 属性来阻止对函数或类型的访问，我们必须将调用该函数或类型的代码用 `#available` 属性包裹起来。
- en: 'The following example shows how we could call the `testAvailability()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何调用 `testAvailability()` 函数：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the `testAvailability()` function is only called if the application
    is running on a device that has iOS version 9 or later.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`testAvailability()` 函数只有在应用程序运行在具有 iOS 9 或更高版本的设备上时才会被调用。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at Swift's error handling features. While we are
    not required to use these features in our custom types, they do give us a uniform
    way to handle and respond to errors. Apple has also started to use this form of
    error handling in their frameworks. It is recommended that we use error handling
    in our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Swift 的错误处理功能。虽然我们不需要在我们的自定义类型中使用这些功能，但它们确实为我们提供了一种统一的方式来处理和响应错误。苹果公司也开始在其框架中使用这种错误处理形式。建议我们在代码中使用错误处理。
- en: We also looked at the availability attribute, which allows us to develop applications
    that take advantage of the latest features of our target operating systems, while
    still allowing our applications to run on older versions. In the next chapter,
    we'll take a look at how to write custom subscripts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了 `availability` 属性，它允许我们开发能够利用目标操作系统的最新功能的应用程序，同时仍然允许我们的应用程序在旧版本上运行。在下一章中，我们将探讨如何编写自定义下标。
