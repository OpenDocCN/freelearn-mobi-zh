- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling and Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started writing applications with Objective-C, one of the most
    noticeable deficiencies was the lack of exception handling. Most modern programming
    languages, such as Java and C#, use `try...catch` blocks, or something similar,
    for exception handling. While Objective-C did have the `try...catch` block, it
    wasn't used within the Cocoa framework itself, and it never really felt like a
    true part of the language. I have significant experience in C, so I was able to
    understand how Apple's frameworks received and responded to errors. To be honest,
    I sometimes preferred this method, even though I had grown accustomed to exception
    handling with Java and C#. When Swift was first introduced, I was hoping that
    Apple would put true error handling into the language so that we would have the
    option of using it; however, it was not in the initial release of Swift. It wasn't
    until Swift 2 was released that Apple added error handling to Swift. While this
    kind of error handling may look similar to exception handling in Java and C#,
    there are some very significant differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to represent errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `do-catch` block in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `defer` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the availability attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Native error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Languages such as Java and C# generally refer to the error handling process
    as exception handling. Within the Swift documentation, Apple refers to this process
    as error handling. While on the outside, Java and C# exception handling may look
    somewhat similar to Swift's error handling, there are some significant differences
    that those familiar with exception handling in other languages will notice throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Representing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can really understand how error handling works in Swift, we must see
    how we can represent an error. In Swift, errors are represented by values of types
    that conform to the `Error` protocol. Swift's enumerations are very well suited
    to modeling error conditions because we generally have a finite number of error
    conditions to represent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would use an enumeration to represent an error. For this,
    we will define a fictitious error named `MyError` with three error conditions,
    `Minor`, `Bad`, and `Terrible`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we defined that the `MyError` enumeration conforms to the
    `Error` protocol and also defined three error conditions: `Minor`, `Bad`, and
    `Terrible`. That is all there is to defining basic error conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the associated values with our error conditions to add more
    details about the error condition. Let''s say that we want to add a description
    to the `Terrible` error condition. We would do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Those who are familiar with exception handling in Java and C# can see that representing
    errors in Swift is a lot cleaner and easier, because we do not need to create
    a lot of boilerplate code or a full class. With Swift, it can be as simple as
    defining an enumeration with our error conditions. Another advantage is that it
    is very easy to define multiple error conditions and group them together so that
    all the related error conditions are of one type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to model errors in Swift. For this example, we'll look
    at how we would assign numbers to players on a baseball team. For a baseball team,
    every new player who is called up is assigned a unique number. This number must
    also be within a certain range, because only two numbers fit on a baseball jersey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we would have three error conditions: the number is too large, the
    number is too small, and the number is not unique. The following example shows
    how we might represent these error conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the `PlayerNumberError` type, we define three very specific error conditions
    that tell us exactly what went wrong. These error conditions are also grouped
    together in one type since they are all related to assigning the players' numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This method of defining errors allows us to define very specific errors that
    let our code know exactly what went wrong if an error condition occurs. It also
    lets us group the errors so that all related errors can be defined in the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to represent errors, let's look at how to throw errors.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an error occurs in a function, the code that called the function must be
    made aware of it; this is called **throwing an error**. When a function throws
    an error, it assumes that the code that called the function, or some code further
    up the chain, will catch and recover appropriately from the error.
  prefs: []
  type: TYPE_NORMAL
- en: To throw an error from a function, we use the `throws` keyword. This keyword
    lets the code that called it know that an error may be thrown from the function.
    Unlike exception handling in other languages, we do not list the specific error
    types that may be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Since we do not list the specific error types that may be thrown from a function
    within the function's definition, it would be good practice to list them in the
    documentation and comments for the function. This allows other developers who
    use the function to know what error types to catch.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will look at how to throw errors. But first, let's add a fourth error
    to the `PlayerNumberError` type that we defined earlier. This demonstrates how
    easy it is to add error conditions to our error types. This error condition is
    thrown if we are trying to retrieve a player by their number, but no player has
    been assigned that number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `PlayerNumberError` type will now look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate how to throw errors, let''s create a `BaseballTeam` structure
    that will contain a list of players for a given team. These players will be stored
    in a dictionary object named `players`. We will use the player''s number as the
    key because we know that each player must have a unique number. The `BaseballPlayer`
    type, which will be used to represent a single player, will be a `typealias` for
    a tuple type, and is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `BaseballTeam` structure, we will have two methods. The first one will
    be named `addPlayer()`. This method will accept one parameter of the `BaseballPlayer`
    type and attempt to add the player to the team. This method can also throw one
    of three error conditions: `NumberTooHigh`, `NumberTooLow`, or `NumberAlreadyExists`.
    Here is how we would write this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `throws` keyword is added to the method's definition. The
    `throws` keyword lets any code that calls this method know that it may throw an
    error and that the error must be handled. We then use the three `guard` statements
    to verify that the number is not too large, not too small, and is unique in the
    `players` dictionary. If any of these conditions are not met, we throw the appropriate
    error using the `throw` keyword. If we make it through all three checks, the player
    is then added to the `players` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method that we will be adding to the `BaseballTeam` structure is
    the `getPlayerByNumber()` method. This method will attempt to retrieve the baseball
    player that has been assigned a given number. If no player is assigned that number,
    this method will throw a `NumberDoesNotExist` error. The `getPlayerByNumber()`
    method will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have added the `throws` keyword to this method definition as well; however,
    this method also has a return type. When we use the `throws` keyword with a return
    type, it must be placed before the return type in the method's definition.
  prefs: []
  type: TYPE_NORMAL
- en: Within the method, we attempt to retrieve the baseball player with the number
    that is passed into the method. If we can retrieve the player, we return it; otherwise,
    we throw the `NumberDoesNotExist` error. Note that if we throw an error from a
    method that has a return type, a return value is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to catch an error with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Catching errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an error is thrown from a function, we need to catch it in the code that
    called it; this is done using the `do-catch` block. We use the `try` keyword,
    within the `do-catch` block, to identify the places in the code that may throw
    an error. The `do-catch` block with a `try` statement has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If an error is thrown, it is propagated out until it is handled by a `catch`
    clause. The `catch` clause consists of the `catch` keyword, followed by a pattern
    to match the error against. If the error matches the pattern, the code within
    the `catch` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use the `do-catch` block by calling both the `getPlayerByNumber()`
    and `addPlayer()` methods of the `BaseballTeam` structure. Let''s look at the
    `getPlayerByNumber()` method first, since it only throws one error condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Within this example, the `do-catch` block calls the `getPlayerByNumber()` method
    of the `BaseballTeam` structure. This method will throw the `NumberDoesNotExist`
    error condition if no player on the team has been assigned this number; therefore,
    we attempt to match this error in the `catch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Any time an error is thrown within a `do-catch` block, the remainder of the
    code within the block is skipped and the code within the `catch` block that matches
    the error is executed. Therefore, in our example, if the `NumberDoesNotExist`
    error is thrown by the `getPlayerByNumber()` method, the first `print` statement
    is never reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have to include a pattern after the `catch` statement. If a pattern
    is not included after the `catch` statement, or if we put in an underscore, the
    `catch` statement will match all the error conditions. For example, either one
    of the following two `catch` statements will catch all errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to capture the error, we can use the `let` keyword, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how to use the `catch` statement, similar to a `switch`
    statement, to catch different error conditions. To do this, we will call the `addPlayer()`
    method of the `BaseballTeam` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have three `catch` statements. Each `catch` statement has
    a different pattern to match; therefore, they will each match a different error
    condition. As you may recall, the `NumberTooHigh` and `NumberToLow` error conditions
    have associated values. To retrieve the associated values, we use the `let` statement
    within parentheses, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always good practice to make your last `catch` statement an empty `catch`
    statement so that it will catch any errors that did not match any of the patterns
    in the previous `catch` statements. Therefore, the previous example should be
    rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also let the errors propagate out rather than immediately catching them.
    To do this, we just need to add the `throws` keyword to the function definition.
    For instance, in the following example, rather than catching the error, we could
    let it propagate out to the code that called the function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we are certain that an error will not be thrown, we can call the function
    using a forced-try expression, which is written as `try!`. The forced-try expression
    disables error propagation and wraps the function call in a runtime assertion
    so no error will be thrown from this call. If an error is thrown, you will get
    a runtime error, so be very careful when using this expression.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you avoid using the forced-try expression in production
    code since it can cause a runtime error and cause your application to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I work with exceptions in languages such as Java and C#, I see a lot of
    empty `catch` blocks. This is where we need to catch the exception, because one
    might be thrown; however, we do not want to do anything with it. In Swift, the
    code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Code like this is one of the things that I dislike about exception handling.
    Well, the Swift developers have an answer for this: `try?`. This attempts to perform
    an operation that may throw an error and converts it into an optional value; therefore,
    the result of the operation will be either `nil` if an error is thrown, or the
    result of the operation if no error is thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the results of `try?` are returned in the form of an optional, we would
    normally use this with optional binding. We could rewrite the previous example
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this makes our code much cleaner and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to perform a cleanup action, regardless of whether we had any errors,
    we can use a `defer` statement. We use `defer` statements to execute a block of
    code just before the code execution leaves the current scope. The following example
    shows how we can use the `defer` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we called this function, the first line to be printed to the console would
    be `Function started`. The code''s execution would skip over the `defer` block,
    and `Function finished` would then be printed to the console. Finally, the `defer`
    block of code would be executed just before we leave the function''s scope, and
    we would see the `In defer block` message. The following is the output of this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `defer` block will always be called before the execution leaves the current
    scope, even if an error is thrown. The `defer` statement is very useful when we
    want to make sure we perform all the necessary cleanup, even if an error is thrown.
    For example, if we successfully open a file to write to, we will always want to
    make sure we close that file, even if we encounter an error during the write operation.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we could put the file-closed functionality in a `defer` block
    to make sure that the file is always closed prior to leaving the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-pattern catch clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we had code that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the `catch` clause for the `PlayerNmberError.NumberTooHigh`
    and `PlayerNumberError.NumberTooLow` errors contains duplicate code. When you
    are developing, it is always good to find a way to eliminate duplicate code like
    this. However, prior to Swift 5.3, we did not have a choice. Swift introduced
    multi-pattern `catch` clauses with SE-0276 in Swift 5.3 to help reduce duplicate
    code like this. Let''s take a look at this by rewriting the previous code to use
    a multi-pattern `catch` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the first `catch` clause, we are now catching both the `PlayerNmberError.NumberTooHigh`
    and `PlayerNumberError.NumberTooLow` errors and that the errors are separated
    by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how to use the new availability attribute with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The availability attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing our applications for the latest **Operating System** (**OS**) version
    gives us access to all the latest features for the platform that we are developing
    for. However, there are times when we want to also target older platforms. Swift
    allows us to use the availability attribute to safely wrap code to run only when
    the correct version of the operating system is available. This was first introduced
    in Swift 2.
  prefs: []
  type: TYPE_NORMAL
- en: The availability attribute is only available when we use Swift on Apple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The availability block essentially lets us, if we are running the specified
    version of the operating system or higher, run this code or otherwise run some
    other code. There are two ways in which we can use the availability attribute.
    The first way allows us to execute a specific block of code that can be used with
    an `if` or a `guard` statement. The second way allows us to mark a method or type
    as available only on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The availability attribute accepts up to six comma-separated arguments, which
    allow us to define the minimum version of the operating system or application
    extension needed to execute our code. These arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iOS`: This is the minimum iOS version that is compatible with our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OSX`: This is the minimum OS X version that is compatible with our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watchOS`: This is the minimum watchOS version that is compatible with our
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tvOS`: This is the minimum tvOS version that is compatible with our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iOSApplicationExtension`: This is the minimum iOS application extension that
    is compatible with our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OSXApplicationExtension`: This is the minimum OS X application extension that
    is compatible with our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the argument, we specify the minimum version that is required. We only
    need to include the arguments that are compatible with our code. As an example,
    if we are writing an iOS application, we only need to include the iOS argument
    in the availability attribute. We end the argument list with an `*` (asterisk)
    as it is a placeholder for future versions. Let''s look at how we would execute
    a specific block of code only if we met the minimum requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `if #available(iOS 9.0, OSX 10.10, watchOS 2, *)` line
    of code prevents the block of code from executing when the application is run
    on a system that does not meet the specified minimum operating system version.
    In this example, we also use the `else` statement to execute a separate block
    of code if the operating system does not meet the minimum requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also restrict access to a function or a type. In the previous code,
    the `available` attribute was prefixed with the `#` (pound, also known as **octothorpe**
    and **hash**) character. To restrict access to a function or type, we prefix the
    `available` attribute with an `@` (at) character. The following example shows
    how we could restrict access to a type and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we specified that the `testAvailability()` function
    and the `testStruct()` type could only be accessed if the code was run on a device
    that has iOS version 9 or newer. In order to use the `@available` attribute to
    block access to a function or type, we must wrap the code that calls that function
    or type with the `#available` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we could call the `testAvailability()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `testAvailability()` function is only called if the application
    is running on a device that has iOS version 9 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at Swift's error handling features. While we are
    not required to use these features in our custom types, they do give us a uniform
    way to handle and respond to errors. Apple has also started to use this form of
    error handling in their frameworks. It is recommended that we use error handling
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the availability attribute, which allows us to develop applications
    that take advantage of the latest features of our target operating systems, while
    still allowing our applications to run on older versions. In the next chapter,
    we'll take a look at how to write custom subscripts.
  prefs: []
  type: TYPE_NORMAL
