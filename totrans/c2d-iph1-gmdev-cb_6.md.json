["```swift\n#import \"SimpleAudioEngine.h\"\n@implementation Ch6_SoundsAndMusic\n-(CCLayer*) runRecipe {\n//Initialize the audio engine\nsae = [SimpleAudioEngine sharedEngine];\n//Background music is stopped on resign and resumed on become active\n[[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n//Initialize source container\nsoundSources = [[NSMutableDictionary alloc] init];\n//Add the sounds\n[self loadSoundEffect:@\"crazy_chimp.caf\"];\n[self loadSoundEffect:@\"rapid_gunfire.caf\"];\n[self loadSoundEffect:@\"howie_scream.caf\"];\n[self loadSoundEffect:@\"air_horn.caf\"];\n[self loadSoundEffect:@\"slide_whistle.caf\"];\n//Add the background music\n[self loadBackgroundMusic:@\"hiphop_boss_man_by_p0ss.mp3\"];\n//Add menu items\nCCMenuItemSprite *musicItem = [self menuItemFromSpriteFile:@\"music_note.png\" tag:0];\nCCMenuItemSprite *chimpItem = [self menuItemFromSpriteFile:@\"you_stupid_monkey.png\" tag:1];\nCCMenuItemSprite *gunItem = [self menuItemFromSpriteFile:@\"tommy_gun.png\" tag:2];\nCCMenuItemSprite *screamItem = [self menuItemFromSpriteFile:@\"yaaargh.png\" tag:3];\nCCMenuItemSprite *airHornItem = [self menuItemFromSpriteFile:@\"air_horn.png\" tag:4];\nCCMenuItemSprite *slideWhistleItem = [self menuItemFromSpriteFile:@\"slide_whistle.png\" tag:5];\n//Create our menu\nCCMenu *menu = [CCMenu menuWithItems: musicItem, chimpItem, gunItem, screamItem, airHornItem, slideWhistleItem, nil];\n[menu alignItemsInColumns: [NSNumber numberWithUnsignedInt:3], [NSNumber numberWithUnsignedInt:3], nil];\nmenu.position = ccp(240,140);\n[self addChild:menu];\nreturn self;\n}\n//Play sound callback\n-(void) playSoundNumber:(id)sender {\nCCMenuItem *item = (CCMenuItem*)sender;\nint number = item.tag;\nif(number == 0){\n[self playBackgroundMusic:@\"hiphop_boss_man_by_p0ss.mp3\"];\n}else if(number == 1){\n[self playSoundFile:@\"crazy_chimp.caf\"];\n}else if(number == 2){\n[self playSoundFile:@\"rapid_gunfire.caf\"];\n}else if(number == 3){\n[self playSoundFile:@\"howie_scream.caf\"];\n}else if(number == 4){\n[self playSoundFile:@\"air_horn.caf\"];\n}else if(number == 5){\n[self playSoundFile:@\"slide_whistle.caf\"];\n}\n}\n-(void) loadBackgroundMusic:(NSString*)fn {\n//Pre-load background music\n[sae preloadBackgroundMusic:fn];\n}\n-(void) playBackgroundMusic:(NSString*)fn {\nif (![sae isBackgroundMusicPlaying]) {\n//Play background music\n[sae playBackgroundMusic:fn];\n}else{\n//Stop music if its currently playing\n[sae stopBackgroundMusic];\n}\n}\n-(CDSoundSource*) loadSoundEffect:(NSString*)fn {\n//Pre-load sound\n[sae preloadEffect:fn];\n//Init sound\nCDSoundSource *sound = [[sae soundSourceForFile:fn] retain];\n//Add sound to container\n[soundSources setObject:sound forKey:fn];\nreturn sound;\n}\n-(void) playSoundFile:(NSString*)fn {\n//Get sound\nCDSoundSource *sound = [soundSources objectForKey:fn];\n//Play sound\n[sound play];\n}\n-(void) cleanRecipe {\n//Stop background music\n[sae stopBackgroundMusic];\nfor(id s in soundSources){\n//Release source\nCDSoundSource *source = [soundSources objectForKey:s];\n[source release];\n}\n[soundSources release];\n//End engine\n[SimpleAudioEngine end];\nsae = nil;\n[super cleanRecipe];\n}\n@end\n\n```", "```swift\n    [[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n\n    ```", "```swift\n    [sae preloadEffect:@\"crazy_chimp.caf\"];\n\n    ```", "```swift\n    CDSoundSource *sound = [[sae soundSourceForFile:fn] retain];\n\n    ```", "```swift\n    NSMutableDictionary *soundSources = [[[NSMutableDictionary alloc] init] autorelease];\n    [soundSources setObject:sound forKey:fn];\n\n    ```", "```swift\n    CDSoundSource *sound = [soundSources objectForKey:fn];\n    [sound play];\n\n    ```", "```swift\n    [sae preloadBackgroundMusic: @\"hiphop_boss_man_by_p0ss.mp3\"];\n    [sae playBackgroundMusic:@\"hiphop_boss_man_by_p0ss.mp3\"];\n\n    ```", "```swift\n    CDLongAudioSource *bgm = [CDAudioManager sharedManager].backgroundMusic;\n\n    ```", "```swift\nafconvert -f caff -d ima4 mysound.wav\n\n```", "```swift\n#import \"SimpleAudioEngine.h\"\n@implementation Ch6_AudioProperties\n-(CCLayer*) runRecipe {\n//Enable accelerometer support\nself.isAccelerometerEnabled = YES;\n[[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0 / 60)];\n//Add background\nCCSprite *bg = [CCSprite spriteWithFile:@\"synth_tone_sheet.png\"];\nbg.position = ccp(240,160);\n[self addChild:bg];\n//Initialize the audio engine\nsae = [SimpleAudioEngine sharedEngine];\n//Background music is stopped on resign and resumed on becoming active\n[[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n//Initialize note container\nnotes = [[NSMutableDictionary alloc] init];\nnoteSprites = [[NSMutableDictionary alloc] init];\n//Preload tone\n[sae preloadEffect:@\"synth_tone_mono.caf\"];\nreturn self;\n}\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\n//Process multiple touches\nfor(int i=0; i<[[touches allObjects] count]; i++){\nUITouch *touch = [[touches allObjects] objectAtIndex:i];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//Use [touch hash] as a key for this sound source\nNSString *key = [NSString stringWithFormat:@\"%d\",[touch hash]];\nif([notes objectForKey:key]){\nCDSoundSource *sound = [notes objectForKey:key];\n[sound release];\n[notes removeObjectForKey:key];\nCCSprite *sprite = [noteSprites objectForKey:key];\n[self removeChild:sprite cleanup:YES];\n[noteSprites removeObjectForKey:key];\n}\n//Play our sound with custom pitch and gain\nCDSoundSource *sound = [[sae soundSourceForFile:@\"synth_tone_mono.caf\"] retain];\n[sound play];\nsound.looping = YES;\n[notes setObject:sound forKey:key];\nsound.pitch = point.x/240.0f;\nsound.gain = point.y/320.0f;\n//Show music note where you touched\nCCSprite *sprite = [CCSprite spriteWithFile:@\"music_note.png\"];\nsprite.position = point;\n[noteSprites setObject:sprite forKey:key];\nsprite.scale = (point.y/320.0f)/2 + 0.25f;\n[self addChild:sprite];\n}\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n//Adjust sound sources and music note positions\nfor(int i=0; i<[[touches allObjects] count]; i++){\nUITouch *touch = [[touches allObjects] objectAtIndex:i];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\nNSString *key = [NSString stringWithFormat:@\"%d\",[touch hash]];\nif([notes objectForKey:key]){\nCDSoundSource *sound = [notes objectForKey:key];\nsound.pitch = point.x/240.0f;\nsound.gain = point.y/320.0f;\nCCSprite *sprite = [noteSprites objectForKey:key];\nsprite.position = point;\nsprite.scale = (point.y/320.0f)/2 + 0.25f;\n}\n}\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n//Stop sounds and remove sprites\nfor(int i=0; i<[[touches allObjects] count]; i++){\nUITouch *touch = [[touches allObjects] objectAtIndex:i];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\nNSString *key = [NSString stringWithFormat:@\"%d\",[touch hash]];\nif([notes objectForKey:key]){\n//Stop and remove sound source\nCDSoundSource *sound = [notes objectForKey:key];\n[sound stop];\n[sound release];\n[notes removeObjectForKey:key];\n//Remove sprite\nCCSprite *sprite = [noteSprites objectForKey:key];\n[self removeChild:sprite cleanup:YES];\n[noteSprites removeObjectForKey:key];\n}\n}\n}\n//Adjust sound pan by turning the device sideways\n- (void) accelerometer:(UIAccelerometer*)accelerometer didAccelerate:(UIAcceleration*)acceleration{\nfor(id s in notes){\nCDSoundSource *sound = [notes objectForKey:s];\nsound.pan = -acceleration.y; //\"Turn\" left to pan to the left speaker\n}\n}\n@end\n\n```", "```swift\nCDSoundSource *sound = [[sae soundSourceForFile:@\"synth_tone_mono.caf\"] retain];\n[sound play];\nsound.looping = YES;\n\n```", "```swift\nsound.pitch = point.x/240.0f;\n\n```", "```swift\nsound.gain = point.y/320.0f;\n\n```", "```swift\nfor(id s in notes){\nCDSoundSource *sound = [notes objectForKey:s];\nsound.pan = -acceleration.y; //\"Turn\" left to pan to the left speaker\n}\n\n```", "```swift\n#import \"SimpleAudioEngine.h\"\n#import \"CDXPropertyModifierAction.h\"\n@implementation Ch6_FadingSoundsAndMusic\n-(CCLayer*) runRecipe {\n//Initialize the audio engine\nsae = [SimpleAudioEngine sharedEngine];\n//Background music is stopped on resign and resumed on becoming active\n[[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n//Initialize source container\nsoundSources = [[NSMutableDictionary alloc] init];\nmusicSources = [[NSMutableDictionary alloc] init];\n//Add music\n[self loadMusic:@\"hiphop_boss_man_by_p0ss.mp3\"];\n[self loadMusic:@\"menu_music_by_mrpoly.mp3\"];\n//Add sounds\n[self loadSoundEffect:@\"gunman_pain.caf\"];\n[self loadSoundEffect:@\"synth_tone.caf\"];\n//Add menu items\n/* CODE OMITTED */\nreturn self;\n}\n//Play music callback\n-(void) playMusicNumber:(id)sender {\nCCMenuItem *item = (CCMenuItem*)sender;\nint number = item.tag;\nif(number == 0){\n[self fadeOutPlayingMusic];\n[self fadeInMusicFile:@\"hiphop_boss_man_by_p0ss.mp3\"];\n}else if(number == 1){\n[self fadeOutPlayingMusic];\n[self fadeInMusicFile:@\"menu_music_by_mrpoly.mp3\"];\n}\n}\n//Fade out any music sources currently playing\n-(void) fadeOutPlayingMusic {\nfor(id m in musicSources){\n//Release source\nCDLongAudioSource *source = [musicSources objectForKey:m];\nif(source.isPlaying){\n//Create fader\nCDLongAudioSourceFader* fader = [[CDLongAudioSourceFader alloc] init:source interpolationType:kIT_Exponential startVal:source.volume endVal:0.0f];\n[fader setStopTargetWhenComplete:NO];\n//Create a property modifier action to wrap the fader\nCDXPropertyModifierAction* fadeAction = [CDXPropertyModifierAction actionWithDuration:3.0f modifier:fader];\n[fader release];//Action will retain\nCCCallFuncN* stopAction = [CCCallFuncN actionWithTarget:source selector:@selector(stop)];\n[[CCActionManager sharedManager] addAction:[CCSequence actions:fadeAction, stopAction, nil] target:source paused:NO];\n}\n}\n}\n//Fade in a specific music file\n-(void) fadeInMusicFile:(NSString*)fn {\n//Stop music if its playing and return\nCDLongAudioSource *source = [musicSources objectForKey:fn];\nif(source.isPlaying){\n[source stop];\nreturn;\n}\n//Set volume to zero and play\nsource.volume = 0.0f;\n[source play];\n//Create fader\nCDLongAudioSourceFader* fader = [[CDLongAudioSourceFader alloc] init:source interpolationType:kIT_Exponential startVal:source.volume endVal:1.0f];\n[fader setStopTargetWhenComplete:NO];\n//Create a property modifier action to wrap the fader\nCDXPropertyModifierAction* fadeAction = [CDXPropertyModifierAction actionWithDuration:1.5f modifier:fader];\n[fader release];//Action will retain\n[[CCActionManager sharedManager] addAction:[CCSequence actions:fadeAction, nil] target:source paused:NO];\n}\n-(void) fadeUpAllSfx:(id)sender {\n//Fade up all sound effects\n[CDXPropertyModifierAction fadeSoundEffects:2.0f finalVolume:1.0f curveType:kIT_Linear shouldStop:NO];\n}\n-(void) fadeDownAllSfx:(id)sender {\n//Fade down all sound effects\n[CDXPropertyModifierAction fadeSoundEffects:2.0f finalVolume:0.0f curveType:kIT_Linear shouldStop:NO];\n}\n-(void) fadeUpSfxNumber:(id)sender {\n//Fade up a specific sound effect\nCCMenuItem *item = (CCMenuItem*)sender;\nint number = item.tag;\nCDSoundSource *source;\nif(number == 0){\nsource = [soundSources objectForKey:@\"gunman_pain.caf\"];\n}else if(number == 1){\nsource = [soundSources objectForKey:@\"synth_tone.caf\"];\n}\nsource.gain = 0.0f;\n[CDXPropertyModifierAction fadeSoundEffect:2.0f finalVolume:1.0f curveType:kIT_Linear shouldStop:NO effect:source];\n}\n-(void) fadeDownSfxNumber:(id)sender {\n//Fade down a specific sound effect\nCCMenuItem *item = (CCMenuItem*)sender;\nint number = item.tag;\nCDSoundSource *source;\nif(number == 0){\nsource = [soundSources objectForKey:@\"gunman_pain.caf\"];\n}else if(number == 1){\nsource = [soundSources objectForKey:@\"synth_tone.caf\"];\n}\nsource.gain = 1.0f;\n[CDXPropertyModifierAction fadeSoundEffect:2.0f finalVolume:0.0f curveType:kIT_Linear shouldStop:NO effect:source];\n}\n@end\n\n```", "```swift\n    CDLongAudioSourceFader* fader = [[CDLongAudioSourceFader alloc] init:source interpolationType:kIT_Linear startVal:source.volume endVal:0.0f];\n    [fader setStopTargetWhenComplete:NO];\n\n    ```", "```swift\n    CDXPropertyModifierAction* fadeAction = [CDXPropertyModifierAction actionWithDuration:3.0f modifier:fader];\n    [fader release];\n\n    ```", "```swift\n    CCCallFuncN* stopAction = [CCCallFuncN actionWithTarget:source selector:@selector(stop)];\n\n    ```", "```swift\n    [[CCActionManager sharedManager] addAction:[CCSequence actions:fadeAction, stopAction, nil] target:source paused:NO];\n\n    ```", "```swift\n    [CDXPropertyModifierAction fadeSoundEffect:2.0f finalVolume:0.0f curveType:kIT_Linear shouldStop:YES effect:source];\n\n    ```", "```swift\n    [CDXPropertyModifierAction fadeSoundEffects:2.0f finalVolume:0.0f curveType:kIT_Linear shouldStop:YES];\n\n    ```", "```swift\n#import \"Ch4_Bullets.h\"\n#import \"SimpleAudioEngine.h\"\n@interface Ch6_AudioInGame : Ch4_Bullets\n/* CODE OMITTED */\n@end\n@implementation Ch6_AudioInGame\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Initialize the audio engine\nsae = [SimpleAudioEngine sharedEngine];\n//Background music is stopped on resign and resumed on becoming active\n[[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n//Initialize source container\nsoundSources = [[NSMutableDictionary alloc] init];\n//Add the sounds\n[self loadSoundEffect:@\"bullet_fire_no_shell.caf\" gain:1.0f];\n[self loadSoundEffect:@\"bullet_casing_tink.caf\" gain:0.25f];\n[self loadSoundEffect:@\"gunman_jump.caf\" gain:1.5f];\n[self loadSoundEffect:@\"box_break.wav\" gain:1.5f];\n//Add the background music\n[self loadBackgroundMusic:@\"hiphop_boss_man_by_p0ss.mp3\"];\nsae.backgroundMusicVolume = 0.5f;\n[self playBackgroundMusic:@\"hiphop_boss_man_by_p0ss.mp3\"];\nreturn self;\n}\n//Jump sound override\n-(void) processJump {\nif(onGround && jumpCounter < 0){\n[self playSoundFile:@\"gunman_jump.caf\"];\n}\n[super processJump];\n}\n//Fire gun sound override\n-(void) fireGun {\nif(fireCount <= 0){\n[self playSoundFile:@\"bullet_fire_no_shell.caf\"];\n}\n[super fireGun];\n}\n//Box explosion sound override\n-(void) boxExplosionAt:(CGPoint)p withRotation:(float)rot {\n[self playSoundFile:@\"box_break.wav\"];\n[super boxExplosionAt:p withRotation:rot];\n}\n//Bullet casing sound override\n-(void) handleCollisionWithMisc:(GameMisc*)a withMisc:(GameMisc*)b {\nif(a.typeTag == TYPE_OBJ_SHELL || b.typeTag == TYPE_OBJ_SHELL){\n[self playSoundFile:@\"bullet_casing_tink.caf\"];\n}\n[super handleCollisionWithMisc:a withMisc:b];\n}\n@end\n\n```", "```swift\n#import \"Ch4_TopDownIsometric.h\"\n#import \"SimpleAudioEngine.h\"\nenum {\nCGROUP_NON_INTERRUPTIBLE = 0\n};\n@interface Ch6_PositionalAudio : Ch4_TopDownIsometric\n/* CODE OMITTED */\n@end\n@implementation Ch6_PositionalAudio\n-(CCLayer*) runRecipe {\n//Run our top-down isometric game recipe\n[super runRecipe];\n//Initialize max audible range\naudibleRange = 20.0f;\n//Initialize the audio engine\nsae = [SimpleAudioEngine sharedEngine];\n//Background music is stopped on resign and resumed on becoming active\n[[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n//Preload the sounds\n[sae preloadEffect:@\"forest_birds_ambience.caf\"];\n[sae preloadEffect:@\"kick_ball_bounce.caf\"];\n[sae preloadEffect:@\"gunman_jump.caf\"];\n[sae preloadEffect:@\"bullet_fire_no_shell.caf\"];\n//Non-interruptible ball source group\n[[CDAudioManager sharedManager].soundEngine setSourceGroupNonInterruptible:CGROUP_NON_INTERRUPTIBLE isNonInterruptible:YES];\n//Add the sounds\nballSource = [[sae soundSourceForFile:@\"kick_ball_bounce.caf\"] retain];\nforestBirdsSource = [[sae soundSourceForFile:@\"forest_birds_ambience.caf\"] retain];\ngunmanJumpSource = [[sae soundSourceForFile:@\"gunman_jump.caf\"] retain];\nfireBallSource = [[sae soundSourceForFile:@\"bullet_fire_no_shell.caf\"] retain];\n//Start playing forest bird source\nforestBirdsSource.gain = 0.0f;\nforestBirdsSource.looping = YES;\n[forestBirdsSource play];\n//Customize fire ball sound\nfireBallSource.pitch = 2.0f;\nfireBallSource.gain = 0.5f;\nreturn self;\n}\n-(void) step:(ccTime)delta {\n[super step:delta];\n//Play forest bird source with gain based on distance from gunman\nfloat distance = 10000.0f;\nfor(int i=0; i<[trees count]; i++){\nGameObject *tree = [trees objectAtIndex:i];\nfloat thisDistance = distanceBetweenPoints(ccp(tree.body->GetPosition().x,tree.body->GetPosition().y),\nccp(gunman.body->GetPosition().x, gunman.body->GetPosition().y));\nif(thisDistance < distance){ distance = thisDistance; }\n}\n//If closest tree is outside of audible range we set gain to 0.0f\nif(distance < audibleRange){\nforestBirdsSource.gain = (audibleRange-distance)/audibleRange;\n}else{\nforestBirdsSource.gain = 0.0f;\n}\n}\n//Fire ball sound override\n-(void) fireBall {\nif(fireCount < 0){\n[fireBallSource play];\n}\n[super fireBall];\n}\n//Jump sound override\n-(void) processJump {\nif(gunman.body->GetZPosition() <= 1.0f){\n[gunmanJumpSource play];\n}\n[super processJump];\n}\n-(void) handleCollisionWithGroundWithObj:(GameObject*)gameObject {\n[super handleCollisionWithGroundWithObj:gameObject];\n//Play ball bounce sound with gain based on distance from gunman\nif(gameObject.typeTag == TYPE_OBJ_BALL){\nfloat distance = distanceBetweenPoints(ccp(gameObject.body->GetPosition().x, gameObject.body->GetPosition().y), ccp(gunman.body->GetPosition().x, gunman.body->GetPosition().y));\nif(distance < audibleRange){\nfloat gain = (audibleRange-distance)/audibleRange;\nfloat pan = (gameObject.body->GetPosition().x - gunman.body->GetPosition().x)/distance;\nfloat pitch = ((((GameIsoObject*)gameObject).inGameSize / 10.0f) * -1) + 2;\nif(distance < audibleRange){\n[self playBallSoundWithGain:gain pan:pan pitch:pitch];\n}\n}\n}\n}\n-(void) playBallSoundWithGain:(float)gain pan:(float)pan pitch:(float)pitch {\n//Play the sound using the non-interruptible source group\n[[CDAudioManager sharedManager].soundEngine playSound:ballSource.soundId sourceGroupId:CGROUP_NON_INTERRUPTIBLE pitch:pitch pan:pan gain:gain loop:NO];\n}\n@end\n\n```", "```swift\n    if(distance < audibleRange){\n    forestBirdsSource.gain = (audibleRange-distance)/audibleRange;\n    }else{\n    forestBirdsSource.gain = 0.0f;\n    }\n\n    ```", "```swift\n    float gain = (audibleRange-distance)/audibleRange;\n\n    ```", "```swift\n    float pan = (gameObject.body->GetPosition().x - gunman.body->GetPosition().x)/distance;\n\n    ```", "```swift\n    float pitch = ((((GameIsoObject*)gameObject).inGameSize / 10.0f) * -1) + 2;\n\n    ```", "```swift\n    enum { CGROUP_NON_INTERRUPTIBLE = 0 };\n    [[CDAudioManager sharedManager].soundEngine setSourceGroupNonInterruptible:CGROUP_NON_INTERRUPTIBLE isNonInterruptible:YES];\n\n    ```", "```swift\n    [[CDAudioManager sharedManager].soundEngine playSound:ballSource.soundId sourceGroupId:CGROUP_NON_INTERRUPTIBLE pitch:pitch pan:pan gain:gain loop:NO];\n\n    ```", "```swift\n    #define CD_BUFFERS_START 64\n    #define CD_BUFFERS_INCREMENT 16\n\n    ```", "```swift\n#import \"SimpleAudioEngine.h\"\n@implementation Ch6_MeteringMusic\n-(CCLayer*) runRecipe {\n//Initialize the audio engine\nsae = [SimpleAudioEngine sharedEngine];\n//Background music is stopped on resign and resumed on becoming active\n[[CDAudioManager sharedManager] setResignBehavior:kAMRBStopPlay autoHandle:YES];\n//Set peak and average power initially\npeakPower = 0;\navgPower = 0;\n//Init speaker sprites (speakerBase, speakerLarge and speakerSmall)\n/* CODE OMITTED */\n//Init meter sprites (avgMeter and peakMeter)\n/* CODE OMITTED */\n//Add the background music\n[sae preloadBackgroundMusic:@\"technogeek_by_mrpoly.mp3\"];\n[sae playBackgroundMusic:@\"technogeek_by_mrpoly.mp3\"];\n//Enable metering\n[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer.meteringEnabled = YES;\n//Schedule step method\n[self schedule:@selector(step:)];\nreturn self;\n}\n-(void) step:(ccTime)delta {\n[self setPeakAndAveragePower];\n[self animateMeterAndSpeaker];\n}\n-(void) setPeakAndAveragePower {\n//Update meters\n[[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer updateMeters];\n//Get channels\nint channels = [CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer.numberOfChannels;\n//Average all the channels\nfloat peakPowerNow = 0;\nfloat avgPowerNow = 0;\nfor(int i=0; i<channels; i++){\nfloat peak = [[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer peakPowerForChannel:i];\nfloat avg = [[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer averagePowerForChannel:i];\npeakPowerNow += peak/channels;\navgPowerNow += avg/channels;\n}\n//Change from a DB level to a 0 to 1 ratio\nfloat adjustedPeak = pow(10, (0.05 * peakPowerNow));\nfloat adjustedAvg = pow(10, (0.05 * avgPowerNow));\n//Average it out for smoothing\npeakPower = (peakPower + adjustedPeak)/2;\navgPower = (avgPower + adjustedAvg)/2;\n}\n-(void) animateMeterAndSpeaker {\n//Average meter\n[avgMeter setTextureRect:CGRectMake(0,0,10,avgPower*500.0f)];\n//Peak meter\npeakMeter.position = ccp(100,20+peakPower*500.0f);\n//Animate speaker\nspeakerLarge.scale = powf(avgPower,0.4f)*2;\nspeakerSmall.scale = powf(avgPower,0.4f)*2;\n}\n@end\n\n```", "```swift\n[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer.meteringEnabled = YES;\n\n```", "```swift\n[[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer updateMeters];\nint channels = [CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer.numberOfChannels;\nfor(int i=0; i<channels; i++){\nfloat peak = [[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer peakPowerForChannel:i];\nfloat avg = [[CDAudioManager sharedManager].backgroundMusic.audioSourcePlayer averagePowerForChannel:i];\npeakPowerNow += peak/channels;\navgPowerNow += avg/channels;\n}\n\n```", "```swift\n//Change from a DB level to a 0 to 1 ratio\nfloat adjustedPeak = pow(10, (0.05 * peakPowerNow));\nfloat adjustedAvg = pow(10, (0.05 * avgPowerNow));\n//Average it out for smoothing\npeakPower = (peakPower + adjustedPeak)/2;\navgPower = (avgPower + adjustedAvg)/2;\n\n```", "```swift\n#import \"SimpleAudioEngine.h\"\n@implementation Ch6_MeteringDialogue\n-(CCLayer*) runRecipe {\n/* CODE OMITTED */\n//Add the sounds\n[self loadLongAudioSource:@\"claghorn_a_joke_son.caf\"];\n[self loadLongAudioSource:@\"claghorn_carolina.caf\"];\n/* CODE OMITTED */\n//Add the background music\n[self loadBackgroundMusic:@\"dixie_1916.mp3\"];\n/* CODE OMITTED */\n//Play background music\n[self playBackgroundMusic:@\"dixie_1916.mp3\"];\n//Have Claghorn introduce himself\n[self playLongAudioSource:@\"claghorn_howdy.caf\"];\n}\n-(void) step:(ccTime)delta {\n/* CODE OMITTED */\n[self setPeakAndAveragePower];\n[self animateClaghorn];\n}\n-(void) setPeakAndAveragePower {\n//Find our playing audio source\nCDLongAudioSource *audioSource = nil;\nfor(id s in soundSources){\nCDLongAudioSource *source = [soundSources objectForKey:s];\nif(source.isPlaying){\naudioSource = source;\nbreak;\n}\n}\n//Update meters\n[audioSource.audioSourcePlayer updateMeters];\n/* CODE OMITTED */\n}\n-(void) animateClaghorn {\n/* Custom mouth animation */\nfloat level = avgPower;\n//Make sure he's actually speaking\nif(level == 0){\nclaghornEyebrows.position = ccp(240,120);\nclaghornMouth.position = ccp(240,120);\nlastAudioLevel = level;\nreturn;\n}\n//Level bounds\nif(level <= 0){ level = 0.01f; }\nif(level >= 1){ level = 0.99f; }\n//Exaggerate level ebb and flow\nif(level < lastAudioLevel){\n//Closing mouth\nlastAudioLevel = level;\nlevel = powf(level,1.5f);\n}else{\n//Opening mouth\nlastAudioLevel = level;\nlevel = powf(level,0.75f);\n}\n//If mouth is almost closed, close mouth\nif(level < 0.1f){ level = 0.01f; }\n//Blink if level > 0.8f\nif(level > 0.8f && !isBlinking){\n[self blink];\n[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:0.5f],\n[CCCallFunc actionWithTarget:self selector:@selector(unblink)], nil]];\n}\n//Raise eyebrows if level > 0.6f\nif(level > 0.6f){\nclaghornEyebrows.position = ccp(240,120 + level*5.0f);\n}else{\nclaghornEyebrows.position = ccp(240,120);\n}\n//Set mouth position\nclaghornMouth.position = ccp(240,120 - level*19.0f);\n}\n-(CDLongAudioSource*) loadLongAudioSource:(NSString*)fn {\n//Init source\nCDLongAudioSource *source = [[CDLongAudioSource alloc] init];\nsource.backgroundMusic = NO;\n[source load:fn];\n//Enable metering\nsource.audioSourcePlayer.meteringEnabled = YES;\n//Add sound to container\n[soundSources setObject:source forKey:fn];\nreturn source;\n}\n-(void) playLongAudioSource:(NSString*)fn {\n//Get sound\nCDLongAudioSource *audioSource = [soundSources objectForKey:fn];\nbool aSourceIsPlaying = NO;\nfor(id s in soundSources){\nCDLongAudioSource *source = [soundSources objectForKey:s];\nif(source.isPlaying){\n[source stop];\n[source rewind];\naSourceIsPlaying = YES;\nbreak;\n}\n}\n//Play sound\nif(!aSourceIsPlaying){\n//Play sound\n[audioSource play];\n[self runAction: [CCSequence actions: [CCDelayTime actionWithDuration:[audioSource.audioSourcePlayer duration]],\n[CCCallFunc actionWithTarget:audioSource selector:@selector(stop)],\n[CCCallFunc actionWithTarget:audioSource selector:@selector(rewind)], nil]];\n}\n}\n@end\n\n```", "```swift\nCDLongAudioSource *audioSource = nil;\nfor(id s in soundSources){\nCDLongAudioSource *source = [soundSources objectForKey:s];\nif(source.isPlaying){\naudioSource = source;\nbreak;\n}\n}\n[audioSource.audioSourcePlayer updateMeters];\n\n```", "```swift\nif(level < lastAudioLevel){\nlastAudioLevel = level;\nlevel = powf(level,1.5f);\n}else{\nlastAudioLevel = level;\nlevel = powf(level,0.75f);\n}\n\n```", "```swift\n#import <MediaPlayer/MediaPlayer.h>\n#import \"AppDelegate.h\"\n@implementation Ch6_StreamingAudio\n-(CCLayer*) runRecipe {\n//Create music player buttons\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@\"music_player.plist\"];\nCCMenuItemSprite *prevItem = [self menuItemFromSpriteFile:@\"music_player_prev.png\" target:self selector:@selector(previousSong:)];\n/* CODE OMITTED */\n//Create menu\n/* CODE OMITTED */\n//Initial variable values\nsourceIndex = 0;\nisPlaying = NO;\n//Streaming sources\nstreamingSources = [[NSMutableArray alloc] init];\n[streamingSources addObject:@\"http://shoutmedia.abc.net.au:10326\"];\n[streamingSources addObject:@\"http://audioplayer.wunderground.com/drgruver/Philadelphia.mp3.m3u\"];\n[streamingSources addObject:@\"http://s8.mediastreaming.it:7050/\"];\n[streamingSources addObject:@\"http://www.radioparadise.com/musiclinks/rp_64aac.m3u\"];\n[streamingSources addObject:@\"http://streaming.wrek.org:8000/wrek_HD-2.m3u\"];\n//Init movie playing (music streamer in this case)\nmoviePlayer = [[MPMoviePlayerController alloc] init];\nmoviePlayer.movieSourceType = MPMovieSourceTypeStreaming;\nmoviePlayer.view.hidden = YES;\n((AppDelegate*)[UIApplication sharedApplication].delegate).window addSubview:moviePlayer.view];\n//Set initial stream source\n[self setStreamSource];\nreturn self;\n}\n//Next callback\n- (void) nextSong:(id)sender {\n[self setIsPlaying];\nsourceIndex++;\nif(sourceIndex > [streamingSources count]-1){\nsourceIndex = 0;\n}\n[self setStreamSource];\n}\n//Previous callback\n- (void) previousSong:(id)sender {\n[self setIsPlaying];\nsourceIndex--;\nif(sourceIndex < 0){\nsourceIndex = [streamingSources count]-1;\n}\n[self setStreamSource];\n}\n-(void) setIsPlaying {\nif(moviePlayer.playbackState == MPMoviePlaybackStatePlaying){\nisPlaying = YES;\n}\n}\n-(void) setStreamSource {\n[moviePlayer stop];\nmoviePlayer.contentURL = [NSURL URLWithString:[streamingSources objectAtIndex:sourceIndex]];\nif(isPlaying){\n[self playMusic:nil];\n}\n}\n@end\n\n```", "```swift\nmoviePlayer.movieSourceType = MPMovieSourceTypeStreaming;\nmoviePlayer.view.hidden = YES;\n\n```", "```swift\n    ((AppDelegate*)[UIApplication sharedApplication].delegate).window addSubview:moviePlayer.view];\n\n    ```", "```swift\n    [moviePlayer stop];\n    moviePlayer.contentURL = [NSURL URLWithString:[streamingSources objectAtIndex:sourceIndex]];\n    if(isPlaying){\n    [self playMusic:nil];\n    }\n\n    ```", "```swift\n#import <AVFoundation/AVFoundation.h>\n#import <CoreAudio/CoreAudioTypes.h>\n#import \"CocosDenshion.h\"\n@interface Ch6_RecordingAudio : Recipe <AVAudioRecorderDelegate>\n{ /* CODE OMITTED */}\n@implementation Ch6_RecordingAudio\n-(CCLayer*) runRecipe {\n//Set initial pitch and recorded temp file object\npitch = 1.0f;\nrecordedTmpFile = nil;\n//Init audio session\n[self initAudioSession];\n/* CODE OMITTED */\nreturn self;\n}\n-(void) initAudioSession {\n//Our AVAudioSession singleton pointer\nAVAudioSession * audioSession = [AVAudioSession sharedInstance];\n//Set up the audioSession for playback and record.\n[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];\n//Activate the session\n[audioSession setActive:YES error:nil];\n//Init CDSoundEngine\nsoundEngine = [[CDSoundEngine alloc] init];\n//Define source groups\nNSArray *defs = [NSArray arrayWithObjects: [NSNumber numberWithInt:1],nil];\n[soundEngine defineSourceGroups:defs];\n}\n-(void) recordAudio {\n//Set settings dictionary: IMA4 format, 44100 sample rate, 2 channels\nNSMutableDictionary* recordSetting = [[[NSMutableDictionary alloc] init] autorelease];\n[recordSetting setValue :[NSNumber numberWithInt:kAudioFormatAppleIMA4] forKey:AVFormatIDKey];\n[recordSetting setValue:[NSNumber numberWithFloat:44100.0] forKey:AVSampleRateKey];\n[recordSetting setValue:[NSNumber numberWithInt: 2] forKey:AVNumberOfChannelsKey];\n//Set recording temp file location on disk\nrecordedTmpFile = [NSURL fileURLWithPath:[NSTemporaryDirectory() stringByAppendingPathComponent: [NSString stringWithString: @\"recording.caf\"]]];\n//Init AVAudioRecorder with location and settings\nrecorder = [[AVAudioRecorder alloc] initWithURL:recordedTmpFile settings:recordSetting error:nil];\n//Set delegate and start recording\n[recorder setDelegate:self];\n[recorder prepareToRecord];\n[recorder record];\n}\n-(void) playAudio {\n//Override the audio to go back to the speaker\nUInt32 audioRouteOverride = kAudioSessionOverrideAudioRoute_Speaker;\nAudioSessionSetProperty(kAudioSessionProperty_OverrideAudioRoute, sizeof (audioRouteOverride),&audioRouteOverride);\n//Get the file path to the recorded audio\nNSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent: [NSString stringWithString: @\"recording.caf\"]];\n//Play our recorded audio\n[soundEngine loadBuffer:0 filePath: filePath];\n[soundEngine playSound:0 sourceGroupId:0 pitch:pitch pan:0.0f gain:10.0f loop: NO];\n}\n-(void) stopRecordingAudio {\n//Stop recording\n[recorder stop];\n}\n- (void) unloadAudioSession {\n//Remove temp file\nNSFileManager * fm = [NSFileManager defaultManager];\nif(recordedTmpFile){ [fm removeItemAtURL:recordedTmpFile error:nil]; }\n//Release recorder\n[recorder dealloc];\nrecorder = nil;\n//Release sound engine\n[soundEngine release];\n//Deactivate audio session\nAVAudioSession * audioSession = [AVAudioSession sharedInstance];\n[audioSession setActive:NO error:nil];\n}\n@end\n\n```", "```swift\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];\n\n    ```", "```swift\n    [[AVAudioSession sharedInstance] setActive:YES error:nil];\n\n    ```", "```swift\n    soundEngine = [[CDSoundEngine alloc] init];\n    NSArray *defs = [NSArray arrayWithObjects: [NSNumber numberWithInt:1],nil];\n    [soundEngine defineSourceGroups:defs];\n\n    ```", "```swift\n    NSMutableDictionary* recordSetting = [[[NSMutableDictionary alloc] init] autorelease];\n    [recordSetting setValue :[NSNumber numberWithInt:kAudioFormatAppleIMA4] forKey:AVFormatIDKey];\n    [recordSetting setValue:[NSNumber numberWithFloat:44100.0] forKey:AVSampleRateKey];\n    [recordSetting setValue:[NSNumber numberWithInt: 2] forKey:AVNumberOfChannelsKey];\n    recordedTmpFile = [NSURL fileURLWithPath:[NSTemporaryDirectory() stringByAppendingPathComponent: [NSString stringWithString: @\"recording.caf\"]]];\n    recorder = [[AVAudioRecorder alloc] initWithURL:recordedTmpFile settings:recordSetting error:nil];\n\n    ```", "```swift\n    [recorder setDelegate:self];\n\n    ```", "```swift\n    [recorder prepareToRecord];\n    [recorder record];\n\n    ```", "```swift\n    [recorder stop];\n\n    ```", "```swift\n    UInt32 audioRouteOverride = kAudioSessionOverrideAudioRoute_Speaker;\n    AudioSessionSetProperty(kAudioSessionProperty_OverrideAudioRoute, sizeof (audioRouteOverride),&audioRouteOverride);\n\n    ```", "```swift\n    NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent: [NSString stringWithString: @\"recording.caf\"]];\n    [soundEngine loadBuffer:0 filePath: filePath];\n    [soundEngine playSound:0 sourceGroupId:0 pitch:pitch pan:0.0f gain:10.0f loop:NO];\n\n    ```", "```swift\n#import <MediaPlayer/MediaPlayer.h>\n#import \"AppDelegate.h\"\n@interface Ch6_iPodLibrary : Recipe <MPMediaPickerControllerDelegate>\n{ /* CODE OMITTED */ }\n@implementation Ch6_iPodLibrary\n-(CCLayer*) runRecipe {\n//Device detection\nNSString *model = [[UIDevice currentDevice] model];\n//Show a blank recipe if we use the simulator\nif([model isEqualToString:@\"iPhone Simulator\"]){\nmessage.position = ccp(240,250);\n[self showMessage:@\"This recipe is not compatible with the Simulator. \\nPlease connect a device.\"];\nreturn self;\n}\n/* CODE OMITTED */\n//Init music player\nmusicPlayer = [MPMusicPlayerController iPodMusicPlayer];\n[musicPlayer setRepeatMode:MPMusicRepeatModeAll];\n//Initial sync of display with music player state\n[self handleNowPlayingItemChanged:nil];\n//Register for music player notifications\nNSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n[notificationCenter addObserver:self selector:@selector(handleNowPlayingItemChanged:)\nname:MPMusicPlayerControllerNowPlayingItemDidChangeNotification object:musicPlayer];\n[musicPlayer beginGeneratingPlaybackNotifications];\nreturn self;\n}\n- (void) handleNowPlayingItemChanged:(id)notification {\n//Get the current playing item\nMPMediaItem *currentItem = musicPlayer.nowPlayingItem;\n//Set labels\nif([currentItem valueForProperty:MPMediaItemPropertyTitle]){\n[songLabel setString: [NSString stringWithFormat:@\"%@\",[currentItem valueForProperty:MPMediaItemPropertyTitle]]];\n[artistLabel setString: [NSString stringWithFormat:@\"%@\",[currentItem valueForProperty:MPMediaItemPropertyArtist]]];\n[albumLabel setString: [NSString stringWithFormat:@\"%@\",[currentItem valueForProperty:MPMediaItemPropertyAlbumTitle]]];\n}\n//Get album artwork\nMPMediaItemArtwork *artwork = [currentItem valueForProperty:MPMediaItemPropertyArtwork];\nUIImage *artworkImage = nil;\nif(artwork) { artworkImage = [artwork imageWithSize:CGSizeMake(100,100)]; }\n//Remove current album art if necessary\nif(albumArt){\n[self removeChild:albumArt cleanup:YES];\nalbumArt = nil;\n}\n//Set album art\nif(artworkImage){\nCCTexture2D *texture = [[[CCTexture2D alloc] initWithImage:artworkImage] autorelease];\nalbumArt = [CCSprite spriteWithTexture:texture];\n[self addChild:albumArt z:1];\nalbumArt.position = ccp(240,120);\nalbumArt.scale = 0.25f;\n}\n}\n//Play callback\n-(void)playMusic:(id)sender { [musicPlayer play]; }\n//Pause callback\n-(void)pauseMusic:(id)sender{ [musicPlayer pause]; }\n//Stop callback\n-(void)stopMusic:(id)sender{ [musicPlayer stop]; }\n//Next callback\n- (void)nextSong:(id)sender { [musicPlayer skipToNextItem]; }\n//Previous callback\n- (void)previousSong:(id)sender {\n//After 3.5 seconds hitting previous merely rewinds the song\nstatic NSTimeInterval skipToBeginningOfSongIfElapsedTimeLongerThan = 3.5;\nNSTimeInterval playbackTime = musicPlayer.currentPlaybackTime;\nif (playbackTime <= skipToBeginningOfSongIfElapsedTimeLongerThan) {\n//Previous song\n[musicPlayer skipToPreviousItem];\n} else {\n//Rewind to beginning of current song\n[musicPlayer skipToBeginning];\n}\n}\n//Add music callback\n- (void)openMediaPicker:(id)sender {\n//Unit music MPMediaPickerController\nMPMediaPickerController *mediaPicker = [[MPMediaPickerController alloc] initWithMediaTypes:MPMediaTypeMusic];\nmediaPicker.delegate = self;\nmediaPicker.allowsPickingMultipleItems = YES;\n//Present picker as a modal view\n((AppDelegate*)[UIApplication sharedApplication].delegate).viewController presentModalViewController:mediaPicker animated:YES];\n[mediaPicker release];\n}\n- (void)mediaPicker: (MPMediaPickerController *)mediaPicker didPickMediaItems:(MPMediaItemCollection *)mediaItemCollection {\n//Dismiss the picker\n((AppDelegate*)[UIApplication sharedApplication].delegate).viewController dismissModalViewControllerAnimated:YES];\n//Assign the selected item(s) to the music player and start playback.\n[musicPlayer stop];\n[musicPlayer setQueueWithItemCollection:mediaItemCollection];\n[musicPlayer play];\n}\n- (void)mediaPickerDidCancel:(MPMediaPickerController *)mediaPicker {\n//User chose no items, dismiss the picker\n((AppDelegate*)[UIApplication sharedApplication].delegate).viewController dismissModalViewControllerAnimated:YES];\n}\n-(void) cleanRecipe {\n//Stop player\n[musicPlayer stop];\n//Stop music player notifications\n[[NSNotificationCenter defaultCenter] removeObserver:self name:MPMusicPlayerControllerNowPlayingItemDidChangeNotification object:musicPlayer];\n[[NSNotificationCenter defaultCenter] removeObserver:self\nname:MPMusicPlayerControllerPlaybackStateDidChangeNotification object:musicPlayer];\n[[NSNotificationCenter defaultCenter] removeObserver:self\nname:MPMusicPlayerControllerVolumeDidChangeNotification object:musicPlayer];\n[musicPlayer endGeneratingPlaybackNotifications];\n//Release player\n[musicPlayer release];\nmusicPlayer = nil;\n[super cleanRecipe];\n}\n@end\n\n```", "```swift\n    musicPlayer = [MPMusicPlayerController iPodMusicPlayer];\n    [musicPlayer setRepeatMode:MPMusicRepeatModeAll];\n\n    ```", "```swift\n    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n    [notificationCenter addObserver:self selector:@selector(handleNowPlayingItemChanged:)\n    name:MPMusicPlayerControllerNowPlayingItemDidChangeNotification object:musicPlayer];\n    [musicPlayer beginGeneratingPlaybackNotifications];\n\n    ```", "```swift\n    MPMediaItem *currentItem = musicPlayer.nowPlayingItem;\n    if([currentItem valueForProperty:MPMediaItemPropertyTitle]){\n    [songLabel setString: [NSString stringWithFormat:@\"%@\",[currentItem valueForProperty:MPMediaItemPropertyTitle]]];\n    [artistLabel setString: [NSString stringWithFormat:@\"%@\",[currentItem valueForProperty:MPMediaItemPropertyArtist]]];\n    [albumLabel setString: [NSString stringWithFormat:@\"%@\",[currentItem valueForProperty:MPMediaItemPropertyAlbumTitle]]];\n    }\n    MPMediaItemArtwork *artwork = [currentItem valueForProperty:MPMediaItemPropertyArtwork];\n    UIImage *artworkImage = nil;\n    if(artwork) { artworkImage = [artwork imageWithSize:CGSizeMake(100,100)]; }\n\n    ```", "```swift\n    MPMediaPickerController *mediaPicker = [[MPMediaPickerController alloc] initWithMediaTypes:MPMediaTypeMusic];\n    mediaPicker.delegate = self;\n    mediaPicker.allowsPickingMultipleItems = YES;\n\n    ```", "```swift\n    ((AppDelegate*)[UIApplication sharedApplication].delegate).viewController presentModalViewController:mediaPicker animated:YES];\n\n    ```", "```swift\n    -(void) mediaPicker:(MPMediaPickerController *)mediaPicker didPickMediaItems:(MPMediaItemCollection *)mediaItemCollection;\n    -(void) mediaPickerDidCancel:(MPMediaPickerController *)mediaPicker;\n\n    ```", "```swift\n    ((AppDelegate*)[UIApplication sharedApplication].delegate).viewController dismissModalViewControllerAnimated:YES];\n    [musicPlayer stop];\n    [musicPlayer setQueueWithItemCollection:mediaItemCollection];\n    [musicPlayer play];\n\n    ```", "```swift\n    NSString *model = [[UIDevice currentDevice] model];\n\n    ```", "```swift\n    - (void)applicationWillResignActive:(UIApplication *)application;\n    - (void)applicationDidBecomeActive:(UIApplication *)application;\n\n    ```", "```swift\n    - (void)applicationWillResignActive:(UIApplication *)application {\n    [[CCDirector sharedDirector] pause];\n    //Pause the music player if its playing\n    if(![[[UIDevice currentDevice] model] isEqualToString:@\"iPhone Simulator\"]){\n    MPMusicPlayerController *musicPlayer = [MPMusicPlayerController iPodMusicPlayer];\n    if(musicPlayer.playbackState == MPMusicPlaybackStatePlaying){\n    [musicPlayer pause];\n    }\n    }\n    }\n    - (void)applicationDidBecomeActive:(UIApplication *)application {\n    [[CCDirector sharedDirector] resume];\n    //Play the music play if its paused\n    if(![[[UIDevice currentDevice] model] isEqualToString:@\"iPhone Simulator\"]){\n    MPMusicPlayerController *musicPlayer = [MPMusicPlayerController iPodMusicPlayer];\n    if(musicPlayer.playbackState == MPMusicPlaybackStatePaused){\n    [musicPlayer play];\n    }\n    }\n    }\n\n    ```", "```swift\n#import \"MIDISampleGenerator.h\"\nstatic const int kWhiteKeyNumbers[] = { 0, 2, 4, 5, 7, 9, 11 };\nstatic const int kWhiteKeyCount = sizeof(kWhiteKeyNumbers) / sizeof(int);\nstatic const int kBlackKey1Numbers[] = { 1, 3 };\nstatic const int kBlackKey1Count = sizeof(kBlackKey1Numbers) / sizeof(int);\nstatic const int kBlackKey2Numbers[] = { 6, 8, 10 };\nstatic const int kBlackKey2Count = sizeof(kBlackKey2Numbers) / sizeof(int);\n@implementation Ch6_MIDISynthesization\n-(CCLayer*) runRecipe {\n//Init sample generator\nsampleGenerator = [[MIDISampleGenerator alloc] init];\n//Init keyboard\n[self initKeyboard];\nreturn self;\n}\n-(void) initKeyboard {\n/* CODE OMITTED */\n}\n-(void) randomize:(id)sender {\n//Randomize values including Modulation, Oscillation, Filter, etc\n[sampleGenerator randomize];\n}\n-(bool) keyPressed:(CCSprite*)key withHash:(NSString*)hashKey {\n//Set darker key color\n[key setColor:ccc3(255,100,100)];\n//Play note\n[sampleGenerator noteOn:key.tag];\n//Keep track of touch\n[keyTouches setObject:[NSNumber numberWithInt:key.tag] forKey:hashKey];\nreturn YES;\n}\n-(bool) keyReleased:(int)note remove:(bool)remove {\n/* CODE OMITTED */\nif(keyReleased){\n//Stop playing note\n[sampleGenerator noteOff:note];\n//Remove tracking\nif(remove){ [keyTouches removeObjectForKey:[NSNumber numberWithInt:note]]; }\n}\nreturn keyReleased;\n}\n@end\n\n```", "```swift\nHELLO, HAL. DO YOU READ ME, HAL?\nOPEN THE POD BAY DOORS, HAL.\nWHAT'S THE PROBLEM?\nWHAT ARE YOU TALKING ABOUT, HAL?\nI DON'T KNOW WHAT YOU'RE TALKING ABOUT, HAL.\nWHERE THE HELL'D YOU GET THAT IDEA, HAL?\nALRIGHT, HAL. I'LL GO IN THROUGH THE EMERGENCY AIRLOCK.\nHAL, I WON'T ARGUE WITH YOU ANYMORE. OPEN THE DOORS.\n\n```", "```swift\n#import \"cocos2d.h\"\n#import \"AudioSessionManager.h\"\n#import \"OpenEarsEventsObserver.h\"\n#import \"PocketsphinxController.h\"\n#import \"FliteController.h\"\n@interface MainLayer : CCLayer <OpenEarsEventsObserverDelegate>\n{ /* CODE OMITTED */ }\n@end\n@implementation MainLayer\n-(id) init\n{\nif( (self=[super init])) {\n/* CODE OMITTED */\n//Init AudioSessionManager and start session\naudioSessionManager = [[AudioSessionManager alloc] init];\n[audioSessionManager startAudioSession];\n//Init pocketsphinx, flite and OpenEars\npocketsphinxController = [[PocketsphinxController alloc] init];\nfliteController = [[FliteController alloc] init];\nopenEarsEventsObserver = [[OpenEarsEventsObserver alloc] init];\n//Text to speech\n[self say:@\"Welcome to OpenEars.\"];\n[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:4.0f],\n[CCCallFunc actionWithTarget:self selector:@selector(welcomeMessage)], nil]];\n//Start the Pocketsphinx continuous listening loop.\n[pocketsphinxController startListening];\n//Set this is an OpenEars observer delegate\n[openEarsEventsObserver setDelegate:self];\n/* CODE OMITTED */\n}\nreturn self;\n}\n-(void) welcomeMessage {\n//Greet the user with a message about his pitiful human brain\n[self say:@\"Hello Dave. I've just picked up a fault in your brain. \\nIt's going to go 100% failure in 72 hours. \\nWould you like me to open the pod bay doors?\"];\n}\n-(void) saySomething {\n//Respond with a random response\nint num = arc4random()%5;\nif(num == 0){\n[self say:@\"This mission is too important for me to allow you to \\njeopardize it Dave.\"];\n}\n/* CODE OMITTED */\n}\n-(void) say:(NSString*)str { /* CODE OMITTED */\n//Have flite speak the message (text to speech)\n[fliteController say:str];\n}\n-(void) suspendRecognition { /*CODE OMITTED */\n//Suspend recognition\n[pocketsphinxController suspendRecognition];\n}\n-(void) resumeRecognition { /* CODE OMITTED */\n//Suspend recognition\n[pocketsphinxController resumeRecognition];\n}\n-(void) stopListening { /* CODE OMITTED */\n//Stop listening\n[pocketsphinxController stopListening];\n}\n-(void) startListening { /* CODE OMITTED */\n//Start listening\n[pocketsphinxController startListening];\n}\n//Delivers the text of speech that Pocketsphinx heard and analyzed, along with its accuracy score and utterance ID.\n- (void) pocketsphinxDidReceiveHypothesis:(NSString *)hypothesis recognitionScore:(NSString *)recognitionScore utteranceID:(NSString *)utteranceID {\n//Display information\n[self showMessage:[NSString stringWithFormat:@\"The received hypothesis is %@ with a score of %@ and an ID of %@\", hypothesis, recognitionScore, utteranceID]]; //Log it.\n//Tell the user what we heard\n[self say:[NSString stringWithFormat:@\"You said %@\",hypothesis]]; //React to it by telling our FliteController to say the heard phrase.\n//Respond with a witty retort\n[self runAction:[CCSequence actions:[CCDelayTime actionWithDuration:4.0f],\n[CCCallFunc actionWithTarget:self selector:@selector(saySomething)], nil]];\n}\n@end\n\n```", "```swift\n    audioSessionManager = [[AudioSessionManager alloc] init];\n    [audioSessionManager startAudioSession];\n    pocketsphinxController = [[PocketsphinxController alloc] init];\n    fliteController = [[FliteController alloc] init];\n    openEarsEventsObserver = [[OpenEarsEventsObserver alloc] init];\n\n    ```", "```swift\n    [pocketsphinxController suspendRecognition];\n    [pocketsphinxController resumeRecognition];\n    [pocketsphinxController stopListening];\n    [pocketsphinxController startListening];\n\n    ```", "```swift\n    - (void) pocketsphinxDidReceiveHypothesis:(NSString *)hypothesis recognitionScore:(NSString *)recognitionScore utteranceID:(NSString *)utteranceID;\n\n    ```"]