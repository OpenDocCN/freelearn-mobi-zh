- en: Streaming Your Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss higher-order functions for collections. For Java
    developers, they first appeared in Java 8 with the introduction of Stream API.
    But they were around for much longer in functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: First, since we expect that many of our readers are familiar with Java 8, let's
    cover what Stream API is in Java briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Streams from Java8 are not to be confused with some of the I/O classes with
    similar names, such as `InputStream` or `OutputStream`. While the latter represent
    data, the former are sequences of elements of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: If those are sequences, and they all have the same type, how are they different
    from `Lists`? Well, streams can be infinite, unlike collections.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a set of actions defined for Java streams. Not only are those
    actions the same for any kind of stream, they also have familiar names for those
    that come from totally different languages. There's the `map()` function in JavaScript,
    which does the same as the `map()` method in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of making extensive use of small, reusable, and composable functions
    comes directly from functional programming, which we discussed in the previous
    chapter. They allow us to write code in a manner that tells *what* we want to
    do, instead of *how* we want to do it.
  prefs: []
  type: TYPE_NORMAL
- en: But in Java, to use those functions, we have to either receive a stream or create
    a stream from a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, in order to get to all this functional goodness for collections, we
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, you can do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But all those methods and more are available directly on collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all; there is no need to convert from the stream and back unless you
    plan to operate on *infinite data* in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's not as simple as that, but we cover the differences and pitfalls near
    the end of this chapter, in the *Streams are lazy, collections are not* section.
    Let's start by understanding what those weird functions actually do.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we won't be able to cover all the functions available on collections,
    but we'll cover the most widely used ones.
  prefs: []
  type: TYPE_NORMAL
- en: The examples will be somewhat boring, mostly lists of numbers, letters, and
    people. That's to let you focus on how each function actually works. We'll go
    back to some crazy examples in the next chapter. Stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: The it notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We glanced at the notion of `it` briefly in previous chapters, but for this
    chapter, we need to understand it a bit more (pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin is all about brevity. First, if our lambda doesn''t have an argument,
    we don''t need to specify anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we have a function that takes another function as an argument (and
    doesn''t do anything with it for simplicity)? See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify both the argument name and type explicitly, and wrap them in
    brackets, like any other function invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But since the lambda is the last parameter (and the only one, in this case),
    we can omit the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And since the compiler can infer the type of parameter, we can omit it too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And since `x` is the only parameter, we can use the implicit name for it, which
    is `it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the shortest notation in most of the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: The map() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most well known higher-order functions on collections is `map()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a function that receives a list of strings and returns
    a new list of the same size containing each string concatenated to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The task is quite trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But for such a trivial task, we had to write quite a lot of code. What would
    we have to change in order to capitalize each string instead of repeating it twice?
    We would like to change only this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But we have to create another function for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in Kotlin, we could pass a function as a second parameter. And since
    we don''t actually care what the type is, as long as it''s the same for both input
    and output, we can use generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can call our *generified* function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s almost exactly what `.map()` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another variation of `map()` is `mapTo()`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the lambda, it receives the destination where the results should
    be incorporated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But `mapTo()` lets you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the second option, we use the results list as an argument, which allows us
    to reduce code nesting.
  prefs: []
  type: TYPE_NORMAL
- en: Filter family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common task is filtering a collection. You know the drill. You iterate
    over it and put only values that fit your criteria in a new collection. For example,
    if given a range of numbers between 1-10, we would like to return only odd ones.
    Of course, we''ve already learned this lesson from the previous example, and wouldn''t
    simply create a function called `filterOdd()`, as later we would be required to also
    implement `filterEven()`, `filterPrime()`, and so on. We''ll receive a lambda
    as the second argument right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking it will print only odd numbers. How odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, we have a built-in function that does exactly that already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Find family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say you have an unordered list of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And would like to find a first object that matches *some criteria*. Using extension
    functions, you could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, when you have a list of objects, you can simply call `find()` on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, you don't have to implement anything. This method is already implemented
    for you in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also an accompanying `findLast()` method, which does the same, but
    which starts with the last element of the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Drop family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, this is cool if you have to iterate over all elements in your collection
    anyway. But with the `for` loops in Java, you could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How are you going to achieve that with your funky functions, huh?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, for that there''s `drop()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Do note that this doesn''t modify the original collection in any way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to stop your *loop* earlier, there''s `dropLast()` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting function is `dropWhile()`, in which it receives a predicate
    instead of a number. It skips until the predicate returns true for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And there's the accompanying `dropLastWhile()`.
  prefs: []
  type: TYPE_NORMAL
- en: Sort family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't worry, we won't have to implement our own sort algorithm. This is not
    CS 101.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the list of people from the preceding `find()` example, we would like
    to sort them by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easily achieved with `sortedBy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also `sortedByDescending()`, which will reverse the order of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you want to compare by more than one parameter, use the combination
    of `sortedWith` and `compareBy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ForEach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first *terminator* we'll see. Terminator functions return something
    other than a new collection, so you can't chain the result of this call to other
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `forEach()`, it returns Unit. So it''s like the plain, old `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Do note that `forEach()` has some minor performance impacts compared to the
    traditional `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also `forEachIndexed()`, which provides an index in the collection
    alongside the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Kotlin 1.1, there''s also the `onEach()` function, which is a bit more
    useful, since it returns the collection again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Join family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we used the side effect of printing to the console,
    which is not favorable in terms of functional programming. What''s more, we also
    have this ugly comma at the end of our output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There must be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many times have you had to actually write code to simply concatenate some
    list of values into a string? Well, Kotlin has a function for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Simply beautiful, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you want to separate it with other characters, or don''t want spaces,
    there''s a way to configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Fold/Reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like `forEach()`, both `fold()` and `reduce()` are terminating functions.
    But instead of terminating with Unit, which is not useful, they terminate with
    a single value of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common example of `reduce` is, of course, for adding up stuff. With
    the list of people from the previous example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Well, combining a lot of people into one doesn't make much sense, unless you're
    a fan of some horror movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'But with reduce, we can also compute who''s the oldest or the youngest in the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function we''re about to discuss, `fold()`, is much like `reduce`,
    but it takes another argument, which is the initial value. It''s useful when you''ve
    already computed something, and now want to use this intermediate result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Flat family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say you have a list of other lists. You probably got it from different database
    queries, or maybe from different configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And you want to turn them into a single list such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to merge those lists is to write some imperative code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But calling `flatten()` will do the same for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also control what happens with those results using `flatMap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this case, it refers to one of the sublists.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also decide to use `flatMap()` for type conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We converted all integers to doubles, and then merged them into a single list.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the first `it` refers to one of the lists, while the second `it` refers
    to a single item inside the current list.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as `flatten()` goes, it flattens only one level down. To demonstrate
    that, we''ll use `Set` for the first level of nesting, `List` for the second level
    of nesting, and `Set` again for the third level of nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `flatten` once, we receive only the first level flattened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To completely flatten the list, we need to call `flatten()` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin prevents us from calling `flatten()` three times, as it recognizes the
    amount of nesting we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say we have a list of elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take only part of this list using `slice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We're using Kotlin ranges, which is a nice syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, there''s a `subList()` method, which is similar, but not inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Chunked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very common to see this chunking logic in production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have a huge list of identifiers that you read from somewhere and you need
    to check whether your database or some remote service contains them. But there
    are limitations on how many identifiers you can pass with a single request. Databases,
    for example, often have limitations of the number of arguments to a query and
    on the total query length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t simply pass an entire list to our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we write large piles of imperative code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, since Kotlin 1.2, there''s the `chunked()` function for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Zip/Unzip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not related to archiving in any way, `zip()` allows us to create pairs out of
    two lists based on their indexes. That may sound confusing, so let's look at an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two functions, one fetching all active employees, and the other for
    how many days the employee was employed in our startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `zip()` between the two of them will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that since we had a bug in our second function, and returned the days
    for the employees that had already left our startup, the length of the two lists
    wasn''t equal, to begin with. Calling `zip()` will always produce the shortest
    list of pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is not a map, but a list of pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having such a list, we can also unzip it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Streams are lazy, collections are not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be careful with those functions on large collections, though. Most of them will
    copy the collection for the sake of immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions starting with `as` won''t do that, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the difference, check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that code using `stream()` actually never executes. Streams, being
    lazy, wait for a terminating function call. Functions on collections, on the other
    hand, execute one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add the terminating call though, we''ll see totally different numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Converting from the stream back to the list is an expensive operation. Take
    those points into consideration when deciding which approach to use.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since streams were introduced only in Java 8, but Kotlin is backward-compatible
    down to Java 6, it needed to provide another solution for the possibility of infinite
    collections. This solution was named *sequenced*, so it won't clash with Java
    streams when they're available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate an infinite sequence of numbers, starting with `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To take only the first `100`, we use the `take()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'A finite number of sequences can be created by returning `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'A finite number of sequences can be created from ranges or collections by calling
    `asSequence()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to practicing functional programming principles and
    learning the building blocks of functional programming in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should know how to transform your data with `map()`/`mapTo()`, how to `filter()`
    collections, and `find()` elements by criteria.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be familiar with how to `drop()` elements to skip them, how
    to `sort()` collections, and how to iterate over them using `forEach()` and `onEach()`.
  prefs: []
  type: TYPE_NORMAL
- en: Use `join()` to stringify collections, `fold()` and `reduce()` to total collections
    up, and `flatten()` and `flatTo()` to reduce collection nesting.
  prefs: []
  type: TYPE_NORMAL
- en: '`slice()` is a way to get only a portion of a collection, while `chunked()`
    is used to break a collection into even portions.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `zip()` and `unzip()` combine two collections into a pair, or split
    the pair back into two parts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss how familiarity with those methods helps
    us to become truly reactive.
  prefs: []
  type: TYPE_NORMAL
