<html><head></head><body><p>&#13;
&#13;
                            &#13;
                    Generics, Operators, and Nested Types&#13;
                &#13;
            &#13;
            &#13;
                &#13;
<p>Swift provides a number of advanced features for building functionality that is flexible but well defined so that it feels like you are extending the language itself. In this chapter, we will examine two of these features: <strong>generics</strong> and <strong>operators</strong>. We will also see how nested types allow logical grouping, access control, and namespacing for your constructs.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Using generics with types</li>&#13;
<li>Using generics with functions</li>&#13;
<li>Using generics with protocols</li>&#13;
<li>Using advanced operators</li>&#13;
<li>Defining option sets</li>&#13;
<li>Creating custom operators</li>&#13;
<li>Nesting types and namespacing</li>&#13;
</ul>&#13;
<h1 id="uuid-85ee78f1-5c09-4b71-b68a-e1b0198dd54b">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/39I7wuy" target="_blank">https://bit.ly/39I7wuy</a></p>&#13;
<h1 id="uuid-97476daf-27bb-46d6-bc79-66eb84d3980e">Using generics with types</h1>&#13;
<p>When we build things in Swift that interact with other types, we often specify the type we are interacting with directly. This is helpful because it means we know the capabilities that the type has; we can put those capabilities to use and ensure that the outputs have the correct type. However, we now have a construct that can only interact with the specified type; it can't be reused with other types, even if the concepts are the same.</p>&#13;
<p><strong>Generics</strong> give us the advantage of having a defined type while being generically applicable to other types. It is, perhaps, best illustrated with an example.</p>&#13;
<p>In this recipe, we will create a generic class that stores the last five things it was given and returns them all upon request.</p>&#13;
<h2 id="uuid-16065ac4-7eee-44c7-9ec1-d89686897e07">Getting ready</h2>&#13;
<p>We will create a custom collection object that will store the last five strings that the user copied so that they can paste not just the last string copied, but any of the last five. You can add strings to the list and ask for all the strings in the list, which will be returned newest to oldest:</p>&#13;
<pre>class RecentList { <br/>     <br/>    var slot1: String? <br/>    var slot2: String? <br/>    var slot3: String? <br/>    var slot4: String? <br/>    var slot5: String? <br/>     <br/>    func add(recent: String) { <br/>         <br/>        // Move each slot down 1 <br/>        slot5 = slot4 <br/>        slot4 = slot3 <br/>        slot3 = slot2 <br/>        slot2 = slot1 <br/>        slot1 = recent <br/>    } <br/>     <br/>    func getAll() -&gt; [String] { <br/>        var recent = [String]() <br/>        if let slot1 = slot1 { <br/>            recent.append(slot1) <br/>        } <br/>        if let slot2 = slot2 { <br/>            recent.append(slot2) <br/>        } <br/>        if let slot3 = slot3 { <br/>            recent.append(slot3) <br/>        } <br/>        if let slot4 = slot4 { <br/>            recent.append(slot4) <br/>        } <br/>        if let slot5 = slot5 { <br/>            recent.append(slot5) <br/>        } <br/>        return recent <br/>    } <br/>} <br/>let recentlyCopiedList = RecentList() <br/>recentlyCopiedList.add(recent: "First") <br/>recentlyCopiedList.add(recent: "Next") <br/>recentlyCopiedList.add(recent: "Last") <br/>var recentlyCopied = recentlyCopiedList.getAll() <br/>print(recentlyCopied) // Last, Next, First </pre>&#13;
<p>This is great – it does just what we want. Now, let's say that we want to add a list of five recent contacts to a contacts app. The concept is exactly the same as the list of copied strings, as we want to do the following:</p>&#13;
<ul>&#13;
<li>Add something to a list.</li>&#13;
<li>Get all the things on the list so that we can present them to the user.</li>&#13;
</ul>&#13;
<p>However, because we specified that the <kbd>RecentList</kbd> object can only work with strings, it can't work with my custom <kbd>Person</kbd> object. We can use generics to make this more useful.</p>&#13;
<p>Let's see how to do this by making <kbd>RecentList</kbd> use generics.</p>&#13;
<h2 id="uuid-195fd076-9f41-4d03-9daa-a1120e4614f1">How to do it...</h2>&#13;
<p>We will update our <kbd>RecentList</kbd> code to use generics, so it can be used with other types:</p>&#13;
<ol>&#13;
<li>Amend the <kbd>RecentList</kbd> object to define a generic type, <kbd>ListItemType</kbd>, which we use in place of <kbd>String</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class RecentList&lt;ListItemType&gt; { <br/> <br/>    var slot1: ListItemType? <br/>    var slot2: ListItemType? <br/>    var slot3: ListItemType? <br/>    var slot4: ListItemType? <br/>    var slot5: ListItemType? <br/> <br/>    func add(recent: ListItemType) { <br/>        // Move each slot down 1 <br/>        slot5 = slot4 <br/>        slot4 = slot3 <br/>        slot3 = slot2 <br/>        slot2 = slot1 <br/>        slot1 = recent <br/>    } <br/> <br/>    func getAll() -&gt; [ListItemType] { <br/>        var recent = [ListItemType]() <br/>        if let slot1 = slot1 { <br/>            recent.append(slot1) <br/>        } <br/>        if let slot2 = slot2 { <br/>            recent.append(slot2) <br/>        } <br/>        if let slot3 = slot3 { <br/>            recent.append(slot3) <br/>        } <br/>        if let slot4 = slot4 { <br/>            recent.append(slot4) <br/>        } <br/>        if let slot5 = slot5 { <br/>            recent.append(slot5) <br/>        } <br/>        return recent <br/>    } <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Provide a specified type, <kbd>String</kbd>, when creating <kbd>RecentList</kbd>, which will be used to replace the generic type for this instance of <kbd>RecentList</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let recentlyUsedWordList = RecentList&lt;String&gt;() <br/>recentlyUsedWordList.add(recent: "First") <br/>recentlyUsedWordList.add(recent: "Next") <br/>recentlyUsedWordList.add(recent: "Last") <br/>var recentlyUsedWords = recentlyUsedWordList.getAll() <br/>print(recentlyUsedWords) // Last, Next, First</pre>&#13;
<div>Instead of using generics, we could have replaced all the <kbd>String</kbd> references in <kbd>RecentlList</kbd> with <kbd>Any</kbd>, which would allow it to accept any type. However, this would allow the list to be made up of different types of things, which is not what we want. It would also require us to cast values that are returned, to make them useful. </p>&#13;
<p style="padding-left: 60px">Let's examine how our newly genericized <kbd>RecentList</kbd> can be used for the other example we discussed earlier, the list of recent contacts.</p>&#13;
<ol start="3">&#13;
<li>Create a simple <kbd>Person</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Person { <br/> <br/>    let name: String <br/>    init(name: String) { <br/>        self.name = name <br/>    } <br/>}</pre>&#13;
<ol start="4">&#13;
<li>Create some people to add to our recent contact list:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let rod = Person(name: "Rod") <br/>let jane = Person(name: "Jane") <br/>let freddy = Person(name: "Freddy")  </pre>&#13;
<ol start="5">&#13;
<li>Create a new <kbd>RecentList</kbd>, providing the specific <kbd>Person</kbd> type:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let lastCalledList = RecentList&lt;Person&gt;() </pre>&#13;
<ol start="6">&#13;
<li>Add person objects to this list:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">lastCalledList.add(recent: freddy) <br/>lastCalledList.add(recent: jane) <br/>lastCalledList.add(recent: rod) </pre>&#13;
<ol start="7">&#13;
<li>Get all the people in the list, and since this is typed as an array of <kbd>Person</kbd> objects, print their <kbd>name</kbd> property:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let lastCalled = lastCalledList.getAll() <br/>for person in lastCalled {<br/>    print(person.name)<br/>}<br/>// Rod<br/>// Jane<br/>// Freddy</pre>&#13;
<p>We now have a generic <kbd>RecentList</kbd> class that we have used with both strings and a custom <kbd>Person</kbd> class.</p>&#13;
<h2 id="uuid-361cffd8-fa41-4ea8-89e1-8b849c592a22">How it works...</h2>&#13;
<p>To add generics to a <kbd>class</kbd> or <kbd>struct</kbd>, the generic type is defined in angle brackets after the class or struct name, and can be given any type name, although it should begin with a <em>capital letter</em> like other type names:</p>&#13;
<pre>class RecentList&lt;ListItemType&gt; { <br/>    //... <br/>}</pre>&#13;
<p>This generic type now becomes a stand-in for the specific type that will be specified when it is used, and we can use this wherever we would use the specific type.</p>&#13;
<p>It can be used as a property type:</p>&#13;
<pre>var slot1: ListItemType? </pre>&#13;
<p>As a parameter value:</p>&#13;
<pre>func add(recent: ListItemType) </pre>&#13;
<p>And as a return type:</p>&#13;
<pre>func getAll() -&gt; [ListItemType] </pre>&#13;
<p>In many other programming languages that have a generics system, the generic type is often given a one-letter type name, usually <kbd>T</kbd>. Swift aims to be concise, but not at the expense of clarity, so I suggest using a more descriptive type name.</p>&#13;
<p>A descriptive type name becomes especially important if you have multiple generic types, which you can have as a comma-separated list within the angle brackets:</p>&#13;
<pre>class RecentList&lt;ListItemType, SomeOtherType&gt; { <br/>    //... <br/>} </pre>&#13;
<p>We have now created a generic <kbd>RecentList</kbd> object that can be used with any type.</p>&#13;
<h2 id="uuid-14636881-c4fe-492c-9a17-b1f6cc631a6f">There's more...</h2>&#13;
<p>While being extremely generic has its advantages, you may wish to constrain which types can be used for the generic type, especially if you need to use some features of that constrained type.</p>&#13;
<p>Let's say that in addition to returning an array of items from <kbd>RecentList</kbd>, we want to be able to print out the list directly. To do this, we need to ensure that the type of item used in <kbd>RecentList</kbd> is something that can be converted into a <em>string</em> to be printed. There is already a <kbd>CustomStringConvertible</kbd> protocol that defines this behavior, so we want to ensure that any specific type used with <kbd>RecentList</kbd> conforms to <kbd>CustomStringConvertible</kbd>:</p>&#13;
<pre>class RecentList&lt;ListItemType: CustomStringConvertible&gt; { <br/>    //... <br/>}</pre>&#13;
<p>We add the constraint after the generic type name, separated by a colon, similar to how we specify protocol conformance and class inheritance. Indeed, while this example constrains the generic type to implement a protocol, we can instead specify a class that the specific type must be, or inherit from.</p>&#13;
<p>Now that we have this constraint, we can be sure that any specific type given will conform to <kbd>CustomStringConvertible</kbd>, and will therefore have a <kbd>description</kbd> string that we can print, so let's create a method to do that:</p>&#13;
<pre>class RecentList&lt;ListItemType: CustomStringConvertible&gt; { <br/>func printRecentList() {<br/>    for item in getAll() {<br/>        let printableItem = String(describing: item)<br/>        print(printableItem)<br/>    }<br/>}<br/> //... <br/></pre>&#13;
<p>The only thing left to do is to make our <kbd>Person</kbd> class conform to <kbd>CustomStringConvertible</kbd> so that it can continue to be used as a specific type in <kbd>RecentList</kbd>:</p>&#13;
<pre>extension Person: CustomStringConvertible { <br/>    public var description: String { <br/>        return name <br/>    } <br/>} </pre>&#13;
<p class="mce-root">Now we can use this functionality with our <kbd>String</kbd> type's <kbd>RecentlyList</kbd> and our <kbd>Person</kbd> type's <kbd>RecentList</kbd>:</p>&#13;
<pre class="p1">// Using String type<br/>let recentlyUsedWordList = RecentList&lt;String&gt;()<br/>recentlyUsedWordList.add(recent: "First")<br/>recentlyUsedWordList.add(recent: "Next")<br/>recentlyUsedWordList.add(recent: "Last")<br/>recentlyUsedWordList.printRecentList()<br/>// Last<br/>// Next<br/>// First<br/><br/>// Using Person type<br/>let rod = Person(name: "Rod")<br/>let jane = Person(name: "Jane")<br/>let freddy = Person(name: "Freddy")<br/>let lastCalledList = RecentList&lt;Person&gt;()<br/>lastCalledList.add(recent: freddy)<br/>lastCalledList.add(recent: jane)<br/>lastCalledList.add(recent: rod)<br/>lastCalledList.printRecentList()<br/>// Rod<br/>// Jane<br/>// Freddy</pre>&#13;
<p>By constraining the generic type, we could use features that we knew the type would have, to provide additional functionality.</p>&#13;
<h2 id="uuid-72f01926-d21a-47e5-b95d-6d73fc537eb7">See also</h2>&#13;
<p>Further information about generic types can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/generics">http://swiftbook.link/docs/generics</a>.</p>&#13;
<h1 id="uuid-3cf95d27-63d3-49b6-9361-268a8442991c">Using generics with functions</h1>&#13;
<p>In addition to being able to specify generic types, you can use generics to build functions that are both widely applicable and strongly typed. In this recipe, we will use generics with functions.</p>&#13;
<h2 id="uuid-358aea9b-3228-4c83-9405-ee777306daca">How to do it...</h2>&#13;
<p>We will use generics to create a function to help with placing values into a dictionary:</p>&#13;
<ol>&#13;
<li>Create a generic function that inserts the same value into a dictionary for multiple keys:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func makeDuplicates&lt;ItemType&gt;(of item: ItemType, <br/>   withKeys keys: Set&lt;String&gt;) -&gt; [String: ItemType] { <br/> <br/>    var duplicates = [String: ItemType]() <br/>    for key in keys { <br/>        duplicates[key] = item <br/>    } <br/>    return duplicates <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Use this function, passing in a single value and multiple keys, and the value is stored against each of the given keys:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let awards: Set&lt;String&gt; = ["Best Director",<br/>                           "Best Picture", <br/>                           "Best Original Screenplay", <br/>                           "Best International Feature"] <br/>let oscars2020 = makeDuplicates(of: "Parasite", withKeys: awards) <br/>print(oscars2020["Best Picture"] ?? "") <br/>// Parasite <br/>print(oscars2020["Best International Feature"] ?? "") <br/>// Parasite</pre>&#13;
<h2 id="uuid-1d18b1b9-a4ce-49d9-915c-0389b3a7cee6">How it works...</h2>&#13;
<p>Just like generics for types, the generic type for a function is specified within angle brackets:</p>&#13;
<pre>func makeDuplicates&lt;ItemType&gt;(of item: ItemType, <br/>   withKeys keys: Set&lt;String&gt;) -&gt; [String: ItemType] { <br/>    //... <br/>} </pre>&#13;
<p>The defined generic type name can then be used as a type definition within the rest of the function definition. In our example, we want to define the type of our input item to be duplicated, and we also want the values that are held in the dictionary to be returned to be of the same type.</p>&#13;
<p>Instead of using generics, we could have used the <kbd>Any</kbd> type in place of the generic type:</p>&#13;
<pre>func makeDuplicates(of item: Any, withKeys keys: Set&lt;String&gt;) -&gt; [String: Any] { <br/>    //... <br/>} </pre>&#13;
<p>However, this approach presents a few problems for anyone using this function:</p>&#13;
<ul>&#13;
<li>They will get back a dictionary containing values of the <kbd>Any</kbd> type, which will need to be cast to a more useful type.</li>&#13;
<li>Without seeing the implementation, they can't be sure that the dictionary contains values of the same type. One key may have a <kbd>String</kbd> stored against it, and another may have an <kbd>Int</kbd>.</li>&#13;
<li>Without seeing the implementation, they can't be sure that the values of the returned dictionary are of the same type as the item provided.</li>&#13;
</ul>&#13;
<p>By using a generic type, we allow the functionality to be widely applicable while enforcing our type logic at compile time.</p>&#13;
<p>You'll notice that unlike instantiating a type with generics, we don't need to explicitly state the specific type to use when executing the function:</p>&#13;
<pre>let oscars2020 = makeDuplicates(of: "Parasite", withKeys: awards)</pre>&#13;
<p>This is because the compiler is able to infer it from the type of the first parameter provided. Since <kbd>Parasite</kbd> is a string, and the compiler knows that the parameter has the <kbd>ItemType</kbd> generic type, the compiler infers that for this use of the method, the <kbd>ItemType</kbd> generic type becomes the specific type of <kbd>String</kbd>.</p>&#13;
<h2 id="uuid-24822b1a-aa2f-4d20-9cd1-0cfbb801c386">There's more...</h2>&#13;
<p>We can increase the usability of our function by providing a generic type for the set of keys we provide as the second parameter:</p>&#13;
<pre>func makeDuplicates&lt;ItemType, KeyType&gt;(of item: ItemType, withKeys  <br/>  keys: Set&lt;KeyType&gt;) -&gt; [KeyType: ItemType] { <br/>     <br/>    var duplicates = [KeyType: ItemType]() <br/>    for key in keys { <br/>        duplicates[key] = item <br/>    } <br/>    return duplicates <br/>} </pre>&#13;
<p>Multiple generic types are defined just as they were in the previous recipe, as a comma-separated list within the angle brackets.</p>&#13;
<p>All the collection types in Swift (array, dictionary, set, and so on) use generics, and in the preceding function, we are passing the generic type from our function into the set. Therefore, <kbd>KeyType</kbd> must conform to <kbd>Hashable</kbd>, since this is required for use in a <kbd>Set</kbd>.</p>&#13;
<p>If we wanted to make this constraint explicit or constrain the generic type for some other reason, this is defined after a colon:</p>&#13;
<pre>func makeDuplicates&lt;ItemType, KeyType: Hashable&gt;(of item: ItemType, <br/>   withKeys keys: Set&lt;KeyType&gt;) -&gt; [KeyType: ItemType] { <br/>  <br/>    var duplicates = [KeyType: ItemType]() <br/>    for key in keys { <br/>        duplicates[key] = item <br/>    } <br/>    return duplicates <br/>} </pre>&#13;
<p>Just as with the previous example, if both specific types we are using can be inferred from the input or output, we don't need to specify it:</p>&#13;
<pre>let awards: Set&lt;String&gt; = ["Best Director", <br/>                           "Best Picture", <br/>                           "Best Original Screenplay", <br/>                           "Best International Feature"] <br/>let oscars2020 = makeDuplicates(of: "Parasite", withKeys: awards) <br/>print(oscars2020["Best Picture"]) // Parasite <br/>print(oscars2020["Best International Feature"]) // Parasite</pre>&#13;
<p>We have used two generic types to improve the flexibility of our function.</p>&#13;
<h2 id="uuid-1d205a29-b40a-48e3-bcde-0bc3136176c6">See also</h2>&#13;
<p>Further information about generic functions can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/generic-functions">http://swiftbook.link/docs/generic-functions</a>.</p>&#13;
<h1 id="uuid-75119e1a-de71-4a02-83e1-9053e3c39340">Using generics with protocols</h1>&#13;
<p>So far in this chapter, we have seen how to use generics within types and functions. In this recipe, we will round off our journey through generics in Swift by looking at how they can be used in protocols. This will allow us to produce abstract interfaces while maintaining strongly typed requirements that allow for a more descriptive model.</p>&#13;
<p>In this recipe, we will build a model for a transport app in the UK with the goal of providing the distance and duration of a journey for different methods of transport.</p>&#13;
<h2 id="uuid-7abfccd4-4775-4011-ba19-b3268c96b14f">How to do it...</h2>&#13;
<p>The ways that people travel can be very different, so let's start by defining transport methods in a generic way, and then specify what those travel methods are:</p>&#13;
<ol>&#13;
<li>Define a protocol to define the features of a transport method:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">protocol TransportMethod { <br/>    associatedtype CollectionPoint <br/>    var defaultCollectionPoint: CollectionPoint { get } <br/>    var averageSpeedInKPH: Double { get } <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Create a struct for traveling by train that implements the <kbd>TransportMethod</kbd> protocol:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct Train: TransportMethod { <br/>    typealias CollectionPoint = TrainStation <br/>     <br/>    // User's home or nearest station <br/>    var defaultCollectionPoint: TrainStation { <br/>        return TrainStation.BMS <br/>    } <br/>     <br/>    var averageSpeedInKPH: Double { <br/>        return 100 <br/>    } <br/>}</pre>&#13;
<ol start="3">&#13;
<li>We need to define the <kbd>TrainStation</kbd> type that we put as <kbd>CollectionPoint</kbd>. Let's do that as an enum:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum TrainStation: String { <br/>    case BMS = "Bromley South" <br/>    case VIC = "London Victoria" <br/>    case RAI = "Rainham (Kent)" <br/>    case BTN = "Brighton (East Sussex)" <br/>    // Full list of UK train stations codes at  <br/>    // http://www.nationalrail.co.uk/static/documents/content<br/>      // /station_codes.csv<br/>}</pre>&#13;
<ol start="4">&#13;
<li>Since we plan to calculate the distance and duration of a journey, let's create a <kbd>Journey</kbd> object to represent that journey from a starting point to an endpoint:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Journey&lt;TransportType: TransportMethod&gt; { <br/>     <br/>    let start: TransportType.CollectionPoint <br/>    let end: TransportType.CollectionPoint <br/>     <br/>    init(start: TransportType.CollectionPoint,  <br/>         end: TransportType.CollectionPoint) { <br/>        self.start = start <br/>        self.end = end <br/>    } <br/>}</pre>&#13;
<ol start="5">&#13;
<li>Add the transport method as a property of the journey as this will be used for the duration calculation:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Journey&lt;TransportType: TransportMethod&gt; { <br/>     <br/>    let start: TransportType.CollectionPoint <br/>    let end: TransportType.CollectionPoint <br/>    let method: TransportType <br/>     <br/>    init(method: TransportType,  <br/>         start: TransportType.CollectionPoint,  <br/>         end: TransportType.CollectionPoint) { <br/>        self.start = start <br/>        self.end = end <br/>        self.method = method <br/>    } <br/>}</pre>&#13;
<ol start="6">&#13;
<li>To calculate the distance of our journey, we need the start and end to have definite locations. So, define a protocol that provides this location:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">protocol TransportLocation { <br/>    var location: CLLocation { get } <br/>} </pre>&#13;
<ol start="7">&#13;
<li>Import the <kbd>CoreLocation</kbd> framework at the top of the playground:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import CoreLocation</pre>&#13;
<ol start="8">&#13;
<li>Constrain <kbd>CollectionPoint</kbd> associated type on <kbd>TransportMethod</kbd>, so that it must conform to the <kbd>TransportLocation</kbd> protocol we have just created:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">protocol TransportMethod { <br/>    associatedtype CollectionPoint: TransportLocation <br/>    var defaultCollectionPoint: CollectionPoint { get } <br/>    var averageSpeedInKPH: Double { get } <br/>} </pre>&#13;
<ol start="9">&#13;
<li>Use the location on the start and end of the <kbd>CollectionPoint</kbd> to calculate the distance and duration of the journey:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Journey&lt;TransportType: TransportMethod&gt; { <br/>     <br/>    var start: TransportType.CollectionPoint <br/>    var end: TransportType.CollectionPoint <br/>    let method: TransportType <br/>    var distanceInKMs: Double <br/>    var durationInHours: Double  <br/>     <br/>    init(method: TransportType,  <br/>         start: TransportType.CollectionPoint,  <br/>         end: TransportType.CollectionPoint) { <br/>        self.start = start <br/>        self.end = end <br/>        self.method = method <br/>        // CoreLocation provides the distance in meters,  <br/>        // so we divide by 1000 to get kilometers <br/>        distanceInKMs = end.location.distance(from: start.location) <br/>          / 1000 <br/>        durationInHours = distanceInKMs / method.averageSpeedInKPH  <br/>    } <br/>} </pre>&#13;
<ol start="10">&#13;
<li>Ensure our <kbd>TrainStation</kbd> enum conforms to <kbd>TransportLocation</kbd>, which is now a requirement:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum TrainStation: String, TransportLocation { <br/>    case BMS = "Bromley South" <br/>    case VIC = "London Victoria" <br/>    case RAI = "Rainham (Kent)" <br/>    case BTN = "Brighton (East Sussex)" <br/>    // Full list of UK train stations codes can be found at  <br/>    // http://www.nationalrail.co.uk/static/documents/content<br/>      // /station_codes.csv <br/>     <br/>    var location: CLLocation { <br/>        switch self { <br/>        case .BMS: <br/>            return CLLocation(latitude: 51.4000504, <br/>                              longitude: 0.0174237) <br/>        case .VIC: <br/>            return CLLocation(latitude: 51.4952103, <br/>                              longitude: -0.1438979) <br/>        case .RAI: <br/>            return CLLocation(latitude: 51.3663, <br/>                              longitude: 0.61137) <br/>        case .BTN: <br/>            return CLLocation(latitude: 50.829, <br/>                              longitude: -0.14125) <br/>        } <br/>    } <br/>}</pre>&#13;
<ol start="11">&#13;
<li>Use our <kbd>Journey</kbd> object to calculate the distance and duration of a train journey:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let trainJourney = Journey(method: Train(), <br/>                           start: TrainStation.BMS, <br/>                           end: TrainStation.VIC) <br/>let distanceByTrain = trainJourney.distanceInKMs <br/>let durationByTrain = trainJourney.durationInHours <br/>print("Journey distance: \(distanceByTrain) km") <br/>print("Journey duration: \(durationByTrain) hours") </pre>&#13;
<h2 id="uuid-ea0240fa-67d8-487e-934c-d61f6092c9ce">How it works...</h2>&#13;
<p>At the outset, it may not be clear which is the best structure to use to define a transport method, and there might be different structures appropriate for different travel methods. Therefore, we can define a transport method as a protocol that appropriate types can conform to:</p>&#13;
<pre>protocol TransportMethod { <br/>    associatedtype CollectionPoint <br/>    var defaultCollectionPoint: CollectionPoint { get } <br/>    var averageSpeedInKPH: Double { get } <br/>} </pre>&#13;
<p>We define an associated generic type that we name <kbd>CollectionPoint</kbd>, which will represent the type of location that someone can be collected from when using this transport method. By using generics, we have ultimate flexibility in how a transport method chooses to define what can serve as a collection point.</p>&#13;
<p>Having defined an associated type, it can then be used as a placeholder in properties and methods for the specific type that will be defined when the protocol is used. We use it to define a default collection point that each transport method should provide.</p>&#13;
<p>Each transport method also provides an average speed, which will be used later in calculating the travel time.</p>&#13;
<p>Let's look at a concrete example of a transport method to help define the model further:</p>&#13;
<pre>struct Train: TransportMethod { <br/>    typealias CollectionPoint = TrainStation <br/>     <br/>    // User's home or nearest station <br/>    var defaultCollectionPoint: TrainStationPoint { <br/>        return TrainStation.BMS <br/>    } <br/>     <br/>    var averageSpeedInKPH: Double { <br/>        return 100 <br/>    } <br/>}</pre>&#13;
<p>For <kbd>Train</kbd> to conform to the <kbd>TransportMethod</kbd> protocol, we must provide a specific version of the <kbd>CollectionPoint</kbd> generic type that is required by the protocol. In the case of traveling by train, the collection point will be a train station, so we now have to define the <kbd>TrainStation</kbd> type:</p>&#13;
<pre>enum TrainStation: String { <br/>    case BMS = "Bromley South" <br/>    case VIC = "London Victoria" <br/>    case RAI = "Rainham (Kent)" <br/>    case BTN = "Brighton (East Sussex)" <br/>    // Full list of UK train stations codes at  <br/>    // http://www.nationalrail.co.uk/static/documents/content<br/>      // /station_codes.csv<br/>}</pre>&#13;
<p>Since there are a finite number of train stations that are discretely definable, an <kbd>enum</kbd> is a good way to represent them. I've only listed a small number above, for brevity.</p>&#13;
<p>Our goal is to model a journey and calculate the duration of the journey over specific transport methods, so let's create a <kbd>Journey</kbd> object:</p>&#13;
<pre>class Journey&lt;TransportType: TransportMethod&gt; { <br/>     <br/>    let start: TransportType.CollectionPoint <br/>    let end: TransportType.CollectionPoint <br/>     <br/>    init(start: TransportType.CollectionPoint,  <br/>         end: TransportType.CollectionPoint) { <br/>        self.start = start <br/>        self.end = end <br/>    } <br/>} </pre>&#13;
<p>A journey takes place from one point to another, so we take the journey's start and end as input parameters. We need to have the flexibility to provide any type as the start and end, but we need them to be types connected to a transport method, with the same type for the start and end values. To accomplish this, we can have a generic type constrained to conform to the <kbd>TransportMethod</kbd> protocol; we can then define our start and end property types by referencing the <kbd>CollectionPoint</kbd> associated type of the generic type.</p>&#13;
<p>Our goal is to calculate the duration of a journey. To do this, we will need the speed of travel during the journey and the distance from start to end. Our <kbd>TransportMethod</kbd> protocol defines that it will provide an average speed, so let's also take the transport method as an input to our journey:</p>&#13;
<pre>class Journey&lt;TransportType: TransportMethod&gt; { <br/>     <br/>    let start: TransportType.CollectionPoint <br/>    let end: TransportType.CollectionPoint <br/>    let method: TransportType <br/>     <br/>    init(method: TransportType,  <br/>         start: TransportType.CollectionPoint,  <br/>         end: TransportType.CollectionPoint) { <br/>        self.start = start <br/>        self.end = end <br/>        self.method = method <br/>    } <br/>} </pre>&#13;
<p>To get the distance of the journey, we need to calculate the distance between the start and end, but the type of both the start and end of the journey is the generic <kbd>CollectionPoint</kbd> type, which could be any type, and so does not have any location information that we can use to calculate distance.</p>&#13;
<p>To solve this, let's constrain <kbd>CollectionPoint</kbd> so that it must conform to a new protocol, <kbd>TransportLocation</kbd>:</p>&#13;
<pre>protocol TransportLocation { <br/>    var location: CLLocation { get } <br/>} </pre>&#13;
<p>Anything conforming to <kbd>TransportLocation</kbd> must provide a location in the form of a <kbd>CLLocation</kbd> object. The <kbd>CLLocation</kbd> object is part of the <kbd>CoreLocation</kbd> framework on iOS. Further investigation of the <kbd>CoreLocation</kbd> framework is outside the scope of this book, but it's enough to know that it provides ways to calculate the distance between two <kbd>CLLocation</kbd> objects, and we need to include the following at the top of this playground to use it:</p>&#13;
<pre>import CoreLocation </pre>&#13;
<p>With our <kbd>TransportLocation</kbd> protocol defined, we can constrain the <kbd>CollectionPoint</kbd> associated type on the <kbd>TransportMethod</kbd> protocol:</p>&#13;
<pre>protocol TransportMethod { <br/>    associatedtype CollectionPoint: TransportLocation <br/>    var defaultCollectionPoint: CollectionPoint { get } <br/>    var averageSpeedInKPH: Double { get } <br/>} </pre>&#13;
<p>Since our <kbd>CollectionPoint</kbd> will now conform to <kbd>TransportLocation</kbd>, and therefore must have a location property, we can go back to our <kbd>Journey</kbd> object and use this to calculate the distance of the journey and the duration:</p>&#13;
<pre>class Journey&lt;TransportType: TransportMethod&gt; { <br/>     <br/>    var start: TransportType.CollectionPoint <br/>    var end: TransportType.CollectionPoint <br/>    let method: TransportType <br/>    var distanceInKMs: Double <br/>    var durationInHours: Double  <br/>     <br/>    init(method: TransportType,  <br/>         start: TransportType.CollectionPoint,  <br/>         end: TransportType.CollectionPoint) { <br/>        self.start = start <br/>        self.end = end <br/>        self.method = method <br/>        // CoreLocation provides the distance in meters,  <br/>        // so we divide by 1000 to get kilometers <br/>        distanceInKMs = end.location.distance(from: start.location) / <br/>          1000 <br/>        durationInHours = distanceInKMs / method.averageSpeedInKPH  <br/>    } <br/>} </pre>&#13;
<p>The last thing we need to do is to ensure that our <kbd>TrainStation</kbd> enum conforms to <kbd>TransportLocation</kbd> as this is now a requirement. To do this, we just need to declare conformance and add a <kbd>location</kbd> property:</p>&#13;
<pre>enum TrainStation: String, TransportLocation { <br/>    case BMS = "Bromley South" <br/>    case VIC = "London Victoria" <br/>    case RAI = "Rainham (Kent)" <br/>    case BTN = "Brighton (East Sussex)" <br/>    // Full list of UK train stations codes can be found at  <br/>    // http://www.nationalrail.co.uk/static/documents/content<br/>     // /station_codes.csv <br/>     <br/>    var location: CLLocation { <br/>        switch self { <br/>        case .BMS: <br/>            return CLLocation(latitude: 51.4000504, <br/>                              longitude: 0.0174237) <br/>        case .VIC: <br/>            return CLLocation(latitude: 51.4952103, <br/>                              longitude: -0.1438979) <br/>        case .RAI: <br/>            return CLLocation(latitude: 51.3663, <br/>                              longitude: 0.61137) <br/>        case .BTN: <br/>            return CLLocation(latitude: 50.829, <br/>                              longitude: -0.14125) <br/>        } <br/>    } <br/>}</pre>&#13;
<p>Let's see how we would use our travel model to create a journey with specific types:</p>&#13;
<pre>let trainJourney = Journey(method: Train(), <br/>                           start: TrainStation.BMS, <br/>                           end: TrainStation.VIC) <br/>let distanceByTrain = trainJourney.distanceInKMs <br/>let durationByTrain = trainJourney.durationInHours <br/>print("Journey distance: \(distanceByTrain) km") <br/>print("Journey duration: \(durationByTrain) hours") </pre>&#13;
<p>We have used generics with protocols to create a generic system without prescribing the type of Swift construct we need to use.</p>&#13;
<h2 id="uuid-c3676e6e-0de4-4702-b5d4-b28839af76dd">There's more...</h2>&#13;
<p>In this recipe, we made one type conform to <kbd>TransportMethod</kbd> – this was our <kbd>Train</kbd> struct. Let's look at another to see how tackling things in a protocol-oriented way allows flexibility in implementation.</p>&#13;
<p>In the next <kbd>TransportMethod</kbd>, we will implement <kbd>Road</kbd>, but there are a number of different vehicle types that we can use to travel by road, and they may have different average speeds. Since we have a finite list of options for travel by road, let's define it using an <kbd>enum</kbd>:</p>&#13;
<pre>enum Road: TransportMethod { <br/>    typealias CollectionPoint = CLLocation <br/>     <br/>    case car <br/>    case motobike <br/>    case van <br/>    case hgv <br/>     <br/>    // The users home or current location <br/>    var defaultCollectionPoint: CLLocation { <br/>        return CLLocation(latitude: 51.1, <br/>                          longitude: 0.1) <br/>    } <br/>     <br/>    var averageSpeedInKPH: Double { <br/>        switch self {<br/>        case .car: return 60 <br/>        case .motobike: return 70 <br/>        case .van: return 55 <br/>        case .hgv: return 50 <br/>        } <br/>    } <br/>}</pre>&#13;
<p>A journey by train has a finite list of collection points, which is the train stations but almost anywhere can be a collection point when traveling by road. Therefore, we can define the collection point for <kbd>Road</kbd> to be any <kbd>CLLocation</kbd>, but <kbd>CLLocation</kbd> doesn't conform to <kbd>TransportLocation</kbd>. We can solve this by extending <kbd>CLLocation</kbd> to add conformance:</p>&#13;
<pre>extension CLLocation: TransportLocation { <br/>    var location: CLLocation { <br/>        return self <br/>    } <br/>} </pre>&#13;
<p>Now, we can define a journey by road and calculate the duration:</p>&#13;
<pre>let start = CLLocation(latitude: 51.3994669, <br/>                       longitude: 0.0116888) <br/>let end = CLLocation(latitude: 51.2968654, <br/>                     longitude: 0.5053609) <br/>let roadJourney = Journey(method: Road.car, <br/>                          start: start, <br/>                          end: end) <br/>let distanceByRoad = roadJourney.distanceInKMs <br/>let durationByRoad = roadJourney.durationInHours <br/>print("Journey distance: \(distanceByRoad) km") <br/>print("Journey duration: \(durationByRoad) hours") </pre>&#13;
<p>By taking a protocol-orientated approach to tackling the task of calculating a journey's duration, and by using protocol generics, we were able to use completely different, but appropriate, implementations for two transport methods while providing an interface so that they can be handled in a common way.</p>&#13;
<p>For a train journey, we used an <kbd>enum</kbd> to model the train stations and a <kbd>struct</kbd> to model the transport method, and for <kbd>road,</kbd> we implemented an <kbd>enum</kbd> for the transport method and used the <kbd>CLLocation</kbd> object for the transport location.</p>&#13;
<h2 id="uuid-bb769975-e64c-4720-9145-b1183084f2e9">See also</h2>&#13;
<p>Further information about associated types can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/associated-types">http://swiftbook.link/docs/associated-types</a>.</p>&#13;
<h1 id="uuid-064e837a-9c0a-453b-99f4-31ee141c909d">Using advanced operators</h1>&#13;
<p>Swift is a programming language that takes a relatively small number of well-defined principles and builds on them to create expressive and powerful language features. The concept of mathematical operators, such as <em>+</em>, <em>-</em>, <em>*</em>, and <em>/</em> for addition, subtraction, multiplication, and division, respectively, seems so fundamental as to not warrant a mention. However, in Swift, this common mathematical functionality is built on top of an underlying operator system that is extensible and powerful.</p>&#13;
<p>In this recipe, we will look at some of the more advanced operators provided by the Swift standard library, and in the next recipe, we will create our own custom operators.</p>&#13;
<h2 id="uuid-3af66452-dec4-42f4-a7da-af7efd1ca513">How to do it...</h2>&#13;
<p>The operators we will explore are known as bitwise operators and are used to manipulate numerical bit representations.</p>&#13;
<p>An integer value in Swift can be represented in its binary form by prefixing the integer literal with <kbd>0b</kbd>:</p>&#13;
<pre>let zero: Int  = 0b000 <br/>let one: Int   = 0b001 <br/>let two: Int   = 0b010 <br/>let three: Int = 0b011 <br/>let four: Int  = 0b100 <br/>let five: Int  = 0b101 <br/>let six: Int   = 0b110 <br/>let seven: Int = 0b111 </pre>&#13;
<p>A bit is the smallest value in a computer system, consisting of either a 1 or 0. The integers mentioned here can be represented by three bits, which are clearly visible when represented in binary form, as illustrated in the preceding snippet. The integer <kbd>six</kbd> can be represented by the three bits 1, 1, and 0.</p>&#13;
<p>These binary representations are really useful when you need to represent multiple options in one value. For example, let's say that we want to indicate which devices are supported for a specific feature of an app. The available devices are as listed:</p>&#13;
<ul>&#13;
<li>Phone</li>&#13;
<li>Tablet</li>&#13;
<li>Watch</li>&#13;
<li>Laptop</li>&#13;
<li>Desktop</li>&#13;
<li>TV</li>&#13;
<li>Brain implant</li>&#13;
</ul>&#13;
<p>Certain features may be appropriate for all the devices, or you may still be working on a feature, and so it isn't currently appropriate for any device, or it may be a combination of different devices. We can have Boolean values for each of the devices to indicate whether the feature is supported for that device, but this is not the best solution as there is nothing intrinsically tying the properties to each other, and you can forget to update some of the values as circumstances change.</p>&#13;
<p>Instead, we can represent all the supported devices with one integer value, and use each bit of the integer to represent a different device:</p>&#13;
<pre>let phone: Int        = 0b0000001 <br/>let tablet: Int       = 0b0000010 <br/>let watch: Int        = 0b0000100 <br/>let laptop: Int       = 0b0001000 <br/>let desktop: Int      = 0b0010000 <br/>let tv: Int           = 0b0100000 <br/>let brainImplant: Int = 0b1000000 <br/> <br/>var supportedDevices: Int </pre>&#13;
<p>To see how this enables us to store multiple devices in one value, let's add together a number of device values:</p>&#13;
<pre> phone  = 0b0000001  + <br/> tablet = 0b0000010  + <br/> tv     = 0b0100000 <br/> ------------------ <br/> phone <br/> tablet = 0b0100011 <br/> tv </pre>&#13;
<p>As each device is represented by a different bit, the device values are combined by adding the values, and they don't overlap.</p>&#13;
<p>To test whether a particular device or combination of devices is supported, we can use a bitwise <strong>AND</strong> operation. A bitwise AND operation will compare the corresponding bits for two different binary values and will set that bit to 1 in a new binary value if both bit input values are 1. As an example, let's test whether phones are supported in the combined value we created earlier:</p>&#13;
<pre> Supported Devices    = 0b 0 1 0 0 0 1 1 <br/> Phone                = 0b 0 0 0 0 0 0 1 <br/> AND Operation Result = 0b 0 0 0 0 0 0 1 </pre>&#13;
<p>The result only has a 1-bit value for the rightmost bit because this is the only bit that was set to 1 in both the <kbd>Supported Devices</kbd> value and the <kbd>Phone</kbd> value.</p>&#13;
<p>Once we have that result, we can directly compare it to the value for <kbd>Phone</kbd>, and if they are equal, then we know that the value of the supported devices included the <kbd>Phone</kbd> value:</p>&#13;
<pre> AND Operation Result = 0b 0 0 0 0 0 0 1 <br/> Phone                = 0b 0 0 0 0 0 0 1 </pre>&#13;
<p>We now have a way to combine the possible options into one value, and a way to compare those values to see whether one is contained in another, using bitwise operations. The Swift standard library contains bitwise operators that allow us to perform these operations as easily as other mathematical operations, such as <em>+</em>, <em>-</em>, <em>*</em>, and <em>/</em>.</p>&#13;
<p>Typically, an operator will be in the following form:</p>&#13;
<pre>&lt;#left hand side value#&gt; &lt;#operator#&gt; &lt;#right hand side value#&gt;  </pre>&#13;
<p>As it is when adding two numbers together:</p>&#13;
<pre>2 + 3</pre>&#13;
<p>In the preceding example, we have these:</p>&#13;
<ul>&#13;
<li><kbd>2</kbd>: This is the left-hand side value.</li>&#13;
<li><kbd>+</kbd>: This is the operator.</li>&#13;
<li><kbd>3</kbd>: This is the right-hand side value.</li>&#13;
</ul>&#13;
<p>The <strong>bit shift operator</strong> (<kbd>&lt;&lt;</kbd>) will take an integer value on the left-hand side and shift it by the number of bit positions to the right-hand side. Therefore, we can use this to express our intention better when declaring the device values:</p>&#13;
<pre>let phone: Int        = 1 &lt;&lt; 0 // 0b0000001 <br/>let tablet: Int       = 1 &lt;&lt; 1 // 0b0000010 <br/>let watch: Int        = 1 &lt;&lt; 2 // 0b0000100 <br/>let laptop: Int       = 1 &lt;&lt; 3 // 0b0001000 <br/>let desktop: Int      = 1 &lt;&lt; 4 // 0b0010000 <br/>let tv: Int           = 1 &lt;&lt; 5 // 0b0100000 <br/>let brainImplant: Int = 1 &lt;&lt; 6 // 0b1000000 </pre>&#13;
<p>The bitwise <strong>AND</strong> operator (<kbd>&amp;</kbd>) will perform the same bit comparison that was previously described manually, and we can use this to create a function to determine whether a particular device exists within the value for the supported devices:</p>&#13;
<pre>supportedDevices = phone + tablet + tv <br/> <br/>func isSupported(device: Int) -&gt; Bool { <br/>    let bitWiseANDResult = supportedDevices &amp; device <br/>    let containsDevice = bitWiseANDResult == device <br/>    return containsDevice <br/>} <br/> <br/>let phoneSupported = isSupported(device: phone) <br/>print(phoneSupported) // true <br/> <br/>let brainImplantSupported = isSupported(device: brainImplant) <br/>print(brainImplantSupported) // false </pre>&#13;
<p>The Swift standard library also provides operators for the following logical operations:</p>&#13;
<ul>&#13;
<li><strong>OR</strong>: The OR operation, denoted by <kbd>|</kbd>, compares bits and sets the corresponding bit to 1 if either value has the bit set to 1. For our devices, this will mean creating a union between two device combinations:</li>&#13;
</ul>&#13;
<pre>let deviceThatSupportUIKit = phone + tablet + tv <br/>let stationaryDevices = desktop + tv <br/>let stationaryOrUIKitDevices = deviceThatSupportUIKit | <br/>  stationaryDevices <br/>let orIsUnion = stationaryOrUIKitDevices == (phone + tablet + tv +<br/>  desktop) <br/>print(orIsUnion) // true </pre>&#13;
<ul>&#13;
<li><strong>XOR (exclusive or)</strong>: The XOR operation, denoted by <kbd>^</kbd>, will only set the bit to 1 if either value has the bit set to 1, but not if they both do:</li>&#13;
</ul>&#13;
<pre>let onlyStationaryOrUIKitDevices = deviceThatSupportUIKit ^ <br/>  stationaryDevices <br/>let xorIsUnionMinusIntersection = onlyStationaryOrUIKitDevices == (phone + <br/>  tablet + desktop) <br/>print(xorIsUnionMinusIntersection) // true</pre>&#13;
<p class="mce-root">We have seen some of the advanced operators available to us, provided by the Swift standard library.</p>&#13;
<h2 id="uuid-fabcf953-3d6a-40b2-8cab-325139c4082a">See also</h2>&#13;
<p>Further information about advanced operators can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/advanced-operators">http://swiftbook.link/docs/advanced-operators</a>.</p>&#13;
<h1 id="uuid-3940e201-97dc-423e-98e4-f1206946b31a">Defining option sets</h1>&#13;
<p>The use of bitwise operations to hold multiple options in one value is a common pattern and is used throughout the <strong>Cocoa Touch framework</strong>, with one example being <kbd>UIDeviceOrientation</kbd>. In Swift, there is a protocol, <kbd>OptionSet</kbd>, that formalizes this pattern and provides additional convenience. In this recipe, we will explore how to define your own option sets.</p>&#13;
<h2 id="uuid-c8cae4fd-7dd0-479b-9ccc-5c9d83b6c0c1">How to do it...</h2>&#13;
<p>Let's rewrite our example from the last recipe, which defined supported device values, to use an <kbd>OptionSet</kbd>:</p>&#13;
<pre>struct Devices: OptionSet { <br/>     <br/>    let rawValue: Int <br/>     <br/>    static let phone        = Devices(rawValue: 1 &lt;&lt; 0) <br/>    static let tablet       = Devices(rawValue: 1 &lt;&lt; 1) <br/>    static let watch        = Devices(rawValue: 1 &lt;&lt; 2) <br/>    static let laptop       = Devices(rawValue: 1 &lt;&lt; 3) <br/>    static let desktop      = Devices(rawValue: 1 &lt;&lt; 4) <br/>    static let tv           = Devices(rawValue: 1 &lt;&lt; 5) <br/>    static let brainImplant = Devices(rawValue: 1 &lt;&lt; 6) <br/>     <br/>    static let none: Devices = [] <br/>    static let all: Devices = [.phone, <br/>                               .tablet, <br/>                               .watch, <br/>                               .laptop, <br/>                               .desktop, <br/>                               .tv, <br/>                               .brainImplant] <br/>    static let stationary: Devices = [.desktop, .tv] <br/>    static let supportsUIKit: Devices = [.phone, <br/>                                         .tablet, <br/>                                         .tv] <br/>} <br/> <br/>let supportedDevices: Devices = [.phone, <br/>                                 .tablet, <br/>                                 .watch, <br/>                                 .tv] </pre>&#13;
<h2 id="uuid-863785f4-dedc-4554-94bf-69f7776e8c46">How it works...</h2>&#13;
<p>The <kbd>OptionSet</kbd> protocol requires a <kbd>rawValue</kbd> property, and the convention is to define static constants for each of the options. Additionally, convenient combinations of options can also be defined as static constants, and <kbd>OptionSet</kbd> provides a convenience initializer, which allows an array of options to be provided, then the options are combined through bitwise addition and stored as one value.</p>&#13;
<p>The <kbd>OptionSet</kbd> protocol provides set-like manipulation and comparison methods that perform the same bitwise operations that we covered in the last recipe:</p>&#13;
<pre>// Contains / AND and comparison <br/>let phoneIsSupported = supportedDevices.contains(.phone) <br/> <br/>// Union / OR  <br/>let stationaryOrUIKitDevices = <br/>  Devices.supportsUIKit.union(Devices.stationary)  <br/> <br/>// Intersection / AND <br/>let stationaryAndUIKitDevices =<br/>  Devices.supportsUIKit.intersection(Devices.stationary) </pre>&#13;
<p>Many of the set methods that we examined in <a href="67605929-e031-49f6-83a9-9f7352e9bad3.xhtml" target="_blank">Chapter 2</a>, <em>Mastering the Building Blocks,</em> are also provided.</p>&#13;
<h2 id="uuid-5233362f-883a-48f0-8e5b-d9d95b077c3c">See also</h2>&#13;
<p>Further information about the <kbd>OptionSet</kbd> protocol can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/optionset">http://swiftbook.link/docs/optionset</a>.</p>&#13;
<h1 id="uuid-ae0a40ab-76e3-460c-b7de-241333949159">Creating custom operators</h1>&#13;
<p>In an earlier recipe, we looked at some of the advanced operators that Swift offers on top of the common mathematical operators. In this recipe, we will look at how we can create our own operators, enabling very concisely expressive behaviors that feel like part of the language.</p>&#13;
<p>The custom operator we will create will be used to append the information in one value to the information in another value, producing a new value that contains the second value, followed by the first. The functionality we are looking to achieve is similar to the <kbd>&gt;&gt;</kbd> Unix command.</p>&#13;
<h2 id="uuid-4aeaf5e5-af28-4d8d-82c7-1cacc68877ef">Getting ready</h2>&#13;
<p>Let's understand how the Unix command, <kbd>&gt;&gt;</kbd>, works, and in this recipe, we will implement something similar in Swift using a custom operator.</p>&#13;
<p>Since macOS is Unix-based, we can provide Unix commands within Terminal. Open up the Terminal application on your Mac:</p>&#13;
<div><img src="img/48084519-19b6-43b6-a8dc-6624eabb9d36.png" style="" width="1119" height="851"/></div>&#13;
<p>Figure 4.1 – Spotlight search</p>&#13;
<p>Type <kbd>cd ~/Desktop</kbd> and press <em>Enter to </em>move to the folder containing all the files and folders on your desktop. Type <kbd>touch Tasks.txt</kbd> and then press <em>Enter to</em> create a blank text file on your desktop, called <kbd>Tasks.txt</kbd>.</p>&#13;
<p>To add tasks to our tasks text file we can type the following command, followed by <em>Enter</em>:</p>&#13;
<pre>echo "buy milk" &gt;&gt; Tasks.txt</pre>&#13;
<p>If you open the text file on your desktop, you'll see that we have added buy milk on the first line.</p>&#13;
<p>Enter another task in the same way:</p>&#13;
<pre>echo "mow the lawn" &gt;&gt; Tasks.txt </pre>&#13;
<p>Reopen the <kbd>Tasks.txt</kbd> file, and you will see that mow the lawn has been added on the second line:</p>&#13;
<div><img src="img/41f26fea-a607-412a-91ed-4262aa5f5ba7.png" style="" width="1201" height="572"/></div>&#13;
<p>Figure 4.2 – Task result</p>&#13;
<p>Add a few more tasks in the same way, and you'll see that each task is appended to the text file on the next line.</p>&#13;
<p>The command we issue in Terminal takes the following form:</p>&#13;
<pre>&lt;#What to append#&gt; &gt;&gt; &lt;#Where to append it#&gt;</pre>&#13;
<p>Let's create similar behavior in Swift; however, we can't use the same command string, <kbd>&gt;&gt;</kbd>, as this is already defined as bit shifting to the right, so let's make it <kbd>&gt;&gt;&gt;</kbd>.</p>&#13;
<h2 id="uuid-da241c9e-ed23-4a75-80e8-a99f4fa70de9">How to do it...</h2>&#13;
<p>We will define and then use a new "append" operator <kbd>&gt;&gt;&gt;</kbd>:</p>&#13;
<ol start="1">&#13;
<li>Declare an <kbd>infix operator</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">infix operator &gt;&gt;&gt;</pre>&#13;
<ol start="2">&#13;
<li>Define the behavior for our operator when used with two strings:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func &gt;&gt;&gt; (lhs: String, rhs: String) -&gt; String { <br/>    var combined = rhs <br/>    combined.append(lhs) <br/>    return combined <br/>}  </pre>&#13;
<ol start="3">&#13;
<li>Define the behavior for our operator when appending a <kbd>String</kbd> to an array of strings:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func &gt;&gt;&gt; (lhs: String, rhs: [String]) -&gt; [String] { <br/>    var combined = rhs <br/>    combined.append(lhs) <br/>    return combined <br/>}</pre>&#13;
<ol start="4">&#13;
<li>Define the behavior for our operator when appending an array of strings to another array of strings:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func &gt;&gt;&gt; (lhs: [String], rhs: [String]) -&gt; [String] { <br/>    var combined = rhs <br/>    combined.append(contentsOf: lhs) <br/>    return combined <br/>}</pre>&#13;
<ol start="5">&#13;
<li>With these implementations in place, use our new operator to append things:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let appendedString = "Two" &gt;&gt;&gt; "One" <br/>print(appendedString) // OneTwo<br/> <br/>let appendedStringToArray = "three" &gt;&gt;&gt; ["one", "two"] <br/>print(appendedStringToArray) // ["one", "two", "three"]<br/> <br/>let appendedArray = ["three", "four"] &gt;&gt;&gt; ["one", "two"] <br/>print(appendedArray)  // ["one", "two", "three", "four"]</pre>&#13;
<ol start="6">&#13;
<li>Refactor the preceding two operator implementations to use a generic element type for arrays:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func &gt;&gt;&gt; &lt;Element&gt;(lhs: Element, <br/>                   rhs: Array&lt;Element&gt;) -&gt; Array&lt;Element&gt; { <br/>    var combined = rhs <br/>    combined.append(lhs) <br/>    return combined <br/>} <br/> <br/>func &gt;&gt;&gt; &lt;Element&gt;(lhs: Array&lt;Element&gt;, <br/>                   rhs: Array&lt;Element&gt;) -&gt; Array&lt;Element&gt; { <br/>    var combined = rhs <br/>    combined.append(contentsOf: lhs) <br/>    return combined <br/>} </pre>&#13;
<ol start="7">&#13;
<li>Use the operator with arrays of any type:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let appendedIntToArray = 3 &gt;&gt;&gt; [1, 2] <br/>print(appendedIntToArray) // [1, 2, 3]<br/> <br/>let appendedIntArray = [3, 4] &gt;&gt;&gt; [1, 2] <br/>print(appendedIntArray) // [1, 2, 3, 4]</pre>&#13;
<p style="padding-left: 60px" class="mce-root">We can implement our custom append operator for our own custom types too.</p>&#13;
<ol start="8">&#13;
<li>Create a <kbd>Task</kbd> and a <kbd>TaskList</kbd> to hold it:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct Task { <br/>    let name: String  <br/>} <br/> <br/>class TaskList: CustomStringConvertible { <br/>    private var tasks: [Task] = [] <br/>    func append(task: Task) { <br/>        tasks.append(task) <br/>    } <br/>    var description: String { <br/>        return tasks.map { $0.name }.joined(separator: "\n") <br/>    } <br/>} </pre>&#13;
<ol start="9">&#13;
<li>Extend <kbd>TaskList</kbd> to add support for our new append operator:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension TaskList { <br/>    static func &gt;&gt;&gt; (lhs: Task, rhs: TaskList) { <br/>        rhs.append(task: lhs) <br/>    } <br/>}</pre>&#13;
<ol start="10">&#13;
<li>Append a <kbd>Task</kbd> to a <kbd>TaskList</kbd> using our custom operator:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let shoppingList = TaskList() <br/>Task(name: "get milk") &gt;&gt;&gt; shoppingList <br/>print(shoppingList) <br/>Task(name: "get teabags") &gt;&gt;&gt; shoppingList <br/>print(shoppingList)</pre>&#13;
<h2 id="uuid-98499bda-9d45-4ff1-859a-8b689d8643c9">How it works...</h2>&#13;
<p>First, we declared an <kbd>infix operator</kbd>:</p>&#13;
<pre>infix operator &gt;&gt;&gt;</pre>&#13;
<p>Operators can come in three types:</p>&#13;
<ul>&#13;
<li><kbd>prefix</kbd> – Operates on one value and is placed before the value. An example is the NOT operator:</li>&#13;
</ul>&#13;
<pre style="padding-left: 60px">let trueValue = !falseValue</pre>&#13;
<ul>&#13;
<li><kbd>postfix</kbd> – Operates on one value and is placed after the value. An example is the force unwrap operator: </li>&#13;
</ul>&#13;
<pre style="padding-left: 60px">let unwrapped = optional!</pre>&#13;
<ul>&#13;
<li><kbd>infix</kbd> - Operates on two values and is placed between them. An example is the addition operator:</li>&#13;
</ul>&#13;
<pre style="padding-left: 60px">let five = 2 + 3</pre>&#13;
<p>Once we have defined the operator, we can write top-level functions that implement the behavior for each pair of types: one on the <strong>left-hand side</strong> (<strong>LHS</strong>) and one on the <strong>right-hand side</strong> (<strong>RHS</strong>). Method parameter overloading allows us to specify the operator implementation for multiple-type pairings.</p>&#13;
<p>We can define how to append one string to another when our operator is used with strings:</p>&#13;
<pre>func &gt;&gt;&gt; (lhs: String, rhs: String) -&gt; String { <br/>    var combined = rhs <br/>    combined.append(lhs) <br/>    return combined <br/>}  </pre>&#13;
<p>We can implement appending a <kbd>String</kbd> to an array of strings:</p>&#13;
<pre>func &gt;&gt;&gt; (lhs: String, rhs: [String]) -&gt; [String] { <br/>    var combined = rhs <br/>    combined.append(lhs) <br/>    return combined <br/>}</pre>&#13;
<p>We can also implement appending the elements in an array of strings to another array of strings:</p>&#13;
<pre>func &gt;&gt;&gt; (lhs: [String], rhs: [String]) -&gt; [String] { <br/>    var combined = rhs <br/>    combined.append(contentsOf: lhs) <br/>    return combined <br/>}</pre>&#13;
<p>This allows us to use the operator with strings and arrays of strings, as those are the implementations we defined:</p>&#13;
<pre>let appendedString = "Two" &gt;&gt;&gt; "One" <br/>print(appendedString) // OneTwo<br/> <br/>let appendedStringToArray = "three" &gt;&gt;&gt; ["one", "two"] <br/>print(appendedStringToArray) // ["one", "two", "three"]<br/> <br/>let appendedArray = ["three", "four"] &gt;&gt;&gt; ["one", "two"] <br/>print(appendedArray)  // ["one", "two", "three", "four"]</pre>&#13;
<p class="mce-root">We can implement our appending operator on every type of array that we think might be useful, but instead, we can implement it as a generic function and have it work for all arrays.</p>&#13;
<p>So, we can refactor the preceding two array implementations to use a generic element type:</p>&#13;
<pre>func &gt;&gt;&gt; &lt;Element&gt;(lhs: Element, <br/>                   rhs: Array&lt;Element&gt;) -&gt; Array&lt;Element&gt; { <br/>    var combined = rhs <br/>    combined.append(lhs) <br/>    return combined <br/>} <br/> <br/>func &gt;&gt;&gt; &lt;Element&gt;(lhs: Array&lt;Element&gt;, <br/>                   rhs: Array&lt;Element&gt;) -&gt; Array&lt;Element&gt; { <br/>    var combined = rhs <br/>    combined.append(contentsOf: lhs) <br/>    return combined <br/>} </pre>&#13;
<p>This allows us to use arrays of ints without having to explicitly define them for int arrays:</p>&#13;
<pre>let appendedIntToArray = 3 &gt;&gt;&gt; [1, 2] <br/>print(appendedIntToArray) // [1, 2, 3]<br/> <br/>let appendedIntArray = [3, 4] &gt;&gt;&gt; [1, 2] <br/>print(appendedIntArray)  // [1, 2, 3, 4]</pre>&#13;
<p>We can also implement it for our own custom types. Let's create <kbd>Task</kbd> and <kbd>TaskList</kbd>, which might benefit from using the operator:</p>&#13;
<pre>struct Task { <br/>    let name: String  <br/>} <br/> <br/>class TaskList: CustomStringConvertible { <br/>    private var tasks: [Task] = [] <br/>    func append(task: Task) { <br/>        tasks.append(task) <br/>    } <br/>    var description: String { <br/>        return tasks.map { $0.name }.joined(separator: "\n") <br/>    } <br/>} </pre>&#13;
<p>We've added <kbd>CustomStringConvertible</kbd> conformance so that we can easily print out the result.</p>&#13;
<p>An alternative to implementing the use of an operator as a top-level function is to declare it within the relevant type as a static function. We'll declare it within an extension on our <kbd>TaskList</kbd> object, but we can just as easily declare it within the main <kbd>TaskList</kbd> class declaration:</p>&#13;
<pre>extension TaskList { <br/>  static func &gt;&gt;&gt; (lhs: Task, rhs: TaskList) { <br/>    rhs.append(task: lhs) <br/>  } <br/>} </pre>&#13;
<p>Implementing this within a type has a few advantages: The implementation code is right next to the type itself, making it easier to find, and taking advantage of any values or types that might have a private, or otherwise restricted, access control, which will prevent them from being visible to a top-level function.</p>&#13;
<p>Now we can use our <kbd>&gt;&gt;&gt;</kbd> operator to append a <kbd>Task</kbd> to a <kbd>TaskList</kbd>:</p>&#13;
<pre>let shoppingList = TaskList() <br/>Task(name: "get milk") &gt;&gt;&gt; shoppingList <br/>print(shoppingList) <br/>Task(name: "get teabags") &gt;&gt;&gt; shoppingList <br/>print(shoppingList) </pre>&#13;
<p>We have created a custom operator, to allow more concise and expressive code.</p>&#13;
<h2 id="uuid-57f1c6c3-ad7f-4275-9a98-8bbdf0dc7890">There's more...</h2>&#13;
<p>Operators don't just work individually – they are often used within the same expression as other operators; the mathematical operators are a helpful example of this:</p>&#13;
<pre>let result = 6 + 8 / 2 / 4</pre>&#13;
<p>The order that each of these operations is performed in will affect the result. To understand the order in which the operations are performed, we can add brackets that will perform the same function:</p>&#13;
<pre>let result = 6 + ((8 / 2) / 4) </pre>&#13;
<p>In Swift, the decision about how to order the operations is made using two concepts – precedence and associativity:</p>&#13;
<ul>&#13;
<li><strong>Precedence</strong>: This defines how important the operation type is. Therefore the operations with the highest precedence are performed first; for example, multiplication (*) has higher precedence than addition (+) and is therefore always performed first.</li>&#13;
<li><strong>Associativity</strong>: This defines which side, left or right, a value should associate itself with for evaluation when it has an operation with the same precedence on either side. This has the effect of defining the order that operations of the same precedence should be evaluated in: left to right or right to left.</li>&#13;
</ul>&#13;
<p>Let's use this information to understand the operation ordering of the preceding mathematical operation. We have an expression comprising of one addition and two division operations. Division operations have higher precedence than addition operations; therefore, the division operations are evaluated first:</p>&#13;
<pre>let result = 6 + (8 / 2 / 4) </pre>&#13;
<p>We now have two division operations that need to be evaluated before the addition operation. Since both are division operators, they have the same precedence, so we have to look at associativity to know in which order to evaluate them. The division operation has an associativity of <kbd>left</kbd>, so they should be evaluated from left to right. Therefore, <kbd>8 / 2</kbd> is evaluated first and <kbd>4 / 4</kbd> is evaluated next. This gives us the following:</p>&#13;
<pre>let result = 6 + ((8 / 2) / 4) </pre>&#13;
<p>We need to define precedence and associativity for our custom operator, as the compiler does not currently know how it should be ordered within an expression containing multiple operations. Because of this, the following expression will not compile:</p>&#13;
<pre>let multiOperationArray = [5,6] &gt;&gt;&gt; [3,4] &gt;&gt;&gt; [1,2] + [9,10] &gt;&gt;&gt; [7,8] <br/>print(multiOperationArray) </pre>&#13;
<p>Precedence and associativity are defined within a precedence group, and an operator can either conform to an existing group or one that has been newly defined.</p>&#13;
<p>Let's define a new precedence group for our appending operator:</p>&#13;
<pre>precedencegroup AppendingPrecedence { <br/>    associativity: left <br/>    higherThan: AdditionPrecedence <br/>    lowerThan: MultiplicationPrecedence <br/>} </pre>&#13;
<p>Here, we give it the name <kbd>AppendingPrecedence</kbd> and define its values within curly brackets. We'll set its associativity to the left to match mathematical operations, and to establish precedence, we define that this precedence group is higher than another precedence group and lower than some other precedence groups. For the appending operator, we'll set the precedence to be higher than addition, so it will be evaluated before the addition operators but after the multiplication operators. Both the <kbd>AdditionPrecendence</kbd> and <kbd>MultiplicationPrecedence</kbd> groups are defined by the <em>standard library</em>.</p>&#13;
<p>Now that we have a precedence group defined, we can ensure that our custom operator conforms to it:</p>&#13;
<pre>infix operator &gt;&gt;&gt; : AppendingPrecedence </pre>&#13;
<p>With precedence and associativity declared, the composite expression previously created will now compile:</p>&#13;
<pre>let multiOperationArray = [5,6] &gt;&gt;&gt; [3,4] &gt;&gt;&gt; [1,2] + [9,10] &gt;&gt;&gt; [7,8] <br/> print(multiOperationArray) // [1,2,3,4,5,6,7,8,9,10] </pre>&#13;
<p>We have defined how our custom operator works alongside other operators, allowing for complex combinations.</p>&#13;
<h2 id="uuid-7c55b2d0-b71b-48b2-b12e-2de84ded72ec">See also</h2>&#13;
<p>Further information about custom operators can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/custom-operators">http://swiftbook.link/docs/custom-operators</a>.</p>&#13;
<h1 id="uuid-9ccd47a7-55ac-4c00-9668-adca1b972d26">Nesting types and namespacing</h1>&#13;
<p>In Objective-C, all objects are at the <strong>top level</strong> and are given a global scope. They can be said to be in the same <strong>namespace</strong>. This is one reason for the convention among Objective-C developers, including Apple, of prefixing their class names with two- or three-letter identifiers.</p>&#13;
<p>These prefix characters allow similarly named classes from different frameworks to be differentiated, for example, <em>UIView</em> from <em>UIKit</em> and <em>SKView</em> from <em>SpriteKit</em>. Swift solves this problem by allowing types to be nested within other types, providing namespacing with nested types and modules.</p>&#13;
<p>Any type can be defined as being nested within another type. This allows us to tightly associate one type with another, in addition to providing namespacing, which helps differentiate types with the same name. In this recipe, we will create some nested types to see if it affects how they are referenced.</p>&#13;
<h2 id="uuid-e99080e4-7fe8-40fd-8786-002fd45d6b3e">How to do it...</h2>&#13;
<p>Let's build a system to monitor a physical device and the user interface that it displays. Both the device and the user interface have the concept of orientation, although each has a differing definition:</p>&#13;
<ol>&#13;
<li>Define a class to represent the device:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Device { <br/>     <br/>    enum Category { <br/>        case watch <br/>        case phone <br/>        case tablet <br/>    } <br/>     <br/>    enum Orientation { <br/>        case portrait <br/>        case portraitUpsideDown <br/>        case landscapeLeft <br/>        case landscapeRight <br/>    } <br/>     <br/>    let category: Category <br/>    var currentOrientation: Orientation = .portrait <br/>     <br/>    init(category: Category) { <br/>        self.category = category <br/>    } <br/>} </pre>&#13;
<p style="padding-left: 60px">Within this class, we have defined two enums, which only have value when used in relation to the <kbd>Device</kbd> class. Nesting the type also allows us to simplify the names of these types. It would be customary to name them <kbd>DeviceCategory</kbd> and <kbd>DeviceOrientation</kbd> to avoid confusion, but since they are nested, we can remove the <kbd>Device</kbd> prefix.</p>&#13;
<p style="padding-left: 60px">Any use of the nested types, within the type that contains them, can be used without any qualifiers; however, this is not the case for use outside of the containing type.</p>&#13;
<ol start="2">&#13;
<li>Access nested types from outside the containing type using dot syntax:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let phone = Device(category: .phone) <br/>let desiredOrientation: Device.Orientation = .portrait <br/>let phoneHasDesiredOrientation = phone.currentOrientation == <br/>  desiredOrientation  </pre>&#13;
<p style="padding-left: 60px">To reference a nested type, we must first specify the containing type, so the <kbd>Orientation</kbd> enum, within the <kbd>Device</kbd> class, becomes <kbd>Device.Orientation</kbd>.</p>&#13;
<ol start="3">&#13;
<li>Define a struct to represent a user interface:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct UserInterface { <br/>     <br/>    struct Version { <br/>        let major: Int <br/>        let minor: Int <br/>        let patch: Int <br/>    } <br/>     <br/>    enum Orientation { <br/>        case portrait <br/>        case landscape <br/>    } <br/>     <br/>    let version: Version <br/>    var orientation: Orientation <br/>} </pre>&#13;
<p style="padding-left: 60px">Our <kbd>UserInterface</kbd> struct also includes a nested <kbd>Orientation</kbd> enum, but as these two enums lie in different namespaces, there is no naming conflict. As before, the nested types can be used without any qualifiers in the containing type.</p>&#13;
<p style="padding-left: 60px">Let's see how these two nested types can be used in conjunction with one another.</p>&#13;
<ol start="4">&#13;
<li>Create a function to convert from device orientation to user interface orientation:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func uiOrientation(for deviceOrientation: Device.Orientation) -&gt; <br/>  UserInterface.Orientation { <br/>    switch deviceOrientation { <br/>    case Device.Orientation.portrait, <br/>      Device.Orientation.portraitUpsideDown: <br/>        return UserInterface.Orientation.portrait <br/>    case Device.Orientation.landscapeLeft, <br/>      Device.Orientation.landscapeRight: <br/>        return UserInterface.Orientation.landscape <br/>    } <br/>} <br/>let phoneUIOrientation = uiOrientation(for: <br/>   phone.currentOrientation) <br/>print(phoneUIOrientation) // UserInterface.Orientation.portrait </pre>&#13;
<h2 id="uuid-0a86c524-0b69-4e80-a1e7-f5516bd00e87">How it works...</h2>&#13;
<p>Our orientation conversion function specifies the full enum case for the <kbd>switch</kbd> statement and the <kbd>return</kbd> statements; for example:</p>&#13;
<pre>Device.Orientation.portrait <br/>UserInterface.Orientation.portrait </pre>&#13;
<p>However, as we've seen previously when the compiler knows the type of the enum, only the case needs to be specified; the enum type can be removed. For our function, the input parameter type is <kbd>Device.Orientation</kbd> and the return type is <kbd>UserInterface.Orientation</kbd>, so the compiler does know enum types, and therefore we can remove the types:</p>&#13;
<pre>func uiOrientation(for deviceOrientation: Device.Orientation) -&gt; UserInterface.Orientation { <br/>    switch deviceOrientation { <br/>    case .portrait, .portraitUpsideDown: <br/>        return .portrait <br/>    case .landscapeLeft, .landscapeRight: <br/>        return .landscape <br/>    } <br/>} </pre>&#13;
<p>Note that the <kbd>switch</kbd> case contains <kbd>.portrait</kbd> and returns <kbd>.portrait</kbd>, but these are cases from different enums, and the compiler knows the difference.</p>&#13;
<h2 id="uuid-6ea78e50-be93-4d0d-8d1d-0654348d0bf5">There's more...</h2>&#13;
<p>We've seen how namespacing separates types nested within different containing types, but types within modules are also namespaced. This allows you to name your types without fear of collision with types in other modules.</p>&#13;
<p>Let's imagine that we are building an app for hospitals to keep track of their events and resources. As part of this, we create a class to represent surgical operations that we intend to track:</p>&#13;
<pre>class Operation { <br/>     <br/>    let doctorsName: String <br/>    let patientsName: String <br/>     <br/>    init(doctorsName: String, patientsName: String) { <br/>        self.doctorsName = doctorsName <br/>        self.patientsName = patientsName <br/>    } <br/>} </pre>&#13;
<p>There is another class called <kbd>Operation</kbd>, provided by the <strong>Foundation</strong> framework, that can be used to execute and manage a long-running task. We can use both types of <kbd>Operation</kbd> side by side, because the <kbd>Foundation</kbd> framework is exposed as a module, and so the long-running <kbd>Operation</kbd> class can be used by referencing the <kbd>Foundation</kbd> module:</p>&#13;
<pre>import Foundation <br/> <br/>let medicalOperation = Operation(doctorsName: "Dr. Crusher", <br/>                                 patientsName: "Commander Riker") <br/>let longRunningOperation = Foundation.Operation() </pre>&#13;
<p>We've seen how you can disambiguate two types with the same name, using the module they are within.</p>&#13;
<h2 id="uuid-1f6c1521-54da-409e-b7cf-31eaecd12072">See also</h2>&#13;
<p>Further information about nested types can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/nested-types">http://swiftbook.link/docs/nested-types</a>.</p>&#13;
&#13;
&#13;
            &#13;
&#13;
            &#13;
        &#13;
    </div></body></html>