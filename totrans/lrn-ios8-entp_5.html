<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Frameworks Introduced with iOS 8"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Frameworks Introduced with iOS 8</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with PhotoKit</li><li class="listitem" style="list-style-type: disc">Handoff for resuming activities seamlessly among all devices</li></ul></div><div class="section" title="Working with PhotoKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Working with PhotoKit</h1></div></div></div><p>One new feature in <a class="indexterm" id="id288"/>iOS 8 has been revealed; it is named <span class="strong"><strong>PhotoKit</strong></span>, also known as Photos Framework. It's a new extension that lets developers work more effectively with photos and videos stored in the device.</p><p>PhotoKit consists <a class="indexterm" id="id289"/>of the following two new frameworks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Photos Framework</strong></span>: This will allow developers to retrieve and edit photos and videos. It is <a class="indexterm" id="id290"/>responsible for handling changes made from external apps and also provides the <a class="indexterm" id="id291"/>tools to build a complete app, such as the Photos app that is available in iOS by default.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Photos UI</strong></span>: This is <a class="indexterm" id="id292"/>responsible for providing the ability to create editing extensions—in other words, to edit photos with our custom app directly from the iOS Camera roll.</li></ul></div><div class="section" title="Photos Framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Photos Framework</h2></div></div></div><p>Photos <a class="indexterm" id="id293"/>Framework provides tools to access, add, edit, and remove the model objects (images, videos, albums, and moments).</p><p>These model instances have a key characteristic—that is, they're read-only. So, for example, we can edit an image, and it won't modify the original content; however, it will create a new one.</p><p>The different model objects are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Assets</strong></span>: They <a class="indexterm" id="id294"/>refer to images and videos, and are represented by the <code class="literal">PHAsset</code> class. It gives the ability to specify the type of media content (photo or video), the date of creation, location, and whether it's a <a class="indexterm" id="id295"/>favorite or not.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Asset collections</strong></span>: They're <a class="indexterm" id="id296"/>also called moments, and they refer to ordered collections of assets, such as albums and smart <a class="indexterm" id="id297"/>albums. These objects are represented by <code class="literal">PHAssetCollection</code>, and its properties are title, type, and the start and end dates.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Collection lists</strong></span>: They're an <a class="indexterm" id="id298"/>ordered collection of collections, and they usually represent a folder or a moment year. The class that <a class="indexterm" id="id299"/>manages them, <code class="literal">PHCollectionList</code>, stores the type, title, and the start and end dates of the list.</li></ul></div><p>Photos <a class="indexterm" id="id300"/>Framework also introduces <span class="strong"><strong>Transient collections</strong></span>, which reference a <a class="indexterm" id="id301"/>group of assets that are the result of a search or user selection, and can be used to interchange with common collections. One more thing to take into account when using this framework is that we will need to make use of class methods such as the following ones to work with assets:</p><div class="informalexample"><pre class="programlisting">[PHAsset fetchAssetsWithMediaType: options:];
[PHAssetCollection fetchMomentsWithOptions:];
[PHAssetCollection transientAssetCollectionWithAssets:title:];</pre></div></div><div class="section" title="Photos UI"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Photos UI</h2></div></div></div><p>Photos UI is a very <a class="indexterm" id="id302"/>interesting framework that allows us to create photo-editing extensions in our apps that will be available in the built-in Photos app.</p><p>This means that, when editing an image in the Camera roll, we can choose which app we want to use for this purpose; the result of this editing will be available for other apps and devices through iCloud and won't modify the original as it's read-only. To achieve this, we will need to create an app extension target that will provide a view controller that, in turn, will adopt the <code class="literal">PHContentEditingController</code> protocol. This is pretty simple, as the new version of Xcode provides a template to create photo-editing extensions; we just need to focus on the implementation of the following protocol methods:</p><div class="informalexample"><pre class="programlisting">[startContentEditingWithInput:]
[finishContentEditingWithCompletionHandler:]
[canHandleAdjustmentData:]
[cancelContentEditing]</pre></div><p>We can use Photos Framework to work with the photo and video assets managed by the Photos app, including <a class="indexterm" id="id303"/>the <span class="strong"><strong>iCloud Photo Library</strong></span>. Use this framework to retrieve <a class="indexterm" id="id304"/>assets for display and playback, edit their image or video content, or work with collections of assets, such as albums, moments, and iCloud shared albums.</p></div><div class="section" title="Features of PhotoKit"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Features of PhotoKit</h2></div></div></div><p>The features <a class="indexterm" id="id305"/>of PhotoKit are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fetching entities and requesting changes</strong></span>: Instances of the Photos Framework model classes (<code class="literal">PHAsset</code>, <code class="literal">PHAssetCollection</code>, and<code class="literal"> PHCollectionList</code>) represent the entities on which a user works within the Photos app. These entities are assets (images or videos), collections of assets (such as albums or moments), and lists of collections (such as album folders or moment clusters). These objects, also called photo entities, are read-only, immutable, and contain only metadata such as the asset's media type and its creation date.<p>We work with assets and collections by fetching the photo entities we're interested in and then using these objects to fetch the data we need to work with. To make changes to photo entities, we create change request objects and explicitly commit them to the shared <code class="literal">PHPhotoLibrary</code> object. This architecture makes it easy, safe, and efficient to work with the same assets from multiple threads or multiple apps and app extensions.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Change observing</strong></span>: Use the shared <code class="literal">PHPhotoLibrary</code> object to register a change handler for the photo entities you fetch. PhotoKit tells your app whenever another app or device changes the content or metadata of an asset or the list of assets in a collection. The <code class="literal">PHChange</code> objects provide information on the object state before and after each change, with semantics that make it easy to update a collection view or a similar interface.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Support for Photos app features</strong></span>: Use the <code class="literal">PHCollectionList</code> class to find assets corresponding to the moments hierarchy in the Photos app. Use the <code class="literal">PHAsset</code> class to identify burst photos, panoramic photos, and high-frame-rate videos. When the iCloud Photo Library is enabled, assets and collections in Photos Framework reflect the content available across all the devices on the same iCloud account.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Asset and thumbnail loading and caching</strong></span>: Use the <code class="literal">PHImageManager</code> class to request images of assets in a specified size or AV Foundation objects to work with video assets. Photos Framework automatically downloads or generates images according to your specification, caching them for quick reuse. For faster performance with a large numbers of assets—for example, when populating a collection view with thumbnails—the <code class="literal">PHCachingImageManager</code> subclass adds bulk preloading.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Asset content editing</strong></span>: The <code class="literal">PHAsset</code> and <code class="literal">PHAssetChangeRequest</code> classes define the methods to request photo or video content to edit and to commit your edits to the photo library. To support continuity of editing between different apps and extensions, Photos keeps the current and previous versions of each asset, along with the <code class="literal">PHAdjusmentData</code> object that describes the last edit. If your app supports adjustment data from a previous edit, you can allow the user to <a class="indexterm" id="id306"/>revert or alter the edit.</li></ul></div><p>There are a lot of classes for PhotoKit; we will discuss them in this table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Classes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHAdjustmentData</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When a <a class="indexterm" id="id307"/>user edits an asset, Photos saves this object along with the modified <a class="indexterm" id="id308"/>image or video data</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHAssetChangeRequest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id309"/>can create and use this object within a photo library and change <a class="indexterm" id="id310"/>the block to create, delete, or modify <code class="literal">PHAsset</code> objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHAssetCollectionChangeRequest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id311"/>can create and use this object within a photo library and change the block to create, delete, or <a class="indexterm" id="id312"/>modify <code class="literal">PHAssetCollection</code> objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHChange</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Photos <a class="indexterm" id="id313"/>provides this object to notify your app of any changes to the <a class="indexterm" id="id314"/>assets and collections managed by the Photos app</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHCollectionListChangeRequest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id315"/>can <a class="indexterm" id="id316"/>create and use this object within a photo library and change the block to create, delete, or modify <code class="literal">PHCollectionList</code> objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHContentEditingInput</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id317"/>object describes <a class="indexterm" id="id318"/>an asset to be used for editing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHContentEditingInputRequestOptions</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id319"/>can use this object to specify options when requesting to edit the image or video content <a class="indexterm" id="id320"/>of a <code class="literal">PHAsset</code> object</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHContentEditingOutput</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id321"/>object represents the results of editing the photo or video <a class="indexterm" id="id322"/>content of a Photos asset</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHFetchOptions</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id323"/>can use this object to specify options when using class methods on <a class="indexterm" id="id324"/>the <code class="literal">PHAsset</code>, <code class="literal">PHCollection</code>, <code class="literal">PHAssetCollection</code>, and <code class="literal">PHCollectionList</code> classes to retrieve photo entities</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHFetchResult</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id325"/>object is a container for an ordered list of photo <a class="indexterm" id="id326"/>entity objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHFetchResultChangeDetails</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id327"/>object provides detailed information about the differences between two fetch results—the <a class="indexterm" id="id328"/>one that you previously obtained and the updated one that would be the result if you performed the same fetch again</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHImageManager</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id329"/>shared object, and it provides methods to load images or video <a class="indexterm" id="id330"/>data associated with a <code class="literal">PHAsset</code> object</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHCachingImageManager</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id331"/>object fetches or generates image data for photo or video <a class="indexterm" id="id332"/>assets.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHImageRequestOptions</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id333"/>can use this object to specify options when requesting image <a class="indexterm" id="id334"/>representations of photo assets from a <code class="literal">PHImageManager</code> object</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHObject</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id335"/>class is the abstract base class for photo-entity <a class="indexterm" id="id336"/>objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHAsset</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id337"/>object represents an image or video file that appears in the Photos <a class="indexterm" id="id338"/>app, including the iCloud Photos content</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHCollection</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id339"/>class is an abstract class that defines the behavior <a class="indexterm" id="id340"/>shared between the Photos collection classes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHAssetCollection</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id341"/>object represents <a class="indexterm" id="id342"/>a collection of photos or video assets</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHCollectionList</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id343"/>object represents <a class="indexterm" id="id344"/>a group of asset collections</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHObjectPlaceholder</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id345"/>object is a read-only <a class="indexterm" id="id346"/>proxy that represents an object yet to be created</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHObjectChangeDetails</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id347"/>object provides detailed information about the differences <a class="indexterm" id="id348"/>between two states of a photo entity—one that you previously obtained and the updated state that would be the result if you fetched this entity again</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHPhotoLibrary</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is <a class="indexterm" id="id349"/>a shared object that represents the user's Photos library—the entire set of assets and collections <a class="indexterm" id="id350"/>managed by the Photos app, including the objects stored in the local device and (if enabled) in iCloud Photos</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PHVideoRequestOptions</code> </p>
</td><td style="text-align: left" valign="top">
<p>You <a class="indexterm" id="id351"/>can use this <a class="indexterm" id="id352"/>object to specify options when requesting video assets from a <code class="literal">PHImageManager</code> object</p>
</td></tr></tbody></table></div><p>PhotoKit makes it easy to query model data through a variety of fetch methods. For example, to retrieve all images, you can call <code class="literal">PFAsset.Fetch,</code> passing the <code class="literal">PHAssetMediaType.Image</code> media type:</p><div class="informalexample"><pre class="programlisting">PHFetchResult fetchResults = PHAsset.FetchAssets (PHAssetMediaType.Image, null);</pre></div><p>The <code class="literal">PHFetchResult</code> instance <a class="indexterm" id="id353"/>will then contain all the <code class="literal">PFAsset</code> instances that represent images. To get the images themselves, you can use <code class="literal">PHImageManager</code> (or the caching version, <code class="literal">PHCachingImageManager</code>) to make a request for the image by calling <code class="literal">requestImageForAsset</code>. For example, the following code retrieves an image for each asset in <code class="literal">PHFetchResult</code> to display in a collection view cell. This example is in the Swift language, so we need to understand Swift. To begin with <a class="indexterm" id="id354"/>Swift in a better way, you can go to <a class="ulink" href="http://www.raywenderlich.com/tutorials">http://www.raywenderlich.com/tutorials</a>.</p><div class="informalexample"><pre class="programlisting">public override UICollectionViewCell GetCell (UICollectionView collectionView, NSIndexPath indexPath)
{
  var imageCell = (ImageCell)collectionView.DequeueReusableCell(cellId, indexPath);
  imageMgr.RequestImageForAsset ((PHAsset)fetchResults[(uint)indexPath.Item], 
    thumbnaillSize,
    PHImageContentMode.AspectFill, new PHImageRequestOptions (),(img, info) =&gt; {
        imageCell.ImageView.Image = img;
    });
  return imageCell;
}</pre></div><p>This is how you handle querying and reading data. You can also write changes back to the library. Since multiple interested applications are able to interact with the system's photo library, you can register an observer to be notified of any changes using <code class="literal">PhotoLibraryObserver</code>. Then, when changes come in, your application can update accordingly. For example, here's a simple implementation for reloading the collection view:</p><div class="informalexample"><pre class="programlisting">class PhotoLibraryObserver : PHPhotoLibraryChangeObserver
{
  readonly PhotosViewController controller;
  public PhotoLibraryObserver (PhotosViewController controller)
  {
    this.controller = controller;
  }
  public override void PhotoLibraryDidChange (PHChange changeInstance)
  {
    DispatchQueue.MainQueue.DispatchAsync (() =&gt; {
      var changes = changeInstance.GetFetchResultChangeDetails (controller.fetchResults);
      controller.fetchResults = changes.FetchResultAfterChanges;
      controller.CollectionView.ReloadData ();
    });
  }
}</pre></div><p>To actually write changes back from your application, you can create a change request. Each of the model classes has an associated change request class. For example, to change <code class="literal">PHAsset</code>, you can create <code class="literal">PHAssetChangeRequest</code>. The steps to perform changes that are written back to the photo library and sent to observers, like the preceding code, are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Perform the editing operation.</li><li class="listitem">Save the filtered image data to a <code class="literal">PHContentEditingOutput</code> instance.</li><li class="listitem">Make a change request to publish the changes form the editing output.</li></ol></div><p>Here's an example that writes back a change to an image that applies a core image noir filter. You can also refer to <a class="ulink" href="http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/">http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/</a> to understand in more detail:</p><div class="informalexample"><pre class="programlisting">void ApplyNoirFilter (object sender, EventArgs e)
{
  Asset.RequestContentEditingInput (new PHContentEditingInputRequestOptions (), (input, options) =&gt; {
    //
    // perform the editing operation, which applies a noir filter in this case
    var image = CIImage.FromUrl (input.FullSizeImageUrl);
    image = image.CreateWithOrientation ((CIImageOrientation)input.FullSizeImageOrientation);
    var noir = new CIPhotoEffectNoir {
      Image = image
    };
    var ciContext = CIContext.FromOptions (null);
    var output = noir.OutputImage;
    var uiImage = UIImage.FromImage (ciContext.CreateCGImage (output, output.Extent));
    imageView.Image = uiImage;
    //
    // save the filtered image data to a PHContentEditingOutput instance
    var editingOutput = new PHContentEditingOutput(input);
    var adjustmentData = new PHAdjustmentData();
    var data = uiImage.AsJPEG();
    NSError error;
    data.Save(editingOutput.RenderedContentUrl, false, out error);
    editingOutput.AdjustmentData = adjustmentData;
    //
    // make a change request to publish the changes form the editing output
    PHPhotoLibrary.GetSharedPhotoLibrary.PerformChanges (
      () =&gt; {
        PHAssetChangeRequest request = PHAssetChangeRequest.ChangeRequest(Asset);
        request.ContentEditingOutput = editingOutput;
      },
    (ok, err) =&gt; Console.WriteLine ("photo updated successfully: {0}", ok));
  });
}</pre></div><p>When the user selects the button, the filter is applied, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Features of PhotoKit" src="graphics/1829OT_05_01.jpg"/></div><p>Thanks to <code class="literal">PHPhotoLibraryChangeObserver</code>, the change is reflected in the collection view when the user navigates back to the photo library.</p><p>You can download the sample project from <a class="ulink" href="https://github.com/mikebluestein/PhotoKitDemo">https://github.com/mikebluestein/PhotoKitDemo</a>.</p></div></div></div>
<div class="section" title="Handoff for seamlessly resuming activities"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Handoff for seamlessly resuming activities</h1></div></div></div><p>Handoff is a <a class="indexterm" id="id355"/>feature in OS X and iOS that extends the user experience of continuity across devices. Handoff enables users to begin an activity on one device and then switch to another device and resume the same activity there. For example, a user who is browsing a long article in Safari moves to an iOS device that's signed in to the same Apple ID; the same webpage now automatically opens in Safari on iOS, with the same scroll position as on the original device. Handoff makes this experience as seamless as possible.</p><p>To participate in Handoff, an app adopts a small API in foundation. Each ongoing activity in an app is represented by a user activity object that contains the data needed to resume an activity on another device. When the user chooses to resume this activity, the object is sent to the resuming device. Each user activity object has a delegate object that is invoked to refresh the activity state at opportune times, such as just before the user activity object is sent between devices.</p><p>If continuing an activity requires more data than is easily transferred by the user activity object, the resuming app has the option to open a stream to the originating app. Document-based apps automatically support activity continuation for users working with iCloud-based documents. Apple apps use public APIs to implement Handoff for iOS 8 and OS X v10.10. A <a class="indexterm" id="id356"/>third-party developer can use the same APIs to implement Handoff in apps that share the developer's team ID. Such apps must either be distributed through the <a class="indexterm" id="id357"/>App Store or signed by the registered developer.</p><div class="section" title="Compatibility with Handoff"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Compatibility with Handoff</h2></div></div></div><p>First, let's see <a class="indexterm" id="id358"/>what is compatible with Handoff:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">iOS devices with a Lightning connector along with 2012 or later Mac models support Handoff. Both have radio chips that support both Bluetooth Low Energy and Wi-Fi Direct.</li><li class="listitem" style="list-style-type: disc">If your device is compatible, you can enable Handoff in the <span class="strong"><strong>General</strong></span> system preference on your Mac and in the <span class="strong"><strong>General</strong></span> pane under the <span class="strong"><strong>Settings</strong></span> app in iOS; in both cases, look for an option that includes the <span class="strong"><strong>Handoff</strong></span> word.</li><li class="listitem" style="list-style-type: disc">All the devices have to be signed in to the same iCloud account. Handoff doesn't work with other users (this is what AirDrop is for).</li><li class="listitem" style="list-style-type: disc">Finally, make sure that both Bluetooth and Wi-Fi are turned on for all devices.</li></ul></div><p>So far, Apple has announced that Handoff will work with the following apps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mail</li><li class="listitem" style="list-style-type: disc">Safari</li><li class="listitem" style="list-style-type: disc">Pages</li><li class="listitem" style="list-style-type: disc">Numbers</li><li class="listitem" style="list-style-type: disc">Keynote</li><li class="listitem" style="list-style-type: disc">Maps</li><li class="listitem" style="list-style-type: disc">Messages</li><li class="listitem" style="list-style-type: disc">Reminders</li><li class="listitem" style="list-style-type: disc">Calendar</li><li class="listitem" style="list-style-type: disc">Contacts</li></ul></div><p>With them, we can start composing or reading an e-mail or website; editing a document, spreadsheet, or keynote; finding a location; typing a text; picking a reminder; entering an appointment; or looking up an <a class="indexterm" id="id359"/>address on your Mac and continuing or finishing it on your iPhone (iPad, or vice versa).</p><div class="section" title="App framework support"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec04"/>App framework support</h3></div></div></div><p>
<span class="strong"><strong>UIKit</strong></span> and <span class="strong"><strong>AppKit</strong></span> <a class="indexterm" id="id360"/>provide support for Handoff in the <a class="indexterm" id="id361"/>document, responder, and app delegate classes. Although there are minor <a class="indexterm" id="id362"/>behavioral differences between the platforms, the basic mechanism that enables the apps to save and restore user activities is the same, and the APIs are the same.</p></div><div class="section" title="Handoff interactions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec05"/>Handoff interactions</h3></div></div></div><p>Handing off a user <a class="indexterm" id="id363"/>activity involves the following three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a user activity object for each activity in which the user is engaged.</li><li class="listitem">Update the user activity object regularly with information on what the user is doing.</li><li class="listitem">Continue the user activity on a different device when the user requests it.</li></ol></div></div></div><div class="section" title="Implementing Handoff directly"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Implementing Handoff directly</h2></div></div></div><p>Adopting <a class="indexterm" id="id364"/>Handoff in your app requires you to write the code that use APIs in UIKit and AppKit to create a user activity object, update the state of the object to track the activity, and continue the activity on another device.</p><div class="section" title="Creating the user activity object"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec06"/>Creating the user activity object</h3></div></div></div><p>Every user <a class="indexterm" id="id365"/>activity that can be handed off to <a class="indexterm" id="id366"/>a continuing device is represented by a user activity object instantiated from the <code class="literal">NSUserActivity</code> class. This class creates a user activity object for each user activity it supports. The types of those user activities depend on the app. For example, Safari lets the user to continue with the browser on the same site.</p><p>The following code creates the instance of <code class="literal">NSUserActivity</code>. The <code class="literal">myacitvity.userinfo</code> object stores the current URL with the scroll position. The <code class="literal">becomeCurrent</code> object contains the current state of our project, and it is updating every second. Creating an object for the current state is necessary; otherwise, other devices won't understand from where to start.</p><div class="informalexample"><pre class="programlisting">NSUserActivity* myActivity = [[NSUserActivity alloc]
   initWithActivityType: @"com.myCompany.myBrowser.browsing"];
myActivity.userInfo = @{ ... };
myActivity.title = @"Browsing";
[myActivity becomeCurrent];</pre></div><p>After terminating or finishing the app, the user activity object will release automatically. Then the object <a class="indexterm" id="id367"/>is removed from all the <a class="indexterm" id="id368"/>devices.</p></div><div class="section" title="Specifying an activity type"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec07"/>Specifying an activity type</h3></div></div></div><p>The <a class="indexterm" id="id369"/>activity type identifier is a short string that appears in your app's <code class="literal">Info.plist</code> property list file in its <code class="literal">NSUserActivityTypes</code> array, which lists all the activity types that your app supports. The same string is passed when you create the activity, where the activity object is created with the <a class="indexterm" id="id370"/>activity type of <code class="literal">com.myCompany.myBrowser.browsing</code>, a reverse-DNS-style notation intended to avoid collisions. When the user chooses to continue the activity, the activity type (along with the app's team ID) determines which app to launch on the receiving device to continue the activity.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>You can specify the activity type of an <code class="literal">NSUserActivity</code> object when you create the instance. You cannot change the activity type of the object after it is created.</p></div></div><p>For example, a Reminders-style app serializes the reminder list the user is looking at. When the user clicks on a new reminder list, the app tracks that activity in <code class="literal">NSUserActivityDelegate</code>. The following code shows a possible implementation of a method that gets called whenever the user switches to a different reminder list. This app appends an activity name to the app's bundle identifier to create the activity type to use when it creates its <code class="literal">NSUserActivity</code> object.</p><div class="informalexample"><pre class="programlisting">    // UIResponder and NSResponder have a userActivity property
    NSUserActivity *currentActivity = [self userActivity];
 
   // Build an activity type using the app's bundle identifier
    NSString *bundleName = [[NSBundle mainBundle] bundleIdentifier];
    NSString *myActivityType = [bundleName stringByAppendingString:@".selected-list"];
 
    if(![[currentActivity activityType] isEqualToString:myActivityType]) {
        [currentActivity invalidate];
 
        currentActivity = [[NSUserActivity alloc]
          initWithActivityType:myActivityType];
        [currentActivity setDelegate:self];
        [currentActivity setNeedsSave:YES];
 
        [self setUserActivity:currentActivity];
 
    } else {
 
      // Already tracking user activity of this type
      [currentActivity setNeedsSave:YES];
    }</pre></div><p>The preceding code uses the <code class="literal">setNeedsSave</code>: accessor method to mark the user activity object when it <a class="indexterm" id="id371"/>needs to be updated. This <a class="indexterm" id="id372"/>enables the system to coalesce updates and perform them lazily.</p></div><div class="section" title="Populating the activity object's user info dictionary"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec08"/>Populating the activity object's user info dictionary</h3></div></div></div><p>The <a class="indexterm" id="id373"/>activity object has a user info dictionary that contains whatever data is needed to hand off the <a class="indexterm" id="id374"/>activity to the continuing app. The user info dictionary can contain <code class="literal">NSArray</code>, <code class="literal">NSDate</code>, <code class="literal">NSDictionary</code>, <code class="literal">NSNull</code>, <code class="literal">NSNumber</code>, <code class="literal">NSSet</code>, <code class="literal">NSString</code>, and <code class="literal">NSUrl</code> objects. The system modifies the <code class="literal">NSUrl</code> objects that use the <code class="literal">file:</code> scheme and point at iCloud documents to point to the same items in the corresponding container on the receiving device:</p><div class="informalexample"><pre class="programlisting">NSUserActivity* myActivity = [[NSUserActivity alloc]
                      initWithActivityType: @"com.myCompany.myReader.reading"];
 
// Initialize userInfo
NSURL* webpageURL = [NSURL URLWithString:@"http://www.myCompany.com"];
myActivity.userInfo = @{
             @"docName" : currentDoc,
             @"pageNumber" : self.pageNumber,
             @"scrollPosition" : self.scrollPosition
};</pre></div></div><div class="section" title="Adopting Handoff in responders"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Adopting Handoff in responders</h3></div></div></div><p>You can <a class="indexterm" id="id375"/>associate responder objects (inheriting from <code class="literal">NSResponder</code> on OS X or <code class="literal">UIResponder</code> on iOS) with a given user activity if you set the activity as the responder's <code class="literal">userActivity</code> property. The system automatically saves the <code class="literal">NSUserActivity</code> object at appropriate times, calling the responder's <code class="literal">updateUserActivityState</code>: override to add current data to the user activity object using the <a class="indexterm" id="id376"/>activity object's <code class="literal">userInfoEntriesFromDictionary</code>: method:</p><div class="informalexample"><pre class="programlisting">- (void)updateUserActivityState:(NSUserActivity *)userActivity {
    . . .
  [userActivity setTitle: self.activityTitle];
  [userActivity addUserInfoEntriesFromDictionary: self.activityUserInfo];
}</pre></div></div><div class="section" title="Continuing an activity"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Continuing an activity</h3></div></div></div><p>Handoff <a class="indexterm" id="id377"/>automatically advertises user activities that are available to be continued on iOS and OS X devices that are in physical <a class="indexterm" id="id378"/>proximity to the originating device and signed in to the same iCloud account as the originating device. When the user chooses to continue a given activity, Handoff launches the appropriate app and sends the app delegate messages that determine how the activity is resumed using the <code class="literal">AppDelegate</code>.</p><p>Implement the <code class="literal">application:willContinueUserActivityWithType:</code> method to let the user know that the activity will continue shortly. Use the <code class="literal">application:continueUserActivity:restorationHandler:</code> method to configure the app to continue the activity. The system calls this method when the activity object, including the activity state data in its <code class="literal">userInfo</code> dictionary, is available to the continuing app.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>For URLs transferred in the <code class="literal">userinfo</code> dictionary of an <code class="literal">NSUserActivity</code> object, we must call <code class="literal">startAccessingSecurityScopedResource</code>, and it must return <code class="literal">YES</code> before we can access the URL. Call <code class="literal">stopAccessingSecurityScopedResource</code> when you are done using the file.</p></div></div><p>Exceptions to this requirement are URLs of <code class="literal">UIDocument</code> documents and those of <code class="literal">NSDocument</code> that are automatically created for <code class="literal">specifyingNSUbiquitousDocumentUserActivityType</code> apps and return NO from the <code class="literal">:continueUserActivity:restorationHandler:</code> application (or leave it unimplemented). See <span class="emphasis"><em>Adopting Handoff in Document-Based Apps</em></span> at <a class="ulink" href="https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17">https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17</a>.</p><p>Additional configuration <a class="indexterm" id="id379"/>of your app to continue the activity can optionally be performed by objects you give to the restoration handler block that is passed in with the <code class="literal">application:continueUserActivity:restorationHandler:</code> message. The following code shows <a class="indexterm" id="id380"/>a simple implementation of this method:</p><div class="informalexample"><pre class="programlisting">- (BOOL)application:(NSApplication *)application
             continueUserActivity: (NSUserActivity *)userActivity
               restorationHandler: (void (^)(NSArray*))restorationHandler {
    BOOL handled = NO;
    // Extract the payload
    NSString *type = [userActivity activityType];
    NSString *title = [userActivity title];
    NSDictionary *userInfo = [userActivity userInfo];
    // Assume the app delegate has a text field to display the activity information
    [appDelegateTextField setStringValue: [NSString stringWithFormat:
        @"User activity is of type %@, has title %@, and user info %@",
        type, title, userInfo]];
 
    restorationHandler(self.windowControllers);
    handled = YES;
 
    return handled;
}</pre></div><p>In this case, the app delegate has an array of <code class="literal">NSWindowController</code> objects, <code class="literal">windowControllers</code>. These window controllers know how to configure all of the app's windows to resume the activity. After you pass this array to the <code class="literal">restorationHandler</code> block, Handoff sends each of those objects a <code class="literal">restoreUserActivityState:</code> message, passing in the resuming activity's <code class="literal">NSUserActivity</code> object. The window controllers inherit the <code class="literal">restoreUserActivityState:</code> method from <code class="literal">NSResponder</code>; each controller object overrides this method to configure its window, using the information in the activity object's <code class="literal">userInfo</code> dictionary.</p><p>To support graceful failure, the app delegate should implement the <code class="literal">application:didFailToContinueUserActivityWithType:error:</code> method. If you don't implement this method, the app framework, nonetheless, displays diagnostic information contained in the passed-in <code class="literal">NSError</code> object.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The <code class="literal">UIApplicationDelegate</code> methods for Handoff described in this section are not called when either of the application delegate methods, <code class="literal">application:willFinishLaunchingWithOptions:</code> or <code class="literal">application:didFinishLaunchingWithOptions:</code>, returns NO.</p></div></div></div></div><div class="section" title="Native App-to-Web Browser Handoff"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Native App-to-Web Browser Handoff</h2></div></div></div><p>When using a <a class="indexterm" id="id381"/>native app on the originating device, the user might want to continue the activity on a corresponding native app. If there is a web page that corresponds to the activity, it can still be handed off. For example, video library apps enable users to browse movies <a class="indexterm" id="id382"/>available for viewing, and mail apps enable users to read and compose e-mails. In many cases, users can perform the same activity through a web page interface. In this case, the native app knows the URL for the web interface, possibly including syntax that designates a particular video being browsed or message being read. So, when the native app creates the <code class="literal">NSUserActivity</code> object, it sets the <code class="literal">webpageURL</code> property. If the receiving device doesn't have an app that supports the user activity's <code class="literal">activityType</code> property, it can resume the activity in the default web browser of the continuing platform.</p><p>A web browser on OS X that wants to continue an activity in this way should claim the <code class="literal">NSUserActivityTypeBrowsingWeb</code> activity type (by entering this string in its <code class="literal">NSUserActivityTypes</code> array in the app's <code class="literal">Info.plist</code> property list file). This ensures that, if the user selects any other browser as their default browser, it receives the activity object instead of Safari.</p></div><div class="section" title="Web Browser-to-Native App Handoff"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Web Browser-to-Native App Handoff</h2></div></div></div><p>In the <a class="indexterm" id="id383"/>opposite case, if the user is using a web browser on the originating device and the receiving device is an iOS device with a native app that claims the domain portion of the <code class="literal">webpageURL</code> property, then iOS launches the native <a class="indexterm" id="id384"/>app and sends it an <code class="literal">NSUserActivity</code> object with an <code class="literal">activityType</code> value of <code class="literal">NSUserActivityTypeBrowsingWeb</code>. The <code class="literal">webpageURL</code> property contains the URL that the user was visiting, while the <code class="literal">userInfo</code> dictionary is empty.</p><p>The native app on the receiving device must adapt to this behavior by claiming a domain in the <code class="literal">com.apple.developer.associated-domains</code> entitlement. The value of this entitlement has the <code class="literal">&lt;service&gt;:&lt;fully qualified domain name&gt;</code> format, for example, <code class="literal">activitycontinuation:example.com</code>. In this case, the service must be <code class="literal">activitycontinuation</code>. Add the value for the <code class="literal">com.apple.developer.associated-domains</code> entitlement in Xcode in the <span class="strong"><strong>Associated Domains</strong></span> section under the <span class="strong"><strong>Capabilities</strong></span> tab of the <span class="strong"><strong>Target</strong></span> settings.</p><p>If this domain matches the <code class="literal">webpageURL</code> property, Handoff downloads a list of approved app IDs from the domain. Domain-approved apps are authorized to continue the activity. On your website, you can list the approved apps in a signed JSON file named <code class="literal">apple-app-site-association</code>; for example, the web address becomes <code class="literal">https://example.com/apple-app-site-association</code> (you must use an actual device rather than the simulator to test download the JSON file).</p><p>The JSON file contains a dictionary that specifies a list of app identifiers in the <code class="literal">&lt;team identifier&gt;.&lt;bundle identifier&gt;</code> format in the <span class="strong"><strong>General</strong></span> tab of the <span class="strong"><strong>Target</strong></span> settings—for example, <code class="literal">YWBN8XTPBJ.com.example.myApp</code>. The following code shows an example of such a JSON file formatted for reading:</p><div class="informalexample"><pre class="programlisting">{
    "activitycontinuation": {
    "apps": [ "YWBN8XTPBJ.com.example.myApp",
              "YWBN8XTPBJ.com.example.myOtherApp" ]
    }
}</pre></div><p>To sign the JSON file (so that it is returned from the server with the correct content-type of <code class="literal">application/pkcs7-mime</code>), put the content in a text file and sign it. You can perform this task with terminal commands such as those shown in the following code, by removing the whitespace from the text for ease of manipulation. Use the <code class="literal">openssl</code> command with the certificate and key for an identity issued by a certificate authority trusted by iOS (which is listed at <a class="ulink" href="http://support.apple.com/kb/ht5012">http://support.apple.com/kb/ht5012</a>). It need not be the same identity that hosts the web credentials (<code class="literal">https://example.com</code> in the example code), but <a class="indexterm" id="id385"/>it must be a valid TLS certificate <a class="indexterm" id="id386"/>for the domain name in question:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>echo '{"activitycontinuation":{"apps":["YWBN8XTPBJ.com.example.myApp",</strong></span>
<span class="strong"><strong>"YWBN8XTPBJ.com.example.myOtherApp"]}}' &gt; json.txt</strong></span>
<span class="strong"><strong> cat json.txt | openssl smime -sign -inkey example.com.key</strong></span>
<span class="strong"><strong>                             -signer example.com.pem</strong></span>
<span class="strong"><strong>                             -certfile intermediate.pem</strong></span>
<span class="strong"><strong>                             -noattr -nodetach</strong></span>
<span class="strong"><strong>                             -outform DER &gt; apple-app-site-association</strong></span>
</pre></div><p>The output of the <code class="literal">openssl</code> command is the signed JSON file that you put on your website at the <code class="literal">apple-app-site-association</code> URL—in this example, <code class="literal">https://example.com/apple-app-site-association</code>.</p><p>An app can set the <code class="literal">webpageURL</code> property to any web URL, but it only receives activity objects whose <code class="literal">webpageURL</code> domain is in the <code class="literal">com.apple.developer.associated-domains </code>entitlement. Also, the scheme of the <code class="literal">webpageURL</code> must be <code class="literal">http</code> or <code class="literal">https</code>. Any other scheme throws <a class="indexterm" id="id387"/>an exception.</p></div><div class="section" title="Using continuation streams"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Using continuation streams</h2></div></div></div><p>If resuming an <a class="indexterm" id="id388"/>activity requires more data than can be efficiently transferred by the initial Handoff payload, a continuing app can call back to the originating app's activity object to open streams between the apps and transfer more data. In this case, the originating app sets its <code class="literal">NSUserActivity</code> object's Boolean property, <code class="literal">supportsContinuationStreams</code>, to <code class="literal">YES</code>, sets the user activity delegate, and then calls <code class="literal">becomeCurrent</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">NSUserActivity* activity = [[NSUserActivity alloc] init];
activity.title = @"Editing Mail";
activity.supportsContinuationStreams = YES;
activity.delegate = self;
[activity becomeCurrent];</pre></div><p>On the continuing device, after users indicate that they want to resume the activity, the system launches the appropriate app and begins sending messages to the app delegate. The app delegate can then request streams back to the originating app by sending the<code class="literal"> getContinuationStreamsWithCompletionHandler</code> message to its user activity object, as shown in the override implementation in the following code:</p><div class="informalexample"><pre class="programlisting">- (BOOL)application:(UIApplication *)application
        continueUserActivity: (NSUserActivity *)userActivity
        restorationHandler: (void(^)(NSArray *restorableObjects))restorationHandler
{
    [userActivity getContinuationStreamsWithCompletionHandler:^(
                  NSInputStream *inputStream,
                  NSOutputStream *outputStream, NSError *error) {
 
        // Do something with the streams
 
    }];
 
  return YES;
}</pre></div><p>On the originating device, the user activity delegate receives the streams in a callback to its <code class="literal">userActivity:didReceiveInputStream:outputStream</code> method, which it implements to provide the data needed to continue the user activity on the resuming device using the streams.</p><p>
<code class="literal">NSInputStream</code> provides read-only access to stream data, and <code class="literal">NSOutputStream</code> provides write-only access. Therefore, data written to the output stream on the originating side is read from the input stream on the continuing side; and vice versa. Streams are meant to be used in a request-and-response fashion, that is, the continuing side uses the streams to request more continuation data from the originating side, which then uses the streams to provide the requested data.</p><p>Continuation streams are an optional feature of Handoff; most user activities do not need them for successful continuation. Even when streams are needed, in most cases there should be minimal back-and-forth between the apps. A simple request from the continuing app accompanied by a response from the originating app should be enough for most continuation <a class="indexterm" id="id389"/>events. You can download the sample project from <a class="ulink" href="https://github.com/dokterdok/Continuity-Activation-Tool">https://github.com/dokterdok/Continuity-Activation-Tool</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we discussed the new iOS 8 APIs and little code snippets of Swift. You learned about the PhotoKit framework and Handoff with some code snippets. In the next chapter, we will discuss iCloud and security services in iOS, together with their implementations.</p></div></body></html>