- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Blazor Hybrid App Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET MAUI, an alternative approach to constructing the **user interface**
    (**UI**) is by using Blazor. Blazor, a modern web framework developed by Microsoft,
    allows developers to create interactive web applications utilizing C# and Razor
    syntax instead of JavaScript. Additionally, Blazor can be employed in the development
    of .NET MAUI applications as part of a Blazor Hybrid app. The fundamental building
    blocks of Blazor are Razor components, which can be reused between native and
    web applications when utilizing Blazor and Blazor Hybrid. In comparison to XAML
    UIs, a Blazor UI offers increased reusability, encompassing both native and web
    applications. In this chapter, we will provide an introduction to Blazor and discuss
    its implementation in various scenarios. Additionally, we will introduce Razor
    components and explain how to develop a Blazor Hybrid app using these components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a .NET MAUI Blazor project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a new Razor component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter08](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/41dfc374525657f3c09c3870733ddaccff3c3412).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blazor is a framework designed to build web applications utilizing HTML, CSS,
    and C#. When developing web applications with Blazor in ASP.NET Core, you have
    two options to consider: Blazor Server and Blazor **WebAssembly** (**Wasm**).
    Furthermore, .NET MAUI enables the use of Blazor to create native applications,
    introducing a third variant – the Blazor Hybrid app.'
  prefs: []
  type: TYPE_NORMAL
- en: In web application development, tasks typically involve creating a frontend
    UI and a backend service. Backend services can be accessed through RESTful APIs
    or **remote procedure calls** (**RPCs**). UI components, comprised of HTML, CSS,
    and JavaScript, are loaded in a browser and displayed as web pages. In the ASP.NET
    Core architecture, components related to user interaction can be rendered on the
    server. This hosting model is known as Blazor Server. Alternatively, we can execute
    most of the UI components within the browser, which is referred to as the Blazor
    Wasm hosting model.
  prefs: []
  type: TYPE_NORMAL
- en: In some instances, applications may require access to device-specific features,
    such as sensors or cameras; to accommodate these requirements, developers usually
    create native applications. However, Blazor offers an additional solution – the
    Blazor Hybrid app. Now, let’s discuss Blazor hosting models in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor is a web framework designed for building web UI components, commonly
    referred to as Razor components, which can be hosted through various methods.
    These components can operate on the server side within ASP.NET Core (Blazor Server)
    or client side inside a web browser (Blazor Wasm).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Razor components can be implemented in native mobile and desktop
    applications by rendering them within an embedded Web View control (Blazor Hybrid).
    Despite the differences in hosting models, the process of building Razor components
    remains consistent. Consequently, the same Razor components can be utilized across
    all hosting models without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In traditional web application development, the logic for user interactions
    is executed on the server side. Within the MVC design pattern, handling user interaction
    is an integral part of the application architecture. When a user interaction occurs
    in the browser, it is sent back to the server for processing. As a result, the
    entire page may be reloaded in response to the user’s request.
  prefs: []
  type: TYPE_NORMAL
- en: To enhance performance, Blazor Server employs a design that resembles a **single-page
    application** (**SPA**) framework. When responding to a user request, Blazor Server
    processes it and only sends the **Document Object Model** (**DOM**) changes pertaining
    to the user action to the browser. As depicted in *Figure 8.1*, the processing
    logic in Blazor Server is similar to that of a SPA, with the key distinction being
    that Razor components are rendered on the server, rather than the browser. In
    order to facilitate real-time communication between the web client and the server,
    SignalR, an open source library, is utilized as the connection between the server
    and browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Blazor Server](img/B21554_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Blazor Server'
  prefs: []
  type: TYPE_NORMAL
- en: '**Razor components versus Blazor components**'
  prefs: []
  type: TYPE_NORMAL
- en: People may get confused between Blazor and Razor. Razor was introduced as a
    template engine of ASP.NET in 2010\. Razor syntax is a markup syntax in which
    developers can embed C# code into an HTML page. Blazor is a web framework that
    uses Razor syntax as the programming language. It was introduced around 2018\.
    Blazor is a component-based framework, and a Blazor app consists of Razor components.
    In other words, Blazor is a hosting model for Razor components. Blazor components
    and Razor components are widely used interchangeably, but the correct terminology
    is Razor component.
  prefs: []
  type: TYPE_NORMAL
- en: A Razor component resides in a file with the `.razor` extension, and it is compiled
    as a .NET class at runtime. This `.razor` file can also be split into two files
    with `.razor` and `.razor.cs` extensions. The idea is quite similar to XAML and
    code-behind, which we learned about in *Part 1* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In Blazor Server, the app’s state is maintained on the server, and the client
    does not need a .NET runtime. This model can result in a faster initial load time
    as the browser only downloads a small initial payload. However, it requires a
    constant connection with the server, which may affect the scalability and introduce
    latency in UI updates.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Wasm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blazor Wasm is a hosting model that renders Razor components within a web browser.
    As illustrated in *Figure 8.2*, the Razor components are loaded into the browser
    and compiled into Wasm using the .NET runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Blazor Wasm](img/B21554_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Blazor Wasm'
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, the startup page loads the .NET environment and Razor components.
    These Razor components are compiled to Wasm through a .NET **Intermediate Language**
    (**IL**) interpreter at runtime, which manages DOM changes. This process is commonly
    known as **just-in-time** (**JIT**) compilation. With JIT, the compilation takes
    place at runtime, which results in slower performance compared to **ahead-of-time**
    (**AOT**) compilation. Blazor Wasm apps can be compiled AOT to Wasm to improve
    runtime performance but at the expense of a much larger download size.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of .NET 8, a new runtime feature called jiterpreter was
    introduced in .NET 8 that enables partial JIT support in the .NET IL interpreter
    to achieve improved runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Wasm apps can be deployed as static files and hosted on various web server
    platforms or static site hosting providers. Optionally, Blazor Wasm can also communicate
    with a server through API calls to retrieve data or offload complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wasm**'
  prefs: []
  type: TYPE_NORMAL
- en: Wasm is a binary instruction format for a stack-based virtual machine. Wasm
    is supported by most modern web browsers. With Wasm, we can use many programming
    languages to develop client-side components.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a SPA framework, Blazor can be compared to other JavaScript-based SPA frameworks,
    such as React, Angular, and Vue. Numerous JavaScript SPA frameworks exist, and
    *Table 8.1* contains a comparison between Blazor and React. Although other JavaScript
    frameworks could also be used for comparison, the decision to choose React was
    based on the fact that React Native can be utilized to develop Hybrid apps. This
    shares some similarities with .NET MAUI Blazor, which will be discussed in the
    following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **React** | **Blazor Wasm** | **Blazor Server** |'
  prefs: []
  type: TYPE_TB
- en: '| Language | JavaScript/JSX/TypeScript | C# | C# |'
  prefs: []
  type: TYPE_TB
- en: '| Runtime | JavaScript engine | Wasm | ASP.NET Core |'
  prefs: []
  type: TYPE_TB
- en: '| Progressive Web App (PWA) Support | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Hosting | Flexible to choose | Flexible to choose | ASP.NET Core |'
  prefs: []
  type: TYPE_TB
- en: '| Static Site Hosting | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Offloads Processing to Clients | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Lightweight with great performance | There is a heavier first-time
    load due to the extra download time of .NET runtimes | Similar performance to
    the JavaScript framework |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Comparison of Blazor and React'
  prefs: []
  type: TYPE_NORMAL
- en: Both JavaScript and Wasm are integral features of modern browsers. SPA frameworks
    that utilize either JavaScript or Wasm require no additional dependencies to run
    in a browser. Blazor Wasm supports JavaScript Interop, enabling the use of JavaScript
    components with Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Both Blazor and React support PWA development, which allows SPAs to function
    in offline mode.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Wasm and React both operate on the client side, utilizing **client-side
    rendering** (**CSR**). As a result, relying solely on these libraries for a web
    application could negatively affect **search engine optimization** (**SEO**) and
    the initial loading performance. This is because a considerable amount of time
    is necessary for the proper rendering of the content on the screen. In fact, in
    order to display the complete web app, the browser must download the entire application
    bundle, parse its content, execute it, and then render the result. This process
    could take several seconds for larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Blazor Server employs **server-side rendering** (**SSR**)
    to enhance the performance and user experience of web pages, particularly for
    users with slow internet connections or devices. SSR can decrease the initial
    loading time and bandwidth consumption of web pages by only sending the necessary
    HTML and CSS for the first render, while CSR necessitates downloading and executing
    a significant amount of JavaScript code before anything is rendered. Moreover,
    SSR facilitates faster interactions and transitions between pages, as the server
    can pre-render the upcoming page and transmit it to the browser as soon as the
    user clicks a link.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of SSR is that it can improve the SEO and social media sharing
    of web pages, as the server can provide the full HTML content and metadata of
    each page to crawlers and bots. CSR can make it harder for crawlers and bots to
    access and index the content of web pages, as they may not be able to execute
    JavaScript or wait for asynchronous data fetching.
  prefs: []
  type: TYPE_NORMAL
- en: SSR can also ensure that the content and layout of web pages are consistent
    across different browsers and devices, as the server can handle browser compatibility
    and responsiveness issues.
  prefs: []
  type: TYPE_NORMAL
- en: In recent developments, both Blazor and JavaScript frameworks have transitioned
    to mixed rendering modes to harness the benefits of both CSR and SSR. With the
    introduction of .NET 8, Auto render mode is now available. This mode employs Wasm-based
    rendering when the .NET Wasm runtime can be loaded swiftly (within 100ms). This
    generally occurs when the runtime has already been downloaded and cached, or when
    a high-speed network connection is being used. If these conditions are not satisfied,
    the Auto render mode defaults to Server render mode while simultaneously downloading
    the .NET Wasm runtime in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Hybrid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also utilize Blazor as the UI layer for desktop or mobile native frameworks,
    which are referred to as Blazor Hybrid applications. In such an app, Razor components
    are natively rendered on the device using an integrated WebView control. Wasm
    is not involved, so the application possesses the same capabilities as a native
    app.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.3*, we observe that a Hybrid app allows us to utilize the **BlazorWebView**
    control for constructing and executing Razor components within an embedded WebView.
    The **BlazorWebView** control can be accessed in .NET MAUI and Windows desktop
    environments. By utilizing .NET MAUI and Blazor together, it is possible to use
    one set of web UI components across mobile, desktop, and web platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: BlazorWebView](img/B21554_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: BlazorWebView'
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Hybrid applications can be developed using .NET MAUI, WPF, or Windows
    Forms. This means that it is possible to create a Blazor Hybrid application as
    a WPF, Windows Forms, or .NET MAUI application. In *Part 2*, we will focus solely
    on building a .NET MAUI Blazor Hybrid application.
  prefs: []
  type: TYPE_NORMAL
- en: We have presented three Blazor hosting models. Among these models, both Blazor
    Server and Blazor Hybrid applications offer full support for the .NET API. However,
    Blazor Wasm applications are limited to using a subset of the .NET APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other than the hosting models that we previously introduced. There is a special
    type of Blazor app called Blazor Bindings available. Blazor Bindings or Mobile
    Blazor Bindings is an experimental project from Microsoft aimed at expanding the
    capabilities of Blazor, making it a cross-platform technology not only for creating
    web applications but also, eventually, for mobile development.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is a framework that allows you to build interactive web interfaces using
    C# instead of JavaScript, for both client and server code. It relies on Wasm to
    run the C# code directly in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: With Mobile Blazor Bindings, the developer can write Blazor syntax and components
    but have them rendered as native controls on iOS, macOS, Windows, and Android
    – similar to how .NET MAUI XAML applications operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key components of Mobile Blazor Bindings are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Runtime**: Since .NET 5, we have a common BCL on all support platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor**: Blazor allows running .NET Standard compatible code in the browser
    using Wasm. It also provides a way to define UI components using Razor files (`.razor`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET MAUI**: .NET MAUI is a framework for building native UIs for iOS, macOS,
    Android, and Windows from a single, shared code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BlazorBindings.Maui**: This is the NuGet package published by Oleksandr Liakhevych.
    This package provides the basic Blazor Bindings functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile Blazor Bindings allow developers to use existing Blazor development skills
    for mobile application development, where developers can use Razor syntax with
    C# to build UI components for either Web UI or native UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that, as of January 2024, Mobile Blazor Bindings are
    still in the experimental phase and are not recommended for production applications.
    Microsoft’s original source code repository can be found here: [https://github.com/dotnet/MobileBlazorBindings/](https://github.com/dotnet/MobileBlazorBindings/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the project is in the preview stage and is not under active maintenance.
    However, some updates have been merged from the GitHub repository of Oleksandr
    Liakhevych. Oleksandr Liakhevych is actively developing and maintaining his own
    repository: [https://github.com/Dreamescaper/BlazorBindings.Maui](https://github.com/Dreamescaper/BlazorBindings.Maui).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have applied the Blazor Bindings from Oleksandr Liakhevych in implementing
    the source code for the first and second chapters of the book. The implemented
    code can be found in the designated branches: `BlazorBindings/chapter01` and `BlazorBindings/chapter02`:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition).'
  prefs: []
  type: TYPE_NORMAL
- en: To gain an understanding of Blazor Bindings, let’s compare the code and screenshot
    from the `2nd/chapter01` and `BlazorBindings/chapter01` branches, as exemplified
    in the following code and *Figure 8.4*. The branch `2nd/chapter01` code was created
    from the .NET MAUI project template, whereas the code in the branch `BlazorBindings/chapter01`
    is the equivalent implementation using Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainPage.xaml` (`2nd/chapter01`) – [https://epa.ms/MainPage-CH01](https://epa.ms/MainPage-CH01)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Within `MainPage.xaml`, a `ScrollView` is included. This `ScrollView` contains
    an `Image`, two `Label` instances, and a `Button`, all of which are housed within
    the `VerticalStackLayout` control.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainPage.Razor` (`BlazorBindings/chapter01`) – [https://epa.ms/MainPage-BlazorBindings](https://epa.ms/MainPage-BlazorBindings)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Within `MainPage.razor`, we’ve replicated the same UI but used Razor syntax.
    We’ll delve deeper into the particulars of Razor syntax later in this chapter.
    Meanwhile, we can compare the UIs in *Figure 8.4*. They appear to be identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screens screenshot of a computer  Description automatically generated](img/B21554_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Recreating the main page UI using Razor syntax'
  prefs: []
  type: TYPE_NORMAL
- en: What’s new in .NET 8 Blazor hosting models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous discussion of Blazor hosting models, we touched upon the topic
    of Blazor render modes. Prior to .NET 8, ASP.NET Core supported two render modes:
    SSR and CSR. These render modes were tied to a project type at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: However, .NET 8 introduced a new feature to harness the benefits of both SSR
    and CSR – the Interactive Auto rendering. This new rendering mode initially uses
    a server-side ASP.NET Core for content rendering and interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: It then switches to the .NET Wasm runtime on the client side for subsequent
    rendering and interactivity, after the Blazor bundle is downloaded and the Wasm
    runtime activated. Interactive Auto rendering frequently offers the quickest app
    startup experience.
  prefs: []
  type: TYPE_NORMAL
- en: This constitutes a significant departure from previous ASP.NET Core versions.
    With .NET 8, developers can designate the render modes of individual components
    at both compile time and runtime. Moreover, these render modes can be defined
    at both the component and page levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, in the following example, we apply SSR to the `Dialog`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To designate the render modes at the page level, consult the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the entire page will be rendered server side.
  prefs: []
  type: TYPE_NORMAL
- en: With support for specifying render modes at runtime, the boundary between SSR
    and CSR has become blurry. Developers now have the flexibility to switch render
    modes within a single application.
  prefs: []
  type: TYPE_NORMAL
- en: Before .NET 8, developers could create either a Blazor Server app or a Blazor
    Wasm app using Visual Studio templates. But .NET 8 introduced a new project template
    – the Blazor Web app. We’ll examine these project templates further in the next
    segment.
  prefs: []
  type: TYPE_NORMAL
- en: Project templates of .NET MAUI and Blazor apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor Server, Blazor Wasm, and Blazor Hybrid run in different hosting models
    at runtime, so they have different capabilities. Blazor Web app is the new project
    template introduced in .NET 8\. With this template, we can mix render modes at
    runtime. In this book, our focus is on Blazor Hybrid applications.
  prefs: []
  type: TYPE_NORMAL
- en: We can create different project types using either the command line or Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conserve space, we will examine the project templates using the command
    line only. To list the installed project templates, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding list, we filtered out irrelevant project types. To understand
    the different project types better, we can review the summary depicted in *Table
    8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Template Name/Short Name** | **SDK** | **Target Framework** |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Wasm app (blazorwasm) | Microsoft.NET.Sdk.BlazorWebAssembly | net8.0
    |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Server app (blazorserver) | Microsoft.NET.Sdk.Web | net8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Web app(blazor) | Microsoft.NET.Sdk.WebMicrosoft.NET.Sdk.BlazorWebAssembly
    | net8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI app (maui) | Microsoft.NET.Sdk | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI Blazor app (maui-blazor) | Microsoft.NET.Sdk.Razor | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI Class Library (mauilib) | Microsoft.NET.Sdk | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
  prefs: []
  type: TYPE_TB
- en: '| Razor Class Library (razorclasslib) | Microsoft.NET.Sdk.Razor | net8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Class Library (classlib) | Microsoft.NET.Sdk | net8.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.2: .NET MAUI and Blazor-related project types'
  prefs: []
  type: TYPE_NORMAL
- en: The project types illustrated in *Table 8.2* can be categorized into two groups
    – Blazor apps and .NET MAUI apps. Let’s examine these groups in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In both Blazor Server and Blazor Wasm templates, the target framework is net8.0,
    but they utilize different SDKs. The Blazor Server application can fully leverage
    the server’s capabilities using `Microsoft.NET.Sdk.Web`, while Blazor Wasm has
    access to only a limited set of .NET APIs via `Microsoft.NET.Sdk.BlazorWebAssembly`.
    In the template of Blazor Web app, it mixes both Blazor Server and Blazor Wasm.
  prefs: []
  type: TYPE_NORMAL
- en: To share Razor components between Blazor Server and Blazor Wasm, a Razor Class
    Library may be employed. This library employs `Microsoft.NET.Sdk.Razor`. Additionally,
    the standard .NET class library, which can be shared across all .NET 8.0 applications,
    utilizes `Microsoft.NET.Sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a .NET MAUI application, one can create XAML-based .NET MAUI apps utilizing
    the `Microsoft.NET.Sdk`, while for .NET MAUI Blazor apps, the `Microsoft.NET.Sdk.Razor`
    is employed. Both project types cater to the same collection of target frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to share components, the standard .NET class library can be utilized.
    If it is necessary to incorporate .NET MAUI features within the shared components,
    the .NET MAUI class library may be employed. For instance, `PassXYZLib` is a .NET
    MAUI class library. Although both the .NET class library and the .NET MAUI class
    library utilize the same `Microsoft.NET.Sdk`, they target distinct frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new .NET MAUI Blazor project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn how to develop a Blazor Hybrid app, we need to upgrade our `PassXYZ.Vault`
    project to accommodate a Blazor-based UI. Fortunately, we don’t need to start
    from scratch – we can simply modify our existing project to support the Blazor
    UI. By doing this, we can efficiently build both an XAML-based app and a Hybrid
    app within the same project. Before incorporating the Blazor UI into our app,
    let’s first establish a new .NET MAUI Blazor project with an identical app name.
    This will allow us to reference the new project when converting our current project
    into a .NET MAUI Blazor project.
  prefs: []
  type: TYPE_NORMAL
- en: We have the option to create this new .NET MAUI Blazor project either through
    the command line or via Visual Studio. We will demonstrate both methods in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a .NET MAUI Blazor project with the dotnet command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us begin by creating a new project using the .NET command line. This can
    be accomplished on both Windows and macOS platforms. To create a new project,
    we will utilize the short name `maui-blazor`, as mentioned in *Table 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, we selected the project template by specifying the
    short name, `maui-blazor`, and designated `PassXYZ.Vault` as the project name.
    After creating the project, it can be built and executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `build` command, we designate `net8.0-android` as the target framework
    for testing our new app. We can replace the target framework with other supported
    frameworks such as `net8.0-ios`, `net8.0-maccatalyst`, or `net8.0-windows10.0.19041.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to *Figure 8.6* to view a screenshot of this new app and its project structure.
    With this, we have successfully created a new project using the command line.
    Now, let’s explore how to accomplish the same task using Visual Studio on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET MAUI Blazor Hybrid App using Visual Studio on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a .NET MAUI Blazor Hybrid App project using Visual Studio, begin
    by launching Visual Studio and selecting `Create a new project`, and then in the
    search box, type `MAUI` to filter the available options. As shown in *Figure 8.5*,
    choose `.NET MAUI Blazor Hybrid App` from the list of project templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21554_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Creating a new .NET MAUI Blazor Hybrid App project'
  prefs: []
  type: TYPE_NORMAL
- en: After completing the project creation using the wizard, we can choose `net8.0-android`
    as the target framework for building and running the project. To conserve space,
    the Android platform will be used as our primary example in this section; however,
    you are welcome to explore and test other target frameworks if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Running the new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the project, press *F5* or *Ctrl* + *F5* in Visual Studio, or use
    the `dotnet` command from the command line. Refer to *Figure 8.6* for screenshots
    illustrating this process and the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Screenshots and project structure](img/B21554_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Screenshots and project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI of the app, created using the template, resembles a SPA with a navigation
    menu at the top for Android devices. When executed on Windows with a larger screen,
    the navigation menu displays on the left side of the screen in a side-by-side
    manner. The project structure closely mirrors that of a standard .NET MAUI app
    but with the following notable differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wwwroot/`: This folder is the root of static files for web pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pages/`: This folder contains Razor pages in the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shared/`: This folder contains Razor components that can be shared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Main.razor`: This is the main page of the Blazor app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_Imports.razor`: This is a helper to import Razor components at the folder
    or project level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the difference between the .`NET MAUI` app and the `.NET MAUI
    Blazor` app, it is helpful to analyze their respective startup code.
  prefs: []
  type: TYPE_NORMAL
- en: The startup code of the .NET MAUI Blazor Hybrid App
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All .NET MAUI apps contain a file named `MauiProgram.cs`, which handles their
    startup and configuration. Let’s examine the startup code of the .NET MAUI Blazor
    Hybrid App:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the .NET MAUI Blazor Hybrid App, we can see that the following Blazor configurations
    have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** `BlazorWebView` is added by calling `AddMauiBlazorWebView()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** Developer tools are added by calling `AddBlazorWebViewDeveloperTools()`
    for debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the startup process is the same as that for an XAML-based .NET
    MAUI app. In the `App.xaml.cs` file, the `MainPage` property, which is inherited
    from the `App` class, is assigned to an instance of `MainPage.xaml` as we can
    see in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary distinction between XAML-based applications and Blazor Hybrid applications
    lies in the UI controls used within `MainPage.xaml`. Let’s examine the code of
    `MainPage.xaml` closely to better understand this difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `MainPage.xaml`, only one UI element named `BlazorWebView` is defined.
    With the `HostPage` property and the nested node `RootComponent`, it is possible
    to customize the `BlazorWebView` efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: We can consider `BlazorWebView` to be similar to a browser. In a browser, the
    UI is typically loaded from an HTML file. The `HostPage` property **(1)** serves
    to indicate the static HTML page that should load within the web view control.
    In our specific case, this refers to `wwwroot/index.xhtml`, which we will examine
    in *Listing 8.1*.
  prefs: []
  type: TYPE_NORMAL
- en: In this static HTML file, we must designate the location for the Razor component
    and determine the root component. Both can be specified using the attributes of
    the nested node `RootComponent` **(2)**.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered that an XAML tag ultimately maps to a
    C# class. In this context, both `BlazorWebView` and `RootComponent` are also C#
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the `RootComponent`, we utilize the `Selector` attribute **(3)** to define
    a CSS selector that determines the placement of the root Razor component within
    our application. In our specific instance, we use the `#app` CSS selector defined
    in the `index.xhtml` file. The `ComponentType` attribute **(4)** establishes the
    type of the root component, which in our case is `Main`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s revisit the HTML file (`index.xhtml`) that was mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.1: `index.xhtml` ([https://epa.ms/index8-1](https://epa.ms/index8-1))'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that `index.xhtml` is a simple HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** It uses the CSS stylesheet from the Bootstrap framework.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** The `id` selector is specified as `app`, which is then passed to the
    `Selector` attribute of the `RootComponent` within the `MainPage.xaml` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** A JavaScript file called `blazor.webview.js` is loaded at the end of
    `index.xhtml`. This is responsible for initializing the runtime environment for
    `BlazorWebView`.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have provided an overview of the .NET MAUI Blazor Hybrid app.
    In the following section, we will substitute the XAML-based UI with one that utilizes
    Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to a .NET MAUI Blazor Hybrid App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a new Hybrid app, which will serve as a
    reference for migrating our existing application. Instead of starting from scratch,
    we can take advantage of both the XAML and Blazor UIs within our current app by
    adjusting the project configuration. For now, we will implement a combination
    of XAML and Blazor UIs in a single application and, later on, transition entirely
    to Blazor in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To convert our app into a .NET MAUI Blazor Hybrid app, it is necessary to implement
    the following modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Change the SDK in the project file by replacing `Microsoft.NET.Sdk` with `Microsoft.NET.Sdk.Razor`,
    as the .NET MAUI Blazor Hybrid app relies on a different SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PassXYZ.Vault.csproj` project file, the following line is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line needs to be replaced with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transfer the subsequent folders from the newly established project into our
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wwwroot`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shared`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transfer the subsequent files from the new project to our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_Imports.razor`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPage.xaml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPage.xaml.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Main.razor`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Revise `MauiProgram.cs` by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To review the commit history of these changes, go to [https://epa.ms/Blazor7-1](https://epa.ms/Blazor7-1).
  prefs: []
  type: TYPE_NORMAL
- en: With these adjustments, we have implemented all the necessary modifications
    to the configuration and can now proceed to the subsequent step. Nonetheless,
    before we delve into working on these changes, let us first acquaint ourselves
    with the fundamental Razor syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor applications are composed of Razor components. As discussed in *Chapter
    3*, *User Interface Design with XAML*, XAML is a language that has its roots in
    XML. UI elements based on XAML consist of XAML pages and their corresponding C#
    code-behind files. Razor components closely resemble this pattern, with the primary
    difference being that Razor employs HTML as its markup language and C# code can
    be directly embedded within the HTML. Alternatively, we can opt to separate the
    C# code into a code-behind file, thus maintaining a clear distinction between
    the UI and its underlying logic.
  prefs: []
  type: TYPE_NORMAL
- en: Code blocks in Razor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the simplest Razor component, it would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we can design our page similarly to an HTML page while
    incorporating programming logic within a code block. Razor pages or Razor components
    are generated as C# classes, with the filename serving as the class name. The
    newly created Razor components can be utilized as HTML tags in another Razor page.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Razor expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Razor syntax, we can transition from HTML to C# using the `@` symbol. These
    are referred to as implicit Razor expressions. For instance, we can use the following
    implicit expression to set the text of the `label` tag with the C# variable `currentUser.Username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There should be no spaces between implicit expressions. Using C# generics in
    implicit expressions is not possible, as the characters within the angle brackets
    (`<>`) are interpreted as an HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Razor expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to address the challenges posed by implicit expressions (e.g., white
    space or utilizing generics), we can employ explicit Razor expressions. These
    explicit expressions are composed of an `@` symbol followed by parentheses. A
    generic method can be invoked as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we intend to concatenate text with an expression, it is necessary to employ
    explicit expressions, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In more complex scenarios, we can utilize explicit Razor expressions, like passing
    a lambda expression to an event handler. Let’s examine another instance of employing
    an explicit Razor expression when embedding HTML within C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Expression encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, we might need to incorporate HTML as a string within our C# code;
    however, the outcome could be different from what we anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we write the following C# expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this after rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To preserve the HTML string, it is necessary to utilize the `MarkupString`
    keyword, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding C# expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the desired output. We will delve deeper into explicit Razor expressions
    as we progress with the creation of Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to HTML code and C# code blocks, there are reserved keywords designed
    for use as Razor directives. These Razor directives are denoted by implicit expressions
    that follow the `@` symbol and contain specific reserved keywords. In the previous
    section, we encountered the code block represented as `@code`. In this instance,
    `@code` serves as a directive, containing the reserved keyword `code`. Throughout
    this book, we will be using the following directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@attribute`: This is used to add the given attribute to the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@code`: This is used to define a code block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@implements`: This is used to implement an interface for the generated class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@inherits`: This is used to specify the parent class for the generated class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@inject`: This is used to inject a service using dependency injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@layout`: This is used to specify a layout for routable Razor components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@namespace`: This is used to define the namespace for the generated class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@page`: This is used to define a route for the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@using`: This is similar to the `using` keyword in C#, which imports a namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directive attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a Razor page, HTML tags can act as classes, and attributes can serve as
    members of the class. Let’s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `input` is an HTML tag, which is a class. The attribute `type` serves
    as a property of the `input` tag and its value is `text`, which indicates the
    type of this `input` tag. You might have noticed another attribute, `@bind`, which
    appears somewhat different from regular attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like a Razor implicit expression. In fact, it is an implicit expression,
    with `bind` being a reserved keyword. This attribute functions as a directive
    attribute. The distinction between a Razor directive and a Razor directive attribute
    lies in the fact that the latter acts as an attribute for an HTML tag. Throughout
    this book, we will be using the following directive attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@bind`: This is used in data binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@on{EVENT}`: This is used in event handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@on{EVENT}:preventDefault`: This is used to prevent the default action for
    the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@on{EVENT}:stopPropagation`: This is used to stop event propagation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ref`: This is used to provide a way to reference a component instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@typeparam`: This is used to declare a generic type parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having familiarized ourselves with the fundamental syntax of the Razor markup
    language, it is time to put it into practice by developing a Razor component within
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Razor component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In developing a .NET MAUI Blazor Hybrid application, we have the option to either
    construct the entire UI utilizing Blazor or combine Razor components with XAML
    components. We will initially explore the second option, as we have already completed
    a password manager application in the first part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Redesigning the login page using a Razor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first UI we aim to replace is the login page. We can accomplish this by
    utilizing a Razor page instead of the XAML page, thereby maintaining the same
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Blazor Hybrid application, the `BlazorWebView` serves as the control that
    hosts Razor components. We can modify `LoginPage.xaml` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On the previous page, there is only a `BlazorWebView` control. We should focus
    on the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `HostPage` attribute is utilized to indicate the HTML page that
    should be loaded in `BlazorWebView`. In this instance, `login.xhtml` (as shown
    in *Listing 8.2*) is the specified page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attributes of `RootComponent` specify the Razor component and CSS selector
    to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** The `ComponentType` attribute indicates the Razor `Login` component,
    which we will be discussing in detail shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** The `Selector` attribute indicates the CSS selector where our web UI
    will be loaded. We have defined the CSS `#login-app` ID in `login.xhtml`. This
    `login.xhtml` HTML page is created and saved in the `wwwroot` folder. Let’s take
    a look at it in *Listing 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.2: `login.xhtml` ([https://epa.ms/Login8-2](https://epa.ms/Login8-2))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 8.2*, we observe that it closely resembles `index.xhtml`, which
    we have examined earlier. The CSS ID `"``login-app"` **(1)** is defined here,
    serving the purpose of loading our Razor component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the .NET MAUI Blazor Hybrid app template, the default CSS framework is Bootstrap
    (`bootstrap.min.css`). At the time of writing, the embedded Bootstrap version
    was 5.1\. However, you might find a newer version in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap is a renowned framework for web development, which provides numerous
    examples of its usage. For instance, there is a sign-in example available on the
    Bootstrap website for creating a login page, as illustrated in *Figure 8.7*. We
    will utilize this example to construct our `Login` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Bootstrap sign-in example](img/B21554_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Bootstrap sign-in example'
  prefs: []
  type: TYPE_NORMAL
- en: You can find this sign-in example at [https://getbootstrap.com/docs/5.1/examples/sign-in/](https://getbootstrap.com/docs/5.1/examples/sign-in/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This sign-in example includes two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.xhtml` (*Listing 8.3*) is the UI of the sign-in page. It defines the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Two `<input>` tags for the username **(1)** and password **(2)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `<input>` tag **(3)** for a checkbox to remember the username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `<button>` tag **(4)** to process the login activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses Bootstrap CSS styles and its own styles defined in `signin.css`.
  prefs: []
  type: TYPE_NORMAL
- en: '`signin.css` (*Listing 8.4*) defines the CSS styles specific to the sign-in
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.3: `index.xhtml` (Bootstrap sign-in example)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `signin.css` (*Listing 8.4*), we modify the `form-signin` CSS class, which
    is used in the sign-in section of `index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.4: `signin.css` (Bootstrap sign-in example)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new Razor component, first, a folder named `Pages` needs to be
    created within the project. Next, right-click on the newly created `Pages` folder
    in Visual Studio and select **Add** | **Razor Component**…. Name this component
    `Login.razor` and proceed to create the file. Once created, copy the part between
    the `<main>` tag from *Listing 8.3* and paste it into the Razor page within a
    `<div>` tag, as demonstrated in *Listing 8.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.5: `Login.razor`'
  prefs: []
  type: TYPE_NORMAL
- en: We employ the directive inject to instantiate `LoginViewModel` as the `viewModel`
    variable **(1)**, and `LoginService` as the `currentUser` variable **(2)**. This
    enables us to reference the `Username` **(3)** and `Password` **(4)** properties
    of `currentUser` in the HTML via the `@` symbol. Similarly, we can define the
    `OnLogin` event handler and associate it with the `onclick` event.
  prefs: []
  type: TYPE_NORMAL
- en: Upon entering their username and password, the `currentUser` properties are
    populated accordingly. When the login button is clicked, the `OnLogin` function
    is triggered. Consequently, the view model’s `LoginCommand` is executed to initiate
    the login process.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-ViewModel (MVVM) pattern in Blazor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the benefits of utilizing Blazor for UI design is that it allows us to
    create most of the UI using HTML initially. After ensuring the UI design meets
    our expectations, we can then implement the programming logic. By employing the
    MVVM pattern, which we explored in *Chapter 3*, *User Interface Design with XAML*,
    we can effectively separate responsibilities within the Razor component development.
    For a Razor component, we can consider the HTML markup as the view and the code
    block as the ViewModel. Should the logic in the code block become overly complex,
    we have the option to separate it into a C# code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: On the login page, we may proceed with utilizing the `LoginViewModel` from the
    XAML domain. This is made possible by the transition from Blazor to the XAML UI
    occurring within `LoginViewModel`. The primary objective is to demonstrate the
    seamless integration of Blazor and XAML UIs within a single application. In the
    subsequent chapter, we will completely replace the XAML UI with the Blazor UI.
  prefs: []
  type: TYPE_NORMAL
- en: In a Razor component, it is possible to incorporate both HTML and C# within
    a single file or divide them between a Razor file and a C# code-behind file, similar
    to XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply this concept to `Login.razor`. By splitting it into two files,
    the component will be divided into two partial classes found in `Login.razor`
    and `Login.razor.cs`, as demonstrated in *Listing 8.6* and *Listing 8.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.6: `Login.razor` ([https://epa.ms/Login8-6](https://epa.ms/Login8-6))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 8.6*, the HTML markup is solely present in `Login.razor`, which
    effectively separates the UI from the underlying logic, resulting in a cleaner
    design. Now, let’s examine the corresponding C# code in *Listing 8.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8.7*: `Login.razor.cs` ([https://epa.ms/Login8-7](https://epa.ms/Login8-7))'
  prefs: []
  type: TYPE_NORMAL
- en: In *Listing 8.7*, we have transferred all the code from the `@code` block to
    the C# file within the `Login` class, which inherits from the `ComponentBase`
    class. All Razor components inherit from `ComponentBase`.
  prefs: []
  type: TYPE_NORMAL
- en: You might have observed the usage of the `Inject` attribute in the declaration
    of the `viewModel` and `currentUser` properties. These properties are initialized
    using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in Blazor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 6*, *Software Design with Dependency Injection*, we introduced how
    to use dependency injection in .NET MAUI development. All the concepts presented
    in that chapter are equally applicable here; however, Blazor offers additional
    features. With Blazor, we can utilize dependency injection in both HTML and C#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As demonstrated in *Listing 8.5*, the following declaration is defined at the
    beginning of the `Login.razor` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we initialize the `viewModel` property through dependency
    injection. This approach employs property injection using the Razor directive,
    which has become more straightforward to use in Blazor than in previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we move it to the C# code-behind file, we can use the `Inject` attribute
    to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In web development, we frequently utilize HTML and CSS in conjunction to design
    UIs for websites. In the Bootstrap example, a `signin.css` file is present. Now,
    where should we store our CSS styles? We will explore this topic in the subsequent
    section.
  prefs: []
  type: TYPE_NORMAL
- en: CSS isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the earlier discussion of the Bootstrap sign-in example, we mentioned the
    presence of an HTML file and a CSS file. Now, the question arises – where should
    the CSS file be placed in order to effectively reuse the sign-in CSS styles on
    our login page?
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTML design, using a CSS framework like Bootstrap may require customization
    of styles at the page level. To facilitate this in Blazor, a technique called
    CSS isolation for Razor components is employed. For CSS styles specific to a component
    or page, we can store them in a file with the `.razor.css` extension. The filename
    should correspond to the `.razor` file in the same folder. For instance, on our
    login page, we can copy the `sign-in.css` file from the Bootstrap example to `Login.razor.css`,
    making minor adjustments as demonstrated in *Listing 8.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8.8: `Login.razor.css` ([https://epa.ms/Login8-8](https://epa.ms/Login8-8))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The styles defined in `Login.razor.css` are only applied to the rendered output
    of the `Login` component. Finally, let’s look at this new login UI in Blazor:'
  prefs: []
  type: TYPE_NORMAL
- en: s![A screenshot of a phone  Description automatically generated](img/B21554_08_08.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Sign in page'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.8*, from left to right, we can see the login page on Windows, iOS,
    and Android. We observe that the look and feel of this new UI closely resemble
    the Bootstrap sign-in example, with the exception of a modified icon. The login
    functionality remains unchanged; however, we employed Blazor to develop a new
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: As the Blazor UI is constructed using web technologies, the appearance and user
    experience are consistent across different platforms. For instance, in the Android
    screenshot, you can see an overlap of the input fields with the placeholders upon
    entering the username and password. This behavior aligns with what you would encounter
    on all three platforms. Though this issue isn’t present on the desktop browser,
    BlazorWebView’s behavior does present some discrepancies compared with traditional
    desktop browsers. Therefore, while the Blazor UI maintains consistency across
    various platforms, it may behave differently when accessed through different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Upon logging in using this Razor page, the subsequent programming logic continues
    to align with what was demonstrated in *Chapter 6*, *Software Design with Dependency
    Injection*. After the login process, the UI framework reverts to XAML as no other
    modifications have been made thus far.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter illustrates the potential to combine a Blazor UI and
    XAML-based UI within a single application. However, it is advisable to avoid this
    approach unless there are no other alternatives available. As depicted in *Figure
    8.8*, Blazor and XAML UIs employ different technologies, which can present unique
    challenges during development. By mixing them, we essentially inherit the issues
    from both types of UI. This could introduce unforeseen complications in the design
    and development process of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored Blazor and how to develop a Blazor Hybrid app.
    Blazor serves as an alternative solution for UI design within .NET MAUI. The primary
    distinction between Blazor and XAML lies in their appearance: while the XAML UI
    closely resembles the native interface, the Blazor UI adopts the aesthetics of
    a web app. Functionality-wise, both offer similar capabilities. Moreover, it is
    possible to integrate Blazor and XAML within a single app and utilize the MVVM
    pattern in both.'
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of using Blazor is the ability to share UI code between the Blazor
    Hybrid app and a web app. If you seek a solution compatible with both native and
    web apps, .NET MAUI Blazor could be an ideal choice.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will transition to using Blazor for all UIs within
    our app. Additionally, we will discuss the initial UI design using layout and
    routing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core updates in .NET 8 Preview 2: [https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASP.NET Core updates in .NET 8 Preview 7: [https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What’s new in ASP.NET Core 8.0: [https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASP.NET Core Blazor hosting models: [https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASP.NET Core Blazor render modes: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
