<html><head></head><body>
        

                            
                    <h1 class="header-title">Powerful Data Processing</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Composing and consuming collections the easy way</li>
<li>Filtering datasets</li>
<li>Automatic <kbd>null</kbd> removal</li>
<li>Sorting data with custom comparators</li>
<li>Building strings based on dataset elements</li>
<li>Dividing data into subsets</li>
<li>Transforming data with  <kbd>map</kbd> and <kbd>flatMap</kbd></li>
<li>Folding and reducing datasets</li>
<li>Grouping data</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p class="p1">This chapter focuses on exploring standard library support for declarative-style operations on collections. The following recipes present solutions to different types of programming problems related to dataset transformations, reductions, and grouping. We will learn how to approach data processing operations with a functional programming style, together with the powerful data-processing extensions built into the standard library.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Composing and consuming collections the easy way</h1>
                
            
            
                
<p>The Kotlin standard library provides a number of handy extensions that make collections creation and merging easy and safe. We are going to learn them step by step. Let's assume we have the following <kbd>Message</kbd> class defined:</p>
<pre>data class Message(val text: String, <br/>                   val sender: String, <br/>                   val timestamp: Instant = Instant.now())</pre>
<p>In this recipe, we are going to create two sample collections containing <kbd>Message</kbd> instances and merge them into one list of <kbd>Message</kbd> objects. Next, we are going to iterate through the list of messages and print their text to the console. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Kotlin standard library provides two basic interfaces which represent collection data structure—<kbd>Collection</kbd> and <kbd>MutableCollection</kbd>, both extending the <kbd>Iterable</kbd> interface. The first one defines an immutable collection that only supports read access to its elements. The second interface allows us to both add and remove elements. There are also more specialized interfaces that extend the <kbd>Collection</kbd> and <kbd>MutableCollection</kbd> base types, such as <kbd>List</kbd>, <kbd>MutableList</kbd>, <kbd>Set</kbd>, and <kbd>MutableSet</kbd>.</p>
<p>There are many functions available for creating collections of different types. The most commonly used ones are the <kbd>&lt;T&gt; listOf(vararg elements: T)</kbd> function, which instantiates a <kbd>List</kbd> instance, and <kbd>&lt;T&gt; mutableListOf(vararg elements: T)</kbd>, which returns an instance of <kbd>MutableList</kbd> for the elements given as a function's arguments. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's declare two lists containing sample data:</li>
</ol>
<pre style="padding-left: 60px">val sentMessages = listOf (<br/>    Message("Hi Agat, any plans for the evening?", "Samuel"),<br/>    Message("Great, I'll take some wine too", "Samuel")<br/>)<br/>val inboxMessages = mutableListOf(<br/>        Message("Let's go out of town and watch the stars tonight!",<br/>         "Agat"),<br/>        Message("Excelent!", "Agat")<br/>)</pre>
<ol start="2">
<li>Merge <kbd>sentMessages</kbd> and <kbd>inboxMessages</kbd> into one collection:</li>
</ol>
<pre style="padding-left: 60px">val allMessages: List&lt;Message&gt; = sentMessages + inboxMessages</pre>
<ol start="3">
<li>Print out the text of the <kbd>Message</kbd> objects stored in the <kbd>allMessages</kbd> list to the console:</li>
</ol>
<pre style="padding-left: 60px">val allMessages: List&lt;Message&gt; = sentMessages + inboxMessages<br/>allMessages.forEach { (text, _) -&gt;<br/>    println(text)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As the result, our code is going to print the following text to the console:</p>
<pre><strong>Hi Agat, any plans for the evening?</strong><br/><strong>Great, I'll take some wine too</strong><br/><strong>Let's go out of town and watch the stars tonight!</strong><br/><strong>Excelent!</strong></pre>
<p>In order to add elements of one collection to another, we are using the <kbd>+</kbd> operator. The standard library overloads this operator with the code responsible for merging elements of two <kbd>Collection</kbd> type instances collections into one instance. The <kbd>sentMessages</kbd> and <kbd>inboxMessages</kbd> variables are declared as <kbd>List</kbd> instances. The <kbd>plus</kbd> function returns a new <kbd>Collection</kbd> instance, containing elements of the <kbd>sentMessages</kbd> and <kbd>inboxMessages</kbd> lists. Finally, we use the <kbd>forEach()</kbd> function to iterate through the next elements of the list. In the lambda block passed to the <kbd>forEach</kbd> function, we are print the <kbd>text</kbd> property of the current <kbd>Message</kbd> to the console. We are destructuring the lambda's argument of the <kbd>Message</kbd> type and accessing its text property directly inside the <kbd>println()</kbd> function. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The standard library also overloads a <kbd>-</kbd> operator for the Collection type. We could use it to subtract some elements from the collection. For example, we could use it like this:</p>
<pre>val receivedMessages = allMessages - sentMessages<br/>receivedMessages.forEach { (text, _) -&gt;<br/>    println(text)<br/>}</pre>
<p>And we would get the following output:</p>
<pre><strong>Let's go out of town and watch the stars tonight!</strong><br/><strong>Excelent!</strong></pre>
<p>We could also use the standard <kbd>for</kbd> loop to implement the iteration:</p>
<pre>for (msg in allMessages) {<br/>    println(msg.text)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can learn more about destructuring declarations in the <em>Destructuring types</em> recipe in <a href="b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml" target="_blank">Chapter 2</a>, <em>Expressive Functions and Adjustable Interfaces</em></li>
<li>If you'd like to master lambda expressions, you can take a look at the <em>Working effectively with lambdas and closures </em>recipe from <a href="28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml" target="_blank">Chapter 3</a>, <em>Shaping Code with Kotlin Functional Programming Features</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Filtering datasets</h1>
                
            
            
                
<p>Filtering is one of the most common programming challenges in the data processing field. In this recipe, we are going to explore the standard library's built-in extension functions that provide an easy way to filter the <kbd>Iterable</kbd> data types. Let's assume we have the following <kbd>Message</kbd> class declaration:</p>
<pre>data class Message(val text: String,<br/>                   val sender: String,<br/>                   val receiver: String,<br/>                   val folder: Folder = Folder.INBOX,<br/>                   val timestamp: Instant = Instant.now())<br/><br/>enum class Folder { INBOX, SENT }</pre>
<p>The <kbd>getMessages()</kbd> function returns the following data:</p>
<pre>fun getMessages() = mutableListOf(<br/>        Message("Je t'aime", "Agat", "Sam", Folder.INBOX),<br/>        Message("Hey, Let's go climbing tomorrow", "Stefan", "Sam", Folder.INBOX),<br/>        Message("&lt;3", "Sam", "Agat", Folder.SENT),<br/>        Message("Yeah!", "Sam", "Stefan", Folder.SENT)<br/>)</pre>
<p>We are going to apply a filtering operation to the <kbd>getMessages()</kbd> function that will return only the messages with the <kbd>Folder.INBOX</kbd> property and with the <kbd>sender</kbd> property equal to <kbd>Agat</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To implement the filtering transformation, we are going to use the <kbd>Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean)</kbd> extension function provided by the standard library. The <kbd>filter()</kbd> function takes a predicate function that returns <kbd>true</kbd> or <kbd>false</kbd> values for the given element of the generic <kbd>Iterable</kbd> dataset type <kbd>T</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Apply filtering to the <kbd>getMessages()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">getMessages().filter { it.folder == Folder.INBOX &amp;&amp; it.sender == "Agat" }</pre>
<ol start="2">
<li>Iterate through the filtered messages and print their messages to the console:</li>
</ol>
<pre style="padding-left: 60px">getMessages().filter { it.folder == Folder.INBOX &amp;&amp; it.sender == "Agat" }<br/> <strong>.forEach { (text) -&gt;<br/>     println(text)</strong><br/><strong> }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are applying the <kbd>filter</kbd> function to the results of the <kbd>ge</kbd><kbd>tMessages()</kbd> function. We pass a lambda block to the <kbd>filter</kbd> function, which returns a Boolean for each of the list's elements. The <kbd>filter</kbd> function returns a list containing filtered objects. Finally, we use the <kbd>forEach()</kbd> function to iterate through the next elements of the list. In the lambda block passed to the <kbd>forEach</kbd> function, we print the <kbd>text</kbd> property of the current <kbd>Message</kbd> to the console.</p>
<p class="mce-root"/>
<p>As a result, the code from the preceding section is going to print the following output to the console:</p>
<pre><strong>Je t'aime</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The Kotlin standard library offers corresponding <kbd>filter()</kbd> extension functions for other types, such as <kbd>Array</kbd>, <kbd>Sequence</kbd>, and <kbd>Map</kbd>. There are also many variations of the filter function that can be useful for specific scenarios. You can find all of them in the official documentation of the Kotlin standard library <kbd>kotlin.collections</kbd> package at <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html">http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to master lambda expressions, you can take a look at the <em>Working effectively with lambdas and closures</em> recipe from <a href="28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml" target="_blank">Chapter 3</a>, <em>Shaping Code with Kotlin Functional Programming Features</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Automatic null removal</h1>
                
            
            
                
<p>While working with poorly designed APIs of servers or external libraries, we often need to deal with receiving null return values. Thankfully, there are a number of standard library features that allow us to handle null values effectively. In this recipe, we are going to implement a data preprocessing operation which will remove all the nulls from the dataset automatically. Let's say we are working with an external API that provides us with the latest news feed. Unfortunately, it's not null-safe and can return random null values. For example, let's assume we have a <kbd>getNews(): List&lt;News&gt;</kbd> function that returns the following data:</p>
<pre>fun getNews() = listOf(<br/> News("Kotlin 1.2.40 is out!", "https://blog.jetbrains.com/kotlin/"),<br/> News("Google launches Android KTX Kotlin extensions for developers",<br/> "https://android-developers.googleblog.com/"),<br/> null,<br/> null,<br/> News("How to Pick a Career", "waitbutwhy.com")<br/>)</pre>
<p class="mce-root"/>
<p>The <kbd>News</kbd> class is defined as follows:</p>
<pre>data class News(val title: String, val url: String)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Apply the <kbd>filterNotNull</kbd> function to the <kbd>getNews()</kbd> function:</p>
<pre>getNews()<br/>        .filterNotNull()<br/>        .forEachIndexed { index, news -&gt;<br/>            println("$index. $news")<br/>        }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As a result, we are going to get the following output printed to the console:</p>
<pre><strong>0. News(title=Kotlin 1.2.40 is out!, url=https://blog.jetbrains.com/kotlin/)</strong><br/><strong>1. News(title=Google launches Android KTX Kotlin extensions for developers, url=https://android-developers.googleblog.com/)</strong><br/><strong>2. News(title=How to Pick a Career, url=waitbutwhy.com)</strong></pre>
<p>In contrast, the code without the <kbd>filterNotNull()</kbd> function is as follows:</p>
<pre>getNews().forEachIndexed { index, news -&gt;<br/>    println("$index. ${news.toString()}")<br/>}</pre>
<p>This will print the following output to the console:</p>
<pre><strong>0. News(title=Kotlin 1.2.40 is out!, url=https://blog.jetbrains.com/kotlin/)</strong><br/><strong>1. News(title=Google launches Android KTX Kotlin extensions for developers, url=https://android-developers.googleblog.com/)</strong><br/><strong>2. null</strong><br/><strong>3. null</strong><br/><strong>4. News(title=How to Pick a Career, url=waitbutwhy.com)</strong></pre>
<p>The <kbd>Iterable.filterNotNull()</kbd> extension function removes all the null values from the original dataset. Under the hood, it copies non-null values to a newly created <kbd>List</kbd> instance. That's why it is more efficient to use sequences instead of collections in order to provide lazy evaluation for large datasets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>In the <em>Filtering data sets</em> recipe<em>, </em>we explored how to use the basic <kbd>filter()</kbd> function form provided by the standard library</li>
<li> If you'd like to master lambda expressions, you can take a look at the <em>Working effectively with lambdas and closures</em> recipe from <a href="28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml" target="_blank">Chapter 3</a>, <em>Shaping Code with Kotlin Functional Programming Features</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Sorting data with custom comparators</h1>
                
            
            
                
<p>In this recipe, we are going to explore the support for sorting collections' elements by their properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>Let's assume we are dealing with the two collections of the <kbd>Message</kbd> type declared as follows:</p>
<pre>data class Message(val text: String,<br/>                   val sender: String,<br/>                   val receiver: String,<br/>                   val time: Instant = Instant.now())</pre>
<p>These are provided by the <kbd>allMessages</kbd> variable:</p>
<pre>val sentMessages = listOf(<br/>        Message("I'm programming in Kotlin, of course", <br/>                "Samuel", <br/>                "Agat", <br/>                Instant.parse("2018-12-18T10:13:35Z")),<br/>        Message("Sure!", <br/>                "Samuel", <br/>                "Agat", <br/>                Instant.parse("2018-12-18T10:15:35Z"))<br/>)<br/>val inboxMessages = mutableListOf(<br/>        Message("Hey Sam, any plans for the evening?", <br/>                "Samuel", <br/>                "Agat", <br/>                Instant.parse("2018-12-18T10:12:35Z")),<br/>        Message("That's cool, can I join you?", <br/>                "Samuel", <br/>                "Agat",<br/>                Instant.parse("2018-12-18T10:14:35Z"))<br/>)<br/><strong>val allMessages = sentMessages + inboxMessages</strong></pre>
<p>If we print the text of consecutive messages from the <kbd>allMessages</kbd> list, we get the following text printed to the console:</p>
<pre><strong>I'm learning Kotlin, of course</strong><br/><strong>Sure!</strong><br/><strong>Hey Sam, any plans for the evening?</strong><br/><strong>That's cool, can I join you?</strong></pre>
<p>That doesn't look right. The messages should be displayed in chronological order. That means they should be sorted by the <kbd>time</kbd> property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Apply the <kbd>sortedBy</kbd> function to the <kbd>allMessages</kbd> collection:</li>
</ol>
<pre style="padding-left: 60px">allMessages.sortedBy { it.time }</pre>
<ol start="2">
<li>Print the sorted elements to the console:</li>
</ol>
<pre style="padding-left: 60px">allMessages.sortedBy { it.time }<br/>        <strong>.forEach {<br/>            println(it.text)</strong><br/><strong>        }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>If we run the preceding code, we get the following output:</p>
<pre><strong>I'm programming in Kotlin, of course</strong><br/><strong>Sure!</strong></pre>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre><strong>Hey Sam, any plans for the evening?</strong><br/><strong>That's cool, can I join you?</strong></pre>
<p>Now, all the messages are sorted properly and the conversation makes sense.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If our collection consisted of objects that implement the Comparable interface, we would be able to sort it simply by applying a <kbd>sorted()</kbd> function to it. The Kotlin standard library also provides more specialized versions of the <kbd>sortedBy()</kbd> function, such as <kbd>sortedByDescending()</kbd> and <kbd>sortedWith()</kbd>. The first one works as a base-sorting function, but it returns the dataset sorted with the opposite order. The <kbd>sortedWith()</kbd> function allows us to sort the list with a custom comparator. For example, to sort a collection of the <kbd>Message</kbd> type elements first by <kbd>sender</kbd> and next by the <kbd>time</kbd> property, we could write the following code:</p>
<pre>allMessages.sortedWith(compareBy(<strong>{it.sender}</strong>, <strong>{it.time}</strong>))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Building strings based on dataset elements</h1>
                
            
            
                
<p>Sometimes, we face the problem of generating text based on collections' elements. This is where the <kbd>Iterable.joinToString()</kbd> extension function can help. For example, we can consider working on an email-message-forwarding feature. When a user clicks the forward button, the original message's body text is concatenated, with the prefix looking something like this:</p>
<pre><strong>&lt;br/&gt;</strong><br/><strong>&lt;p&gt;---------- Forwarded message ----------&lt;/p&gt;</strong><br/><strong>&lt;p&gt;</strong><br/><strong>From: johny.b@gmail.com &lt;br/&gt;</strong><br/><strong>Date: 14/04/2000 &lt;br/&gt;</strong><br/><strong>Subject: Any plans for the evening?&lt;br/&gt;</strong><br/><strong>To: natasha@gmail.com, barbra@gmail.com&lt;br/&gt;</strong><br/><strong>&lt;/p&gt;</strong></pre>
<p>In this recipe, we are going to implement a function that is going to generate the recipients' string, for example:</p>
<pre><strong>To: natasha@gmail.com, barbra@gmail.com&lt;/br&gt;</strong></pre>
<p class="mce-root"/>
<p>For a given list of <kbd>Address</kbd> type objects, it is defined as follows:</p>
<pre>data class Address(val emailAddress: String, val displayName: String)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare the <kbd>generateRecipientsString()</kbd> function header:</li>
</ol>
<pre style="padding-left: 60px">fun generateRecipientsString(recipients: List&lt;Address?&gt;): String</pre>
<ol start="2">
<li>Start by removing all the <kbd>null</kbd> items from the <kbd>recipient</kbd> parameter:</li>
</ol>
<pre style="padding-left: 60px">fun generateRecipientsString(recipients: List&lt;Address?&gt;): String =<br/><strong>        recipients.filterNotNull()</strong></pre>
<ol start="3">
<li>Transform collection elements of the <kbd>Address</kbd> type to the <kbd>String</kbd> type elements corresponding to the <kbd>Address.emailAddress</kbd> property:</li>
</ol>
<pre style="padding-left: 60px">fun generateRecipientsString(recipients: List&lt;Address?&gt;): String =<br/>        recipients.filterNotNull()<br/><strong>                .map { it.emailAddress }</strong></pre>
<ol start="4">
<li>Apply the <kbd>joinToString()</kbd> function in order to merge collection elements into the string:</li>
</ol>
<pre style="padding-left: 60px">fun generateRecipientsString(recipients: List&lt;Address?&gt;): String =<br/>        recipients.filterNotNull()<br/>                .map { it.emailAddress }<br/><strong>                .joinToString(", ", "To: ", "&lt;br/&gt;")</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>generateRecipientsString()</kbd> function uses the <kbd>Iterable.joinToString()</kbd> extension function from the standard library <kbd>kotlin.collections</kbd> package to generate the output string. The <kbd>joinToString()</kbd> function takes three parameters—the separator character, which is used to concatenate the next substrings, the prefix, and the suffix strings. It is invoked on a collection of String values. We are also applying the preprocessing operations that are responsible for removing the <kbd>null</kbd> values from the list of the <kbd>Address</kbd> objects and mapping the <kbd>Address</kbd> type to the <kbd>String</kbd> corresponding to the <kbd>Address.emailAddress</kbd> property.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We could also use another version of the <kbd>joinToString()</kbd> function to simplify the logic of our <kbd>generateRecipientsString()</kbd> function implementation:</p>
<pre>fun generateRecipientsString(recipients: List&lt;Address?&gt;): String =<br/>        recipients.filterNotNull()<br/>            .joinToString(", ", "To: ", "&lt;br/&gt;") { it.emailAddress }</pre>
<p>As you can see, it takes the additional argument in the form of an inlined lambda block, which acts as a transformation function that is being applied to each of the <kbd>recipients</kbd> collection elements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>To explore dataset mapping operations in more depth, you can read the <em>Data transformation with the map and flatMap</em> recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dividing data into subsets</h1>
                
            
            
                
<p>A common data-processing task is to divide a collection of data into subsets. In this recipe, we are going to explore standard library functions that allow us to buffer a collection into smaller chunks. Let's say we have a list containing a large number of <kbd>Message</kbd> type objects and we would like to transform it into collections of sub-lists of a constant size. For example, the transformation would take the original collection of <em>n</em> elements:</p>
<pre><strong>[mssg_1, mssg_2, mssg_3, mssg_4, mssg_5, mssg_6, mssg_7, ..., mssg_n]</strong></pre>
<p>And it would then split it into a collection of four element subsets:</p>
<pre><strong>[[mssg_1, mssg_2, mssg_3, mssg_4], ..., [mssg_n-3, mssg_n-2, mssg_n-1, mssg_n]]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's start by declaring the <kbd>Message</kbd> class that we are going to use in the following recipe:</p>
<pre>data class Message(val text: String,<br/>                   val time: Instant = Instant.now())</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Let's declare the <kbd>messages</kbd> variable that stores the sample data:</p>
<pre>val messages = listOf(<br/>        Message("Any plans for the evening?"),<br/>        Message("Learning Kotlin, of course"),<br/>        Message("I'm going to watch the new Star Wars movie"),<br/>        Message("Would u like to join?"),<br/>        Message("Meh, I don't know"),<br/>        Message("See you later!"),<br/>        Message("I like ketchup"),<br/>        Message("Did you send CFP for Kotlin Conf?"),<br/>        Message("Sure!")<br/>)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Apply the <kbd>windowed()</kbd> function to the <kbd>messages</kbd> list: </li>
</ol>
<pre style="padding-left: 60px">val pagedMessages = messages.windowed(4, partialWindows = true, step = 4)  </pre>
<ol start="2">
<li>Add a <kbd>transform: (List&lt;T&gt;) -&gt; R</kbd> transformation function as an additional, inline parameter to the windowed function:</li>
</ol>
<pre style="padding-left: 60px">val pagedMessages = messages.windowed(4, partialWindows = true, step = 4) { <br/>    it.map { it.text }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>windowed</kbd> function splits the original list of messages into sublists of a specified size. As a result, we get the <kbd>List&lt;List&lt;Message&gt;&gt;</kbd> type assigned to the <kbd>pagedMessages</kbd> handle. We could print the next message subsets with the following code:</p>
<pre>pagedMessages.forEach { println(it) }</pre>
<p>As the result, we get the following output printed to the console:</p>
<pre><strong>[Any plans for the evening?, Learning Kotlin, of course, I'm going to watch the new Star Wars movie, Would u like to join?]</strong><br/><strong>[Meh, I don't know, See you later!, I like the ketchup, Did you send CFP for Kotlin Conf?]</strong><br/><strong>[Sure!]</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>windowed</kbd> function takes four parameters—the size of the window, a flag saying whether partial windows should be created, a step value, and an optional transforming function that is responsible for converting each of the generated windows. In our scenario, we are using a window size equal to <kbd>4</kbd>. This is why we need to specify the step value as equal to <kbd>4</kbd> as well because we want to have consecutive <kbd>Message</kbd> instances stored in the next windows. We also set the <kbd>partialWindows</kbd> argument to <kbd>true</kbd>, otherwise, the last window containing a single message would be omitted. The last param of the <kbd>windowed</kbd> function allows us to map each of the windows into another type. We are mapping each of sublists returned by the <kbd>windowed()</kbd> function into the <kbd>List&lt;String&gt;</kbd> type. There is also another version of the <kbd>windowed</kbd> function, without the last mapping parameter, so it can be treated as the optional one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There is also a handy wrapper of the <kbd>windowed()</kbd> function provided, called <kbd>chunked()</kbd>. It doesn't require the step argument and sets it automatically to the window size value. It would be a good fit for this recipe's problem, however, the <kbd>windowed()</kbd> function was explained as it's more basic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>There are other functions available that solve different list and collection division scenarios, such as the <kbd>subList()</kbd> (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html</a>) and <kbd>partition()</kbd> (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html</a>) functions. You can find out more about them in official docs using the provided links. </li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Data transformation with map and flatMap</h1>
                
            
            
                
<p>The support for declarative data mapping operations is one of the basic and most powerful features in the functional data-processing domain. Often, when working with data, we need to transform a collection of a specific type into another type. It's also a common scenario to generate a list of objects from each element of a collection and to merge all of those new objects in a target collection together. Those are the use cases where the <kbd>map()</kbd> and <kbd>flatMap()</kbd> extension functions help.</p>
<p class="mce-root"/>
<p>In this recipe, we are going to use both of them to implement a mapping data transformation. Let's imagine we are working on the part of the system responsible for managing university department lectures. We are given the following types:</p>
<pre>class Course(val name: String, val lecturer: Lecturer, val isPaid: Boolean = false)<br/>class Student(val name: String, val courses: List&lt;Course&gt;)<br/>class Lecturer(val name: String)</pre>
<p class="mce-root">We also have a <kbd>getStudents(): List&lt;Student&gt;</kbd> function, which returns a list of all students from the database. We want to implement the <kbd>getLecturesOfCoursesWithSubscribedStudents()</kbd> function, which is going to to transform the <kbd>getStudents()</kbd> result to compute a list of lecturers whose courses are subscribed to by at least one student.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a function header:</li>
</ol>
<pre style="padding-left: 60px">fun <strong>getLecturesOfCoursesWithSubscribedStudents</strong>()</pre>
<ol start="2">
<li>Apply the <kbd>flatMap</kbd> operation to the list of students:</li>
</ol>
<pre style="padding-left: 60px">fun <strong>getLecturesOfCoursesWithSubscribedStudents</strong>() =<br/>        getStudents()<br/>                .flatMap { student -&gt;<br/>                    student.courses<br/>                }</pre>
<ol start="3">
<li>Limit the collections' elements to distinct values:</li>
</ol>
<pre style="padding-left: 60px">fun <strong>getLecturesOfCoursesWithSubscribedStudents</strong>() =<br/>        getStudents()<br/>                .flatMap { student -&gt;<br/>                    student.courses<br/>                }<br/>                .distinct()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Map the collection of the <kbd>Course</kbd> type elements to their corresponding <kbd>Lecturer</kbd> type properties:</li>
</ol>
<pre style="padding-left: 60px">fun <strong>getLecturesOfCoursesWithSubscribedStudents</strong>() =<br/> getStudents()<br/> .flatMap { student -&gt;<br/>     student.courses<br/> } <br/> .distinct()<br/> .map { course -&gt; course.lecturer } <br/> .distinct()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>With the following <kbd>flatMap</kbd> operation, the <kbd>getLecturesOfCoursesWithSubscribedStudents()</kbd> function is transforms the collection of the <kbd>Student</kbd> type objects into the collection of the <kbd>Course</kbd> type by merging elements of the <kbd>Student.courses: Collection&lt;Course&gt;</kbd> property:</p>
<pre>getStudents()<br/>        <strong>.flatMap { student: Student -&gt;<br/>            student.courses<br/>        }</strong></pre>
<p>As the result, the preceding code returns the <kbd>Collection&lt;Course&gt;</kbd> type. The collection returned by the <kbd>flatMap</kbd> operation contains a set of all the courses all of the students (obtained from the <kbd>getStudents()</kbd> function) are subscribed to.</p>
<p>Next, in order to remove duplicated courses, we append the chain of operations with the <kbd>distinct()</kbd> function. Then, we use the <kbd>map()</kbd> function. It is responsible for transforming every single element of the <kbd>Course</kbd> type into its corresponding <kbd>Lecturer</kbd> type from the <kbd>Course.lecturer</kbd> property. Finally, we are applying the <kbd>distinct()</kbd> function once again to return the list of lecturers with no duplicates. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The <kbd>map()</kbd> and <kbd>flatMap()</kbd> extension functions are also available for the <kbd>Map</kbd> data structure type. They are useful when it comes to converting a map to a list of objects transformed from the map's key-value pairs.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Folding and reducing data sets</h1>
                
            
            
                
<p>While the <kbd>map()</kbd> operator takes a list of a given size and returns another list of the same size and of the modified type, the <kbd>fold()</kbd> and <kbd>reduce()</kbd> operations applied to the data set return a single element, composed of the consecutive elements of the data set. This may sound like a simple scenario for using a plain, imperative-style loop and local accumulator variable that holds a current state and is updated at each iteration. We can consider the simple task of summing up integer values. Let's consider that we want to compute a sum of consecutive integers from <kbd>0</kbd> to <kbd>10</kbd>. We could achieve it using a simple <kbd>for</kbd> loop:</p>
<pre>var sum = 0<br/>(1..10).forEach {<br/>    sum += it<br/>}</pre>
<p>However, there is an alternative, functional way of performing such computations, using the <kbd>fold()</kbd> function:</p>
<pre>val sum = (1..3).toList().fold(0) { acc, i -&gt; acc + i }<br/></pre>
<p>The second approach is desirable whenever we implement a chain of functional data-processing operations. Compared to the for loop, the <kbd>fold</kbd> function doesn't enforce consuming the collection elements explicitly and can be easily used together with other functional operators.</p>
<p>In this recipe, we are going make use of the <kbd>fold</kbd> function when implementing the function responsible for processing the audio album tracks. Let's assume we are given the following data types:</p>
<pre>data class Track(val title: String, val durationInSeconds: Int)<br/>data class Album(val name: String, val tracks: List&lt;Track&gt;)</pre>
<p>and the sample <kbd>Album</kbd> class instance:</p>
<pre>val album = Album("Sunny side up", listOf(<br/>        Track("10/10", 176),<br/>        Track("Coming Up Easy", 292),<br/>        Track("Growing Up Beside You", 191),<br/>        Track("Candy", 303),<br/>        Track("Tricks of the Trade", 151)<br/>))</pre>
<p>We want to implement an extension function for the <kbd>Album</kbd> type that will return a relative start time for the <kbd>Track</kbd> given as an argument. For example, the start time of the <kbd>Growing Up Beside You</kbd> track should be 468 seconds.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare an extension function for the <kbd>Album</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">fun Album.getStartTime(track: Track): Int</pre>
<ol start="2">
<li>Compute the start time for the given <kbd>Track</kbd> argument:</li>
</ol>
<pre style="padding-left: 60px">fun Album.getStartTime(track: Track): Int {<br/>   <strong> val index = tracks.indexOf(track)</strong><br/><strong>    return this.tracks<br/>            .take(index)</strong><br/><strong>            .map { (name, duration) -&gt; duration }<br/>            .fold(0) { acc, i -&gt; acc + i</strong> }<br/>}</pre>
<ol start="3">
<li>Add a safety check for the <kbd>track</kbd> argument:</li>
</ol>
<pre style="padding-left: 60px">fun Album.getStartTime(track: Track): Int {<br/><strong>    if (track !in tracks) throw IllegalArgumentException("Bad <br/>     track")</strong><br/><br/>    val index = tracks.indexOf(track)<br/>    return tracks<br/>        .take(index)<br/>        .map { (name, duration) -&gt; duration }<br/>        .fold(0) { acc, i -&gt; acc + i }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>At the very beginning, our function does a safety check for the <kbd>track</kbd> argument passed to it to verify whether it belongs to the current <kbd>Album</kbd> instance. If the given track is not found within the <kbd>Album.tracks</kbd> collection, the <kbd>IllegalArgumentException</kbd> exception is thrown.  Next, we create a sublist from the <kbd>tracks</kbd> property elements containing only the elements from the <kbd>0</kbd> index to the index of the <kbd>track</kbd> passed as the function parameter. This sublist is created using the <kbd>take()</kbd> operator. Then, we map each of the <kbd>Track</kbd> type elements to the <kbd>Int</kbd> type corresponding to the duration of the track. Finally, we apply the <kbd>fold</kbd> function, to sum the <kbd>durationInSeconds</kbd> property values of the consecutive <kbd>Track</kbd> elements. The <kbd>fold</kbd> function takes the <kbd>initial</kbd> argument responsible for initializing the internal <kbd>accumulator</kbd> variable holding the current state of the folding result.</p>
<p class="mce-root"/>
<p>In our case, we pass 0 as the <kbd>initial</kbd> value, which corresponds to the album start time. In the second argument passed to the <kbd>fold</kbd> function, we are defining how the <kbd>accumulator</kbd> should be updated with each of the consecutive <kbd>durationInSeconds</kbd> values.</p>
<p>Let's test the <kbd>Album.getStartTime()</kbd> function in action:</p>
<pre>println(album.getStartTime(Track("Growing Up Beside You", 191)))<br/>println(album.getStartTime(Track("Coming Up Easy", 292)))</pre>
<p>The preceding code returns the following output:</p>
<pre><strong>468</strong><br/><strong>176</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The standard library provides a similar function, named <kbd>reduce()</kbd><em>, </em>which does the same operation as <kbd>fold</kbd>. The difference between the two is that <kbd>fold</kbd><em> </em>takes an explicit initial value, whereas <kbd>reduce</kbd> uses the first element from the list as the initial value. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Grouping data</h1>
                
            
            
                
<p>The Kotlin standard library provides built-in support for the dataset <em>group by</em> operation. In this recipe, we are going to explore how to use it.</p>
<p>Let's assume we are working with the following types:</p>
<pre>class Course(val name: String, val lecturer: Lecturer, val isPaid: Boolean = false)<br/>class Student(val name: String, val courses: List&lt;Course&gt;)<br/>class Lecturer(val name: String)</pre>
<p class="mce-root">We also have a <kbd>getStudents(): List&lt;Student&gt;</kbd> function that returns a list of all the students from the database.</p>
<p>Given the <kbd>getStudents(): List&lt;Student&gt;</kbd> function, we are going to implement the <kbd>getCoursesWithSubscribedStudents(): Map&lt;Course, List&lt;Student&gt;&gt;</kbd> function responsible for extracting the map of all the courses students are subscribed to, and the list of students subscribed to each of the courses.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a function header:</li>
</ol>
<pre style="padding-left: 60px">fun getCoursesWithSubscribedStudents(): Map&lt;Course, List&lt;Student&gt;&gt; </pre>
<ol start="2">
<li>Map each of the students to the list of the course-student pairs:</li>
</ol>
<pre style="padding-left: 60px">fun getCoursesWithSubscribedStudents(): Map&lt;Course,<br/> List&lt;Student&gt;&gt; =<br/>    <strong>getStudents()</strong><br/><strong>            .flatMap { student -&gt;<br/>                student.courses.map { course -&gt; course to student }<br/>            }</strong></pre>
<ol start="3">
<li>Group the course-student pairs by <kbd>Course</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fun getCoursesWithSubscribedStudents(): Map&lt;Course,<br/> List&lt;Student&gt;&gt; =<br/>    getStudents()<br/>            .flatMap { student -&gt;<br/>                student.courses.map { course -&gt; course to student }<br/>            }<br/><strong>            .groupBy { (course, student) -&gt; course }</strong></pre>
<ol start="4">
<li>Apply a mapping transformation to the <kbd>Pair&lt;Course, List&lt;Student&gt;&gt;</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">fun getCoursesWithSubscribedStudents(): Map&lt;Course,<br/> List&lt;Student&gt;&gt; =<br/>    getStudents()<br/>            .flatMap { student -&gt;<br/>                student.courses.map { course -&gt; course to student }<br/>            }<br/>            .groupBy { (course, _) -&gt; course }<br/><strong>            .map { (course, courseStudentPairs) -&gt; <br/>                course to courseStudentPairs.map { (_, student) -&gt; <br/>                 student } <br/>            }</strong></pre>
<ol start="5">
<li>Apply a <kbd>toMap()</kbd> function at the end:</li>
</ol>
<pre style="padding-left: 60px">fun getCoursesWithSubscribedStudents(): Map&lt;Course,<br/> List&lt;Student&gt;&gt; =<br/>    getStudents()<br/>            .flatMap { student -&gt;<br/>                student.courses.map { course -&gt; course to student }<br/>            }<br/>            .groupBy { (course, _) -&gt; course }<br/>            .map { (course, courseStudentPairs) -&gt;<br/>                course to courseStudentPairs.map { (_, student) -&gt;<br/>                 student }<br/>            }<br/><strong>            .toMap()</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We start by transforming the list of students to list of the <kbd>Pair&lt;Course, Student&gt;</kbd> type with the <kbd>flatMap()</kbd> function. Next, we apply the <kbd>groupBy()</kbd> function to group those pairs by a distinct <kbd>Course</kbd> instance. As the result of the grouping operation, we receive data of the following type—<kbd>Map.Entry&lt;Course, List&lt;Pair&lt;Course, Student&gt;&gt;&gt;</kbd>. We need to convert the <kbd>Map.Entry.value</kbd> property type to the <kbd>List&lt;Student&gt;</kbd> type. We achieve it with the following mapping transforming function:</p>
<pre>map { (course, courseStudentPairs) -&gt;<br/>    course <strong>to </strong>courseStudentPairs.map { (_, student) -&gt; student }<br/>}</pre>
<p>As a result, each <kbd>Course</kbd> instance is associated with a list of students subscribed to it (<kbd>Pair&lt;Course, List&lt;Student&gt;&gt;</kbd>). Note that the infix <kbd>to</kbd> function is being used to instantiate the Pair type. Finally, we invoke the <kbd>toMap()</kbd> function, which produces the final <kbd>Map&lt;Course, List&lt;Students&gt;&gt;</kbd> instance from the list of course-student pairs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can also modify our map building operation to a more concise form by using the <kbd>mapValues</kbd> function:</p>
<pre>fun getCoursesWithSubscribedStudents(): Map&lt;Course, List&lt;Student&gt;&gt; =<br/>        getStudents()<br/>                .flatMap { student -&gt;<br/>                    student.courses.map { course -&gt; course to student }<br/>                }<br/>                .groupBy { (course, _) -&gt; course }<br/>                <strong>.mapValues { (course, courseStudentPairs) -&gt;<br/>                    courseStudentPairs.map { it -&gt; it.second }<br/>                }</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The code in this recipe uses destructuring types declarations in mapping operations. If you'd like to learn more about this, you can take a look at the <em>Destructuring types </em>recipe from <a href="b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml" target="_blank">Chapter 2</a>, <em>Expressive Functions and Adjustable Interfaces</em>.</li>
</ul>


            

            
        
    </body></html>