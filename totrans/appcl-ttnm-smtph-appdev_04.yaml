- en: Chapter 4. Enhancing your Apps with Audio, Video, and the Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your capture device using an OptionDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing photos from the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing existing photos from the photo library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying photos using ScrollableView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving your captured photo to the device filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing and playing audio via the audio recorder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing video via the video recorder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing video files from the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safely deleting saved files from the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it may be hard to believe, snapping photographs and sharing them wirelessly
    using a phone first happened only in 1997, and wasn't popularized until around
    2004\. By 2010, almost all phones contained a digital camera and many mid-range
    to high-end devices also sported audio and video camcorder capabilities. Most
    iPhone and Android models now have these capabilities, and they have opened new
    pathways for entrepreneurial developers.
  prefs: []
  type: TYPE_NORMAL
- en: Titanium contains APIs that let you access all of the phone interfaces required
    to take photos or video with the built-in camera, record audio, and scroll through
    the device's saved image and video galleries.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter we will introduce all of these concepts and use them
    to put together a basic ''Holiday Memories'' app which will allow our users to
    capture photographs, videos, and audio from their device, save those files to
    the local file storage, and read them back again.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-requisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should already be familiar with Titanium basics, including creating UI objects
    and using Titanium Studio. Additionally, to test camera functionality you are
    going to need either an iPhone or Android device capable of both recording photographs
    and video. An iPhone 3GS model or up will suffice, and all Android phones apart
    from the very bottom-end of the market should be OK.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your capture device using an OptionDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OptionDialog is a modal-only component that allows you to show one or more
    options to a user, usually along with a *cancel* option, which closes the dialog.
    We are going to create this component and use it to present the user with an option
    to choose an image from the camera or the device's photo library.
  prefs: []
  type: TYPE_NORMAL
- en: If you are intending to follow the entire chapter and build the Holiday Memories
    app, then pay careful attention to the first *Getting ready* section for this
    recipe, as it will guide you through setting up the project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in **Holiday
    Memories** as the name of the app, and fill in the rest of the details with your
    own information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is *com.packtpub.holidaymemories)*. This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on. You can obtain
    all of the images used in this recipe, and indeed the entire chapter, by downloading
    the following source files:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this entire chapter can be found in the `/Chapter 4/Holiday
    Memories` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now our project has been created using Titanium Studio. Let''s get down to
    business! Open up the `app.js` file in your editor and remove all existing code.
    After you have done that, type in the following and then hit save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create our first Window''s JavaScript file that we will call
    `photo.js`. Create this blank file in your `Resources` folder and open it in your
    IDE. Enter in the following code to create the "Choose Photo" button which will
    instantiate your OptionDialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in the first block of code is creating our Navigation view with tabs
    and windows, all of which has been covered in [Chapter 1](ch01.html "Chapter 1. Building
    Apps using Native UI Components"), *Building Apps using Native UI Components*
    and [Chapter 2](ch02.html "Chapter 2. Working with Local and Remote Data Sources"),
    *Working with Local and Remote Data Sources*. Our first tab and window use the
    *photo.js* file, the contents of which are visible here in our second block of
    code on the previous page.
  prefs: []
  type: TYPE_NORMAL
- en: The OptionDialog itself is created using the `Titanium.UI.createOptionDialog()`
    method and only requires a few simple parameters. The `title` parameter, in this
    case, appears at the top of your button options and is there to just give your
    user a brief message about what their chosen option will be used for. In our case,
    we're simply notifying them that we'll be using their chosen option to launch
    the appropriate image capture application. The options array is the important
    property here and contains all of the button selections you wish to present to
    the user. Note that we have also included a `cancel` item in our array, and there
    is a corresponding `cancel` property with the same index as part of our `createOptionDialog()`.
    This will draw the button style for cancel a little differently when our OptionDialog
    is presented on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we added an event listener to our OptionDialog and we are outputting
    the chosen button index to the Titanium Studio console, using the `e.index` property.
    We will use this flag in our next recipe to launch either the camera or photo
    gallery depending on the user''s selection. The OptionDialog shown next provides
    the user with two image source options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Capturing photos from the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the device camera we need to access the `Titanium.Media` namespace, and
    specifically the `showCamera` method. This will display the native operating system
    interface for taking photographs, and expose the three events which will help
    us decide what needs to be done with the captured image. We will also check whether
    the user's device is capable of taking camera shots before attempting to do so,
    as some devices (including iPod Touch and the emulator) don't have this capability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this recipe will only work if you are using a physical device! The
    emulators for both Android and the iPhone don't have camera functionality built
    in. If you attempt to run this on the emulator you will just be presented with
    an error dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to extend the event listener of our OptionDialog using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app on a physical device now and you should be able to select the
    camera button from our OptionDialog and take a photograph with your device. This
    image should then appear in our temporary ImageView like it does in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting an image from the camera is actually pretty straightforward. First,
    you'll notice that we've extended the OptionDialog with an if statement. If the
    index property of our dialog is 0 (the first button) then we are launching the
    camera. We do this via the `Titanium.Media.showCamera()` method. This fires three
    events, which we are capturing here, called **success, error**, and **cancel**.
    We are ignoring the cancel event, as there is no processing required if the user
    opts to cancel out of the image capture. In the error event, we are going to display
    an AlertDialog that explains that the camera cannot be initiated. This is the
    dialog you will see if you happen to run this code using an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of our processing takes place in the success event. First, we save
    the captured photograph into a new variable called `image`. We then check that
    the chosen media was actually a photograph by comparing its `mediaType` property.
    It is at this point that the chosen media could actually be a video, so we must
    double check what it is before we use it, as we don't know whether the user has
    taken a photo or video shot until after it has happened. Finally, to show that
    we have actually captured an image with our camera to the user, we create an ImageView
    and set its `image` property to the captured image file, before adding the entire
    thing to our window.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing existing photos from the photo library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of choosing an image from the photo library on the device is very
    similar to that of the camera. We are still using the `Titanium.Media` namespace,
    however, this time we are going to execute the method called `openPhotoLibrary()`,
    which does exactly as the name suggests. As with the previous recipe, once we
    have retrieved an image from the Photo Gallery, we will display it on screen to
    the user using a simple ImageView control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to further extend our OptionDialog to now choose an image from
    the photo library, if the `index` property of 1 (the second button) is selected.
    Add the following code into your dialog''s event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app in the emulator or device and choose the second option from our
    dialog. The photo library should appear and allow you to select an image. This
    selection screen will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe follows more or less the same pattern as when we used the camera
    to obtain our image. First, we extended the `OptionDialog` event listener to perform
    an action when the button index selected equals 1, which in this case is our Photo
    Gallery button. Our `openPhotoGallery()` method also fires three events: **success,
    error**, and **cancel**.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the previous recipe, the majority of our processing takes place in
    the success event. We check that the chosen media was actually a photograph by
    comparing its `mediaType` property, and finally we create an ImageView and set
    its `image` property to the captured image file, before adding the entire thing
    to our window.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's explore media types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Media Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main media types available to you via the `mediaType` enumeration
    when capturing photographs or videos via the in-built camera. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MEDIA_TYPE_PHOTO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEDIA_TYPE_VIDEO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, there are also numerous other sets of more specific `mediaType''s`
    in the enumeration, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MUSIC_MEDIA_TYPE_ALL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MUSIC_MEDIA_TYPE_ANY_AUDIO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MUSIC_MEDIA_TYPE_AUDIOBOOK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MUSIC_MEDIA_TYPE_MUSIC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MUSIC_MEDIA_TYPE_PODCAST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDEO_MEDIA_TYPE_AUDIO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDEO_MEDIA_TYPE_NONE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDEO_MEDIA_TYPE_VIDEO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types are generally only applicable when utilizing the `mediaType` property
    from within the `VideoPlayer` or `AudioPlayer` components.
  prefs: []
  type: TYPE_NORMAL
- en: Saving to photos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run this code in the emulator, but you'll probably notice that there
    are no images in the library and no obvious way to get them there! Thankfully,
    this is actually fairly easy to overcome. Simply open the web browser and find
    an image you want to test with using Google Images or a similar service. Click
    and hold on an image in the browser and you should see an option **save to photos**.
    You can then use these images to test out your code in the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying photos using ScrollableView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common methods of displaying multiple photographs and images
    on mobile devices is the `ScrollableView`. This view type allows for pictures
    to be swiped left and right, and is common among many applications including Facebook
    mobile. The method of showing images in this way is reminiscent of "flipping"
    through a book or album, and is very popular due to the natural feel and simple
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will implement a `ScrollableView` which will contain any number
    of images that can be chosen from the camera or photo gallery. Complete source
    code for this recipe can be found in the `/Chapter 4/Recipe 4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this recipe should work for both Android and iPhone devices. However,
    a recent bug in the latest version of Titanium SDK (1.7.2) may cause it to fail
    on Android. You should check whether you are using the latest version of Titanium
    SDK if you wish to test this on the Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create our ScrollableView object, which we will call `scrollingView`,
    and add it to our `photo.js` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we are going to alter the dialog event listener in order to assign our selected
    photos to the ScrollableView, instead of the temporary ImageView we created earlier.
    Replace all of the code within and including your `if(event.mediaType == Ti.Media.MEDIA_TYPE_PHOTO)`
    with the following code. Note you need to do this for both the images gathered
    from the photo library and from the device camera.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now run your app in either the emulator or your device, and select a couple
    of images one after the other. You can use a combination of images from the camera
    or the photo gallery. Once you have selected at least two images, you should be
    able to swipe between them using a left-to-right or right-to-left gesture.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ScrollableView is really just a collection of views that has a number of
    special events and properties built into it, as you can probably tell by the empty
    array value we have given to the property called `views` in the `createScrollableView()`
    method. It is necessary to set this property on instantiating the ScrollableView
    object, and a good idea to set the `currentPage` index property to 0; our first
    view. We are still creating an ImageView as per the previous recipes. However,
    this time we are not adding that View to our window, but to our `ScrollableView`
    component. We do this by adding a view using the `addView()` method. Finally,
    we have also created an event that attaches to our ScrollableView called `scroll`,
    and we are outputting the `currentPage` property to the Titanium console for debugging
    and testing.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the ScrollableView is an easy and simple component and is very
    useful for photo gallery applications or any other apps where you want to display
    a series of similar views. You could extend this by adding a blank View object
    and putting any number of text fields, labels, or image views you want in each
    of those blank views"the only limit here is your imagination!
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Saving your captured photo to the device filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking pictures is all well and good, but what about when we wish to save an
    image to the filesystemso we can retrieve it again later? In this recipe we will
    do exactly that and also introduce you to the `toImage()` method which is inbuilt
    in many of the Titanium controls. This method takes a flattened image of the entire
    view it is called upon and is extremely useful for taking screenshots or grabbing
    an image of many controls lumped together in a single view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    5` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type in the following code after your `btnGetPhoto` object is created. You can
    replace the existing code that we've written to add the `btnGetPhoto` object to
    the navigation bar, as this code repeats that code and also extends it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Titanium.FileSystem` namespace opens up a range of file manipulation capabilities,
    but most importantly, gives us the basic tools in order to read and write a file
    to the application's storage space on the device. In this recipe we are using
    the `toImage()` method of the `scrollingView` to return a blob of the view's image
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: We can then get a reference to the folder we wish to store the image file data
    in. As you can see in the code, we are getting a reference to that folder by creating
    a new variable such as `var newDir = Titanium.Filesystem.getFile(Titanium.Filesystem.applicationDataDirectory,'photos')`;
    and then ensuring that the folder exists. If it doesn't exist, we can create the
    folder by calling the `createDirectory()` method on our `newDir` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our image data is saved in much the same way. First, we create a variable
    called `writeFile`, which is referencing our file name within the `newDir` object
    folder we have already created. We can then output the file to the filesystem
    using `writeFile's "write()"` method, passing in the image media variable as the
    file data to save.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and playing audio via the audio recorder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another handy feature of the iPhone and most Android handsets is the ability
    to record audio data—perfect for taking audible notes during meetings or those
    long, boring lectures! In this recipe we are going to capture some audio using
    the `Titanium.Media.AudioRecorder` class, and then allow the user to play back
    the recorded sound file.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    6` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this recipe will only work for the iPhone. You will also require a
    physical device for this recipe. Later versions of the Titanium framework should
    support audio recording for Android via the use of intents. In addition, the iPhone
    3G models may not be capable of recording in some of the following compression
    formats, particularly high fidelity formats such as AAC. When in doubt, you should
    try using MP4A or WAV formats.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new JavaScript file called `audio.js` and save it into your resources
    directory. Then back in your `app.js` file, add the URL property of window3, and
    give it a value of `audio.js`. This will load up our video JavaScript file for
    the third tab window of our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type in the following code into your `audio.js` file and save. This will set
    up the interface with a set of buttons and labels so we can start, stop, and playback
    our recorded audio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run your application in the emulator and switch to the **Audio** tab. You
    should see a screen that looks just like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''re going to create an object instance of the `AudioRecorder` method
    called `recording`, and give it a compression value and format value. We will
    also add event listeners to watch out for when the volume, audio line, and recording
    properties change, along with event handlers to capture and process these changes.
    Type in the following directly after the code you created from the previous page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add the section of code after your `Ti.Media` event listeners that
    you created previously. This code will handle all of the events for the audio
    input controls (the stop/start buttons and our high-fidelity switch).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now run your application on a device (the simulator may not be capable of recording
    audio) and you should be able to start, stop, and then playback your audio recording,
    while the high fidelity switch will change the audio compression to a higher fidelity
    format.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are creating an instance of the `AudioRecorder` object, and
    we have called this new object `recording`. We're giving this object a compression
    and audio format. For now, we have set these to the default (PCM compression and
    standard CAF format). Listeners from the `Titanium.Media` namespace are then added,
    which when fired will change the line type or volume labels respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The main processing for this recipe happens within the event handlers for the
    "Start/Stop" and "Playback" buttons called `b1` and `b2` respectively. Our first
    button, `b1`, is first checking its title to determine whether to stop or start
    recording via a simple if statement. If recording has not started, then we kick
    off the process by calling the `start` method of our `recording` object. To do
    so, we also need to start the microphone monitor, which is done by executing the
    line `Ti.Media.startMicrophoneMonitor()`. Our device will then begin recording.
    Tapping the `b1` button again will execute the stop code and simultaneously set
    our file object (the resulting sound-audio file) to the output from our `recording`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `b2` button event handler checks whether we have a valid sound file, and
    whether it is already playing. If we have a valid file and it's playing, then
    the playback will stop. Otherwise, if there is a valid sound file and it hasn't
    already been played back through the speaker, we are creating a new object called
    `sound`, using the `Titanium.Media.createSound` method. This method requires a
    `sound` parameter. We passed the `file` object to it that was created during our
    recording session. Executing the `sound` object's `play` method then kicks off
    the playback, while the event listener/handler for the playback completion resets
    our `b2` button title when the playback has completed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the switch (called `switcher` in this example) simply changes the recording
    format from high fidelity compression to a low one. The lower the quality and
    compression, the smaller the resulting audio file will end up being.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing video via the video recorder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use the inbuilt camera of your iPhone (3GS and above) or Android
    device to record video. The quality and length of the video that you can record
    is dependant on both your device's memory capabilities and the type of camera
    that's included in the hardware. However, you should at least be able to capture
    short video clips in VGA resolution as a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe we will create a basic interface for our **Video** tab consisting
    of a record button, which will launch the camera and record video on your device.
    We''ll also perform this in two separate ways: using standard Titanium code for
    the iPhone and using intents for Android.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this recipe will require a physical device for testing. In addition,
    the iPhone 3G models are not be capable of recording video, but all models from
    the 3GS and upwards should be fine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new JavaScript file called `video.js` and save it into your resources
    folder. Then, back in your `app.js` file, add the URL property of window2 and
    give it a value of `video.js`. This will load up our video JavaScript file for
    the second tab window of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, let's set up the basic interface to have a record button (in the
    navigation bar section for the iPhone and as a normal button for Android), along
    with the `videoFile` variable. This will hold the path to our recorded video as
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the event listener and handler code for the record button.
    This will check our current platform (either iPhone or Android) and execute the
    record video code for the correct platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's work through the code for recording on iPhone devices first, which is
    encapsulated within the `if(Titanium.Plaform.osname == 'iphone')` statement as
    mentioned in the previous code. Here, we are executing the camera in the same
    way you would for capturing plain photos, however, we're passing additional parameters.
    The first of these is called `mediaType`, and it tells the device we want to capture
    a `mediaType` of `MEDIA_TYPE_VIDEO`.
  prefs: []
  type: TYPE_NORMAL
- en: The other two parameters define how long and what quality to capture the video
    in. The parameter `videoMaximumDuration` float defines the duration (how long
    in milliseconds to allow capture before completing,) while the `videoQuality`
    constant indicates the video quality during capture. We have set these to 10 seconds
    (10,000 milliseconds) and a video quality of "high" respectively.
  prefs: []
  type: TYPE_NORMAL
- en: On successful video capture, we save the `event.media` (our video in its raw
    format) to the filesystem, using pretty much the same method as we did when saving
    a photograph. The final step is to set the `videoFile` path to the location of
    our newly saved video file on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: For Android, we are capturing the video in a different way, using an *intent*.
    In this case, we're using the video capture intent called `android.media.action.VIDEO_CAPTURE`.
    Objects of type `android.content.Intent` are used to send asynchronous messages
    within your application or between applications. Intents allow the application
    to send or receive data to and from other activities or services. They also allow
    it to broadcast that a certain event has occurred. In our recipe's code, we are
    executing our Intent and then capturing the result—if the `resultCode` equals
    `Titanium.Android.RESULT_OK` then we know that we've managed to record a video
    clip. We can then move this file from its temporary storage location to a new
    destination of our choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are capturing video in 3GP format for Android while it was in MP4/MOV
    format on the iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: Playing video files from the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have recorded video, what about playing it back? Titanium has an
    inbuilt video player component that can play both local files and remote video
    URLs. In this recipe we'll show you how to create the video player control and
    pass the local file URL of the video we captured in the previous recipe to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    8` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `videos.js` file, underneath the declaration for the `videoFile` object,
    create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your event listener for `btnGetVideo`, extend the code so that it
    checks the button title and plays the recorded video when it has been saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a video player object is no different than creating Labels or Buttons
    as many of the same properties are utilized for positioning and layout. The player
    can be embedded into any other view as you would do with a normal control, meaning
    you could have video thumbnails playing directly from within the rows of a TableView
    if you wanted. Additionally, the Video Player can play both local and remote videos
    (using the Video `url` property). In this recipe, we are uploading a saved video
    from the filesystem that was captured by the camcorder on our device.
  prefs: []
  type: TYPE_NORMAL
- en: You could just as easily load a video from a URL or directly from within your
    `Resources` folder. There is a 10 second video attached to the source code for
    this chapter in both `mp4` and `3gp` formats for you to test with, called `video-test.mp4`.
    You can also attempt to load it remotely using the web address [http://boydlee.com/video-test.mp4](http://boydlee.com/video-test.mp4).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some web video formats such as FLV are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want your video to play using the full screen dimensions and not just
    within a view, then you can set its `fullscreen` property to `true`. This will
    automatically load the video into fullscreen mode when it starts playing.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/3968EXP_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safely deleting saved files from the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create these files and write them to our local phone storage, but what
    about deleting them? In this recipe we'll explain how to safely check for and
    delete files using the `Titanium.Filesystem.File` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    9` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in your `photos.js` file, add the following button code with an event listener
    at the end of the file. This will be our "trash" button and will call the delete
    function on the current selected image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an extra line to our existing `btnSaveCurrentPhoto` click event to make
    our trash button visible only after a photo has actually been saved to the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, extend your button''s event listener to delete the file, only after
    making sure that it already exists, before adding our button to the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File manipulation is all done using methods on the file object, unlike many
    other languages where a "delete" function normally means passing the file object
    into said function to be deleted. In our recipe, you can see we're simply creating
    the file object as we did previously in the recipe on saving photos to the filesystem.
    But instead of writing the object to disk, we're checking its existence and then
    calling `[file-object].deleteFile()`. All file manipulations in Titanium is done
    in this manner. For example, if you wanted to rename the file, you would simply
    create the object and call the `rename()` method, passing in the new value as
    a string parameter.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed that we gave the trash button a parameter called `zIndex`,
    which we have set to `2`. The `zIndex` defines the stack order of a component.
    Components with a higher `zIndex` will always appear above those with a lower
    `zIndex`. In this case, we've given the trash button an index of `2`, so that
    it appears above the other elements whose default `zIndex` value is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the trash icon visible on our newly saved file,
    and the message alert that appears confirming it''s deletion from the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A full list of the `Titanium.Filesystem.File` methods is available at the Appcelerator''s
    website under the current API documentation, at: [http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.Filesystem.File-object](http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.Filesystem.File-object)'
  prefs: []
  type: TYPE_NORMAL
