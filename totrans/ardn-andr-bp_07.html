<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Voice-activated Arduino"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Voice-activated Arduino</h1></div></div></div><p>In this chapter, we will <a id="id365" class="indexterm"/>use another feature of Android devices to control an Arduino system: voice recognition. We will control a relay that is connected to an Arduino board by sending vocal commands from the phone.</p><p>This relay can be connected to many things. For example, it can be connected to an electric door lock so that you could open and close a door by just speaking into your phone. You can also connect the relay to a lamp, to switch the lamp on and off by giving a vocal command to your phone.</p><p>In this chapter, you will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connect a relay and a Bluetooth module to an Arduino board so that it can be controlled from the Android application</li><li class="listitem" style="list-style-type: disc">Build an application using the Android speech API</li><li class="listitem" style="list-style-type: disc">Control the relay on the Arduino board by voice</li></ul></div><div class="section" title="Hardware and software requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec31"/>Hardware and software requirements</h1></div></div></div><p>The<a id="id366" class="indexterm"/> first thing you will need for this project is an Arduino Uno board.</p><p>Then you will<a id="id367" class="indexterm"/> need a BLE module. We chose the Adafruit nRF8001 chip because it comes with a nice Arduino library and it has already existing examples of Android apps to control the module.</p><p>You will also need a relay module. For this project, we used a 5V relay module from Polulu, which is the same as the one we used in the previous chapters. This is an image of the relay we used for this chapter:</p><div class="mediaobject"><img src="graphics/0389OS_07_01.jpg" alt="Hardware and software requirements"/></div><p>Finally, to make the <a id="id368" class="indexterm"/>different electrical connections, you will also need a breadboard and some jumper wires.</p><p>This is the list <a id="id369" class="indexterm"/>of all hardware parts you will need for this project, along <a id="id370" class="indexterm"/>with links to find these parts on the Web:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id371" class="indexterm"/>Arduino Uno board (<a class="ulink" href="http://www.adafruit.com/product/50">http://www.adafruit.com/product/50</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id372" class="indexterm"/>5V relay module (<a class="ulink" href="http://www.pololu.com/product/2480">http://www.pololu.com/product/2480</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id373" class="indexterm"/>Adafruit nRF8001 breakout board (<a class="ulink" href="https://www.adafruit.com/products/1697">https://www.adafruit.com/products/1697</a>)</li><li class="listitem" style="list-style-type: disc">The<a id="id374" class="indexterm"/> breadboard (<a class="ulink" href="https://www.adafruit.com/product/64">https://www.adafruit.com/product/64</a>)</li><li class="listitem" style="list-style-type: disc">Jumper wires (<a class="ulink" href="https://www.adafruit.com/product/758">https://www.adafruit.com/product/758</a>)</li></ul></div><p>Note that these are all the <a id="id375" class="indexterm"/>components we already used in the previous chapters.</p><p>On the software side, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id376" class="indexterm"/>Arduino IDE (<a class="ulink" href="http://arduino.cc/en/Main/Software">http://arduino.cc/en/Main/Software</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id377" class="indexterm"/>Arduino aREST library (<a class="ulink" href="https://github.com/marcoschwartz/aREST/">https://github.com/marcoschwartz/aREST/</a>)</li><li class="listitem" style="list-style-type: disc">The nRF8001 Arduino library for<a id="id378" class="indexterm"/> the BLE chip (<a class="ulink" href="https://github.com/adafruit/Adafruit_nRF8001">https://github.com/adafruit/Adafruit_nRF8001</a>)</li></ul></div><p>To install a<a id="id379" class="indexterm"/> given<a id="id380" class="indexterm"/> library, simply extract the folder in your <code class="literal">Arduino/libraries</code> folder (or create this folder if it doesn't exist yet).</p><div class="section" title="Configuring the hardware"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Configuring the hardware</h2></div></div></div><p>We will <a id="id381" class="indexterm"/>now build the hardware part of the project. To help you out, the following is the schematic of the project, without the relay being connected yet:</p><div class="mediaobject"><img src="graphics/0389OS_07_02.jpg" alt="Configuring the hardware"/></div><p>Note that these instructions are the same as in the previous chapter. Therefore, you can just use the same configuration if you still have it built on your desk.</p><p>The first step is to place the Bluetooth module on the breadboard. Then, connect the power supply from the Arduino board to the breadboard: 5V of the Arduino board goes to the red power rail and <span class="strong"><strong>GND</strong></span> goes to the blue power rail.</p><p>We will now connect the BLE module. First, connect the power supply of the module: <span class="strong"><strong>GND</strong></span> goes to the blue power rail, and <span class="strong"><strong>VIN</strong></span> goes to the red power rail. After this, you need to connect the different wires responsible for the SPI interface: <span class="strong"><strong>SCK</strong></span> to Arduino pin <span class="strong"><strong>13</strong></span>, <span class="strong"><strong>MISO</strong></span> to Arduino pin <span class="strong"><strong>12</strong></span>, and <span class="strong"><strong>MOSI</strong></span> to Arduino pin <span class="strong"><strong>11</strong></span>. Then connect the <span class="strong"><strong>REQ</strong></span> pin to Arduino pin <span class="strong"><strong>10</strong></span>. Finally, connect the <span class="strong"><strong>RDY</strong></span> pin to Arduino pin <span class="strong"><strong>2</strong></span>, and the <span class="strong"><strong>RST</strong></span> pin to Arduino pin <span class="strong"><strong>9</strong></span>.</p><p>For the relay module, connect the <span class="strong"><strong>VCC</strong></span> pin to the red power rail on the breadboard and the <span class="strong"><strong>GND</strong></span> pin on the blue <a id="id382" class="indexterm"/>power rail. Finally, connect the <span class="strong"><strong>SIG</strong></span> pin of the relay to pin number <span class="strong"><strong>7</strong></span> of the Arduino board.</p><p>The following is an image of an overview of the assembled project (for the precise connections between the elements, refer to the preceding instructions):</p><div class="mediaobject"><img src="graphics/0389OS_07_03.jpg" alt="Configuring the hardware"/></div><p>The close-up image <a id="id383" class="indexterm"/>of the relay and BLE module can be seen as follows:</p><div class="mediaobject"><img src="graphics/0389OS_07_04.jpg" alt="Configuring the hardware"/></div></div></div></div>
<div class="section" title="Writing the Arduino sketch"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Writing the Arduino sketch</h1></div></div></div><p>We will <a id="id384" class="indexterm"/>now write the sketch to control the relay from <a id="id385" class="indexterm"/>an Android device. Note that this is the same sketch as in the previous chapter, so you can skip it if you already did this part for the last chapter. The following is the complete sketch<a id="id386" class="indexterm"/> for<a id="id387" class="indexterm"/> this part:</p><div class="informalexample"><pre class="programlisting">// Control Arduino board from BLE

// Libraries
#include &lt;SPI.h&gt;
#include "Adafruit_BLE_UART.h"
#include &lt;aREST.h&gt;

// Pins
#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2   // Should be pin 2 or 3
#define ADAFRUITBLE_RST 9

// Relay pin
const int relay_pin = 7;

// Create aREST instance
aREST rest = aREST();

// BLE instance
Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);

void setup(void)
{  
  // Start Serial
  Serial.begin(115200);

  // Start BLE
  BTLEserial.begin();
 
  // Give name and ID to device
  rest.set_id("001");
  rest.set_name("relay_control");
  
   // Init relay pin
  pinMode(relay_pin,OUTPUT);
}

void loop() {  
  
  // Tell the nRF8001 to do whatever it should be working on.
  BTLEserial.pollACI();
  
  // Ask what is our current status
  aci_evt_opcode_t status = BTLEserial.getState();
  
  // Handle REST calls
  if (status == ACI_EVT_CONNECTED) {
    rest.handle(BTLEserial);
  }
 }</pre></div><p>Now, let's see<a id="id388" class="indexterm"/> the details of the sketch. It starts by importing the required libraries for the nRF8001 module and the aREST library:</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;
#include "Adafruit_BLE_UART.h"
#include &lt;aREST.h&gt;</pre></div><p>Then we will <a id="id389" class="indexterm"/>define which pin the BLE module is connected to:</p><div class="informalexample"><pre class="programlisting">#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3
#define ADAFRUITBLE_RST 9</pre></div><p>We also need to declare which pin the relay is connected to:</p><div class="informalexample"><pre class="programlisting">const int relay_pin = 7;</pre></div><p>After this, we can create an instance of the aREST API that will be used to handle the requests coming via Bluetooth:</p><div class="informalexample"><pre class="programlisting">aREST rest = aREST();</pre></div><p>We will also create an instance of the nRF8001 chip library:</p><div class="informalexample"><pre class="programlisting">Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);</pre></div><p>Now, in the <code class="literal">setup()</code> function of the sketch, we will initialize serial communications and print a welcome message as follows:</p><div class="informalexample"><pre class="programlisting">BTLEserial.begin();</pre></div><p>We will also give a name to the device:</p><div class="informalexample"><pre class="programlisting">rest.set_id("001");
rest.set_name("relay_control");</pre></div><p>Finally, we will set the relay pin so it becomes an output:</p><div class="informalexample"><pre class="programlisting">pinMode(relay_pin,OUTPUT);</pre></div><p>Now, in the <code class="literal">loop()</code> function of the sketch, we will check the status of the BLE chip:</p><div class="informalexample"><pre class="programlisting">BTLEserial.pollACI();
aci_evt_opcode_t status = BTLEserial.getState();</pre></div><p>Then, if any device is connected to the chip, we will process any incoming request with the aREST library:</p><div class="informalexample"><pre class="programlisting">if (status == ACI_EVT_CONNECTED) {
  rest.handle(BTLEserial);
}</pre></div><p>Note that all the code <a id="id390" class="indexterm"/>for this chapter can be found in the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p><p>It's now time<a id="id391" class="indexterm"/> to upload <a id="id392" class="indexterm"/>the sketch to your Arduino board. When this is done, you can move on to the development of the Android app to control the Arduino board via the BLE sketch.</p><div class="section" title="Setting up the Android app"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Setting up the Android app</h2></div></div></div><p>In this project, we<a id="id393" class="indexterm"/> will be implementing an Android app that leverages the use of the Speech Recognition API and we are going output that text in an <code class="literal">EditText</code> field. In the background, we will also include the BLE services in order to connect to the BLE module and be able to send messages to it. Once we have the BLE and Speech Recognition API set up, we will be able to connect them both by setting up conditions where if the speech is recognized as <code class="literal">switch on</code>, it will switch on the relay, whereas if <code class="literal">switch off</code> is recognized, the relay will be switched off.</p><p>We will assume that you will switch on the <code class="literal">Auto-Import</code> function within your preferences. If not, kindly activate it by going to the <span class="strong"><strong>Auto-Import</strong></span> preferences and selecting all the available options. The <span class="strong"><strong>Auto-Import</strong></span> preferences are available on Mac and Windows as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On a Mac, navigate to <span class="strong"><strong>Android Studio</strong></span> &gt; <span class="strong"><strong>Preferences</strong></span> &gt; <span class="strong"><strong>Editor</strong></span> &gt; <span class="strong"><strong>Auto-Import</strong></span></li><li class="listitem" style="list-style-type: disc">On Windows, navigate to <span class="strong"><strong>File</strong></span> &gt; <span class="strong"><strong>Settings</strong></span> &gt; <span class="strong"><strong>Editor</strong></span> &gt; <span class="strong"><strong>Auto-Import</strong></span></li></ul></div><p>With all the necessary settings in place, we will first start off by creating a new project where we will choose the following within the <span class="strong"><strong>New Project</strong></span> setup:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Name</strong></span>: <code class="literal">Talk to Arduino</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Minimum SDK</strong></span>: <code class="literal">18</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Project</strong></span>: <code class="literal">Blank Activity</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Activity Name</strong></span>: <code class="literal">MainScreen</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Domain</strong></span>: <code class="literal">arduinoandroid.com</code></li></ul></div><p>In order to make this <a id="id394" class="indexterm"/>project work, we will need to first go over to the Android <code class="literal">Manifest</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">ma</code>
<code class="literal">in</code> &gt; <code class="literal">AndroidManifest.xml</code>.</p></div><div class="section" title="Laying out the Android user interface and permissions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Laying out the Android user interface and permissions</h2></div></div></div><p>Once we open the file, we need <a id="id395" class="indexterm"/>to add permissions for <a id="id396" class="indexterm"/>access to Bluetooth functionality; this will allow us to transmit the voice messages to the Arduino. The following two lines of XML need to be added to the Android <code class="literal">Manifest</code> file:</p><div class="informalexample"><pre class="programlisting">    &lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;</pre></div><p>The next step that we will take is to set up the very basic Android layout file so that we are able to implement the app's functions and to allow the user to activate the voice recognition intent.</p><p>In our project, we will navigate to the main layout file, which can be accessed from <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_speech.xml</code>.</p><p>By replacing the current code with the following, we will add a relative layout with two buttons, an <code class="literal">EditText</code> field and a <code class="literal">TextView</code> field, which will allow us to see the outcome of our voice input:</p><div class="informalexample"><pre class="programlisting">&lt;RelativeLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin"
    tools:context=".SpeechActivity"&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Talk to Arduino"
        android:id="@+id/talktoArduino"
        android:layout_centerVertical="true"
        android:layout_centerHorizontal="true" /&gt;

    &lt;EditText
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/recordedTalk"
        android:text="What is recorded will be written here"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        android:layout_marginBottom="139dp" /&gt;

    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceSmall"
        android:text="Bluetooth Output"
        android:id="@+id/btView"
        android:layout_marginTop="76dp"
        android:layout_alignParentTop="true"
        android:layout_centerHorizontal="true" /&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Refresh"
        android:id="@+id/refreshBtn"
        android:layout_above="@+id/talktoArduino"
        android:layout_alignStart="@+id/talktoArduino"
        android:layout_alignEnd="@+id/talktoArduino" /&gt;
&lt;/RelativeLayout&gt;</pre></div></div><div class="section" title="Coding the app's internals"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Coding the app's internals</h2></div></div></div><p>We will then <a id="id397" class="indexterm"/>move on to the <code class="literal">MainScreen.java</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">java</code> &gt; <code class="literal">package name</code> &gt; <code class="literal">MainScreen.java</code>.</p><p>We will then replace the current code with the following code, which we will walk through step-by-step and with <span class="strong"><strong>Auto-import</strong></span> enabled; Android Studio will automatically import all the statements that we will need for our project.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Feel free to follow along the project through the GitHub repository where all the source is available for the users of our book in its entirety. The repository is available at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints/tree/master/chapter7/TalktoArduino">https://github.com/marcoschwartz/arduino-android-blueprints/tree/master/chapter7/TalktoArduino</a>.</p></div></div><p>We will start off by declaring the class that extends <code class="literal">Activity</code>:</p><div class="informalexample"><pre class="programlisting">public class SpeechActivity extends Activity {</pre></div><p>The following are all the variables that are needed to be declared in order to work with the BLE module, log<a id="id398" class="indexterm"/> tag for logging purposes, user interface elements, and Bluetooth characteristics for voice recognition requests:</p><div class="informalexample"><pre class="programlisting">    private static final int VOICE_RECOGNITION_REQUEST = 1;

    //Getting the name for Log Tags
    private final String LOG_TAG = SpeechActivity.class.getSimpleName();

    //Declare U.I Elements
    private Button startTalk;
    private Button refresh;
    private EditText speechInput;
    private TextView btv;

    // UUIDs for UAT service and associated characteristics.
    public static UUID UART_UUID = UUID.fromString("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID TX_UUID = UUID.fromString("6E400002-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID RX_UUID = UUID.fromString("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");
    // UUID for the BTLE client characteristic which is necessary for notifications.
    public static UUID CLIENT_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");

    // BTLE stateta
    private BluetoothAdapter adapter;
    private BluetoothGatt gatt;
    private BluetoothGattCharacteristic tx;
    private BluetoothGattCharacteristic rx;

    private boolean areServicesAccessible = false;</pre></div><p>In the <code class="literal">OnCreate()</code> method, we will initialize the user interface layout that we implemented earlier and connect the user interface elements to the different methods within our code:</p><div class="informalexample"><pre class="programlisting">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_speech);
        startTalk = (Button) findViewById(R.id.talktoArduino);
        refresh = (Button) findViewById(R.id.refreshBtn);
        speechInput = (EditText) findViewById(R.id.recordedTalk);
        btv = (TextView) findViewById(R.id.btView);


        startTalk.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                recordSpeech();
            }
        });

        refresh.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                restartScan();
            }
        });

    }</pre></div><p>The <code class="literal">recordSpeech()</code> method <a id="id399" class="indexterm"/>allows us to launch the Google speech recognition intent where we can modify the message that we will show the user. In this case, we decided to replace the default text with the prompt, "You can now send a command to the Arduino":</p><div class="informalexample"><pre class="programlisting">    public void recordSpeech() {

        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);

        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);

        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, "You can now send a command to the Arduino");

        startActivityForResult(intent, VOICE_RECOGNITION_REQUEST);
    }</pre></div><p>The <code class="literal">onActivityResult()</code> method allows the application to process what has been recognized and implement methods <a id="id400" class="indexterm"/>based on what has been received. In the following method, we will take the speech that has been recognized, output it in the <code class="literal">EditText</code> field that we set up earlier and, depending on the output, we will send the commands via BLE to switch on or switch off the relay:</p><div class="informalexample"><pre class="programlisting">    @Override

    protected void onActivityResult(int requestCode, int resultCode, Intent data) {

        if (requestCode == VOICE_RECOGNITION_REQUEST &amp;&amp; resultCode == RESULT_OK) {

            ArrayList&lt;String&gt; matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);

            String userInput = matches.get(0);

            TextView textSaid = (TextView) findViewById(R.id.recordedTalk);

            textSaid.setText(matches.get(0));

            //add an if else loop or case statement

            if (userInput.equalsIgnoreCase("switch on")) {
                String setOutputMessage = "/digital/7/1 /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeSensorData("Sent: " + setOutputMessage);
                } else {
                    writeSensorData("Couldn't write TX characteristic!");
                }
            } else if (userInput.equalsIgnoreCase("switch off")) {
                String setOutputMessage = "/digital/7/0 /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeSensorData("Sent: " + setOutputMessage);
                } else {
                    writeSensorData("Couldn't write TX characteristic!");
                }
            }

        }
        super.onActivityResult(requestCode, resultCode, data);
    }</pre></div><p>The following code deals with making sure the Bluetooth callback output is being sent to its associated <code class="literal">TextView</code>:</p><div class="informalexample"><pre class="programlisting">    private void writeSensorData(final CharSequence text) {
        Log.e(LOG_TAG, text.toString());
        btv.setText(text.toString());
    }</pre></div><p>Here, we will deal <a id="id401" class="indexterm"/>with all the <code class="literal">BluetoothGattCallback</code> class that needs to be implemented to connect to the BLE module:</p><div class="informalexample"><pre class="programlisting">    // BTLE device scanning bluetoothGattCallback.

    // Main BTLE device bluetoothGattCallback where much of the logic occurs.
    private BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {
        // Called whenever the device connection state changes, i.e. from disconnected to connected.
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            super.onConnectionStateChange(gatt, status, newState);
            if (newState == BluetoothGatt.STATE_CONNECTED) {
                writeSensorData("Connected!");
                // Discover services.
                if (!gatt.discoverServices()) {
                    writeSensorData("Failed to start discovering services!");
                }
            } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
                writeSensorData("Disconnected!");
            } else {
                writeSensorData("Connection state changed.  New state: " + newState);
            }
        }

        // Called when services have been discovered on the remote device.
        // It seems to be necessary to wait for this discovery to occur before
        // manipulating any services or characteristics.
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            super.onServicesDiscovered(gatt, status);
            if (status == BluetoothGatt.GATT_SUCCESS) {
                writeSensorData("Service discovery completed!");
            } else {
                writeSensorData("Service discovery failed with status: " + status);
            }
            // Save reference to each characteristic.
            tx = gatt.getService(UART_UUID).getCharacteristic(TX_UUID);
            rx = gatt.getService(UART_UUID).getCharacteristic(RX_UUID);

            // Setup notifications on RX characteristic changes (i.e. data received).
            // First call setCharacteristicNotification to enable notification.
            if (!gatt.setCharacteristicNotification(rx, true)) {
                writeSensorData("Couldn't set notifications for RX characteristic!");
            }

            // Next update the RX characteristic's client descriptor to enable notifications.
            if (rx.getDescriptor(CLIENT_UUID) != null) {
                BluetoothGattDescriptor desc = rx.getDescriptor(CLIENT_UUID);
                desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
                if (!gatt.writeDescriptor(desc)) {
                    writeSensorData("Couldn't write RX client descriptor value!");
                }
            } else {
                writeSensorData("Couldn't get RX client descriptor!");
            }
            areServicesAccessible = true;
        }
    };</pre></div><p>In the following <code class="literal">onStart()</code> and <code class="literal">onStop()</code> methods, we are making sure that we start scanning of BLE devices<a id="id402" class="indexterm"/> and that Bluetooth scanning stops when we close the application so as to prevent the battery drain and ensure optimization of device memory resources for tasks running in the foreground:</p><div class="informalexample"><pre class="programlisting">    protected void onStart() {
        Log.d(LOG_TAG,"onStart has been called");
        super.onStart();
        // / Scan for all BTLE devices.
        // The first one with the UART service will be chosen--see the code in the scanCallback.
        adapter = BluetoothAdapter.getDefaultAdapter();
        startScan();
    }

    //When this Activity isn't visible anymore
    protected void onStop() {
        Log.d(LOG_TAG,"onStop has been called");
        //disconnect and close Bluetooth Connection for better reliability
        if (gatt != null) {
            gatt.disconnect();
            gatt.close();
            gatt = null;
            tx = null;
            rx = null;
        }
        super.onStop();
    }</pre></div><p>The following methods deal with the starting, stopping, and restarting of the Bluetooth scan callback:</p><div class="informalexample"><pre class="programlisting">    private void startScan() {
        if (!adapter.isEnabled()) {
            adapter.enable();
        }
        if (!adapter.isDiscovering()) {
            adapter.startDiscovery();
        }
        writeSensorData("Scanning for devices...");
        adapter.startLeScan(scanCallback);
    }

    private void stopScan() {
        if (adapter.isDiscovering()) {
            adapter.cancelDiscovery();
        }
        writeSensorData("Stopping scan");
        adapter.stopLeScan(scanCallback);
    }

    private void restartScan() {
        stopScan();
        startScan();
    }</pre></div><p>The <code class="literal">scanCallback()</code> method is concerned mostly with the main logic to get the Bluetooth device addresses <a id="id403" class="indexterm"/>and maintain the necessary connections between the Android device and BLE module:</p><div class="informalexample"><pre class="programlisting">    /**
     * Main callback following an LE device scan
     */
    private BluetoothAdapter.LeScanCallback scanCallback = new BluetoothAdapter.LeScanCallback() {
        // Called when a device is found.
        @Override
        public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {
            Log.d(LOG_TAG, bluetoothDevice.getAddress());

            writeSensorData("Found device: " + bluetoothDevice.getAddress());

            // Check if the device has the UART service.
            if (BluetoothUtils.parseUUIDs(bytes).contains(UART_UUID)) {
                // Found a device, stop the scan.
                adapter.stopLeScan(scanCallback);
                writeSensorData("Found UART service!");
                // Connect to the device.
                // Control flow will now go to the bluetoothGattCallback functions when BTLE events occur.
                gatt = bluetoothDevice.connectGatt(getApplicationContext(), false, bluetoothGattCallback);
            }
        }
    };
}</pre></div><p>In contrast to the previous chapters of the book, you will recognize that we have transferred the UUID parsing to a <code class="literal">utility</code> class in order to refactor the code and make our code more readable. In order to create a <code class="literal">utility</code> class, we first need to right-click on our package name and create a new package and call it <code class="literal">Bluetooth</code>.</p><p>After this, we will right-click on the new package, select <span class="strong"><strong>New</strong></span> &gt; <span class="strong"><strong>Java Class</strong></span>, and name the new class as <code class="literal">BluetoothUtils</code>.</p><p>After those two steps, we <a id="id404" class="indexterm"/>will replace the code within the class with the following code:</p><div class="informalexample"><pre class="programlisting">public class BluetoothUtils {

    // Filtering by custom UUID is broken in Android 4.3 and 4.4, see:
    //   http://stackoverflow.com/questions/18019161/startlescan-with-128-bit-uuids-doesnt-work-on-native-android-ble-implementation?noredirect=1#comment27879874_18019161
    // This is a workaround function from the SO thread to manually parse advertisement data.
    public static List&lt;UUID&gt; parseUUIDs(final byte[] advertisedData) {
        List&lt;UUID&gt; uuids = new ArrayList&lt;UUID&gt;();

        int offset = 0;
        while (offset &lt; (advertisedData.length - 2)) {
            int len = advertisedData[offset++];
            if (len == 0)
                break;

            int type = advertisedData[offset++];
            switch (type) {
                case 0x02: // Partial list of 16-bit UUIDs
                case 0x03: // Complete list of 16-bit UUIDs
                    while (len &gt; 1) {
                        int uuid16 = advertisedData[offset++];
                        uuid16 += (advertisedData[offset++] &lt;&lt; 8);
                        len -= 2;
                        uuids.add(UUID.fromString(String.format("%08x-0000-1000-8000-00805f9b34fb", uuid16)));
                    }
                    break;
                case 0x06:// Partial list of 128-bit UUIDs
                case 0x07:// Complete list of 128-bit UUIDs
                    // Loop through the advertised 128-bit UUID's.
                    while (len &gt;= 16) {
                        try {
                            // Wrap the advertised bits and order them.
                            ByteBuffer buffer = ByteBuffer.wrap(advertisedData, offset++, 16).order(ByteOrder.LITTLE_ENDIAN);
                            long mostSignificantBit = buffer.getLong();
                            long leastSignificantBit = buffer.getLong();
                            uuids.add(new UUID(leastSignificantBit,
                                    mostSignificantBit));
                        } catch (IndexOutOfBoundsException e) {
                            // Defensive programming.
                            //Log.e(LOG_TAG, e.toString());
                            continue;
                        } finally {
                            // Move the offset to read the next uuid.
                            offset += 15;
                            len -= 16;
                        }
                    }
                    break;
                default:
                    offset += (len - 1);
                    break;
            }
        }
        return uuids;
    }
}</pre></div><p>Once you <a id="id405" class="indexterm"/>have included this code, you can go ahead and build and run this app on your Android physical device, which is running Android 4.3 or higher and connected to the Internet, due to the fact that most of the speech recognition services work via the Internet.</p><p>When you load the <a id="id406" class="indexterm"/>app, you should start off with something as follows:</p><div class="mediaobject"><img src="graphics/0389OS_07_05.jpg" alt="Coding the app's internals"/></div></div><div class="section" title="How to go further"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>How to go further</h2></div></div></div><p>This base <a id="id407" class="indexterm"/>project offers endless possibilities and you can possibly include other commands that can be recognized and connect other components and sensors in order to enhance the capabilities of your voice-activated app. We hope that with this baseline project, we can inspire you to enhance your projects further on.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Summary</h1></div></div></div><p>Let's summarize what we did in this chapter. As usual, we connected a BLE module to our Arduino board so that it can receive commands via the Android phone. We also connected a simple relay module to the board, to control it via an Android application. Then we designed an application using the Android speech engine to control the relay depending on what the user says to the Android phone.</p><p>In the next chapter, we will use another feature of the Android phone to control Arduino projects: NFC. We will use NFC to control the state of a relay just by putting our phone in front of an Arduino NFC shield.</p></div></body></html>