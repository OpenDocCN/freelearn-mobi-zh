- en: Chapter 7. Adding Reality to Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating physics bodies in the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting contact and collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, you learned about the anatomy of physics simulation
    in games. We have explored various sections of the Physics engine, including its
    integration with games and playing with the basics of the game engine. You have
    learned the ways to create static and dynamic bodies as well. Now, in this chapter,
    our major focus will be on adding some more reality to games by the advanced level
    of physics integration. This includes playing with lots of physics bodies tied
    together with joints. You will also learn the ways to detect the collision between
    two physics bodies. The overall agenda will be to create a mini game in the chapter,
    which will hold together all the recipes and will help in better understanding
    of these sections. The game will be divided into three the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game holding a physics world with some physics bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we will move forward and join those physics bodies with various types of
    joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, finally, you will learn various ways to detect the collision and contact
    between the various physics bodies in the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating physics bodies in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be creating a fresh game project and will set it up
    to be used in all the recipes. The game project will hold together the creation
    of a physics world along with some physics body objects. We will be using these
    physics objects to add joints between them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To develop a mini game using the physics engine, start by creating a new project.
    Open Xcode and go to **File** | **New** | **Project** and navigate to **iOS**
    | **Application** | **SpriteKit Game**. In the popup, provide the product name
    as `Physics Joints` and navigate to **Devices** | **iPhone** and click on **Next**
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Next** and save the project on your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is saved, you should be able to see project settings. In this
    project settings page, just uncheck the **Portrait** from the **Device Orientation**
    section as we are supporting only landscape mode for this game. The final screen
    should look something similar to following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now our project template is ready to hold together some advanced physics behaviors.
    To accommodate these behaviors, we also need to tweak some code in the project.
    Perform the following steps to update the project as per our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `GameScene.m` file available with the code bundle of this chapter;
    this class creates a scene that will be plugged into the game. Remove all the
    code from this class and just add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `initWithSize` method creates an empty scene with specified size. The code
    written inside the `init` function changes the background color of the scene.
    We can tweak the rgb to get the desired background color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now open `GameViewController.m`. Remove all the code from this file and add
    the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now compile and run the app. You should be able to see the background color
    correctly. This will look something similar to following screenshot:![How to do
    it...](img/00108.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we have the background color in place, so let''s add the gravity to the
    world. Open `GameScene.m` and add the following line of code in the end of the
    `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line of code will set the gravity of the world to -0.5, which means all
    the physics objects will experience a force towards the ground in the game scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we have applied some gravitational force to make the objects pulled towards
    the ground. So it''s important to make some boundary to the world, which will
    hold all the objects of the world and prevent them from going off the screen.
    Add the following line of code to add the invisible boundary around the screen
    to hold the physics objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first line, we are creating an edge-based physics boundary object with
    a screen-size frame. This type of physics body does not have any mass or volume
    and they also remain unaffected by forces and impulses. Then we associate the
    object with the physics body of the scene. In the last line, we change the friction
    of the body to 0, to make interaction between objects and the boundary surface
    lossless.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we are all set to create physics bodies in the world. Add the following
    method just after the `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the update method that will be called in each frame of the game execution.
    So all the actions that need regular updates will be coded inside this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's time to create physics objects in the world. All the physics objects are
    referred to as bodies. Now add the following method to create the bodies in the
    physics world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will create two physics bodies, one rectangle and one square.
    We have adjusted the bodies' positions relative to each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the following line of code at the end of the `initWithSize` method
    to add the physics bodies in the game scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are creating the bodies by calling the instance method inside `initWithSize`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, compile and run the app. You should be able to see the two physics bodies
    created in the world and they will fall to the ground because of gravity. This
    will look something similar to following screenshot:![How to do it...](img/00109.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Physics joints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen lots of interesting features of the physics engine. However,
    we can make our games even more interesting by connecting the physics bodies with
    each other using joints. All the physics simulation and forces will be applied
    on the bodies after considering the way they are joined together.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various ways of joining two physics bodies together. They vary based
    on the places and the location of the bodies that are joined. Joints are divided
    into the following types based on the ways they connect bodies with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pin Joint**: This type of joint joins/pins two physics together such that
    they both can independently rotate around their anchor point. The joint will look
    something similar to following diagram:![Getting ready](img/00110.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit Joint**: In this type of joints the bodies always maintain the fix
    maximum distance from each other. This is something like the bodies are connected
    to each other with a rote with a fixed maximum distance which is the length of
    the rope.![Getting ready](img/00111.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Joint**: This type of joint attaches two bodies as if they were connected
    to each other with a spring. This makes them behave in a perfectly elastic manner.
    The length of the spring can be defined by the initial distance between two bodies.![Getting
    ready](img/00112.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sliding Joint**: This type of joint allows to bodies to slide with respect
    to each other. The sliding axis can be explicitly defined by the user.![Getting
    ready](img/00113.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed Joint**: This type of joint fuses the two physics bodies with each
    other through a provided reference point. These joints can be used to create complex
    objects, which can be broken into pieces later.![Getting ready](img/00114.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will open our working project again to integrate and implement all types
    of joints in our project. The following steps will provide the step-by-step ways
    to implement the joints and understand them in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the pin joint, open the `GameScene.m` file and add the following
    function in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first five lines of code, we are creating a rectangular sprite with a
    physics body. We have also specified the collision and the category mask for this
    sprite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, in the following lines of code, we will create square sprite with
    the physics body attached. For this sprite also, we are specifying the category
    and the collision masks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, finally, in last three lines of code, we are attaching the two bodies
    to each other through a pin joint. We've created an object of the `SKPhysicsJointPin`
    class and provided both the rectangle and square bodies to it along with the anchor
    point from which they will be rotating around each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, replace the `createPhysicsBodiesOnScene` function call with `createPinJointOnScene`.
    Add the following code at the end of the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final function should look something similar to following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00115.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, compile and run the project and you should be able to see both the physics
    bodies attached with the pin joint. You can see them attached to each other through
    the anchor point.![How to do it…](img/00116.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will implement the fixed joint; open the `GameScene.m` file, and add
    the following function to implement the fixed joint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have attached two physics bodies together with a fixed joint. In the
    last function, we have provided two bodies and the anchor point to which they
    are attached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, replace the `createPinJointOnScene` function call with `createFixedJointOnScene`.
    Add the following code in the end of the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, compile and run the project and you should be able to see both the physics
    bodies attached by the fixed joint. You will observe that the bodies are attached
    together with the specified anchor point.![How to do it…](img/00117.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to implement the sliding joint in our sample project, open the `GameScene.m`
    file and add the following function at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you will observe that we are creating two physics bodies and in the last
    section we are joining both of them using the slide joint. However, to see slide
    joint in action, we will have to apply impulses on the square body. Add the following
    function to apply an impulse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To add the impulse implementation, we will have to add the following line of
    code at the end of the `createSlidingJointOnScene` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the square body will experience the impulse every 5 seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, replace the `createFixedJointOnScene` function call with `createSlidingJointOnScene`.
    Add the following code at the end of the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, compile and run the project and you should be able to see both the physics
    bodies sliding over each other.![How to do it…](img/00118.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will head towards implementing the spring joint in our sample project.
    Open the `GameScene.m` file and add the following function at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To apply a spring joint between two physics bodies, we have provided two physics
    bodies along with two anchor points as the function parameters. We can also provide
    additional parameters such as damping and frequencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, replace the `createSlidingJointOnScene` function call with `createSpringJointOnScene`.
    Add the following code at the end of the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now compile and run the project and you should be able to see both the physics
    bodies sliding over each other.![How to do it…](img/00119.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next type of joint is the limit joint in our sample project. Now open the
    `GameScene.m` file and add the following function at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the second last section, we are applying the limit joint on both the physics
    bodies that we have created. To apply a limit joint, we have to pass both the
    bodies along with the anchor points that create the joint. Now, when the joint
    object is initialized, we can add the joint to the physics world.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have seen earlier in sliding joint, an extra impulse has been applied
    on one of the bodies. Similarly, here also we have to apply the impulse on the
    square body to test the limit joint behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, replace the `createSpringJointOnScene` function call with `createLimitJointOnScene`.
    Add the following code at the end of the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now compile and run the project and you should be able to see both the physics
    bodies sliding over each other.![How to do it…](img/00120.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detecting contact and collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We apply physics simulation to the bodies by adding the `SKPhysicsBody` function
    to a node. While the scene processes each frame, it performs all the physics-related
    calculations for all the bodies in the scene. It also calculates all the custom
    forces that are applied on any body in the scene, which eventually gives the realistic
    effects in the game. Collision detection is an important part while developing
    any game in the real world because in almost all games we check for the collision
    of two bodies. For example, in any warfare game, we may need to check whether
    a bullet has collided with the player.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various shapes for the physics bodies that can be used to apply physics
    to a scene. These shapes are defined as the personal space of the node. When the
    shape of one node intersects with the shape of another node, the `-didBeginContact`
    method is invoked and physics may be applied. Now, to implement the collision
    detection, we will have to understand the following properties of the physics
    bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`categoryBitMask`: This property defines the category of the physics body.
    We can have custom categories depending on our requirement. For example, in a
    warfare game, we can have player, bullets, and enemies as the categories. All
    the physics bodies can be based on these categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collisionBitMask`: This property adds a mask that defines which physics bodies
    can collide with this physics body. This will help the physics engine to evaluate
    and throw only the required results in the delegate methods. For example, the
    bullets can only collide with enemies, not with any player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contactTestBitMask`: This property defines the mask to specify which categories
    of physics bodies cause intersection notifications with this physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will open our working project again to implement an example dealing
    with collision and contact detection. The following steps will provide the step-by-step
    ways to implement and understand collision detection in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the collision detection, open the `GameScene.m` file and add the
    following function at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we are familiar with code in this function. We will create two physics bodies
    and add them on the scene. Finally, in the last section, we will apply an impulse
    every 5 seconds on the physics body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here we are updating three additional parameters for each of the physics bodies.
    We are updating `categoryBitMask`, `collisionBitMask`, and `contactTestBitMask`
    for the bodies. As explained, we are updating `categoryBitMask` to provide the
    specific categories to the physics bodies. Along with that, we provide the information
    to define which bodies it can detect collision with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have to add the delegate method, which will be invoked when both the
    bodies collide with each other. We have added logs to check the bodies that are
    colliding. We can identify bodies using their `categoryBitMask`.![How to do it…](img/00121.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, replace the `createLimitJointOnScene` function call with `createCollisionDetectionOnScene`.
    Add the following code at the end of the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also we have to subscribe to the delegate callbacks for contact detection.
    To subscribe, add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also have to declare the contact delegate in the interface file. So
    open `GameScene.h` and add the following code at the end of interface declaration
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final code file should look something similar to following screenshot:![How
    to do it…](img/00122.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now compile and run the project and you should be able to see both the physics
    bodies on the screen and logs on the Xcode debug window. You can see that the
    collision has been detected and printed in the logs. You can also notice that
    the collision has been detected between the bodies with category mask as `2` and
    `4`. We have a rectangular body with mask as `2` and square body with mask as
    `4`, which are colliding with each other.![How to do it…](img/00123.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will make the collision detection more intuitive. For this, let''s add
    a label on the screen, which will blink when the bodies collide with each other.
    To do this, add the following line of code at the top just before the `@implementation`
    GameScene code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following lines of code at the start of the `createCollisionDetectionOnScene`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, for fade-in and fade-out of the label on collision, add the following
    line of code at the end of the `didBeginContact` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are checking for the rectangular and square bodies. Once we get a callback
    for the collision of these two bodies, we can fade in the label for a fraction
    of a second and then fade it out again. This will give a nice effect to show when
    the bodies have collided with each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now compile and run the project and you should be able to see both the physics
    bodies attached with the pin joint. You can see them attached to each other through
    the anchor point.![How to do it…](img/00124.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
