<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Using Protocols and Protocol Extensions</h1></div></div></div><p>While watching the presentations from WWDC 2015 about protocol extensions and protocol-oriented programming, I will admit that I was very skeptical. I have worked with object-oriented programming for so long that I was unsure if this new programming paradigm would solve all of the problems that Apple was claiming it would. Since I am not one to let my skepticism get in the way of trying something new, I set up a new project that mirrored the one I was currently working on, but wrote the code using Apple's recommendations for protocol-oriented programming and used protocol extensions extensively in the code. I can honestly say that I was amazed with how much cleaner the new project was compared to the original one. I believe that protocol extensions is going to be one of those defining features that set one programming language apart from the rest. I also believe that many major languages will soon have similar features.</p><p>In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How protocols are used as a type</li><li class="listitem" style="list-style-type: disc">How to implement polymorphism in Swift using protocols</li><li class="listitem" style="list-style-type: disc">How to use protocol extensions</li><li class="listitem" style="list-style-type: disc">Why we would want to use protocol extensions</li></ul></div><p>Protocol extensions are<a class="indexterm" id="id341"/> the backbone for Apple's new protocol-oriented programming paradigm and are arguably one of the most important additions to the Swift programming language. With protocol extensions, we are able to provide method and property implementations to any type that conforms to a protocol. To really understand how useful protocols and protocol extensions are, let's get a better understanding of protocols.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>While classes, structs, and enums can all conform to protocols in Swift, for this chapter, we will be focusing on classes and structs. Enums are used when we need to represent a finite number of cases and while there are valid use cases where we would have an enum conform to a protocol, they are very rare in my experience. Just remember that anywhere that we refer to a class or struct, we can also use an enum.</p></div></div><p>Let's begin exploring protocols by seeing how they are full-fledged types in Swift.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Protocols as types</h1></div></div></div><p>Even though<a class="indexterm" id="id342"/> no functionality is implemented in a protocol, they are still considered a full-fledged type in the Swift programming language and can be used like<a class="indexterm" id="id343"/> any other type. What this means is we can use protocols as a parameter type or a return type in a function. We can also use them as the type for variables, constants, and collections. Let's take a look at some examples. For these few examples, we will use the <code class="literal">PersonProtocol</code> protocol:</p><div><pre class="programlisting">protocol PersonProtocol {
    var firstName: String {get set}
    var lastName: String {get set}
    var birthDate: NSDate {get set}
    var profession: String {get}
    
    init (firstName: String, lastName: String, birthDate: NSDate)
}</pre></div><p>In this first example, we will see how we would use protocols as a parameter type or return type in functions, methods, or initializers:</p><div><pre class="programlisting">  func updatePerson(person: PersonProtocol) -&gt; PersonProtocol {
      // Code to update person goes here
      return person
   }</pre></div><p>In this example, the <code class="literal">updatePerson()</code> function accepts one parameter of the <code class="literal">PersonProtocol</code> protocol type and then returns a value of the <code class="literal">PersonProtocol</code> protocol type. Now let's see how we can use protocols as a type for constants, variables, or properties:</p><div><pre class="programlisting">var myPerson: PersonProtocol</pre></div><p>In this example, we create a variable of the <code class="literal">PersonProtocol</code> protocol type that is named <code class="literal">myPerson</code>. We can also use protocols as the item type to store in collection such as arrays, dictionaries, or sets:</p><div><pre class="programlisting">var people: [PersonProtocol] = []</pre></div><p>In this final example, we create an array of <code class="literal">PersonProtocol</code> protocol types. As we can see from these three<a class="indexterm" id="id344"/> examples, even though the <code class="literal">PersonProtocol</code> protocol does not implement any functionality, we can still use protocols when we need to specify a type. We cannot, however, create an instance of a protocol. This is because no functionality is implemented in a protocol. As an example, if we tried to create an instance of the <code class="literal">PersonProtocol</code> protocol, we would be receiving the <code class="literal">error: protocol type 'PersonProtocol' cannot be instantiated error</code>, as shown in the following example:</p><div><pre class="programlisting">var test = PersonProtocol(firstName: "Jon", lastName: "Hoffman", birthDate: bDateProgrammer)</pre></div><p>We can use the instance of any class or struct that conforms to our protocol anywhere that the protocol type is required. As an example, if we defined a variable to be of the <code class="literal">PersonProtocol</code> protocol type, we could then populate that variable with any class or struct that conforms to the <code class="literal">PersonProtocol</code> protocol. For this example, let's assume that we have two types named <code class="literal">SwiftProgrammer</code> and <code class="literal">FootballPlayer</code>, which conform to the <code class="literal">PersonProtocol</code> protocol:</p><div><pre class="programlisting">var myPerson: PersonProtocol

myPerson = SwiftProgrammer(firstName: "Jon", lastName: "Hoffman", birthDate: bDateProgrammer)
print("\(myPerson.firstName) \(myPerson.lastName)")

myPerson = FootballPlayer(firstName: "Dan", lastName: "Marino", birthDate: bDatePlayer)
print("\(myPerson.firstName) \(myPerson.lastName)")</pre></div><p>In this example, we start off by creating the <code class="literal">myPerson</code> variable of the <code class="literal">PersonProtocol</code> protocol type. We then set the variable with an instance of the <code class="literal">SwiftProgrammer</code> type and print out the first and last names. Next, we set the <code class="literal">myPerson</code> variable to an instance of the <code class="literal">FootballPlayer</code> type and print out the first and last names again. One thing to note is that Swift does not care if the instance is a class or struct. It only matters that the type conforms to the <code class="literal">PersonProtocol</code> protocol type. Therefore, if our <code class="literal">SwiftProgrammer</code> type was a struct and the <code class="literal">FootballPlayer</code> type was a class, our previous example would be perfectly valid.</p><p>As we saw earlier, we can use our <code class="literal">PersonProtocol</code> protocol as the type for an array. This means that we can populate the array with instances of any type that conforms to the <code class="literal">PersonProtocol</code> protocol. Once again, it does not matter if the type is a class or a struct as long as it conforms to the <code class="literal">PersonProtocol</code> protocol. Here is an example of this:</p><div><pre class="programlisting">var programmer = SwiftProgrammer(firstName: "Jon", lastName: "Hoffman", birthDate: bDateProgrammer)

var player = FootballPlayer(firstName: "Dan", lastName: "Marino", birthDate: bDatePlayer)

var people: [PersonProtocol] = []
people.append(programmer)
people.append(player)</pre></div><p>In this example, we<a class="indexterm" id="id345"/> create an instance of the <code class="literal">SwiftProgrammer</code> type and an instance of the <code class="literal">FootballPlayer</code> type. We then add both instances to the <code class="literal">people</code> array.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Polymorphism with protocols</h1></div></div></div><p>What we<a class="indexterm" id="id346"/> were seeing in the previous examples is a form of polymorphism. The word polymorphism comes from the Greek roots <em>Poly</em>, meaning many and <em>morphe</em>, meaning form. In programming languages, polymorphism is a single interface to multiple types (many forms). In the previous example, the single interface was the <code class="literal">PersonProtocol</code> protocol and the multiple types were any type that conforms to that protocol.</p><p>Polymorphism gives us the ability to interact with multiple types in a uniform manner. To illustrate this, we can extend our previous example where we created an array of the <code class="literal">PersonProtocol</code> types and loop through the array. We can then access each item in the array using the properties and methods define in the <code class="literal">PersonProtocol</code> protocol, regardless of the actual type. Let's see an example of this:</p><div><pre class="programlisting">for person in people {
    print("\(person.firstName) \(person.lastName): \(person.profession)")
}</pre></div><p>If we ran this example, the output would look similar to this:</p><div><pre class="programlisting">Jon Hoffman: Swift Programmer
Dan Marino: Football Player</pre></div><p>We have mentioned a few times in this chapter that when we define the type of a variable, constant, collection type, and so on to be a protocol type, we can then use the instance of any type that conforms to that protocol. This is a very important concept to understand and it is what makes protocols and protocol extensions so powerful.</p><p>When we use a protocol to access instances, as shown in the previous example, we are limited to using only properties and methods that are defined in the protocol. If we want to use properties or methods that are specific to the individual types, we would need to cast the instance to that type.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Type casting with protocols</h1></div></div></div><p>Type casting is <a class="indexterm" id="id347"/>a way to check the type of the instance and/or to treat the instance as a specified type. In Swift, we use the <code class="literal">is</code> keyword to check if an instance is a specific type and the <code class="literal">as</code> keyword to treat the instance as a specific type.</p><p>To start with, let's see how we would check the instance type using the <code class="literal">is</code> keyword. The following example shows how would we do this:</p><div><pre class="programlisting">for person in people {
  if person is SwiftProgrammer {
     print("\(person.firstName) is a Swift Programmer")
}
}</pre></div><p>In this example, we use the <code class="literal">if</code> conditional statement to check whether each element in the people array is an instance of the <code class="literal">SwiftProgrammer</code> type and if so, we print that the person is a Swift programmer to the console. While this is a good method to check whether we have an instance of a specific class or struct, it is not very efficient if we wanted to check for multiple types. It is a lot more efficient to use the <code class="literal">switch</code> statement, as shown in the next example, if we want to check for multiple types:</p><div><pre class="programlisting">for person in people {
    switch (person) {
    case is SwiftProgrammer:
        print("\(person.firstName) is a Swift Programmer")
    case is FootballPlayer:
        print("\(person.firstName) is a Football Player")
    default:
        print("\(person.firstName) is an unknown type")
    }
}</pre></div><p>In the previous example, we showed how to use the <code class="literal">switch</code> statement to check the instance type for each element of the array. To do this check, we use the <code class="literal">is</code> keyword in each of the <code class="literal">case</code> statements in an attempt to match the instance type.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Control Flow and Functions">Chapter 4</a>, <em>Control Flow and Functions</em>, we saw how to filter conditional statements with the <code class="literal">where</code> statement. We can also use the <code class="literal">where</code> statement with the <code class="literal">is</code> keyword to filter the array, as shown in the following example:</p><div><pre class="programlisting">for person in people where person is SwiftProgrammer {
    print("\(person.firstName) is a Swift Programmer")

}</pre></div><p>Now let's look at how we can cast an instance of a class or struct to a specific type. To do this, we can use the <code class="literal">as</code> keyword. Since the cast can fail if the instance is not of the specified type, the <code class="literal">as</code> keyword comes in two forms: <code class="literal">as?</code> and <code class="literal">as!</code>. With the <code class="literal">as?</code> form, if the casting fails, it returns<a class="indexterm" id="id348"/> a nil, and with the <code class="literal">as!</code> form, if the casting fails, we get a runtime error; therefore, it is recommended to use the <code class="literal">as?</code> form unless we are absolutely sure of the instance type or we perform a check of the instance type prior to doing the cast.</p><p>Let's look at how we would use the <code class="literal">as?</code> keyword to cast an instance of a class or struct to a specified type:</p><div><pre class="programlisting">for person in people {
    if let p = person as? SwiftProgrammer {
        print("\(person.firstName) is a Swift Programmer")
    }
}</pre></div><p>Since the <code class="literal">as?</code> keyword returns an optional, we can use optional binding to perform the cast, as shown in this example. If we are sure of the instance type, we can use the <code class="literal">as!</code> keyword. The following example shows how to use the <code class="literal">as!</code> keyword when we filter the results of the array to only return instances of the <code class="literal">SwiftProgrammer</code> type:</p><div><pre class="programlisting">for person in people where person is SwiftProgrammer {
  let p = person as! SwiftProgrammer
}</pre></div><p>Now that we have covered the basics of protocols, that is, how polymorphism works and type casting, let's dive into one of the most exciting new features of Swift protocol extensions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Protocol extensions</h1></div></div></div><p>Protocol extensions<a class="indexterm" id="id349"/> allow us to extend a protocol to provide method and property implementations to conforming types. They also allow us to provide common implementations to all the confirming types eliminating the need to provide an implementation in each individual type or the need to create a class hierarchy. While protocol extensions may not seem too exciting, once you see how powerful they really are, they will transform the way you think about and write code.</p><p>Let's begin by looking at how <a class="indexterm" id="id350"/>we would use protocol extension with a very simplistic example. We will start off by defining a protocol called <code class="literal">DogProtocol</code> as follows:</p><div><pre class="programlisting">protocol DogProtocol {
    var name: String {get set}
    var color: String {get set}
}</pre></div><p>With this protocol, we are saying that any type that conforms to the <code class="literal">DogProtocol</code> protocol, must have the two properties of the String type, namely, <code class="literal">name</code> and <code class="literal">color</code>. Now let's define the three types that conform to this protocol. We will name these types <code class="literal">JackRussel</code>, <code class="literal">WhiteLab</code>, and <code class="literal">Mutt</code> as follows:</p><div><pre class="programlisting">struct JackRussel: DogProtocol {
    var name: String
    var color: String
}

class WhiteLab: DogProtocol {
    var name: String
    var color: String
    
    init(name: String, color: String) {
        self.name = name
        self.color = color
    }
}

struct Mutt: DogProtocol {
    var name: String
    var color: String
}</pre></div><p>We purposely <a class="indexterm" id="id351"/>created the <code class="literal">JackRussel</code> and <code class="literal">Mutt</code> types as structs and the <code class="literal">WhiteLab</code> type as a class to show the differences between how the two types are set up and to illustrate how they are treated in the same way when it comes to protocols and protocol extensions. The biggest difference that we can see in this example is the struct types provide a default initiator, but in the class, we must provide the initiator to populate the properties.</p><p>Now let's say that we want to provide a method named <code class="literal">speak</code> to each type that conforms to the <code class="literal">DogProtocol</code> protocol. Prior to protocol extensions, we would start off by adding the method definition to the protocol, as shown in the following code:</p><div><pre class="programlisting">protocol DogProtocol {
    var name: String {get set}
    var color: String {get set}
   func speak() -&gt; String
}</pre></div><p>Once the method is defined in the protocol, we would then need to provide an implementation of the method in every type that conforms to the protocol. Depending on the number of types that conformed to this protocol, this could take a bit of time to implement. The following code sample shows how we might implement this method:</p><div><pre class="programlisting">struct JackRussel: DogProtocol {
    var name: String
    var color: String
     func speak() -&gt; String {
        return "Woof Woof"
    }
}

class WhiteLab: DogProtocol {
    var name: String
    var color: String
    
    init(name: String, color: String) {
        self.name = name
        self.color = color
    }
    func speak() -&gt; String {
        return "Woof Woof"
    }

}

struct Mutt: DogProtocol {
    var name: String
    var color: String
    func speak() -&gt; String {
        return "Woof Woof"
    }

}</pre></div><p>While this method <a class="indexterm" id="id352"/>works, it is not very efficient because anytime we update the protocol, we would need to update all the types that conform to it and we may be duplicating a lot of code, as shown in this example. Another concern is, if we need to change the default behavior of the <code class="literal">speak()</code> method, we would have to go in each implementation and change the <code class="literal">speak()</code> method. This is where protocol extensions come in.</p><p>With protocol extensions, we could take the <code class="literal">speak()</code> method definition out of the protocol itself and define it with the default behavior, in protocol extension. The following code shows how we would define the protocol and the protocol extension:</p><div><pre class="programlisting">protocol DogProtocol {
    var name: String {get set}
    var color: String {get set}
}

extension DogProtocol {
    func speak() -&gt; String {
        return "Woof Woof"
    }
}</pre></div><p>We begin by <a class="indexterm" id="id353"/>defining <code class="literal">DogProtocol</code> with the original two properties. We then create a protocol extension that extends <code class="literal">DogProtocol</code> and contains the default implementation of the <code class="literal">speak()</code> method. With this code, there is no need to provide an implementation of the <code class="literal">speak()</code> method in each of the types that conform to <code class="literal">DogProtocol</code> because they automatically receive the implementation as part of the protocol. Let's see how this works by setting our three types that conform to <code class="literal">DogProtocol</code> back to their original implementations and they should receive the <code class="literal">speak()</code> method from the protocol extension:</p><div><pre class="programlisting">struct JackRussel: DogProtocol {
    var name: String
    var color: String
}
class WhiteLab: DogProtocol {
    var name: String
    var color: String
    
    init(name: String, color: String) {
        self.name = name
        self.color = color
    }
}

struct Mutt: DogProtocol {
    var name: String
    var color: String
}</pre></div><p>We can now use each of the types as shown in the following code:</p><div><pre class="programlisting">let dash = JackRussel(name: "Dash", color: "Brown and White")
let lily = WhiteLab(name: "Lily", color: "White")
let buddy = Mutt(name: "Buddy", color: "Brown")
let dSpeak = dash.speak()  // returns "woof woof"
let lSpeak = lily.speak()  // returns "woof woof"
let bSpeak = buddy.speak() // returns "woof woof"</pre></div><p>As we can see in this example, by adding the <code class="literal">speak()</code> method to the <code class="literal">DogProtocol</code> protocol extension, we are automatically adding that method to all the types that conform to <code class="literal">DogProtocol</code>. The <code class="literal">speak()</code> method in the <code class="literal">DogProtocol</code> protocol extension can be considered a default implementation of the <code class="literal">speak()</code> method because we are able to override it in <a class="indexterm" id="id354"/>the type implementations. As an example, we could override the <code class="literal">speak()</code> method in the <code class="literal">Mutt</code> struct, as shown in the following code:</p><div><pre class="programlisting">struct Mutt: DogProtocol {
    var name: String
    var color: String
    func speak() -&gt; String {
        return "I am hungry"
    }
}</pre></div><p>When we call the <code class="literal">speak()</code> method for an instance of the <code class="literal">Mutt</code> type, it will return the string, <code class="literal">"I am hungry"</code>.</p><p>Now that we have seen how we would use protocols and protocol extensions, let's look at a more real-world example. In numerous apps across multiple platforms (iOS, Android, and Windows), I have had the requirement to validate user input as it is entered. This validation can be done very easily with regular expressions; however, we do not want various regular expressions littered throughout our code. It is very easy to solve this problem by creating different classes or structs that contains the validation code; however, we would have to organize these classes to make them easy to use and maintain. Prior to protocol extensions in Swift, I would use protocols to define the validation requirements and then create a struct that would conform to the protocol for each validation that I needed. Let's take a look at this preprotocol extension method.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>A regular expression is a sequence of characters that define a particular pattern. This pattern can then be used to search a string to see whether the string matches the pattern or contains a match of the pattern. Most major programming languages contain a regular expression parser, and if you are not familiar with regular expressions, it may be worthwhile to learn more about them.</p></div></div><p>The following code shows the <a class="indexterm" id="id355"/>
<code class="literal">TextValidationProtocol</code> protocol that defines the requirements for any type that we want to use for text validation:</p><div><pre class="programlisting"> protocol TextValidationProtocol {

    var regExMatchingString: String {get}
    var regExFindMatchString: String {get}
    var validationMessage: String {get}
    
    func validateString(str: String) -&gt; Bool
    func getMatchingString(str: String) -&gt; String?
}</pre></div><p>In this protocol, we define three properties and two methods that any type that conforms to <code class="literal">TextValidationProtocol</code> must implement. The three properties are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">regExMatchingString</code>: This <a class="indexterm" id="id356"/>is a regular expression string used to verify that the input string contains only valid characters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">regExFindMatchString</code>: This <a class="indexterm" id="id357"/>is a regular expression string used to retrieve a new string from the input string that contains only valid characters. This regular expression is generally used when we need to validate the input in real time, as the user enters information, because it will find the longest matching prefix of the input string.</li><li class="listitem" style="list-style-type: disc"><code class="literal">validationMessage</code>: This <a class="indexterm" id="id358"/>is the error message to display if the input string contains non-valid characters.</li></ul></div><p>The two methods for this protocol are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">validateString</code>: This<a class="indexterm" id="id359"/> method will return <code class="literal">true</code> if the input string contains only valid characters. The <code class="literal">regExMatchingString</code> property will be used in this method to perform the match.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getMatchingString</code>: This <a class="indexterm" id="id360"/>method will return a new string that contains only valid characters. This method is generally used when we need to validate the input real time as the user enters information because it will find the longest matching prefix of the input string. We will use the <code class="literal">regExFindMatchString</code> property in this method to retrieve the new string.</li></ul></div><p>Now let's see how <a class="indexterm" id="id361"/>we would create a struct that conforms to this protocol. The following struct would be used to verify that the input string contains only alpha characters:</p><div><pre class="programlisting">struct AlphaValidation1: TextValidationProtocol {
    static let sharedInstance = AlphaValidation1()
    private init(){}
    
    let regExFindMatchString = "^[a-zA-Z]{0,10}"
    let validationMessage = "Can only contain Alpha characters"
    
    var regExMatchingString: String { get {
        return regExFindMatchString + "$"
        }
    }
    
    func validateString(str: String) -&gt; Bool {
        if let _ = str.rangeOfString(regExMatchingString, options: .RegularExpressionSearch) {
            return true
        } else {
            return false
        }
    }
    func getMatchingString(str: String) -&gt; String? {
        if let newMatch = str.rangeOfString(regExFindMatchString, options: .RegularExpressionSearch) {
            return str.substringWithRange(newMatch)
        } else {
            return nil
        }
    }
}</pre></div><p>In this implementation, the <code class="literal">regExFindMatchString</code> and <code class="literal">validationMessage</code> properties are stored properties, and the <code class="literal">regExMatchingString</code> property is a computed property. We also implement the <code class="literal">validateString()</code> and <code class="literal">getMatchingString()</code> methods within the struct.</p><p>Normally, we<a class="indexterm" id="id362"/> would have several different types that conform to <code class="literal">TextValidationProtocol</code> where each one would validate a different type of input. As we can see from the <code class="literal">AlphaValidation1</code> struct, there is a bit of code involved with each validation type. A lot of the code would also be duplicated in each type. The code for both methods (<code class="literal">validateString()</code> and <code class="literal">getMatchingString()</code>) and the <code class="literal">regExMatchingString</code> property would be duplicated in every validation class. This is not ideal, but if we wanted to avoid creating a class hierarchy with a super class that contains the duplicate code (I personally prefer using value types over classes), we would have no other choice. Now let's see how we would implement this using protocol extensions.</p><p>With protocol extensions, we need to think about the code a little differently. The big difference is, we neither need, nor want to define everything in the protocol. With standard protocols or when we use class hierarchy, all the methods and properties that you would want to access using the generic superclass or protocol would have to be defined within the superclass or protocol. With protocol extensions, it is preferable for us not to define a property or method in the protocol if we are going to be defining it within the protocol extension. Therefore, when we rewrite our text validation types with protocol extensions, <code class="literal">TextValidationProtocol</code> would be greatly simplified to look similar to this:</p><div><pre class="programlisting">protocol TextValidationProtocol {
    var regExFindMatchString: String {get}
    var validationMessage: String {get}
}</pre></div><p>In original <code class="literal">TextValidationProtocol</code>, we defined three properties and two methods. As we can see in this new protocol, we are only <a class="indexterm" id="id363"/>defining two properties. Now that we have our <code class="literal">TextValidationProtocol</code> defined, let's create the protocol extension for it:</p><div><pre class="programlisting">extension TextValidationProtocol {
    
    var regExMatchingString: String { get {
        return regExFindMatchString + "$"
        }
    }
    
    func validateString(str: String) -&gt; Bool {
        if let _ = str.rangeOfString(regExMatchingString, options: .RegularExpressionSearch) {
            return true
        } else {
            return false
        }
    }
    func getMatchingString(str: String) -&gt; String? {
        if let newMatch = str.rangeOfString(regExFindMatchString, options: .RegularExpressionSearch) {
            return str.substringWithRange(newMatch)
        } else {
            return nil
        }
    }
}</pre></div><p>In the <code class="literal">TextValidationProtocol</code> protocol extension, we define the two methods and the third property that were defined in original <code class="literal">TextValidationProtocol</code>, but were not defined in the new one. Now that we have created our protocol and protocol extension, we are able to define our text validation types. In the following code, we define three structs that we will use to validate text when a user types it in:</p><div><pre class="programlisting">struct AlphaValidation: TextValidationProtocol {
    static let sharedInstance = AlphaValidation()
    private init(){}
    
    let regExFindMatchString = "^[a-zA-Z]{0,10}"
    let validationMessage = "Can only contain Alpha characters"
}

struct AlphaNumericValidation: TextValidationProtocol {
    static let sharedInstance = AlphaNumericValidation()
    private init(){}
    
    let regExFindMatchString = "^[a-zA-Z0-9]{0,15}"
    let validationMessage = "Can only contain Alpha Numeric characters"
}


struct DisplayNameValidation: TextValidationProtocol {
    static let sharedInstance = DisplayNameValidation()
    private init(){}
    
    let regExFindMatchString = "^[\\s?[a-zA-Z0-9\\-_\\s]]{0,15}"
    let validationMessage = "Display Name can contain only contain Alphanumeric Characters"
}</pre></div><p>In each one of <a class="indexterm" id="id364"/>the text validation structs, we create a static constant and a private initiator so that we can use the struct as a singleton. For more information on the singleton pattern, please see the <em>The Singleton design pattern</em> section of <a class="link" href="ch17.html" title="Chapter 17. Adopting Design Patterns in Swift">Chapter 17</a>, <em>Adopting Design Patterns in Swift</em>.</p><p>After we define the singleton pattern, all we do in each type is set the values for the <code class="literal">regExFindMatchString</code> and <code class="literal">validationMessage</code> properties. Now, we have not duplicated the code virtually because even if we could, we would not want to define the singleton code in the protocol extension because we would not want to force that pattern on all the conforming types.</p><p>To use the text validation classes, we would want to create a dictionary object that would map the <code class="literal">UITextField</code> objects to the validation class to use it like this:</p><div><pre class="programlisting">var validators = [UITextField: TextValidationProtocol]()</pre></div><p>We could then populate the <code class="literal">validators</code> dictionary as shown here:</p><div><pre class="programlisting">validators[alphaTextField] = AlphaValidation.sharedInstance

validators[alphaNumericTextField] = AlphaNumericValidation.sharedInstance

validators[displayNameTextField] = DisplayNameValidation.sharedInstance</pre></div><p>We can now set the <code class="literal">EditingChanged</code> event of the text fields to a single method named <code class="literal">keyPressed()</code>. To set the edition changed event for each field, we would add the following code to the <code class="literal">viewDidLoad()</code> method of our view controller:</p><div><pre class="programlisting">alphaTextField.addTarget(self,   action:Selector("keyPressed:"), forControlEvents: UIControlEvents.EditingChanged)
alphaNumericTextField.addTarget(self, action: Selector("keyPressed:"), forControlEvents: UIControlEvents.EditingChanged)
displayNameTextField.addTarget(self, action:           Selector("keyPressed:"), forControlEvents: UIControlEvents.EditingChanged)</pre></div><p>Now let's create the <code class="literal">keyPressed()</code> method that each text field calls when a user types a character into the field:</p><div><pre class="programlisting">@IBAction func keyPressed(textField: UITextField) {
        if let validator = validators[textField] where !validator.validateString(textField.text!) {
            textField.text = validator.getMatchingString(textField.text!)
            messageLabel?.text = validator.validationMessage
        }
    }</pre></div><p>In this method, we <a class="indexterm" id="id365"/>use the <code class="literal">if let validator = validators[textField]</code> statement to retrieve the validator for the particular text field and then we use the <code class="literal">where !validator.validateString(textField.text!)</code> statement to validate the string that the user has entered. If the string fails validation, we use the <code class="literal">getMatchingString()</code> method to update the text in the text field by removing all the characters from the input string, starting with the first invalid character and then displaying the error message from the text validation class. If the string passes validation, the text in the text field is left unchanged.</p><p>In the downloadable code for this book, you will find a sample project that demonstrates how to use the text validation types.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we saw that protocols are treated as full-fledged types by Swift. We also saw how polymorphism can be implemented in Swift with protocols. We concluded this chapter with an in-depth look at protocol extensions and saw how we would use them in Swift.</p><p>Protocols and protocol extensions are the backbone of Apple's new protocol-oriented programming paradigm. This new model for programming has the potential to change the way we write and think about code. While we did not specifically cover protocol-oriented programming in this chapter, understanding the topics in this chapter gives us the solid understanding of protocols and protocol extensions needed to learn about this new programming model.</p></div></body></html>