- en: Chapter 8. Testing – Let's Fail Gracefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Truth will sooner come out from error than from confusion."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*—*Francis Bacon**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to maintain high quality of a software product, testing is a very
    important part of the software development life cycle. In this chapter we will
    learn how we can test RubyMotion applications. We will learn to write unit tests,
    which can test an isolated code, and then learn functional testing, which will
    help us automate the UI tests. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of unit testing is to isolate each part of the program and show that
    the individual parts function properly. RubyMotion uses MacBacon, which is an
    iOS flavor of Bacon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bacon is a smaller clone of RSpec. With less than 350 LOCs, we nevertheless
    get all the essential features.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will also follow **Test Driven Development** (**TDD**), a way of working
    where unit tests are created before the code itself is written. Of course, the
    tests will fail initially because we don't have anything. That's the philosophy
    of TDD; first we write the test case, it fails, we then refractor our code and
    once again write the feature code, and this time our test cases pass and the code
    is considered complete.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that the developer himself wears the hat of a tester. We first
    document the feature in the form of a test, which fails, then we write our code
    and refractor, and once again document with a test case for the next feature.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create an application, which we will be using to learn how to write
    test cases for use with TDD.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the folder structure, we can see a `spec` folder and a file `main_spec.rb`
    placed inside this folder. This is the default test file generated by the RubyMotion
    generator; this is where we write our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our first test case in the `main_spec.rb file` inside the `spec`
    folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Bacon gives you a way to encapsulate what you''re testing via the `describe`
    block. As the name suggests, the `describe` block is used to describe the behavior
    of a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Tests are written using the `it` block. The test has a window, which checks
    if our application has a window as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax of these tests is very readable and you can easily
    understand what it means. In this case, `@app.windows.size.should == 1` means
    that your application should have one window.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe()` method clasps into the Bacon API and gives us the `Spec::ExampleGroup`
    class. As the name suggests, it is a group of examples. These examples are actually
    the expected behavior of the object. If you're familiar with the xUnit tools such
    as `Test::Unit`, you can think of an `ExampleGroup` class as being akin to a test
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the test case with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that one test failed (`Bacon::Error: 0.==(1)`). That is exactly
    what we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that `@app.windows.size` should expect the value as 1 but the actual
    value right now is 0\. This is because till now we have not created a window in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s write the code to create a window and update the `app_delegate.rb`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `specs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We see that our test has passed and the code is therefore complete; mission
    accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some commonly used assertions with MacBacon:'
  prefs: []
  type: TYPE_NORMAL
- en: '`should.` and `should.be`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.equal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.match`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.be.identical_to`/`should.be.same_as`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.raise(*exceptions) { }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.change { }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.throw(symbol) { }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should.satisfy { |object| }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s create one more test by adding the following code to your `main_spec.rb`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This test checks whether we have the `rootViewController` property in our application
    whose name should be `RootViewController`. Run this test case and it should fail,
    as we have not yet created `RootViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file `root_view_controller.rb` in the `app` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also update the `app_delegate.rb` file by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now when we run the `specs file`, we will find that all the test cases are passed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add some functionality to our application. How about we calculate
    the sum of the squares of numbers? Let's first write the tests for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `specs` code to the `main_spec.rb` file in the `spec` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, they will surely fail, as we have not yet created the
    `sum_of_square_number` method. So let''s create this method and its logic so that
    our `specs` tests pass, update the `root_view_controller.rb` file, and add the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time, when we run our `specs` tests they will pass.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have learned about testing a piece of code, but it is equally important
    that we test the user interface, so in the next section we will write a functional
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create multiple files in your `spec` folder. RubyMotion automatically
    runs all the files with the `.rb` extension. You can also run individual files
    even from different locations with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RubyMotion lets us write functional tests for our controllers and interacts
    with its views through a set of high-level event generating APIs, by leveraging
    the functionality of Apple's `UIAutomation` framework without forcing us to write
    the tests in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now write tests for user interface of the same application. In the following
    test case, we will test whether we have a label and a button on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `spec` file `restro_view_controller_spec.rb` in the `spec` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`The view(label)` property returns the view that matches the specified accessibility
    label. The `view` command traverses down through the view hierarchy, starting
    from the current window. If no view matches our condition, it keeps retrying it
    until the timeout, which defaults to three seconds. This means you don''t need
    to worry about whether or not the view you''re looking for is still being loaded
    or animated.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the timeout passes and no view matches, an exception will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: The default timeout value can be changed through the `Bacon::Functional.default_timeout`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also check what buttons are available on view with the classname as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to pass this test, let''s write the code for this functionality and update
    the file `root_view_controller.rb` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fire up the terminal and run the application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional testing](img/5220OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created a label and a button in this View and now, when we run our
    `spec test`, it passes. Next, we want to calculate the sum of the squares of the
    first 5 numbers on click of a button. Let''s first write the `spec` code for this
    functionality. Update the file `restro_view_controller_spec.rb` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `tap` command clicks on the button with the label **Click Me**. There are
    many options available with the `tap` command. We will know more about them as
    we proceed with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the corresponding code for this `spec` test and update the
    file `root_view_controller.rb` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fire up the terminal and test our application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional testing](img/5220OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are now familiar with the basic functioning of testing. Next, we will learn
    how to test the device events with RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: Device events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the iOS applications make use of the various device capabilities. As
    a good practice, we must test these features to deliver high quality apps. RubyMotion
    gives us an environment to test some device capabilities. Let's discuss a few
    of them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Rotate device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can test the rotation of the device by calling the following event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rotate_device` command allows us to pass the following two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to`: This passes the orientation to rotate the device; it can either have
    portrait or landscape as a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button`: The `button` here indicates the position of the **home** button;
    it makes sense if we pass the values based on the first value of orientation.
    In portrait mode, we can opt for the `:bottom` or `:top button` location. In landscape
    mode, we can opt for `:left` or `:right` with respect to the button location,
    for example, `rotate_device` `:to` => `:portrait`, `:button` => `:bottom`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This device event will rotate the device to the portrait orientation with the
    **home** button at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s use this rotation in our sample application from the previous section.
    We want to ensure that our application only works in portrait mode. For this we
    must disable the landscape mode. Let''s add a test case for this scenario. Add
    the following code in the file `root_view_controller_spec.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding test case, we rotate the device first in landscape mode and
    then in portrait mode, and then we test that each rotation is actually in portrait
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fire up the terminal and run the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As expected, it failed. Let's write its corresponding code to make our app work
    only in portrait mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `Rakefile` with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test our `spec` file once again and check the output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All tests passed as expected. Now, let''s run the application in a simulator
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotate the device by selecting **Hardware** | **Rotate Left** in the simulator
    menu as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotate device](img/5220OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that even after rotation, the interface orientation does not change
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotate device](img/5220OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accelerometer device event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accelerometer allows us to measure the linear acceleration of the device for
    your application. We can test the accelerometer features either on a device or
    with the following `accelerate` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following parameters can be passed with `accelerate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`: If you hold your device in the portrait orientation and the screen is
    facing you, the x axis will run from left to right, with values on the left as
    negative and values on the right as positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: If you hold your device in the portrait orientation and the screen is
    facing you, the y axis will run from bottom to top, with values on the bottom
    as negative and values on the top as positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z`: If you hold your device in the portrait orientation and the screen is
    facing you, the z axis will run from back to front, with values at the back as
    negative and values towards the front as positive. For example, accelerate: x
    => 0, :y => 0, :z => -1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Accelerometer device event](img/5220OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This test case event simulates a device lying on its back.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To trigger a shake motion event, we can use the following method: `shake()`'
  prefs: []
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user of an iOS application uses the app in a number of ways, by tapping or
    touching the screen and pinching or rotating. With RubyMotion, we can test most
    of these gestures; let's discuss a few of them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the gestures operate on views. We can specify the location of our event
    on the view by either using CGPoint or with the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:top_left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:top_right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:bottom_right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:bottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:bottom_left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: CGPoint lets us access a structure that contains a point in a two-dimensional
    coordinate system, for example, CGPoint.new(100, 200).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To simulate a tapping event on a view, we can specify a label or a view, and
    some specific properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what the purpose of the optional parameters is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`at`: We can specify the location on the view where we want the tap to simulate;
    the default location is the center of the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`times`: This specifies the number of times to tap the view. The default is
    a single tap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touches`: iPhone and iPad are multitouch devices; many apps exploit this feature
    of the iOS devices. You can specify the number of fingers that will be used to
    tap the view. The default is a single touch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example will tap `Test Label` with the default setting of tapping
    a view once with a single touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we will test the view labeled `Test Label` by tapping
    five times with two fingers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Flick
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flick generates a sharp moment of the drag gesture as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass the following options with the `flick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from`: Specifies the location on the view to start the drag gesture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: Specifies the location on the view to end the drag gesture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example generates a flick gesture to the right of the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Pinch open
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pinch open is a gesture using two fingers, which is generally used for zooming
    the images. With the following method we can generate a pinch open gesture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass the following options with the `pinch_open` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from`: This denotes the starting point for two fingers to begin the pinch
    open gesture; by default, it is to the left of the view.'
  prefs: []
  type: TYPE_NORMAL
- en: '`to`: This denotes the ending point for two fingers to finish the pinch open
    gesture; it defaults to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example zooms in on the content view of a `UIScrollView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Pinch close
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pinch close is a gesture using two fingers, which is generally used for zooming
    out on images. With the following method we can generate a pinch close gesture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass the following options with the `pinch_close` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from`: This denotes the starting point for two fingers to begin the pinch
    close gesture; by default, it is to the right of the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: This denotes the ending point for two fingers to finish the pinch close
    gesture; by default, it is to the left of the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example zooms out of the content view of a `UIScrollView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Drag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A drag gesture is generally used for panning and scrolling; it always has a
    start and end point. With the following method we can generate a drag gesture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass the following options with the `drag` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from`: This denotes the part of the view where the drag gesture will begin.
    If not specified, it defaults to none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: This denotes the part of the view where the drag gesture will end. If
    not specified, it defaults to none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number_of_points`: The number of points between `:from` and `:to`. It defaults
    to 20.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`points`: An array of CGPoint instances that specifies the drag path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touches`: The number of fingers to be used to drag. It defaults to a single
    touch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that scrolling in a direction means dragging in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will scroll down in a scroll view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the clockwise and anticlockwise rotation gesture, the following method
    is used. This method will simulate the rotation gesture around the center point
    of the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass the following options with the `rotate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`radians`: The angle of rotation in radians. It defaults to π.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`degrees`: The angle of rotation in degrees. It defaults to 180.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touches`: The number of fingers used to rotate. It defaults to 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recap all that we have learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test device events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far we have covered the basics and advanced topics related to RubyMotion.
    And now we are ready to do some fun stuff. In the next chapter we will learn to
    create games with RubyMotion. Gaming apps are one of (if not the) most popular
    genres of apps on the App Store. Most of us pass the time playing games on our
    iOS devices, so why not learn how to use RubyMotion to create our own game. In
    the next chapter we will learn how to create a game using RubyMotion.
  prefs: []
  type: TYPE_NORMAL
