- en: Chapter 8. Testing – Let's Fail Gracefully
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。测试 - 让我们优雅地失败
- en: '*"Truth will sooner come out from error than from confusion."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"真理往往比混乱更快地从错误中显现出来。"*'
- en: '*—*Francis Bacon**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*——*弗朗西斯·培根**'
- en: 'In order to maintain high quality of a software product, testing is a very
    important part of the software development life cycle. In this chapter we will
    learn how we can test RubyMotion applications. We will learn to write unit tests,
    which can test an isolated code, and then learn functional testing, which will
    help us automate the UI tests. The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持软件产品的高质量，测试是软件开发生命周期中非常重要的一个部分。在本章中，我们将学习如何测试 RubyMotion 应用程序。我们将学习编写单元测试，它可以测试独立的代码，然后学习功能测试，这将帮助我们自动化
    UI 测试。本章将涵盖以下主题：
- en: Unit testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Functional testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Device events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备事件
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: The goal of unit testing is to isolate each part of the program and show that
    the individual parts function properly. RubyMotion uses MacBacon, which is an
    iOS flavor of Bacon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目标是隔离程序的每个部分，并证明各个部分能正常工作。RubyMotion 使用 MacBacon，它是 Bacon 的 iOS 版本。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bacon is a smaller clone of RSpec. With less than 350 LOCs, we nevertheless
    get all the essential features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon 是 RSpec 的一个较小的克隆。尽管少于 350 行代码，但我们仍然获得了所有基本功能。
- en: Here, we will also follow **Test Driven Development** (**TDD**), a way of working
    where unit tests are created before the code itself is written. Of course, the
    tests will fail initially because we don't have anything. That's the philosophy
    of TDD; first we write the test case, it fails, we then refractor our code and
    once again write the feature code, and this time our test cases pass and the code
    is considered complete.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也将遵循 **测试驱动开发**（**TDD**），这是一种在编写代码之前创建单元测试的工作方式。当然，测试最初会失败，因为我们没有任何东西。这就是
    TDD 的哲学；首先我们编写测试用例，它失败了，然后我们重构代码，再次编写功能代码，这次我们的测试用例通过了，代码被认为是完整的。
- en: The idea here is that the developer himself wears the hat of a tester. We first
    document the feature in the form of a test, which fails, then we write our code
    and refractor, and once again document with a test case for the next feature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是开发者自己戴上测试者的帽子。我们首先以测试的形式记录功能，然后编写我们的代码并进行重构，然后再用测试用例记录下一个功能。
- en: First, let's create an application, which we will be using to learn how to write
    test cases for use with TDD.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个应用程序，我们将使用它来学习如何编写与 TDD 一起使用的测试用例。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the folder structure, we can see a `spec` folder and a file `main_spec.rb`
    placed inside this folder. This is the default test file generated by the RubyMotion
    generator; this is where we write our test cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件夹结构中，我们可以看到一个 `spec` 文件夹和一个位于此文件夹中的文件 `main_spec.rb`。这是 RubyMotion 生成器生成的默认测试文件；这是我们编写测试用例的地方。
- en: 'Let''s write our first test case in the `main_spec.rb file` inside the `spec`
    folder as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `spec` 文件夹内的 `main_spec.rb` 文件中编写我们的第一个测试用例，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Bacon gives you a way to encapsulate what you''re testing via the `describe`
    block. As the name suggests, the `describe` block is used to describe the behavior
    of a class as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon 通过 `describe` 块提供了一种封装你正在测试内容的方法。正如其名所示，`describe` 块用于描述类的行为如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Tests are written using the `it` block. The test has a window, which checks
    if our application has a window as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是用 `it` 块编写的。测试有一个窗口，它检查我们的应用程序是否有一个窗口如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the syntax of these tests is very readable and you can easily
    understand what it means. In this case, `@app.windows.size.should == 1` means
    that your application should have one window.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些测试的语法非常易读，你可以轻松理解其含义。在这种情况下，`@app.windows.size.should == 1` 意味着你的应用程序应该有一个窗口。
- en: The `describe()` method clasps into the Bacon API and gives us the `Spec::ExampleGroup`
    class. As the name suggests, it is a group of examples. These examples are actually
    the expected behavior of the object. If you're familiar with the xUnit tools such
    as `Test::Unit`, you can think of an `ExampleGroup` class as being akin to a test
    case.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 方法将 Bacon API 包围起来，并给我们 `Spec::ExampleGroup` 类。正如其名所示，它是一组示例。这些示例实际上是对象的预期行为。如果你熟悉
    `Test::Unit` 等 xUnit 工具，你可以将 `ExampleGroup` 类视为类似于测试用例。'
- en: 'Let''s run the test case with the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行测试用例：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see that one test failed (`Bacon::Error: 0.==(1)`). That is exactly
    what we wanted.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到有一个测试失败了（`Bacon::Error: 0.==(1)`）。这正是我们想要的。'
- en: This means that `@app.windows.size` should expect the value as 1 but the actual
    value right now is 0\. This is because till now we have not created a window in
    our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `@app.windows.size` 应该期望值为 1，但实际上现在的值是 0。这是因为到目前为止，我们还没有在我们的应用程序中创建窗口。
- en: 'Next, let''s write the code to create a window and update the `app_delegate.rb`
    file with the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写创建窗口的代码，并使用以下代码更新 `app_delegate.rb` 文件：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s run the `specs` file as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式运行 `specs` 文件：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We see that our test has passed and the code is therefore complete; mission
    accomplished!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到测试已经通过，因此代码已经完成；任务完成！
- en: 'The following are some commonly used assertions with MacBacon:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 MacBacon 中常用的断言：
- en: '`should.` and `should.be`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.` 和 `should.be`'
- en: '`should.equal`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.equal`'
- en: '`should.match`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.match`'
- en: '`should.be.identical_to`/`should.be.same_as`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.be.identical_to`/`should.be.same_as`'
- en: '`should.raise(*exceptions) { }`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.raise(*exceptions) { }`'
- en: '`should.change { }`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.change { }`'
- en: '`should.throw(symbol) { }`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.throw(symbol) { }`'
- en: '`should.satisfy { |object| }`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should.satisfy { |object| }`'
- en: 'Now let''s create one more test by adding the following code to your `main_spec.rb`
    file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过向 `main_spec.rb` 文件添加以下代码创建另一个测试：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This test checks whether we have the `rootViewController` property in our application
    whose name should be `RootViewController`. Run this test case and it should fail,
    as we have not yet created `RootViewController`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查我们是否在我们的应用程序中有一个名为 `rootViewController` 的属性，其名称应该是 `RootViewController`。运行这个测试用例，它应该失败，因为我们还没有创建
    `RootViewController`。
- en: 'Let''s create a file `root_view_controller.rb` in the `app` folder as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `app` 文件夹中创建一个名为 `root_view_controller.rb` 的文件，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also update the `app_delegate.rb` file by adding the following line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还通过添加以下行更新 `app_delegate.rb` 文件：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now when we run the `specs file`, we will find that all the test cases are passed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行 `specs` 文件时，我们会发现所有测试用例都已通过。
- en: Next, let's add some functionality to our application. How about we calculate
    the sum of the squares of numbers? Let's first write the tests for this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给我们的应用程序添加一些功能。我们计算数字的平方和怎么样？让我们首先为这个功能编写测试。
- en: 'Add the following `specs` code to the `main_spec.rb` file in the `spec` folder:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `specs` 代码添加到 `spec` 文件夹中的 `main_spec.rb` 文件：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run the test, they will surely fail, as we have not yet created the
    `sum_of_square_number` method. So let''s create this method and its logic so that
    our `specs` tests pass, update the `root_view_controller.rb` file, and add the
    following method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它们肯定会失败，因为我们还没有创建 `sum_of_square_number` 方法。所以让我们创建这个方法和其逻辑，以便我们的 `specs`
    测试通过，更新 `root_view_controller.rb` 文件，并添加以下方法：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, when we run our `specs` tests they will pass.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们运行我们的 `specs` 测试时，它们会通过。
- en: So far we have learned about testing a piece of code, but it is equally important
    that we test the user interface, so in the next section we will write a functional
    test.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何测试一段代码，但同样重要的是测试用户界面，因此在下一段我们将编写一个功能测试。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can create multiple files in your `spec` folder. RubyMotion automatically
    runs all the files with the `.rb` extension. You can also run individual files
    even from different locations with the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的 `spec` 文件夹中创建多个文件。RubyMotion 会自动运行所有扩展名为 `.rb` 的文件。你也可以使用以下命令运行单个文件，即使它们位于不同的位置：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Functional testing
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: RubyMotion lets us write functional tests for our controllers and interacts
    with its views through a set of high-level event generating APIs, by leveraging
    the functionality of Apple's `UIAutomation` framework without forcing us to write
    the tests in JavaScript.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion 允许我们为控制器编写功能测试，并通过一组高级事件生成 API 与其视图交互，利用 Apple 的 `UIAutomation` 框架的功能，而无需强迫我们用
    JavaScript 编写测试。
- en: Let's now write tests for user interface of the same application. In the following
    test case, we will test whether we have a label and a button on the screen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为同一应用程序的用户界面编写测试。在以下测试用例中，我们将测试屏幕上是否有标签和按钮。
- en: 'Create the `spec` file `restro_view_controller_spec.rb` in the `spec` folder:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `spec` 文件夹中创建 `restro_view_controller_spec.rb` 测试文件：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`The view(label)` property returns the view that matches the specified accessibility
    label. The `view` command traverses down through the view hierarchy, starting
    from the current window. If no view matches our condition, it keeps retrying it
    until the timeout, which defaults to three seconds. This means you don''t need
    to worry about whether or not the view you''re looking for is still being loaded
    or animated.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`The view(label)` 属性返回与指定可访问标签匹配的视图。`view` 命令从当前窗口开始遍历视图层次结构。如果没有视图匹配我们的条件，它将一直重试，直到超时，默认为三秒。这意味着你不需要担心你正在寻找的视图是否仍在加载或动画中。'
- en: Finally, if the timeout passes and no view matches, an exception will be raised.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果超时通过且没有视图匹配，将抛出异常。
- en: The default timeout value can be changed through the `Bacon::Functional.default_timeout`
    property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认超时值可以通过 `Bacon::Functional.default_timeout` 属性更改。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can also check what buttons are available on view with the classname as
    follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查具有以下类名的视图上可用的按钮：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now to pass this test, let''s write the code for this functionality and update
    the file `root_view_controller.rb` with the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了通过这个测试，让我们编写这个功能的代码，并使用以下代码更新文件 `root_view_controller.rb`：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s fire up the terminal and run the application with the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动终端并使用以下命令运行应用程序：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![Functional testing](img/5220OT_08_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![功能测试](img/5220OT_08_01.jpg)'
- en: 'We have created a label and a button in this View and now, when we run our
    `spec test`, it passes. Next, we want to calculate the sum of the squares of the
    first 5 numbers on click of a button. Let''s first write the `spec` code for this
    functionality. Update the file `restro_view_controller_spec.rb` with the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个视图中创建了一个标签和一个按钮，现在，当我们运行我们的 `spec test` 时，它通过了。接下来，我们想在按钮点击时计算前5个数的平方和。让我们首先编写这个功能的
    `spec` 代码，并使用以下代码更新文件 `restro_view_controller_spec.rb`：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `tap` command clicks on the button with the label **Click Me**. There are
    many options available with the `tap` command. We will know more about them as
    we proceed with this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`tap` 命令点击带有标签 **点击我** 的按钮。`tap` 命令有许多可用选项。随着我们继续本章的学习，我们将了解更多关于它们的信息。'
- en: 'Now let''s write the corresponding code for this `spec` test and update the
    file `root_view_controller.rb` with the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这个 `spec` 测试编写相应的代码，并使用以下代码更新文件 `root_view_controller.rb`：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s fire up the terminal and test our application with the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动终端并使用以下命令测试我们的应用程序：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![Functional testing](img/5220OT_08_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![功能测试](img/5220OT_08_02.jpg)'
- en: We are now familiar with the basic functioning of testing. Next, we will learn
    how to test the device events with RubyMotion.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在熟悉了测试的基本功能。接下来，我们将学习如何使用 RubyMotion 测试设备事件。
- en: Device events
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备事件
- en: Most of the iOS applications make use of the various device capabilities. As
    a good practice, we must test these features to deliver high quality apps. RubyMotion
    gives us an environment to test some device capabilities. Let's discuss a few
    of them in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 iOS 应用程序都利用了各种设备功能。作为一个好的实践，我们必须测试这些功能以提供高质量的应用程序。RubyMotion 给我们提供了一个测试一些设备功能的环境。让我们在本节中讨论其中的一些。
- en: Rotate device
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转设备
- en: 'We can test the rotation of the device by calling the following event:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用以下事件来测试设备的旋转：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `rotate_device` command allows us to pass the following two arguments:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate_device` 命令允许我们传递以下两个参数：'
- en: '`to`: This passes the orientation to rotate the device; it can either have
    portrait or landscape as a value.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：这传递了旋转设备的方向；它可以是纵向或横向的值。'
- en: '`button`: The `button` here indicates the position of the **home** button;
    it makes sense if we pass the values based on the first value of orientation.
    In portrait mode, we can opt for the `:bottom` or `:top button` location. In landscape
    mode, we can opt for `:left` or `:right` with respect to the button location,
    for example, `rotate_device` `:to` => `:portrait`, `:button` => `:bottom`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button`：这里的 `button` 指的是 **主页** 按钮的位置；如果我们根据方向的第一值传递值，这就有意义了。在纵向模式下，我们可以选择
    `:bottom` 或 `:top button` 位置。在横向模式下，我们可以选择相对于按钮位置的 `:left` 或 `:right`，例如，`rotate_device`
    `:to` => `:portrait`，`:button` => `:bottom`。'
- en: This device event will rotate the device to the portrait orientation with the
    **home** button at the bottom.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此设备事件将使设备旋转到竖直方向，且**主页**按钮位于底部。
- en: 'Now let''s use this rotation in our sample application from the previous section.
    We want to ensure that our application only works in portrait mode. For this we
    must disable the landscape mode. Let''s add a test case for this scenario. Add
    the following code in the file `root_view_controller_spec.rb`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用上一节中的示例应用中的这个旋转。我们想要确保我们的应用仅在竖直模式下工作。为此，我们必须禁用横屏模式。让我们为这种情况添加一个测试用例。在文件`root_view_controller_spec.rb`中添加以下代码：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the preceding test case, we rotate the device first in landscape mode and
    then in portrait mode, and then we test that each rotation is actually in portrait
    mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试用例中，我们首先在横屏模式下旋转设备，然后旋转到竖直模式，然后测试每次旋转实际上是否在竖直模式下。
- en: 'Let''s fire up the terminal and run the test as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动终端并按照以下方式运行测试：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As expected, it failed. Let's write its corresponding code to make our app work
    only in portrait mode.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它失败了。让我们编写相应的代码，使我们的应用仅在竖直模式下工作。
- en: 'Update `Rakefile` with the following line of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`Rakefile`：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s test our `spec` file once again and check the output on the console:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测试我们的`spec`文件，并检查控制台上的输出：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All tests passed as expected. Now, let''s run the application in a simulator
    with the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都如预期通过。现在，让我们使用以下命令在模拟器中运行应用：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Rotate the device by selecting **Hardware** | **Rotate Left** in the simulator
    menu as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，在模拟器菜单中选择**硬件** | **向左旋转**来旋转设备：
- en: '![Rotate device](img/5220OT_08_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![旋转设备](img/5220OT_08_03.jpg)'
- en: 'You can see that even after rotation, the interface orientation does not change
    as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，即使旋转后，界面方向也没有改变，如下截图所示：
- en: '![Rotate device](img/5220OT_08_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![旋转设备](img/5220OT_08_04.jpg)'
- en: Accelerometer device event
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速度计设备事件
- en: 'Accelerometer allows us to measure the linear acceleration of the device for
    your application. We can test the accelerometer features either on a device or
    with the following `accelerate` event:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计允许我们测量设备对应用线性加速度的测量。我们可以通过设备或以下`accelerate`事件来测试加速度计功能：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following parameters can be passed with `accelerate`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`accelerate`传递以下参数：
- en: '`x`: If you hold your device in the portrait orientation and the screen is
    facing you, the x axis will run from left to right, with values on the left as
    negative and values on the right as positive.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 如果你将设备竖直握持且屏幕朝向你，x轴将从左到右运行，左侧的值为负，右侧的值为正。'
- en: '`y`: If you hold your device in the portrait orientation and the screen is
    facing you, the y axis will run from bottom to top, with values on the bottom
    as negative and values on the top as positive.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`: 如果你将设备竖直握持且屏幕朝向你，y轴将从底部到顶部运行，底部的值为负，顶部的值为正。'
- en: '`z`: If you hold your device in the portrait orientation and the screen is
    facing you, the z axis will run from back to front, with values at the back as
    negative and values towards the front as positive. For example, accelerate: x
    => 0, :y => 0, :z => -1.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z`: 如果你将设备竖直握持且屏幕朝向你，z轴将从后向前运行，背部的值为负，朝向前的值为正。例如，加速：x => 0, :y => 0, :z =>
    -1。'
- en: '![Accelerometer device event](img/5220OT_08_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![加速度计设备事件](img/5220OT_08_05.jpg)'
- en: This test case event simulates a device lying on its back.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试用例事件模拟设备背面朝下。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To trigger a shake motion event, we can use the following method: `shake()`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发摇动事件，我们可以使用以下方法：`shake()`
- en: Gestures
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势
- en: A user of an iOS application uses the app in a number of ways, by tapping or
    touching the screen and pinching or rotating. With RubyMotion, we can test most
    of these gestures; let's discuss a few of them in this section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: iOS应用程序的用户可以通过点击或触摸屏幕以及捏合或旋转等方式使用该应用。使用RubyMotion，我们可以测试这些手势中的大多数；让我们在本节中讨论其中的一些。
- en: 'Most of the gestures operate on views. We can specify the location of our event
    on the view by either using CGPoint or with the following constants:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数手势都作用于视图。我们可以通过使用CGPoint或以下常量来指定我们的事件在视图上的位置：
- en: '`:top`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:top`'
- en: '`:top_left`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:top_left`'
- en: '`:top_right`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:top_right`'
- en: '`:bottom_right`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:bottom_right`'
- en: '`:bottom`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:bottom`'
- en: '`:bottom_left`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:bottom_left`'
- en: '`:left`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:left`'
- en: '`:right`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:right`'
- en: Note
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CGPoint lets us access a structure that contains a point in a two-dimensional
    coordinate system, for example, CGPoint.new(100, 200).
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CGPoint`让我们可以访问一个包含二维坐标系中点的结构，例如，CGPoint.new(100, 200)。'
- en: Tap
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击
- en: 'To simulate a tapping event on a view, we can specify a label or a view, and
    some specific properties as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中模拟点击事件，我们可以指定一个标签或视图，以及以下一些特定属性：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s understand what the purpose of the optional parameters is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解可选参数的目的是什么：
- en: '`at`: We can specify the location on the view where we want the tap to simulate;
    the default location is the center of the view.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`: 我们可以指定视图上我们想要点击模拟的位置；默认位置是视图的中心。'
- en: '`times`: This specifies the number of times to tap the view. The default is
    a single tap.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`times`: 这指定了点击视图的次数。默认为单次点击。'
- en: '`touches`: iPhone and iPad are multitouch devices; many apps exploit this feature
    of the iOS devices. You can specify the number of fingers that will be used to
    tap the view. The default is a single touch.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touches`: iPhone和iPad是多点触控设备；许多应用程序利用iOS设备的这一特性。您可以指定用于点击视图的手指数量。默认为单指。'
- en: 'The following example will tap `Test Label` with the default setting of tapping
    a view once with a single touch:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用单指点击视图一次的默认设置来点击`Test Label`：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the next example, we will test the view labeled `Test Label` by tapping
    five times with two fingers:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将通过用两个手指点击五次来测试标记为`Test Label`的视图：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Flick
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轻扫
- en: 'Flick generates a sharp moment of the drag gesture as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 轻扫生成拖动手势的尖锐瞬间如下：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can pass the following options with the `flick` method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`flick`方法传递以下选项：
- en: '`from`: Specifies the location on the view to start the drag gesture.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 指定视图上开始拖动手势的位置。'
- en: '`to`: Specifies the location on the view to end the drag gesture.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 指定视图上结束拖动手势的位置。'
- en: 'The following example generates a flick gesture to the right of the view:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例生成向右滑动视图的轻扫手势：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pinch open
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捏合展开
- en: 'Pinch open is a gesture using two fingers, which is generally used for zooming
    the images. With the following method we can generate a pinch open gesture:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 捏合展开是使用两个手指的手势，通常用于放大图像。通过以下方法我们可以生成捏合展开手势：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can pass the following options with the `pinch_open` method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`pinch_open`方法传递以下选项：
- en: '`from`: This denotes the starting point for two fingers to begin the pinch
    open gesture; by default, it is to the left of the view.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`: 这表示两个手指开始捏合展开手势的起点；默认情况下，它位于视图的左侧。'
- en: '`to`: This denotes the ending point for two fingers to finish the pinch open
    gesture; it defaults to the right.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`to`: 这表示两个手指完成捏合展开手势的终点；默认为右侧。'
- en: 'The following example zooms in on the content view of a `UIScrollView` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将`UIScrollView`类的视图内容放大：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Pinch close
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捏合缩小
- en: 'Pinch close is a gesture using two fingers, which is generally used for zooming
    out on images. With the following method we can generate a pinch close gesture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 捏合缩小是使用两个手指的手势，通常用于缩小图像。通过以下方法我们可以生成捏合缩小手势：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can pass the following options with the `pinch_close` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`pinch_close`方法传递以下选项：
- en: '`from`: This denotes the starting point for two fingers to begin the pinch
    close gesture; by default, it is to the right of the view.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 这表示两个手指开始捏合缩小手势的起点；默认情况下，它位于视图的右侧。'
- en: '`to`: This denotes the ending point for two fingers to finish the pinch close
    gesture; by default, it is to the left of the view.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 这表示两个手指完成捏合缩小手势的终点；默认情况下，它位于视图的左侧。'
- en: 'The following example zooms out of the content view of a `UIScrollView` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将`UIScrollView`类的视图内容缩小：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Drag
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖动
- en: 'A drag gesture is generally used for panning and scrolling; it always has a
    start and end point. With the following method we can generate a drag gesture:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动手势通常用于平移和滚动；它始终有一个起点和终点。通过以下方法我们可以生成拖动手势：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can pass the following options with the `drag` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`drag`方法传递以下选项：
- en: '`from`: This denotes the part of the view where the drag gesture will begin.
    If not specified, it defaults to none.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 这表示拖动手势将开始的视图部分。如果没有指定，则默认为无。'
- en: '`to`: This denotes the part of the view where the drag gesture will end. If
    not specified, it defaults to none.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 这表示拖动手势将结束的视图部分。如果没有指定，则默认为无。'
- en: '`number_of_points`: The number of points between `:from` and `:to`. It defaults
    to 20.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number_of_points`: `:from`和`:to`之间点的数量。默认为20。'
- en: '`points`: An array of CGPoint instances that specifies the drag path.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`points`：一个指定拖动路径的CGPoint实例数组。'
- en: '`touches`: The number of fingers to be used to drag. It defaults to a single
    touch.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touches`：用于拖动的手指数量。默认值为单指。'
- en: Keep in mind that scrolling in a direction means dragging in the opposite direction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，向一个方向滚动意味着在相反方向拖动。
- en: 'The following code will scroll down in a scroll view:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在滚动视图中向下滚动：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Rotation
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: To test the clockwise and anticlockwise rotation gesture, the following method
    is used. This method will simulate the rotation gesture around the center point
    of the view.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试顺时针和逆时针旋转手势，使用以下方法。此方法将在视图的中心点周围模拟旋转手势。
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can pass the following options with the `rotate` method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rotate`方法传递以下选项：
- en: '`radians`: The angle of rotation in radians. It defaults to π.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radians`：旋转的角度（以弧度为单位）。默认值为π。'
- en: '`degrees`: The angle of rotation in degrees. It defaults to 180.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`degrees`：旋转的角度（以度为单位）。默认值为180。'
- en: '`touches`: The number of fingers used to rotate. It defaults to 2.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touches`：用于旋转的手指数量。默认值为2。'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let''s recap all that we have learned in this chapter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在本章中学到的所有内容：
- en: Unit test cases
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试用例
- en: Functional test cases
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试用例
- en: How to test device events
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试设备事件
- en: So far we have covered the basics and advanced topics related to RubyMotion.
    And now we are ready to do some fun stuff. In the next chapter we will learn to
    create games with RubyMotion. Gaming apps are one of (if not the) most popular
    genres of apps on the App Store. Most of us pass the time playing games on our
    iOS devices, so why not learn how to use RubyMotion to create our own game. In
    the next chapter we will learn how to create a game using RubyMotion.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了与RubyMotion相关的基础和高级主题。现在，我们准备做一些有趣的事情。在下一章中，我们将学习如何使用RubyMotion创建游戏。游戏应用是App
    Store上最受欢迎的应用类型之一（如果不是最受欢迎的话）。我们大多数人都会在iOS设备上玩游戏来消磨时间，那么为什么不学习如何使用RubyMotion来创建我们自己的游戏呢？在下一章中，我们将学习如何使用RubyMotion创建一个游戏。
