- en: Chapter 11. Extensions, Photos, and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing the geekiest keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time to take your pill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding effects to your photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being a film critic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaving breadcrumbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Currency Converter app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method swizzling in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associated objects in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter of this book. Here, we are going to learn different
    topics that weren't mentioned in the previous chapters, mainly new features of
    Xcode 6.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the geekiest keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: App extensions are a new feature where an application can come with some kind
    of plugins, which can even interact with other apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are going to develop a keyboard for geek people. This keyboard
    will contain only two keys: key *0* and key *1*. When you type a combination of
    eight keys, you will get a new character.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, make sure that you have iOS 8, it doesn't matter if you are
    using the simulator or a physical device. The custom keyboard feature is only
    available on iOS 8.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new single view application called `Chapter 11 Geekboard` and let's
    start coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main development of this recipe is based on the app extension of the custom
    keyboard. However, as we are going to need a view for testing our keyboard, let''s
    start by clicking on the storyboard and adding a text field on our view. Link
    this text field with the view controller calling it `inputTextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s make this text field the first responder, just as the application
    is about to launch. You won''t need to tap on the field for displaying the keyboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is everything we have to code with this view controller; everything else
    will be done on the application extension. The next step is opening the menu and
    adding a new target to our project. In this case, select **Custom Keyboard** from
    the **Application Extension** section:![How to do it…](img/00169.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this target `Geekboard` and press **Yes** when a dialog asks for activating
    the **Geekboard** scheme:![How to do it…](img/00170.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before coding, let's start by adding a new view to this target; therefore click
    on the new file from the menu and choose **View** from the **User Interface**
    section:![How to do it…](img/00171.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this view `Geekboard` (again) but before pressing the **Create** button
    ensure that this file belongs to the extension target as shown in the following
    screenshot:![How to do it…](img/00172.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it is created, click on the new file (`Geekboard.xib`), select the only
    view it has, and let's change some properties of it by clicking on the **Attribute
    Inspector**. Here you have to change the size to **Freeform**, the status bar
    to **None**, and the background color to silver:![How to do it…](img/00173.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! After that, select the **Size Inspector** and change the view size to
    **320** by **160**:![How to do it…](img/00174.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view properties are done, now we need to set the file's owner class. To
    do it click on the file's owner icon (the yellow cube), select the identity inspector,
    and change the class name to `KeyboardViewController`:![How to do it…](img/00175.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is one more thing we need to do in this XIB file: we have to add a few
    components for this layout. Add a label, for letting the user know the binary
    combination that was made, and two buttons: one that represents digit 0 and another
    one that represents digit **1**. It should look something similar to the following
    screenshot:![How to do it…](img/00176.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course the label is going to be changed and the buttons don''t need a different
    action due to the only difference being the digit value; therefore we will create
    the same action for both buttons and differentiate them by checking the sender.
    To summarize, link the label and the buttons with the `KeyboardViewController`
    as per the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't remove any code done by the Xcode on the `KeyboardViewController` yet.
    If it's necessary to remove any code, it will be explicitly written.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Link both buttons with an empty action called `addBit`. Don''t worry about
    by its contents, we are going to develop it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the `KeyboardViewController` we are also going to add two attributes for
    controlling the current keyboard state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to set up the view, so go to the `viewDidLoad` method and add some
    lines of code after `super.viewDidLoad` and before the Apple precooked code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have typed that, we can complete our app by developing the buttons
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application is done, let's test it. Press play, and when the application
    launches the keyboard is shown but, that's not our keyboard!!! What happened?
    The reason is that you have to add this keyboard the same way you add another
    language keyboard on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bearing that in mind, press the home button, go to settings, choose general,
    then keyboard, then another option of keyboards, and at last the option **Add
    new keyboard...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see some suggested keyboards and another section with third-party
    keyboards. Select the **Geekboard** from this section:![How to do it…](img/00177.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to your app (**Chapter 11 Geekboard**) and you will see that the keyboard
    is not there yet. So you have to tap the globe icon until you get your keyboard
    and, voila!, it''s working. Type this binary message: `01001000 01000101 01001100
    01001100 01001111` for example, but if you are really geeky, you can go to the
    **Mail** application and write an e-mail with only this keyboard. Do you accept
    the challenge?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A custom keyboard is a feature called **App Extension**. It has some limitations,
    for example, it can't be used for passwords and other text field types such as
    phone contacts. It also can't display anything above its top.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom keyboard implies creating a controller of type `UIInputViewController`,
    which is a class that inherits from `UIViewController`, meaning that you can use
    the `UIViewController` methods if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For making the keyboard development simpler, we added a new XIB file, which
    allowed us to visually create the layout. Some developers think that the XIB files
    were removed from the Xcode since the storyboard was incorporated, however you
    can see that this is not true; you can still use the XIB files for customizing
    some views such as a keyboard or a table cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Submitting a text to the text field is very easy: you only need to create a
    `UITextDocumentProxy` object and use the `insertText` method. It will know the
    active text field magically.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The custom keyboards communication is a bit limited because it can't use the
    network or share any file with the containing app by default. In case you desire
    to use these features, you have to go to its `Info.plist` and set the option `RequestsOpenAccess`
    to `yes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next recipe, we are going to learn something different: we are going
    to develop for the Apple Watch.'
  prefs: []
  type: TYPE_NORMAL
- en: Time to take your pill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Who in this world has never fallen sick? Let's face it, soon or later we get
    sick and we have to follow the doctor's prescription. If you are like me and look
    at your watch frequently when it's time to take a pill, maybe what we need is
    an app that can tell us about it, and this time it will be an Apple Watch application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe you will need Xcode 6.2 or higher, because we are going to use
    the WatchKit, which is not available on previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Start as usual by just creating a single view iOS application and call it `Chapter
    11 Red Pill`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step we need to do is just create a new target, but this time you
    have to add the **WatchKit App** from the **WatchKit** section:![How to do it…](img/00178.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Next** dialog uncheck the notifications, glance and complications options;
    it will make the project cleaner:![How to do it…](img/00179.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, a dialog requesting to activate the WatchKit App will appear; accept
    it by pressing the **Activate** button:![How to do it…](img/00180.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see that there are two new groups on your project: one for the WatchKit
    extension and another one for the WatchKit app. Open your extension group and
    add a new Swift file called `FrequencyData.swift`. Here you only need to type
    this simple code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now go to your WatchKit app group, expand it, and click on the storyboard.
    Here you have something like the view controller but here it''s called interface.
    In your interface, add a label and try to make it fit on the whole screen. Connect
    it with the interface controller as an IBOutlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new interface and place another label; you don't have to connect it
    just change its text to `It's time to take your pill`. If it doesn't fit, change
    the label number of lines to two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the first interface, hold the control key and drag it to the second
    interface. You may now have your storyboard looking like the following:![How to
    do it…](img/00181.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the second interface and go to its attribute inspector. Set the identifier
    to `its_time`:![How to do it…](img/00182.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to the extension group and open the `InterfaceController` file. As usual
    we are going to start by adding the necessary attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now initialize the context on the `awakeWithContext` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we have to request the user to select the time he needs to take
    his pill. Do it on the method `willActivate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we need a method called `tick`, which is going to be called
    every second. Code it this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app is done, let's test it by changing the current scheme to `Chapter 11
    Red Pill WatchKit App` and pressing play. You should see a dialog like the following
    one:![How to do it…](img/00183.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose 2 minutes, which was done just for testing, and wait until you get your
    alert.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the components classes are different; instead of `UIViewController`
    we have `WKInterfaceController`, and instead of `UILabel` we have `WKInterfaceLabel`.
    Some methods are different, for example the interface controller initializes its
    attributes on the `awakeWithContext` method rather than `viewDidLoad`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one component called `WKInterfaceTimer`, which works as a label with
    an `NSTimer` like we did. In this recipe we used the `WKInterfaceLabel` with an
    `NSTimer` because it is more flexible and you can customize the text that is on
    your component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WatchKit has more features such as notifications and glance. Try to have a look
    on the official documentation at [https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969](https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969)
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we are going to return to iOS and learn how to use the camera
    for taking pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Adding effects to your photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is unbelievable how mobile phones have replaced traditional photo cameras.
    I remember when we used to take the camera only to special events and nowadays
    our cameras follow us everywhere. We can say that the mobile phone has gone even
    further: you can take a picture of yourself on the phone, edit it, and share it
    with your friends and family.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to take a picture with your phone
    and edit it in a very easy way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are going to use the device camera for this recipe you will need a physical
    device for testing this app. You can change it if you are using photos from the
    gallery, but you will also need to upload some pictures to the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project called `Chapter 11 Photo Effects` and let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your project, click on the **General Settings** of your target and add
    a framework called **CoreImage**. After that go to the storyboard, add an image
    view and four buttons under it. Change the button labels to `Take photo`, `Sepia`,
    `Blur,` and `Dots`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the image with the view controller as an attribute and call it `imageView`.
    Now create one action for each button and call them `takePhoto`, `sepia`, `blur`,
    and `dots`. Don''t worry about their contents now, we are going to fill them in
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click on the view controller source code and let''s start completing it by
    adding a new attribute called `image` of optional type `UIImage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `UIImagePickerController` requires a delegate and only accepts objects
    that are also navigation controller delegates, therefore append these protocols
    to the view controller definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s almost time to start coding functions, however we still need to add a
    detail: we have to import the core image on the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, at this time we can start coding the view controller methods. Start by
    checking whether your device has a camera on the `viewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is completing the `takePhoto` method. This method initializes
    the image picker and calls the camera view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you might imagine, the delegate needs to have at least one method; in this
    case we need one method for receiving the picture from the user and another in
    case of canceling it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have done that, we only need to complete the effects code; they are
    very similar but not the same, so here you have them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app is done. Now press play, take a photo, and choose the effect you like
    most.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UIImagePickerController` was created for using the camera easily; this way
    we don''t have to use complicated camera settings and worry about different states
    of it. To use the `UIImagePickerController` you need a delegate and on its method
    you can retrieve the taken picture as a `UIImage`.'
  prefs: []
  type: TYPE_NORMAL
- en: After receiving the picture you can use the Core Image for adding some effects;
    however you need to convert from `UIImage` to `CIImage`. If you loaded the `UIImage`
    from a local file you can convert it easily by calling a property `CIImage`; however
    this is not the case, as this picture was loaded from the camera so you need to
    create a new object and send your `UIImage` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use the filter that you want with the corresponding values. When
    you use a `CIFilter` you have to check the attributes that are accepted by it;
    sometimes you can use the default values and sometimes you would like to change
    them.
  prefs: []
  type: TYPE_NORMAL
- en: After using the filter you can retrieve your picture by using the `outputImage`
    attribute and after that you can construct a new `UIImage` with the `CIImage`
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CoreImage` has a lot of filters, so nowadays it''s not necessary to look for
    libraries or algorithms that modify our pictures. Check the filters that are available
    at [https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346](https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346)
    and test them with different attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next recipe, we are going to learn how we can send information from the
    iPhone to our Mac.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being a film critic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times that an app needs to transfer information from your device to
    the computer and vice versa; for example, you might be watching a movie on your
    iPad on your way home (assuming that you are not the driver) and then you will
    continue watching it on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For scenarios like this one, Apple has created a new technology called **Handoff**.
    The idea is simple: continue the task you are doing on another device.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to create an app where the user can start writing
    his opinion about a film on one device and check it on a Mac application. This
    recipe will be divided into smaller sections for easier consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Handoff framework has software and hardware requirements. The software requirements
    are Xcode 6, iOS 8, and OS X Yosemite (10.10); therefore make sure that your hardware
    is able to use all these software versions (or higher). Unfortunately Handoff
    can't be used with the simulator. Another software requirement is that both devices
    (the computer and your Apple mobile device) must be logged into the same iCloud
    account and they must be paired.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement for the hardware is that it has Bluetooth LE 4.0\. The easiest
    way to check whether your iPhone or iPad can use this feature is by opening your
    settings, going to general and checking whether there is an option called **Handoff
    & Suggested Apps**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure that the **Handoff** option is on, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have checked the device requirements, it''s time to check whether
    the computer meets the requirements. On your Mac computer, open the system preferences,
    then open the **General options**, and ascertain that there is a Handoff option
    and it is checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of all requirements, the most complicated one is that this technology needs
    the application signed by a team (or a developer), which implies being enrolled
    on the Apple Development Program for each platform. This means that if you are
    going to use this technology between mobile devices and mac computers, you need
    both subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to use both platforms but if you only have an iOS
    subscription, it is very straightforward to change the Mac app to an iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start coding the project; in this case start creating a workspace
    called `Chapter 11 Films`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will split the recipe into three mini-recipes for better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the workspace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create the workspace in a group called `Common Code`; here you have to add
    a new Swift file called `FilmData.swift`, and we are going to add this simple
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's create a new iOS project called `Chapter 11 Films iOS`. Ensure that it
    is going to be added to your workspace on the combo box:![Creating the workspace](img/00187.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the procedure with a Mac OS X Cocoa application called `Chapter 11 Films
    MacOSX`, but be aware that you have to add it to the workspace and the group must
    be in the workspace too:![Creating the workspace](img/00188.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have both projects, let's add to both of them the first file we created
    at the beginning of this recipe (`FilmData.swift`). This way we don't have to
    repeat the code for each project:![Creating the workspace](img/00189.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have these common parts we are going to continue with the Mac application.
    So click on the Mac project, go to **General Settings**, change the signing section
    to **Developer ID**, and select your team account:![Creating the workspace](img/00190.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the `info.plist` file, which is located on the **Supporting Files**
    group and add a new key called **NSUserActivityTypes**. Change its type to array,
    try to expand it but as you can see there is no item, so click on the plus sign
    and write the value `com.packtpub.editingfilm`:![Creating the workspace](img/00191.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is clicking on the XIB file and adding five labels into the only
    window we have. Put one under the other and, after that, start from the first
    one connecting to the `AppDelegate.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that we only need to add the following code to the `AppDelegate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good, the Mac application is done; before we press play remember that you have
    to log in on iCloud to do it, so you have to open the **System Preferences**,
    then go to iCloud and log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that this account must be the same one that you are going to use on
    the mobile device. Once it is done, return to your app and press play. You should
    see just a window with some labels—don't worry about them now as we are going
    to check them later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing the iOS part of the app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this time, we are ready to develop the iOS part of the app. First, you have
    to set your team on the main project target and also add the key `NSUserActivityTypes`
    on the `info.plist`. As we did on the Mac application, change its type to Array
    and add the value `com.packtpub.editingfilm` as we also did on the Mac application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the storyboard and, as usual, you might see only a view controller.
    Click on it, go to the **Editor** menu, move down to the option `Embed in` and
    select **Navigation controller**. As you might expect, we are going to add a second
    view controller later. Now just remove the navigation bar by clicking on the navigation
    controller, select the attribute inspector, and uncheck the option **Show Navigation
    Bar**:![Developing the iOS part of the app](img/00192.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now return to the original view controller and simply add a table view on that.
    In this case we need to display some cells with contents and we also need to do
    something when they are selected. This means that we will need to set the view
    controller to `UITableViewDelegate` and `UITableViewDatasource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, bind the table view with the view controller as the data source
    and delegate. As a data source, we need an array of `FilmData`, which will be
    an attribute initialized with a private function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Of course, we are going to receive an error here because we need to implement
    this function, so do it outside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that we need to complete the data source methods on the view controller
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even then, the app is not finished yet. You should press play and test it, and
    you will see a view similar to the following one. Don't forget to make sure that
    you have chosen the right schema; otherwise it will restart the application:![Developing
    the iOS part of the app](img/00193.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this phase is done, we can return to our view controller and implement
    the last method. Don''t worry when you get some compiler errors, they are going
    to be fixed soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This view controller is done, the next step is to create a new Cocoa Touch class
    that inherits from the UIViewController, called `FilmDetailViewController`. Uncheck
    the **XIB** option:![Developing the iOS part of the app](img/00194.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have your new Swift file you can return to the storyboard and add a
    new view controller. In this storyboard add five labels, one stepper, a text view,
    and a button. Change the text view background to gray. You should have a layout
    similar to the following one:![Developing the iOS part of the app](img/00195.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new view controller needs to know that its class is not the default view
    controller, therefore select the view controller, go to its identity inspector
    and change its class to **FilmDetailViewController**. Levering that we are here,
    we should also set **Storyboard ID** to `film_detail`:![Developing the iOS part
    of the app](img/00196.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now link the labels, the stepper, and the text view with the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have these attributes we can set the actions. The only one that will
    need a protocol is the text view; then start adding the `UITextViewDelegate` to
    the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that we can connect the view controller as the text view delegate, create
    an action called done for the button, and another one called `changeScore` as
    the stepper value changed event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Coding the class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Great, now we can code the previous class without worrying about the storyboard.
    Let''s start with the attribute `film`, which will contain the information of
    the movie that is on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we can initialize the views we have on screen and an inherited attribute
    called `userActivity`. Remember that here we suppose that the attribute film was
    already set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that we can complete the views events; here we are going to add a new
    one called `textViewDidChange`, which belongs to the `UITextViewDelegate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last part of this code is about getting all of the information we want
    to transmit and updating the `userActivity` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing the app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The app is done and as you know, we have to test it. Before pressing play, make
    sure that the right schema is selected and the app is going to be installed on
    your mobile device, not on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press play, select a movie you like most (or hate most), set a score for it,
    and write your comment. Return to your Mac (remember that you haven't stopped
    the Mac application) and check that your dock has a new icon. It means that it
    detected a user activity that can be read. Click on this icon:![Testing the app](img/00197.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that your Mac app is in the foreground and it will show the information
    received from your device:![Testing the app](img/00198.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handoff works with a feature called **Activity**. Activities are some kind of
    information about what the user is doing right now, such as composing an e-mail,
    editing a video, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Handoff you have to plan three phases for your activities: creating
    the activity, updating it, and destroying it. We created it on the `viewDidLoad`
    method, updated it every time the user changed the score or the opinion text,
    and destroyed it when the user pressed the done button.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use Handoff on your own classes you have to add an `NSUserActivity`
    object. A good feature about this class is that it is the same using the AppKit
    (OS X) and the UIKit (iOS). Some classes already have this object as a property
    such as `NSDocument`, `UIDocuments`, `NSResponder`, and `UIResponder`.
  prefs: []
  type: TYPE_NORMAL
- en: As the `UIViewController` inherits from `UIResponder`, we could use the existing
    attribute `userActivity`. Every time that we or the app thinks that the activity
    needs to be updated, the method `updateUserActivityState` is called. Here it should
    set the whole information that should be transmitted even when the information
    hasn't changed such as the movie title, the director, or the production year because
    after updating the state, the `userInfo` dictionary is going to empty.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't overload the user info dictionary; Apple recommends storing up to 3k of
    information, more than that can affect the application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For receiving the information we need two steps: the first one is checking
    whether the app accepts the activity at that moment by implementing the method
    `willContinueUserActivityWithType` on the app delegate. The other one is implementing
    the app delegate method `continueUserActivity` for retrieving the information
    and sending it to the corresponding view or object.'
  prefs: []
  type: TYPE_NORMAL
- en: An important detail is that Handoff is for being used between apps by the same
    company or developer and only with the same user; that's the reason that you have
    to use the same team signature and the user must be logged in.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we created an app that edits your movie opinion and another one
    that can receive it, however you can modify the Mac application in a way that
    it can also edit and retransmit it to the device application. Try to do it as
    homework.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apple has a good sample about how to use Handoff with photos; have a look at
    [https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html](https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html)
    to download it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaving breadcrumbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever gone somewhere and started wondering whether your path was the
    best one? At times, we would like to review our journey once we've reached the
    destination. Usually we do this when the journey has been a very long one. In
    this recipe, we are going to create an app for recording our steps and then we
    can check the path we took.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new single-view application called `Chapter 11 Breadcrumbs`, add the
    `Core Location` framework, and the `Map Kit` framework. You can use the simulator
    or a physical device for testing this app, however if you are as lazy as me, it
    will be better using the simulator, that way you don''t have to stand up and walk
    to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have added the frameworks, you just need to follow these steps for
    creating the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the storyboard, add a label on the top, a button under it, and a map view
    under that. The result can be similar to the following screenshot:![How to do
    it…](img/00200.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, start connecting the label and the map view with the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can click on the view controller and start by importing the core location
    and the map kit frameworks, and of course don''t remove the UIKit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, complete the `ViewController` class by adding the `CLLocationManagerDelegate`
    and the `MKMapViewDelegate` protocols, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is adding the view controller attributes. In this case we will
    need the location manager for receiving the current position, an array of positions
    that we have passed through, and a Boolean attribute for following the user on
    the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to initialize the manager attribute and the map view to do it,
    so we are going to use the method `viewDidLoad`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to update the map view and the `locationStack` every time we receive
    a new location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The app is still not displaying the path; the reason is that we need to draw
    it by writing the map view method `renderForOverlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the app is working; however it can be quite difficult to check our journey
    because it is always being updated, so it is time to add the button event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The app is almost done. There is one detail that you still need to set up:
    the permission on iOS 9\. So go to your `info.plist`, then add a new record with
    the key **Required background modes**, and write in `Item 0` a string value of
    **App registers for location updates**:![How to do it…](img/00201.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the app is done, press play and walk around if you are using a physical
    device or click on **Debug**, then scroll down to location and select freeway
    drive if you are using the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core location framework allows us to retrieve the current device position
    but of course it needs a delegate; that's the reason we had to implement the `CLLocationManagerDelegate`
    protocol. This protocol receives positions from the method `didUpdateLocations`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we receive it, we could store the location into the `locationStack` array.
    Actually if you don't want to keep information of the whole journey, you can just
    store the last location.
  prefs: []
  type: TYPE_NORMAL
- en: After storing a new location, we can create a polyline, which is like a segment
    of our journey. This information is submitted to the map view.
  prefs: []
  type: TYPE_NORMAL
- en: The map view needs to render it with the method `rendererForOverlay` of the
    `MKMapViewDelegate`. The reason for that is that you are free to draw what you
    want on the map, and you can create shapes such as circles, squares, and so on
    for highlighting an area.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a route on a map view is something very common, mainly if you would
    like to use directions. Have a look at MKDirections, which can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Currency Converter app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, our apps must be prepared to be executed everywhere; therefore your
    app should have as many languages as possible. Consider that internationalization
    is very important for using different languages or different number formats.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create an app that will show us the currency
    exchange rate, but more important than that, it will be adapted to the current
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a single-view application called `Chapter 11 Currency Converter` and
    place the two flag pictures on the `images.xcassets`. These pictures can be downloaded
    from the book resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the Currency Converter app:'
  prefs: []
  type: TYPE_NORMAL
- en: First, click on the **Supporting Files** group and add a new file. In this case,
    go to the **Resource** section and select the **Strings File**:![How to do it…](img/00202.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this file, add these keys with their corresponding values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, go to the storyboard and add four labels, two buttons, a text field, and
    an image view on the bottom, similar to the following screenshot:![How to do it…](img/00203.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have your layout done, connect the UI components (except the title
    label) with the view controller with the following names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the text field **Keyboard Type** to **Numbers and Punctuations** in the
    attribute inspector:![How to do it…](img/00204.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the protocol `UITextFieldDelegate` to the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, set the view controller as the text field delegate and write `Amount of
    money` as the text field placeholder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another important action is changing the view class from `UIView` to `UIControl`
    so we can hide the keyboard easily:![How to do it…](img/00205.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the view controller and add the following attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this time, we can start coding the view controller methods; starting from
    the beginning we are going to implement the `viewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, there is a private method called `setup`, which we are going
    to implement right now. This method is responsible for retrieving the currency
    rate from the Internet and calculates the value of the amount of money that the
    user has entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to implement the buttons event. The event is the same for both
    of them, so connect the touch up event with this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect the main view (the one that we changed to `UIControl`) touch up event
    with the view controller creating a method called touchup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can complete the view controller with the last method, which allows
    us to hide the keyboard when the return key is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app is basically done, however we can only say that it is ready for localization,
    but except for the currency format we can say that there is nothing that could
    demonstrate it. So click on your project on the project navigator, and go to the
    info tab of the project. Make sure that you selected the project and not the target.
    Scroll down to the **Locations** section and click on the plus sign. Select **Spanish,**
    a new language:![How to do it…](img/00206.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now expand your storyboard and select **Main.strings (Spanish)**:![How to do
    it…](img/00207.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the title from `Currency Converter` to `Conversor de monedas` and the
    text field place holder from `Amount of money` to `Cantidad de dinero`. The modified
    lines should be similar to the following ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to design the whole layout before translating it to other languages; adding
    components to your view sometimes makes you translate everything again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Return to `Localizable.strings`, and on the file inspector, click on the **Localize…**
    button, which is located in the **Localization** section:![How to do it…](img/00208.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dialog requesting to move this file to the `lproj` folder will appear. Choose
    the base language:![How to do it…](img/00209.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the localization section has replaced the old button with some
    language options; check the **Spanish** option:![How to do it…](img/00210.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `Localizable.strings` and click the Spanish one:![How to do it…](img/00211.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now update the values translating them to the Spanish language, as in the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's time to test our app, press play and check that the app works perfectly
    fine, then press the home button, go to **Settings**, enter into the **General**
    section, tap (or click) on **Language & Region**, and change the region to **Spain**
    and the language to **Spanish**. Now return to your app and you should see it
    with Spanish text; the numbers should be represented with the Spanish format:![How
    to do it…](img/00212.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you would like to translate your app to other languages you first have
    to create it with the base language (default language) but bear in mind that every
    text can be translated; therefore instead of using hardcoded text, you have to
    retrieve it from the `Localizable.strings` file.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `NSLocalizedString` for retrieving strings from the Localizable file.
    You can also get format strings and use them in the String format initializer.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use date and number formatters using `NSDateFormatter` and `NSNumberFormatter`;
    that way you don't have to worry about local dates and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to translate your storyboard, so it is not necessary to set
    the labels and placeholders on the view did load.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also translate other files such as the launch screen and the `Info.plist`.
    For example you can change the application name according to the language using
    the `Bundle display name` key (`CFBundleDisplayName`).
  prefs: []
  type: TYPE_NORMAL
- en: The `NSLocalizedString` has other options that allow you to use translation
    in complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: Method swizzling in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method swizzling is a well-known practice with programming languages that support
    a dynamic method dispatch. This is also very common in Objective-C. With method
    swizzling, you are able to swap out a method implementation for a different one
    at runtime. It is recommended to use method swizzling sparingly and only when
    an alternative (possibly protocols or extensions) is not present.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a playground and name it `Swizzling`. We will not be using a project
    for this recipe so do not worry about project settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use `UIViewController` as an example. Add the following code to your
    playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to make sure that we are not swizzling from a subclass when we
    expect the super class. Add the following code after initializing the static struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example we want additional actions to be taken for every `UIViewController`;
    however, we need to preserve the original functionality of `viewWillAppear`. This
    can only be accomplished with method swizzling. Although Swift takes a more static
    approach to method dispatch, you are still able to swizzle methods at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We wrap every call in a `dispatch_once` block to guarantee this only happens
    once at runtime. We define each Selector, both the existing and the new one. Once
    we make a call to `class_addMethod` we check that it worked, and if so, swap implementations
    (happens at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Objective-C, you will note that normally swizzling
    methods occur in the load method, which is guaranteed to be called when a class
    definition is loaded. Considering this is an Objective-C method only, we call
    the swizzling code in initialize, which occurs before any class methods are called.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to swizzling system methods, you can also swizzle methods created
    in custom Swift classes. There are some extra considerations, however. The class
    must extend NSObject and the desired method must also include the dynamic attribute
    in their definition. Using `@objc` will cause your code to run through the Objective-C
    runtime (thus supporting dynamic method dispatch); however, it does not guarantee
    the dynamic dispatch of a property or method.
  prefs: []
  type: TYPE_NORMAL
- en: Associated objects in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to method swizzling, we can also utilize another runtime process
    known as associated objects. This is similar to extensions in Swift; however,
    extensions do not allow you to add a new property to an existing class. Let's
    add a descriptive name property to all UIViewControllers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a playground and name it `Associated Objects`. We will not be using a
    project for this recipe so do not worry about project settings. If you used the
    previous recipe, you may continue with the same playground file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to your playground file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a private static struct to store keys that reference our objects.
    In this case, it will only be the `DescriptiveName` object. Now we define a new
    variable for `UIViewController` and perform the required methods in the get and
    set methods.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `objc_getAssociatedObject()` to return the proper object and cast
    it as a String object. For set, we call the `objc_setAssociatedObject()` method.
    Here we pass in self to let the runtime know we are adding to the `UIViewController`
    and then reference our static struct for the object we want to associate with
    the class. Last, we set up the property to be retained and non-atomic.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that every `UIViewController` will contain a new property, `DescriptiveName`,
    which can be accessed anywhere in code.
  prefs: []
  type: TYPE_NORMAL
