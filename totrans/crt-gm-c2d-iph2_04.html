<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Give a Snake a Snack…</h1></div></div></div><p>One of the challenges of object-oriented design for a game is how to build fully cohesive objects that function as needed for a game. We will build this project with that focus in mind. The main class for the player will be as self-contained and self-sufficient as possible.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overriding methods</li><li class="listitem" style="list-style-type: disc">Self-contained classes</li><li class="listitem" style="list-style-type: disc">Difficulty levels</li><li class="listitem" style="list-style-type: disc">Scaling level progression</li><li class="listitem" style="list-style-type: disc">Object lifespan control</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>The project is…</h1></div></div></div><p>This chapter will take on the often copied game that has <a id="id689" class="indexterm"/>
<a id="id690" class="indexterm"/>graced pretty much every possible computing platform, from early cell phones to current consoles: the snake game. There are many variations under a variety of names, but the mechanics are generally the same. You control a snake that is always moving forward. You can turn the snake right or left (at right angles only), avoiding walls and eating mice (or other food). Each time you eat something, your snake gets longer. You can go on eating (and growing) until you run into a wall or your own tail.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Design approach</h2></div></div></div><p>The "classic" way to handle the snake's movement in a snake game is to draw a new body segment in the direction the snake is moving, and erase the one at the end. <a id="id691" class="indexterm"/>While this <a id="id692" class="indexterm"/>approach works, we want to use a more object-oriented approach in our design.</p><p>We will focus on letting the snake be as autonomous as possible. We want a <code class="literal">snake</code> class that we can simply instruct to move, and the <a id="id693" class="indexterm"/>
<code class="literal">snake</code> object will handle the movement itself. The <a id="id694" class="indexterm"/>
<code class="literal">snake</code> class will also be able to handle what to do when we pass it a message to "turn left" or "turn right".</p><p>The levels should be generated with a variable number of walls inside the playfield, as well as drawing outer walls around the edge of the screen. Finally, we need to have mice appear on the playfield as the food. These mice should have a limited lifespan, so they will disappear if they are not eaten in a given amount of time. <a id="id695" class="indexterm"/>
<a id="id696" class="indexterm"/>When a mouse is eaten or runs out of life, we will replace it with another. Let's see what it should look like:</p><div><img src="img/9007_04_01.jpg" alt="Design approach"/></div><p>We will also establish three difficulty levels, and incrementing game levels for each difficulty. Since the game is based primarily on random elements, we need to use the difficulty and the level number in setting the variable elements in the game (for example, high levels are faster with more mice and more walls), as well as the snake's movement speed. That doesn't sound too difficult, does it?</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Building a better snake</h1></div></div></div><p>The first thing we need to keep in mind is that the snake is of a variable length. The snake could be as short as one segment or as long as 100 segments <a id="id697" class="indexterm"/>(in theory—we won't get that long in our game). <a id="id698" class="indexterm"/>As we said during the design, the snake should be as autonomous as possible. With that in mind, let's look at the <code class="literal">SNSnake.h</code> file to see what we need.</p><p>
<strong>Filename</strong>: <a id="id699" class="indexterm"/>
<a id="id700" class="indexterm"/>
<code class="literal">FileSNSnake.h</code>
</p><div><pre class="programlisting">#import "SNSnakeSegment.h"

@class SNPlayfieldLayer;

@interface SNSnake : CCNode {
    
    SNPlayfieldLayer *parentLayer; // Parent layer
    NSMutableArray *snakebody; // Contains the snake
    NSInteger headRow; // Starting row for snake head
    NSInteger headColumn; // Starting col for snake head
    
    SnakeHeading _snakeDirection;  // Direction facing
    float _snakeSpeed; // Current rate of movement
}

@property (nonatomic, retain) NSMutableArray *snakebody;
@property (nonatomic, assign) SnakeHeading snakeDirection;
@property (nonatomic, assign) float snakeSpeed;

+(id) createWithLayer:(SNPlayfieldLayer*)myLayer
           withLength:(NSInteger)startLength;

-(void) addSegment;
-(void) move;
-(void) turnLeft;
-(void) turnRight;
-(void) deathFlash;

@end</pre></div><p>We need to track how fast the snake should move (<code class="literal">snakeSpeed</code>) and what direction it is moving in (<code class="literal">snakeDirection</code>). But what is this <a id="id701" class="indexterm"/>
<a id="id702" class="indexterm"/>
<code class="literal">SnakeHeading</code> variable type? We will again be placing our common definitions in a separate definitions <a id="id703" class="indexterm"/>file, <code class="literal">SNDefinitions.h</code>. Even though we did not import that file in this header, it is imported in the <code class="literal">SNSnakeSegment.h</code> file, which is then imported here, so we <a id="id704" class="indexterm"/>can use it freely. The definition of <code class="literal">SnakeHeading</code> is:</p><p>
<strong>Filename</strong>: <a id="id705" class="indexterm"/>
<a id="id706" class="indexterm"/>
<code class="literal">SNDefinitions.h</code>
</p><div><pre class="programlisting">typedef enum {
    kUp = 1,
    kRight,
    kLeft,
    kDown
} SnakeHeading;</pre></div><p>The <code class="literal">SnakeHeading</code> type <a id="id707" class="indexterm"/>
<a id="id708" class="indexterm"/>uses these four directional values (which are integers in disguise) to keep track which direction, relative to the playfield, the snake is facing. This is easier than trying to remember that one means "up".</p><p>The entire snake's body, including the head, will be stored in the <code class="literal">NSMutableArray</code> <code class="literal">snakeBody</code>. This array will contain objects of type <code class="literal">SNSnakeSegment</code>, but we don't have to provide those specifics in the header.</p><p>One aspect worth pointing out is that we declare some of these variables as properties. Why only some, and not others? When you declare a property, it can be accessed from outside the class. A variable without a property declaration will be only usable inside the class in which it is defined. So here, we know we will want the main playfield to be able to use the <code class="literal">snakeSpeed</code>, <code class="literal">snakeDirection</code>, and <code class="literal">snakeBody</code>, so we declare those as properties.</p><p>The <code class="literal">headRow</code> and <code class="literal">headColumn</code> <a id="id709" class="indexterm"/>
<a id="id710" class="indexterm"/>
<a id="id711" class="indexterm"/>
<a id="id712" class="indexterm"/>are convenience variables to keep track of where we want the head of the snake to start in our playing grid. These could be done away with entirely and hardcode the starting values, but this allows us to easily relocate the snake's starting position without digging through the code to identify the values to change.</p><p>We will be handling all of the segment creation within this class (using the <a id="id713" class="indexterm"/>
<a id="id714" class="indexterm"/>
<code class="literal">addSegment</code> method), so we need to keep a reference to the game layer itself. This is stored in the <code class="literal">parentLayer</code> variable, which is of type <code class="literal">SNPlayfieldLayer</code>. As we discussed in <a class="link" href="ch03.html" title="Chapter 3. Thumping Moles for Fun">Chapter 3</a>, <em>Thumping Moles for Fun</em>, the <a id="id715" class="indexterm"/>
<a id="id716" class="indexterm"/>
<code class="literal">@class</code> declaration at the top of the header file tells the compiler "we have a class called <code class="literal">SNPlayfieldLayer</code>
<a id="id717" class="indexterm"/>
<a id="id718" class="indexterm"/>, but that's <a id="id719" class="indexterm"/>
<a id="id720" class="indexterm"/>all you need to know for now". Unlike our use of a forward declaration in <a class="link" href="ch03.html" title="Chapter 3. Thumping Moles for Fun">Chapter 3</a>, we do need to call a method from that class, so we will add the line <code class="literal">#import "SNPlayfieldLayer.h"</code> into the <code class="literal">SNSnake.m</code> file.</p><p>We also provide several exposed methods in the header. These should all be fairly self-explanatory. We do need to point out the one class method, <a id="id721" class="indexterm"/>
<a id="id722" class="indexterm"/>
<code class="literal">createWithLayer: withLength:</code>. In earlier chapters, we often took the approach of using default <code class="literal">init</code> structures, and filled in the variables after the object was instantiated. While this does work, it is often cleaner to build your own class methods to ensure that no required parameters are overlooked. This approach also allows us to pursue our goal with this game of making the snake as self-contained as possible.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Anatomy of a snake segment</h2></div></div></div><p>Before we dive into the <code class="literal">SNSnake</code> <a id="id723" class="indexterm"/>
<a id="id724" class="indexterm"/>implementation, let's <a id="id725" class="indexterm"/>turn our attention to the <code class="literal">SNSnakeSegment</code>. This is the <a id="id726" class="indexterm"/>object that will represent each segment of the snake, both head and body. This class is a mostly unmodified subclass of <code class="literal">CCSprite</code>, but we will make a small, yet important change to its behavior.</p><p>
<strong>Filename</strong>: <code class="literal">SNSnakeSegment.h</code>
</p><div><pre class="programlisting">@interface SNSnakeSegment : CCSprite {
    CGPoint _priorPosition; 
    SNSnakeSegment *_parentSegment; 
}

@property (nonatomic, assign) CGPoint priorPosition;
@property (nonatomic, assign) SNSnakeSegment *parentSegment;

@end</pre></div><p>We establish a property named <code class="literal">priorPosition</code>
<a id="id727" class="indexterm"/>
<a id="id728" class="indexterm"/>
<a id="id729" class="indexterm"/>
<a id="id730" class="indexterm"/>, which is the position where this sprite was before the last time it moved. We also keep a property for <code class="literal">parentSegment</code>. The <a id="id731" class="indexterm"/>
<a id="id732" class="indexterm"/>
<code class="literal">parentSegment</code> is the segment of the snake directly in front of the current segment. In this way, each snake segment has a direct connection to the segment in front of it.</p><p>
<strong>Filename</strong>: <a id="id733" class="indexterm"/>
<a id="id734" class="indexterm"/>
<code class="literal">SNSnakeSegment.m</code>
</p><div><pre class="programlisting">@implementation SNSnakeSegment

@synthesize priorPosition = _priorPosition;
@synthesize parentSegment = _parentSegment;

-(void) setPosition:(CGPoint)position {
    // override the method to let us keep the prior position
    self.priorPosition = self.position;
    [super setPosition:position];
}

@end</pre></div><p>This class is very brief, yet it will make our game a lot easier to build. In most ways this will behave as a normal <code class="literal">CCSprite</code>, except when the <code class="literal">setPosition</code> method is used. We are overriding <code class="literal">setPosition</code> to provide new behavior. First, we store our current position in the <code class="literal">priorPosition</code> variable, and then we call the <code class="literal">super setPosition </code>method, which actually calls the standard <a id="id735" class="indexterm"/>
<a id="id736" class="indexterm"/>
<code class="literal">CCSprite</code> <code class="literal">setPosition</code> method. All told, this will behave like a standard <code class="literal">setPosition</code>, except that it is quietly <a id="id737" class="indexterm"/>storing the coordinates of its last position before the <a id="id738" class="indexterm"/>move. To understand why, we will need to look at the snake's implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Dissecting the snake</h2></div></div></div><p>Let's begin with the <a id="id739" class="indexterm"/>
<a id="id740" class="indexterm"/>
<code class="literal">createWithLayer:withLength:</code> class method, and the <a id="id741" class="indexterm"/>
<a id="id742" class="indexterm"/>related <a id="id743" class="indexterm"/>
<a id="id744" class="indexterm"/>
<code class="literal">initWithLayer:withLength:</code> instance method.</p><p>
<strong>Filename</strong>: <a id="id745" class="indexterm"/>
<a id="id746" class="indexterm"/>
<code class="literal">SNSnake.m</code>
</p><div><pre class="programlisting">+(id) createWithLayer:(SNPlayfieldLayer*)myLayer
           withLength:(NSInteger)startLength {
    return [[[self alloc] initWithLayer:myLayer
            withLength:startLength] autorelease];
}

-(id) initWithLayer:(SNPlayfieldLayer*)myLayer
                withLength:(NSInteger)startLength {
    if (self = [super init]) {
        
        // Keep a reference to the parent, so we can use
        // the parent layer's positioning method
        parentLayer = myLayer;

        // Set up the snakebody array
        snakebody = [[NSMutableArray alloc]
                     initWithCapacity:30];

        // Set the starting defaults
        headRow = 2;
        headColumn = 2;
        self.snakeSpeed = 0.3;
        self.snakeDirection = kUp;
        
        // Add the head
        [self addHead];
        
        // Add the requested number of body segments
        for (int i = 1; i &lt; startLength; i++) {
            [self addSegment];
        }
    }
    return self;
}</pre></div><p>We keep a reference to the layer passed (as <code class="literal">parentLayer</code>), initialize the <code class="literal">NSMutableArray snakeBody</code>, and set some default values for the rest of the variables. We then call <code class="literal">addHead</code> to add the snake's head. This must be called before we make any calls to <code class="literal">addSegment</code>, because we need the head to be the first element in the array. We then use the <a id="id747" class="indexterm"/>
<code class="literal">startLength</code> variable to determine how many times we <a id="id748" class="indexterm"/>need to call the <a id="id749" class="indexterm"/>
<a id="id750" class="indexterm"/>
<code class="literal">addSegment</code> method. Notice that the <a id="id751" class="indexterm"/>
<a id="id752" class="indexterm"/>
<code class="literal">addSegment</code> loop will iterate one time less than the passed <code class="literal">startLength</code>. We do this because the head does count as a <a id="id753" class="indexterm"/>part of the snake length, so if we requested a <code class="literal">snakeLength</code> of five, we only need to generate four body segments.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Building the head</h2></div></div></div><p>Now let's look at the <a id="id754" class="indexterm"/>
<a id="id755" class="indexterm"/>
<a id="id756" class="indexterm"/>
<code class="literal">addHead</code> method.</p><p>
<strong>Filename</strong>: <code class="literal">SNSnake.m</code>
</p><div><pre class="programlisting">-(void) addHead {
    // Create the snake head
    SNSnakeSegment *newSeg = [SNSnakeSegment
            spriteWithSpriteFrameName:@"snakehead.png"];
    
    // We use the parent layer's positioning method, so we 
    // will still be in lockstep with the other objects
    CGPoint newPos = [parentLayer positionForRow:headRow
                                andColumn:headColumn];
    
    // Set up the snake's initial head position
    [newSeg setPosition:newPos];
    [newSeg setPriorPosition:newSeg.position];
    
    // The head has no parent segment
    [newSeg setParentSegment:nil];
    
    // Add the head to the array and parent
    [snakebody addObject:newSeg];
    [parentLayer addChild:newSeg z:100];
}</pre></div><p>We begin this method by using the standard <code class="literal">CCSprite</code> <code class="literal">spriteWithSpriteFrameName</code> convenience method to create the sprite. Next we see one of the reasons we keep a reference to the <code class="literal">parentLayer</code>. To set the value of the <code class="literal">CGPoint newPos</code>, we call the <code class="literal">positionForRow:andColumn:</code> method <a id="id757" class="indexterm"/>
<a id="id758" class="indexterm"/>directly from the parent layer. Calling the method from the parent layer guarantees we are using the same grid formula for all object position calculations, without having to maintain multiple versions of <a id="id759" class="indexterm"/>the same <a id="id760" class="indexterm"/>
<a id="id761" class="indexterm"/>
<code class="literal">positionForRow:</code> method in different classes. This is the only piece of code that uses the <a id="id762" class="indexterm"/>
<a id="id763" class="indexterm"/>
<code class="literal">headRow</code> and <a id="id764" class="indexterm"/>
<a id="id765" class="indexterm"/>
<code class="literal">headColumn</code> variables, so we could have avoided those variables and embedded the values directly in this method call if we wanted to tighten up the code. We set the position for our <code class="literal">newSeg</code> to the value of <code class="literal">newPos</code>, and then we set the value of <code class="literal">priorPosition</code> to the same value.</p><p>The next line is the only real substantial difference between the head and a body segment: we set the <code class="literal">parentSegment</code> to nil. If the segment does not have a <code class="literal">parentSegment</code>, we can be sure it is the head segment.</p><p>After adding the snake's head to the <code class="literal">snakeBody</code> array, we add the <a id="id766" class="indexterm"/>head as a child of the <code class="literal">parentLayer</code>. Notice we use a <code class="literal">Z</code> order of 100. When we create the snake, we want the head to overlap the next body segment, so we start with a high <code class="literal">Z</code> value for the head.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Building the body segments</h2></div></div></div><p>We now turn our attention to the <a id="id767" class="indexterm"/>
<a id="id768" class="indexterm"/>
<code class="literal">addSegment</code> method, <a id="id769" class="indexterm"/>which adds a single body segment to the <a id="id770" class="indexterm"/>snake.</p><p>
<strong>Filename</strong>: <a id="id771" class="indexterm"/>
<a id="id772" class="indexterm"/>
<code class="literal">SNSnake.m</code>
</p><div><pre class="programlisting">-(void) addSegment {
    // Create a new segment
    SNSnakeSegment *newSeg = [SNSnakeSegment
            spriteWithSpriteFrameName:@"snakebody.png"];

    // Get a reference to the last segment of the snake
    SNSnakeSegment *priorSeg = [snakebody objectAtIndex:
                                ([snakebody count] - 1)];
    
    // The new segment is positioned at the prior
    // position as stored in priorSeg
    [newSeg setPosition:[priorSeg position]];
    
    // We start with same position for both variables
    [newSeg setPriorPosition:[newSeg position]];
    // Connect this segment to the one in front of it
    [newSeg setParentSegment:priorSeg];
    // Add the segment to the array and layer
    [snakebody addObject:newSeg];
    [parentLayer addChild:newSeg z:100-[snakebody count]];
}</pre></div><p>At first glance, this looks very similar to the <a id="id773" class="indexterm"/>
<a id="id774" class="indexterm"/>
<code class="literal">addHead</code> method. Let's take a closer look. We use a different image for the body segments. Then we look up the last segment in the <code class="literal">snakeBody</code> array. Here we use the prior segment's position as the position for our new segment. We also set the <a id="id775" class="indexterm"/>
<a id="id776" class="indexterm"/>
<code class="literal">parentSegment</code> variable to point to the prior segment. So each segment now has a connection to the one in front of it, and it <a id="id777" class="indexterm"/>identifies its own position as being in the prior location of the parent segment. (For the initial building of the snake, these will all share the same <a id="id778" class="indexterm"/>coordinates, but this design will be essential when we are calling this method during gameplay.)</p><p>We add this segment to the <a id="id779" class="indexterm"/>
<a id="id780" class="indexterm"/>
<code class="literal">snakeBody</code> array, and then add this segment to the <code class="literal">parentLayer</code>. You will notice we assign the <code class="literal">Z</code> order as <code class="literal">100 – [snakeBody count].</code> This will essentially slip each segment under the segment in front of it, since a higher <code class="literal">Z</code> order is drawn on top of lower <code class="literal">Z</code> orders.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Moving the snake</h1></div></div></div><p>We now turn our attention to the way we move the snake. Since we want <a id="id781" class="indexterm"/>as much of the snake's control <a id="id782" class="indexterm"/>inside the snake object, we will be generating our own <a id="id783" class="indexterm"/>
<a id="id784" class="indexterm"/>
<code class="literal">move</code> method, instead of using <code class="literal">setPosition</code>.</p><p>
<strong>Filename</strong>: <a id="id785" class="indexterm"/>
<a id="id786" class="indexterm"/>
<code class="literal">SNDefinition.h</code>
</p><div><pre class="programlisting">#define gridSize 22</pre></div><p>In the <code class="literal">SNDefinitions.h</code> file we have created a <code class="literal">gridSize</code> definition that works well with the graphics we have defined for this project. Having a centralized <code class="literal">gridSize</code> definition allows us to alter the dimensions of the playfield in one <a id="id787" class="indexterm"/>place. With that definition fresh in our minds, let's look at the <code class="literal">move</code> method.</p><p>
<strong>Filename</strong>: <a id="id788" class="indexterm"/>
<a id="id789" class="indexterm"/>
<code class="literal">SNSnake.m</code>
</p><div><pre class="programlisting">-(void) move {
    CGPoint moveByCoords;
    // Based on the direction, set the coordinate change
    switch (self.snakeDirection) {
        case kUp:
            moveByCoords = ccp(0,gridSize);
            break;
        case kLeft:
            moveByCoords = ccp(-gridSize,0);
            break;
        case kDown:
            moveByCoords = ccp(0,-gridSize);
            break;
        case kRight:
            moveByCoords = ccp(gridSize,0);
            break;
        default:
            moveByCoords = ccp(0,0);
            break;
    }
    
    // Iterate through each segment and move it
    for (SNSnakeSegment *aSeg in snakebody) {
        if (aSeg.parentSegment == nil) {
            // Move the head by the specified amount
            [aSeg setPosition:ccpAdd(aSeg.position,
                                     moveByCoords)];
        } else {
            // Body segments move to the prior position 
            // of the segment ahead of it
            [aSeg setPosition:
                    aSeg.parentSegment.priorPosition];
        }
    }
}</pre></div><p>We use the <a id="id790" class="indexterm"/>
<a id="id791" class="indexterm"/>
<code class="literal">snakeDirection</code> variable and the defined <code class="literal">gridSize</code> to determine where to move the head of the snake. All of the snake's movements will be constrained to the grid. If we allowed free movement, it would be extremely easy to run into the edges of a wall. By constraining the snake's movements to a grid, we allow the snake to have "close calls" with walls without dying because they were one pixel too close.</p><p>We then iterate through all members of the <a id="id792" class="indexterm"/>
<a id="id793" class="indexterm"/>
<code class="literal">snakeBody</code> array. If the segment does not have a <code class="literal">parentSegment</code> defined, it is the head. We use the <code class="literal">ccpAdd</code> function to add the new <code class="literal">moveByCoords</code> to the head's current position. The <a id="id794" class="indexterm"/>
<a id="id795" class="indexterm"/>
<code class="literal">ccpAdd</code> function takes two <code class="literal">ccp</code> coordinates as arguments and adds them together into a new <code class="literal">ccp</code> value. <a id="id796" class="indexterm"/>The end result is a new position for the head segment, moved in the desired direction.</p><p>If there is a <code class="literal">parentSegment</code> defined, it is a normal body segment. Here is where we take advantage of the extra variables we added to the <a id="id797" class="indexterm"/>
<a id="id798" class="indexterm"/>
<code class="literal">SNSnakeSegment</code> class. We set the segment's position to the prior position of their parent segment. This means <a id="id799" class="indexterm"/>for each segment, it will move to the same position just vacated by the segment in front of it. In this way, the snake's body will follow the same path as the head, even through multiple turns.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Turning the snake</h2></div></div></div><p>Now that we have addressed moving the snake, we need to <a id="id800" class="indexterm"/>make it turn. <a id="id801" class="indexterm"/>As we just saw in the <code class="literal">move</code> method, the movement is completely driven by the <a id="id802" class="indexterm"/>
<a id="id803" class="indexterm"/>
<code class="literal">snakeDirection</code> variable. All we need to do is adjust that variable, and the snake will move in the new direction.</p><p>
<strong>Filename</strong>: <code class="literal">SNSnake.m</code>
</p><div><pre class="programlisting">-(void) turnLeft {
    switch (self.snakeDirection) {
        case kUp:
            self.snakeDirection = kLeft;
            break;
        case kLeft:
            self.snakeDirection = kDown;
            break;
        case kDown:
            self.snakeDirection = kRight;
            break;
        case kRight:
            self.snakeDirection = kUp;
            break;
        default:
            break;
    } 
}</pre></div><p>If the snake is sent the message to <code class="literal">turnLeft</code>, and the snake is currently facing up, the new direction will be facing left. We check each of the four movement directions, and change the snake's direction appropriately. Since the <a id="id804" class="indexterm"/>
<a id="id805" class="indexterm"/>
<code class="literal">switch</code> statements are using the <a id="id806" class="indexterm"/>integer values underlying the <code class="literal">SnakeHeading</code> type, it is very efficient and lightweight code. We repeat the same structure in the <a id="id807" class="indexterm"/>
<a id="id808" class="indexterm"/>
<code class="literal">turnRight</code> command, except we change the <code class="literal">snakeDirection</code> to turn in the correct "turn right" direction. (See the <a id="id809" class="indexterm"/>code bundle if you need to see how <code class="literal">turnRight</code> differs from <code class="literal">turnLeft</code>.)</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Death of a snake</h2></div></div></div><p>There is one method left to complete the snake. At some point, <a id="id810" class="indexterm"/>the player will do something unfortunate and run into a wall (or their own tail). <a id="id811" class="indexterm"/>The snake dies, and game is over. We include the visual "death" in the snake class.</p><p>
<strong>Filename</strong>: <code class="literal">SNSnake.m</code>
</p><div><pre class="programlisting">-(void) deathFlash {
    // Establish a flashing/swelling animation of head
    CCTintTo *flashA = [CCTintTo actionWithDuration:0.2
                        red:255.0 green:0.0 blue:0.0];
    CCTintTo *flashB = [CCTintTo actionWithDuration:0.2
                        red:255.0 green:255.0 blue:255.0];
    CCScaleBy *scaleA = [CCScaleBy actionWithDuration:0.3
                        scale:2.0];
    CCScaleBy *scaleB = [CCScaleBy actionWithDuration:0.3
                        scale:0.5];
    
    SNSnakeSegment *head = [snakebody objectAtIndex:0];
    
    [head runAction:[CCRepeatForever actionWithAction:
            [CCSequence actions:flashA, flashB, nil]]];
    [head runAction:[CCRepeatForever actionWithAction:
            [CCSequence actions:scaleA, scaleB, nil]]];
}</pre></div><p>We leverage <code class="literal">cocos2d</code> actions to give a nice death sequence. We set up two separate <code class="literal">CCRepeatForever</code> sequences that are run simultaneously on the snake's head. We flash red and then back to normal sprite color (setting the color to pure white gives the original sprite coloring). We also scale the head to twice its own size, and then back to normal. We set these with slightly different durations, so the two behaviors are <a id="id812" class="indexterm"/>
<a id="id813" class="indexterm"/>not in lockstep with each other. Together, these provide a nice appearance of throbbing pain, perfect for the death of the snake.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Building the environment</h1></div></div></div><p>The snake is now functionally complete, so we turn our attention to building an interesting environment for the snake to live in. All of our <a id="id814" class="indexterm"/>
<a id="id815" class="indexterm"/>game objects use the same positioning method we saw when designing the snake.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(CGPoint) positionForRow:(NSInteger)rowNum
                andColumn:(NSInteger)colNum {
    float newX = (colNum * gridSize) - 2;
    float newY = (rowNum * gridSize) - 4;
    return ccp(newX, newY);
}</pre></div><p>This method takes the designated row and column values and multiplies them by the <code class="literal">gridSize</code>. The additional modifiers (-2 and -4) are used to better align the walls so there is an equal size of partial walls on the outside edges of the screen. This is because the <code class="literal">gridSize</code> value of <code class="literal">22</code> does not exactly fit the dimensions of the iPhone screen. With this slight adjustment, it looks visually centered after we add the outer walls.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Outer walls</h2></div></div></div><p>The first part of the environment to build are the outer walls, <a id="id816" class="indexterm"/>since the snake needs to be contained on the <a id="id817" class="indexterm"/>screen. Let's look at that method.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) createOuterWalls {
    // Left and Right edges of screen
    for (int row = 0; row &lt;= size.height/gridSize+1; row++) {
        // Build a new wall on the left edge
        CGPoint newPosLeft = [self positionForRow:row
                                    andColumn:0];
        CCSprite *newWallLeft = [CCSprite
                spriteWithSpriteFrameName:@"wall.png"];
        [newWallLeft setPosition:newPosLeft];
        [self addChild:newWallLeft];
        [wallsOnField addObject:newWallLeft];

        // Build a new wall on the right edge
        CGPoint newPosRight = [self positionForRow:row
                andColumn:(size.width/gridSize)+1];
        CCSprite *newWallRight = [CCSprite
                spriteWithSpriteFrameName:@"wall.png"];
        [newWallRight setPosition:newPosRight];
        [self addChild:newWallRight];
        [wallsOnField addObject:newWallRight];
    }
    // Top and Bottom edges of screen
    for (int col = 1; col &lt; size.width/gridSize; col++) {
        // Build a new wall at bottom edge of screen
        CGPoint newPosBott = [self positionForRow:0
                                    andColumn:col];
        CCSprite *newWallBottom = [CCSprite
                spriteWithSpriteFrameName:@"wall.png"];
        [newWallBottom setPosition:newPosBott];
        [self addChild:newWallBottom];
        [wallsOnField addObject:newWallBottom];

        // Build a new wall at the top edge of screen
        CGPoint newPosTop = [self positionForRow:
                (size.height/gridSize)+1 andColumn:col];
        CCSprite *newWallTop = [CCSprite
                spriteWithSpriteFrameName:@"wall.png"];
        [newWallTop setPosition:newPosTop];
        [self addChild:newWallTop];
        [wallsOnField addObject:newWallTop];
    }
}</pre></div><p>We have two separate loops, one for each pair of edges on the screen. The loop for the left and right edges is the same, as is the top and bottom edge loop. We iterate from the minimum grid position through the maximum grid position for that edge <a id="id818" class="indexterm"/>of the screen. We base the <a id="id819" class="indexterm"/>maximum on the size of the screen divided by the <code class="literal">gridSize</code>, so we will always be at the outside edges, even if we change the <code class="literal">gridSize</code>.</p><p>For each position (and side of the screen), we create a new <code class="literal">CCSprite</code>, set its position, and add it to the layer. We also add it to the <code class="literal">wallsOnField</code> array. The <code class="literal">wallsOnField</code> array is <a id="id820" class="indexterm"/>
<a id="id821" class="indexterm"/>critical to the collision handling routines we will address shortly.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Inner walls</h2></div></div></div><p>When we move to building the inner walls, we have a couple of <a id="id822" class="indexterm"/>additional details to consider. We need to <a id="id823" class="indexterm"/>make sure the position is not already occupied by another object. We also want to make sure we don't build a wall in front of the snake.</p><p>
<strong>Filename</strong>: <a id="id824" class="indexterm"/>
<a id="id825" class="indexterm"/>
<code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) createWall {
    BOOL approvedSpot = YES;
    SNSnakeSegment *head = [[snake snakebody]
objectAtIndex:0];
    
    CGRect snakeline = CGRectMake(head.boundingBox.origin.x - 
        head.contentSize.width/2, 0,
        head.boundingBox.origin.x + head.contentSize.width/2, 
        size.height);
    
    // Randomly generate a position
    NSInteger newRow = CCRANDOM_0_1()*(size.height/gridSize);
    NSInteger newCol = CCRANDOM_0_1()*(size.width/gridSize);
    CGPoint newPos = [self positionForRow:newRow
                                andColumn:newCol];
    
    // Build a new wall, add it to the layer
    CCSprite *newWall = [CCSprite
                spriteWithSpriteFrameName:@"wall.png"];
    [newWall setPosition:newPos];
    [self addChild:newWall];
    
    // Check to make sure we aren't on top of the snake
    for (SNSnakeSegment *aSeg in [snake snakebody]) {
        if (CGRectIntersectsRect([newWall boundingBox],
                                 [aSeg boundingBox])) {
            approvedSpot = NO;
            break;
        }
    }
    // Checks for a clear path in front of the snake
    // Assumes the snake is facing up
    if (CGRectIntersectsRect([newWall boundingBox],
                             snakeline)) {
        approvedSpot = NO;
    }
    // Check to make sure there are no walls overlapping
    for (CCSprite *aWall in wallsOnField) {
        if (CGRectIntersectsRect([newWall boundingBox],
                                 [aWall boundingBox])) {
            approvedSpot = NO;
            break;
        }
    }
    // Check to make sure there are no mice in the way
    for (CCSprite *aMouse in miceOnField) {
        if (CGRectIntersectsRect([newWall boundingBox],
                                 [aMouse boundingBox])) {
            approvedSpot = NO;
            break;
        }
    }
    // If we passed everything, keep the wall
    if (approvedSpot) {
        [wallsOnField addObject:newWall];
    // If we detected an overlap, build a replacement
    } else {
        [self removeChild:newWall cleanup:YES];
        [self createWall];
        return;
    }
}</pre></div><p>We start this method by creating a <code class="literal">CGRect</code> that is directly in front of the snake. This <code class="literal">CGRect</code> <a id="id826" class="indexterm"/>assumes the snake is facing up, which is the default we established in the <a id="id827" class="indexterm"/>
<a id="id828" class="indexterm"/>
<code class="literal">SNSnake</code> class. Our design does not allow for adding extra walls during a level, so we can be sure the snake is facing up when the environment is built.</p><p>We generate a random position, based on the screen size <a id="id829" class="indexterm"/>divided by the <code class="literal">gridSize</code>. We go ahead and build a new wall and add it to the layer. At this point, we don't know if the wall is in a good position or not, but we add it anyway. We then proceed to iterate through all of our arrays to see if the new wall we just created is overlapping an <a id="id830" class="indexterm"/>existing object, using a call to <code class="literal">CGRectIntersectsRect</code>. We also check to see if the new wall is in the "line of sight" of the snake. If the wall is in an empty position, we add it to the <a id="id831" class="indexterm"/>
<a id="id832" class="indexterm"/>
<code class="literal">wallsOnField</code> array. If it is in a bad (occupied) position, we remove the wall from the layer and then call the <code class="literal">createWall</code> method again to build a replacement.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Building snake food</h2></div></div></div><p>We only have one type of object left to complete the environment: mice to eat. If you recall from our original design, we want the mice to have a limited <a id="id833" class="indexterm"/>lifespan before they disappear <a id="id834" class="indexterm"/>from the playfield. We do this by creating <code class="literal">SNMouse</code>, a subclass of <code class="literal">CCSprite</code>.</p><p>
<strong>Filename</strong>: <a id="id835" class="indexterm"/>
<a id="id836" class="indexterm"/>
<code class="literal">SNMouse.m</code>
</p><div><pre class="programlisting">+(id) spriteWithSpriteFrameName:(NSString *)spriteFrameName {
    return [[[self alloc] initWithSpriteFrameName:
             spriteFrameName] autorelease];
}
-(id) initWithSpriteFrameName:(NSString*)spriteFrameName {
    if (self = [super initWithSpriteFrameName:spriteFrameName]) {
        // Lifespan is between 10 and 20
        lifespan = 10 + (CCRANDOM_0_1() * 10);
    }
    return self;
}</pre></div><p>We are using a new variable, <code class="literal">lifespan</code>, and we set it to a random value between 10 and 20 (this is in seconds). This is defined when the mouse is instantiated, so it will be different for each mouse. (Note that we use a class convenience method that overrides the <code class="literal">spriteWithSpriteFrameName</code>. This is needed in <code class="literal">cocos2d 2.0</code> because the <code class="literal">init</code> method is not called during instantiation.) The actual creation of the mouse is nearly the same as the <a id="id837" class="indexterm"/>
<a id="id838" class="indexterm"/>
<code class="literal">createWall</code> method.</p><p>
<strong>Filename</strong>: <a id="id839" class="indexterm"/>
<a id="id840" class="indexterm"/>
<code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) createMouse {
    BOOL approvedSpot = YES;
    
    // Randomly generate a position
    NSInteger newRow = CCRANDOM_0_1()*(size.height/gridSize);
    NSInteger newCol = CCRANDOM_0_1()*(size.width/gridSize);
    CGPoint newPos = [self positionForRow:newRow
                                andColumn:newCol];
    // Build a new mouse, add it to the layer
    SNMouse *newMouse = [SNMouse
                spriteWithSpriteFrameName:@"mouse.png"];
    [newMouse setPosition:newPos];
    [self addChild:newMouse];
    // Check to make sure we aren't on top of the snake
    for (SNSnakeSegment *aSeg in [snake snakebody]) {
        if (CGRectIntersectsRect([newMouse boundingBox],
                                 [aSeg boundingBox])) {
            approvedSpot = NO;
            break;
        }
    }
    // Check to make sure there are no walls here
    for (CCSprite *aWall in wallsOnField) {
        if (CGRectIntersectsRect([newMouse boundingBox],
                                 [aWall boundingBox])) {
            approvedSpot = NO;
            break;
        }
    }
    // Check to make sure there are no mice in the way
    for (SNMouse *aMouse in miceOnField) {
        if (CGRectIntersectsRect([newMouse boundingBox],
                                 [aMouse boundingBox])) {
            approvedSpot = NO;
            break;
        }
    }
    // If we passed everything, keep the mouse
    if (approvedSpot) {
        [miceOnField addObject:newMouse];
    // If we detected an overlap, build a replacement
    } else {
        [self removeChild:newMouse cleanup:YES];
        [self createMouse];
        return;
    }
}</pre></div><p>The only structural difference between this method <a id="id841" class="indexterm"/>and the <a id="id842" class="indexterm"/>
<a id="id843" class="indexterm"/>
<code class="literal">createWall</code> method is that we don't check for the snake's "line of sight" <code class="literal">CGRect</code>, since there's <a id="id844" class="indexterm"/>no harm in putting a mouse directly in front of the snake. That's all it takes to make snake food.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Collisions and eating</h1></div></div></div><p>Now that we have all of the visible objects on the <a id="id845" class="indexterm"/>screen, we can move to the collision detection. Collision detection is actually the easy part. <a id="id846" class="indexterm"/>We have already written code that looks suspiciously like collision detection in the <code class="literal">createWall</code>
<a id="id847" class="indexterm"/>
<a id="id848" class="indexterm"/> and <a id="id849" class="indexterm"/>
<a id="id850" class="indexterm"/>
<code class="literal">createMouse</code> methods. The checks we perform are nearly the same, except we are concerned only with collisions involving the head of the snake, since it is the only part of the snake that can collide with another surface. Let's look at the <a id="id851" class="indexterm"/>
<a id="id852" class="indexterm"/>
<code class="literal">checkForCollisions</code> method in two sections. The first section <a id="id853" class="indexterm"/>contains the checking for game ending crashes.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code> (<code class="literal">checkForCollisions</code>, part 1)</p><div><pre class="programlisting">-(void) checkForCollisions {
    // Get the head
    SNSnakeSegment *head = [[snake snakebody]
                                        objectAtIndex:0];
    // Check for collisions with the snake's body
    for (SNSnakeSegment *bodySeg in [snake snakebody]) {
        if (CGRectIntersectsRect([head boundingBox],
            [bodySeg boundingBox]) &amp;&amp; head != bodySeg) {
            [self snakeCrash];
            break;
        }
    }
    // Check for collisions with the walls
    for (CCSprite *aWall in wallsOnField) {
        if (CGRectIntersectsRect([aWall boundingBox],
                                 [head boundingBox])) {
            [self snakeCrash];
            break;
        }
    }</pre></div><p>First we get the head segment to use in all of our collision checking. We compare it against all segments in the <code class="literal">snakebody</code> array. If the <a id="id854" class="indexterm"/>
<a id="id855" class="indexterm"/>
<code class="literal">CGRectIntersectsRect</code> is true (that is, the two <code class="literal">CGRects</code> are overlapping at least a bit), and the segment it is testing is not the head, then it has crashed into its own tail. The second check is the same <code class="literal">boundingBox</code> check we used earlier against all the walls in the <code class="literal">wallsOnField</code> array. Any positive hits in these routines will cause the <a id="id856" class="indexterm"/>
<a id="id857" class="indexterm"/>
<code class="literal">snakeCrash</code> method to be called.</p><p>The second half is concerned with eating mice. It is a <a id="id858" class="indexterm"/>little more involved, but still fairly simple.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code> (<code class="literal">checkForCollisions</code>, part 2)</p><div><pre class="programlisting">    // Check for mice eaten
    CCSprite *mouseToEat;
    BOOL isMouseEaten = NO;
    for (CCSprite *aMouse in miceOnField) {
        if (CGRectIntersectsRect([head boundingBox],
                                 [aMouse boundingBox])) {
            isMouseEaten = YES;
            mouseToEat = aMouse;
            [[SimpleAudioEngine sharedEngine]
                                playEffect:SND_GULP];
            break;
        }
    }
    if (isMouseEaten) {
        // Replace the mouse, longer snake, score
        [mouseToEat removeFromParentAndCleanup:YES];
        [miceOnField removeObject:mouseToEat];
        [self createMouse];
        [snake addSegment];
        [self incrementScore];
    }
}</pre></div><p>Here we look for collisions between the snake's head and the mice on the playfield. Because we want to eat the mice, not crash into them, <a id="id859" class="indexterm"/>
<a id="id860" class="indexterm"/>we care more about which mouse is being eaten. In this case, we retain the mouse that has just been eaten in the <a id="id861" class="indexterm"/>
<a id="id862" class="indexterm"/>
<code class="literal">mouseToEat</code> variable. We do this because part of the process we must go through to remove the mouse would cause the array to mutate while iterating through it, which would cause the game to crash. So we set <code class="literal">mouseToEat</code> to reference the mouse in question, and set the <code class="literal">isMouseEaten</code> <code class="literal">BOOL</code> to <code class="literal">YES</code>.</p><p>Once we are safely outside of the loop through the <code class="literal">miceOnField</code> array, we can remove the mouse from the layer (<code class="literal">removeFromParentAndCleanup</code>) as well as removing it from the <code class="literal">miceOnField</code> array. We then trigger the creation of a new mouse. Since each mouse eaten should lengthen the snake by one, we then call the snake's <code class="literal">addSegment</code> method. This is the same method we used in the initial build of the <a id="id863" class="indexterm"/>snake.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Levels and difficulties</h1></div></div></div><p>You can play on the same level for only a limited time before your snake becomes so long that it is impossible to continue. To solve that issue, we will <a id="id864" class="indexterm"/>implement levels. Additionally, not everyone likes to play at the same speed to begin with, so we will also add difficulty or skill levels. <a id="id865" class="indexterm"/>We address this need by another custom <a id="id866" class="indexterm"/>
<a id="id867" class="indexterm"/>
<code class="literal">init</code> method for the <a id="id868" class="indexterm"/>
<a id="id869" class="indexterm"/>
<code class="literal">SNPlayfieldLayer</code> class, as shown in the following shortened form:</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">+(id) initForLevel:(NSInteger)startLevel
     andDifficulty:(SNSkillLevel)skillLevel {
            return [[[self alloc]initForLevel:startLevel
                  andDifficulty:skillLevel] autorelease];
}

-(id) initForLevel:(NSInteger)startLevel
     andDifficulty:(SNSkillLevel)skillLevel {
  
    if (self = [super init]) {
      levelNum = startLevel;
        currentSkill = skillLevel;

  // See code bundle for complete initForLevel method</pre></div><p>When we create the scene (and subsequently the layer), we pass it <a id="id870" class="indexterm"/>
<a id="id871" class="indexterm"/>to the starting level and skill level. We store those passed values in the variables: <code class="literal">levelNum</code> and <code class="literal">currentSkill</code>. We want the level and skill-based parameters all centralized, so all of the level-control <a id="id872" class="indexterm"/>values are set in one method, <code class="literal">createSnake</code>.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) createSnake {
    NSInteger snakeLength = 4 + currentSkill;
    snake = [[SNSnake createWithLayer:self
                        withLength:snakeLength] retain];
    snake.snakeSpeed = .3 -((levelNum+currentSkill)*0.02);

    wallCount = 3 + (levelNum * currentSkill);
    mouseCount = currentSkill;
}</pre></div><p>Here we see how we are setting a few important variables based on the <code class="literal">levelNum</code> and <code class="literal">currentSkill</code>. Part of the "behind the scenes" is our use of mathematical operations using the <code class="literal">currentSkill</code>. It is of type <code class="literal">SNSkillLevel</code>, which is <a id="id873" class="indexterm"/>another custom type.</p><p>
<strong>Filename</strong>: <code class="literal">SNDefinitions.h</code>
</p><div><pre class="programlisting">typedef enum {
    kSkillEasy = 1,
    kSkillMedium,
    kSkillHard
} SNSkillLevel;</pre></div><p>From this you can see that any reference to the <code class="literal">currentSkill</code> type is actually representing values of <code class="literal">1</code>, <code class="literal">2</code>, or <code class="literal">3</code>. So the number of walls we would create for a game on <code class="literal">kSkillHard</code> and level 10 would be <code class="literal">3 + (10 * 3) = 33</code>. This allows the game to slowly ramp up in difficulty, with the skill level determining not only that level 1 begins slightly harder, but the actual difficulty scales up faster on the harder skill levels.</p><p>The snake speed needs a little explanation. The speed is <a id="id874" class="indexterm"/>actually the delay between movements. So the lower the number, the faster it moves. Our calculation starts at <code class="literal">.3</code> and uses a formula to speed up as the levels increase. So the previously cited example of <code class="literal">kSkillHard</code> on level 10 would result in a snake speed of <code class="literal">0.3 – (13 * 0.02)</code>, which is a pretty fast value of <code class="literal">0.04</code>. All of this logic was centralized in this method so we can tweak the parameters side-by-side as we approach our optimal gameplay experience.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>The main loop</h1></div></div></div><p>Much of the remaining functionality is in the <a id="id875" class="indexterm"/>
<a id="id876" class="indexterm"/>
<code class="literal">update</code> method. There are three distinct sections of the loop, and we will look at them in turn. The <a id="id877" class="indexterm"/>first section handles the movement updates.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code> (<code class="literal">update</code>, part 1)</p><div><pre class="programlisting">-(void)update:(ccTime)dt {
  stepTime += dt;
  if (stepTime &gt; snake.snakeSpeed) {
        stepTime = 0;
      [snake move];
      [self checkForCollisions];
    }</pre></div><p>We use a standard delta time counter to keep adding to the <a id="id878" class="indexterm"/>
<a id="id879" class="indexterm"/>
<code class="literal">stepTime</code> variable. On each loop, we check if the <code class="literal">stepTime</code> is greater than the <code class="literal">snakeSpeed</code> variable. If it is, then we need to move the snake. As discussed in the previous sections of the chapter, all we have to do is call the snake's <code class="literal">move</code> method. The only time we need to check for collisions is after the snake's <code class="literal">move</code> method is called, so we call that method next.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Level-up checking</h2></div></div></div><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code> (<code class="literal">update</code>, part 2)</p><div><pre class="programlisting">    if (playerScore &gt;= 8) {
        [self showLevelComplete];
    }</pre></div><p>Here we have hard-coded the value of <code class="literal">8</code> as being the total number of <a id="id880" class="indexterm"/>mice needed to be eaten per level before we advance. Although we don't reproduce the <a id="id881" class="indexterm"/>
<a id="id882" class="indexterm"/>
<code class="literal">showLevelComplete</code> method here, it unschedules the update, gives a "Level Complete" display, and then makes the following call:</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">    [[CCDirector sharedDirector] replaceScene:
        [SNPlayfieldScene sceneForLevel:levelNum + 1
                          andDifficulty:currentSkill]];</pre></div><p>We call <code class="literal">replaceScene</code>, requesting the current scene to be <a id="id883" class="indexterm"/>replaced with a fresh one that is exactly the same, except one level higher. The level-based variables we saw in the <code class="literal">createSnake</code> method will make the next level just a little bit <a id="id884" class="indexterm"/>
<a id="id885" class="indexterm"/>harder, and the level up process can continue for as long as the player can keep up with it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Dead mice</h2></div></div></div><p>The third and final piece of the update loop handles the <a id="id886" class="indexterm"/>
<a id="id887" class="indexterm"/>
<code class="literal">lifespan</code> we discussed for the mice. Every mouse already has a semi-random <code class="literal">lifespan</code>, but we haven't <a id="id888" class="indexterm"/>done anything with it yet.</p><p>
<strong>Filename</strong>: <code class="literal">SNPlayfieldLayer.m</code> (<code class="literal">update</code>, part 3)</p><div><pre class="programlisting">  for (SNMouse *aMouse in miceOnField) {
        aMouse.lifespan = aMouse.lifespan - dt;
        
      if (aMouse.lifespan &lt;= 0) {
            [deadMice addObject:aMouse];
            [aMouse removeFromParentAndCleanup:YES];
        }
    }
    [miceOnField removeObjectsInArray:deadMice];

    // Add new mice as replacements
    for (int i = 0; i &lt; [deadMice count]; i++) {
        [self createMouse];
    }
    
    [deadMice removeAllObjects];
}</pre></div><p>We again use the delta time, but this time we subtract the delta from the <code class="literal">lifespan</code> of every mouse on the field. If a mouse's <code class="literal">lifespan</code> reaches zero, it died of old age. We add it to the <code class="literal">deadMice</code> array so we can get rid of it outside of the loop. We use an array in this method because there could be more than one mouse whose <code class="literal">lifespan</code> expires in the same iteration. We remove the dead mice from the <code class="literal">miceOnField</code> array, clear them from the layer, and create new mice in their place. This assures that the correct number of mice are on-screen at all times.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>But…how do we control the snake?</h1></div></div></div><p>The most basic question of all has been completely ignored until now. We <a id="id889" class="indexterm"/>have dealt with how the game works internally, but we have actually left the player out in the cold. It is precisely because we have done so much "under the hood" work on the snake and its environment that makes the touch handler really anti-climatic. We will focus on the direct user interaction. (There is additional code that handles the game over and some basic splash screens that are <a id="id890" class="indexterm"/>outside of the scope of this chapter.)</p><p>
<strong>Filename</strong>: <a id="id891" class="indexterm"/>
<a id="id892" class="indexterm"/>
<code class="literal">SNPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(BOOL) ccTouchBegan:(UITouch *)touch
           withEvent:(UIEvent *)event {
    
    CGPoint location = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:location];
    
    if (convLoc.x &lt; size.width/2) {
        // Touched left half of the screen
        [snake turnLeft];
        return YES;
    } else {
        // Touched right half of the screen
        [snake turnRight];
        return YES;
    }
        
    // If we did not claim the touch.
    return NO;
}</pre></div><p>We start by using a standard conversion of the touch to OpenGL coordinate space. We evaluate the converted touch location and compare its <code class="literal">x</code> value to determine which half of the screen has been touched. If the left half of the screen was touched, we instruct the snake to turn left. For the right side, we instruct the snake to turn right. You will notice that we are using <a id="id893" class="indexterm"/>
<a id="id894" class="indexterm"/>
<code class="literal">ccTouchBegan</code>, rather than <a id="id895" class="indexterm"/>
<a id="id896" class="indexterm"/>
<code class="literal">ccTouchEnded</code>. We want responsiveness as soon as the screen is touched, not relying on the player lifting their finger off or moving it around. If they want to turn, we want to respond as fast as possible, and only trigger once. The touch will not trigger again until their finger is raised and tapped again.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we have focused more on internal structure than we have on complex gameplay. By designing each object as fully contained as possible, it insulates the layer from the object. If we wanted to change the way the snake's movement is handled, for example, we could make those changes in the <code class="literal">SNSnake</code> class without touching the <code class="literal">SNPlayfieldLayer</code> at all. We have experimented with overriding the <code class="literal">setPosition</code> method to control the serpentine nature of the snake's movement. We have implemented easy collision detection. We have also built our first game that includes several difficulty levels with increasingly more difficult playable levels. Finally, we have seen how adding a single variable can be all we really need to turn a <code class="literal">CCSprite</code> into a mouse with a life of its own (and how to get rid of dead ones).</p><p>In the next chapter we will move on to a brick-breaking game using the <code class="literal">Box2D</code> physics engine. We will use plists to store level data and even build some simple power-ups that will change the physics of the game while the game is running.</p></div></body></html>