<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. User Interface: Views</h1></div></div></div><p>In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding and customizing views</li><li class="listitem" style="list-style-type: disc">Receiving user input with buttons</li><li class="listitem" style="list-style-type: disc">Using labels to display text</li><li class="listitem" style="list-style-type: disc">Displaying images</li><li class="listitem" style="list-style-type: disc">Displaying and editing text</li><li class="listitem" style="list-style-type: disc">Using the keyboard</li><li class="listitem" style="list-style-type: disc">Displaying progress</li><li class="listitem" style="list-style-type: disc">Displaying content larger than the screen</li><li class="listitem" style="list-style-type: disc">Navigating through content divided into pages</li><li class="listitem" style="list-style-type: disc">Displaying a toolbar</li><li class="listitem" style="list-style-type: disc">Creating a custom view</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Introduction</h1></div></div></div><p>An application's user interface is essential for providing the user with an easy way of communicating with a device, be it a computer, a mobile phone, or a tablet. On a mobile device, the user interface is not only essential but the only way to interact with the user. Developers have to cope with various limitations and restrictions when developing for mobile devices. The processing power does not match desktop CPUs and the screens are smaller, making the process of choosing what sort of information will be displayed each time somewhat more difficult.</p><p>In this chapter, we will discuss the key components of an iOS application's UI. We will see how to use and customize these components to create rich application user interfaces and discuss their similarities and differences they have with their desktop equivalents. Here is a list of these components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UIView:</code> It is a customizable container, which is the base object of most iOS user interface controls<a id="id122" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIButton:</code> It is the equivalent of a<code class="literal"> Button</code> in .NET world<a id="id123" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UILabel:</code> It is the equivalent of a<code class="literal"> Label</code> in .NET world<a id="id124" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIImageView:</code> It is a view that allows us to display and create basic animations with images<a id="id125" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UITextView:</code> It is a view, which allows us to display editable text<a id="id126" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UITextField:</code> It is similar to .NET's<code class="literal"> TextBox</code> control<a id="id127" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIProgressView:</code> It displays known length progress<a id="id128" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIScrollView:</code> It provides the ability to display scrollable content<a id="id129" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIPageControl:</code> It provides navigation functionality to content, divided into different pages or screens<a id="id130" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIToolbar:</code> It provides a toolbar at the bottom of the screen that accepts customizable buttons<a id="id131" class="indexterm"/></li></ul></div><p>We will also talk about how to programmatically create instances of these components and use them efficiently.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Adding and customizing views</h1></div></div></div><p>In this task, we will discuss how to add and customize a<code class="literal"> UIView</code> with<strong> Interface Builder</strong>.<a id="id132" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec01"/>Getting ready</h2></div></div></div><p>Adding views with Interface Builder is a simple task. Let's start by creating a new<strong> iPhone Single View Application</strong> project in MonoDevelop. Name the project<code class="literal"> FirstViewApp</code>, and open the<code class="literal"> FirstViewAppViewController.xib</code> file with Interface Builder.<a id="id133" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> To add a view to the project, drag-and-drop a<code class="literal"> UIView</code> object from the<strong> Library</strong> pad onto the main view. Make sure it fits the entire window area.<a id="id134" class="indexterm"/></li><li class="listitem"> To make the<code class="literal"> UIView</code> accessible, create an outlet for it, and name it<code class="literal"> subView</code>.<a id="id135" class="indexterm"/><div><h3 class="title"><a id="note13"/>Note</h3><p>The concept of outlets and how to use them is discussed in detail in<a class="link" href="ch01.html" title="Chapter 1. Development Tools"> Chapter 1</a>,Accessing the UI with Outlets.</p></div></li><li class="listitem"> Select the view that we just added and go to the<strong> Inspector</strong> pad. Select the<strong> Attributes</strong> tab, and in the<strong> Background</strong> drop-down list, select<strong> Light Gray Color</strong>.</li><li class="listitem"> Now, select the<strong> Size</strong> tab and reduce the view's height by<code class="literal"> 60</code> points.</li><li class="listitem"> Save the document.</li><li class="listitem"> Compile and run the application on the simulator. The result should look like the following image:</li></ol></div><div><img src="img/1468EXP_02_01.jpg" alt="How to do it..."/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The gray portion of the simulator's screen is the view that we have just added.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec03"/>How it works...</h2></div></div></div><p>We have successfully created an application that contains one view. Of course, this application does not provide any functionality. It is only meant to show how to add a view and display it.<a id="id136" class="indexterm"/>
</p><p>Views are the essential components of an iOS application interface. Every visual UI object inherits from the<code class="literal"> UIView</code> class. The concept is somewhat different than a<code class="literal"> Form</code> in .NET. A view manages content drawing, accepts other views as subviews, provides auto-sizing features, can accept touch events for itself and its subviews, and many of its properties can even be animated. Even<code class="literal"> UIWindow</code> inherits from<code class="literal"> UIView</code>. It is this class or its inheritors that iOS developers will use most frequently.<a id="id137" class="indexterm"/>
</p><p>When a view, which is added with Interface Builder, is first instantiated at runtime, it sets its<code class="literal"> Frame</code> property with values that are set through the<strong> Inspector</strong> window's<strong> Size</strong> tab. The<code class="literal"> Frame</code> property is of type<code class="literal"> RectangleF</code> and defines the location of the view in its superview's coordinate system, in our case the main window, and its size in points.<a id="id138" class="indexterm"/>
</p><div><h3 class="title"><a id="note14"/>Note</h3><p>In Objective-C, the<code class="literal"> Frame</code> property of<code class="literal"> UIView</code> is of the type<code class="literal"> CGRect</code>. This type has not been bound in MonoTouch, and the more familiar<code class="literal"> System.Drawing.RectangleF</code> was used instead.</p><p>A superview is a view's parent view, while subviews are its child views. Views that have the same superview are described as siblings.</p></div><p>The default coordinate system in iOS originates from the top-left corner and extends towards the bottom and the right. The coordinate origin is always the same and cannot be changed programmatically.</p><p>The coordinate system of iOS is displayed in the following image:</p><div><img src="img/1468EXP_02_02.jpg" alt="How it works..."/></div><p>When the<code class="literal"> Frame</code> property is set, it adjusts the<code class="literal"> Bounds</code> property. The<code class="literal"> Bounds</code> property defines the location of the view in its own coordinate system and its size in points. It is also of the type<code class="literal"> RectangleF</code>. The default location for the<code class="literal"> Bounds</code> property is<code class="literal"> (0,0)</code>, and its size is always the same as the view's<code class="literal"> Frame</code> value. Both these properties' sizes are connected to each other, so when you change the size of the<code class="literal"> Frame</code>, the size of the<code class="literal"> Bounds</code> changes accordingly and vice versa. You can change the<code class="literal"> Bounds</code> property to display different parts of the view. A view's<code class="literal"> Frame</code> can exceed the screen in both location and position. That is to say that a view's frame with values (x = -50, y = -50, width = 1500, height = 1500) is perfectly acceptable.<a id="id139" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec04"/>There's more...</h2></div></div></div><p>Another thing to note is that the<code class="literal"> UIView</code> class inherits from<code class="literal"> UIResponder</code>. The<code class="literal"> UIResponder</code> class is responsible for responding to and handling events. When a view is added to another view, it becomes part of its responder chain. The<code class="literal"> UIView</code> class exposes the properties and methods of<code class="literal"> UIResponder</code>, and the ones we are interested in describing for now are the following two:<a id="id140" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><code class="literal"> IsFirstResponder</code><strong> property:</strong> It returns a boolean value indicating whether the view is the first responder. Basically, it indicates if the view has focus.<a id="id141" class="indexterm"/></li><li class="listitem"><code class="literal"> ResignFirstResponder():</code> It causes the view to lose focus.<a id="id142" class="indexterm"/></li></ol></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Adding views programmatically</h3></div></div></div><p>If we would like to add a view programmatically, we would use the<code class="literal"> UIView.AddSubview(UIView)</code> method:<a id="id143" class="indexterm"/>
</p><div><pre class="programlisting">this.View.AddSubview(this.subView);
</pre></div><p>The<code class="literal"> AddSubview()</code> method adds its parameter, which is of the type<code class="literal"> UIView</code>, to the list of the caller's subviews and sets its<code class="literal"> Superview</code> parameter to the caller. A view will not be displayed unless it is added to a parent view with the<code class="literal"> AddSubview()</code> method. Also, if a view already has a superview and it is added to another view with its<code class="literal"> AddSubview()</code> method, then its<code class="literal"> Superview</code> is changed to that of the new caller. What this means is that a view can only have only one superview each time.<a id="id144" class="indexterm"/>
</p><div><h3 class="title"><a id="note15"/>Note</h3><p>When adding a view as a subview with Interface Builder, it is not required to use the<code class="literal"> AddSubview()</code> method to display the subview. It is required to call the<code class="literal"> AddSubview()</code> method, however, when adding views programmatically.</p></div><p>For removing a view from its superview programmatically, call its<code class="literal"> RemoveFromSuperview()</code> method. Calling this method on a view, which has no superview, does nothing. Care must be taken when we want to reuse the view we want to remove. We must keep a reference to it, or it might be released after the method is called.<a id="id145" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>View content layout</h3></div></div></div><p>Another important property of<code class="literal"> UIView</code> is<code class="literal"> ContentMode. ContentMode</code> accepts values of the enumeration type<code class="literal"> UIViewContentMode</code>. This property sets how the<code class="literal"> UIView</code> will display its content. The default value of this property is<code class="literal"> UIViewContentMode.ScaleToFill</code>, which scales the content to fit the exact view's size, distorting it if necessary.<a id="id146" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a custom view</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, Accessing the UI with Outlets.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em></li><li class="listitem" style="list-style-type: disc"><em>Accessing the UI with outlets</em></li></ul></div><p>Chapter 3,<em> User Interface: View Controllers:</em>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>View controllers</em> and<em> views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Receiving user input with buttons</h1></div></div></div><p>In this recipe, we will learn how to use buttons to receive and respond to user input.<a id="id147" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Getting ready</h2></div></div></div><p>We used buttons in<a class="link" href="ch01.html" title="Chapter 1. Development Tools"> Chapter 1</a>,<em> Accessing the UI with Outlets</em> to discuss how to use Interface Builder to add controls to the user interface. In this task, we will describe the<code class="literal"> UIButton</code> class in more detail. Open the project<code class="literal"> FirstViewApp</code> that we created in the previous task in MonoDevelop. Increase the main view's height to cover the entire screen in Interface Builder, and save the document.<a id="id148" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>How to do it...</h2></div></div></div><p>We will programmatically add a button in our interface that will change our view's background color when tapped.</p><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> FirstViewAppViewController.cs</code> file, and enter the following code in the class::<a id="id149" class="indexterm"/><div><pre class="programlisting">UIButton buttonChangeColor;
private void CreateButton (){
RectangleF viewFrame = this.subView.Frame;
RectangleF buttonFrame = new RectangleF (10f, viewFrame.Bottom - 200f, viewFrame.Width - 20f, 50f);
this.buttonChangeColor = UIButton.FromType (UIButtonType.RoundedRect);
this.buttonChangeColor.Frame = buttonFrame;
this.buttonChangeColor.SetTitle ("Tap to change view color", UIControlState.Normal);
this.buttonChangeColor.SetTitle ("Changing color...", UIControlState.Highlighted);
this.buttonChangeColor.TouchUpInside += this.buttonChangeColor_TouchUpInside;
this.subView.AddSubview (this.buttonChangeColor);
}
bool isRed;
private void buttonChangeColor_TouchUpInside (object sender, EventArgs e){
if (this.isRed) {
this.subView.BackgroundColor = UIColor.LightGray;
this.isRed = false;
} else {
this.subView.BackgroundColor = UIColor.Red;
this.isRed = true;
}
}
</pre></div></li><li class="listitem"> And in the<code class="literal"> ViewDidLoad()</code> method, add the following line:<a id="id150" class="indexterm"/><div><pre class="programlisting">this.CreateButton ();
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. When the button is tapped, the result should be similar to the following screenshot:</li></ol></div><div><img src="img/1468EXP_02_03.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>How it works...</h2></div></div></div><p>In this task, we have added a button to the user interface that changes the background color of the superview. Furthermore, we have accomplished this without using Interface Builder at all.<a id="id151" class="indexterm"/>
</p><p>Let's now see what the code does.</p><div><ol class="orderedlist"><li class="listitem"> We create a field that will hold the button object:<div><pre class="programlisting">// A button to change the view's background color
UIButton buttonChangeColor;
</pre></div></li><li class="listitem"> In the<code class="literal"> CreateButton()</code> method, we create the button and set some properties.<a id="id152" class="indexterm"/><div><pre class="programlisting">RectangleF viewFrame = this.subView.Frame;
RectangleF buttonFrame = new RectangleF (10f, viewFrame.Bottom - 200f, viewFrame.Width - 20f, 50f);
</pre></div></li><li class="listitem"> First, we assign the view's<code class="literal"> Frame</code> to a new variable named<code class="literal"> viewFrame</code>. Then, we create a new<code class="literal"> RectangleF</code> object named<code class="literal"> buttonFrame</code>, which will be assigned to the button's<code class="literal"> Frame</code> property. Now that we have a frame for our button, we can initialize it, as shown in the following code snippet:<div><pre class="programlisting">//Create the button.
this.buttonChangeColor = UIButton.FromType (UIButtonType.RoundedRect);
this.buttonChangeColor.Frame = buttonFrame;
</pre></div></li><li class="listitem"> The button is initialized with the static method<code class="literal"> UIButton.FromType(UIButtonType)</code>. This method takes one parameter of the type<code class="literal"> UIButtonType</code> and returns predefined types of buttons that are included in iOS SDK. The<code class="literal"> UIButtonType.RoundedRect</code> button enumeration value, used here, is the default type of iOS button with rounded corners. After the<code class="literal"> buttonChangeColor</code> object is initialized, we set its<code class="literal"> Frame</code> to the<code class="literal"> RectangleF</code> value we created previously.<a id="id153" class="indexterm"/></li><li class="listitem"> Now that we have provided initialization code for the button, we will set its titles (that's right, more than one):<div><pre class="programlisting">// Set the button's titles
this.buttonChangeColor.SetTitle ("Tap to change view color", UIControlState.Normal);
this.buttonChangeColor.SetTitle ("Changing color...", UIControlState.Highlighted);
</pre></div></li><li class="listitem">We call the <code class="literal">UIButton.SetTitle(string, UIControlState)
</code> method twice. This method is responsible for setting the button's title for each given button state. The string parameter is the actual title that will be shown. The second parameter is an enumeration of the type UIControlState that indicates the different control states that apply to controls. These control states are:<a id="id154" class="indexterm"/><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Normal:</code> The default idle state of an enabled control<a id="id155" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Highlighted:</code> The state of the control when a touch-up event occurs<a id="id156" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Disabled:</code> The control is disabled and does not accept any events<a id="id157" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Selected:</code> The control is selected. In most cases, this state does not apply. It is useful, however, when a selection state is required, such as in a<code class="literal"> UISegmentedControl</code> object<a id="id158" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Application:</code> An additional control state values for application use<a id="id159" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Reserved:</code> For internal framework use<a id="id160" class="indexterm"/><p>So, with the method <code class="literal">UIButton.SetTitle(string, UIControlState)
</code>, we have set the title that will be displayed when the button is in its default state and the title that will be displayed while it is being tapped.
</p></li></ul></div></li><li class="listitem"> After that, we set the button's handler for the<code class="literal"> TouchUpInside</code> event, and add it as a subview to the<code class="literal"> subView:</code><a id="id161" class="indexterm"/><div><pre class="programlisting">this.buttonChangeColor.TouchUpInside += this.buttonChangeColor_TouchUpInside;
this.subView.AddSubview (this.buttonChangeColor);
</pre></div></li><li class="listitem"> Inside the<code class="literal"> buttonChangeColor_TouchUpInside</code> event, we change the background color of the view, according to the boolean field that we have declared:<a id="id162" class="indexterm"/><div><pre class="programlisting">if (this.isRed) {

this.subView.BackgroundColor = UIColor.LightGray;
this.isRed = false;
} else {
this.subView.BackgroundColor = UIColor.Red;
this.isRed = true;
}
</pre></div></li></ol></div><p>This is done by setting the view's<code class="literal"> BackgroundColor</code> property to the appropriate<code class="literal"> UIColor</code> class instance we want, as shown in the highlighted code previously. The<code class="literal"> UIColor</code> object is a class with many different static methods and properties that allow us to create different color objects.<a id="id163" class="indexterm"/>
</p><p>When you compile and run the application on the simulator, notice not only the view's color change when you tap the button, but also how the button's title changes while the mouse cursor (or finger on the device) is touching the button.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>There's more...</h2></div></div></div><p>In this task, we used the<code class="literal"> UIButton.FromType(UIButtonType)</code> static method to initialize the button. A brief description of each of the enumeration flags of<code class="literal"> UIButtonType</code> is as follows:<a id="id164" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Custom:</code> It's a borderless transparent button. Use this flag when creating custom buttons with images as backgrounds. The button's title is not transparent.<a id="id165" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">RoundedRect:</code> It's the default type of button with rounded corners.<a id="id166" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">DetailDisclosure:</code> It's a round blue button that reveals additional information related to an item.<a id="id167" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">InfoLight:</code> It's a light-colored button with the letter (i), representing information display.<a id="id168" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">InfoDark:</code> It's the same as<code class="literal"> InfoLight</code>, shown with dark color.<a id="id169" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ContactAdd:</code> It's a round blue button with a white plus sign (+). Usually displayed to present contact information to add to an item.<a id="id170" class="indexterm"/></li></ul></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Creating custom buttons</h3></div></div></div><p>For creating custom buttons with the type<code class="literal"> UIButtonType.Custom</code>, use the<code class="literal"> UIButton</code> class'<code class="literal"> SetBackgroundImage()</code> and<code class="literal"> SetImage()</code> methods. They both accept one<code class="literal"> UIImage</code> and one<code class="literal"> UIControlState</code> parameters, so that different images for different control states can be set. When setting images for buttons, whether creating a custom button or not, be sure to set the<code class="literal"> UIButton.ContentMode</code> property accordingly.<a id="id171" class="indexterm"/>
</p><p>The functionality provided by the methods<code class="literal"> SetImage</code> and<code class="literal"> SetBackgroundImage</code> can also be accomplished in the corresponding<strong> Image</strong> and<strong> Background</strong> fields in the<strong> Attributes</strong> tab of the<strong> Inspector</strong> pad in Interface Builder. Select the state for which to set the desired image(s) from the drop-down list box, and set the path to the image file, as shown in the following screenshot:<a id="id172" class="indexterm"/>
</p><div><img src="img/1468EXP_02_04.jpg" alt="Creating custom buttons"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying images</em></li><li class="listitem" style="list-style-type: disc"><em>Creating a custom view</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <em>Development Tools:</em></p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em>,</li><li class="listitem" style="list-style-type: disc"><em>Accessing the UI with Outlets</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Using labels to display text</h1></div></div></div><p>In this recipe, we will learn how to display informative text to the user with labels.<a id="id173" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Getting ready</h2></div></div></div><p>In this task, we will describe the<code class="literal"> UILabel</code> class in more detail. Once again, all of the work will be done without the help of Interface Builder. Open the project<code class="literal"> FirstViewApp</code> that we modified in the previous recipe in MonoDevelop.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>How to do it...</h2></div></div></div><p>We will programmatically create a label, which will display some static guidance text.<a id="id174" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Open the file<code class="literal"> FirstViewAppViewcontroller.cs</code>, and enter the following code in the class:<a id="id175" class="indexterm"/><div><pre class="programlisting">UILabel labelInfo;
private void CreateLabel (){
RectangleF viewFrame = this.subView.Frame;
RectangleF labelFrame = new RectangleF (10f, viewFrame.Y + 20f, viewFrame.Width - 20f, 100f);
this.labelInfo = new UILabel (labelFrame);
this.labelInfo.Lines = 3;
this.labelInfo.TextAlignment = UITextAlignment.Center;
this.labelInfo.BackgroundColor = UIColor.Clear;
this.labelInfo.TextColor = UIColor.White;
this.labelInfo.ShadowColor = UIColor.DarkGray;
this.labelInfo.ShadowOffset = new SizeF (1f, 1f);
this.labelInfo.Text = "Tap the button below to change the background color." + " Notice the button's title change while it is being tapped!";
//this.labelInfo.AdjustsFontSizeToFitWidth = true;
this.subView.AddSubview (this.labelInfo);
}
</pre></div></li><li class="listitem"> And in the<code class="literal"> FinishedLaunching()</code> method, add the following line:<a id="id176" class="indexterm"/><div><pre class="programlisting">this.CreateLabel();
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. The output should look like the following screenshot:</li></ol></div><div><img src="img/1468EXP_02_05.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>How it works...</h2></div></div></div><p>We have successfully created a label and put some information text in it. Let's step through the code and see what actually goes on.<a id="id177" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> We first create the<code class="literal"> labelInfo</code> field that will hold our<code class="literal"> UILabel</code> object in the<code class="literal"> FirstViewAppViewController</code> class.<a id="id178" class="indexterm"/><div><pre class="programlisting">// A label that displays some text
UILabel labelInfo;
</pre></div></li><li class="listitem"> We then create the method<code class="literal"> CreateLabel()</code>, which will instantiate and customize the label. Like the button we created in the previous task, our label needs a frame. So, we create one, again depending on the view's<code class="literal"> Frame</code> property:<a id="id179" class="indexterm"/><div><pre class="programlisting">//Create the appropriate rectangles for the label's frame
RectangleF viewFrame = this.subView.Frame;
RectangleF labelFrame = new RectangleF (10f, viewFrame.Y + 20f, viewFrame.Width - 20f, 100f);
</pre></div></li><li class="listitem"> We just set its height to be higher than the button's, to<code class="literal"> 100</code> points. Now that we have a<code class="literal"> Frame</code> for the label, we initialize it:<div><pre class="programlisting">//Create the label
this.labelInfo = new UILabel (labelFrame);
this.labelInfo.Lines = 3;
this.labelInfo.TextAlignment = UITextAlignment.Center;
this.labelInfo.BackgroundColor = UIColor.Clear;
</pre></div></li><li class="listitem">The <code class="literal">
</code> constructor is used, so that the Frame property will be set immediately upon initialization. The Lines property determines the total number of lines the text on the label text will be divided to. The TextAlignment property accepts values of the enumeration type UITextAlignment, which contains the usual text alignment flags: Center, Left, and Right. To make the Frame of the label completely invisible, so that only our text will be visible, we set the BackgroundColor property to the color UIColor.Clear.<a id="id180" class="indexterm"/></li><li class="listitem"> The next part is quite interesting. Apart from being able to set the font color of the<code class="literal"> label</code>, we can also set a shadow at the displayed text:<div><pre class="programlisting">// Set text color and shadow
this.labelInfo.TextColor = UIColor.White;
this.labelInfo.ShadowColor = UIColor.DarkGray;
this.labelInfo.ShadowOffset = new SizeF (1f, 1f);
</pre></div></li><li class="listitem">The TextColor property accepts <code class="literal">UIColor
</code> values. To set a shadow for the text of the label, set a UIColor to the ShadowColor property. Then, set a SizeF structure to the ShadowOffset property. This property determines the exact location of the shadow. The width parameter of SizeF defines the horizontal placement of the shadow, and the height parameter defines the vertical placement. Negative values are acceptable. A negative value for width means that the shadow will be positioned towards the left, while a negative value for the height means that the shadow will be positioned above the text. The value we have set in the previous code means that the shadow will be displayed 1 point to the right and 1 point below the text.<a id="id181" class="indexterm"/></li><li class="listitem"> We have prepared how the<code class="literal"> label</code> will render its text. To assign the text the<code class="literal"> label</code> will display, set its<code class="literal"> Text</code> property:<a id="id182" class="indexterm"/><div><pre class="programlisting">// Set text to be displayed
this.labelInfo.Text = "Tap the button below to change the background color." + " Notice the button's title change while it is being tapped!";
</pre></div></li><li class="listitem"> As you can see, we have defined quite a long string for the<code class="literal"> label</code> to display. Finally, add the<code class="literal"> label</code> to the view to be displayed:<div><pre class="programlisting">this.mainView.AddSubview (this.labelInfo);
</pre></div></li></ol></div><p>This code gives the result shown in the<em> How to do it</em> section of this task.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>There's more...</h2></div></div></div><p>In the previous code, there is also one more line of code, which is commented out:</p><div><pre class="programlisting">//this.labelInfo.AdjustsFontSizeToFitWidth = true;
</pre></div><p>The<code class="literal"> AdjustsFontSizeToFitWidth</code> property accepts a boolean value. If set to<code class="literal"> true</code>, it instructs the<code class="literal"> label</code> to automatically change the font size so that it can fit inside the width of the<code class="literal"> label</code>. Setting this property to<code class="literal"> true</code> has absolutely no effect if the<code class="literal"> label</code> supports more than one line. So, just to see how this property works, uncomment it and set the<code class="literal"> Lines</code> property to<code class="literal"> 1</code>. The result will look similar to the following:<a id="id183" class="indexterm"/>
</p><div><img src="img/1468EXP_02_06.jpg" alt="There's more..."/></div><p>As you can see, the text on the<code class="literal"> label</code> needs a magnifying glass to read, so it does not work for us properly here. The<code class="literal"> AdjustsFontSizeToFitWidth</code> property, however, is very useful when there is limited space for the width of the<code class="literal"> label</code> on the screen and we want our text to fit that space. To prevent a situation like this, set the<code class="literal"> MinimumFontSize</code> property to the desired value. Just as its name suggests, the size of the font will not be smaller than this property's value.<a id="id184" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>UILabel fonts</h3></div></div></div><p>Setting the font of the displayed text in a<code class="literal"> label</code> is easy. Set its<code class="literal"> Font</code> property with the<code class="literal"> UIFont.FromName(string, float)</code> static method. The<code class="literal"> string</code> parameter represents the name of the font to set and can include both the font family and style, while the<code class="literal"> float</code> parameter determines its size. For example, to set the font of the<code class="literal"> label</code> to<code class="literal"> Helvetica Bold</code>, call the following method:<a id="id185" class="indexterm"/>
</p><div><pre class="programlisting">this.labelInfo.Font = UIFont.FromName("Helvetica-Bold", 17f);
</pre></div><p>If the font name is not found, the<code class="literal"> FromName</code> static method returns<code class="literal"> null</code>. Care must be taken for this, since when the<code class="literal"> UILabel.Font</code> property is set to<code class="literal"> null</code>, an exception will occur. The available styles for a font family can be determined by calling the<code class="literal"> UIFont.FontNamesForFamilyName(string)</code> method, which returns a<code class="literal"> string[]</code> containing all the available font styles. If the<code class="literal"> Helvetica</code> font family is passed to this method, it will return a<code class="literal"> string[]</code> with the following items:<a id="id186" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Helvetica-BoldOblique<p>Helvetica
</p><p>Helvetica-Bold
</p><p>Helvetica-Oblique
</p></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying and editing text</em></li></ul></div><p>In this book:</p><p>

<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, Accessing the UI with Outlets:
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em></li></ul></div><p>
<em>Chapter 11, Graphics and Animation:</em>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Display blinking text</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Displaying images</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> UIImageView</code> class to display images on screen.<a id="id187" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Getting ready</h2></div></div></div><p>In this task, we will see how to bundle and display images in a project. An image file will be needed for display. The image file used here is named<code class="literal"> Toroni.jpg</code>. Create a new<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> ImageViewerApp</code>.<a id="id188" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> ImageViewerAppViewController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<code class="literal"> UIImageView</code> object on its view. Connect the<code class="literal"> UIImageView</code> object with an outlet named<code class="literal"> imageDisplay</code>.<a id="id189" class="indexterm"/></li><li class="listitem"> Save the document.</li><li class="listitem"> Back in MonoDevelop, in the<code class="literal"> ImageViewerAppViewController</code> class, enter the following code:<a id="id190" class="indexterm"/><div><pre class="programlisting">public override ViewDidLoad(){
base.ViewDidLoad();
this.imageDisplay.ContentMode = UIViewContentMode.ScaleAspectFit;
this.imageDisplay.Image = UIImage.FromFile("Toroni.jpg");
}
</pre></div></li><li class="listitem"> Right-click on the project in the<strong> Solution</strong> pad and select<strong> Add | Add Files</strong>. Select the image file you want to display, and click on<strong> Open</strong>.</li><li class="listitem"> Right-click on the image file you have just added, and click on<strong> Build Action | Content</strong>.</li><li class="listitem"> Finally, compile and run the application on the simulator. The image you added to the project should be displayed on the screen, as shown in the following Image:</li></ol></div><div><img src="img/1468EXP_02_07.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIImageView</code> class is basically a view customized for displaying images. When adding an image in a project, its<strong> Build Action</strong> must be set to<strong> Content</strong> in the<strong> Solution</strong> pad, otherwise the image will not be copied into the application bundle.<a id="id191" class="indexterm"/>
</p><p>The<code class="literal"> ContentMode</code> property is very important when displaying images. It sets the way the<code class="literal"> UIView</code> (UIImageView, in this case) object will display the image. We have set it to<code class="literal"> UIViewContentMode.ScaleAspectFit</code>, so that it will be resized to fit the area of<code class="literal"> UIImageView</code>, keeping the aspect ratio intact at the same time. If the<code class="literal"> ContentMode</code> field was left at its default<code class="literal"> Scale To Fill</code> value, the output would be something like the following Image:<a id="id192" class="indexterm"/>
</p><div><img src="img/1468EXP_02_08.jpg" alt="How it works..."/></div><p>To set the image that the<code class="literal"> UIImageView</code> should display, we set its<code class="literal"> Image</code> property with a<code class="literal"> UIImage</code> object:</p><div><pre class="programlisting">this.imageDisplay.Image = UIImage.FromFile("Toroni.jpg");
</pre></div><p>The<code class="literal"> ContentMode</code> property accepts an enumeration type named<code class="literal"> UIViewContentMode</code>. The values provided are:<a id="id193" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>ScaleToFill:</strong> This is the default value of the base<strong> UIView</strong> object. It scales the content to fit the size of the view, changing the aspect ratio as necessary.</li><li class="listitem" style="list-style-type: disc"><strong>ScaleAspectFit:</strong> It scales the content to fit the size of the view, maintaining its aspect ratio. The remaining area of the view's content becomes transparent.</li><li class="listitem" style="list-style-type: disc"><strong>ScaleAspectFill:</strong> Scales the content to fill the size of the view, maintaining its aspect ratio. Some part of the content may be left out.</li><li class="listitem" style="list-style-type: disc"><strong>Redraw:</strong> When a view's bounds are changed, its content is not redrawn. This value causes the content to be redrawn. Drawing content is an expensive operation in terms of CPU cycles, so think twice before using this value with large contents.</li><li class="listitem" style="list-style-type: disc"><strong>Center:</strong> Places the content at the center of the view, keeping its aspect ratio.</li><li class="listitem" style="list-style-type: disc"><strong>Top, Bottom, Left, Right, TopLeft, TopRight, BottomLeft</strong>, and<strong> BottomRight:</strong> Aligns the content in the view, with the corresponding value.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIImage</code> class is the object that represents image information. The file formats it supports are listed in the following table:<a id="id194" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>File Format</p>
</th><th style="text-align: left" valign="bottom">
<p>File Extension</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Portable Network Graphics (PNG)</p>
</td><td style="text-align: left" valign="top">
<p>.png</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Joint Photographic Experts Group (JPEG)</p>
</td><td style="text-align: left" valign="top">
<p>.jpg, .jpeg</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Tagged Image File Format (TIFF)</p>
</td><td style="text-align: left" valign="top">
<p>.tiff, .tif</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Graphic Interchange Format</p>
</td><td style="text-align: left" valign="top">
<p>.gif</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows Bitmap Format</p>
</td><td style="text-align: left" valign="top">
<p>.bmp</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows Icon Format</p>
</td><td style="text-align: left" valign="top">
<p>.ico</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows Cursor</p>
</td><td style="text-align: left" valign="top">
<p>.cur</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>XWindow bitmap</p>
</td><td style="text-align: left" valign="top">
<p>.xbm</p>
</td></tr></tbody></table></div><div><h3 class="title"><a id="note16"/>Note</h3><p>Animated GIF image files are not supported by the<code class="literal"> UIImageView</code> class. When an animated GIF is set to the<code class="literal"> Image</code> property of a<code class="literal"> UIImageView</code>, only its first frame will be displayed.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Using images for different screen sizes</h3></div></div></div><p>Creating images for backgrounds provides developers with the ability to produce rich and elegant user interfaces for their applications. The preferred image file format for creating backgrounds for views is<code class="literal"> PNG</code>. But, since the iPhone 4 was released, the screen resolution was increased. To support both screen resolutions in an application, the iOS SDK provides an easy solution. Just save the image in the higher resolution and add a<code class="literal"> @2x</code> suffix to the filename, just before the extension. For example, the name of a higher resolution version of a file named<code class="literal"> Default.png</code> would be<code class="literal"> Default@2x.png</code>. Also, no extra code is required to use both files.<a id="id195" class="indexterm"/>
</p><p>Just use the<code class="literal"> UIImage.FromBundle(string)</code> static method, passing the filename without extension, and iOS takes care of loading the appropriate file, depending on the device the application is running on.</p><div><pre class="programlisting">this.imageDisplay = UIImage.FromBundle("Default");
</pre></div><div><h3 class="title"><a id="note17"/>Note</h3><p>The preceding only applies to PNG image files.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch07.html" title="Chapter 7. Multimedia Resources">Chapter 7</a>,Multimedia Resources:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Loading an Image</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec06"/>Displaying and editing text</h1></div></div></div><p>In this recipe, we will learn how to display simple text blocks with editing functionality.<a id="id196" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Getting ready</h2></div></div></div><p>In this task, we will discuss the usage of<code class="literal"> UITextView</code> and how to display editable text with it. Create a new<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> TextViewApp</code>.<a id="id197" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open<code class="literal"> TextViewAppViewController.xib</code> in Interface Builder.</li><li class="listitem"> Add a UIButton near the top of its view and a UITextView below it. Connect both objects to their outlets.</li><li class="listitem"> Save the document.</li><li class="listitem"> Back in MonoDevelop, enter the following<code class="literal"> ViewDidLoad</code> method in the<code class="literal"> TextViewAppViewController</code> class:<div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.buttonFinished.Enabled = false;
this.buttonFinished.TouchUpInside += delegate {
this.myTextView.ResignFirstResponder();
} ;
this.myTextView.Delegate = new MyTextViewDelegate(this);
}
Add the following nested class:
private class MyTextViewDelegate : UITextViewDelegate{
public MyTextViewDelegate (TextViewAppViewController parentController){
this.parentController = parentController;
}
private TextViewAppViewController parentController;
public override void EditingStarted (UITextView textView){
this.parentController.buttonFinished.Enabled = true;
}
public override void EditingEnded (UITextView textView){
this.parentController.buttonFinished.Enabled = false;
}
public override void Changed (UITextView textView){
Console.WriteLine ("Text changed!");
}
}//end void MyTextViewDelegate
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap somewhere in the text view and the keyboard will appear. Type some text and then tap on the<strong> Finished</strong> button to hide the keyboard.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How it works...</h2></div></div></div><p>The<code class="literal"> UITextView</code> class provides an object that displays editable blocks of text. To respond to the events of our text view, we have implemented a class that inherits from<code class="literal"> UITextViewDelegate</code> that will act as the text view's delegate:<a id="id198" class="indexterm"/>
</p><div><pre class="programlisting">private class MyTextViewDelegate : UITextViewDelegate{
public MyTextViewDelegate (TextViewAppViewController parentController){
this.parentController = parentController;
}
private TextViewAppViewController parentController;
</pre></div><p>We declared a constructor that accepts a<code class="literal"> TextViewAppViewController</code> object, so that we can have an instance of our controller available to access our controls.<a id="id199" class="indexterm"/>
</p><p>Then, we override three methods of the<code class="literal"> UITextViewDelegate</code> class:<a id="id200" class="indexterm"/>
</p><div><pre class="programlisting">public override void EditingStarted (UITextView textView){
this.parentController.buttonFinished.Enabled = true;
}
public override void EditingEnded (UITextView textView){
this.parentController.buttonFinished.Enabled = false;
}
public override void Changed (UITextView textView){
Console.WriteLine ("Text changed!");
}
</pre></div><p>These methods are the handlers that will get called whenever a corresponding event is triggered. When tapping on the text, the<code class="literal"> EditingStarted()</code> method gets called. We enable the<strong> Finished</strong> button in it. When we type some text in the text view, the<code class="literal"> Changed()</code> method gets called, and we can see the output of the<code class="literal"> Console.WriteLine()</code> method in MonoDevelop's<strong> Application Output</strong> pad. Finally, when we tap on the<strong> Finished</strong> button, the keyboard hides and the<code class="literal"> EditingEnded()</code> method gets called that allows us to disable the button.<a id="id201" class="indexterm"/>
</p><p>In the<code class="literal"> ViewDidLoad</code> method, we assign a handler to the<code class="literal"> TouchUpInside</code> event of the button:<a id="id202" class="indexterm"/>
</p><div><pre class="programlisting">this.buttonFinished.TouchUpInside += delegate {
this.myTextView.ResignFirstResponder ();
};
</pre></div><p>We call the text view's<code class="literal"> ResignFirstResponder()</code> method in it so that when the button is tapped, the text view will lose focus, causing the keyboard to hide. Then, we assign a new instance of the delegate that we created to the text view's<code class="literal"> Delegate</code> property, passing the instance of the<code class="literal"> TextViewAppViewController</code> object:<a id="id203" class="indexterm"/>
</p><div><pre class="programlisting">this.myTextView.Delegate = new MyTextViewDelegate (this);
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>There's more...</h2></div></div></div><p>Delegates in Objective-C are somewhat different than delegates in C#. Although in both worlds their most common usage is to provide access to some form of event notification mechanism, in Objective-C this mechanism is a bit more complex. A C# delegate is much like a function pointer in C or C++ programming languages. It is an object that holds a reference to a method of a specific signature. On the other hand, an Objective-C delegate is a certain type of object that conforms to a specific protocol. It is basically an object that wraps one or more methods (and/or other members) that act as event handlers.<a id="id204" class="indexterm"/>
</p><div><h3 class="title"><a id="note18"/>Note</h3><p>An Objective-C protocol is similar to an interface in C#.</p></div><p>The concept of Delegate objects might seem confusing at first, but it is not difficult to comprehend. Regarding the event notification mechanism, MonoTouch simplifies things for .NET developers by providing events for most objects.</p><div><h3 class="title"><a id="note19"/>Note</h3><p>The<code class="literal"> UITextView</code> class is suitable for displaying simple blocks of text, without formatting. For displaying formatted text, use the<code class="literal"> UIWebView</code> class instead.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using the keyboard</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch05.html" title="Chapter 5. Displaying Data">Chapter 5</a>, Displaying Data:
</p><p>
<em>Displaying and formatting text</em>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Using the keyboard</h1></div></div></div><p>In this recipe, we will discuss some important aspects of the virtual keyboard usage.<a id="id205" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Getting ready</h2></div></div></div><p>In the previous two tasks, we discussed the types of text input available. In this task, we will discuss some of the things we can, or even must, do to use the keyboard effectively. Create a new<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> KeyboardApp</code>.<a id="id206" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>How to do it...</h2></div></div></div><p>Follow these steps to create the project:</p><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> KeyboardAppViewController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<code class="literal"> UITextField</code> object in the bottom-half portion of the view and connect it to an outlet.<a id="id207" class="indexterm"/></li><li class="listitem"> Save the document.</li><li class="listitem"> Back in MonoDevelop, enter the following code in the<code class="literal"> KeyboardAppViewController</code> class:<a id="id208" class="indexterm"/><div><pre class="programlisting">private NSObject kbdWillShow, kbdDidHide;
public override void ViewDidLoad(){
base.ViewDidLoad();
this.emailField.KeyboardType = UIKeyboardType.EmailAddress;
this.emailField.ReturnKeyType = UIReturnKeyType.Done;
this.kbdWillShow = NSNotificationCenter.DefaultCenter. AddObserver (UIKeyboard.WillShowNotification, delegate(NSNotification ntf) {
RectangleF kbdBounds = UIKeyboard.FrameEndFromNotification (ntf);
RectangleF textFrame = this.emailField.Frame;
textFrame.Y -= kbdBounds.Height;
this.emailField.Frame = textFrame;
} );
this.kbdDidHide = NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidHideNotification, delegate(NSNotification ntf){
RectangleF kbdBounds = UIKeyboard.FrameEndFromNotification (ntf);
RectangleF textFrame = this.emailField.Frame;
textFrame.Y += kbdBounds.Height;
this.emailField.Frame = textFrame;
} );
this.emailField.ShouldReturn = delegate(UITextField textField) {
return textField.ResignFirstResponder ();
} ;
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.<a id="id209" class="indexterm"/></li><li class="listitem"> Tap on the text field and watch it moving upwards to avoid being hidden from the keyboard.</li><li class="listitem"> Tap the<strong> Done</strong> button on the keyboard and watch the text field returning to its original position when the keyboard hides.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>How it works...</h2></div></div></div><p>There are various types of keyboards in iOS. Since not all keys can be displayed at once due to the restricted screen size, it is good practice to set the appropriate type of keyboard, according to the text input we need the user to provide. In this project, we have set the keyboard to the<strong> Email Address</strong> type. We have also customized the type of the<strong> Return</strong> key by setting it to<strong> Done</strong>.<a id="id210" class="indexterm"/>
</p><div><pre class="programlisting">this.emailField.KeyboardType = UIKeyboardType.EmailAddress;
this.emailField.ReturnKeyType = UIReturnKeyType.Done;
</pre></div><p>When the keyboard is displayed, it is the developer's responsibility to make sure it does not obstruct essential UI elements. In this case, since we provide the user with the ability to enter some text input, we have to make sure that the text field is visible so the user will be able to see what is being typed. For this, we add two observers in the default notification center.</p><div><pre class="programlisting">// Add observers for the keyboard
this.kbdWillShow = NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillShowNotification, delegate(NSNotification ntf) {
</pre></div><p>An<code class="literal"> NSNotificationCenter</code> provides a notification mechanism for various notifications.</p><p>We access the runtime's default notification center through the<code class="literal"> NSNotificationCenter.DefaultCenter</code> static property. An observer is added with the<code class="literal"> AddObserver()</code> method, which accepts two parameters. The first parameter represents an<code class="literal"> NSString</code> value, which informs the notification center of what type of notification to watch. The<code class="literal"> UIKeyboard</code> class contains pre-defined static properties with the types of keyboard notifications we need. The<code class="literal"> UIKeyboard.WillShowNotification</code> is passed, stating that the observer will observe and inform when the keyboard will be ready to appear. The second parameter is of the type<code class="literal"> Action&lt;NSNotification&gt;</code> and represents the handler that will be executed when the notification occurs. Inside the<code class="literal"> anonymous()</code> method, we call the<code class="literal"> UIKeyboard.FrameEndNotification(NSNotification)</code> method that returns the keyboard's bounds:<a id="id211" class="indexterm"/>
</p><div><pre class="programlisting">//Get the keyboard's bounds
RectangleF kbdBounds = UIKeyboard.FrameEndNotification (ntf);
</pre></div><p>Then, we store the text field's frame in a variable and reduce its<code class="literal"> Y</code> position value so that the text field will move upwards:</p><div><pre class="programlisting">// Get the text field's frame
RectangleF textFrame = this.emailField.Frame;
// Change the y position of the text field frame
textFrame.Y -= kbdBounds.Height;
</pre></div><p>When the new frame is set to the<code class="literal"> emailField</code>, it will move to the new position:</p><div><pre class="programlisting">this.emailField.Frame = textFrame;
</pre></div><p>The second observer is needed for moving the text field back to its original position. It is almost the same as the first observer, except for two differences. The<code class="literal"> UIKeyboard.DidHideNotification NSString</code> is passed, instructing the observer to trigger the handler after the keyboard has been dismissed, and the<code class="literal"> Y</code> value of the text field's frame is increased to make the text field return to its original position.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>There's more...</h2></div></div></div><p>The two fields of the type<code class="literal"> NSObject</code> in the class hold information about the observers we added. For removing the two observers we have added here, add the following code:<a id="id212" class="indexterm"/>
</p><div><pre class="programlisting">NSNotificationCenter.DefaultCenter.RemoveObserver (this.kbdWillShow);
NSNotificationCenter.DefaultCenter.RemoveObserver (this.kbdDidHide);
</pre></div><div><h3 class="title"><a id="note21"/>Note</h3><p>Care must be taken when developing an application that uses the keyboard and supports multiple interface orientations. If, for example, the keyboard appears in portrait orientation and the user changes to landscape orientation, both the keyboard's bounds and the text field's frame will be different and must be adjusted accordingly.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying and editing text</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch09.html" title="Chapter 9. Interacting with Device Hardware">Chapter 9</a>,Interacting with Device Hardware:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Rotating the device</em></li><li class="listitem" style="list-style-type: disc"><em>Adjusting the UI</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Displaying progress</h1></div></div></div><p>In this recipe, we will discuss how to display progress of a known length.<a id="id213" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Getting ready</h2></div></div></div><p>In this task, we will talk about the<code class="literal"> UIProgressView</code> control. This control provides similar functionality to the<strong> ProgressBar</strong> in .NET. Create a<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> ProgressApp</code>.<a id="id214" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>How to do it...</h2></div></div></div><p>Here are the steps for using the<code class="literal"> UIProgressView</code> class. Note that in this recipe, we will add all controls programmatically, without the use of Interface Builder:<a id="id215" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Add the following<code class="literal"> using</code> directives in the<code class="literal"> ProgressAppViewController</code> class file:<div><pre class="programlisting">using System.Drawing;
using System.Threading;
</pre></div></li><li class="listitem"> Add the following fields:<div><pre class="programlisting">UILabel labelStatus;
UIButton buttonStartProgress;
UIProgressView progressView;
float incrementBy = 0f;
</pre></div></li><li class="listitem"> Enter the following code in the<code class="literal"> ViewDidLoad</code> override:<div><pre class="programlisting">// Initialize the label
this.labelStatus = new UILabel (new RectangleF (60f, 60f, 200f, 50f));
this.labelStatus.AdjustsFontSizeToFitWidth = true;
// Initialize the button
this.buttonStartProgress = UIButton.FromType (UIButtonType.RoundedRect);
this.buttonStartProgress.Frame = new RectangleF (60f, 400f, 200f, 40f);
this.buttonStartProgress.SetTitle ("Tap to start progress!", UIControlState.Normal);
this.buttonStartProgress.TouchUpInside += delegate {
// Disable the button
this.buttonStartProgress.Enabled = false;
this.progressView.Progress = 0f;
// Start a progress
new Action (this.StartProgress).BeginInvoke (null, null);
} ;
// Initialize the progress view
this.progressView = new UIProgressView (new RectangleF (60f, 200f, 200f, 50f));
// Set the progress view's initial value
this.progressView.Progress = 0f;
// Set the progress increment value
// for 10 items
this.incrementBy = 1f / 10f;
this.View.AddSubview(this.labelStatus);
this.View.AddSubview(this.buttonStartProgress);
this.View.AddSubview(this.progressView);
</pre></div></li><li class="listitem"> Add the following method in the class:<div><pre class="programlisting">private void StartProgress (){
while (this.progressView.Progress &lt; 1){
Thread.Sleep (1000);
this.BeginInvokeOnMainThread (delegate {
// Advance the progress
this.progressView.Progress += this.incrementBy;
// Set the label text
this.labelStatus.Text = String.Format ("Current value: {0}", Math.Round ((double)this.progressView.Progress, 2));
if (this.progressView.Progress == 1){
this.labelStatus.Text = "Progress completed!";
this.buttonStartProgress.Enabled = true;
}
} );
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap on the button and watch the progress bar fill.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>How it works...</h2></div></div></div><p>The current value of<code class="literal"> UIProgressView</code> is represented by its<code class="literal"> Progress</code> property. Its acceptable value range is always from<code class="literal"> 0</code> to<code class="literal"> 1</code>. So, when initializing it, we set it to<code class="literal"> 0</code> to make sure that the bar is not filled at all:<a id="id216" class="indexterm"/>
</p><div><pre class="programlisting">this.progressView.Progress = 0f;
</pre></div><p>Since the<code class="literal"> UIProgressView</code> has a specific range, we need to assign the value we want it to be incremented by, depending on the number of items we need to process, in this case<code class="literal"> 10:</code>
</p><div><pre class="programlisting">this.incrementBy = 1f / 10f;
</pre></div><p>In the button's<code class="literal"> TouchUpInside</code> handler, we disable the button and start our progress by asynchronously invoking a method:<a id="id217" class="indexterm"/>
</p><div><pre class="programlisting">this.buttonStartProgress.TouchUpInside += delegate {
// Disable the button
this.buttonStartProgress.Enabled = false;
this.progressView.Progress = 0;
// Start a progress
new Action (this.StartProgress).BeginInvoke (null, null);
};
</pre></div><p>In the<code class="literal"> StartProgress()</code> method, we start a loop that will process the work that needs to be done. Since the work executes in an asynchronous method, when we want to make changes to the controls, it must be done on the main UI thread by calling the<code class="literal"> BeginInvokeOnMainThread()</code> method of<code class="literal"> UIApplicationDelegate</code>, which accepts a parameter of the type<code class="literal"> NSAction</code>. An<code class="literal"> NSAction</code> can accept anonymous methods as well:<a id="id218" class="indexterm"/>
</p><div><pre class="programlisting">this.BeginInvokeOnMainThread (delegate {
// Advance the progress
this.progressView.Progress += this.incrementBy;
// Set the label text
this.labelStatus.Text = String.Format ("Current value: {0}", Math.Round ((double)this.progressView.Progress, 2));
if (this.progressView.Progress == 1){
this.labelStatus.Text = "Progress completed!";
this.buttonStartProgress.Enabled = true;
}
});
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIProgressView</code> supports one more style other than the default. Set its<code class="literal"> Style</code> property to<code class="literal"> UIProgressViewStyle.Bar</code> so that the bar will look like the one in the Mail application when receiving new e-mails.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Receiving user input with buttons</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Displaying content larger than the screen</h1></div></div></div><p>In this recipe, we will learn how to display content that extends beyond the screen's bounds.<a id="id219" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Getting ready</h2></div></div></div><p>In this task, we will discuss the<code class="literal"> UIScrollView</code> control. Create an<strong> iPhone Single View Application</strong> project, and name it<code class="literal"> ScrollApp</code>.<a id="id220" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>How to do it...</h2></div></div></div><p>Here are the steps to create the project:</p><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> ScrollAppViewController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<code class="literal"> UIScrollView</code> object on its view and connect it to an outlet. And save the document.</li><li class="listitem"> Back in MonoDevelop, add the following code in the<code class="literal"> ScrollAppViewController</code> class:<a id="id221" class="indexterm"/><div><pre class="programlisting">// Image view
UIImageView imgView;
public override void ViewDidLoad(){
base.ViewDidLoad();
this.imgView = new UIImageView (UIImage.FromFile ("Kastoria.jpg"));
this.scrollContent.ContentSize = this.imgView.Image.Size;
this.scrollContent.ContentOffset = new PointF (200f, 50f);
this.scrollContent.PagingEnabled = true;
this.scrollContent.MinimumZoomScale = 0.5f;
this.scrollContent.MaximumZoomScale = 2f;
this.scrollContent.ViewForZoomingInScrollView = delegate(UIScrollView scroll) {
return this.imgView;
} ;
this.scrollContent.ZoomScale = 1f;
this.scrollContent.IndicatorStyle = UIScrollViewIndicatorStyle.White;
this.scrollContent.AddSubview (this.imgView);
}
</pre></div></li><li class="listitem"> Finally, add an image to the project and set its<strong> Build Action</strong> to<strong> Content</strong>. An image larger than the simulator's screen, a size of<strong> 320x480</strong> pixels, is preferable.</li><li class="listitem"> Compile and run the application on the simulator. Tap-and-drag on the image to display different portions. By press<em> Alt</em><em> +</em> mouse-click, you can simulate the pinch zooming function.<a id="id222" class="indexterm"/></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIScrollView</code> is capable of managing content that expands beyond the screen size. The size of the content the scroll view will display must be set in its<code class="literal"> ContentSize</code> property:<a id="id223" class="indexterm"/>
</p><div><pre class="programlisting">this.scrollContent.ContentSize = this.imgView.Image.Size;
</pre></div><p>The<code class="literal"> ContentOffset</code> property defines the position of the content inside the scroll view's bounds:<a id="id224" class="indexterm"/>
</p><div><pre class="programlisting">this.scrollContent.ContentOffset = new PointF (200f, 50f);
</pre></div><p>What this means is that the image's (x=200, y=50) point will be displayed at the origin (x=0, y=0) of the<code class="literal"> UIScrollView</code>. To provide zooming functionality for the content, we first set the<code class="literal"> MinimumZoomScale</code> and<code class="literal"> MaximumZoomScale</code> properties that set the minimum and maximum zoom scale for the content. A value of<code class="literal"> 2</code> means the content will be double in size, while a value of<code class="literal"> 0.5</code> means the content will be half the size.<a id="id225" class="indexterm"/>
</p><div><pre class="programlisting">this.scrollContent.MinimumZoomScale = 0.5f;
this.scrollContent.MaximumZoomScale = 2f;
</pre></div><p>For the actual zooming operation, we need to set the<code class="literal"> ViewForZoomingInScrollView</code> property, which accepts a delegate of the type<code class="literal"> UIScrollViewGetZoomView</code> and returns a<code class="literal"> UIView</code>. Here, the image view we created is returned, but another higher resolution image view can be used instead to provide better image quality when zooming. After the delegate is assigned, the initial zoom scale is set:<a id="id226" class="indexterm"/>
</p><div><pre class="programlisting">this.scrollContent.ViewForZoomingInScrollView = delegate(UIScrollView scroll) {
return this.imgView;
};this.scrollContent.ZoomScale = 1f;
</pre></div><p>Finally, the scroll view's indicator style is set:</p><div><pre class="programlisting">this.scrollContent.IndicatorStyle = UIScrollViewIndicatorStyle.White;
</pre></div><p>Indicators are the two lines that appear when scrolling or zooming: one on the vertical-right side and one on the horizontal-bottom side of the scroll view, which informs the user of the position of the content. Much like scroll bars.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>There's more...</h2></div></div></div><p>To provide a more pleasing scrolling and zooming effect to the user, the<code class="literal"> UIScrollView</code> exposes the<code class="literal"> Bounce</code> property. By default, it is set to<code class="literal"> true</code>, but we have the option to disable it by setting it to<code class="literal"> false</code>. Bouncing the content gives immediate feedback to the user that the bounds of the content have been reached, in either a horizontal or vertical direction. Furthermore, the<code class="literal"> AlwaysBounceHorizontal</code> and<code class="literal"> AlwaysBounceVertical</code> properties can be set individually. Setting one or both of these properties will make the scroll view always bounce the content in each respective direction, even if the content is equal to or smaller than the scroll view's bounds. Hence, no actual scrolling is needed.<a id="id227" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>UIScrollView events</h3></div></div></div><p>The<code class="literal"> UIScrollView</code> class exposes some very useful events:<a id="id228" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Scrolled:</code> This event occurs while the content is being scrolled<a id="id229" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">DecelerationStarted:</code> This event occurs when the user has started scrolling the content<a id="id230" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">DecelerationEnded:</code> This event occurs when the user has finished scrolling and the content has stopped moving<a id="id231" class="indexterm"/></li></ul></div><div><h3 class="title"><a id="note22"/>Note</h3><p>If a handler has been assigned to the<code class="literal"> Scrolled</code> event, and the<code class="literal"> ContentOffset</code> property is set, the event will be triggered.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying images</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying and editing text</em></li><li class="listitem" style="list-style-type: disc"><em>Navigating through content divided into pages</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Navigating through content divided into pages</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> UIPageControl</code> class to provide page navigation.<a id="id232" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UIPageControl</code> provides a simple visual representation of multiple pages or screens in an iOS app, indicated as dots. The dot that corresponds to the current page is highlighted. It is usually combined with the<code class="literal"> UIScrollView</code>. Create a new<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> PageNavApp</code>. Add three image files in the project and set their<strong> Build Action</strong> to<strong> Content</strong>.<a id="id233" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How to do it...</h2></div></div></div><p>Here are the steps to create this project:</p><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> PageNavAppViewController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<code class="literal"> UIPageControl</code> to the bottom of the view and<code class="literal"> UIScrollView</code> above it. Resize the scroll view to take up all the remaining space of the view, and save the document.</li><li class="listitem"> Back in MonoDevelop, enter the following code in the<code class="literal"> PageNavAppViewController</code> class:<a id="id234" class="indexterm"/><div><pre class="programlisting">UIImageView page1;
UIImageView page2;
UIImageView page3;
public override void ViewDidLoad(){
base.ViewDidLoad();
this.scrollView.DecelerationEnded += this.scrollView_DecelerationEnded;
this.pageControl.ValueChanged += this.pageControl_ValueChanged;
this.scrollView.Scrolled += delegate {
Console.WriteLine ("Scrolled!");
} ;
this.scrollView.PagingEnabled = true;
RectangleF pageFrame = this.scrollView.Frame;
this.scrollView.ContentSize = new SizeF (pageFrame.Width * 3, pageFrame.Height);
this.page1 = new UIImageView (pageFrame);
this.page1.ContentMode = UIViewContentMode.ScaleAspectFit;
this.page1.Image = UIImage.FromFile ("Parga01.jpg");
pageFrame.X += this.scrollView.Frame.Width;
this.page2 = new UIImageView (pageFrame);
this.page2.ContentMode = UIViewContentMode.ScaleAspectFit;
this.page2.Image = UIImage.FromFile ("Parga02.jpg");
pageFrame.X += this.scrollView.Frame.Width;
this.page3 = new UIImageView (pageFrame);
this.page3.ContentMode = UIViewContentMode.ScaleAspectFit;
this.page3.Image = UIImage.FromFile ("Parga03.jpg");
this.scrollView.AddSubview (this.page1);
this.scrollView.AddSubview (this.page2);
this.scrollView.AddSubview (this.page3);
}
</pre></div></li><li class="listitem"> Add the following methods in the class:<a id="id235" class="indexterm"/><div><pre class="programlisting">private void scrollView_DecelerationEnded (object sender, EventArgs e){
float x1 = this.page1.Frame.X;
float x2 = this.page2.Frame.X;
float x = this.scrollView.ContentOffset.X;
if (x == x1){
this.pageControl.CurrentPage = 0;
} else if (x == x2){
this.pageControl.CurrentPage = 1;
} else{
this.pageControl.CurrentPage = 2;
}
}
private void pageControl_ValueChanged (object sender, EventArgs e){
PointF contentOffset = this.scrollView.ContentOffset;
switch (this.pageControl.CurrentPage){
case 0:
contentOffset.X = this.page1.Frame.X;
this.scrollView.SetContentOffset (contentOffset, true);
break;
case 1:
contentOffset.X = this.page2.Frame.X;
this.scrollView.SetContentOffset (contentOffset, true);
break;
case 2:
contentOffset.X = this.page3.Frame.X;
this.scrollView.SetContentOffset (contentOffset, true);
break;
default:
// do nothing
break;
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. Scroll on the scroll view to change page. Likewise, tap or scroll on the page control to change page.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How it works...</h2></div></div></div><p>The first thing we need to do is set the<code class="literal"> UIScrollView.PagingEnabled</code> property to<code class="literal"> true</code>, which is done as follows:<a id="id236" class="indexterm"/>
</p><div><pre class="programlisting">this.scrollView.PagingEnabled = true;
</pre></div><p>This property instructs the scroll view to perform scrolling at multiples of the scroll view's bounds, hence providing paging functionality. After that, the image views that will be displayed in different pages are prepared. Here, we take care of adjusting each image view's frame so that they will be positioned next to each other:</p><div><pre class="programlisting">this.page1 = new UIImageView (pageFrame);
//…
pageFrame.X += this.scrollView.Frame.Width;
//…
pageFrame.X += this.scrollView.Frame.Width;
</pre></div><p>We have attached handlers for two events. The first one is the<code class="literal"> UIScrollView.DecelerationEnded</code> event, which will adjust the page control's current page when the user scrolls the scroll view. The current page is determined by the scroll view's<code class="literal"> ContentOffset</code> property:<a id="id237" class="indexterm"/>
</p><div><pre class="programlisting">float x = this.scrollView.ContentOffset.X;
if (x == x1) {
this.pageControl.CurrentPage = 0;
// etc.
</pre></div><p>The second event we attach a handler to is the<code class="literal"> UIPageControl.ValueChanged</code> event. In this handler, we make sure the content is scrolled when the user taps or drags on the page control. The scroll is performed when the<code class="literal"> ContentOffset</code> property is set to the desired image view's<code class="literal"> Frame.X</code> property, using the<code class="literal"> UIScrollView.SetContentOffset(PointF, bool)</code> method:<a id="id238" class="indexterm"/>
</p><div><pre class="programlisting">case 0:
contentOffset.X = this.page1.Frame.X;
this.scrollView.SetContentOffset (contentOffset, true);
break;
// etc.
</pre></div><p>The second parameter of the<code class="literal"> SetContentOffset()</code> method instructs the scroll view to animate while scrolling.<a id="id239" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>There's more...</h2></div></div></div><p>In this recipe, different<code class="literal"> UIImageView</code> objects have been used. Any kind of<code class="literal"> UIView</code> objects can be used, according to the type of content we want to display.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Proper usage of the UIPageControl</h3></div></div></div><p>Users expect that scrolling to other pages will occur when tapping or dragging on the page control. It is not good practice to use it for displaying page indexing only, without being a fully active control.<a id="id240" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying images</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying content larger than the screen</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Displaying a toolbar</h1></div></div></div><p>In this recipe, we will learn how to add and use toolbars in applications.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UIToolbar</code> class provides a toolbar that holds various buttons. It is the bar that resides at the bottom of views. Create a new<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> ToolbarApp</code>.<a id="id241" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How to do it...</h2></div></div></div><p>Here are the steps to create this project:</p><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> ToolbarAppViewController.xib</code> file in Interface Builder and add a<code class="literal"> UIToolbar</code> object at the bottom of its view.</li><li class="listitem"> Select the button it contains by default and set its<strong> Identifier</strong> in the<strong> Attributes Inspector</strong> pad to<strong> Save</strong>.</li><li class="listitem"> Add a<strong> Flexible Space Bar Button Item</strong> object to the toolbar.</li><li class="listitem"> Add another button on the toolbar, on the right side of the previous object, and set its<strong> Identifier</strong> to<strong> Reply</strong>.</li><li class="listitem"> Add a<code class="literal"> UILabel</code> object on the view and connect all controls, apart from the flexible space item, to outlets.</li><li class="listitem"> Save the document.<a id="id242" class="indexterm"/></li><li class="listitem"> Back in MonoDevelop, enter the following code in the<code class="literal"> ToolBarAppViewController</code> class:<a id="id243" class="indexterm"/><div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.barSave.Clicked += delegate {
this.labelStatus.Text = "Button Save tapped!";
} ;
this.barReply.Clicked += delegate {
this.labelStatus.Text = "Button Reply tapped!";
} ;
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. Tap on both of the toolbar's buttons and see the status string display on the label.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How it works...</h2></div></div></div><p>The toolbar holds items of the type<code class="literal"> UIBarButtonItem</code>. These items are special kinds of buttons and spacers. A<code class="literal"> UIBarButtonItem</code> can have a custom type, or any of the predefined types that are listed in the<strong> Identifier</strong> attribute in Interface Builder. When the item is a button and the behavior it provides is included in these identifiers, it is recommended to use them. Each one of these identifiers basically provides a specific icon to the button, according to its intended usage, and the user is quite familiar with them since they are used by most iOS applications. Notice that the<strong> Flexible Space Bar Button Item</strong> we added to the toolbar is also a<strong> UIBarButtonItem</strong>, with a specific identifier. Its purpose is to keep two buttons apart, changing their in-between distance in situations where this is required, for example, when rotating the device at a landscape orientation and the toolbar resizes to fit the new width.<a id="id244" class="indexterm"/>
</p><div><h3 class="title"><a id="note23"/>Note</h3><p>Just rotating the device will not make the<strong> UIToolbar</strong> resize. This kind of behavior will be discussed in<a class="link" href="ch03.html" title="Chapter 3. User Interface: View Controllers"> Chapter 3</a>,User Interface: View Controllers</p></div><p>This kind of bar button is displayed in Interface Builder, but not at runtime.</p><p>In the code, we add handlers to the bar buttons'<code class="literal"> Clicked</code> event, whose purpose is quite familiar:</p><div><pre class="programlisting">this.barSave.Clicked += delegate {
this.labelStatus.Text = "Button Save tapped!";
};
</pre></div><p>It is being triggered when the user taps on the button.<a id="id245" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIBarButtonItem</code> class has a<code class="literal"> Style</code> property that determines the button's style. It can be used only when the button item's identifier is set to<code class="literal"> Custom</code>.<a id="id246" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Setting a UIToolbar's items programmatically</h3></div></div></div><p>To set bar button items to a<code class="literal"> UIToolbar</code>, use one of the overloads of its<code class="literal"> SetItems()</code> method. An example for setting two bar button items in a<code class="literal"> UIToolbar</code> is as follows:<a id="id247" class="indexterm"/>
</p><div><pre class="programlisting">UIBarButtonItem barSave = new UIBarButtonItem(UIBarButtonSystemItem.Save);
UIBarButtonItem barReply = new UIBarButtonItem(UIBarButtonSystemItem.Reply);
this.toolBar.SetItems(new UIBarButtonItem[] { barSave, barReply }, true);
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>See also</h2></div></div></div><p>In this book:</p><p>
<a class="link" href="ch03.html" title="Chapter 3. User Interface: View Controllers">Chapter 3</a>,User Interface: View Controllers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Navigating through different view controllers</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Creating a custom view</h1></div></div></div><p>In this recipe, we will learn how to override the<code class="literal"> UIView</code> class and/or classes that derive from it, to create custom views.<a id="id248" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>So far, we have discussed many of the available views there are to create iOS applications. There will be many cases, however, that we will need to implement our own custom views. In this task, we will see how to create a custom view and use it.</p><div><h3 class="title"><a id="note24"/>Note</h3><p>Creating custom views is very useful when we want to capture touches or implement other custom behavior, such as drawing.</p></div><p>Create a new<strong> iPhone Single View Application</strong> project in MonoDevelop, and name it<code class="literal"> CustomViewApp</code>.<a id="id249" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it...</h2></div></div></div><p>Here are the steps to complete this project:</p><div><ol class="orderedlist"><li class="listitem"> Add a new C# class file in the project, and name it<code class="literal"> MyView</code>.</li><li class="listitem"> Implement it with the following code:<div><pre class="programlisting">using System;
using MonoTouch.UIKit;
using MonoTouch.Foundation;
using System.Drawing;
namespace CustomViewApp{
[Register("MyView")]
public class MyView : UIView{
private UILabel labelStatus;
public MyView (IntPtr handle) : base(handle){
this.Initialize ();
}
public MyView (RectangleF frame) : base(frame){
this.Initialize ();
}
private void Initialize (){
this.BackgroundColor = UIColor.LightGray;
this.labelStatus = new UILabel (new RectangleF (0f, 400f, this.Frame.Width, 60f));
this.labelStatus.TextAlignment = UITextAlignment.Center;
this.labelStatus.BackgroundColor = UIColor.DarkGray;
this.AddSubview (this.labelStatus);
}
public override void TouchesMoved (NSSet touches, UIEvent evt){
base.TouchesMoved (touches, evt);
UITouch touch = (UITouch)touches.AnyObject;
PointF touchLocation = touch.LocationInView (this);
this.labelStatus.Text = String.Format ("X: {0} - Y: {1}", touchLocation.X, touchLocation.Y);
}
}
}
</pre></div></li><li class="listitem"> Open the<code class="literal"> CustomViewAppViewController.xib</code> file in Interface Builder, and add a<code class="literal"> UIView</code> object on the main view.</li><li class="listitem"> Connect it to an outlet and set its<strong> Class</strong> field in the<strong> Identity Inspector</strong> to<code class="literal"> MyView</code>.</li><li class="listitem"> Save the document.</li><li class="listitem"> Compile and run the application on the simulator. Tap-and-drag on the view, and watch the touch coordinates being displayed in the label at the bottom of the screen.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works...</h2></div></div></div><p>The first thing to note when creating custom views is to derive them from the<code class="literal"> UIView</code> class and to decorate them with the<code class="literal"> Register</code> attribute:<a id="id250" class="indexterm"/>
</p><div><pre class="programlisting">[Register("MyView")]
public class MyView : UIView
</pre></div><p>The<code class="literal"> Register</code> attribute basically exposes our class to the Objective-C world. Note that the name we pass as its parameter must be the same name that we enter in the<strong> Class</strong> field in the<strong> Identity Inspector</strong>. It is important to create the following constructor that overrides the base class'<code class="literal"> UIView(IntPtr)</code>.<a id="id251" class="indexterm"/>
</p><div><pre class="programlisting">public MyView (IntPtr handle) : base(handle) {}
</pre></div><p>This constructor is always being called when a view is initialized through native code. If we do not override it, an exception will occur upon initialization of the object when the runtime tries to recreate it if it has been removed when a memory warning is issued. The other constructor that is used in this example is just provided as guidance on what might be used if the view was initialized programmatically:</p><div><pre class="programlisting">public MyView (RectangleF frame) : base(frame) {}
</pre></div><p>Both these constructors call the<code class="literal"> Initialize()</code> method that performs the initialization we need, such as creating the label that will be used, set background colors, and so on.</p><p>Then, the<code class="literal"> TouchesMoved</code> method is overridden. This is the method that is executed when the user drags a finger on the view. Inside the method, we retrieve the<code class="literal"> UITouch</code> object from the method's<code class="literal"> NSSet</code> parameter:<a id="id252" class="indexterm"/>
</p><div><pre class="programlisting">UITouch touch = (UITouch)touches.AnyObject;
</pre></div><div><h3 class="title"><a id="note25"/>Note</h3><p>An<code class="literal"> NSSet</code> object is a collection of data that are not in particular order. It is similar to an array. Its<code class="literal"> AnyObject</code> parameter returns an object from the collection.</p></div><p>The<code class="literal"> UITouch</code> object contains information about user touches. We retrieve the touch's current location from it:<a id="id253" class="indexterm"/>
</p><div><pre class="programlisting">PointF touchLocation = touch.LocationInView (this);
</pre></div><p>Its<code class="literal"> LocationInView</code> method accepts a parameter of the type<code class="literal"> UIView</code> that declares in which view's coordinate system the location will be calculated. In this case, we are interested in the coordinates of<code class="literal"> MyView</code>.<a id="id254" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec54"/>There's more...</h2></div></div></div><p>If we would like to initialize the custom view that we created programmatically, we would enter the following code:</p><div><pre class="programlisting">MyView myView = new MyView(new RectangleF(0f, 0f, 320f, 480f));
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec55"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch03.html" title="Chapter 3. User Interface: View Controllers">Chapter 3</a>,User Interface: View Controllers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>View controllers and views</em></li></ul></div></div></div></body></html>