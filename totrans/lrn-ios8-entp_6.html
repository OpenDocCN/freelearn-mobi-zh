<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Using iCloud and Security Services</h1></div></div></div><p>In this chapter, you will learn how to store your data on cloud, that is, on iCloud and security services for iOS, through which we can secure our data, passwords, and so on.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with iCloud</li><li class="listitem" style="list-style-type: disc">Saving data using the keychain process</li><li class="listitem" style="list-style-type: disc">iOS Touch ID authentication</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Working with iCloud</h1></div></div></div><p>Basically, <strong>iCloud</strong> <a class="indexterm" id="id390"/>is a service that helps users synchronize their data across devices. The main purpose is to let users easily store their data, whether it's a file or document, so that they can access it on any of their iOS devices. While you can use other cloud services to save files or data, the core idea behind iCloud is to eliminate explicit or wired connection between devices. Apple does not want users to think of the cloud servers and the syncing. Everything simply works seamlessly.</p><p>The same design philosophy also applies to developers. When we adopt iCloud, we do not need to know how to interact with the cloud server or upload data to iCloud. The iOS handles all the heavy lifting. Our focus is on the content such as managing the change of data or developing a connection between a cloud and a device.</p><p>iCloud offers three kinds of storage:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Key-value storage</strong>: This <a class="indexterm" id="id391"/>is used to store content <a class="indexterm" id="id392"/>such as settings, preferences, and app states.</li><li class="listitem" style="list-style-type: disc"><strong>Document storage</strong>: This <a class="indexterm" id="id393"/>is used to store file type content <a class="indexterm" id="id394"/>such as WordPress documents, drawings, and complex app states.</li><li class="listitem" style="list-style-type: disc"><strong>Core data storage</strong>: This is <a class="indexterm" id="id395"/>used for multi-device database solutions for structured content. iCloud core data storage is built on <a class="indexterm" id="id396"/>document storage and employs the same iCloud APIs.</li></ul></div><p>Let's understand how <a class="indexterm" id="id397"/>iCloud actually works. To use iCloud, we need an iOS developer account. Assuming that we have an iOS developer account, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <a class="ulink" href="https://idmsa.apple.com/IDMSWebAuth/login?&amp;appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2F%2Faccount%2Findex.action">https://idmsa.apple.com/IDMSWebAuth/login?&amp;appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2F%2Faccount%2Findex.action</a>. We will first create the app ID with the iCloud feature available.</li><li class="listitem">Sign in to the iOS Provisioning Portal, select the app IDs, and then create a new app ID.</li><li class="listitem">Enable the iCloud service for your app by selecting the <strong>iCloud</strong> option. Select the Xcode that you are using (if you are using Xcode 5, then select Xcode 5) and click on <strong>Continue</strong>, as shown in the following screenshot:<div><img alt="Working with iCloud" src="img/1829OT_06_01.jpg"/></div></li><li class="listitem">Now, give the name of our project in the <strong>Name</strong> text field, write the bundle ID in the <strong>Bundle ID</strong> <a class="indexterm" id="id398"/>text field, and click on <strong>Continue</strong>, as shown in the following screenshot:<div><img alt="Working with iCloud" src="img/1829OT_06_02.jpg"/></div></li><li class="listitem">Now, it will show the enabled services for our app. Make sure <strong>iCloud</strong> is enabled or configurable, as shown in the following screenshot:<div><img alt="Working with iCloud" src="img/1829OT_06_03.jpg"/></div></li><li class="listitem">Then, go to <strong>Xcode</strong> and build a new single-view application. After that, go to <strong>Capabilities</strong> in <a class="indexterm" id="id399"/><strong>Xcode</strong> and turn on <strong>iCloud</strong>; this will include iCloud entitlements, iCloud containers, and the link to the Cloud framework, as shown in the following screenshot:<div><img alt="Working with iCloud" src="img/1829OT_06_04.jpg"/></div></li><li class="listitem">Make sure that <a class="indexterm" id="id400"/>the entitlements are created automatically. The following screenshot shows the entitlements created:<div><img alt="Working with iCloud" src="img/1829OT_06_05.jpg"/></div></li><li class="listitem">Delete the<code class="literal"> ViewController</code> class and existing view in the storyboard.</li><li class="listitem">Now, we will empty the storyboard and create a new objective-C class, a subclass of <code class="literal">tableViewController</code>, and name it (for example, <code class="literal">NoteListViewController</code>).</li><li class="listitem">Drag one table view controller to the storyboard and embed it in Navigation Controller. Now, give <a class="indexterm" id="id401"/>a name to this table view controller from the Attribute Inspector; it should be the same as the class name. Do the same thing one more time for a new class and name it (for example, <code class="literal">AddNoteViewController</code>).</li><li class="listitem">Now, we have two table views in the storyboard. For <code class="literal">NoteListViewController</code>, drag a button to the top-right part of the navigation bar and set the identifier as <code class="literal">add</code>. This will automatically change the button to a <strong>+</strong> button, as shown in the following screenshot. Next, select the prototype cell and change its style to <strong>Basic</strong>.<div><img alt="Working with iCloud" src="img/1829OT_06_06.jpg"/><div><p>Navigation Controller and Note List View Controller</p></div></div></li><li class="listitem">For <code class="literal">AddNoteViewController</code>, drag the bar buttons into the navigation bar. Name one as <code class="literal">Cancel</code> and the other as <code class="literal">Save</code>.</li><li class="listitem">Then, select the table <a class="indexterm" id="id402"/>view and set the content to <strong>Static Cells</strong>. Finally, add one static row to the table view and add a text field, as shown here:<div><img alt="Working with iCloud" src="img/1829OT_06_07.jpg"/><div><p>Navigation Controller and Note List View Controller</p></div></div></li><li class="listitem"><code class="literal">AddNoteViewController</code> will be shown when the user taps on the <strong>+</strong> button. So, press and hold <a class="indexterm" id="id403"/>the <em>Ctrl</em> key, click on the <strong>+</strong> button, and drag it to <strong>Add Note View Controller</strong>. Select <strong>Modal</strong> as the Segue action. Our storyboard should now look like this:<div><img alt="Working with iCloud" src="img/1829OT_06_08.jpg"/><div><p>The table view showing Add Note View Controller</p></div></div></li><li class="listitem">Finally, link up the text field to <code class="literal">AddNoteViewController</code> and create two action methods: <code class="literal">Cancel</code> and <code class="literal">Save</code>. Our code in <code class="literal">AddNoteViewController.h</code> should like this:<div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;
@interface AddNoteViewController : UITableViewController
- (IBAction)cancel:(id)sender;
- (IBAction)save:(id)sender;
@property (weak, nonatomic) IBOutlet UITextField *noteTextField;</pre></div></li><li class="listitem">We need to implement the <code class="literal">NoteListViewController</code> class so that we can display the notes available on the cloud in the table view. Open <code class="literal">NoteListViewController.h</code> and add this property to it:<div><pre class="programlisting">@property (strong, nonatomic) NSMutableArray *notes;</pre></div></li><li class="listitem">The purpose of the <a class="indexterm" id="id404"/>property is to save notes locally. We'll display the notes in the table view when needed. Next, we need to make a lazy instantiation of this property. Lazy instantiation is a good technique if we have an object that only needs to be configured once and has some configuration involved that we don't want to clutter in our <code class="literal">init</code> method. Add the following code in <code class="literal">NoteListViewController.m</code>:<div><pre class="programlisting">- (NSArray *)notes
{
  if(!_notes){
    _notes = [NSMutableArray array];
    _notes = [[[NSUbiquitousKeyValueStore defaultStore] arrayForKey:@"AVAILABLE_NOTES"] mutableCopy];
  }
  return _notes;
}</pre></div></li><li class="listitem">In <code class="literal">viewDidLoad</code>, we need to create the notification method as follows:<div><pre class="programlisting">- (void)viewDidLoad
{
  [super viewDidLoad];
  self.navigationItem.leftBarButtonItem = self.editButtonItem;
  //  Observer to catch changes from iCloud
  NSUbiquitousKeyValueStore *store = [NSUbiquitousKeyValueStore defaultStore];
  [[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(storeDidChange:)name: NSUbiquitousKeyValueStoreDidChangeExternallyNotificationobject:store]; [[NSUbiquitousKeyValueStore defaultStore] synchronize]; // Observer to catch the local changes 
  [[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(didAddNewNote:)name:@"New Note"object:nil]; }</pre></div><p>iCloud data <a class="indexterm" id="id405"/>synchronization is achieved using the <code class="literal">NSUbiquitousKeyValueStore</code> class. <code class="literal">NSUbiquitousKeyValueStore</code> is a subclass of <code class="literal">NSObject</code>, and it is available in iOS 5.0 and later. An <code class="literal">NSNotificationCenter</code> object provides a mechanism to broadcast information or messages within a program. It is also a subclass of <code class="literal">NSObject</code>, and it is available in iOS 2.0 and later.</p><p>Our <code class="literal">viewDidLoad</code> method will probably look like this:</p><div><img alt="Working with iCloud" src="img/1829OT_06_09.jpg"/></div></li><li class="listitem">Now, we have to implement methods that are executed when the preceding notifications are <a class="indexterm" id="id406"/>called. The <code class="literal">didAddNewNote</code> method will be invoked when users save a new note:<div><pre class="programlisting">#pragma mark - Observer New Note
- (void)didAddNewNote:(NSNotification *)notification{
    NSDictionary *userInfo = [notification userInfo];
    NSString *noteStr = [userInfo valueForKey:@"Note"];
    [self.notes addObject:noteStr];
    // Update data on the iCloud
    [[NSUbiquitousKeyValueStore defaultStore] setArray:self.notes forKey:@"AVAILABLE_NOTES"];
    // Reload the table view to show changes
    [self.tableView reloadData];
}

#pragma mark - Observer

- (void)storeDidChange:(NSNotification *)notification{
    // Retrieve the changes from iCloud
    _notes = [[[NSUbiquitousKeyValueStore defaultStore] arrayForKey:@"AVAILABLE_NOTES"] mutableCopy];
    // Reload the table view to show changes
    [self.tableView reloadData];
}</pre></div></li><li class="listitem">We need to display the notes in table view. We have already retrieved the notes saved in iCloud; the rest of the implementation is to display the notes in the table view. In <code class="literal">NoteListViewController.m</code>, add the following code:<div><pre class="programlisting">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
  {
    return 1;
  }
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  return [self.notes count];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
  static NSString *CellIdentifier = @"Cell";
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];
  NSString *note = [self.notes objectAtIndex:indexPath.row];
  [cell.textLabel setText:note];
  return cell;
}</pre></div></li><li class="listitem">We have now come <a class="indexterm" id="id407"/>to the last part of the process: implementing <code class="literal">AddNoteViewController</code> to add notes to the cloud. Go to the implementation file of <code class="literal">AddNoteViewController</code> and add the following code:<div><pre class="programlisting">- (IBAction)cancel:(id)sender {
    [self dismissViewControllerAnimated:YES completion:nil];
}
- (IBAction)save:(id)sender {
    // Notify the previous view to save the changes locally
    [[NSNotificationCenter defaultCenter] postNotificationName:@"New Note" object:selfuserInfo:[NSDictionary dictionaryWithObject:self.noteTextField.text forKey:@"Note"]];
    [self dismissViewControllerAnimated:YES completion:nil];
}</pre></div></li><li class="listitem">To test the note app, we have to compile and deploy it onto an actual device. If you are using a simulator that supports iOS 7.1 or later, then you will be able to use the simulator <a class="indexterm" id="id408"/>for testing. Make sure that you enable iCloud on both devices. Launch the app, add a note on one device, and you'll see the note appear on the other device.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Keychain Services</h1></div></div></div><p>
<strong>Keychain Services</strong> is <a class="indexterm" id="id409"/>a programming interface that enables developers to add, find, modify, and remove keychain items. In iOS and OS X, a keychain is an encrypted container that stores passwords and other private data that need to be secured. In iOS, each application has its own keychain to which it has access. This ensures that our data is secured by the third party and other users.</p><p>Keychain provides a small space on which we can only store specific data such as passwords, account numbers, private numbers, and so on. With this article, I hope to convince you of the value of using the keychain in iOS and OS X instead of, for example, the application's user-defaults database, which stores its data in plain text without any form of security. Saving our data in keychain is better than the default database, because keychain is far more secure and robust.</p><p>In iOS, an application can use the keychain through the Keychain Services API. This API provides a number of functionalities to manipulate the data stored in the application's keychain. The APIs are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SecItemAdd</code>: This <a class="indexterm" id="id410"/>API is used to add data in <a class="indexterm" id="id411"/>keychain</li><li class="listitem" style="list-style-type: disc"><code class="literal">SecItemCopyMatching</code>: This <a class="indexterm" id="id412"/>API is used to <a class="indexterm" id="id413"/>find the existing data in keychain</li><li class="listitem" style="list-style-type: disc"><code class="literal">SecItemDelete</code>: This <a class="indexterm" id="id414"/>API is used to <a class="indexterm" id="id415"/>remove the data from the application's keychain</li><li class="listitem" style="list-style-type: disc"><code class="literal">SecItemUpdate</code>: This <a class="indexterm" id="id416"/>API is used to update the data in the <a class="indexterm" id="id417"/>application's keychain</li></ul></div><p>The Keychain Services API is a C-based API, but this doesn't prevent us from using it. Each of the preceding functions accepts a dictionary (<code class="literal">CFDictionaryRef</code>).</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Encryption and decryption</h2></div></div></div><a class="indexterm" id="id418"/><p>Most of us know about two types of encryption: symmetric and asymmetric encryption. Symmetric encryption, on the one hand, uses one shared key to encrypt and decrypt data. Asymmetric <a class="indexterm" id="id419"/>encryption, on the other hand, uses one key to encrypt data and another separate, but related, key to decrypt data.</p><p>In iOS, to encrypt and decrypt data, a Security framework is available. This process takes place under the hood, so we won't be directly interacting with this framework. We'll use symmetric encryption in our example application.</p><p>The Security framework offers a number of other services, such as Randomize services to generate cryptographically-secure random numbers; Certificate, Key and Trust services to manage certificates; public and private keys; and trust policies. The Security framework is a low-level framework available in both iOS and OS X with C-based APIs.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec41"/>iOS keychain concepts and structure</h2></div></div></div><p>The keychain is a <a class="indexterm" id="id420"/>secure and encrypted way to store our precious data. It is important that your app, and all subsequent versions of it, are signed by the same mobile-provision profile. If they aren't, you will have many troubles later on.</p><p>A keychain is a <a class="indexterm" id="id421"/>unit of sensitive data stored in your app. Keychain items are accompanied by one or more attributes. The attributes describe the keychain item, and which attributes we can use depends on the item class of the keychain item. The item class refers to the type of data we are going to store. This can be a username/password combination, a certificate, a generic password, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Understanding the application flow</h2></div></div></div><p>Before we start <a class="indexterm" id="id422"/>building the application, we need to know about the application flow, which is explained here:</p><div><ol class="orderedlist arabic"><li class="listitem">When the user launches the application, it presents the user with a view to sign in.</li><li class="listitem">If it hasn't created an account yet, its credentials are added to the keychain and signed in. If it has an account but enters an incorrect password, an error message is shown.</li><li class="listitem">Once it has signed in, it has access to the data collected with the application. The data is securely stored by the application.</li><li class="listitem">Whenever it takes data with the text field, this data is encrypted and stored in the application's <code class="literal">Documents</code> directory.</li><li class="listitem">Whenever it switches to another application or the device gets locked, it automatically signs out.</li></ol></div><p>Let's start an activity <a class="indexterm" id="id423"/>on the Keychain. Just follow these <a class="indexterm" id="id424"/>steps to accomplish the activity:</p><div><ol class="orderedlist arabic"><li class="listitem">Open Xcode and make a single-view application. Then, go to <strong>KeyChainSample</strong> | <strong>Capabilities</strong> and turn on the <strong>Keychain Sharing</strong> option, as shown in the following screenshot:<div><img alt="Understanding the application flow" src="img/1829OT_06_11.jpg"/></div></li><li class="listitem">After turning on the <strong>Keychain Sharing</strong> option, it will automatically create <strong>Entitlements File</strong> for us, as shown in the following screenshot:<div><img alt="Understanding the application flow" src="img/1829OT_06_12.jpg"/></div></li><li class="listitem">Don't forget <a class="indexterm" id="id425"/>to add <strong>Security framework</strong> (shown in the following screenshot); without it, the keychain will not <a class="indexterm" id="id426"/>work:<div><img alt="Understanding the application flow" src="img/1829OT_06_13.jpg"/></div></li><li class="listitem">Now, make a <a class="indexterm" id="id427"/>user interface in the <a class="indexterm" id="id428"/>storyboard like this:<div><img alt="Understanding the application flow" src="img/1829OT_06_14.jpg"/></div></li><li class="listitem">Add a new Objective-C file to the project subclass of <code class="literal">NSObject</code>. Then, write the following code in the interface file of the new file. Also, import <code class="literal">security.h</code> on the top of the file:<div><pre class="programlisting">#import &lt;security.h&gt;
@interface KeyChain : NSObject
{
  NSString * service;
  NSString * group;
}
-(id) initWithService:(NSString *) service_ withGroup:(NSString*)group_;

-(BOOL) insert:(NSString *)key : (NSData *)data;
-(NSData*) find:(NSString*)key;</pre></div><p>Our interface file will look like this:</p><div><img alt="Understanding the application flow" src="img/1829OT_06_15.jpg"/></div></li><li class="listitem">Write the following <a class="indexterm" id="id429"/>code in the implementation <a class="indexterm" id="id430"/>file of the new file that we added:<div><pre class="programlisting">@implementation KeyChain
-(id) initWithService:(NSString *) service_ withGroup:(NSString*)group_
{   self =[super init];
    if(self)
    {
      service = [NSString stringWithString:service_];
      if(group_)
        group = [NSString stringWithString:group_];
    }
    return  self;
}
-(NSMutableDictionary*) prepareDict:(NSString *) key
{
    NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];
    [dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
    NSData *encodedKey = [key dataUsingEncoding:NSUTF8StringEncoding];
    [dict setObject:encodedKey forKey:(__bridge id)kSecAttrGeneric];
    [dict setObject:encodedKey forKey:(__bridge id)kSecAttrAccount];
    [dict setObject:service forKey:(__bridge id)kSecAttrService];
    [dict setObject:(__bridge id)kSecAttrAccessibleAlwaysThisDeviceOnly forKey:(__bridge id)kSecAttrAccessible];
    if(group != nil)
      [dict setObject:group forKey:(__bridge id)kSecAttrAccessGroup];
    return  dict;
    
}
-(BOOL) insert:(NSString *)key : (NSData *)data
{
    NSMutableDictionary * dict =[self prepareDict:key];
    [dict setObject:data forKey:(__bridge id)kSecValueData];
    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);
    if(errSecSuccess != status) {
      NSLog(@"Unable add item with key =%@ error:%ld",key,status);
    }
    return (errSecSuccess == status);
}
-(NSData*) find:(NSString*)key
{
    NSMutableDictionary *dict = [self prepareDict:key];
    [dict setObject:(__bridge id)kSecMatchLimitOne forKey:(__bridge id)kSecMatchLimit];
    [dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnData];
    CFTypeRef result = NULL;
    OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)dict,&amp;result);
    
    if( status != errSecSuccess) {
      NSLog(@"Unable to fetch item for key %@ with error:%ld",key,status);
    return nil;
    }
    return (__bridge NSData *)result;
}</pre></div><p>The <code class="literal">_bridge</code> object is used to transfer a pointer between Objective-C and the core foundation, with no transfer of ownership. Our interface file will probably <a class="indexterm" id="id431"/>look like this:</p><div><img alt="Understanding the application flow" src="img/1829OT_06_16.jpg"/></div></li><li class="listitem">Connect the <a class="indexterm" id="id432"/>UI components to our <code class="literal">viewController.h</code> file. Import <code class="literal">KeyChain</code> (the newly added Objective-C file) on top of the file and create an object of the <code class="literal">KeyChain</code> class in the interface as follows:<div><img alt="Understanding the application flow" src="img/1829OT_06_17.jpg"/></div></li><li class="listitem">Add the <a class="indexterm" id="id433"/>code in the <code class="literal">IBAction</code> methods of our <a class="indexterm" id="id434"/>button with some more code as follows in the <code class="literal">viewController.m</code> file:<div><pre class="programlisting">#define SERVICE_NAME @"ANY_NAME_FOR_YOU"
#define GROUP_NAME @"iOS"
@interface ViewController ()
@end
@implementation ViewController
- (void)viewDidLoad
{
    [super viewDidLoad];
    keychain = [[KeyChain alloc]initWithService:SERVICE_NAME withGroup:nil];
}

-(void) showMessage:(NSString*)text
{
  UIAlertView * alert =[[UIAlertView alloc ] initWithTitle:@"Info"message:text delegate:nil cancelButtonTitle:@"Cancel" otherButtonTitles: nil];
  [alert show];
}
- (IBAction)save:(id)sender {
    NSString *keyString =self.keyTextField.text;
    NSData *data = [self.dataTextField.text dataUsingEncoding:NSUTF8StringEncoding];
    if([keychain insert:keyString :data])
    {
      [self showMessage:@"Successfully added data"];
    }
    else
      [self showMessage:@"Failed to  add data"];
    self.dataTextField.text =@"";
    self.keyTextField.text =@"";
}
- (IBAction)find:(id)sender {
    NSString *keyString =self.keyTextField.text;
    NSData * data =[keychain find:keyString];
    if(data)
    {
      [self showMessage:[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]];
    }
    else
    {
        [self showMessage:@"Failed to get Data"];
    }
}

- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    [textField resignFirstResponder];
    return YES;
}</pre></div><p>Our interface file will probably look like this:</p><div><img alt="Understanding the application flow" src="img/1829OT_06_18.jpg"/></div></li><li class="listitem">Compile and <a class="indexterm" id="id435"/>run the project; our simulator looks <a class="indexterm" id="id436"/>like the following screenshot. Enter the values and click on the <strong>Save</strong> button:<div><img alt="Understanding the application flow" src="img/1829OT_06_19.jpg"/></div></li><li class="listitem">After <a class="indexterm" id="id437"/>clicking on the <strong>Save</strong> button, one pop <a class="indexterm" id="id438"/>up will appear (as shown in the following screenshot) with a message that our data is saved in the keychain securely.<div><img alt="Understanding the application flow" src="img/1829OT_06_20.jpg"/></div></li><li class="listitem">Now <a class="indexterm" id="id439"/>write the <strong>Key</strong> value in the text field that <a class="indexterm" id="id440"/>exists in the keychain storage and click on the <strong>Find</strong> button. It will show data in a pop-up message as follows:<div><img alt="Understanding the application flow" src="img/1829OT_06_21.jpg"/></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>The Touch ID API</h1></div></div></div><p>Apple <a class="indexterm" id="id441"/>introduced a new feature in iOS 7 called <strong>Touch ID authentication</strong>. Previously, there was only four-digit passcode security in iPhones; now, Apple has extended security and introduced a new security pattern in iPhones. In <a class="indexterm" id="id442"/>Touch ID authentication, our fingerprint acts as a password. After launching the Touch ID fingerprint-recognition technology in the iPhone 5S last year, Apple is now providing it for developers with iOS 8. Now, third-party apps will be able to use Touch ID for authentication in the new iPhone and iPad OSes. Accounting apps, and other apps that contain personal and important data, will be protected with Touch ID. Now, you can protect all your apps with your fingerprint password.</p><div><img alt="The Touch ID API" src="img/1829OT_06_22.jpg"/></div><p>There are two ways to <a class="indexterm" id="id443"/>use Touch ID as an authentication mechanism in our <a class="indexterm" id="id444"/>iOS 8 applications. They are explained in the following sections.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Touch ID through touch authentication</h2></div></div></div><p>The Local <a class="indexterm" id="id445"/>Authentication API is an API that returns a Boolean value to accept and decline the fingerprint. If there is an error, then an error code gets executed and tells us what the issue is.</p><p>Certain conditions <a class="indexterm" id="id446"/>have to be met when using Local Authentication. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application must be in the foreground (this doesn't work with background processes)</li><li class="listitem" style="list-style-type: disc">If you're using the straight Local Authentication method, you will be responsible for handling all the errors and properly responding with your UI to ensure that <a class="indexterm" id="id447"/>there is an alternative <a class="indexterm" id="id448"/>method to log in to your apps</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Touch ID through Keychain Access</h2></div></div></div><p>Keychain Access <a class="indexterm" id="id449"/>includes the new Touch ID integration in iOS 8. In Keychain Access, we don't have to work on implementation <a class="indexterm" id="id450"/>details; it automatically handles the passcode implementation using the user's passcode. Several keychain items can be chosen to use Touch ID to unlock the item when requested in code through the use of the new <strong>Access </strong><a class="indexterm" id="id451"/><strong>Control Lists</strong> (<strong>ACLs</strong>). ACL is a feature of iOS 8. If Touch ID has been locked out, then it will allow the user to enter the device's passcode to proceed without any interruption.</p><p>There are some features of Keychain Access that make it the best option for us. They are listed here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keychain Access uses Touch ID, and its attributes won't be synced by any cloud services. So, these features make it very safe to use.</li><li class="listitem" style="list-style-type: disc">If users overlay more than one query, then the system gets confused about correct user, and it will pop up a dialog box with multiple touch issues.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Using the Local Authentication framework</h2></div></div></div><p>Apple <a class="indexterm" id="id452"/>provides a framework to use Touch ID in our app called <strong>Local Authentication</strong>. This framework was introduced for iOS 8. To make an app, including the Touch ID authentication, we need to import this framework in our <a class="indexterm" id="id453"/>code. It is present in the framework library of Apple. Let's see how to use the Local Authentication framework:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the Local Authentication framework as follows:<div><pre class="programlisting">#import&lt;localAuthentication/localAuthentication.h&gt;</pre></div><p>This framework will work on Xcode 6 and above.</p></li><li class="listitem">To use this API, we have to create a Local Authentication context, as follows:<div><pre class="programlisting">LAContext *passcode = [[LAContext alloc] init];</pre></div></li><li class="listitem">Now, check whether Touch ID is available or not and whether it can be used for authentication:<div><pre class="programlisting">- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError * __autoreleasing *)error;</pre></div></li><li class="listitem">To display Touch ID, use the following code:<div><pre class="programlisting">- (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString *)localizedReason 
    reply:(void(^)(BOOL success, NSError *error))reply;</pre></div></li><li class="listitem">Take a <a class="indexterm" id="id454"/>look at the following <a class="indexterm" id="id455"/>example of Touch ID:<div><pre class="programlisting">LAContext *passcode = [[LAContext alloc] init];
NSError *error = nil;
NSString *Reason = &lt;#String explaining why our app needs authentication#&gt;;
if ([passcode canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error])
{
  [passcode evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
    localizedReason:Reason reply:^(BOOL success, NSError *error) {
        if (success) 
        {
          // User authenticated successfully
        } else 
        {
          // User did not authenticate successfully,go through the error
        }
    }];
}
else
{
    // could not go through policy look at error and show an appropriate message to user
}</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, you learned how to push your data to iCloud and how to save your private data, such as passwords, account numbers, ATM pins, and so on, to Keychain. We also focused on the Touch ID API, which was introduced in iOS 8. In the next chapter, you will learn how to push your app on the App Store.</p></div></body></html>