- en: Chapter 2. Instant Gratification – Your First Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Dream the impossible, seek the unknown, and achieve greatness."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*–*Anonymous**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are all charged up about RubyMotion and have our system set up,
    let''s create a simple RubyMotion application. We will try and keep it simple,
    but sometimes you may feel disconnected by monotonously typing the code. Although,
    going along is enough for now. Remember that mimicry is a powerful form of learning;
    that''s how we have learned most of our skills, such as talking, reading, writing,
    and that is how you will learn to program with RubyMotion. We promise you that
    by the end of this book, you will have sufficient knowledge of RubyMotion to create
    an iOS application and make it live on the App Store. In this chapter we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first RubyMotion application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the folder structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REPL – the interactive console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your first application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the classic `HelloWorld` application. As we have discussed
    in the last chapter, RubyMotion has a terminal-based flow, so let's fire up our
    terminal and create our very first RubyMotion application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you observe closely the output on the terminal screen, you will see that
    a lot of files and directories have been generated by a single `motion` command,
    which automatically creates standard directories, and you will also see the file
    structure that will quickly bring us onboard with app development, which we can
    work on later and enhance to make a fully functional application. Moreover, since
    the structure is common to all the RubyMotion apps, it's easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like the `motion` command, popular frameworks such as Ruby on Rails also
    have commands such as `rails` to create a predefined layout of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps automatically compile the code and start the application
    on a simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the application, traverse to the application directory, and type the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Your first application](img/5220OT_02_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Wow! The `rake` command automatically compiles the code and starts the application
    on a simulator. So far, we have not created any views for our application; that's
    why we can see a blank screen. It looks boring, but remember that we have not
    written a single line of code. So let's write some code, create some views, and
    build our application again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can open the RubyMotion project in your favorite editor. If you don't have
    an editor yet, you can use either TextEdit or VIM.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the file `app_delegate.rb` in the app folder and add the following code
    in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s re-run our application by traversing to the application directory and
    typing the execute command (`rake`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `rake` command will compile our code and fire up the iPhone simulator.
    We can see a blue pop-up saying **Hello World!** in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Your first application](img/5220OT_02_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let's understand the code that we have written in `AppDelegate`. Here the application
    method (`didFinishLaunchingWithOptions:launchOptions`) is called first when our
    application starts. This will be the starting point of our application and the
    right place to define our window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RubyMotion functions are a combination of the usual Ruby name method (`didFinishLaunchingWithOptions`)
    with their named parameters; a variable directly follows the function, which it
    refers to, and therefore, we don't need to know the implementation of the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Named parameters were added to RubyMotion to preserve the existing Objective-C
    APIs, and the extra symbols are required parts of the method name, for example,
    `didFinishLaunchingWithOptions`:`launchOptions`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As discussed, the code written in `AppDelegate` will be called automatically
    as the application is initialized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the following code snippet, we created an object alert of the `UIAlertView`
    class and then we assigned a `Hello World!` string to the message attribute of
    the object. Now we have our alert object ready. To display this alert on the device
    screen, we call the show method on the alert object as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`UIAlertView` is a class that is bundled in the `UIKit` framework of the iOS.
    We can use this class to display an alert message on the screen. This class is
    inherited from `UIView` that is inherited from `UIResponder` that, in turn, is
    inherited from `NSObject`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why do we see the NS prefix?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective-C is a superset of C and thus doesn't have namespaces like in C++;
    therefore, the symbols must be prefixed with a unique prefix so that they don't
    collide. This is particularly important for symbols defined in a framework. The
    original code for the Cocoa frameworks came from the NextStep libraries, and so
    the NextStep engineers chose to prefix their symbols with NS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To exit the application, close the simulator by selecting the **exit** option
    or press *Command* + *Q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The iOS simulator is a great tool for testing your applications quickly. It
    comes bundled with Xcode. But you can't test everything on the simulator. To test
    the shaking of a device, camera, GPS, Accelerometer, Gyroscope, and other device
    capabilities, you may require additional products to pass device data to the app
    in the simulator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will understand the folder structure of our application
    as we know from the previous section that `motion create <project name>` sets
    up the directory structure with all the essential files to run a simple RubyMotion
    application. Let''s walk through each one of them to have a precise understanding
    of their function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app` folder: This is the core of your application code; you will write
    most of your code in this folder. RubyMotion iterates in this folder and loads
    any `.rb` file that it catches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to keep your code somewhere else other than the `app` directory,
    add the folder path to the `Rakefile`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `app_delegate.rb` file in the `app` folder: This file is at the heart of
    the RubyMotion application. If you are a little familiar with iOS development,
    this is the delegate file. A delegate is an object that usually reacts to some
    event in another object and/or can affect how another object behaves. There are
    various methods that can be implemented in `UIApplicationDelegate`. These methods
    are called during the different phases of an application, such as during the finish
    of its launch, during termination, when the application is low on memory, and
    during the occurrence of important changes. While the application is running,
    tracking its state transitions is one of the main jobs of the application delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'App delegates use the method `application:didFinishLaunchingWithOptions` as
    the first entry point. This method is called after your application has been launched.
    When this method is called, your application is in the inactive state. A few other
    methods available are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`applicationWillEnterForeground`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applicationWillTerminate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application:shouldSaveApplicationState`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application:shouldRestoreApplicationState`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of available methods can be obtained from the iOS developer library
    ([http://developer.apple.com/library/ios](http://developer.apple.com/library/ios)).
    The good part here is that most of the methods are self-explanatory by their name.
    For example, `applicationWillEnterForeground` will be called when your application
    is relaunched.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We see that in some iOS 6 applications, the app is restored to the previous
    state; we can handle this in an application delegate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `resources` folder: As the name suggests, the `resources` folder contains
    static content, such as images, sounds, UI layouts, and icons that we use in our
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Spec` folder: This folder contains automated test cases. RubyMotion supports
    a Ruby testing framework, Bacon; it is a small RSpec clone that is used for writing
    unit, functional, and UI tests. By default, it creates `main_spec.rb` as an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rakefile`: With `Rakefile` we can configure our application name, resources,
    gems to be included, and the code location. We will discuss more about `Rakefile`
    later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some more goodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that it's not so much fun to have only a simple `HelloWorld` pop-up
    as our very first application, so let's jazz up our code by adding some more goodies
    to our alert box; and this time, let's do things in a much better way.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier we had added an alert box in the delegate itself. Actually it is not
    a good idea to write code in the application delegate. It is better to write code
    in a Model-View-Controller (MVC) way. Right now we won't cover all three parts
    of the MVC architecture for now let's begin with the controller for our application
    and add three buttons in this alert box, add a title, and add a message for the
    title box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `UIAlertView` that we''ve used in the last section has numerous properties,
    such as title, message, delegate, cancelButtonTitle, otherButtonTitles, and many
    more. Let''s use a few of them in our application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file `root_controller.rb` in the `app` folder and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To call this controller, we need to update our `AppDelegate` class. Replace
    the following code in your `app_delegate.rb` `file`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the simulator by running the `rake` command from the console inside your
    application directory as follows:![Some more goodies](img/5220OT_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's cool; our earlier `HelloWorld` pop-up has now been replaced with an alert
    box that has a title, a cancel button, and two other buttons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The iOS SDK has been built around the MVC pattern that separates responsibilities
    and ends up with an application that is easy to design and maintain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's understand the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an iPhone application starts, it puts a window on the screen, which we
    have created using the `UIWindow` class. You can think of a window as a drawing
    board where you can put anything, such as a button, textbox or label. The instance
    of the `UIWindow` class manages and coordinates the views of an application, which
    are displayed on a device screen.
  prefs: []
  type: TYPE_NORMAL
- en: A `UIScreen` object contains the bounding rectangle of the device's entire screen.
    So, `UIScreen.mainScreen.bounds` returns the rectangle size according to the screen
    size and orientation of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every iOS application needs at least one window, which is an instance of the
    `UIWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, should I remember all the properties and methods of
    the Apple iOS SDK, such as `UIAlertView`? It is not necessary to memorize them
    as one can always refer to the properties and methods from the iOS development
    library. Nevertheless, having a basic idea about the usage of a class can come
    in handy at times. The popular IDE, RubyMine, supports RubyMotion. It also has
    a useful autocompletion feature.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The more you understand, the less you have to memorize.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RubyMotion is based on an underlying principle, "to use the tools which developers
    love". Therefore, to create an application using RubyMotion, we require only two
    tools; the first is your favorite editor and the second is the terminal. While
    developing a RubyMotion application, you will be required to familiarize yourself
    with the command line. Familiarity with the terminal always helps in faster and
    comfortable development.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our `HelloWorld` application, let us explore a few
    commands that we have already used, and remember that RubyMotion uses them considerably.
    These commands are responsible for inaugurating our RubyMotion projects, `motion`
    and `rake`.
  prefs: []
  type: TYPE_NORMAL
- en: Motion command – one-stopshop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As used previously, the `motion` command creates our RubyMotion project and
    also supports various other options. The `motion` command is similar to the popular
    framework Ruby on Rails' `rails` command. Before we go any further, let's fire
    up our terminal and see what can be done using the `motion` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`motion account`: This displays the account/license information on the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion activate`: If you want to activate your RubyMotion framework with a
    new license or if you have not yet activated the framework, `motion activate`
    can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion create <project name>`: This command will generate a RubyMotion project''s
    skeleton that will have all the essential files needed to begin developing an
    iOS application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion ri <API-name>`: This command helps us to find the documentation for
    the API that has been mentioned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion update`: RubyMotion is a fast-moving framework and often requires updates.
    `motion update` updates your framework from the command line itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion support`: There may be times when you have questions only an expert
    can answer. `motion` `support` helps you connect with RubyMotion directly, and
    you can ask a question by filling up a form. It can also be used for any feature
    request or for reporting a bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rake tasks – get things done fast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rake is a simple Ruby build program with capabilities similar to `Make`. RubyMotion's
    `rake` command has many predefined tasks that help you do several trivial jobs,
    such as compiling your code to test in a simulator or creating a package to test
    on a device, with ease. Let's fire up our terminal again and check what tasks
    can be performed using `rake --tasks`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table elaborates the different Rake tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Rake task | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Rake archive | Create a `.ipa` archive |'
  prefs: []
  type: TYPE_TB
- en: '| Rake archive:distribution | Create a `.ipa` archive for distribution |'
  prefs: []
  type: TYPE_TB
- en: '| Rake build | Build everything |'
  prefs: []
  type: TYPE_TB
- en: '| Rake build:device | Build the device version |'
  prefs: []
  type: TYPE_TB
- en: '| Rake build:simulator | Build the simulator version |'
  prefs: []
  type: TYPE_TB
- en: '| Rake clean | Clear build objects |'
  prefs: []
  type: TYPE_TB
- en: '| Rake config | Show project config |'
  prefs: []
  type: TYPE_TB
- en: '| Rake ctags | Generate ctags |'
  prefs: []
  type: TYPE_TB
- en: '| Rake default | Build the project, then run the simulator |'
  prefs: []
  type: TYPE_TB
- en: '| Rake device | Deploy on the device |'
  prefs: []
  type: TYPE_TB
- en: '| Rake simulator | Run the simulator |'
  prefs: []
  type: TYPE_TB
- en: '| Rake spec | Same as a `spec:simulator` |'
  prefs: []
  type: TYPE_TB
- en: '| Rake spec:device | Run the test/spec suite on the device |'
  prefs: []
  type: TYPE_TB
- en: '| Rake spec:simulator | Run the test/spec suite on the simulator |'
  prefs: []
  type: TYPE_TB
- en: '| Rake static | Create a static library |'
  prefs: []
  type: TYPE_TB
- en: So Rake has plenty of tasks to do, but most importantly, out of all these tasks,
    if we simply run Rake, it will build and run our application on the iOS simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Rake file – configuring your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RubyMotion applications are highly configurable using different attributes in
    a `Rakefile`. These attributes, by default, come with a sensible value but can
    be overridden with custom values. Let's explore each one of them—this section
    will come in handy, time and again, as we proceed with our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see your current application configuration, run the `rake config` task,
    and you will be presented with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the entire configuration settings for your application. These settings
    can be modified in a `Rakefile`. You may find it easy to understand what these
    properties do by their names, but let us explain a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is where you can specify the name of your project as a string.
    By default, the name of your application will be the attribute that you passed
    during `motion create`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: This variable saves the current application version as a string;
    it is 1.0 by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identifier`: The project identifier is a string that is in reverse DNS—a naming
    convention that is in the reverse order of the domain name notation—such as `com.yourcompany.yourapp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delegate_class`: This is where you specify your application delegate class
    as a string that is loaded once the application starts. The default value is `AppDelegate`
    and the class is defined in the `app`/`app_delegate.rb` file. However, we can
    rename the `AppDelegate` class to a custom name of our choice and this then has
    to be updated in the `Rakefile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Files`: This shows every `.rb` file in the `app` directory in an array format.
    The default value is the result of executing the following expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`framework`: This shows the names of the iOS frameworks that are used in our
    application in an array format. Soon you will be using many iOS frameworks, such
    as CoreFoundation, CoreMotion, and others, with your application. The build system
    is capable of dealing with dependencies, therefore they should be mentioned here.
    The default value is either `UIKit`, `Foundation`, or `CoreGraphics`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libs`: This variable shows the library paths that are to be linked to the
    application in an array format. It contains the path to public system libraries,
    for example, **/usr/lib/libz.dylib**. The default value is `[]`, an empty array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_dir`: This variable is used to specify the directory path where you
    want the application build to be created in a string format. It must be relative
    to the project directory. The directory initially gets created automatically.
    In case it is not created, a temporary directory will be used instead. The default
    value is `build`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources_dir`: This variable is used to specify the directory for the resource
    files where all the images and icons go in a string format. It must be relative
    to the project directory. The default value is `resources`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec_dir`: This variable is used to specify the directory of `spec` files
    where all our test cases are present in a String format. The default value is
    `spec`. It should be relative to the project directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icons`: This variable lists the icons used for the application present in
    the `resources` folder in an `array` format, for example, `icon.png` and/or `icon-72.png`.
    The files should be in tune with Apple''s **HIG** (**Human Interface Guidelines**).
    By default, the value is `[]`, an empty array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fonts`: This variable lists the names of the font files present in the `resources`
    directory in an `array` format. These fonts will be taken into account while either
    generating the application bundle or testing on a simulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prerendered_icon`: iOS application icons usually have a reflective shine on
    them. For that purpose, this property is used. If it is false, we will get the
    reflective shine on the icon. By default, the value is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device_family`: With this property, we can specify which family of iOS device
    our application supports. The values can be `iphone`, `ipad`, or for universal
    application [`:iphone`, `:ipad`]. By default it is `:iphone`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interface_orientations`: Apple iOS devices support various orientations for
    an application. They can be `portrait`, `landscape_left`, `landscape_right`, or
    `portrait_upside_down`. By default, the value is an array of `:portrait`, `:landscape_left`,
    or `:landscape_right`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xcode_dir`: This configuration tells us where the Xcode is installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Giving a new value to the `XCode_dir` property should generally be done first,
    before changing other `Rakefile` properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sdk_version`: This configuration lets us decide which SDK version will be
    used. By default, the value is the most recent version of the supported SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deployment_target`: This configuration shows which iOS SDK to target for the
    RubyMotion project. By default, the value is of the current SDK version that is
    installed, but this can be changed to any desired version of the iOS SDK, for
    example, 6.0 that will use iOS SDK Version 6.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`codesign_certificate`: This configuration shows which code-signing certificate
    is used. By default, the value is the first iPhone developer certificate in the
    keychain utility; for example, in our case it is **iPhone developer: Paul Akshat
    (S3KPMT842Z)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provisioning_profile`: This configuration variable specifies the path of the
    provisioning profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seed_id`: The Apple provisioning profile has an identifier. This configuration
    shows us the same, which is usually the first application identifier picked from
    the provisioning profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REPL – the interactive console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RubyMotion comes with an interactive console that lets us traverse and scan
    the code that we are using in our application. The good thing is that the console
    is connected to the application running on the simulator. This means that if we
    make any changes from the console, it will be reflected on the simulator in real
    time. Let's try this with our `HelloWorld` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, it will open a simulator and the terminal screen will show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now hold the *Command* key and hover the mouse over the simulator. You will
    see a red-bordered box. As we move the mouse pointer over an element, we can see
    its corresponding class object appearing in the terminal window `(UIView:0xc5710c0)?`
    as seen in the following screenshot. Now click the mouse to select the object
    that you want to work on dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: '![REPL – the interactive console](img/5220OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try the following command on the terminal and observe the changes in the simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self` returns the current object selected by the mouse.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an object `blue` for the `UIColor` class and assign the color blue to
    the variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the background color of the view, use the `backgroundColor` property
    of the selected view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the background color on the simulator has been changed to blue
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REPL – the interactive console](img/5220OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s dismiss the alert box by clicking on any button and put a new alert
    box with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The simulator shows a new alert box on screen without compiling the code as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REPL – the interactive console](img/5220OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can dismiss the alert box as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see how REPL is a great tool for developing applications for iOS and
    how it helps us make changes dynamically. To make these changes permanent we need
    to add the same code to our source code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger – catch your mistakes!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical debugger provides the ability to halt when specific conditions are
    encountered. It also offers sophisticated functions, such as running a program
    step by step, breaking or pausing the program for an examination based on breakpoints,
    and tracking the values of the variables at that state. RubyMotion Version 1.24
    and above support debugging using GDB: the GNU project debugger ([http://www.gnu.org/software/gdb/](http://www.gnu.org/software/gdb/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The RubyMotion debugger provides the following inbuilt debugging facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: It stops the program at a specific line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It examines the problem when the program has stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It checks the value for the variables at a specific breakpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The RubyMotion compiler implements the **DWARF** debugging format's metadata
    for the Ruby language. This allows external programs, such as the debugger in
    our case, to retrieve source-level information about the RubyMotion application.
    The metadata is saved under a `.dSYM` bundle file at the same level as the `.app`
    bundle in the build directory of your project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to start debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three ways in which we can start the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: While testing on a simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can start the debugger with a simulator. The debugger will directly attach
    itself to the app and replace the interactive shell (REPL).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, just type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While testing on a device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can start debugging with the device running simultaneously. The build system
    will start the iOS debugging server on the device and then remotely attach the
    debugger on your shell right after the application has been deployed on the device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the release mode, local variables might not be accessible in the debugger
    as they are optimized to fit into CPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test your application on a device, you are required to enroll for the **Apple
    Developer Program**. We will discuss this in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Entering commands before starting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might need some breakpoint before loading the application; we can do this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On execution of this command, the GDB will start and we will be able to set
    the breakpoints. This is discussed in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can put breakpoints at a specific location of our application code using
    the `break` command and then pass the location where the debugger should stop
    the execution of the code using the `file_name:line_number` notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try putting a breakpoint in our current application. To do so, we need
    to start our `HelloWorld` application in debugging mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s set a breakpoint on the eighth line of the file `app_delegate.rb`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, the execution of your application will halt at line
    number 8 of the `app_delegate.rb` file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To list the breakpoints that have been set up in the current debugging environment,
    we use the `info breakpoint` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the list of breakpoints created in the last section can also
    be seen in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Moving between the different breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `continue` command will continue the execution of the program until it reaches
    the next breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use its alias `c` as follows; it is more handy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `next` command will continue the execution of the program until the next
    source-level location. This is usually the very next line in the Ruby source code.
    You should have a look at the terminal for the relevant source code line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Checking the value of a local variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an important feature of debugging, to check the value of a variable
    at a specific breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the alert is an object of the `UIAlertView` class
  prefs: []
  type: TYPE_NORMAL
- en: '**Pro** (**print-ruby-object**) accepts two parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The object on which the variable will be retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name that you want to get.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check the variables available for us to execute, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Checking the value of an instance variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also check the value of an instance variable during some breakpoint
    using **pri** (**print-ruby-ivar**) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`pri` accepts two commands as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The object on which the instance variable will be retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance variable that you want to get. Make sure to include the `@` character
    in the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use `pri @tweet` instead of `pri self @tweet`.
  prefs: []
  type: TYPE_NORMAL
- en: Disable breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To disable a breakpoint, use `disable` followed by the breakpoint number; it
    has to be disabled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Exit debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type `quit` to exit the debugger as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased,
    and the graphics bundle of this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
  prefs: []
  type: TYPE_NORMAL
- en: If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recap what we have done in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a simple RubyMotion application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed the basic RubyMotion application structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored the commands available with RubyMotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performed different Rake tasks with RubyMotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to configure your RubyMotion application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worked with the interactive console—REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugged your application using the RubyMotion debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we turn our attention to RubyMotion data type objects—such
    as strings and arrays. We will also learn how to interface with C and we will
    focus on memory management in RubyMotion.
  prefs: []
  type: TYPE_NORMAL
