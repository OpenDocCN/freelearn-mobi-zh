- en: Chapter 7. Key-value Programming Approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key-value coding is a really cool function that works well with key-value observing.
    It allows you to code less and create very elegant solutions and code modules.
    There are many cases in a real application when something changes and another
    part of the application should be affected. The thing is that you can do anything
    when a property of an instance or class changes, including but not limited to
    checking whether its value is valid, sending a message to someone when something
    changes to a certain value, and so on. The options are unlimited.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is key-value coding?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NSKeyValueCoding protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual subsets of the NSKeyValueCoding behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associated objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectors as keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum flexibility and handling unusual keys/values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, do note that the NSKeyValueCoding protocol has been available since Mac
    OS X 10.0 in Cocoa, and it has also made its appearance in iOS 2.0, which came
    out in July 11, 2008\. Generally, APIs for iOS and Mac tend to make their appearance
    on the Mac platform first before making their appearance on the iOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: What is key-value coding or KVC?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key-value coding is basically a mechanism to indirectly access an object''s
    properties, rather than explicitly getting and setting those properties via instance
    variables. With KVC, we use strings as properties keys, which act as an identifier.
    It is used by passing a "key", which is a string to get or set the property related
    to that key. For example, take a look at the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created `DogClass` with two properties of `NSString`
    and `NSInteger`. Then, we used `valueForKey` and `setValue` to get the value of
    `dog_name` and `number_legs` respectively using key-value coding.
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds familiar to you, you may recognize the syntactical similarity
    when using NSDictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another sample code, which you can refer to for more clarification.
    Let''s check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Some developers who were introduced to Objective-C earlier disliked this approach
    of setting the property explicitly using the dot operator as seen in `myObject.myProperty
    = myValue`, but it is essentially helpful since it separates the property involved
    in the setting process from the action of setting itself. A normal setter is applicable
    in this context, but writing your own setters will mean that you are writing a
    lot of boilerplate code and this will make your code more verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, your app's accessor methods will implement the methods and patterns
    signatures determined by the KVC. The task of those accessor methods is to provide
    a way into the property values of your application's data models. There are two
    of them, `set` and `get` accessors. The `set` accessors—also known as `setters`—set
    the property's value, while the get ones—also known as `getters`—get/return the
    property's value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a `NSTableViewDataSource` method to handle an edit for one of the rows,
    other than the default one, without it being KVC. It should look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as soon as we can use KVC, the method can be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The essence of KVC is shown here; it's a better approach because each property's
    edit doesn't need to be handled as a separate condition. Another huge advantage
    is its efficiency since a table with thousands of columns will be handled by the
    same code, not even a line added to it. Notice that in the first example, we needed
    to have two `if` loops to handle two different identifiers, but using KVC, we
    can cut down on the verbose code and use `setValue` instead and achieve the same
    result with just one statement.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the fact that key-value coding simplifies your code, implementing its
    compliant accessors is an effective design principle, and it helps the data encapsulation
    and makes it easier to work with key-value observing—which we will cover later—and
    other technologies such as Cocoa bindings, Core Data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`NSKeyValueCoding` is an informal protocol that provides the essential methods
    for KVC, while `NSObject` provides its default implementations. Key-value coding
    can access three types of object values; they are attributes, one-to-one relationships,
    and one-to-many relationships, where we can access a property indirectly using
    a string.'
  prefs: []
  type: TYPE_NORMAL
- en: What we call attribute is just a simple value property, so it might be a `NSString`
    or `Boolean` value, as well as `NSNumber` and other immutable object types.
  prefs: []
  type: TYPE_NORMAL
- en: When an object has properties of its own, these are known as properties, which
    are assigned a one-to-one relationship between the object and property. What is
    interesting about these properties is that they can change, without the object
    changing itself at all. To better understand this, think of a `NSView` instance's
    superview as a one-to-one relationship. A set of related objects make a one-to-many
    relationship. We can see this in `NSArray` or `NSSet` instances, where a `NSArray`
    or `NSSet` instance has a one-to-many relationship to a group of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The NSKeyValueCoding protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NSKeyValueCoding` protocol is used in every sample code I've shown until
    now. I also have been calling it a protocol, but as I said earlier, it's an informal
    protocol, a `NSObject` category.
  prefs: []
  type: TYPE_NORMAL
- en: KVC is a mechanism that enables you to indirectly access an object's properties,
    using a "key" of strings to do it. To enable KVC, `NSKeyValueCoding` must be complied
    by your classes. Most of the time, you don't need to do anything in order to get
    it done because it's complied by `NSObject`.
  prefs: []
  type: TYPE_NORMAL
- en: To make a key-value coding compliant class for a certain property, the methods
    `setValue:forKey:` and `valueForKey:` must be implemented to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Compliance of attributes and one-to-one relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must ensure that your class has the following specification in case the
    of properties that are simply attributes or one-to-one relationships; an example
    would be `[myObject setValue:myValue forKey:@"myProperty"];`, which we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Have an instance variable called `<key>` or `_<key>`, or have an implemented
    method called `-<key>`, which is a reference to the key in your key-value pair.
    As a rule of thumb, KVC keys start with lowercase letters, but for ones, such
    as URL, it's also acceptable if the first letter is uppercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the property is a mutable one, `-set<Ket>:` would be also implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the `-set<Key>:` method should not include any validation
    as validation is to be implemented by the method mentioned in the next point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the validation is suitable for the key, `-validate<Key>:error:` must be implemented
    here along with your validation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance of indexed one-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `NSArrays` or `NSMutableArrays` will introduce you to the concept of
    one to-many relationships, where the key-value coding compliance requirements
    for indexed to-many relationships you need to ensure are:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of a method called `-<key>`, returning an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides, you might have an `NSArray` instance variable called `<key>` or `_<key>`
    or even proceed the implementation of `-countOf<Key>` and one or all of the following:
    `-<key>AtIndexes:` or `-objectIn<Key>AtIndex:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to improve performance, you can also implement `-get<Key>:range:` but
    it's not a requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, if you are dealing with mutable indexed ordered one to-many relationships,
    these are your requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get at least one of the methods implemented: `-insertObject:in<Key>AtIndex:`
    and `-insert<Key>:atIndexes:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get at least one of the methods implemented: `-removeObjectFrom<Key>AtIndex:`
    and `-remove<Key>AtIndexes:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an option, you can even implement one of the methods: `-replace<Key>AtIndexes:with`
    or `-replaceObjectIn<Key>AtIndex:withObject:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance of unordered many-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NSSets are an example of an unordered collection and also have a many to-many
    relationship, so the key-value coding compliance requirements for unordered many
    to-many relationships you need to ensure are:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of a method called `-<key>`, returning an `NSSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, set an instance variable called `<key>` or `_<key>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or get these methods implemented: `-enumeratorOf<Key>` , `-countOf<Key>`, and
    `-memberOf<Key>:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it''s a mutable unordered to-many relationship, KVC compliance will ask
    you to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement at least one of the following methods: `-add<Key>:` or `-add<Key>Object:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement at least one of the following methods: `-remove<Key>:` or `-remove<Key>Object:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to improve performance, you can implement `-set<Key>:` and `-insert<Key>:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With NSString keys, you can set and get values using the methods `setValue:forKey:`
    and `valueForKey:`. This key is a simple string that serves as an identifier to
    an object''s property. A key must be in accordance with the following rules: starting
    with a lowercase letter, shouldn''t contain white-spaces, and make use of ASCII
    encoding. All these rules are applied in the following sample keys: `mySampleKey`,
    `pageNumber`, and `oddSum`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also key paths, they're basically a string with two or more keys separated
    by dots, as `pictures.byOwner.forYear`. If you have a hard time trying to understand,
    think about it as a UNIX directory relative path as shown here, `pictures/Vasilkoff/2014`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s clear that the folder 2014 is relative to `Vasilkoff`, which is relative
    to `pictures`, which in turn is relative to the user''s current directory. In
    key paths, the first key—in our preceding code sample: `pictures`—is relative
    to the receiver object.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, using the concept of address and street as you can derive a street
    from the address. So, if you use the same concept, the `address.street` key path
    will get the value of the address property from the receiving object, and then
    you can determine the street property relative to the address object.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of key-value coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most properties support the `NSKeyValueCoding` informal protocol by default.
    Any object that inherits from `NSObject` has automatic support for `NSKeyValueCoding`.
    So, your own custom class will not have support for `NSKeyValueCoding` unless
    you explicitly make it inherit from `NSObject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KVC will automatically look for setter and getter methods and if none is found,
    then it will even get or set instance variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility of using key paths is really helpful while handling multiple
    property objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be notified of the state change, KVC can be easily integrated with `NSKeyValueObserving`
    in order to implement the observer software pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility of dealing with undefined keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This provides fallbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of key-value coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property keys must be only `NSStrings`, which means that the compiler does
    not have any information on the type of property or any details about its existence.
    So, any type of information cannot be retrieved from the return value of ID, which
    as you know, is a pointer to an Objective-C object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its extended search path makes it a very slow KVC approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must provide a method or an instance variable matching the name of
    the property, only then it will be found by `NSKeyValueCoding`. If there is a
    typo in your key, your application will crash during runtime and not compile time,
    so you must make sure that your key is spelled correctly to avoid a crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual subsets of NSKeyValueCoding behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NSKeyValueCoding` protocol acts in different ways while looking up for
    methods and instance variables. In the first case, it will look up for the method's
    selector's name, while in the last, it will look up for the instance variable's
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done manually, as we can see in the following samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since KVC can look up for setters and getters automatically, you might only
    be required to use the preceding approach by creating your own lookup path if
    you want to avoid `NSKeyValueCoding` to find specified or ordinary methods and
    instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of creating your own lookup path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid `NSKeyValueCoding`, looking for methods or instance variables that
    will normally be found by `NSKeyValueCoding` and creating your own lookup path
    will be the approach you require. Let''s start with the advantages and follow
    that up with the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It may be faster than normal `NSKeyValueCoding` paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gives you more control over the path. Unlike `NSKeyValueCoding` paths, it
    will also work for non `NSObject` inherited classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing it manually, non-object values can be used for get and set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of creating your own lookup path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, you will spend more time working on it than just using normal `NSKeyValueCoding`
    paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also provides less flexibility as you need to write more code to cover any
    unusual key/value cases, which is normally covered by the automatic method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associated objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Objective-C 2.0 runtime used by apps in iOS and 64-bit Mac OS X, you''re
    allowed to set an association from any object to another. The object, in this
    case, without support from instance variables or methods can have a random set
    of extra properties set by the key at runtime, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can use this if you want to set a property from outside an object. If you
    would be an object and your t-shirt color a property of yours, it would be like
    someone changing its color from outside your house, and you wouldn't even notice
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You should use it in similar circumstances, where you want to keep the object
    away for knowing, supporting, or being involved while you set a property from
    other parts of the program. Associated objects should not be the method you want
    to use at the top of your head as lack of type information makes it easy for a
    crash to appear due to incorrect typing.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using associated objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key can be any pointer. In this case, `OBJC_ASSOCIATION_ASSIGN` can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be the fastest key-value coding approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no support required from the method or instance variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of using associated objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It has no effect over the object itself (instance variable or method). The object
    won't know about its own changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In associated objects, a key is no longer `NSString`, but a pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectors as keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, KVC looks up for a property key and acts only after the property key
    is found. The other approach is about acting on an object's property in the lookup
    process. There is a lookup method in Objective-C core and its keys are used as
    selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code is how you implement this lookup method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is very similar to the manual implementation of the instance variable's
    setter, but instead of using the key to form a selector to do a look up, it uses
    the selector itself as the key.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using selectors as keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's possible to get and set non-object data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From all approaches that handles methods, this is the fastest one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of using selectors as keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need different selectors for get and set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since selectors are not objects, it's impossible to store directly in `NSArray`
    and `NSDictionary`. Instead, you can use `NSValue` or Core Foundation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum flexibility and handling unusual keys/values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you learned so many ways to use key-value coding, there is still a very
    important way of implementation if you are looking for more flexibility while
    handling unusual keys/values. Just do it yourself. The final approach to key-value
    coding is to handle the implementation yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Create a getter and setter method, and inside of each method properly returning
    and setting the values on a dictionary owned by the object might be the easiest
    way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check out this approach in the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In our sample code, we used `NSDictionary` for the value''s internal storage;
    however, you can use your own storage solutions, or even Cocoa key-value storage
    structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSMutableDictionary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSMapTable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFMutableDictionaryRef`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of doing your own implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple collections can be exposed by a single object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any data type supported by the respective collection can be used while getting
    and setting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among all methods of implementation, this is the most flexible one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of doing your own implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It simply does not work for random objects, only the target class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You're unable to use other `NSKeyValueCoding` concepts in addition to this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value observing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key-value observing—also known as KVO—is a way to get notified about changes
    in a variable, but only if it was changed using KVC. We can highlight two things
    out of this:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you need KVC in order to do KVO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, if a variable is changed directly without key-value coding by its
    default setter and getter methods, you won't get notified at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every variable in any key path can be observed by an object. It's useful if
    you consider using KVO. As KVO is built on top of KVC, you need KVC to implement
    KVO, and using KVO should be one of the reasons why you need to use KVC.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing key-value observing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is relatively easy to implement KVO, as we shall see in the following code
    example. On the specified key path, you add an observer. After this, you can create
    a method that will be called anytime the observer sees modifications in the variables
    on its key path.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object can be registered as an observer by using the following method from
    `NSKeyCodingProtocol: addObserver:forKeyPath:options:context:`. Anytime a modification
    is performed, the following method is called `observeValueForKeyPath:ofObject:change:context:`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, go to your class and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw earlier, this method is called when any modification is performed.
    However, the protocol is even more powerful than this; it gives you the possibility
    to be notified about a change before it occurs and also after it''s done, by using
    the respective methods: `willChangeValueForKey` and `didChangeValueForKey`. You
    might consider these methods if you need time-specific notifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the following code where we register an object as an observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you look carefully, you will notice that we've used the options `NSKeyValueObservingOptionNew`
    and `NSKeyValueObservingOptionOld`. Both are used if we want to know the old and
    new values. These values will be stored in our dictionary of changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, let''s assume that development stages are represented by levels,
    `NSInteger` values from *0* to *10*, and at every modification, we need to inform
    our progress. In this case, we will create two simple methods to do it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The two preceding methods are now complete; one will inform no progress if the
    development stage doesn't change—we will consider that it's impossible to decrease,
    in our scenario, and the other one will inform the real progress by levels if
    the development stage changes. However, now, we want to call the properly methods
    after comparing the values. Remember we used the options `NSKeyValueObservingOptionNew`
    and `NSKeyValueObservingOptionOld`; they will save the old and the new values
    after a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The old and new values will be handled inside the method that is called when
    the observer notifies a modification, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we make sure that if the observed key is the one we are
    actually looking for, just to be really sure—in our case, the key is `developmentStage`.
    Then, we store the old and the new values in order to compare them. If there are
    positive changes, inform the progress, if not, call the other method to inform
    about the bad news.
  prefs: []
  type: TYPE_NORMAL
- en: This is a real handy tool, even more if it is used cleverly as it is really
    powerful since it allows us to observe or watch a KVC key path on an object and
    to be notified when the value of the object changes, which can be useful in some
    programming contexts. Having control even on the change of your properties is
    a really powerful feature, and I'm sure you will find great cases to use in your
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must be careful while overriding KVC methods implementation as the default
    implementation caches Objective-C runtime information in order to be more effective
    and less erroneous, and unnecessary overriding implementations can affect the
    performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have taken a deep dive into key-value coding and other details such
    as various implementation methods, their advantages and disadvantages, and also
    key-value observing—a mechanism built on top of key-value coding.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw some working code for key-value coding and key-value observing with
    some explanation on why we prefer to use key-value coding over other similar methods
    such as using a dot operator to access properties.
  prefs: []
  type: TYPE_NORMAL
- en: With this, I hope all these will help to give you an understanding of key-value
    coding and key-value observing. So with this, let's move on to the next chapter
    where we will wade into the brand new language by Apple called Swift.
  prefs: []
  type: TYPE_NORMAL
