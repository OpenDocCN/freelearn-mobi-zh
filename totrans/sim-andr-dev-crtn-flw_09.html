<html><head></head><body>
		<div><h1 id="_idParaDest-78"><em class="italic"><a id="_idTextAnchor083"/>Chapter 7</em>: Testing Kotlin Flows</h1>
			<p>In the previous chapter, we focused on understanding Kotlin Flow cancellation, learning how to make Flows cancellable, and handling the cancellation. We also learned about retrying tasks with Flows and handling completion and exceptions in your Flows. </p>
			<p>Adding tests for the Kotlin Flows in your code is an important part of app development. Tests will ensure that the Flows we add to our projects are free of bugs or errors and that they will work as we intended. They can make developing apps easier and help you refactor and maintain your code confidently.</p>
			<p>In this chapter, we will learn how to test Kotlin Flows in Android. First, we will understand how to set up your Android project for testing Flows. We will then proceed with creating and running tests for Kotlin Flows. </p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Setting up an Android project for testing Flows</li>
				<li>Testing Kotlin Flows</li>
				<li>Testing Flows with Turbine</li>
			</ul>
			<p>By the end of this chapter, you will have learned about Kotlin Flow testing. You will be able to write and run unit and integration tests for the Flows in your Android applications.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended:</p>
			<ul>
				<li>Intel Core i5 or equivalent or higher</li>
				<li>A minimum of 4 GB of RAM </li>
				<li>4 GB of available space</li>
			</ul>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter07">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor085"/>Setting up an Android project for testing Flows</h1>
			<p>In this section, we <a id="_idIndexMarker313"/>will start by looking at how to set up our Android project for testing Kotlin Flows. Once we have done that, it will be easy for us to add unit and integration tests for the Flows in our project.</p>
			<p>To create <a id="_idIndexMarker314"/>a unit test in Android, your project must have <a id="_idIndexMarker315"/>the JUnit 4 testing library, a unit testing framework for Java. New projects created in Android Studio should already have this added in the <code>app/build</code> dependencies. If your project does not have JUnit yet, you can add it by adding the following in your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'junit:junit:4.13.2'</pre>
			<pre class="source-code">}</pre>
			<p>Adding this to your dependencies enables you to use<a id="_idIndexMarker316"/> the JUnit 4 testing framework to unit-test your code.</p>
			<p>It is also a good idea to use mock objects for your tests. Mockito<a id="_idIndexMarker317"/> is a popular Java mocking library that you can use on Android. You can also use Mockito-Kotlin to use Mockito<a id="_idIndexMarker318"/> with idiomatic Kotlin code. To add Mockito and Mockito-Kotlin to your Android tests, you can add the following in your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'org.mockito:mockito-core:4.0.0'</pre>
			<pre class="source-code">    testImplementation 'org.mockito.kotlin:mockito-</pre>
			<pre class="source-code">      kotlin:4.0.0'</pre>
			<pre class="source-code">}</pre>
			<p>This will allow you to use Mockito to create mock objects for your Android tests using Kotlin-like code. Mockito-Kotlin <a id="_idIndexMarker319"/>has a dependency <a id="_idIndexMarker320"/>to <code>mockito-core</code> and <code>mockito-kotlin</code>:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'org.mockito.kotlin:mockito-</pre>
			<pre class="source-code">      kotlin:4.0.0'</pre>
			<pre class="source-code">}</pre>
			<p>As Kotlin Flow is built on top of coroutines, you can use the <code>kotlinx-coroutines-test</code> library to help you add tests for both coroutines and Flows. This library contains utility classes to make the writing of tests easier. To add it to your project, you can add the following to your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'org.jetbrains.kotlinx:kotlinx-</pre>
			<pre class="source-code">      coroutines-test:1.6.0'</pre>
			<pre class="source-code">}</pre>
			<p>Adding this allows you to use the <code>kotlinx-coroutines-test</code> library for testing coroutines and flows in your project.</p>
			<p>In this section, we have learned about setting up our Android project to test Kotlin Flows. We will learn about testing Kotlin Flows in the next section.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor086"/>Testing Kotlin Flows</h1>
			<p>In this <a id="_idIndexMarker322"/>section, we will focus on testing Kotlin Flows. We can create unit and integration tests<a id="_idIndexMarker323"/> for classes such as <code>ViewModel</code> that use Flow in their code.</p>
			<p>To test code that collects a Flow, you can use a mock object that can return values which you can do assertion checks. For example, if your <code>ViewModel</code> listens to the Flow from a repository, you can create a custom <code>Repository</code> class that emits a Flow with a predefined set of values for easier testing.</p>
			<p>For example, say <a id="_idIndexMarker324"/>you have a <code>MovieViewModel</code> class such as the following<a id="_idIndexMarker325"/> that has a <code>fetchMovies</code> function that collects a Flow:</p>
			<pre class="source-code">class MovieViewModel(private val movieRepository:</pre>
			<pre class="source-code">  MovieRepository) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    suspend fun fetchMovies() {</pre>
			<pre class="source-code">        movieRepository.fetchMovies().collect {</pre>
			<pre class="source-code">            _movies.value = it</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <code>fetchMovies</code> function collects a Flow from <code>movieRepository.fetchMovies()</code>. You can write a test for this <code>MovieViewModel</code> by creating <code>MovieRepository</code> , which returns a specific set of values, which you will check to see whether it’s the same value that will be set to the movies <code>LiveData</code> in <code>MovieViewModel</code>. An example implementation of this looks like the following:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val list = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val expected = MutableLiveData&lt;List&lt;Movie&gt;&gt;()</pre>
			<pre class="source-code">        expectedMovies.value = list</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMoviesFlow() } doReturn</pre>
			<pre class="source-code">              flowOf(movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val dispatcher = StandardTestDispatcher()</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository, dispatcher)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies()</pre>
			<pre class="source-code">            dispatcher.scheduler.advanceUntilIdle()</pre>
			<pre class="source-code">            assertEquals(expectedMovies.value,</pre>
			<pre class="source-code">              movieViewModel.movies.value)</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this<a id="_idIndexMarker326"/> example, <code>fetchMoviesFlow</code> of <code>MovieRepository</code> returns a list <a id="_idIndexMarker327"/>of movies that has only one item. After calling <code>movieViewModel.fetchMovies()</code>, the test checks whether the value in the <code>MovieViewModel.movies</code> <code>LiveData</code> was set to this list.</p>
			<p>You can also test a Flow by collecting it to another object. You can do that by converting the Flow to a list with <code>toList()</code> or to a set with <code>toSet()</code>, getting the first item with first, taking items with <code>take()</code>, and other terminal operators. Then, you can check the values returned with the expected values. </p>
			<p>For <a id="_idIndexMarker328"/>example, say <a id="_idIndexMarker329"/>you have <code>MovieViewModel</code>, which has a function that returns a Flow, such as the following class:  </p>
			<pre class="source-code">class MovieViewModel(private val movieRepository:</pre>
			<pre class="source-code">  MovieRepository) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchFavoriteMovies(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <code>fetchFavoriteMovies</code> function returns a Flow of <code>List&lt;Movie&gt;</code>. You can write a test for this function by converting <code>Flow&lt;List&lt;Movie&gt;&gt;</code> into a list, as shown in the following example: </p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchFavoriteMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val expectedList = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchFavoriteMovies() } doReturn</pre>
			<pre class="source-code">              flowOf(expectedList)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            assertEquals(expectedList,</pre>
			<pre class="source-code">             movieViewModel.fetchFavoriteMovies().toList())</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this<a id="_idIndexMarker330"/> example, you converted the Flow of the list of movies from <code>movieViewModel.fetchFavoriteMovies()</code> to a list of movies and compared it with<a id="_idIndexMarker331"/> the expected list.</p>
			<p>To test error-handling in Flow, you can mock your test objects to throw an exception. You can then check the exception thrown or the code that handles it. The following example shows how you can write tests for a Flow’s failure case:</p>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMoviesFlowWithError() {</pre>
			<pre class="source-code">        val movieService: MovieService = mock {</pre>
			<pre class="source-code">            onBlocking { getMovies(anyString()) } doThrow</pre>
			<pre class="source-code">              IOException(exception)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">        val movieRepository = MovieRepository(movieService)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieRepository.fetchMoviesFlow().catch {</pre>
			<pre class="source-code">                assertEquals(exception, it.message)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this<a id="_idIndexMarker332"/> test class, every time <code>MovieService.getMovies()</code> is called, it will throw <code>IOException</code>. We then call <code>movieRepository.fetchMoviesFlow()</code> and use the <code>catch</code> operator to handle the exception. Then, we compare the exception message with the expected string.</p>
			<p>We can also <a id="_idIndexMarker333"/>test Flow retries by mocking our class to return a specific exception that would trigger a retry. For retries that still fail afterward, you can check the exception or the exception handling. To test retries that succeed, you can mock your class to either throw an exception or return a Flow that you can compare with the expected values. </p>
			<p>The following example shows how you can test a Flow that has a retry for <code>IOException</code> and any number of attempts:</p>
			<pre class="source-code">class MovieViewModelTest { </pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    fun fetchMoviesWithError() { </pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val movies = listOf(Movie(title = "Movie"))</pre>
			<pre class="source-code">        val exception = "Exception"</pre>
			<pre class="source-code">        val hasRetried = false</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock { </pre>
			<pre class="source-code">            onBlocking { fetchMoviesFlow() } doAnswer {</pre>
			<pre class="source-code">                flow {</pre>
			<pre class="source-code">                    if (hasRetried) emit(movies) else throw</pre>
			<pre class="source-code">                      IOException (exception)</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, we<a id="_idIndexMarker334"/> used a <code>hasRetried</code> variable to determine whether to return a<a id="_idIndexMarker335"/> Flow of movies or to throw an exception that can trigger a retry. It is <code>false</code> by default to allow a retry. Later in the code, we can change this value to <code>true</code> to return a Flow of movies, which we can then compare to the expected values.</p>
			<p>In this section, we learned how to create and run tests for Kotlin Flows in our Android project. We will learn about testing hot flows with Turbine in the next section.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/>Testing Flows with Turbine</h1>
			<p>In this <a id="_idIndexMarker336"/>section, we will learn how to test Flows using Turbine, which is a <a id="_idIndexMarker337"/>third-party library that we can use to test flows in our project.</p>
			<p>Hot flows <a id="_idIndexMarker338"/>such as <code>SharedFlow</code> and <code>StateFlow</code>, as you learned in the previous chapter, emit values <a id="_idIndexMarker339"/>even if there are no listeners. They also keep emitting values and do not complete. Testing them is a bit more complicated. You won’t be able to convert these flows to a list and then compare it to the expected values.</p>
			<p>To test hot flows and <a id="_idIndexMarker340"/>make testing other Flows easier, you can use a library from Cash App called <a id="_idIndexMarker341"/>Turbine (<a href="https://github.com/cashapp/turbine">https://github.com/cashapp/turbine</a>). Turbine is a <a id="_idIndexMarker342"/>small testing library for Kotlin Flow that you can use in Android.</p>
			<p>You can use the Turbine testing library in your Android project by adding the following to your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'app.cash.turbine:turbine:0.8.0'</pre>
			<pre class="source-code">}</pre>
			<p>Adding this will allow you to use the Turbine testing library in your project to test the Flow in your code.</p>
			<p>Turbine has a <code>test</code> extension function on Flow. It has a suspending validation block, where you can consume items from the Flow one by one and compare them with the expected values. It will then cancel the Flow at the end of the validation block. </p>
			<p>An example of using Turbine and the <code>test</code> extension function to test Flows is shown in the following code block:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val expectedList = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMovies() } doReturn</pre>
			<pre class="source-code">              flowOf(expectedList)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies().test {</pre>
			<pre class="source-code">               assertEquals(movie1, awaitItem())</pre>
			<pre class="source-code">               assertEquals(movie2, awaitItem())</pre>
			<pre class="source-code">               awaitComplete()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <a id="_idIndexMarker343"/>test used an <code>awaitItem()</code> function to get<a id="_idIndexMarker344"/> the next item emitted by the Flow and compared it with the expected items. Then, it used an <code>awaitComplete()</code> function to assert that the Flow had completed.</p>
			<p>To test for exceptions thrown by the Flow, you can use the <code>awaitError()</code> function that returns <code>Throwable</code>. You can then compare this <code>Throwable</code> to the one you expected to be thrown. The following example <a id="_idIndexMarker345"/>shows<a id="_idIndexMarker346"/> how you can use this to test your Flow:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMoviesError() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val exception = "Test Exception"</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMovies() } doAnswer</pre>
			<pre class="source-code">                flow {</pre>
			<pre class="source-code">                    throw RuntimeException(exception)</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }//mock</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies().test {</pre>
			<pre class="source-code">                assertEquals(exception,</pre>
			<pre class="source-code">                  awaitError().message)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we used the <code>awaitError()</code> function to receive the exception and compare its message with the expected exception.</p>
			<p>To test hot flows, you have to emit values inside the <code>test</code> lambda. You can also use the <code>cancelAndConsumeRemainingEvents()</code> function or the  <code>cancelAndIgnoreRemainingEvents()</code> function to cancel any remaining events from the Flow.</p>
			<p>The following shows an example of using the <code>cancelAndIgnoreRemainingEvents()</code> function <a id="_idIndexMarker347"/>after checking the first item from<a id="_idIndexMarker348"/> the Flow:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val expectedList = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMovies() } doReturn</pre>
			<pre class="source-code">              flowOf(expectedList)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies().test {</pre>
			<pre class="source-code">               assertEquals(movie1, awaitItem())</pre>
			<pre class="source-code">               cancelAndIgnoreRemainingEvents()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the test <a id="_idIndexMarker349"/>will check the first item from the Flow, ignore any <a id="_idIndexMarker350"/>remaining items, and cancel the Flow.</p>
			<p>In this section, you have learned how to test Flows with Turbine. Let’s try what we have learned so far by adding some tests to Flows in an Android project.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor088"/>Exercise 7.01 – Adding tests to Flows in an Android app</h1>
			<p>For this exercise, you<a id="_idIndexMarker351"/> will be continuing the movie app you worked on in <em class="italic">Exercise 6.01 – Handling Flow exception in an Android app</em>. This application displays the movies that are currently playing in movie theatres. You will be adding tests for the Kotlin Flows in the project by following these steps:</p>
			<ol>
				<li>Open in Android Studio the movie app you worked on in <em class="italic">Exercise 6.01 – Handling Flow exception in an Android app</em>.</li>
				<li>Go to the <code>MovieViewModelTest</code> class. Run the test class, and the <code>fetchMovies()</code> test function will fail. That is because we changed the implementation to use Flow in the previous chapter.</li>
				<li>Remove the content of the <code>fetchMovies()</code> test function and replace it with the following content:<pre>@Test
fun fetchMovies() {
    val dispatcher = StandardTestDispatcher()
 
    val movies = listOf(Movie(title = "Movie"))
    val expectedMovies =
      MutableLiveData&lt;List&lt;Movie&gt;&gt;()
    expectedMovies.postValue(movies)
 
    val movieRepository: MovieRepository = mock {
        onBlocking { fetchMoviesFlow() } doReturn
          flowOf(movies)
    }
 
    val movieViewModel =
      MovieViewModel(movieRepository, dispatcher)
}</pre></li>
			</ol>
			<p>With <a id="_idIndexMarker352"/>this code, we will be mocking <code>MovieRepository</code> to return a Flow of a list of movies, <code>movies</code>, which contains a single movie.</p>
			<ol>
				<li value="4">At the end of the <code>fetchMovies()</code> function, add the following code to test the <code>fetchMovies()</code> function of <code>MovieViewModel</code>:<pre>@Test
fun fetchMovies() {
    ...
 
    runTest {
        movieViewModel.fetchMovies()
        dispatcher.scheduler.advanceUntilIdle()
        assertEquals(expectedMovies.value,
          movieViewModel.movies.value)
    }
}</pre></li>
			</ol>
			<p>This will call the <code>fetchMovies()</code> function from <code>movieViewModel</code>. We will then compare the returned <code>movieViewModel.movies</code> to see whether they are the same as the expected <code>movies</code> list (with a single Movie item).</p>
			<ol>
				<li value="5">In<a id="_idIndexMarker353"/> the <code>loading()</code> test function, replace the assertions with the following:<pre>assertTrue(movieViewModel.loading.value)
dispatcher.scheduler.advanceUntilIdle()
assertFalse(movieViewModel.loading.value)</pre></li>
			</ol>
			<p>The <code>loading</code> variable is no longer nullable, so this simplifies the assertion statements.</p>
			<ol>
				<li value="6">Run the <code>MovieViewModelTest</code> class again. It should successfully run, and all the tests will pass.</li>
				<li>Open the <code>MovieRepositoryTest</code> class. We will be adding tests for the <code>fetchMoviesFlow()</code> function of <code>MovieRepository</code>. First, add the following function to test the successful case of the function:<pre>@Test
fun fetchMoviesFlow() {
    val movies = listOf(Movie(id = 3), Movie(id = 4))
    val response = MoviesResponse(1, movies)
 
    val movieService: MovieService = mock {
        onBlocking { getMovies(anyString()) } doReturn
          response
    }
    val movieRepository =
      MovieRepository(movieService)
 
    runTest {
        movieRepository.fetchMoviesFlow().collect {
            assertEquals(movies, it)
        }
    }
}</pre></li>
			</ol>
			<p>This will mock <code>MovieRepository</code> to always return the list of movies that we will later compare with the movies from the <code>fetchMoviesFlow()</code> function.</p>
			<ol>
				<li value="8">Add the<a id="_idIndexMarker354"/> following function to add a test for the case when the <code>fetchMoviesFlow()</code> function throws an exception:<pre>@Test
fun fetchMoviesFlowWithError() {
    val exception = "Test Exception"
 
    val movieService: MovieService = mock {
        onBlocking { getMovies(anyString()) } doThrow
          RuntimeException(exception)
    }
    val movieRepository =
      MovieRepository(movieService)
 
    runTest {
        movieRepository.fetchMoviesFlow().catch {
            assertEquals(exception, it.message)
        }
    }
}</pre></li>
			</ol>
			<p>This test will use a fake <code>MovieRepository</code> that will always throw an error when calling <code>fetchMoviesFlow</code>. We will then test whether the exception thrown will be the same as the one that we expect.</p>
			<ol>
				<li value="9">Run<a id="_idIndexMarker355"/> the <code>MovieRepositoryTest</code> class. All the tests in <code>MovieRepository Test</code> should run and pass without an error.</li>
				<li>Now, we will use the Turbine testing library to test the Flow from the <code>fetchMoviesFlow()</code> function of <code>MovieRepository</code>. Add the following in the <code>app/build.gradle</code> dependencies:<pre>testImplementation 'app.cash.turbine:turbine:0.8.0'</pre></li>
			</ol>
			<p>This will allow us to use the Turbine testing library to create unit tests for Flows in our Android project.</p>
			<ol>
				<li value="11">Add a new test function to test the success case of the <code>fetchMoviesFlow()</code> function by adding the following:<pre>@Test
fun fetchMoviesFlowTurbine() {
    val movies = listOf(Movie(id = 3), Movie(id = 4))
    val response = MoviesResponse(1, movies)
 
    val movieService: MovieService = mock {
        onBlocking { getMovies(anyString()) } doReturn
          response
    }
    val movieRepository =
      MovieRepository(movieService)
 
    runTest {
        movieRepository.fetchMoviesFlow().test {
            assertEquals(movies, awaitItem())
            awaitComplete()
        }
    }
}</pre></li>
			</ol>
			<p>With this, we <a id="_idIndexMarker356"/>will be mocking <code>MovieRepository</code> to return a list of movies. We will later compare that with the list from <code>movieRepository.fetchMoviesFlow()</code> using <code>awaitItem()</code>. The <code>awaitComplete()</code> function will then check that the Flow has terminated.</p>
			<ol>
				<li value="12">Add another function to test using Turbine in the case when <code>fetchMoviesFlow</code> throws an exception by adding the following:<pre>@Test
fun fetchMoviesFlowWithErrorTurbine() {
    val exception = "Test Exception"
 
    val movieService: MovieService = mock {
        onBlocking { getMovies(anyString()) } doThrow
          RuntimeException(exception)
    }
    val movieRepository =
      MovieRepository(movieService)
 
    runTest {
        movieRepository.fetchMoviesFlow().test {
            assertEquals(exception,
              awaitError().message)
        }
    }
}</pre></li>
			</ol>
			<p>This will<a id="_idIndexMarker357"/> use a <code>MovieRepository</code> mock class that will throw <code>RuntimeException</code> when calling <code>fetchMoviesFlow()</code>. We will then test that the exception message is the same one that was fetched, using the <code>awaitError()</code> call.</p>
			<ol>
				<li value="13">Run the <code>MovieRepositoryTest</code> class again. All the tests in <code>MovieRepository Test</code> should run and pass without an error.</li>
			</ol>
			<p>In this exercise, we have worked on an Android project that uses Kotlin Flow, and we have created tests for these Flows.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor089"/>Summary</h1>
			<p>This chapter focused on testing Kotlin Flows in our Android project. We started by setting up the project for adding tests for the Flows. The coroutines testing library (<strong class="bold">kotlinx-coroutines-test</strong>) can help you in creating tests for coroutines and Flows.</p>
			<p>We learned how to add tests for the Flows in your Android application. You can use a mock class that returns a Flow of values and then compare it with the returned values. You can also convert a Flow into <code>List</code> or <code>Set</code>, or take values from the Flow; you can then compare them with the expected values.</p>
			<p>Then, we learned about testing hot Flows with Turbine, a third-party testing library for testing Kotlin Flows. Turbine has a <code>test</code> extension on Flow where you can consume and compare values one by one.</p>
			<p>Finally, we worked on an exercise where we created tests for the Kotlin Flows in an existing Android project. We also used the Turbine testing library to make the writing of tests for Flows easier.</p>
			<p>Throughout the book, we have gained knowledge and skills about asynchronous programming in Android. We learned how to use Kotlin coroutines and Flow to simplify asynchronous programming in our Android projects. </p>
			<p>Everything in Android is always evolving. There are also more advanced topics about coroutines and Flow that we have not covered. It is good to keep yourself up to date with the latest updates about Android, Kotlin coroutines, and Kotlin Flow. You can find out the latest about coroutines on Android at <a href="https://developer.android.com/kotlin/coroutines">https://developer.android.com/kotlin/coroutines</a> and the latest about Kotlin Flow on Android at <a href="https://developer.android.com/kotlin/flow">https://developer.android.com/kotlin/flow</a>.</p>
		</div>
	</body></html>