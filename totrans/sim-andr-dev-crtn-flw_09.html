<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-78"><em class="italic"><a id="_idTextAnchor083"/>Chapter 7</em>: Testing Kotlin Flows</h1>
			<p>In the previous chapter, we focused on understanding Kotlin Flow cancellation, learning how to make Flows cancellable, and handling the cancellation. We also learned about retrying tasks with Flows and handling completion and exceptions in your Flows. </p>
			<p>Adding tests for the Kotlin Flows in your code is an important part of app development. Tests will ensure that the Flows we add to our projects are free of bugs or errors and that they will work as we intended. They can make developing apps easier and help you refactor and maintain your code confidently.</p>
			<p>In this chapter, we will learn how to test Kotlin Flows in Android. First, we will understand how to set up your Android project for testing Flows. We will then proceed with creating and running tests for Kotlin Flows. </p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Setting up an Android project for testing Flows</li>
				<li>Testing Kotlin Flows</li>
				<li>Testing Flows with Turbine</li>
			</ul>
			<p>By the end of this chapter, you will have learned about Kotlin Flow testing. You will be able to write and run unit and integration tests for the Flows in your Android applications.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended:</p>
			<ul>
				<li>Intel Core i5 or equivalent or higher</li>
				<li>A minimum of 4 GB of RAM </li>
				<li>4 GB of available space</li>
			</ul>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter07">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor085"/>Setting up an Android project for testing Flows</h1>
			<p>In this section, we <a id="_idIndexMarker313"/>will start by looking at how to set up our Android project for testing Kotlin Flows. Once we have done that, it will be easy for us to add unit and integration tests for the Flows in our project.</p>
			<p>To create <a id="_idIndexMarker314"/>a unit test in Android, your project must have <a id="_idIndexMarker315"/>the JUnit 4 testing library, a unit testing framework for Java. New projects created in Android Studio should already have this added in the <strong class="source-inline">app/build</strong> dependencies. If your project does not have JUnit yet, you can add it by adding the following in your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'junit:junit:4.13.2'</pre>
			<pre class="source-code">}</pre>
			<p>Adding this to your dependencies enables you to use<a id="_idIndexMarker316"/> the JUnit 4 testing framework to unit-test your code.</p>
			<p>It is also a good idea to use mock objects for your tests. Mockito<a id="_idIndexMarker317"/> is a popular Java mocking library that you can use on Android. You can also use Mockito-Kotlin to use Mockito<a id="_idIndexMarker318"/> with idiomatic Kotlin code. To add Mockito and Mockito-Kotlin to your Android tests, you can add the following in your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'org.mockito:mockito-core:4.0.0'</pre>
			<pre class="source-code">    testImplementation 'org.mockito.kotlin:mockito-</pre>
			<pre class="source-code">      kotlin:4.0.0'</pre>
			<pre class="source-code">}</pre>
			<p>This will allow you to use Mockito to create mock objects for your Android tests using Kotlin-like code. Mockito-Kotlin <a id="_idIndexMarker319"/>has a dependency <a id="_idIndexMarker320"/>to <strong class="bold">mockito-core</strong> so you can simply use the<a id="_idIndexMarker321"/> following to import both <strong class="source-inline">mockito-core</strong> and <strong class="source-inline">mockito-kotlin</strong>:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'org.mockito.kotlin:mockito-</pre>
			<pre class="source-code">      kotlin:4.0.0'</pre>
			<pre class="source-code">}</pre>
			<p>As Kotlin Flow is built on top of coroutines, you can use the <strong class="source-inline">kotlinx-coroutines-test</strong> library to help you add tests for both coroutines and Flows. This library contains utility classes to make the writing of tests easier. To add it to your project, you can add the following to your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'org.jetbrains.kotlinx:kotlinx-</pre>
			<pre class="source-code">      coroutines-test:1.6.0'</pre>
			<pre class="source-code">}</pre>
			<p>Adding this allows you to use the <strong class="source-inline">kotlinx-coroutines-test</strong> library for testing coroutines and flows in your project.</p>
			<p>In this section, we have learned about setting up our Android project to test Kotlin Flows. We will learn about testing Kotlin Flows in the next section.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor086"/>Testing Kotlin Flows</h1>
			<p>In this <a id="_idIndexMarker322"/>section, we will focus on testing Kotlin Flows. We can create unit and integration tests<a id="_idIndexMarker323"/> for classes such as <strong class="source-inline">ViewModel</strong> that use Flow in their code.</p>
			<p>To test code that collects a Flow, you can use a mock object that can return values which you can do assertion checks. For example, if your <strong class="source-inline">ViewModel</strong> listens to the Flow from a repository, you can create a custom <strong class="source-inline">Repository</strong> class that emits a Flow with a predefined set of values for easier testing.</p>
			<p>For example, say <a id="_idIndexMarker324"/>you have a <strong class="source-inline">MovieViewModel</strong> class such as the following<a id="_idIndexMarker325"/> that has a <strong class="source-inline">fetchMovies</strong> function that collects a Flow:</p>
			<pre class="source-code">class MovieViewModel(private val movieRepository:</pre>
			<pre class="source-code">  MovieRepository) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    suspend fun fetchMovies() {</pre>
			<pre class="source-code">        movieRepository.fetchMovies().collect {</pre>
			<pre class="source-code">            _movies.value = it</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <strong class="source-inline">fetchMovies</strong> function collects a Flow from <strong class="source-inline">movieRepository.fetchMovies()</strong>. You can write a test for this <strong class="source-inline">MovieViewModel</strong> by creating <strong class="source-inline">MovieRepository</strong> , which returns a specific set of values, which you will check to see whether it’s the same value that will be set to the movies <strong class="source-inline">LiveData</strong> in <strong class="source-inline">MovieViewModel</strong>. An example implementation of this looks like the following:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val list = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val expected = MutableLiveData&lt;List&lt;Movie&gt;&gt;()</pre>
			<pre class="source-code">        expectedMovies.value = list</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMoviesFlow() } doReturn</pre>
			<pre class="source-code">              flowOf(movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val dispatcher = StandardTestDispatcher()</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository, dispatcher)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies()</pre>
			<pre class="source-code">            dispatcher.scheduler.advanceUntilIdle()</pre>
			<pre class="source-code">            assertEquals(expectedMovies.value,</pre>
			<pre class="source-code">              movieViewModel.movies.value)</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this<a id="_idIndexMarker326"/> example, <strong class="source-inline">fetchMoviesFlow</strong> of <strong class="source-inline">MovieRepository</strong> returns a list <a id="_idIndexMarker327"/>of movies that has only one item. After calling <strong class="source-inline">movieViewModel.fetchMovies()</strong>, the test checks whether the value in the <strong class="source-inline">MovieViewModel.movies</strong> <strong class="source-inline">LiveData</strong> was set to this list.</p>
			<p>You can also test a Flow by collecting it to another object. You can do that by converting the Flow to a list with <strong class="source-inline">toList()</strong> or to a set with <strong class="source-inline">toSet()</strong>, getting the first item with first, taking items with <strong class="source-inline">take()</strong>, and other terminal operators. Then, you can check the values returned with the expected values. </p>
			<p>For <a id="_idIndexMarker328"/>example, say <a id="_idIndexMarker329"/>you have <strong class="source-inline">MovieViewModel</strong>, which has a function that returns a Flow, such as the following class:  </p>
			<pre class="source-code">class MovieViewModel(private val movieRepository:</pre>
			<pre class="source-code">  MovieRepository) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchFavoriteMovies(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <strong class="source-inline">fetchFavoriteMovies</strong> function returns a Flow of <strong class="source-inline">List&lt;Movie&gt;</strong>. You can write a test for this function by converting <strong class="source-inline">Flow&lt;List&lt;Movie&gt;&gt;</strong> into a list, as shown in the following example: </p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchFavoriteMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val expectedList = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchFavoriteMovies() } doReturn</pre>
			<pre class="source-code">              flowOf(expectedList)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            assertEquals(expectedList,</pre>
			<pre class="source-code">             movieViewModel.fetchFavoriteMovies().toList())</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this<a id="_idIndexMarker330"/> example, you converted the Flow of the list of movies from <strong class="source-inline">movieViewModel.fetchFavoriteMovies()</strong> to a list of movies and compared it with<a id="_idIndexMarker331"/> the expected list.</p>
			<p>To test error-handling in Flow, you can mock your test objects to throw an exception. You can then check the exception thrown or the code that handles it. The following example shows how you can write tests for a Flow’s failure case:</p>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMoviesFlowWithError() {</pre>
			<pre class="source-code">        val movieService: MovieService = mock {</pre>
			<pre class="source-code">            onBlocking { getMovies(anyString()) } doThrow</pre>
			<pre class="source-code">              IOException(exception)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">        val movieRepository = MovieRepository(movieService)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieRepository.fetchMoviesFlow().catch {</pre>
			<pre class="source-code">                assertEquals(exception, it.message)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this<a id="_idIndexMarker332"/> test class, every time <strong class="source-inline">MovieService.getMovies()</strong> is called, it will throw <strong class="source-inline">IOException</strong>. We then call <strong class="source-inline">movieRepository.fetchMoviesFlow()</strong> and use the <strong class="source-inline">catch</strong> operator to handle the exception. Then, we compare the exception message with the expected string.</p>
			<p>We can also <a id="_idIndexMarker333"/>test Flow retries by mocking our class to return a specific exception that would trigger a retry. For retries that still fail afterward, you can check the exception or the exception handling. To test retries that succeed, you can mock your class to either throw an exception or return a Flow that you can compare with the expected values. </p>
			<p>The following example shows how you can test a Flow that has a retry for <strong class="source-inline">IOException</strong> and any number of attempts:</p>
			<pre class="source-code">class MovieViewModelTest { </pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    fun fetchMoviesWithError() { </pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val movies = listOf(Movie(title = "Movie"))</pre>
			<pre class="source-code">        val exception = "Exception"</pre>
			<pre class="source-code">        val hasRetried = false</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock { </pre>
			<pre class="source-code">            onBlocking { fetchMoviesFlow() } doAnswer {</pre>
			<pre class="source-code">                flow {</pre>
			<pre class="source-code">                    if (hasRetried) emit(movies) else throw</pre>
			<pre class="source-code">                      IOException (exception)</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, we<a id="_idIndexMarker334"/> used a <strong class="source-inline">hasRetried</strong> variable to determine whether to return a<a id="_idIndexMarker335"/> Flow of movies or to throw an exception that can trigger a retry. It is <strong class="source-inline">false</strong> by default to allow a retry. Later in the code, we can change this value to <strong class="source-inline">true</strong> to return a Flow of movies, which we can then compare to the expected values.</p>
			<p>In this section, we learned how to create and run tests for Kotlin Flows in our Android project. We will learn about testing hot flows with Turbine in the next section.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/>Testing Flows with Turbine</h1>
			<p>In this <a id="_idIndexMarker336"/>section, we will learn how to test Flows using Turbine, which is a <a id="_idIndexMarker337"/>third-party library that we can use to test flows in our project.</p>
			<p>Hot flows <a id="_idIndexMarker338"/>such as <strong class="source-inline">SharedFlow</strong> and <strong class="source-inline">StateFlow</strong>, as you learned in the previous chapter, emit values <a id="_idIndexMarker339"/>even if there are no listeners. They also keep emitting values and do not complete. Testing them is a bit more complicated. You won’t be able to convert these flows to a list and then compare it to the expected values.</p>
			<p>To test hot flows and <a id="_idIndexMarker340"/>make testing other Flows easier, you can use a library from Cash App called <a id="_idIndexMarker341"/>Turbine (<a href="https://github.com/cashapp/turbine">https://github.com/cashapp/turbine</a>). Turbine is a <a id="_idIndexMarker342"/>small testing library for Kotlin Flow that you can use in Android.</p>
			<p>You can use the Turbine testing library in your Android project by adding the following to your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    testImplementation 'app.cash.turbine:turbine:0.8.0'</pre>
			<pre class="source-code">}</pre>
			<p>Adding this will allow you to use the Turbine testing library in your project to test the Flow in your code.</p>
			<p>Turbine has a <strong class="source-inline">test</strong> extension function on Flow. It has a suspending validation block, where you can consume items from the Flow one by one and compare them with the expected values. It will then cancel the Flow at the end of the validation block. </p>
			<p>An example of using Turbine and the <strong class="source-inline">test</strong> extension function to test Flows is shown in the following code block:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val expectedList = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMovies() } doReturn</pre>
			<pre class="source-code">              flowOf(expectedList)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies().test {</pre>
			<pre class="source-code">               assertEquals(movie1, awaitItem())</pre>
			<pre class="source-code">               assertEquals(movie2, awaitItem())</pre>
			<pre class="source-code">               awaitComplete()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <a id="_idIndexMarker343"/>test used an <strong class="source-inline">awaitItem()</strong> function to get<a id="_idIndexMarker344"/> the next item emitted by the Flow and compared it with the expected items. Then, it used an <strong class="source-inline">awaitComplete()</strong> function to assert that the Flow had completed.</p>
			<p>To test for exceptions thrown by the Flow, you can use the <strong class="source-inline">awaitError()</strong> function that returns <strong class="source-inline">Throwable</strong>. You can then compare this <strong class="source-inline">Throwable</strong> to the one you expected to be thrown. The following example <a id="_idIndexMarker345"/>shows<a id="_idIndexMarker346"/> how you can use this to test your Flow:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMoviesError() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val exception = "Test Exception"</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMovies() } doAnswer</pre>
			<pre class="source-code">                flow {</pre>
			<pre class="source-code">                    throw RuntimeException(exception)</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }//mock</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies().test {</pre>
			<pre class="source-code">                assertEquals(exception,</pre>
			<pre class="source-code">                  awaitError().message)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we used the <strong class="source-inline">awaitError()</strong> function to receive the exception and compare its message with the expected exception.</p>
			<p>To test hot flows, you have to emit values inside the <strong class="source-inline">test</strong> lambda. You can also use the <strong class="source-inline">cancelAndConsumeRemainingEvents()</strong> function or the  <strong class="source-inline">cancelAndIgnoreRemainingEvents()</strong> function to cancel any remaining events from the Flow.</p>
			<p>The following shows an example of using the <strong class="source-inline">cancelAndIgnoreRemainingEvents()</strong> function <a id="_idIndexMarker347"/>after checking the first item from<a id="_idIndexMarker348"/> the Flow:</p>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val expectedList = listOf(movie1, movie2)</pre>
			<pre class="source-code">        val movieRepository: MovieRepository = mock {</pre>
			<pre class="source-code">            onBlocking { fetchMovies() } doReturn</pre>
			<pre class="source-code">              flowOf(expectedList)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        val movieViewModel =</pre>
			<pre class="source-code">          MovieViewModel(movieRepository)</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            movieViewModel.fetchMovies().test {</pre>
			<pre class="source-code">               assertEquals(movie1, awaitItem())</pre>
			<pre class="source-code">               cancelAndIgnoreRemainingEvents()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the test <a id="_idIndexMarker349"/>will check the first item from the Flow, ignore any <a id="_idIndexMarker350"/>remaining items, and cancel the Flow.</p>
			<p>In this section, you have learned how to test Flows with Turbine. Let’s try what we have learned so far by adding some tests to Flows in an Android project.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor088"/>Exercise 7.01 – Adding tests to Flows in an Android app</h1>
			<p>For this exercise, you<a id="_idIndexMarker351"/> will be continuing the movie app you worked on in <em class="italic">Exercise 6.01 – Handling Flow exception in an Android app</em>. This application displays the movies that are currently playing in movie theatres. You will be adding tests for the Kotlin Flows in the project by following these steps:</p>
			<ol>
				<li>Open in Android Studio the movie app you worked on in <em class="italic">Exercise 6.01 – Handling Flow exception in an Android app</em>.</li>
				<li>Go to the <strong class="source-inline">MovieViewModelTest</strong> class. Run the test class, and the <strong class="source-inline">fetchMovies()</strong> test function will fail. That is because we changed the implementation to use Flow in the previous chapter.</li>
				<li>Remove the content of the <strong class="source-inline">fetchMovies()</strong> test function and replace it with the following content:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    val dispatcher = StandardTestDispatcher()</p><p class="source-code"> </p><p class="source-code">    val movies = listOf(Movie(title = "Movie"))</p><p class="source-code">    val expectedMovies =</p><p class="source-code">      MutableLiveData&lt;List&lt;Movie&gt;&gt;()</p><p class="source-code">    expectedMovies.postValue(movies)</p><p class="source-code"> </p><p class="source-code">    val movieRepository: MovieRepository = mock {</p><p class="source-code">        onBlocking { fetchMoviesFlow() } doReturn</p><p class="source-code">          flowOf(movies)</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    val movieViewModel =</p><p class="source-code">      MovieViewModel(movieRepository, dispatcher)</p><p class="source-code">}</p></li>
			</ol>
			<p>With <a id="_idIndexMarker352"/>this code, we will be mocking <strong class="source-inline">MovieRepository</strong> to return a Flow of a list of movies, <strong class="source-inline">movies</strong>, which contains a single movie.</p>
			<ol>
				<li value="4">At the end of the <strong class="source-inline">fetchMovies()</strong> function, add the following code to test the <strong class="source-inline">fetchMovies()</strong> function of <strong class="source-inline">MovieViewModel</strong>:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    ...</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieViewModel.fetchMovies()</p><p class="source-code">        dispatcher.scheduler.advanceUntilIdle()</p><p class="source-code">        assertEquals(expectedMovies.value,</p><p class="source-code">          movieViewModel.movies.value)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will call the <strong class="source-inline">fetchMovies()</strong> function from <strong class="source-inline">movieViewModel</strong>. We will then compare the returned <strong class="source-inline">movieViewModel.movies</strong> to see whether they are the same as the expected <strong class="source-inline">movies</strong> list (with a single Movie item).</p>
			<ol>
				<li value="5">In<a id="_idIndexMarker353"/> the <strong class="source-inline">loading()</strong> test function, replace the assertions with the following:<p class="source-code">assertTrue(movieViewModel.loading.value)</p><p class="source-code">dispatcher.scheduler.advanceUntilIdle()</p><p class="source-code">assertFalse(movieViewModel.loading.value)</p></li>
			</ol>
			<p>The <strong class="source-inline">loading</strong> variable is no longer nullable, so this simplifies the assertion statements.</p>
			<ol>
				<li value="6">Run the <strong class="source-inline">MovieViewModelTest</strong> class again. It should successfully run, and all the tests will pass.</li>
				<li>Open the <strong class="source-inline">MovieRepositoryTest</strong> class. We will be adding tests for the <strong class="source-inline">fetchMoviesFlow()</strong> function of <strong class="source-inline">MovieRepository</strong>. First, add the following function to test the successful case of the function:<p class="source-code">@Test</p><p class="source-code">fun fetchMoviesFlow() {</p><p class="source-code">    val movies = listOf(Movie(id = 3), Movie(id = 4))</p><p class="source-code">    val response = MoviesResponse(1, movies)</p><p class="source-code"> </p><p class="source-code">    val movieService: MovieService = mock {</p><p class="source-code">        onBlocking { getMovies(anyString()) } doReturn</p><p class="source-code">          response</p><p class="source-code">    }</p><p class="source-code">    val movieRepository =</p><p class="source-code">      MovieRepository(movieService)</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieRepository.fetchMoviesFlow().collect {</p><p class="source-code">            assertEquals(movies, it)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will mock <strong class="source-inline">MovieRepository</strong> to always return the list of movies that we will later compare with the movies from the <strong class="source-inline">fetchMoviesFlow()</strong> function.</p>
			<ol>
				<li value="8">Add the<a id="_idIndexMarker354"/> following function to add a test for the case when the <strong class="source-inline">fetchMoviesFlow()</strong> function throws an exception:<p class="source-code">@Test</p><p class="source-code">fun fetchMoviesFlowWithError() {</p><p class="source-code">    val exception = "Test Exception"</p><p class="source-code"> </p><p class="source-code">    val movieService: MovieService = mock {</p><p class="source-code">        onBlocking { getMovies(anyString()) } doThrow</p><p class="source-code">          RuntimeException(exception)</p><p class="source-code">    }</p><p class="source-code">    val movieRepository =</p><p class="source-code">      MovieRepository(movieService)</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieRepository.fetchMoviesFlow().catch {</p><p class="source-code">            assertEquals(exception, it.message)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This test will use a fake <strong class="source-inline">MovieRepository</strong> that will always throw an error when calling <strong class="source-inline">fetchMoviesFlow</strong>. We will then test whether the exception thrown will be the same as the one that we expect.</p>
			<ol>
				<li value="9">Run<a id="_idIndexMarker355"/> the <strong class="source-inline">MovieRepositoryTest</strong> class. All the tests in <strong class="source-inline">MovieRepository Test</strong> should run and pass without an error.</li>
				<li>Now, we will use the Turbine testing library to test the Flow from the <strong class="source-inline">fetchMoviesFlow()</strong> function of <strong class="source-inline">MovieRepository</strong>. Add the following in the <strong class="source-inline">app/build.gradle</strong> dependencies:<p class="source-code">testImplementation 'app.cash.turbine:turbine:0.8.0'</p></li>
			</ol>
			<p>This will allow us to use the Turbine testing library to create unit tests for Flows in our Android project.</p>
			<ol>
				<li value="11">Add a new test function to test the success case of the <strong class="source-inline">fetchMoviesFlow()</strong> function by adding the following:<p class="source-code">@Test</p><p class="source-code">fun fetchMoviesFlowTurbine() {</p><p class="source-code">    val movies = listOf(Movie(id = 3), Movie(id = 4))</p><p class="source-code">    val response = MoviesResponse(1, movies)</p><p class="source-code"> </p><p class="source-code">    val movieService: MovieService = mock {</p><p class="source-code">        onBlocking { getMovies(anyString()) } doReturn</p><p class="source-code">          response</p><p class="source-code">    }</p><p class="source-code">    val movieRepository =</p><p class="source-code">      MovieRepository(movieService)</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieRepository.fetchMoviesFlow().test {</p><p class="source-code">            assertEquals(movies, awaitItem())</p><p class="source-code">            awaitComplete()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>With this, we <a id="_idIndexMarker356"/>will be mocking <strong class="source-inline">MovieRepository</strong> to return a list of movies. We will later compare that with the list from <strong class="source-inline">movieRepository.fetchMoviesFlow()</strong> using <strong class="source-inline">awaitItem()</strong>. The <strong class="source-inline">awaitComplete()</strong> function will then check that the Flow has terminated.</p>
			<ol>
				<li value="12">Add another function to test using Turbine in the case when <strong class="source-inline">fetchMoviesFlow</strong> throws an exception by adding the following:<p class="source-code">@Test</p><p class="source-code">fun fetchMoviesFlowWithErrorTurbine() {</p><p class="source-code">    val exception = "Test Exception"</p><p class="source-code"> </p><p class="source-code">    val movieService: MovieService = mock {</p><p class="source-code">        onBlocking { getMovies(anyString()) } doThrow</p><p class="source-code">          RuntimeException(exception)</p><p class="source-code">    }</p><p class="source-code">    val movieRepository =</p><p class="source-code">      MovieRepository(movieService)</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieRepository.fetchMoviesFlow().test {</p><p class="source-code">            assertEquals(exception,</p><p class="source-code">              awaitError().message)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will<a id="_idIndexMarker357"/> use a <strong class="source-inline">MovieRepository</strong> mock class that will throw <strong class="source-inline">RuntimeException</strong> when calling <strong class="source-inline">fetchMoviesFlow()</strong>. We will then test that the exception message is the same one that was fetched, using the <strong class="source-inline">awaitError()</strong> call.</p>
			<ol>
				<li value="13">Run the <strong class="source-inline">MovieRepositoryTest</strong> class again. All the tests in <strong class="source-inline">MovieRepository Test</strong> should run and pass without an error.</li>
			</ol>
			<p>In this exercise, we have worked on an Android project that uses Kotlin Flow, and we have created tests for these Flows.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor089"/>Summary</h1>
			<p>This chapter focused on testing Kotlin Flows in our Android project. We started by setting up the project for adding tests for the Flows. The coroutines testing library (<strong class="bold">kotlinx-coroutines-test</strong>) can help you in creating tests for coroutines and Flows.</p>
			<p>We learned how to add tests for the Flows in your Android application. You can use a mock class that returns a Flow of values and then compare it with the returned values. You can also convert a Flow into <strong class="source-inline">List</strong> or <strong class="source-inline">Set</strong>, or take values from the Flow; you can then compare them with the expected values.</p>
			<p>Then, we learned about testing hot Flows with Turbine, a third-party testing library for testing Kotlin Flows. Turbine has a <strong class="source-inline">test</strong> extension on Flow where you can consume and compare values one by one.</p>
			<p>Finally, we worked on an exercise where we created tests for the Kotlin Flows in an existing Android project. We also used the Turbine testing library to make the writing of tests for Flows easier.</p>
			<p>Throughout the book, we have gained knowledge and skills about asynchronous programming in Android. We learned how to use Kotlin coroutines and Flow to simplify asynchronous programming in our Android projects. </p>
			<p>Everything in Android is always evolving. There are also more advanced topics about coroutines and Flow that we have not covered. It is good to keep yourself up to date with the latest updates about Android, Kotlin coroutines, and Kotlin Flow. You can find out the latest about coroutines on Android at <a href="https://developer.android.com/kotlin/coroutines">https://developer.android.com/kotlin/coroutines</a> and the latest about Kotlin Flow on Android at <a href="https://developer.android.com/kotlin/flow">https://developer.android.com/kotlin/flow</a>.</p>
		</div>
	</body></html>