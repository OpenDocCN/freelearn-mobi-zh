- en: Handling File Operations in Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kotlin中处理文件操作
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Reading from files using InputReader
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用InputReader从文件中读取
- en: Reading all lines in a file using InputReader
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用InputReader从文件中读取所有行
- en: Reading line by line using InputReader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用InputReader逐行读取
- en: Reading from files using BufferedReader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用BufferedReader从文件中读取
- en: Reading all lines in a file using BufferedReader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用BufferedReader从文件中读取所有行
- en: Reading line by line using BufferedReader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用BufferedReader逐行读取
- en: Reading string and JSON over network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络读取字符串和JSON
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Kotlin I/O is used for input and output processing. Kotlin provides the `kotlin.io`
    API for working with files and streams. Some of the functions used in `kotlin.io`
    are extensions of `java.io` classes. All in all, using `kotlin.io` for reading
    from and writing to files and streams is very easy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin I/O用于输入和输出处理。Kotlin提供了`kotlin.io` API来处理文件和流。`kotlin.io`中使用的某些函数是`java.io`类的扩展。总的来说，使用`kotlin.io`从文件和流中读取和写入非常简单。
- en: Reading from files using InputReader
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用InputReader从文件中读取
- en: '`Kotlin.io` provides a nice, clean API for reading from and writing to files.
    One way of doing this is by using `InputReader`. We will see how to do that in
    this recipe.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kotlin.io`提供了一个干净、简洁的API来读取和写入文件。实现这一目标的一种方法是通过使用`InputReader`。我们将在本食谱中看到如何做到这一点。'
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。您还可以使用IntelliJ
    IDEA作为开发环境。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'There are a lot of ways to go about reading from a file, but it is very important
    to understand the motivation behind them so as to be able to use the correct one
    for our purpose:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件的方法有很多，但了解其背后的动机非常重要，这样我们才能为我们的目的选择正确的方法：
- en: 'First, we will try to get the `InputStream` of the file and use the reader
    to read the contents:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将尝试获取文件的`InputStream`，并使用读取器来读取内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code block, `lorem.txt` is simply a file that we want to read.
    The file is located in the same folder as our code source file. If we need to
    read a file located in a different folder, it looks similar to the following:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`lorem.txt`只是一个我们想要读取的文件。该文件位于我们的代码源文件相同的文件夹中。如果我们需要读取位于不同文件夹中的文件，它看起来类似于以下内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This piece of code simply takes all the text in the file and prints it on the
    console.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码只是将文件中的所有文本打印到控制台上。
- en: 'Another way of reading file contents is by directly creating a reader of the
    file, like we do in this code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件内容的另一种方法是直接创建文件的读取器，就像我们在以下代码中所做的那样：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of both preceding code blocks will simply be the text in the file
    as it is. In our case, it was as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述两个代码块输出的结果将简单地是文件中的文本，正如它本身那样。在我们的例子中，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, what if we want to read the file line by line because we want to do some
    processing on each line? In that case, we use the `useLines()` method in place
    of `use()`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想逐行读取文件，因为我们要对每一行进行处理，那该怎么办呢？在这种情况下，我们使用`useLines()`方法来代替`use()`方法。
- en: 'Check out the following example, where we get an input stream from the file
    and use the `useLines()` method to get each line one after the other:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下示例，其中我们从文件中获取输入流，并使用`useLines()`方法逐行读取：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, if we wish to use a reader directly on the file, we do this:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果我们希望直接在文件上使用读取器，我们这样做：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output, in this case, will be the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将是以下内容：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Did you note that we used the `use()` and `useLines()` methods for reading the
    file? The call to the `Closeable.use()` function will automatically close the
    input at the end of the lambda's execution. Now, we can of course use `Reader.readText()`,
    but that does not close the stream after execution. There are other methods apart
    from `use()`, such as `Reader.readText()` and so on, that can be used to read
    the contents of a stream or file. The decision to use any method is based on whether
    we want the stream to be closed on its own after execution, or we want to handle
    closing the resources, and whether or not we want to read from a stream or directly
    from the file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们使用了 `use()` 和 `useLines()` 方法来读取文件吗？对 `Closeable.use()` 函数的调用将在 lambda
    表达式执行结束时自动关闭输入。现在，我们当然可以使用 `Reader.readText()`，但这不会在执行后关闭流。除了 `use()` 之外，还有其他方法，如
    `Reader.readText()` 等，可以用来读取流或文件的内容。使用任何方法的决策取决于我们是否希望在执行后自动关闭流，或者我们希望处理关闭资源，以及我们是否希望从流中读取或直接从文件中读取。
- en: There's more…
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`BufferedReader` reads a couple of characters at a time from the input stream
    and stores them in the buffer. That’s why it is called `BufferedReader`. On the
    other hand, `InputReader` reads only one character from the input stream and the
    remaining characters still remain in the stream. There is no buffer in this case.
    This is why `BufferedReader` is fast, as it maintains a buffer, and retrieving
    data from the buffer is always quicker compared to retrieving data from disk.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader` 一次从输入流中读取几个字符并将它们存储在缓冲区中。这就是为什么它被称为 `BufferedReader`。另一方面，`InputReader`
    只读取输入流中的一个字符，其余字符仍然留在流中。在这种情况下没有缓冲区。这就是为什么 `BufferedReader` 快速，因为它维护一个缓冲区，从缓冲区中检索数据总是比从磁盘检索数据更快。'
- en: Reading all lines in a file using InputReader
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 InputReader 读取文件中的所有行
- en: We can use `InputReader` to read all the lines in a file in one go. In this
    recipe, we will learn how to do that.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `InputReader` 一次性读取文件中的所有行。在本教程中，我们将学习如何做到这一点。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此目的，这需要安装 Kotlin 编译器和 JDK。您还可以使用
    IntelliJ IDEA 作为开发环境。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to understand how to read a file using the `InputReader`
    class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来了解如何使用 `InputReader` 类读取文件：
- en: 'There are two ways to read a file, one of which is to attach an input stream
    to the file. Let''s see how we can do that and use `InputReader` to read its contents:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件有两种方式，其中一种是将输入流附加到文件上。让我们看看如何操作，并使用 `InputReader` 来读取其内容：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The other way is without getting a stream and directly reading the contents
    of the file, such as in the following example:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方式是不获取流，直接读取文件的内容，如下例所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output, in this case, is simply the contents of the file as it is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出仅仅是文件的内容，没有变化：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We used the `use()` method because it closes the stream after execution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `use()` 方法是因为它在执行后关闭了流。
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Attaching `inputStream` to a file returns the file contents as a stream of bytes.
    We can use a reader on the stream returned, or we can use the reader directly
    on the file. The `read()` method of `inputStream` reads the next byte in the stream.
    The `readText()` method returns the entire contents of the file as a string using
    UTF-8 or specified charset.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `inputStream` 附加到文件上会返回一个字节数据流。我们可以使用流返回的读取器，或者我们可以直接在文件上使用读取器。`inputStream`
    的 `read()` 方法读取流中的下一个字节。`readText()` 方法使用 UTF-8 或指定的字符集返回文件的整个内容作为字符串。
- en: This `readText()` method is not recommended for huge files. It has an internal
    limitation of 2 GB file size. In case of a huge file, we read it byte by byte
    from the stream.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `readText()` 方法不推荐用于大文件。它有一个内部限制，即文件大小为 2 GB。在处理大文件的情况下，我们从流中逐字节读取。
- en: Reading line by line using InputReader
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 InputReader 逐行读取
- en: Sometimes we need to read the contents of a file line by line and process it.
    This is easily done by reading a file line by line using the `InputReader`. Let's
    see how.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要逐行读取文件内容并进行处理。这可以通过使用 `InputReader` 逐行读取文件来实现。让我们看看如何操作。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。您还可以使用IntelliJ
    IDEA作为开发环境。
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the following steps, we will learn how to make use of the `InputReader`
    class to read the text line by line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何使用`InputReader`类逐行读取文本：
- en: 'Let''s start with attaching the `InputStream` to the file and going line by
    line on the contents, like this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将`InputStream`附加到文件并逐行读取内容开始，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each line is appended with `*` in this case. Here''s how the output looks:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，每一行都附加了`*`。以下是输出结果：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can directly attach the reader to the file and read it line by line. The
    following code does just that:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接将读取器附加到文件上，并逐行读取。以下代码正是这样做的：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `useLines()` method provides us an iterable over all the lines of the file
    or stream and then does something with each line, which is a string. We add all
    the modified strings to a list and print them out.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLines()`方法为我们提供了一个遍历文件或流中所有行的可迭代对象，并对每一行（字符串）进行一些操作。我们将所有修改后的字符串添加到一个列表中，并打印出来。'
- en: Reading from files using BufferedReader
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`BufferedReader`读取文件
- en: '`BufferedReader` stores some characters as it reads into the buffer. This makes
    the reading faster and hence more efficient. In this recipe, we will understand
    how to use the `BufferedReader` to read the contents of a file.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader`在读取时将一些字符存储在缓冲区中。这使得读取更快，因此更高效。在本例中，我们将了解如何使用`BufferedReader`读取文件内容。'
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。您还可以使用IntelliJ
    IDEA作为开发环境。
- en: How to do it…
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the mentioned steps to learn more about the working of the `BufferedReader`
    class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习更多关于`BufferedReader`类的工作原理：
- en: 'We can directly attach a `BufferedReader` to the file and read the contents
    of the whole file, as in the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接将`BufferedReader`附加到文件上，并读取整个文件的内容，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also go line by line on the contents that we need so as to be able to
    process each line individually. In the following code, we go line by line and
    add a character at the beginning and the length of the string after the character:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以逐行处理所需的内容，以便能够单独处理每一行。在以下代码中，我们逐行读取并添加一个字符到字符串的开始处和字符后的字符串长度：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code blocks, we are directly attaching the reader to the file.
    However, there are cases when we need to take a stream of data. In that scenario,
    we can get an Input Stream from the file that we want to read and then attach
    a `BufferedReader` to it.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们是直接将读取器附加到文件上的。然而，在某些情况下，我们需要获取一个数据流。在这种情况下，我们可以从要读取的文件中获取一个输入流，然后将其附加到`BufferedReader`上。
- en: 'In the following code, we are trying to read line by line from the file input
    stream using a `BufferedReader`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们尝试使用`BufferedReader`逐行从文件输入流中读取：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the output when we try to read all the contents of the file in one
    go:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们尝试一次性读取文件的全部内容时，以下是输出结果：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output resembles the file, ignoring the `charset`. We can also specify
    the desired `charset`, such as we do in the following code, if needed:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出类似于文件，忽略`charset`。如果需要，我们也可以指定所需的`charset`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we go line by line using either of the preceding examples, we get the
    following output:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用上述任一示例逐行读取时，我们得到以下输出：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Using `InputStream` helps us get a stream of the file we wish to read. We can
    also read from the file directly though. In either case, the `BufferedReader`
    keeps presaving some data that it is reading in its buffer for faster operation,
    which increases the overall efficiency of the read operation, as compared to when
    using `InputReader`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`InputStream`可以帮助我们获取要读取的文件的流。我们也可以直接从文件中读取。在两种情况下，`BufferedReader`都会预先保存一些数据到其缓冲区中，以便更快地操作，这比使用`InputReader`时提高了整体读取操作的效率。
- en: We use the `use()` and/or `useLines()` method in place of `Reader.readText()` and
    so on so that it automatically closes the input stream at the end of execution,
    which is a much cleaner and more responsible way of handling I/O of files. However,
    if needed, one can use a method such as `Reader.readText()` when they want to
    handle opening and closing the stream on their own.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `use()` 和/或 `useLines()` 方法代替 `Reader.readText()` 等方法，这样它会在执行结束时自动关闭输入流，这是一种更干净、更负责任地处理文件
    I/O 的方法。然而，如果需要，当想要自己处理流的打开和关闭时，可以使用 `Reader.readText()` 等方法。
- en: Reading all lines in a file using BufferedReader
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BufferedReader 逐行读取文件中的所有行
- en: '`BufferedReader` can be used to read contents of a file or an input stream.
    It presaves some contents it reads, so the read operation is faster. In this recipe,
    we will learn how to read all the contents of a file in one go using `BufferedReader`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader` 可以用来读取文件或输入流的内容。它预先保存了一些读取的内容，因此读取操作更快。在本菜谱中，我们将学习如何使用 `BufferedReader`
    一次性读取文件的所有内容。'
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此目的，这需要安装 Kotlin 编译器和 JDK。您还可以使用
    IntelliJ IDEA 作为开发环境。
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we will learn how to use `BufferedReader` to read all
    lines of a file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何使用 `BufferedReader` 读取文件的所有行：
- en: 'Let''s start with getting the `InputStream` of our file and use the `BufferedReader`
    on it to read the contents of the file in one go:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从获取文件的 `InputStream` 开始，并使用 `BufferedReader` 来一次性读取文件内容：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output, in this case, will be the exact same as the file, depending on
    the charset of course, if we use it. Here''s an example where we use another charset:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将与文件完全相同，当然，这取决于字符集。这里有一个使用另一个字符集的例子：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s quickly see the code example without getting the `inputStream`
    on this file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们快速查看一个不获取此文件 `inputStream` 的代码示例：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Although you might have guessed the output, here''s the output anyway:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管您可能已经猜到了输出，但这里还是提供了输出：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`BufferedReader`, as it reads, stores some characters in a buffer, hence the
    read operations are faster. We can directly attach the `BufferedReader` to the
    file or the stream and read from it.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader` 在读取时会将一些字符存储在缓冲区中，因此读取操作更快。我们可以直接将 `BufferedReader` 连接到文件或流，并从中读取。'
- en: The `use()` method ensures that the file or stream is closed after execution
    completes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`use()` 方法确保在执行完成后关闭文件或流。'
- en: Reading line by line using bufferedReader
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 bufferedReader 逐行读取
- en: In this recipe, we will understand how to use the `bufferedReader` to read the
    contents of a file line by line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何使用 `bufferedReader` 逐行读取文件内容。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此目的，这需要安装 Kotlin 编译器和 JDK。您还可以使用
    IntelliJ IDEA 作为开发环境。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the given steps, we will learn how to use `BufferedReader` to read a file
    line by line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的步骤中，我们将学习如何使用 `BufferedReader` 逐行读取文件：
- en: 'Let''s start with getting the `InputStream` of our file and use the `BufferedReader`
    on it to read the contents of the file line by line:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从获取文件的 `InputStream` 开始，并使用 `BufferedReader` 来逐行读取文件内容：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output, in this case, is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output depends on the charset we use if we use one. This is a code example
    with a charset:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用字符集，输出将取决于我们使用的字符集。这是一个带有字符集的代码示例：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s go through a code example where we read directly from a file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个直接从文件读取的代码示例来了解：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`BufferedReader` provides us with a lot of methods that we can use to read
    contents of the file or input stream line by line. Using `useLines()`, we get
    a sequence of lines that we can then iterate on using `forEach`. A user may terminate
    the iteration loop, so the caller needs to close the `BufferedReader`, which is
    what `useLines()` does. We can only iterate over the sequence returned once.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader` 为我们提供了许多方法，我们可以使用这些方法逐行读取文件或输入流的内容。使用 `useLines()`，我们可以获取一个行序列，然后我们可以使用
    `forEach` 来迭代它。用户可能会终止迭代循环，因此调用者需要关闭 `BufferedReader`，这正是 `useLines()` 所做的。我们只能迭代返回的序列一次。'
- en: 'The syntax for `useLines()` is this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLines()` 的语法如下：'
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more…
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We can also use other methods like `readLine()` for this purpose. This code
    is an example of that:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他方法，如 `readLine()` 来实现这个目的。以下是一个示例代码：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The great thing about using the `useLines()` method is that it closes the stream
    post-execution. Also, the code in the preceding examples was a more idiomatic
    and clean way of doing the same thing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useLines()` 方法的优点是它在执行后关闭流。此外，前面示例中的代码是完成同样任务的一种更符合 Kotlin 风格和更简洁的方式。
- en: Another method provided by Kotlin that returns a sequence of lines is `lineSequence()`,
    but it does not close the `BufferedReader` after execution, which is why it's
    good to use `useLines()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供的另一个返回行序列的方法是 `lineSequence()`，但它执行后不会关闭 `BufferedReader`，这就是为什么使用
    `useLines()` 是一个好的选择。
- en: In the end, it depends on the scenario in which the code is to be used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这取决于代码将要被使用的场景。
- en: Reading string and JSON over network
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过网络读取字符串和 JSON
- en: Networking is an essential component of apps. Most of the apps we use are connected
    to the internet and involve reading/writing data over the internet. In this recipe,
    we will learn how to perform network requests in Kotlin. Although you can also
    use a third-party library such as Retrofit, Volley and such, understanding how
    it's done in Kotlin is worthwhile. So let's get started!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是应用程序的一个基本组件。我们使用的许多应用程序都连接到互联网，并涉及在互联网上读取/写入数据。在这个菜谱中，我们将学习如何在 Kotlin 中执行网络请求。虽然你也可以使用像
    Retrofit、Volley 这样的第三方库，但了解在 Kotlin 中是如何实现的仍然很有价值。所以，让我们开始吧！
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be working with Android code, so I'll be using Android Studio. It's
    also required to include the anko-commons library as we will be using its methods
    in our code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android 代码，所以我将使用 Android Studio。还需要包含 anko-commons 库，因为我们将使用其方法来编写代码。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s follow these steps to understand how to make a network request in Kotlin:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来了解如何在 Kotlin 中进行网络请求：
- en: 'Making a network request in Kotlin is straightforward with simple syntax. Here''s
    how you would read data over the internet in Kotlin:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用简单的语法进行网络请求非常直接。以下是你在 Kotlin 中如何读取网络数据的方法：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That''s it! Remember that this is equivalent to Java code when making a network
    request:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！记住，当进行网络请求时，这相当于 Java 代码：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, of course, if you try it on the main thread, you will get the `NetworkOnMainThreadException`
    exception. To get away with this, we need to make the network call in the background.
    One way to do this is by using an `Async` task. An `Async` task was a pain to
    implement in Java, but we can do it quite easily using Anko (a library for Kotlin).
    This is how you would create a background task in Kotlin using Anko:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，当然，如果你在主线程上尝试它，你会得到 `NetworkOnMainThreadException` 异常。为了避免这种情况，我们需要在后台进行网络调用。一种方法是通过使用
    `Async` 任务。在 Java 中实现 `Async` 任务是一个痛苦的过程，但我们可以使用 Anko（一个 Kotlin 的库）轻松地做到这一点。这是你在
    Kotlin 中使用 Anko 创建后台任务的方法：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In Java's `Async` task implementation, the `Async` task could be fired even
    if the activity was being destroyed. This resulted in defensive programming where
    you had to make checks on whether the UI was still present to do UI operations.
    However, Anko's implementation of background task takes care of it, and it won't
    fire the task if the activity is dying.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 的 `Async` 任务实现中，即使活动正在被销毁，`Async` 任务也可能被触发。这导致了防御性编程，你必须检查 UI 是否仍然存在来进行
    UI 操作。然而，Anko 的后台任务实现会处理这个问题，并且如果活动正在死亡，它不会触发任务。
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `doAsync` returns a Java `Future`. In simple words, a `Future` is a proxy
    or a wrapper around an object that is not yet there. When the asynchronous operation
    is done, you can extract it. If you want to avoid working with `Future`, `doAsync`
    has a different construct that accepts an `ExecutorService`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAsync`返回一个Java `Future`。简单来说，`Future`是一个代理或包装器，它围绕着一个尚未存在的对象。当异步操作完成时，你可以从中提取它。如果你想要避免与`Future`一起工作，`doAsync`有一个不同的结构，它接受一个`ExecutorService`：'
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we discussed, the `uiThread` block isn't executed if the activity is closing.
    The reason is that it doesn't hold a context instance, only a weak reference.
    So even if the block isn't finished, the context will not leak.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的那样，如果活动正在关闭，则不会执行`uiThread`块。原因是它不持有上下文实例，而只持有弱引用。因此，即使该块未完成，上下文也不会泄漏。
