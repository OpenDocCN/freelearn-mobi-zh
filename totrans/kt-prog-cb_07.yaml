- en: Handling File Operations in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from files using InputReader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading all lines in a file using InputReader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading line by line using InputReader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from files using BufferedReader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading all lines in a file using BufferedReader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading line by line using BufferedReader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading string and JSON over network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin I/O is used for input and output processing. Kotlin provides the `kotlin.io`
    API for working with files and streams. Some of the functions used in `kotlin.io`
    are extensions of `java.io` classes. All in all, using `kotlin.io` for reading
    from and writing to files and streams is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from files using InputReader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Kotlin.io` provides a nice, clean API for reading from and writing to files.
    One way of doing this is by using `InputReader`. We will see how to do that in
    this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of ways to go about reading from a file, but it is very important
    to understand the motivation behind them so as to be able to use the correct one
    for our purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will try to get the `InputStream` of the file and use the reader
    to read the contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, `lorem.txt` is simply a file that we want to read.
    The file is located in the same folder as our code source file. If we need to
    read a file located in a different folder, it looks similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code simply takes all the text in the file and prints it on the
    console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way of reading file contents is by directly creating a reader of the
    file, like we do in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of both preceding code blocks will simply be the text in the file
    as it is. In our case, it was as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, what if we want to read the file line by line because we want to do some
    processing on each line? In that case, we use the `useLines()` method in place
    of `use()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check out the following example, where we get an input stream from the file
    and use the `useLines()` method to get each line one after the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we wish to use a reader directly on the file, we do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in this case, will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you note that we used the `use()` and `useLines()` methods for reading the
    file? The call to the `Closeable.use()` function will automatically close the
    input at the end of the lambda's execution. Now, we can of course use `Reader.readText()`,
    but that does not close the stream after execution. There are other methods apart
    from `use()`, such as `Reader.readText()` and so on, that can be used to read
    the contents of a stream or file. The decision to use any method is based on whether
    we want the stream to be closed on its own after execution, or we want to handle
    closing the resources, and whether or not we want to read from a stream or directly
    from the file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BufferedReader` reads a couple of characters at a time from the input stream
    and stores them in the buffer. That’s why it is called `BufferedReader`. On the
    other hand, `InputReader` reads only one character from the input stream and the
    remaining characters still remain in the stream. There is no buffer in this case.
    This is why `BufferedReader` is fast, as it maintains a buffer, and retrieving
    data from the buffer is always quicker compared to retrieving data from disk.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading all lines in a file using InputReader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use `InputReader` to read all the lines in a file in one go. In this
    recipe, we will learn how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to understand how to read a file using the `InputReader`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to read a file, one of which is to attach an input stream
    to the file. Let''s see how we can do that and use `InputReader` to read its contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way is without getting a stream and directly reading the contents
    of the file, such as in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in this case, is simply the contents of the file as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We used the `use()` method because it closes the stream after execution.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attaching `inputStream` to a file returns the file contents as a stream of bytes.
    We can use a reader on the stream returned, or we can use the reader directly
    on the file. The `read()` method of `inputStream` reads the next byte in the stream.
    The `readText()` method returns the entire contents of the file as a string using
    UTF-8 or specified charset.
  prefs: []
  type: TYPE_NORMAL
- en: This `readText()` method is not recommended for huge files. It has an internal
    limitation of 2 GB file size. In case of a huge file, we read it byte by byte
    from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Reading line by line using InputReader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to read the contents of a file line by line and process it.
    This is easily done by reading a file line by line using the `InputReader`. Let's
    see how.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn how to make use of the `InputReader`
    class to read the text line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with attaching the `InputStream` to the file and going line by
    line on the contents, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line is appended with `*` in this case. Here''s how the output looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can directly attach the reader to the file and read it line by line. The
    following code does just that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useLines()` method provides us an iterable over all the lines of the file
    or stream and then does something with each line, which is a string. We add all
    the modified strings to a list and print them out.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from files using BufferedReader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BufferedReader` stores some characters as it reads into the buffer. This makes
    the reading faster and hence more efficient. In this recipe, we will understand
    how to use the `BufferedReader` to read the contents of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the mentioned steps to learn more about the working of the `BufferedReader`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly attach a `BufferedReader` to the file and read the contents
    of the whole file, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also go line by line on the contents that we need so as to be able to
    process each line individually. In the following code, we go line by line and
    add a character at the beginning and the length of the string after the character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code blocks, we are directly attaching the reader to the file.
    However, there are cases when we need to take a stream of data. In that scenario,
    we can get an Input Stream from the file that we want to read and then attach
    a `BufferedReader` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code, we are trying to read line by line from the file input
    stream using a `BufferedReader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output when we try to read all the contents of the file in one
    go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output resembles the file, ignoring the `charset`. We can also specify
    the desired `charset`, such as we do in the following code, if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we go line by line using either of the preceding examples, we get the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `InputStream` helps us get a stream of the file we wish to read. We can
    also read from the file directly though. In either case, the `BufferedReader`
    keeps presaving some data that it is reading in its buffer for faster operation,
    which increases the overall efficiency of the read operation, as compared to when
    using `InputReader`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `use()` and/or `useLines()` method in place of `Reader.readText()` and
    so on so that it automatically closes the input stream at the end of execution,
    which is a much cleaner and more responsible way of handling I/O of files. However,
    if needed, one can use a method such as `Reader.readText()` when they want to
    handle opening and closing the stream on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Reading all lines in a file using BufferedReader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BufferedReader` can be used to read contents of a file or an input stream.
    It presaves some contents it reads, so the read operation is faster. In this recipe,
    we will learn how to read all the contents of a file in one go using `BufferedReader`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn how to use `BufferedReader` to read all
    lines of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with getting the `InputStream` of our file and use the `BufferedReader`
    on it to read the contents of the file in one go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in this case, will be the exact same as the file, depending on
    the charset of course, if we use it. Here''s an example where we use another charset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s quickly see the code example without getting the `inputStream`
    on this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you might have guessed the output, here''s the output anyway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BufferedReader`, as it reads, stores some characters in a buffer, hence the
    read operations are faster. We can directly attach the `BufferedReader` to the
    file or the stream and read from it.'
  prefs: []
  type: TYPE_NORMAL
- en: The `use()` method ensures that the file or stream is closed after execution
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: Reading line by line using bufferedReader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will understand how to use the `bufferedReader` to read the
    contents of a file line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for
    the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the given steps, we will learn how to use `BufferedReader` to read a file
    line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with getting the `InputStream` of our file and use the `BufferedReader`
    on it to read the contents of the file line by line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in this case, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output depends on the charset we use if we use one. This is a code example
    with a charset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go through a code example where we read directly from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BufferedReader` provides us with a lot of methods that we can use to read
    contents of the file or input stream line by line. Using `useLines()`, we get
    a sequence of lines that we can then iterate on using `forEach`. A user may terminate
    the iteration loop, so the caller needs to close the `BufferedReader`, which is
    what `useLines()` does. We can only iterate over the sequence returned once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for `useLines()` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also use other methods like `readLine()` for this purpose. This code
    is an example of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about using the `useLines()` method is that it closes the stream
    post-execution. Also, the code in the preceding examples was a more idiomatic
    and clean way of doing the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Another method provided by Kotlin that returns a sequence of lines is `lineSequence()`,
    but it does not close the `BufferedReader` after execution, which is why it's
    good to use `useLines()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it depends on the scenario in which the code is to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Reading string and JSON over network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is an essential component of apps. Most of the apps we use are connected
    to the internet and involve reading/writing data over the internet. In this recipe,
    we will learn how to perform network requests in Kotlin. Although you can also
    use a third-party library such as Retrofit, Volley and such, understanding how
    it's done in Kotlin is worthwhile. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be working with Android code, so I'll be using Android Studio. It's
    also required to include the anko-commons library as we will be using its methods
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to understand how to make a network request in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a network request in Kotlin is straightforward with simple syntax. Here''s
    how you would read data over the internet in Kotlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Remember that this is equivalent to Java code when making a network
    request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, of course, if you try it on the main thread, you will get the `NetworkOnMainThreadException`
    exception. To get away with this, we need to make the network call in the background.
    One way to do this is by using an `Async` task. An `Async` task was a pain to
    implement in Java, but we can do it quite easily using Anko (a library for Kotlin).
    This is how you would create a background task in Kotlin using Anko:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In Java's `Async` task implementation, the `Async` task could be fired even
    if the activity was being destroyed. This resulted in defensive programming where
    you had to make checks on whether the UI was still present to do UI operations.
    However, Anko's implementation of background task takes care of it, and it won't
    fire the task if the activity is dying.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `doAsync` returns a Java `Future`. In simple words, a `Future` is a proxy
    or a wrapper around an object that is not yet there. When the asynchronous operation
    is done, you can extract it. If you want to avoid working with `Future`, `doAsync`
    has a different construct that accepts an `ExecutorService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed, the `uiThread` block isn't executed if the activity is closing.
    The reason is that it doesn't hold a context instance, only a weak reference.
    So even if the block isn't finished, the context will not leak.
  prefs: []
  type: TYPE_NORMAL
