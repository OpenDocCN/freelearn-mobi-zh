<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Data Storage</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Storing simple data</li>
<li>Read and writing a text file to internal storage</li>
<li>Read and writing a text file to external storage</li>
<li>Including resource files in your project</li>
<li>Creating and using an SQLite database</li>
<li>Accessing data in the background using a Loader</li>
<li>Accessing external storage with scoped directories</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Since most applications, big or small, require saving data – from default user selections to user accounts – Android offers many options. From saving a simple value to creating full databases using SQLite, storage options include the following:</p>
<ul>
<li>Shared preferences: Simple name/value pairs</li>
<li>Internal storage: Data files in private storage</li>
<li>External storage: Data files in private or public storage</li>
<li>SQLite database: Private data (can be made public through a Content Provider)</li>
<li>Cloud storage: Private server or service provider</li>
</ul>
<p>There are benefits and trade-offs to using internal and external storage. We will list some of the differences here to help you decide which option best fits your needs:</p>
<p style="padding-left: 30px"><strong>Internal storage</strong>:</p>
<ul>
<li>Unlike external storage, internal storage is always available but generally has less free space</li>
<li>Files are not accessible to the user (unless the device has root access)</li>
<li>Files are automatically deleted when your app is uninstalled (or with the <span class="packt_screen">Clear Cache</span>/<span class="packt_screen">Cleanup File</span> option in the App Manager)</li>
</ul>
<p style="padding-left: 30px"><strong>External storage</strong>:</p>
<ul>
<li>The device may not have external storage or it may be inaccessible (such as when it's connected to a computer)</li>
<li>Files are accessible to the user (and other apps) without requiring root access</li>
<li>Files are not deleted when your app is uninstalled (unless you use <kbd>getExternalFilesDir()</kbd> to get app-specific public storage)</li>
</ul>
<p>In this chapter, we will demonstrate working with shared preferences, internal and external storage, and SQLite databases. For cloud storage, take a look at the internet recipes in <a href="d130c363-73b4-48bd-aa87-e4398aef7664.xhtml"><span class="ChapterrefPACKT">Chapter 12</span></a>, <em>Telephony, Networks</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing simple data</h1>
                </header>
            
            <article>
                
<p>It's a common requirement to store simple data, and Android makes it simple using the Preferences API. It's not limited to just user preferences either; you can store any of the primitive data types using a name/value pair.</p>
<p>We'll demonstrate saving a name from an <kbd>EditText</kbd> and displaying it when the application starts. The following screenshots shows how the application looks the first time with no saved name:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ed2bbe2-b637-4865-a352-2db38ed9d601.png" style="width:22.75em;height:45.67em;"/></p>
<p>This is an example of how it looks after saving a name:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/306a0343-f644-4791-b986-16282f6f2ad9.png" style="width:21.50em;height:42.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>Preferences</kbd>. <span class="s1">Use the default </span><span class="s2"><span class="packt_screen">Phone &amp; Tablet</span></span><span class="s1"> options and select </span><span class="s2"><span class="packt_screen">Empty Activity</span></span><span class="s1"> in the </span><span class="s2"><span class="packt_screen">Add an Activity to Mobile</span></span><span class="s1"> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We'll use the existing <span class="packt_screen">TextView</span> to display a <span class="packt_screen">Welcome back</span> message and create a new <kbd>EditText</kbd> button to save the name. Start by opening <kbd>activity_main.xml</kbd>:</p>
<ol>
<li>Replace the existing <span class="packt_screen">TextView</span> with the following new views:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;TextView<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/textView"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent" </span><span>/&gt;<br/></span><span><br/></span><span>&lt;EditText<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/editTextName"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:ems=</span><span>"10"<br/></span><span>    </span><span>android</span><span>:hint=</span><span>"Enter your name"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"</span><span>/&gt;<br/></span><span><br/></span><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Save"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toBottomOf=</span><span>"@+id/editTextName"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"saveName"</span><span>/&gt;<br/></span></pre>
<ol start="2">
<li>Open <kbd>ActivityMain.java</kbd> and add the following global declarations:</li>
</ol>
<pre style="padding-left: 60px">private final String NAME="NAME"; 
private EditText mEditTextName; </pre>
<ol start="3">
<li>Add the following code to <kbd>onCreate()</kbd> to save a reference to <kbd>EditText</kbd> and to load any saved name:</li>
</ol>
<pre style="padding-left: 60px">TextView textView = (TextView)findViewById(R.id.<span>textView</span>)<span>;<br/></span>SharedPreferences sharedPreferences = getPreferences(<span>MODE_PRIVATE</span>)<span>;<br/></span>String name = sharedPreferences.getString(<span>NAME</span><span>,null</span>)<span>;<br/></span><span>if </span>(name==<span>null</span>) {<br/>    textView.setText(<span>"Hello"</span>)<span>;<br/></span>} <span>else </span>{<br/>    textView.setText(<span>"Welcome back " </span>+ name + <span>"!"</span>)<span>;<br/></span>}<br/><span>mEditTextName </span>= findViewById(R.id.<span>editTextName</span>)<span>;</span></pre>
<ol start="4">
<li>Add the following <kbd>saveName()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>saveName</span>(View view) {<br/>    SharedPreferences.Editor editor = getPreferences(<span>MODE_PRIVATE</span>).edit()<span>;<br/></span><span>    </span>editor.putString(<span>NAME</span><span>, </span><span>mEditTextName</span>.getText().toString())<span>;<br/></span><span>    </span>editor.commit()<span>;<br/></span>}</pre>
<ol start="5">
<li>Run the program on a device or emulator. Since we are demonstrating persisting data, it loads the name during <kbd>onCreate()</kbd>, so save a name and restart the program to see it load.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To load the name, we first get a reference to <kbd>SharedPreference</kbd> and call the <kbd>getString()</kbd> method. We pass in the key for our name/value pair (we created a constant called <kbd>NAME</kbd>) and the default value to return if the key is not found.</p>
<p>To save the preference, we first need to get a reference to the Preference Editor. We use <kbd>putString()</kbd> with our <kbd>NAME</kbd> <span>constant</span><span> </span><span>and follow it with</span> <kbd>commit().</kbd> <span>Without</span> <kbd>commit()</kbd><span>, the change will not be saved.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Our example stores all the preferences in a single file. We can also store preferences in different files using <kbd>getSharedPreferences()</kbd> and passing in the name. One example where this option could be useful is you wanted to have separate profiles in a multi-user app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read and write a text file to internal storage</h1>
                </header>
            
            <article>
                
<p>When simple name/value pairs are not sufficient, Android also supports regular file operations, including working with text and binary data.</p>
<p>The following recipe demonstrates how to read and write a file to internal or private storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>InternalStorageFile</kbd>. <span class="s1">Use the default </span><span class="s2"><span class="packt_screen">Phone &amp; Tablet</span></span><span class="s1"> options and select </span><span class="s2"><span class="packt_screen">Empty Activity</span></span><span class="s1"> in the </span><span class="s2"><span class="packt_screen">Add an Activity to Mobile</span></span><span class="s1"> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To demonstrate both reading and writing text, we'll need a layout with an <kbd>EditText</kbd> and two buttons. Start by opening <kbd>main_activity.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>&lt;TextView&gt;</kbd> element with the following views:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;EditText<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/editText"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:inputType=</span><span>"textMultiLine"<br/></span><span>    </span><span>android</span><span>:ems=</span><span>"10"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toTopOf=</span><span>"@+id/buttonRead"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent" </span><span>/&gt;<br/></span><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/buttonRead"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Read"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toTopOf=</span><span>"@+id/buttonWrite"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"readFile"</span><span>/&gt;<br/></span><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/buttonWrite"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Write"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"writeFile"</span><span>/&gt;</span></pre>
<ol start="2">
<li>Now, open <kbd>ActivityMain.java</kbd> and add the following global variables:</li>
</ol>
<pre style="padding-left: 60px">private final String FILENAME="testfile.txt"; 
EditText mEditText; </pre>
<ol start="3">
<li>Add the following to the <kbd>onCreate()</kbd> method, after <kbd>setContentView ()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">mEditText = (EditText)findViewById(R.id.editText); </pre>
<ol start="4">
<li>Add the following <kbd>writeFile()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>writeFile</span>(View view) {<br/>    <span>try </span>{<br/>        FileOutputStream fileOutputStream = openFileOutput(<span>FILENAME</span><span>, </span>Context.<span>MODE_PRIVATE</span>)<span>;        <br/></span><span>        </span>fileOutputStream.write(<span>mEditText</span>.getText().toString().getBytes())<span>;<br/></span><span>        </span>fileOutputStream.close()<span>;<br/></span><span>    </span>} <span>catch </span>(java.io.IOException e) {<br/>        e.printStackTrace()<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="5">
<li>Now, add the <kbd>readFile()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>readFile</span>(View view) {<br/>    StringBuilder stringBuilder = <span>new </span>StringBuilder()<span>;<br/></span><span>    try </span>{<br/>        InputStream inputStream = openFileInput(<span>FILENAME</span>)<span>;<br/></span><span>        if </span>( inputStream != <span>null </span>) {<br/>            InputStreamReader inputStreamReader = <span>new </span>InputStreamReader(inputStream)<span>;            <br/></span><span>            </span>BufferedReader bufferedReader = <span>new </span>BufferedReader(inputStreamReader)<span>;<br/></span><span>            </span>String newLine = <span>null;<br/></span><span>            while </span>((newLine = bufferedReader.readLine()) != <span>null </span>) {<br/>                stringBuilder.append(newLine+<span>"</span><span>\n</span><span>"</span>)<span>;<br/></span><span>            </span>}<br/>            inputStream.close()<span>;<br/></span><span>        </span>}<br/>    } <span>catch </span>(java.io.IOException e) {<br/>        e.printStackTrace()<span>;<br/></span><span>    </span>}<br/>    <span>mEditText</span>.setText(stringBuilder)<span>;<br/></span>}</pre>
<ol start="6">
<li>Run the program on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We use the <kbd>InputStream</kbd> and <kbd>FileOutputStream</kbd> classes to read and write, respectively. Writing to the file is as simple as getting the text from <kbd>EditText </kbd>and calling the <kbd>write()</kbd> method.</p>
<p>Reading back the contents is a little more involved. We could use the <kbd>FileInputStream</kbd> class for reading, but when working with text, the helper classes make it easier. In our example, we open the file with <kbd>openFileInput()</kbd>, which returns an <kbd>InputStream</kbd> object. We then use <kbd>InputStream</kbd> to get a <kbd>BufferedReader</kbd>, which offers the <kbd>ReadLine()</kbd> method. We loop through each line in the file and append it to our <kbd>StringBuilder</kbd>. When we're finished reading the file, we assign the text to <kbd>EditText</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The previous example used the private storage to save the file. Here's how you can use the cache folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching files</h1>
                </header>
            
            <article>
                
<p>If all you need is to temporarily store data, you can also use the cache folder. The following method returns the cache folder as a <kbd>File</kbd> object (the next recipe demonstrates working with the <kbd>File</kbd> object):</p>
<pre>getCacheDir() </pre>
<p>The main benefit of the cache folder is that the system can clear the cache if running low on storage space. (The user can also clear the cache folder from <span class="packt_screen">Apps Management</span> in <span class="packt_screen">Settings</span>.)</p>
<p>For example, if your app downloads news articles, you could store those in the cache. When your app starts, you can display the news already downloaded. These are files that are not required to make your app work. If the system is low on resources, the cache can be cleared without adversely affecting your app. (Even though the system may clear the cache, it's still a good idea for your app to remove old files as well.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The next recipe, <em>Read and write a text file to external storage</em>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read and write a text file to external storage</h1>
                </header>
            
            <article>
                
<p>The process of reading and writing files to external storage is basically the same as using internal storage. The difference is in obtaining a reference to the storage location. Also, as mentioned in the <em>Introduction</em>, external storage may not be available, so it's best to check availability before attempting to access it.</p>
<p>This recipe will read and write a text file, as we did in the previous recipe. We'll also demonstrate how to check the external storage state before we access it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>ExternalStorageFile</kbd>. <span class="s1">Use the default </span><span class="s2"><span class="packt_screen">Phone &amp; Tablet</span></span><span class="s1"> options and select </span><span class="s2"><span class="packt_screen">Empty Activity</span></span><span class="s1"> on the </span><span class="s2"><span class="packt_screen">Add an Activity</span> <span class="packt_screen">to Mobile</span></span><span class="s1"> dialog. </span>We will use the same layout as the previous recipe, so you can just copy and paste if you typed it in already. Otherwise, use the layout from step 1 in the previous recipe, <em>Read and write a text file to internal storage</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As mentioned previously in the <em>Getting ready</em> section, we'll use the layout from the previous recipe. With the layout file done, the first step will be to add permission to access the write to external storage. Here are the steps:</p>
<ol>
<li>Open the <span class="packt_screen">Android Manifest</span> and add the following permission:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;uses-permission </span><span>android</span><span>:name=</span><span>"android.permission.READ_EXTERNAL_STORAGE" </span><span>/&gt;<br/></span><span>&lt;uses-permission </span><span>android</span><span>:name=</span><span>"android.permission.WRITE_EXTERNAL_STORAGE" </span><span>/&gt;</span></pre>
<ol start="2">
<li>Next, open <kbd>ActivityMain.java</kbd> and add the following global variables:</li>
</ol>
<pre style="padding-left: 60px"><span>private final </span>String <span>FILENAME</span>=<span>"testfile.txt"</span><span>;<br/></span><span>private final </span>String[] <span>PERMISSIONS_STORAGE </span>= {<br/>        Manifest.permission.<span>READ_EXTERNAL_STORAGE</span><span>,<br/></span><span>        </span>Manifest.permission.<span>WRITE_EXTERNAL_STORAGE<br/></span>}<span>;<br/></span>EditText <span>mEditText</span><span>;</span></pre>
<ol start="3">
<li>Add the following to the <kbd>onCreate()</kbd> method, after <kbd>setContentView()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">mEditText = (EditText)findViewById(R.id.editText); </pre>
<ol start="4">
<li>Add the following two methods to check the storage state:</li>
</ol>
<pre style="padding-left: 60px"><span>public boolean </span><span>isExternalStorageWritable</span>() {<br/>    <span>if </span>(Environment.<span>MEDIA_MOUNTED</span>.equals(Environment.<span>getExternalStorageState</span>())) {<br/>        <span>return true;<br/></span><span>    </span>}<br/>    <span>return false;<br/></span>}<br/><br/><span>public boolean </span><span>isExternalStorageReadable</span>() {<br/>    <span>if </span>(Environment.<span>MEDIA_MOUNTED</span>.equals(Environment.<span>getExternalStorageState</span>()) ||<br/>            Environment.<span>MEDIA_MOUNTED_READ_ONLY</span>.equals(Environment.<span>getExternalStorageState</span>())) {<br/>        <span>return true;<br/></span><span>    </span>}<br/>    <span>return false;<br/></span>}</pre>
<ol start="5">
<li>Add the following method to verify the app has permission to access the external storage:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>checkStoragePermission</span>() {<br/>    <span>int </span>permission = ActivityCompat.<span>checkSelfPermission</span>(<span>this, <br/></span><span>            </span>Manifest.permission.<span>WRITE_EXTERNAL_STORAGE</span>)<span>;<br/></span><span><br/></span><span>    if </span>(permission != PackageManager.<span>PERMISSION_GRANTED</span>) {<br/>        ActivityCompat.<span>requestPermissions</span>(<span>this, </span><span>PERMISSIONS_STORAGE</span><span>,</span><span>101</span>)<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="6">
<li> Add the following <kbd>writeFile()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>writeFile</span>(View view) {<br/>    <span>if </span>(isExternalStorageWritable()) {<br/>        checkStoragePermission()<span>;<br/></span><span>        try </span>{<br/>            File textFile = <span>new </span>File(Environment.<span>getExternalStorageDirectory</span>()<span>, </span><span>FILENAME</span>)<span>;<br/></span><span>            </span>FileOutputStream fileOutputStream = <span>new </span>FileOutputStream(textFile)<span>;<br/></span><span>            </span>fileOutputStream.write(<span>mEditText</span>.getText().toString().getBytes())<span>;<br/></span><span>            </span>fileOutputStream.close()<span>;<br/></span><span>        </span>} <span>catch </span>(java.io.IOException e) {<br/>            e.printStackTrace()<span>;<br/></span><span>            </span>Toast.<span>makeText</span>(<span>this, </span><span>"Error writing file"</span><span>, </span>Toast.<span>LENGTH_LONG</span>).show()<span>;<br/></span><span>        </span>}<br/>    } <span>else </span>{<br/>        Toast.<span>makeText</span>(<span>this, </span><span>"Cannot write to External Storage"</span><span>, </span>Toast.<span>LENGTH_LONG</span>).show()<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="7">
<li>Add the following <kbd>readFile()</kbd>method:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>readFile</span>(View view) {<br/>    <span>if </span>(isExternalStorageReadable()) {<br/>        checkStoragePermission()<span>;<br/></span><span>        </span>StringBuilder stringBuilder = <span>new </span>StringBuilder()<span>;<br/></span><span>        try </span>{<br/>            File textFile = <span>new </span>File(Environment.<span>getExternalStorageDirectory</span>()<span>, </span><span>FILENAME</span>)<span>;<br/></span><span>            </span>FileInputStream fileInputStream = <span>new </span>FileInputStream(textFile)<span>;<br/></span><span>            if </span>(fileInputStream != <span>null </span>) {<br/>                InputStreamReader inputStreamReader = <span>new </span>InputStreamReader(fileInputStream)<span>;<br/></span><span>                </span>BufferedReader bufferedReader = <span>new </span>BufferedReader(inputStreamReader)<span>;<br/></span><span>                </span>String newLine = <span>null;<br/></span><span>                while </span>( (newLine = bufferedReader.readLine()) != <span>null </span>) {<br/>                    stringBuilder.append(newLine+<span>"</span><span>\n</span><span>"</span>)<span>;<br/></span><span>                </span>}<br/>                fileInputStream.close()<span>;<br/></span><span>            </span>}<br/>            <span>mEditText</span>.setText(stringBuilder)<span>;<br/></span><span>        </span>} <span>catch </span>(java.io.IOException e) {<br/>            e.printStackTrace()<span>;<br/></span><span>            </span>Toast.<span>makeText</span>(<span>this, </span><span>"Error reading file"</span><span>, </span>Toast.<span>LENGTH_LONG</span>).show()<span>;<br/></span><span>        </span>}<br/>    } <span>else </span>{<br/>        Toast.<span>makeText</span>(<span>this, </span><span>"Cannot read External Storage"</span><span>,<br/></span><span>                </span>Toast.<span>LENGTH_LONG</span>).show()<span>;<br/></span><span>    </span>}</pre>
<ol start="8">
<li>Run the program on a device or emulator with external storage.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Reading and writing files are basically the same for both internal and external storage. The main difference is that we should check for the availability of the external storage before attempting to access it, which we do with the <kbd>isExternalStorageWritable()</kbd> and <kbd>isExternalStorageReadable()</kbd> methods. When checking the storage state, <kbd>MEDIA_MOUNTED</kbd> means we can read and write to it.</p>
<p>Unlike the internal storage example, we request the working path, which we do in this line of code:</p>
<pre>File textFile = <span>new </span>File(Environment.<span>getExternalStorageDirectory</span>()<span>, </span><span>FILENAME</span>)<span>;</span></pre>
<p>The actual reading and writing is done with the same classes, as it is just the location that is different.</p>
<div class="packt_tip">It is not safe to hard code an external folder path. The path can vary between versions of the OS and especially between hardware manufacturers. It is always best to call <kbd>getExternalStorageDirectory()</kbd> as shown.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You probably noticed the <kbd>checkStoragePermission()</kbd> function from step 5 wasn't mentioned. This is because permissions aren't specific to storage but are required for the app to access various device features. Unlike the previous recipe, which used local app storage, "external" storage is considered risky for the user. (It wouldn't be good if just any app could go through a user's private files.) For that reason, the app must make additional effort to check if it has the required permission to access storage. If it does not, the user will be prompted. Note that this additional dialog is coming from the OS, not the app itself.</p>
<p>When you first run the app, if you are prompted for permission but still get an error writing, exit the app and restart. For a more in-depth explanation and handling of the new Android permission model, see the <em>See also...</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting public folders</h1>
                </header>
            
            <article>
                
<p>The <kbd>getExternalStorageDirectory()</kbd> method returns the root folder of the external storage. If you want to obtain specific public folders, such as the <kbd>Music</kbd> or <kbd>Ringtone</kbd> folder, use <kbd>getExternalStoragePublicDirectory()</kbd> and pass in the desired folder type, for example:</p>
<pre>getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking available space</h1>
                </header>
            
            <article>
                
<p>One issue consistent between internal and external storage is limited space. If you know how much space you will need ahead of time, you can call the <kbd>getFreeSpace()</kbd> method on the <kbd>File</kbd> object. (<kbd>getTotalSpace()</kbd> will return the total space.) Here is a simple example, using the call to <kbd>getFreeSpace()</kbd>:</p>
<pre>if (Environment.getExternalStorageDirectory().getFreeSpace() &lt; RQUIRED_FILE_SPACE) { 
    //Not enough space 
} else { 
    //We have enough space 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a file</h1>
                </header>
            
            <article>
                
<p>There are many helper methods available through the <kbd>File</kbd> object, including deleting a file. If we wanted to delete the text file we created in the example, we could call <kbd>delete()</kbd> as follows:</p>
<pre>textFile.delete() </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with directories</h1>
                </header>
            
            <article>
                
<p>Although it's called a <kbd>File</kbd> object, it supports directory commands as well, such as making and removing directories. If you want to make or remove a directory, build the <kbd>File</kbd> object, then call the respective methods: <kbd>mkdir()</kbd> and <kbd>delete()</kbd>. (There's also a method called <kbd>mkdirs()</kbd> (plural) that will create parent folders as well.)</p>
<p>Refer to the link in the <em>See also</em> section for a complete list<span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preventing files from being included in galleries</h1>
                </header>
            
            <article>
                
<p>Android employs a <strong>media scanner</strong> that automatically includes sound, video, and image files in system collections, such as the <span class="packt_screen">Image Gallery</span>. To exclude your directory, create an empty file called <kbd>.nomedia</kbd> (note the preceding period) in the same directory as the files you wish to exclude.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>For more information on the Android 6.0 permission model, see the corresponding recipe in <a href="98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml">Chapter 15</a>,<em> Getting Your App Ready for the Play Store</em></li>
<li>For a complete list of methods available in the <kbd>File</kbd> class, visit<br/>
<a href="http://developer.android.com/reference/java/io/File.html"><span class="URLPACKT">http://developer.android.com/reference/java/io/File.html</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Including resource files in your project</h1>
                </header>
            
            <article>
                
<p>Android provides two options for including files in your project: the <kbd>raw</kbd> folder and the <kbd>assets</kbd> folder. Which option you use depends on your requirements. To start, we'll give a brief overview of each option to help you decide the best use:</p>
<ul>
<li><strong>Raw files</strong>
<ul>
<li>Included in the resource directory: <kbd>/res/raw</kbd></li>
<li>As a resource, accessed through the raw identifier: <kbd>R.raw.&lt;resource&gt;</kbd></li>
<li>A good place for storing media files such as MP3, MP4, and OGG files</li>
</ul>
</li>
<li><strong>Asset files</strong></li>
</ul>
<ul>
<li style="list-style-type: none">
<ul>
<li>Creates a file compiled in your APK (does not provide a resource ID)</li>
<li>Access files using their filenames, generally making them easier to use with dynamically created names</li>
<li>Some APIs do not support a Resource Identifier and therefore require including as an Asset</li>
</ul>
</li>
</ul>
<p>Generally, <kbd>raw</kbd> files are easier to work with since they are accessed through the resource identifier. As we'll demonstrate in this recipe, the main difference is how you access the file. In this example, we will load both a <kbd>raw</kbd> text file and an <kbd>asset</kbd> text file and display the contents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in <span class="packt_screen">Android Studio</span> and call it <kbd>ReadingResourceFiles</kbd>. <span class="s1">Use the default </span><span class="s2"><span class="packt_screen">Phone &amp; Tablet</span></span><span class="s1"> options and select </span><span class="s2"><span class="packt_screen">Empty Activity</span></span><span class="s1"> in the </span><span class="s2"><span class="packt_screen">Add an Activity to Mobile</span></span><span class="s1"> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To demonstrate reading content from both resource locations, we'll create a split layout. We also need to create both resource folders as they are not included in the default <span class="packt_screen">Android project</span>. Here are the steps:</p>
<ol>
<li>Open <kbd>activity_main.xml</kbd> and replace the contents with the following layout:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:orientation=</span><span>"vertical"</span><span>&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textViewRaw"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"0dp"<br/></span><span>        </span><span>android</span><span>:layout_weight=</span><span>"1"<br/></span><span>        </span><span>android</span><span>:gravity=</span><span>"center_horizontal|center_vertical"</span><span>/&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textViewAsset"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"0dp"<br/></span><span>        </span><span>android</span><span>:layout_weight=</span><span>"1"<br/></span><span>        </span><span>android</span><span>:gravity=</span><span>"center_horizontal|center_vertical"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt; </span></pre>
<ol start="2">
<li>Create the <kbd>raw</kbd> resource folder in the <kbd>res</kbd> folder. It will read as follows: <kbd>res/raw</kbd>. You can easily create it manually or let Android Studio do it for you by right-clicking on the <kbd>res</kbd> folder and selecting <span class="packt_screen">New</span> | <span class="packt_screen">Android Resource Directory</span>. When the Select Resource Directory dialog opens, select <span class="packt_screen">raw</span> as the <kbd>Resource type</kbd>, as shown in this screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5e832b7e-dd40-4271-a0f3-82b56494d0bc.png" style="width:53.42em;height:30.83em;"/></p>
<ol start="3">
<li>Create a new text file by right-clicking on the <kbd>raw</kbd> folder and select <span class="packt_screen">New</span> | <span class="packt_screen">File</span>. Name the file <kbd>raw_text.txt</kbd> and type some text in the file. (This text will be displayed when you run the application.)</li>
<li>Create the <kbd>asset</kbd> folder. The <kbd>asset</kbd> folder is trickier to create manually as it needs to be at the correct folder level. Fortunately, Android Studio provides a menu option that makes creating it very easy. Go to the <span class="packt_screen">File</span> menu (or right-click on the <span class="packt_screen">app</span> node) and select <span class="packt_screen">New</span> | <span class="packt_screen">Folder</span> | <span class="packt_screen">Assets Folder</span>, as shown in this screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ebd91ff-349c-40e8-8746-fc4cd3d6f047.png" style="width:52.25em;height:53.17em;"/></p>
<ol start="5">
<li>Create a text file in the asset folder called <kbd>asset_text.txt</kbd>. Again, whatever text you type here will be shown when you run the app. Here's how the final result should look after both text files are created:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b681874c-85c9-47fa-9084-6d53269ee5e7.png" style="width:12.75em;height:21.25em;"/></p>
<ol start="6">
<li>Now, it's time for the code. Open <kbd>MainActivity.java</kbd> and add the following method to read the text file (which is passed into the method):</li>
</ol>
<pre style="padding-left: 60px"><span>private </span>String <span>getText</span>(InputStream inputStream) {<br/>    StringBuilder stringBuilder = <span>new </span>StringBuilder()<span>;<br/></span><span>    try </span>{<span>;<br/></span><span>        if </span>( inputStream != <span>null </span>) {<br/>            InputStreamReader inputStreamReader = <span>new </span>InputStreamReader(inputStream)<span>;            <br/></span><span>            </span>BufferedReader bufferedReader = <span>new </span>BufferedReader(inputStreamReader)<span>;<br/></span><span>            </span>String newLine = <span>null;<br/></span><span>            while </span>((newLine = bufferedReader.readLine()) != <span>null </span>) {<br/>                stringBuilder.append(newLine+<span>"</span><span>\n</span><span>"</span>)<span>;<br/></span><span>            </span>}<br/>            inputStream.close()<span>;<br/></span><span>        </span>}<br/>    } <span>catch </span>(java.io.IOException e) {<br/>        e.printStackTrace()<span>;<br/></span><span>    </span>}<br/>    <span>return </span>stringBuilder.toString()<span>;<br/></span>}</pre>
<ol start="7">
<li>Finally, add the following code to the <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">TextView textViewRaw = findViewById(R.id.<span>textViewRaw</span>)<span>;<br/></span>textViewRaw.setText(getText(<span>this</span>.getResources().openRawResource(R.raw.<span>raw_text</span>)))<span>;<br/></span>TextView textViewAsset = findViewById(R.id.<span>textViewAsset</span>)<span>;<br/></span><span>try </span>{<br/>    textViewAsset.setText(getText(<span>this</span>.getAssets().open(<span>"asset_text.txt"</span>)))<span>;<br/></span>} <span>catch </span>(IOException e) {<br/>    e.printStackTrace()<span>;<br/></span>}</pre>
<ol start="8">
<li>Run the program on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To summarize, the only difference is in how we get a reference to each file. This line of code reads the <kbd>raw</kbd> resource:</p>
<pre>this.getResources().openRawResource(R.raw.raw_text) </pre>
<p>And this code reads the <kbd>asset</kbd> file:</p>
<pre>this.getAssets().open("asset_text.txt") </pre>
<p>Both calls return an <kbd>InputStream</kbd>, which the <kbd>getText()</kbd> method uses to read the file contents. It is worth noting, though, that the call to open the <kbd>asset</kbd> text file requires an additional <kbd>try</kbd>/<kbd>catch</kbd>.</p>
<p>As noted in the recipe introduction, resources are indexed so we have compile-time verification, which the <kbd>asset</kbd> folder does not have.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>A common approach is to include resources in your APK, but download new resources as they become available. (See the network communication in <a href="d130c363-73b4-48bd-aa87-e4398aef7664.xhtml"><span class="ChapterrefPACKT">Chapter 13</span></a>, <em>Telephony, Networks, and the Web</em>.) If new resources aren't available, you can always fall back on the resources in your APK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Network communication recipes in <span class="ChapterrefPACKT"><a href="d130c363-73b4-48bd-aa87-e4398aef7664.xhtml">Chapter 13</a></span>, <em>Telephony, Networks, and the Web.</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and using an SQLite database</h1>
                </header>
            
            <article>
                
<p>In this recipe, we're going to demonstrate working with an SQLite database. If you are already familiar with SQL databases from other platforms, then much of what you know will apply. If you are new to SQLite, take a look at the reference links in the <em>See also</em> section as this recipe assumes a basic understanding of database concepts, including schemas, tables, cursors, and raw SQL.</p>
<p>To get you up and running with an SQLite database quickly, our example implements the basic CRUD operations. Generally, when creating a database in Android, you create a class that extends <kbd>SQLiteOpenHelper</kbd>, which is where your database functionality is implemented. Here is a list of the CRUD (create, read, update, and delete) functions:</p>
<ul>
<li>Create: <kbd>insert()</kbd></li>
<li>Read: <kbd>query()</kbd> and <kbd>rawQuery()</kbd></li>
<li>Update: <kbd>update()</kbd></li>
<li>Delete: <kbd>delete()</kbd></li>
</ul>
<p>To demonstrate a fully working database, we will create a simple <kbd>Dictionary</kbd> database where we'll store words and their definitions. We'll demonstrate the CRUD operations by adding new words (with their definitions) and updating existing word definitions. We'll show words in a <kbd>ListView</kbd> using a cursor. Pressing a word in the <kbd>ListView</kbd> will read the definition from the database and display it in a Toast message. A long press will delete the word.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it <kbd>SQLiteDatabase</kbd>. <span class="s1">Use the default </span><span class="s2"><span class="packt_screen">Phone &amp; Tablet</span></span><span class="s1"> options and select </span><span class="s2"><span class="packt_screen">Empty Activity</span></span><span class="s1"> on the </span><span class="s2"><span class="packt_screen">Add an Activity to Mobile</span></span><span class="s1"> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, we'll create the UI, which will consist of two <kbd>EditText</kbd> fields, a button, and a <kbd>ListView</kbd>. As we add words to the database, they will populate the <kbd>ListView</kbd>. Start by opening <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the default XML with the following:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>xmlns:</span><span>app</span><span>=</span><span>"http://schemas.android.com/apk/res-auto"<br/></span><span>    </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:orientation=</span><span>"vertical"</span><span>&gt;<br/></span><span>    &lt;EditText<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/editTextWord"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_alignParentTop=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_alignParentLeft=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_alignParentStart=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"Word"</span><span>/&gt;<br/></span><span>    &lt;EditText<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/editTextDefinition"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_below=</span><span>"@+id/editTextWord"<br/></span><span>        </span><span>android</span><span>:layout_alignParentLeft=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_alignParentStart=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"Definition"</span><span>/&gt;<br/></span><span>    &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/buttonAddUpdate"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"Save"<br/></span><span>        </span><span>android</span><span>:layout_alignParentRight=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_alignParentTop=</span><span>"true" </span><span>/&gt;<br/></span><span>    &lt;ListView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/listView"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_below=</span><span>"@+id/et_definition"<br/></span><span>        </span><span>android</span><span>:layout_alignParentLeft=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_alignParentBottom=</span><span>"true" </span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<ol start="2">
<li>Add a new Java class to the project named <kbd>DictionaryDatabase</kbd>. This class extends from <kbd>SQLiteOpenHelper</kbd> and handles all the SQLite functions. Here is the class declaration:</li>
</ol>
<pre style="padding-left: 60px">public class DictionaryDatabase extends SQLiteOpenHelper { </pre>
<ol start="3">
<li>Below the declaration, add the following constants:</li>
</ol>
<pre style="padding-left: 60px"><span>private static final </span>String <span>DATABASE_NAME </span>= <span>"dictionary.db"</span><span>;<br/></span><span>private static final </span>String <span>TABLE_DICTIONARY </span>= <span>"dictionary"</span><span>;<br/></span><span><br/></span><span>private static final </span>String <span>FIELD_WORD </span>= <span>"word"</span><span>;<br/></span><span>private static final </span>String <span>FIELD_DEFINITION </span>= <span>"definition"</span><span>;<br/></span><span>private static final int </span><span>DATABASE_VERSION </span>= <span>1</span><span>;</span></pre>
<ol start="4">
<li>Add the following constructor, <kbd>OnCreate()</kbd>, and <kbd>onUpgrade()</kbd> methods:</li>
</ol>
<pre style="padding-left: 60px"><span>DictionaryDatabase</span>(Context context) {<br/>    <span>super</span>(context<span>, </span><span>DATABASE_NAME</span><span>, null, </span><span>DATABASE_VERSION</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>onCreate</span>(SQLiteDatabase db) {<br/>    db.execSQL(<span>"CREATE TABLE " </span>+ <span>TABLE_DICTIONARY </span>+<br/>            <span>"(_id integer PRIMARY KEY," </span>+<br/>            <span>FIELD_WORD </span>+ <span>" TEXT, " </span>+<br/>            <span>FIELD_DEFINITION </span>+ <span>" TEXT);"</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>onUpgrade</span>(SQLiteDatabase db<span>, int </span>oldVersion<span>, int </span>newVersion) {<br/>    <span>//Handle database upgrade as needed<br/></span>}</pre>
<ol start="5">
<li>The following methods are responsible for creating, updating, and deleting the records:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>saveRecord</span>(String word<span>, </span>String definition) {<br/>    <span>long </span>id = findWordID(word)<span>;<br/></span><span>    if </span>(id&gt;<span>0</span>) {<br/>        updateRecord(id<span>, </span>word<span>,</span>definition)<span>;<br/></span><span>    </span>} <span>else </span>{<br/>        addRecord(word<span>,</span>definition)<span>;<br/></span><span>    </span>}<br/>}<br/><br/><span>public long </span><span>addRecord</span>(String word<span>, </span>String definition) {<br/>    SQLiteDatabase db = getWritableDatabase()<span>;<br/></span><span><br/></span><span>    </span>ContentValues values = <span>new </span>ContentValues()<span>;<br/></span><span>    </span>values.put(<span>FIELD_WORD</span><span>, </span>word)<span>;<br/></span><span>    </span>values.put(<span>FIELD_DEFINITION</span><span>, </span>definition)<span>;<br/></span><span>    return </span>db.insert(<span>TABLE_DICTIONARY</span><span>, null, </span>values)<span>;<br/></span>}<br/><br/><span>public int </span><span>updateRecord</span>(<span>long </span>id<span>, </span>String word<span>, </span>String definition) {<br/>    SQLiteDatabase db = getWritableDatabase()<span>;<br/></span><span>    </span>ContentValues values = <span>new </span>ContentValues()<span>;<br/></span><span>    </span>values.put(<span>"_id"</span><span>, </span>id)<span>;<br/></span><span>    </span>values.put(<span>FIELD_WORD</span><span>, </span>word)<span>;<br/></span><span>    </span>values.put(<span>FIELD_DEFINITION</span><span>, </span>definition)<span>;<br/></span><span>    return </span>db.update(<span>TABLE_DICTIONARY</span><span>, </span>values<span>, </span><span>"_id = ?"</span><span>, new </span>String[]{String.<span>valueOf</span>(id)})<span>;<br/></span>}<br/><span>public int </span><span>deleteRecord</span>(<span>long </span>id) {<br/>    SQLiteDatabase db = getWritableDatabase()<span>;<br/></span><span>    return </span>db.delete(<span>TABLE_DICTIONARY</span><span>, </span><span>"_id = ?"</span><span>, new </span>String[]{String.<span>valueOf</span>(id)})<span>;<br/></span>}</pre>
<ol start="6">
<li>And these methods handle reading the information from the database:</li>
</ol>
<pre style="padding-left: 60px"><span>public long </span><span>findWordID</span>(String word) {<br/>    <span>long </span>returnVal = -<span>1</span><span>;<br/></span><span>    </span>SQLiteDatabase db = getReadableDatabase()<span>;<br/></span><span>    </span>Cursor cursor = db.rawQuery(<br/>            <span>"SELECT _id FROM " </span>+ <span>TABLE_DICTIONARY </span>+ <span>" WHERE " </span>+ <span>FIELD_WORD </span>+ <span>" = ?"</span><span>, <br/></span><span>            new </span>String[]{word})<span>;<br/></span><span>    if </span>(cursor.getCount() == <span>1</span>) {<br/>        cursor.moveToFirst()<span>;<br/></span><span>        </span>returnVal = cursor.getInt(<span>0</span>)<span>;<br/></span><span>    </span>}<br/>    <span>return </span>returnVal<span>;<br/></span>}<br/><br/><span>public </span>String <span>getDefinition</span>(<span>long </span>id) {<br/>    String returnVal = <span>""</span><span>;<br/></span><span>    </span>SQLiteDatabase db = getReadableDatabase()<span>;<br/></span><span>    </span>Cursor cursor = db.rawQuery(<br/>            <span>"SELECT definition FROM " </span>+ <span>TABLE_DICTIONARY </span>+ <span>" WHERE _id = ?"</span><span>, <br/></span><span>            new </span>String[]{String.<span>valueOf</span>(id)})<span>;<br/></span><span>    if </span>(cursor.getCount() == <span>1</span>) {<br/>        cursor.moveToFirst()<span>;<br/></span><span>        </span>returnVal = cursor.getString(<span>0</span>)<span>;<br/></span><span>    </span>}<br/>    <span>return </span>returnVal<span>;<br/></span>}<br/><br/><span>public </span>Cursor <span>getWordList</span>() {<br/>    SQLiteDatabase db = getReadableDatabase()<span>;<br/></span><span>    </span>String query = <span>"SELECT _id, " </span>+ <span>FIELD_WORD </span>+<br/>            <span>" FROM " </span>+ <span>TABLE_DICTIONARY </span>+ <span>" ORDER BY " </span>+ <span>FIELD_WORD </span>+<br/>            <span>" ASC"</span><span>;<br/></span><span>    return </span>db.rawQuery(query<span>, null</span>)<span>;<br/></span>}</pre>
<ol start="7">
<li>With the database, class finished, open <kbd>MainActivity.java</kbd>. Add the following global variables below the class declaration:</li>
</ol>
<pre style="padding-left: 60px">EditText mEditTextWord; 
EditText mEditTextDefinition; 
DictionaryDatabase mDB; 
ListView mListView; </pre>
<ol start="8">
<li>Add the following method to save the fields when the button is clicked:</li>
</ol>
<pre style="padding-left: 60px"><span>private void </span><span>saveRecord</span>() {<br/>    <span>mDB</span>.saveRecord(<span>mEditTextWord</span>.getText().toString()<span>, </span><span>mEditTextDefinition</span>.getText().toString())<span>;<br/></span><span>    </span><span>mEditTextWord</span>.setText(<span>""</span>)<span>;<br/></span><span>    </span><span>mEditTextDefinition</span>.setText(<span>""</span>)<span>;<br/></span><span>    </span>updateWordList()<span>;<br/></span>}</pre>
<ol start="9">
<li>Add this method to populate the <kbd>ListView</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><span>private void </span><span>updateWordList</span>() {<br/>    SimpleCursorAdapter simpleCursorAdapter = <span>new </span>SimpleCursorAdapter(<br/>            <span>this,<br/></span><span>            </span>android.R.layout.<span>simple_list_item_1</span><span>,<br/></span><span>            </span><span>mDB</span>.getWordList()<span>,<br/></span><span>            new </span>String[]{<span>"word"</span>}<span>,<br/></span><span>            new int</span>[]{android.R.id.<span>text1</span>}<span>,<br/></span><span>            </span><span>0</span>)<span>;<br/></span><span>    </span><span>mListView</span>.setAdapter(simpleCursorAdapter)<span>;<br/></span>}</pre>
<ol start="10">
<li>Finally, add the following code to <kbd>onCreate()</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><span>mDB </span>= <span>new </span>DictionaryDatabase(<span>this</span>)<span>;<br/></span><span>mEditTextWord </span>= findViewById(R.id.<span>editTextWord</span>)<span>;<br/></span><span>mEditTextDefinition </span>= findViewById(R.id.<span>editTextDefinition</span>)<span>;<br/></span>Button buttonAddUpdate = findViewById(R.id.<span>buttonAddUpdate</span>)<span>;<br/></span>buttonAddUpdate.setOnClickListener(<span>new </span>View.OnClickListener() {<br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>onClick</span>(View v) {<br/>        saveRecord()<span>;<br/></span><span>    </span>}<br/>})<span>;<br/></span><span><br/></span><span>mListView </span>= findViewById(R.id.<span>listView</span>)<span>;<br/></span><span>mListView</span>.setOnItemClickListener(<span>new </span>AdapterView.OnItemClickListener() {<br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>onItemClick</span>(AdapterView&lt;?&gt; parent<span>, </span>View view<span>, int </span>position<span>, long </span>id) {<br/>        Toast.<span>makeText</span>(MainActivity.<span>this, </span><span>mDB</span>.getDefinition(id)<span>, </span>Toast.<span>LENGTH_SHORT</span>).show()<span>;<br/></span><span>    </span>}<br/>})<span>;<br/></span><span>mListView</span>.setOnItemLongClickListener(<span>new </span>AdapterView.OnItemLongClickListener() {<br/>    <span>@Override<br/></span><span>    </span><span>public boolean </span><span>onItemLongClick</span>(AdapterView&lt;?&gt; parent<span>, </span>View view<span>, int </span>position<span>, long </span>id) {<br/>        Toast.<span>makeText</span>(MainActivity.<span>this, <br/></span><span>                </span><span>"Records deleted = " </span>+ <span>mDB</span>.deleteRecord(id)<span>, </span>Toast.<span>LENGTH_SHORT</span>).show()<span>;<br/></span><span>        </span>updateWordList()<span>;<br/></span><span>        return true;<br/></span><span>    </span>}<br/>})<span>;<br/></span>updateWordList()<span>;</span></pre>
<ol start="11">
<li>Run the program on a device or emulator and try it out.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We'll start by explaining the <kbd>DictionaryDatabase</kbd> class as that's the heart of an SQLite database. The first item to note is the constructor:</p>
<pre>DictionaryDatabase(Context context) { 
    super(context, DATABASE_NAME, null, DATABASE_VERSION); 
} </pre>
<p>Notice <kbd>DATABASE_VERSION</kbd>? Only when you make changes to your database schema do you need to increment this value.</p>
<p>Next is <kbd>onCreate()</kbd>, where the database is actually created. This is only called the first time the database is created, not each time the class is created. It's also worth noting the <kbd>_id</kbd> field. Android does not require tables to have a primary field, but some classes, such as the <kbd>SimpleCursorAdapter</kbd>, may require an <kbd>_id</kbd>.</p>
<p>We're required to implement the <kbd>onUpgrade()</kbd> callback, but as this is a new database, there's nothing to do. This method will only be called when the database version is incremented.</p>
<p>The <kbd>saveRecord()</kbd> method handles calling <kbd>addRecord()</kbd> or <kbd>updateRecord()</kbd>, as appropriate. Since we are going to modify the database, both methods use <kbd>getWritableDatabase()</kbd> to get an updatable database reference. A writable database requires more resources so if you don't need to make changes, get a read-only database instead.</p>
<p>The last method to note is <kbd>getWordList()</kbd>, which returns all the words in the database using a cursor object. We use this cursor to populate the <kbd>ListView</kbd>, which brings us to <kbd>ActivityMain.java</kbd>. The <kbd>onCreate()</kbd> method does the standard initialization we've seen before and also creates an instance of the database with the following line of code:</p>
<pre>mDB = new DictionaryDatabase(this); </pre>
<p>The <kbd>onCreate()</kbd> method is also where we set up the events to show the word definition (with a Toast) when an item is pressed and to delete the word on a long press. Probably the most complicated code is in <kbd>updateWordList()</kbd>.</p>
<p>This isn't the first time we've used an adapter, but this is the first cursor adapter, so we'll explain. We use the <kbd>SimpleCursorAdapter</kbd> to create a mapping between our field in the cursor and the <kbd>ListView</kbd> item. We use the <kbd>layout.simple_list_item_1</kbd> layout, which only includes a single text field with the ID <kbd>android.R.id.text1</kbd>. In a real application, we'd probably create a custom layout and include the definition in the <kbd>ListView</kbd> item, but we wanted to demonstrate a method to read the definition from the database.</p>
<p>We call <kbd>updateWordList()</kbd> in three places: during <kbd>onCreate()</kbd> to create the initial list, then again after we add/update an item, and lastly when deleting an item.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Although this is a fully functioning example of SQLite, it is still just the basics. There are many books dedicated to SQLite for Android and they are worth checking out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Upgrading a database</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, when we increment the database version, the <kbd>onUpgrade()</kbd> method will be called. What you do here is dependent on the changes made to the database. If you changed an existing table, ideally you'll want to migrate the user data to the new format by querying the existing data and inserting it into the new format. Keep in mind that there is no guarantee the user will upgrade in consecutive order, so they could jump from version 1 to version 4, for example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>SQLite homepage: <a href="https://www.sqlite.org/"><span class="URLPACKT">https://www.sqlite.org/</span></a></li>
<li>SQLite database Android reference: <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html"><span class="URLPACKT">http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing data in the background using a Loader</h1>
                </header>
            
            <article>
                
<p>Any potentially long-running operations should not be done on the UI thread, as this can cause your application to be slow or become unresponsive. The Android OS will bring up the <strong>Application Not Responding</strong> (<strong>ANR</strong>) dialog when apps become unresponsive.</p>
<p>Since querying databases can be time-consuming, Android introduced the Loader API in Android 3.0. A Loader processes the query on a background thread and notifies the UI thread when it finishes.</p>
<p>The two primary benefits to Loaders are the following:</p>
<ul>
<li>Querying the database is (automatically) handled on a background thread</li>
<li>The query auto-updates (when using a Content Provider data source)</li>
</ul>
<p>To demonstrate a Loader, we will modify the previous SQLite database example to use a <kbd>CursorLoader</kbd> to populate <kbd>ListView</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will use the project from the previous example, <em>Creating and using an SQLite database,</em> as the base for this recipe. Create a new project in Android Studio and call it <kbd>Loader</kbd>. <span class="s1">Use the default </span><span class="s2">Phone &amp; Tablet</span><span class="s1"> options and select </span><span class="s2">Empty Activity</span><span class="s1"> on the </span><span class="s2">Add an Activity to Mobile</span><span class="s1"> dialog. </span>Copy the <kbd>DictionaryDatabase</kbd> class and the layout from the previous recipe. Although we will use parts of the previous <kbd>ActivityMain.java</kbd> code, we will start at the beginning in this recipe to make it easier to follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With the project set up as described in <em>Getting ready</em>, we'll continue by creating two new Java classes, and then tie it all together in <kbd>ActivityMain.java</kbd>. Here are the steps:</p>
<ol>
<li>Create a new Java class called <kbd>DictionaryAdapter</kbd> that extends <kbd>CursorAdapter</kbd>. This class replaces the <kbd>SimpleCursorAdapater</kbd> used in the previous recipe. Here is the full code:</li>
</ol>
<pre style="padding-left: 60px"><span>public class </span>DictionaryAdapter <span>extends </span>CursorAdapter {<br/>    <span>public </span><span>DictionaryAdapter</span>(Context context<span>, </span>Cursor c<span>, int </span>flags) {<br/>        <span>super</span>(context<span>, </span>c<span>, </span>flags)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public </span>View <span>newView</span>(Context context<span>, </span>Cursor cursor<span>, </span>ViewGroup parent) {<br/>        <span>return </span>LayoutInflater.<span>from</span>(context)<br/>                .inflate(android.R.layout.<span>simple_list_item_1</span><span>,</span>parent<span>, false</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>bindView</span>(View view<span>, </span>Context context<span>, </span>Cursor cursor) {<br/>        TextView textView = view.findViewById(android.R.id.<span>text1</span>)<span>;<br/></span><span>        </span>textView.setText(cursor.getString(getCursor().getColumnIndex(<span>"word"</span>)))<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="2">
<li>Next, create another new Java class and call this one <kbd>DictionaryLoader</kbd>. Although this is the class that handles the data loading on the background thread, it's actually very simple:</li>
</ol>
<pre style="padding-left: 60px"><span>public class </span>DictionaryLoader <span>extends </span>CursorLoader { <br/>    Context <span>mContext</span><span>;<br/></span><span>    public </span><span>DictionaryLoader</span>(Context context) {<br/>        <span>super</span>(context)<span>;<br/></span><span>        </span><span>mContext </span>= context<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public </span>Cursor <span>loadInBackground</span>() {<br/>        DictionaryDatabase db = <span>new </span>DictionaryDatabase(<span>mContext</span>)<span>;<br/></span><span>        return </span>db.getWordList()<span>;<br/></span><span>    </span>}<br/>} </pre>
<ol start="3">
<li>Next, open <kbd>ActivityMain.java</kbd>. We need to change the declaration to implement the <kbd>LoaderManager.LoaderCallbacks&lt;Cursor&gt;</kbd> interface as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>public class </span>MainActivity <span>extends </span>AppCompatActivity <br/>    <span>implements </span>LoaderManager.LoaderCallbacks&lt;Cursor&gt; {</pre>
<ol start="4">
<li>Add the adapter to the global declarations. The complete list is as follows:</li>
</ol>
<pre style="padding-left: 60px">EditText mEditTextWord; 
EditText mEditTextDefinition; 
DictionaryDatabase mDB; 
ListView mListView; 
DictionaryAdapter mAdapter; </pre>
<ol start="5">
<li>Change <kbd>onCreate()</kbd> to use the new adapter and add a call to update the Loader after deleting a record. The final <kbd>onCreate()</kbd> method should look as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>protected void </span><span>onCreate</span>(Bundle savedInstanceState) {<br/>    <span>super</span>.onCreate(savedInstanceState)<span>;<br/></span><span>    </span>setContentView(R.layout.<span>activity_main</span>)<span>;<br/></span><span><br/></span><span>    </span><span>mDB </span>= <span>new </span>DictionaryDatabase(<span>this</span>)<span>;<br/></span><span><br/></span><span>    </span><span>mEditTextWord </span>= findViewById(R.id.<span>editTextWord</span>)<span>;<br/></span><span>    </span><span>mEditTextDefinition </span>= findViewById(R.id.<span>editTextDefinition</span>)<span>;    <br/></span><span>    </span>Button buttonAddUpdate = findViewById(R.id.<span>buttonAddUpdate</span>)<span>;<br/></span><span>    </span>buttonAddUpdate.setOnClickListener(<span>new </span>View.OnClickListener() {<br/>        <span>@Override<br/></span><span>        </span><span>public void </span><span>onClick</span>(View v) {<br/>            saveRecord()<span>;<br/></span><span>        </span>}<br/>    })<span>;<br/></span><span><br/></span><span>    </span><span>mListView </span>= findViewById(R.id.<span>listView</span>)<span>;<br/></span><span>    </span><span>mListView</span>.setOnItemClickListener(<span>new </span>AdapterView.OnItemClickListener() {<br/>        <span>@Override<br/></span><span>        </span><span>public void </span><span>onItemClick</span>(AdapterView&lt;?&gt; parent<span>, </span>View view<span>, int </span>position<span>, long </span>id) {<br/>            Toast.<span>makeText</span>(MainActivity.<span>this,<br/></span><span>                    </span><span>mDB</span>.getDefinition(id)<span>,<br/></span><span>                    </span>Toast.<span>LENGTH_SHORT</span>).show()<span>;<br/></span><span>        </span>}<br/>    })<span>;<br/></span><span>    </span><span>mListView</span>.setOnItemLongClickListener(<span>new </span>AdapterView.OnItemLongClickListener() {<br/>        <span>@Override<br/></span><span>        </span><span>public boolean </span><span>onItemLongClick</span>(AdapterView&lt;?&gt; parent<span>, </span>View view<span>, int </span>position<span>, long </span>id) {<br/>            Toast.<span>makeText</span>(MainActivity.<span>this, </span><span>"Records deleted = " </span>+ <span>mDB</span>.deleteRecord(id)<span>,<br/></span><span>                    </span>Toast.<span>LENGTH_SHORT</span>).show()<span>;<br/></span><span>            </span>getSupportLoaderManager().restartLoader(<span>0</span><span>, null, </span>MainActivity.<span>this</span>)<span>;<br/></span><span>            return true;<br/></span><span>        </span>}<br/>    })<span>;<br/></span><span>    </span>getSupportLoaderManager().initLoader(<span>0</span><span>, null, this</span>)<span>;<br/></span><span>    </span><span>mAdapter </span>= <span>new </span>DictionaryAdapter(<span>this,</span><span>mDB</span>.getWordList()<span>,</span><span>0</span>)<span>;<br/></span><span>    </span><span>mListView</span>.setAdapter(<span>mAdapter</span>)<span>;<br/></span>}</pre>
<ol start="6">
<li>We no longer have the <kbd>updateWordList()</kbd> method, so change <kbd>saveRecord()</kbd><br/>
as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>private void </span><span>saveRecord</span>() {<br/>    <span>mDB</span>.saveRecord(<span>mEditTextWord</span>.getText().toString()<span>, </span><span>mEditTextDefinition</span>.getText().toString())<span>;<br/></span><span>    </span><span>mEditTextWord</span>.setText(<span>""</span>)<span>;<br/></span><span>    </span><span>mEditTextDefinition</span>.setText(<span>""</span>)<span>;<br/></span><span>    </span>getSupportLoaderManager().restartLoader(<span>0</span><span>, null, </span>MainActivity.<span>this</span>)<span>;<br/></span>}</pre>
<ol start="7">
<li>Finally, implement these three methods for the Loader interface:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>public </span>Loader&lt;Cursor&gt; <span>onCreateLoader</span>(<span>int </span>id<span>, </span>Bundle args) {<br/>    <span>return new </span>DictionaryLoader(<span>this</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>onLoadFinished</span>(Loader&lt;Cursor&gt; loader<span>, </span>Cursor data) {<br/>    <span>mAdapter</span>.swapCursor(data)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>onLoaderReset</span>(Loader&lt;Cursor&gt; loader) {<br/>    <span>mAdapter</span>.swapCursor(<span>null</span>)<span>;<br/></span>}</pre>
<ol start="8">
<li>Run the program on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The default <kbd>CursorAdapter</kbd> requires a Content Provider URI. Since we are accessing the SQLite database directly (and not through a Content Provider), we don't have a URI to pass, so instead, we created a custom adapter by extending the <kbd>CursorAdapter</kbd> class. <kbd>DictionaryAdapter</kbd> still performs the same functionality as <kbd>SimpleCursorAdapter</kbd> from the previous recipe, namely mapping the data from the cursor to the item layout.</p>
<p>The next class we added was <kbd>DictionaryLoader</kbd>, which handles populating the adapter. As you can see, it's actually very simple. All it does is return the cursor from <kbd>getWordList()</kbd>. The key here is that this query is being handled in a background thread and will call the <kbd>onLoadFinished()</kbd> callback (in <kbd>MainActivity.java</kbd>) when it finishes. Fortunately, most of the heavy lifting is handled in the base class.</p>
<p>This takes us to <kbd>ActivityMain.java</kbd>, where we implemented the following three callbacks from the <kbd>LoaderManager.LoaderCallbacks</kbd> interface:</p>
<ul>
<li><kbd>onCreateLoader()</kbd>: It's initially called in <kbd>onCreate()</kbd> with the <kbd>initLoader()</kbd> call. It's called again with the <kbd>restartLoader()</kbd> call after we make changes to the database.</li>
<li><kbd>onLoadFinished()</kbd>: It's called when the Loader <kbd>loadInBackground()</kbd> finishes.</li>
<li><kbd>onLoaderReset()</kbd>: It's called when the Loader is being recreated (such as with the <kbd>restart()</kbd> method). We set the old cursor to <kbd>null</kbd> because it will be invalidated and we don't want a reference kept around.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As you saw in the previous example, we need to manually notify the Loader to re-query the database using <kbd>restartLoader()</kbd>. One of the benefits of using a Loader is that it can auto-update, but it requires a Content Provider as the data source. A Content Provider supports using an SQLite database as the data source and is recommended for a serious application. (See the following Content Provider link to get started.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>AsyncTask</em> recipe in <a href="01fd07ae-9274-4fb2-a536-bc3ed6ec088c.xhtml"><span class="ChapterrefPACKT">Chapter 14</span></a>, <em>Location and Using Geofencing</em>.</li>
<li>Creating a Content Provider: <a href="http://developer.android.com/guide/topics/providers/content-provider-creating.html"><span class="URLPACKT">http://developer.android.com/guide/topics/providers/content-provider-creating.html</span></a>.</li>
</ul>
<ul>
<li>It's also worth checking out Paging and LiveData in the Android Jetpack Components: <a href="https://developer.android.com/jetpack/">https://developer.android.com/jetpack/</a>.</li>
<li>The Loader (and AsyncTask) are both included in the Android SDK. A non-SDK option (and highly recommended) is RXJava for Android: <a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a>. RXJava is gaining popularity on Android and we're seeing more and more support for RXJava observables.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing external storage with scoped directories in Android N</h1>
                </header>
            
            <article>
                
<p>With security awareness on the rise, users are becoming more skeptical about allowing apps to have unnecessary permissions. Android N introduces a new option called Scoped Directory Access, allowing your application to request access to only the required permissions, instead of general access to all folders.</p>
<p>If your application requests <kbd>READ_EXTERNAL_STORAGE</kbd> and/or <kbd>WRITE_EXTERNAL_STORAGE</kbd> permission, but only needs access to a specific directory, you can use Scoped Directory access instead. This recipe will demonstrate how to request access to a specific directory, the <kbd>Music</kbd> folder in this case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Create a new project in Android Studio and call it <kbd>ScopedDirectoryAccess</kbd></span><span>.</span> <span>In the <span class="packt_screen">Target Android Device</span> dialog, be sure to select <span class="packt_screen">API 24: Android 7.0 (Nougat)</span> or higher for the </span><span class="packt_screen">Phone &amp; Tablet</span><span> option. S</span><span class="s1">elect </span><span class="s2"><span class="packt_screen">Empty Activity</span></span><span class="s1"> on the </span><span class="s2"><span class="packt_screen">Add an Activity to Mobile</span></span><span class="s1"> dialog.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To initiate the user access request, we'll add a button to the layout. Start by opening <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>TextView</kbd> with this button XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Request Access"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"onAccessClick"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent" </span><span>/&gt;</span></pre>
<ol start="2">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following line of code to the class:</li>
</ol>
<pre style="padding-left: 60px"><span>private final int </span><span>REQUEST_FOLDER_MUSIC</span>=<span>101</span><span>;</span></pre>
<ol start="3">
<li>Add the method to handle the button click:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>onAccessClick</span>(View view) {<br/>    StorageManager storageManager = (StorageManager)getSystemService(Context.<span>STORAGE_SERVICE</span>)<span>;<br/></span><span>    </span>StorageVolume storageVolume = storageManager.getPrimaryStorageVolume()<span>;<br/></span><span>    </span>Intent intent = storageVolume.createAccessIntent(Environment.<span>DIRECTORY_MUSIC</span>)<span>;<br/></span><span>    </span>startActivityForResult(intent<span>, </span><span>REQUEST_FOLDER_MUSIC</span>)<span>;<br/></span>}</pre>
<ol start="4">
<li>Override the <kbd>onActivityResult()</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>protected void </span><span>onActivityResult</span>(<span>int </span>requestCode<span>, int </span>resultCode<span>, </span>Intent data) {<br/>    <span>super</span>.onActivityResult(requestCode<span>, </span>resultCode<span>, </span>data)<span>;<br/></span><span>    switch </span>(requestCode) {<br/>        <span>case </span><span>REQUEST_FOLDER_MUSIC</span>:<br/>            <span>if </span>(resultCode == Activity.<span>RESULT_OK</span>) {<br/>                getContentResolver().takePersistableUriPermission(data.getData()<span>, </span><span>0</span>)<span>;<br/></span><span>            </span>}<br/>            <span>break;<br/></span><span>    </span>}<br/>}</pre>
<ol start="5">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The access request is handled by the OS, not by the app. To request access, we need to call <kbd>createAccessIntent()</kbd>, which we do with this line of code:</p>
<pre>Intent intent = storageVolume.createAccessIntent(Environment.<span>DIRECTORY_MUSIC</span>)<span>;</span></pre>
<p>We call the Intent using the <kbd>startActivityForResult()</kbd> method, which we’ve used before. Since we are looking for a result to come back, we need to pass a unique identifier to know when the returned result callback is from our request. (The <kbd>onActivityResult()</kbd> callback method can receive callbacks for multiple requests.) If the request code matches our request, we then check whether the result code equals <kbd>Activity.RESULT_OK</kbd>, which means the user granted the permission request. We pass the result to <kbd>takePersistableUriPermission()</kbd> so we will not need to prompt the user the next time we need to access the same directory. </p>
<div class="packt_infobox">
<p>Access to a directory also includes access to all sub-directories.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>For the best user experience, observe the following best practices:</p>
<ol>
<li>Make sure to persist the URI after the user grants permission to avoid repeatedly requesting the same permission (as we do with <kbd>takePersistableUriPermission()</kbd>)</li>
<li>If the user denies the permission request, don't annoy your users by continuously asking</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>See the following link for more information on the Storage Access Framework: <a href="http://developer.android.com/guide/topics/providers/document-provider.html">http://developer.android.com/guide/topics/providers/document-provider.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>