- en: Chapter 11. Implementing In-App Purchases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In-App Purchase is an optional feature, which developers can use to embed a
    store directly within an app. Sometimes you may want to extend more features in
    your current game to keep your consumers interested in playing. Here's your chance
    and possibly more revenue in your pocket!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This chapter only concerns with In-App Purchases in the Apple iTunes Store
    for the iOS platform. If you are a paid Corona SDK subscriber, In-App Purchase
    support for Android via Google''s Google Play Store (not available on Kindle Fire
    and Nook) is available in the Daily Builds page starting with build 2012.760\.
    The Daily Builds can be found at: [http://developer.anscamobile.com/downloads/daily-builds](http://developer.anscamobile.com/downloads/daily-builds).
    Android developers who want to implement In-App Purchases in their apps can use
    this as an alternative.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We''ll cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumable, non-consumable, and subscription purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring purchased items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing Corona's store module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and testing In-App Purchases on a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready, set, go!
  prefs: []
  type: TYPE_NORMAL
- en: The wonders of In-App Purchase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of implementing In-App Purchase is to add an in-app payment functionality
    to collect payment for enhanced functionality or additional content usable in
    your game. The following are options of incorporating this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: A game that offers new level packs to play outside of the default content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A freemium game that allows you to purchase virtual currency to create/build
    new assets during gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding additional characters or special power ups to enhance game elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some examples that can be done with In-App Purchases.
  prefs: []
  type: TYPE_NORMAL
- en: In-App Purchases allow users to purchase additional content within an application.
    The App Store manages transaction information only. Developers cannot use the
    App Store to deliver content. So, either you bundle content with your app when
    you ship it waiting to be unlocked upon purchase, or you have to work out your
    own system to download the data if you wish to deliver content.
  prefs: []
  type: TYPE_NORMAL
- en: Types of In-App Purchases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several In-App Purchase types you can apply in your apps. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumable:** These are products that must be purchased each time the user
    needs that item. They''re typically a one-time service, such as money in an app
    where you need to pay for supplies to build structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-consumable:** These are products that only need to be purchased once
    by the user. This could be additional level packs in a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto-renewable subscription:** These are products that allow the user to
    purchase in-app content for a set duration of time. An example of an auto-renewable
    subscription would be a magazine or newspaper that takes advantage of the auto-renewing
    functionality built into iOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free subscriptions:** These are used to put free subscription content in
    newsstands. Once a user signs up for a free subscription, it will be available
    on all devices associated with the user''s Apple ID. Note that free subscriptions
    do not expire and can only be offered in newsstand-enabled apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-renewing subscriptions:** Similar to auto-renewable subscriptions, this
    is a non-renewing subscription that requires a user to renew each time the subscription
    is due to expire. Your app must contain code that recognizes when the expiration
    occurs. It must also prompt the user to purchase a new subscription. An auto-renewable
    subscription eliminates these steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corona's store module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying In-App Purchases in your application can be a little mind-boggling
    and a tedious process. Integrating it with Corona requires calling the `store`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `store` module is already incorporated into the Corona API, similar to
    Facebook and Game Network. You can find more information on Corona''s `store`
    module at the following URL: [http://developer.anscamobile.com/reference/in-app-purchases](http://developer.anscamobile.com/reference/in-app-purchases).'
  prefs: []
  type: TYPE_NORMAL
- en: store.init()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This must be called when handling store transactions to your app. It activates
    In-App Purchases and allows you to receive callbacks with the listener function
    you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`listener`—This function that will handle transaction callback events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following blocks determine the transaction states that can occur during
    an In-App Purchase. The four different states are: purchased, restored, cancelled,
    and failed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: event.transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object containing the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transaction object supports the following read-only properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state`—A string containing the state of the transaction. Valid values are`"purchased",
    "restored", "cancelled"`, and`"failed"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`productIdentifier`—The product identifier associated with the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`receipt`—A unique receipt returned from the store. It is returned as a hexadecimal
    string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identifier`—A unique transaction identifier returned from the store. It is
    a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`—The date of when the transaction occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`originalReceipt`—A unique receipt returned from the store from the original
    purchase attempt. This is mostly relevant in a case of a restore. It is returned
    as a hexadecimal string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`originalIdentifier`—A unique transaction identifier returned from the store
    from the original purchase attempt. This is mostly relevant in a case of a restore.
    It is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`originalDate`—The date of when the original transaction occurred. This is
    mostly relevant in a case of a restore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errorType`—The type of error that occurred when the state is`"failed"` (a
    string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errorString`—A descriptive error message of what went wrong in the`"failed"`
    case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: store.loadProducts()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method retrieves information about items available for sale. This includes
    the price of each item, a name, and a description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrayOfProductIdentifiers`—An array with each element containing a string
    of the Product ID of the In-App product you want to know about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listener`—A callback function that is invoked when the store finishes retrieving
    the product information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: The following block displays the list of products that are available in the
    app. Information about the product can be retrieved from the `loadProductsCallback()`
    function and determines whether it is valid or invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: event.products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `store.loadProducts()` returns its requested list of products, you can
    access the array of product information through the `event.products` property.
  prefs: []
  type: TYPE_NORMAL
- en: Product information such as title, description, price, and the product identifier
    is contained in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entry in the `event.products` array supports the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`—The localized name of the item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`—The localized description of the item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price`—The price of an item (as a number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`productIdentifier`—The product identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: event.invalidProducts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `store.loadProducts()` returns its requested list of products, any products
    you requested that are not available for sale will be returned in an array. Access
    the array of invalid products through the `event.invalidProducts` property.
  prefs: []
  type: TYPE_NORMAL
- en: It is a Lua array containing the product identifier string requested from `store.loadProducts()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: store.canMakePurchases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This returns true if purchases are allowed, false otherwise. Corona's API can
    check if purchasing is possible. iOS devices provide a setting that disables purchasing.
    This can be used to avoid purchasing apps accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: store.purchase()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`store.purchase()` Initiates a purchase transaction on a provided list of products.'
  prefs: []
  type: TYPE_NORMAL
- en: This function will send out purchase requests to the store. The listener specified
    in `store.init()` will be invoked when the store finishes processing the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrayOfProducts`—An array specifying the products you want to buy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: store.finishTransaction()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method notifies the App Store that a transaction is complete.
  prefs: []
  type: TYPE_NORMAL
- en: After you finish handling a transaction, you must call `store.finishTransaction()`
    on the transaction object. If you don't do this, the App Store will think your
    transaction was interrupted and will attempt to resume it on the next application
    launch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transaction` - The transaction object belonging to the transaction you want
    to mark as finished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: store.restore()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any previously purchased items that have been wiped clean from a device or upgraded
    to a new device can be restored on the users account without paying for the product
    again. The `store.restore()` API initiates this process. Transactions can be restored
    by the `transactionCallback` listener, which is registered with `store.init()`.
    Transaction state will be`"restored"` and your app may then make use of the`"originalReceipt",
    "originalIdentifier"`, and`"originalDate"` fields of the transaction object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: The block will run through the `transactionCallback()` function and determine
    if a product has been previously purchased from the application. If the result
    is true, `store.restore()` will initiate the process of retrieving the product
    without asking the user to pay for it again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create an In-App Purchase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before reading on, make sure you know how to create an App ID and Distribution
    Provisioning Profile from the iOS Provisioning Portal. Also, make sure you already
    know how to manage new applications in iTunes Connect. If you''re unsure, please
    refer to [Chapter 10](ch10.html "Chapter 10. Optimizing, Testing, and Shipping
    your Games"), *Optimizing, Testing, and Shipping your Games*, for more information.
    The following are the things that need to be ready in your app before creating
    an In-App Purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: A Distribution Certificate already made for your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explicit App ID for your application that is, `com.companyname.appname`.
    Do not substitute a wild-card character (asterisk *). The **Bundle ID** needs
    to be completely unique to use the In-App Purchase function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ad-hoc Distribution Provisioning Profile (used for testing In-App Purchases).
    When you're ready to submit an app with In-App Purchase, an App Store Distribution
    Provisioning Profile is required.![Create an In-App Purchase](img/1888_11_01.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have your application information set up in iTunes Connect. You do not have
    to have your binary uploaded to create or test In-App Purchases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that you already have an iOS Paid Applications contract in effect
    with Apple. If you don't have, you'll need to request one in **Contracts, Tax,
    and Banking** located on the iTunes Connect home page. You will need to provide
    your banking and tax information in order to offer In-App Purchases in your apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action—creating the In-App Purchase in iTunes Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be implementing an In-App Purchase through iTunes Connect and create a
    scenario in a sample application that will call a transaction. Let's create the
    Product ID that will use in our In-App Purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to iTunes Connect. On the home page, select **Manage Your Applications**.
    Select the application you plan to add an In-App Purchase to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you're on the app summary page, click on the **Manage In-App Purchases**
    button and then click on the **Create New** button on the top-left corner.![Time
    for action—creating the In-App Purchase in iTunes Connect](img/1888_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be brought to a page that shows you a summary of the type of In-App
    Purchases you can create. For this example, **Non-Consumable** is selected. We'll
    be creating a product that only needs to be purchased once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next page is the area you fill in the information about the product.
    The information applies to consumable, non-consumable, and non-renewing Subscription
    In-App Purchases. Fill out the **Reference Name** and **Product ID** for your
    product. The **Product ID** needs to be a unique identifier and can be any alphanumeric
    sequence of letters and numbers (that is, `com.companyname.appname.productid).`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Auto-Renewable subscriptions require you to generate a shared secret. If you
    are to use Auto-Renewable Subscriptions in your app, then on the **Manage in-App
    Purchases** page, click on the **View or generate a shared secret** link. You
    will be brought to a page to generate the shared secret. Click on the **Generate**
    button. The shared secret will display a string of 32 randomly generated alphanumeric
    characters. When you choose Auto-Renewable Subscriptions, the difference from
    the other In-App Purchase types is that you have to choose the duration between
    auto-renewals of your product. For more information on Auto-Renewable Subscriptions,
    go to: [https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf](http://https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—creating the In-App Purchase in iTunes Connect](img/1888_11_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the **Add Language** button. Select the language that will be used
    for the In-App Purchase. Add a **Display Name** for your product and a short description
    about it. When you're done, click on the **Save** button.![Time for action—creating
    the In-App Purchase in iTunes Connect](img/1888_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Pricing and Availability**, make sure that **Yes** is selected for **Cleared
    for Sale**. In the **Price Tier** drop-down menu, select the price you plan to
    sell your In-App Purchase. In this example, **Tier 1** is selected. In **Screenshot
    for Review**, you'll need to upload a screenshot of your In-App Purchase. If you're
    testing on an ad-hoc build, the screenshot is not necessary. Once you're ready
    for distribution, the screenshot is required so the In-App Purchase can be reviewed
    upon submittal. Click on the **Save** button when done.![Time for action—creating
    the In-App Purchase in iTunes Connect](img/1888_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a summary of the In-App Purchase you created on the next page.
    Click on the **Done** button if all the information looks correct.![Time for action—creating
    the In-App Purchase in iTunes Connect](img/1888_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a new In-App Purchase is a rather simple process. The information contained
    in the **Product ID** is what will be called upon during a transaction. Managing
    the type of In-App Purchase is entirely up to what type of product you want to
    sell in your game. This example demonstrates the purpose of taking a non-consumable
    product that represents purchasing/unlocking a new level in a game. It's a common
    scenario for users that want to sell level packs.
  prefs: []
  type: TYPE_NORMAL
- en: Your application does not have to be completed to test In-App Purchases. All
    that is required is to have your application information set up in iTunes Connect
    so you can manage In-App Purchase features.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—using the Corona store module to create an In-App Purchase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have set up our Product ID for our In-App Purchase in iTunes Connect,
    we can implement it into our app to purchase the product we're going to sell.
    A sample menu app of **Breakout** was created to demonstrate how to purchase levels
    within an application. The app contains two levels in the level select screen.
    The first one is available by default and the second one is locked and can only
    be unlocked by purchasing it for $0.99\. We're going to create a level select
    screen so it acts in that manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chapter 11` folder, copy the `Breakout In-App Purchase Demo` project
    folder to your desktop. You can download the project files accompanying this book
    from the Packt website. You will notice that the configuration, libraries, assets
    and `.lua` files needed are included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new levelselect.lua file and save it to the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the scene with the following variables and saving/loading functions.
    The most important variable of all is `local store = require("store")` which calls
    the `store` module for In-App Purchases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `createScene()` event and remove the`"mainmenu", "level1"`, and`"level2"`
    scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the `enterScene()` event and an array that contains a string of
    the **Product ID** set as an In-App Purchase in iTunes Connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a local blank table for `validProducts` and `invalidProducts`. Create a
    local function called `unpackValidProducts()` that checks valid and invalid Product
    IDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a local function called `loadProductsCallback()` with an `event` parameter.
    Set up the handler to receive product information with `print` statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a local function called `transactionCallback()` with an `event` parameter.
    Add in several cases of results that are supposed to occur for every `transaction.state`.
    When the store is done with the transaction, call `store.finishTransaction(event.transaction)`
    before the end of the function. Set up another local function called `setUpStore()`
    with an `event` parameter to call `store.loadProducts(listOfProducts, loadProductsCallback)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the display objects for the background and level 1 button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the level 2 button placement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the local `onBuyLevel2Touch(event)` function and create an `if` statement
    to check when `event.phase == ended and level2Unlocked ~= tonumber(loadedLevel2Unlocked)`
    so the scene changes to `mainmenu.lua`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the same `if` statement, create a local function called `buyLevel2()`
    with a `product` parameter to call the `store.purchase()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in an `elseif` statement to check when level 2 has been purchased and unlocked
    once the transaction has been completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Activate the In-App Purchase with `store.init()` and call `transactionCallback()`
    as the parameter. Also call `setupMyStore()` with a timer set at 500 milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the close UI button and a local function called `onCloseTouch()` with
    an event parameter. Set the function transition scenes to `loadmainmenu.lua` upon
    release of the close button. Close the `enterScene()` event with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `exitScene()` and `destroyScene()` events. Within the `exitScene()`
    event, cancel the `menuTimer` timer. Add in all the event listeners to the scene
    events and `return scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and run the project in the Corona simulator. When you select the
    **Play** button, you will notice a **1** button and a **Locked** button on the
    level select screen. By pressing the **Locked** button it calls the store to make
    a transaction. You will notice a `print` statement in the terminal that displays
    what **Product ID** is being referred to for purchase. The full In-App Purchase
    features cannot be tested in the simulator. You will have to create a distribution
    build and upload it to an iOS device to instigate a purchase in the store.![Time
    for action—using the Corona store module to create an In-App Purchase](img/1888_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we used the `saveValue()` and `loadValue()` functions from
    the `BeebeGames` class to implement how our locked level will go from locked to
    unlocked using movieclips as buttons. The array in `local listOfProducts` displays
    a Product ID in a string format. The **Product ID** in this example needs to be
    a non-consumable In-App Purchase type and has to be an existing one in iTunes
    Connect.
  prefs: []
  type: TYPE_NORMAL
- en: The `unpackValidProducts()` function checks how many valid and invalid items
    are in the In-App Purchase. The `loadProductsCallback()` function receives the
    product information in the store. The `transactionCallback(event)` function checks
    every state—`"purchased","restored", "cancelled"`, and`"failed"`. When a`"purchased"`
    state is achieved within the In-App Purchase, the `saveValue()` function is called
    to change the value of `level2.data`. When the transaction is completed, `store.finishTransaction(event.transaction)`
    needs to be called to tell the store you are done with your purchase.
  prefs: []
  type: TYPE_NORMAL
- en: The `setupMyStore(event)` function calls `store.loadProducts(listOfProducts,
    loadProductsCallback)` and checks the available Product ID(s) in the application.
    The event is handled once `store.init(transactionCallback)` is initialized and
    `setupMyStore()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `onBuyLevel2Touch(event)` function allows us to check when an In-App Purchase
    has been made for the locked level. When the user is able to purchase and accepts
    the In-App Purchase, the transaction is processed and the value of `level2Unlocked`
    will match that of `tonumber(loadedLevel2Unlocked)`. The `buyLevel2(product)`
    function validates the purchased item with `store.purchase()` once the Product
    ID returns valid.
  prefs: []
  type: TYPE_NORMAL
- en: After the In-App Purchase, the screen transitions to the main menu to allow
    the **Locked** button to change to the level **2** button. Once the button has
    changed to frame 2, level 2 is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—handling multiple product IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to create an In-App Purchase for one product, try adding
    more than one in the same application. The scenarios are open-ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More levels for purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New characters the user can play as if your game has a feature user character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New background scenes for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you handle new products for your store is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Testing In-App Purchases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want to make sure that purchases work correctly. Apple provides a sandbox
    environment that allows you to test your app In-App Purchases. The sandbox environment
    uses the same model as the App Store, but does not process actual payments. Transactions
    return as if payments were processed successfully. It is a requirement to test
    In-App Purchases in a sandbox environment before submitting them for review by
    Apple.
  prefs: []
  type: TYPE_NORMAL
- en: When testing in the sandbox environment, you'll need to create a separate user
    test account that is different from your current iTunes Connect account. Using
    your current account is not allowed to test your store in the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: User test accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While logged into your iTunes Connect account, you'll have to select the **Manage
    Users** link from the home page. Select **Test User** on the **Select User Type**
    page. Add a new user and make sure that the test account uses an e-mail address
    that is not associated with any other Apple account. All test accounts should
    only be used in the test environment when testing In-App Purchases. Click on the
    **Save** button when all the information is filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Once your user test account is created, you'll have to make sure that you're
    signed out of your Apple account in the **Store** settings of your device. This
    will keep non-test accounts from being used when testing In-App Purchases. You're
    only allowed to sign in to your user test account when prompted in the In-App
    Purchase sandbox when testing your application. Do not sign in to your test account
    before the application is launched. This will prevent it from invalidating your
    test account.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—testing the In-App Purchase with the Breakout In-App Purchase
    demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can test an In-App Purchase on an iOS device, make sure that you
    have a test user account already made in iTunes Connect. Also, make sure that
    you created a distribution build using an ad-hoc Distribution Provisioning Profile
    for the app to test In-App Purchase features. If you followed all the earlier
    steps in this chapter, testing a purchase through the store will work accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the Corona simulator, create a distribution build of the Breakout In-App
    Purchase Demo. Once the build has been compiled, upload the build to your iOS
    device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep your device connected to your machine and launch Xcode. In the toolbar,
    select **Windows** | **Organizer**. Once you're in **Organizer**, select the device
    that is connected in the **Devices** section and then select **Console**. This
    will allow you to check the console output of your device to catch debug messages
    from your code, (that is, `print` statements) and any application crashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before launching the application, you'll need to select the **Settings** icon
    on your device. Scroll up until you see the **Store** icon and select it.![Time
    for action—testing the In-App Purchase with the Breakout In-App Purchase demo](img/1888_11_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign out of your iTunes Store account if you're logged in so you can test In-App
    Purchases in the sandbox environment.![Time for action—testing the In-App Purchase
    with the Breakout In-App Purchase demo](img/1888_11_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the Breakout In-App Purchase demo from your device. Select the **Play**
    button and then select the **Locked** button. The screen will transition back
    to the main menu and a window will pop up to confirm your In-App Purchase. Click
    on **OK** to continue with the purchase.![Time for action—testing the In-App Purchase
    with the Breakout In-App Purchase demo](img/1888_11_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next you will be greeted with another window to sign in with your Apple ID.
    This is where you will log in with your test user account you created in iTunes
    Connect. Do not sign in with your actual Apple account ID used to log in to iTunes
    Connect.![Time for action—testing the In-App Purchase with the Breakout In-App
    Purchase demo](img/1888_11_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you're logged in, select the **Play** button again. You will notice that
    the **2** button has been unlocked. When you select it, you will have access to
    that scene.![Time for action—testing the In-App Purchase with the Breakout In-App
    Purchase demo](img/1888_11_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of the app and refer to the console. You will notice the output from
    the device and some familiar `print` statements from our code. The console log
    displays the **Product ID** used for the In-App Purchase and informs you if it
    is valid and if the transaction was successful.![Time for action—testing the In-App
    Purchase with the Breakout In-App Purchase demo](img/1888_11_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to make sure that the In-App Purchase actually worked, delete the
    application from your device and log out of your user test account. Upload the
    same build to your device. No need to create a new one. Launch the application
    and run the In-App Purchase again. Log in using the same user test account. You
    should receive a pop-up window that mentions you already purchased the product
    and asks you if you want to download it again for free. Receiving a notification
    means your In-App Purchase was successful!![Time for action—testing the In-App
    Purchase with the Breakout In-App Purchase demo](img/1888_11_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to follow the In-App Purchase test steps accordingly. To make
    sure you're getting accurate results in the sandbox environment, signing out of
    your Apple account from the **Store** settings is the key to this whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch the application and call the store function by clicking on the
    **Locked** button, you will notice the display name and price of the In-App Purchase.
    It should match what you created in iTunes Connect if you implemented it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When you log in using the test user account you created in iTunes Connect, the
    transaction should go through without any errors assuming there are no server
    issues on Apple's side or connection problems on the device. **Level 2** on the
    level select screen will be unlocked and accessible. Congratulations! You have
    created an In-App Purchase!
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—using other In-App Purchase types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Breakout In-App Purchase demo, we focused more on non-consumable In-App
    Purchases. Try integrating consumable, auto-renewable subscriptions, or non-renewing
    subscriptions to your own apps.
  prefs: []
  type: TYPE_NORMAL
- en: Apps that feature consumable products are games that require currency to buy
    or build things in a free-to-play environment. Subscription products can be focused
    towards games that are never-ending and are constantly updated with new levels
    or may require an online server to interact in a multiplayer environment. See
    what you can come up with!
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz—all about In-App Purchases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are non-consumable purchases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Products that only need to be purchased once by the user.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. Products that need to be purchased each time the user needs the item.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. Products that allow the user to purchase content for a set duration of time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. A subscription that requires a user to renew it each time it expires.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is true about testing In-App Purchases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. You need to be logged in to your account at all times.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. Your Apple account is used to test In-App Purchases.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. Log in to your user test account when prompted in In-App Purchase sandbox.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of Provisioning Profile must be used to test In-App Purchases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Development Provisioning Profile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. Ad-hoc Distribution Provisioning Profile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. App Store Distribution Provisioning Profile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can finally see the light at the end of the tunnel. By now, you should have
    an idea on how to implement In-App Purchases in to your games. It is a very lengthy
    process to organize, set up the code, and testing accurate purchases in the sandbox
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following were discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Product IDs for In-App Purchases in iTunes Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing purchase items using Corona's `store` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding test user accounts in iTunes Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing In-App Purchases on a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grasping the concept of In-App Purchasing can take some time. It is best to
    study the sample code and review the functions pertaining to Corona's `store`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out Apple''s In-App Purchase Programming Guide at: [https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf](http://https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf)
    and the In-App Purchases in the API Reference section of Anscamobile''s site:
    [http://developer.anscamobile.com/reference/index/app-purchases](http://developer.anscamobile.com/reference/index/app-purchases)
    for more references pertaining to this topic.'
  prefs: []
  type: TYPE_NORMAL
- en: After 11 chapters, we have reached the end of this book. You now have obtained
    enough knowledge to create your own applications to sell in the App Store or Google
    Play Store. Hopefully all the information you have acquired has been helpful.
    I look forward to hearing about the games you have developed using Corona SDK!
  prefs: []
  type: TYPE_NORMAL
