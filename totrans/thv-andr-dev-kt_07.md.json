["```kt\n[versions]\n...\ncamerax = \"1.2.1\"\naccompanist = \"0.31.1-alpha\"\n[libraries]\n...\ncameraCore = { module = \"androidx.camera:camera-core\", version.ref = \"camerax\" }\ncameraCamera2 = { module = \"androidx.camera:camera-camera2\", version.ref = \"camerax\" }\ncameraView = { module = \"androidx.camera:camera-view\", version.ref = \"camerax\" }\ncameraExtensions = { module = \"androidx.camera:camera-extensions\", version.ref = \"camerax\" }\naccompanist = { group = \"com.google.accompanist\", name = \"accompanist-permissions\", version.ref = \"accompanist\"}\n```", "```kt\n    implementation(libs.cameraCore)\n    implementation(libs.cameraCamera2)\n    implementation(libs.cameraView)\n    implementation(libs.cameraExtensions)\n    implementation(libs.androidx.camera.lifecycle)\n    implementation(libs.accompanist)\n```", "```kt\n@Composable\nfun CameraPreviewWithImageAnalysis() {\n    val cameraProvider = rememberCameraProvider()\n    val preview = remember { Preview.Builder().build() }\n    val text = remember { mutableStateOf(\"Analyzing...\") }\n    val imageAnalyzer = ImageAnalysis.Builder()\n        .setAnalyzer { image ->\n            // Process the image data here\n            text.value = \"Detected image to analyze...\"\n        }\n        .build()\n    LaunchedEffect(cameraProvider) {\n        val useCaseBinding = UseCaseBinding.Builder()\n            .addUseCases(preview, imageAnalyzer)\n            .build()\n        val camera =\n            cameraProvider.bindToLifecycle(useCaseBinding)\n        camera.close()\n    }\n    Box(modifier = Modifier.fillMaxSize()) {\n        Preview(preview)\n        Text(text.value)\n    }\n}\n```", "```kt\n@Composable\nfun BarcodeScannerPreview() {\n    val cameraProvider = rememberCameraProvider()\n    val preview = remember { Preview.Builder().build() }\n    val barcodeText = remember { mutableStateOf(\"\") }\n    val barcodeScanner = BarcodeScanner.Builder()\n        .setBarcodeFormats(BarcodeScannerOptions.\n            BarcodeFormat.ALL_FORMATS)\n        .build()\n    LaunchedEffect(cameraProvider) {\n        val imageAnalyzer = ImageAnalysis.Builder()\n            .setAnalyzer { image ->\n                val rotation =\n                    image.imageInfo.rotationDegrees\n                val imageProxy =\n                    InputImage.fromMediaImage(image.image,\n                        rotation)\n                barcodeScanner.processImage(imageProxy)\n                    .addOnSuccessListener { barcodes ->\n                        if (barcodes.isNotEmpty()) {\n                            val barcode = barcodes[0]\n                            barcodeText.value =\n                                barcode.displayValue\n                        } else {\n                            barcodeText.value = \"No barcode\n                                detected\"\n                        }\n                    }\n                    .addOnFailureListener { e ->\n                        barcodeText.value = \"Barcode\n                            scanning failed: ${e.message}\"\n                    }\n            }\n            .build()\n        val useCaseBinding = UseCaseBinding.Builder()\n            .addUseCases(preview, imageAnalyzer)\n            .build()\n        val camera =\n            cameraProvider.bindToLifecycle(useCaseBinding)\n        camera.close()\n    }\n    Box(modifier = Modifier.fillMaxSize()) {\n        Preview(preview)\n        Text(barcodeText.value)\n    }\n}\n```", "```kt\n@Composable\nfun CameraSelectorExample() {\n    val cameraProvider = rememberCameraProvider()\n    val preview = remember { Preview.Builder().build() }\n    val isUsingFrontCamera = remember {\n        mutableStateOf(true) }\n    val cameraSelector = remember {\n        if (isUsingFrontCamera.value) {\n            CameraSelector.DEFAULT_FRONT_CAMERA\n        } else {\n            CameraSelector.DEFAULT_BACK_CAMERA\n        }\n    }\n    val imageAnalyzer = ImageAnalysis.Builder()\n        .setAnalyzer { image ->\n            // Process the image data here\n        }\n        .build()\n    LaunchedEffect(cameraProvider) {\n        val useCaseBinding = UseCaseBinding.Builder()\n            .addUseCases(preview, imageAnalyzer)\n            .build()\n        val camera =\n            cameraProvider.bindToLifecycle(useCaseBinding)\n        camera.close()\n    }\n    Box(modifier = Modifier.fillMaxSize()) {\n        Preview(preview)\n        Column {\n            Button(onClick = {\n                isUsingFrontCamera.value =\n                    !isUsingFrontCamera.value\n            }) {\n                Text(\"Switch Camera\")\n            }\n        }\n    }\n}\n```", "```kt\n@Composable\nfun CameraControlsExample() {\n    val cameraProvider = rememberCameraProvider()\n    val preview = remember { Preview.Builder().build() }\n    val zoomLevel = remember { mutableStateOf(1.0f) }\n    val focusPoint = remember { mutableStateOf(0.5f, 0.5f) }\n    val isTorchEnabled = remember { mutableStateOf(false) }\n    val imageAnalyzer = ImageAnalysis.Builder()\n        .setAnalyzer { image ->\n            // Process the image data here\n        }\n        .build()\n```", "```kt\n    LaunchedEffect(cameraProvider) {\n        val cameraControl =\n            cameraProvider.getCameraControl(preview)\n        cameraControl.setZoomRatio(zoomLevel.value)\n        cameraControl.setFocusPoint(focusPoint.value)\n        cameraControl.enableTorch(isTorchEnabled.value)\n        val useCaseBinding = UseCaseBinding.Builder()\n            .addUseCases(preview, imageAnalyzer)\n            .build()\n        val camera =\n            cameraProvider.bindToLifecycle(useCaseBinding)\n        camera.close()\n    }\n```", "```kt\n    Box(modifier = Modifier.fillMaxSize()) {\n        Preview(preview)\n        Column {\n            Slider(\n                value = zoomLevel.value,\n                onValueChange = { zoomLevel.value = it },\n                valueRange = 1.0f..5.0f,\n                steps = 10\n            ) {\n                Text(\"Zoom\")\n            }\n            Button(onClick = {\n                val newFocusPoint = if (focusPoint.value ==\n                0.5f) {\n                    0.1f to 0.1f\n                } else {\n                    0.5f to 0.5f\n                }\n                focusPoint.value = newFocusPoint\n                cameraControl.setFocusPoint(newFocusPoint)\n            }) {\n                Text(\"Adjust Focus\")\n            }\n            Button(onClick = {\n                isTorchEnabled.value =\n                    !isTorchEnabled.value\n                cameraControl.enableTorch(\n                    isTorchEnabled.value)\n            }) {\n                Text(\"Toggle Torch\")\n            }\n        }\n    }\n}\n```", "```kt\n<uses-permission android:name=\"android.permission.CAMERA\" />\n```", "```kt\nimport com.google.accompanist.permissions.ExperimentalPermissionsApi\nimport com.google.accompanist.permissions.PermissionState\nimport com.google.accompanist.permissions.rememberPermissionState\n@OptIn(ExperimentalPermissionsApi::class)\n@Composable\nfun CameraPermissionRequester(onPermissionGranted: () -> Unit) {\n    // ... code ...\n}\n```", "```kt\nval cameraPermissionState = rememberPermissionState(Manifest.permission.CAMERA)\n```", "```kt\n@OptIn(ExperimentalPermissionsApi::class)\n@Composable\nfun CameraPermissionRequester(onPermissionGranted:\n@Composable () -> Unit) {\n```", "```kt\n    // Camera permission state\n    val cameraPermissionState = rememberPermissionState(\n        android.Manifest.permission.CAMERA\n    )\n```", "```kt\n    if (cameraPermissionState.status.isGranted) {\n        OnPermissionGranted.invoke()\n```", "```kt\n    } else {\n                Surface(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(16.dp)\n                        .padding(top = 24.dp),\n                    color =\n                      MaterialTheme.colorScheme.background,\n        ) {\n            Column(\n                modifier = Modifier.padding(16.dp),\n                verticalArrangement =\n                    Arrangement.spacedBy(12.dp),\n                horizontalAlignment =\n                    Alignment.CenterHorizontally\n            ) {\n                val textToShow = if\n                (cameraPermissionState.shouldShowRationale)\n                {\n                    \"The camera and record audio are\n                     important for this app. Please grant\n                     the permissions.\"\n                } else {\n                    \"Camera permission is required for this\n                     feature to be available. Please grant\n                     the permission.\"\n                }\n                Text(\n                    text = textToShow,\n                    style =\n                    MaterialTheme.typography.bodyLarge.copy\n                    (\n                        fontSize = 16.sp,\n                        fontWeight = FontWeight.Medium\n                    ),\n                    color =\n                    MaterialTheme.colorScheme.onBackground\n                )\n                Button(\n                    onClick = { cameraPermissionState\n                        .launchMultiplePermissionRequest()\n                        },\n                    colors = ButtonDefaults.buttonColors(\n                        containerColor =\n                        MaterialTheme.colorScheme.primary,\n                        contentColor =\n                        MaterialTheme.colorScheme.onPrimary\n                    ),\n                    contentPadding = PaddingValues(12.dp)\n                ) {\n                    Text(\"Request Permission\",\n                        fontSize = 14.sp,\n                            fontWeight = FontWeight.Bold)\n                }\n            }\n        }\n    }\n}\n```", "```kt\n@Composable\n@Composable\nfun CameraPreview(cameraController:\nLifecycleCameraController, modifier: Modifier = Modifier) {\n    AndroidView(\n        factory = { context ->\n            PreviewView(context).apply {\n                implementationMode =\n                  PreviewView.ImplementationMode.COMPATIBLE\n            }\n        },\n        modifier = modifier,\n        update = { previewView ->\n            previewView.controller = cameraController\n        }\n    )\n}\n```", "```kt\n    CameraPermissionRequester {\n        Box(contentAlignment = Alignment.BottomCenter,\n        modifier = Modifier.fillMaxSize()) {\n            CameraPreview(\n                cameraController = cameraController,\n                modifier = Modifier.fillMaxSize()\n            )\n        }\n    }\n```", "```kt\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            MediaStore.Images.Media.getContentUri(\n                MediaStore.VOLUME_EXTERNAL_PRIMARY)\n        } else {\n            MediaStore.Images.Media.EXTERNAL_CONTENT_URI\n        }\n}\n```", "```kt\nclass SaveCaptureUseCase(private val context: Context) {\n}\n```", "```kt\n    suspend fun save(capturePhotoBitmap: Bitmap):\n    Result<Uri> = withContext(Dispatchers.IO) {\n        val resolver: ContentResolver =\n            context.applicationContext.contentResolver\n        val imageCollection = getImageCollectionUri()\n        val nowTimestamp = System.currentTimeMillis()\n        val imageContentValues =\n            createContentValues(nowTimestamp)\n        val imageMediaStoreUri: Uri? =\n            resolver.insert(imageCollection,\n                imageContentValues)\n        return@withContext imageMediaStoreUri?.let { uri ->\n            saveBitmapToUri(resolver, uri,\n                capturePhotoBitmap, imageContentValues)\n        } ?: Result.failure(Exception(\"Couldn't create file\n                                       for gallery\"))\n    }\n```", "```kt\n    private fun getImageCollectionUri(): Uri =\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)\n        {\n            MediaStore.Images.Media.getContentUri(\n                MediaStore.VOLUME_EXTERNAL_PRIMARY)\n        } else {\n            MediaStore.Images.Media.EXTERNAL_CONTENT_URI\n        }\n```", "```kt\nprivate fun createContentValues(timestamp: Long):\nContentValues = ContentValues().apply {\n        put(MediaStore.Images.Media.DISPLAY_NAME,\n            \"$FILE_NAME_PREFIX${System.currentTimeMillis()}\n                .jpg\")\n        put(MediaStore.Images.Media.MIME_TYPE, \"image/jpg\")\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)\n        {\n            put(MediaStore.MediaColumns.DATE_TAKEN,\n                timestamp)\n            put(MediaStore.MediaColumns.RELATIVE_PATH,\n                \"${Environment.DIRECTORY_DCIM}/Packtagram\")\n            put(MediaStore.MediaColumns.IS_PENDING, 1)\n        }\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R)\n        {\n            put(MediaStore.Images.Media.DATE_ADDED,\n                timestamp)\n            put(MediaStore.Images.Media.DATE_MODIFIED,\n                timestamp)\n            put(MediaStore.Images.Media.AUTHOR,\n                AUTHOR_NAME)\n            put(MediaStore.Images.Media.DESCRIPTION,\n                DESCRIPTION)\n        }\n    }\n```", "```kt\n    private fun saveBitmapToUri(\n        resolver: ContentResolver,\n        uri: Uri,\n        bitmap: Bitmap,\n        contentValues: ContentValues\n    ): Result<Uri> = kotlin.runCatching {\n       resolver.openOutputStream(uri).use { outputStream ->\n           checkNotNull(outputStream) { \"Couldn't create\n               file for gallery, MediaStore output stream\n                   is null»}`\n           bitmap.compress(Bitmap.CompressFormat.JPEG,\n               IMAGE_QUALITY, outputStream)\n        }\n```", "```kt\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)\n        {\n            contentValues.clear()\n            contentValues.put(\n                MediaStore.MediaColumns.IS_PENDING, 0)\n            resolver.update(uri, contentValues, null, null)\n        }\n        return Result.success(Unit)\n    }.getOrElse { exception ->\n        exception.message?.let(::println)\n        resolver.delete(uri, null, null)\n        return Result.failure(exception)\n    }\n}\n```", "```kt\ncompanion object {\n    private const val IMAGE_QUALITY = 100\n    private const val FILE_NAME_PREFIX = \"YourImageName\"\n    private const val AUTHOR_NAME = \"Your Name\"\n    private const val DESCRIPTION = \"Your description\"\n}\n```", "```kt\nclass StoryEditorViewModel(\n    private val saveCaptureUseCase: SaveCaptureUseCase\n): ViewModel() {\n    private val _isEditing = MutableStateFlow(false)\n    val isEditing: StateFlow<Boolean> = _isEditing\n    private val _imageCaptured: MutableStateFlow<Uri> =\n        MutableStateFlow(Uri.EMPTY)\n    val imageCaptured: StateFlow<Uri> = _imageCaptured\n    fun storePhotoInGallery(bitmap: Bitmap) {\n        viewModelScope.launch {\n            val imageUri =\n                saveCaptureUseCase.save(bitmap).getOrNull()\n            if (imageUri != null) {\n                _imageCaptured.value = imageUri\n                _isEditing.value = true\n            }\n    }\n}\n```", "```kt\n@Composable\nfun StoryContent(\n    isEditing: Boolean = false,\n    onImageCaptured: (Bitmap) -> Any,\n    modifier: Modifier = Modifier,\n) { ... }\n```", "```kt\nfun capturePhoto(\n        context: Context,\n        cameraController: LifecycleCameraController,\n        onPhotoCaptured: (Bitmap) -> Unit,\n        onError: (Exception) -> Unit\n    ) {\n```", "```kt\nval mainExecutor: Executor =\nContextCompat.getMainExecutor(context)\n```", "```kt\n        cameraController.takePicture(mainExecutor,\n        @ExperimentalGetImage object :\n        ImageCapture.OnImageCapturedCallback() {\n            override fun onCaptureSuccess(image:\n            ImageProxy) {\n                try {\n                    CoroutineScope(Dispatchers.IO).launch {\n                        val correctedBitmap: Bitmap? =\n                            image\n                                ?.image\n                                ?.toBitmap()\n                                ?.rotateBitmap(image\n                                    .imageInfo\n                                    .rotationDegrees)\n                        correctedBitmap?.let {\n                            withContext(Dispatchers.Main) {\n                                onPhotoCaptured(\n                                    correctedBitmap)\n                            }\n                        }\n                        image.close()\n                    }\n                } catch (e: Exception) {\n                    onError(e)\n                } finally {\n                    image.close()\n                }\n            }\n            override fun onError(exception:\n            ImageCaptureException) {\n                Log.e(\"CameraContent\", \"Error capturing\n                    image\", exception)\n                onError(exception)\n            }\n        })\n    }\n```", "```kt\nOutlinedButton(\n                    onClick = { capturePhoto(\n                        context = localContext,\n                        cameraController =\n                            cameraController,\n                        onPhotoCaptured = {\n                            onImageCaptured(it) },\n                        onError = { /* Show error */ }\n                            )\n                    },\n                    modifier = Modifier.size(50.dp),\n                    shape = CircleShape,\n                    border = BorderStroke(4.dp,\n                        MaterialTheme.colorScheme.primary),\n                    contentPadding = PaddingValues(0.dp),\n                    colors =\n                        ButtonDefaults.outlinedButtonColors\n                            (contentColor =\n                                MaterialTheme.colorScheme\n                                    .primary)\n                ) {\n                }\n```", "```kt\n@Composable\nfun BlackAndWhiteFilter(\n    imageUri: Uri,\n    modifier: Modifier = Modifier\n) {\n    var isBlackAndWhiteEnabled by remember {\n    mutableStateOf(false) }\n    val localContext = LocalContext.current\n    Box(modifier = modifier.fillMaxSize()) {\n        Canvas(modifier = Modifier.fillMaxSize()) {\n            getBitmapFromUri(localContext, imageUri)?.let {\n                val imageBitMap = it.asImageBitmap()\n                val colorFilter = if\n                (isBlackAndWhiteEnabled) {\n                    val colorMatrix = ColorMatrix().apply {\n                        setToSaturation(0f) }\n                    ColorFilter.colorMatrix(colorMatrix)\n                } else {\n                    null\n                }\n                val (offsetX, offsetY) =\n                    getCanvasImageOffset(imageBitMap)\n                val scaleFactor =\n                    getCanvasImageScale(imageBitMap)\n                with(drawContext.canvas) {\n                    save()\n                    translate(offsetX, offsetY)\n                    scale(scaleFactor, scaleFactor)\n                    drawImage(\n                        image = imageBitMap,\n                        topLeft =\n                            androidx.compose.ui.geometry\n                                .Offset.Zero,\n                        colorFilter = colorFilter\n                    )\n                    restore()\n                }\n            }\n        }\n        Button(\n            onClick = { isBlackAndWhiteEnabled =\n                !isBlackAndWhiteEnabled },\n            modifier = Modifier.padding(16.dp)\n        ) {\n            Text(\"Apply Black and White Filter\")\n        }\n    }\n}\n```", "```kt\n@Composable\nfun ImageWithTextOverlay(capturedBitmap: Bitmap) {\n    var textOverlay = remember { mutableStateOf(\"Add your\n        text here\") }\n    var showTextField = remember { mutableStateOf(false) }\n    Box(modifier = Modifier.fillMaxSize()) {\n        Image(\n            bitmap = capturedBitmap.asImageBitmap(),\n            contentDescription = \"Captured Image\",\n            modifier = Modifier.matchParentSize()\n        )\n        if (showTextField) {\n            TextField(\n                value = textOverlay,\n                onValueChange = { textOverlay = it },\n                modifier = Modifier\n                    .align(Alignment.Center)\n                    .padding(16.dp)\n            )\n        }\n        Text(\n            text = textOverlay,\n            color = Color.White,\n            fontSize = 24.sp,\n            modifier = Modifier.align(Alignment.Center)\n        )\n        FloatingActionButton(\n            onClick = { showTextField = !showTextField },\n            modifier = Modifier\n                .align(Alignment.BottomEnd)\n                .padding(16.dp)\n        ) {\n            Icon(Icons.Default.Edit, contentDescription =\n                \"Edit Text\")\n        }\n    }\n}\n```", "```kt\n@Composable\nfun ImageWithTextOverlay(capturedBitmap: Bitmap) {\n    var textOverlay = remember { mutableStateOf(\"Your text\n        here\") }\n    var showTextField = remember { mutableStateOf(false) }\n    var textPosition by remember {\n        mutableStateOf(Offset.Zero) }\n```", "```kt\n    val imageModifier = Modifier.fillMaxSize()\n    Box(modifier = Modifier.fillMaxSize()) {\n        Image(\n            bitmap = capturedBitmap.asImageBitmap(),\n            contentDescription = \"Captured Image\",\n            modifier = imageModifier\n        )\n        if (showTextField) {\n            TextField(\n                value = textOverlay,\n                onValueChange = { textOverlay = it },\n                modifier = Modifier\n                    .align(Alignment.Center)\n                    .padding(16.dp)\n            )\n        }\n        DraggableText(\n            text = textOverlay,\n            position = textPosition,\n            onPositionChange = { newPosition ->\n                textPosition = newPosition },\n            modifier = Modifier\n                .offset { IntOffset(textPosition.x.toInt(),\n                    textPosition.y.toInt()) }\n                .align(Alignment.Center)\n        )\n        FloatingActionButton(\n            onClick = { showTextField = !showTextField },\n            modifier = Modifier\n                .align(Alignment.BottomEnd)\n                .padding(16.dp)\n        ) {\n            Icon(Icons.Default.Edit, contentDescription =\n                \"Edit Text\")\n        }\n    }\n}\n```", "```kt\n@Composable\nfun DraggableText(\n    text: String,\n    position: Offset,\n    onPositionChange: (Offset) -> Unit,\n    modifier: Modifier = Modifier\n) {\n```", "```kt\n    var dragOffset = remember { mutableStateOf(position) }\n    Text(\n        text = text,\n        color = Color.White,\n        fontSize = 24.sp,\n        modifier = modifier\n            .offset {\n                IntOffset(dragOffset.value.x.roundToInt(),\n                    dragOffset.value.y.roundToInt()) }\n            .pointerInput(Unit) {\n                detectDragGestures { change, dragAmount ->\n                    change.consume()\n                    dragOffset.value =\n                        Offset((dragOffset.value.x +\n                            dragAmount.x),\n                                (dragOffset.value.y +\n                                    dragAmount.y))\n                    onPositionChange(dragOffset.value)\n                }\n            }\n            .background(\n                color = Color.Black.copy(alpha = 0.5f),\n                shape = RoundedCornerShape(8.dp)\n            )\n    )\n```", "```kt\n[versions]\n...\nml-labeling = \"17.0.5\"\n[libraries]\n...\nmlKitLabeling= { group = \"com.google.mlkit\", name = \"image-labeling\", version.ref=\"ml-labeling\"}\n```", "```kt\n    implementation(libs.mlKitLabeling)\n```", "```kt\n@Composable\nfun CameraPreviewWithImageLabeler(cameraController: LifecycleCameraController, modifier: Modifier = Modifier) {\n    val context = LocalContext.current\n    var labels by remember {\n        mutableStateOf<List<String>>(emptyList()) }\n    val cameraProviderFuture = remember {\n        ProcessCameraProvider.getInstance(context) }\n    val previewView = remember { PreviewView(context) }\n    val imageAnalysis = remember {\n        ImageAnalysis.Builder()\n            .setTargetResolution(Size(1280, 720))\n            .setBackpressureStrategy(\n                ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)\n            .build()\n    }\n    DisposableEffect(Unit) {\n        val cameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(\n                previewView.surfaceProvider)\n        }\n        val cameraSelector =\n            CameraSelector.DEFAULT_BACK_CAMERA\n        cameraProvider.bindToLifecycle(\n            context as LifecycleOwner, cameraSelector,\n                preview, imageAnalysis)\n        onDispose {\n            cameraProvider.unbindAll()\n        }\n    }\n    imageAnalysis.setAnalyzer(ContextCompat.getMainExecutor\n    (context)) { imageProxy ->\n        processImageProxyForLabeling(imageProxy) {\n        detectedLabels ->\n            labels = detectedLabels\n        }\n    }\n    Box(modifier = modifier) {\n        AndroidView(\n            factory = { previewView },\n            modifier = modifier\n        )\n        Canvas(modifier = Modifier.fillMaxSize()) {\n            drawIntoCanvas { canvas ->\n                val paint = android.graphics.Paint().apply\n                {\n                    color = android.graphics.Color.RED\n                    textSize = 60f\n                }\n                labels.forEachIndexed { index, label ->\n                    canvas.nativeCanvas.drawText(label,\n                        10f, 100f + index * 70f, paint)\n                }\n            }\n        }\n    }\n}\n```", "```kt\n@OptIn(ExperimentalGetImage::class)\nprivate fun processImageProxyForLabeling(imageProxy:\nImageProxy, onLabelsDetected: (List<String>) -> Unit) {\n    val mediaImage = imageProxy.image\n    if (mediaImage != null) {\n        val image = InputImage.fromMediaImage(mediaImage,\n            imageProxy.imageInfo.rotationDegrees)\n        val labeler =\n        ImageLabeling.getClient(\n            ImageLabelerOptions.DEFAULT_OPTIONS)\n        labeler.process(image)\n            .addOnSuccessListener { labels ->\n                val labelNames = labels.map { it.text }\n                onLabelsDetected(labelNames)\n            }\n            .addOnFailureListener { e ->\n                e.printStackTrace()\n            }\n            .addOnCompleteListener {\n                imageProxy.close()\n            }\n    }\n}\n```"]