- en: '*Chapter 2*: Working with Dark Mode'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all love it…well most of us do anyway, and those who do have been asking
    for it for a while now too. Apple first took the plunge into Dark Mode with macOS
    Mojave back in 2018, not only changing the way users interacted with the OS but
    also paving the way for developers to build native dark-themed apps for the first
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Dark mode for iPhone wasn't announced until WWDC 2019, but we all knew it was
    coming, and with everything that AppKit had offered, we knew we were in for a
    treat with what UIKit would have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover everything you need to know to get up and running
    with dark mode in iOS and iPadOS; everything from taking an existing app and making
    the necessary adjustments to support dark mode, to all the little hidden extras
    that we can add in when building our app to ensure we give the user the best possible
    experience. We'll also touch on best practices too – taking note of the little
    things we can do that allow Dark Mode in UIKit to make our lives so much easier
    from the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Dark Mode?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with views in Dark Mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further exploring Dark Mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for Xcode in the App Store and select and download the latest version.
    Launch Xcode and follow any additional installation instructions that your system
    may prompt you with. Once Xcode has fully launched, you're ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: What is Dark Mode?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll start by taking a look at what exactly Dark Mode is,
    how we can use it, and what it can do not only for the end user but also for developers.
    We'll cover everything from enabling it on our devices to using environment overrides
    in Xcode and developer options in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why we would need Dark Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I covered in the introduction of this chapter, most of us have been craving
    dark mode in iOS for a very long time now. Us developers got our Xcode fix back
    in 2018 – but one of the burning questions I've been asked many times (especially
    in the past 12 months) is…why?
  prefs: []
  type: TYPE_NORMAL
- en: It could be down to something as simple as the time of the day. Satellite navigation
    systems have been doing it in our cars for years – as soon as the sun goes down,
    our system switches, and a more relaxing, subtle version of our road home pops
    up on our screen – so why not do that for our apps?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns out that some apps have already been doing that for a while (to
    a degree), while not necessarily offering an automatic nocturnal mode. The Twitter
    app for iOS offered a "dark mode" option long before the WWDC 19 announcement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stop for a moment and think about the logic behind such a control, along
    with everything you''d need to change to achieve this. I''m sure a company as
    big as Twitter has written their own internal framework to handle this, but under
    the hood, it''s basically going look a lot like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Everything will have to be taken into consideration, from the text color to
    the drop shadows that you might have decorating your UIButton or UIViews.
  prefs: []
  type: TYPE_NORMAL
- en: The background is a massive change to consider too. One common pattern that
    a lot of iOS developers follow is to quite simply develop a brand-new app on top
    of a white canvas; from here, we don't need to worry about controlling the background
    color or keeping track of it with an IBOutlet – it's simply the tablecloth for
    the rest of our app to sit on.
  prefs: []
  type: TYPE_NORMAL
- en: With implementing a dark mode feature, everything needs to be changed – even
    asset images that sit proudly on one style of background could be lost in another.
    Let's take a look at some of the developer features that come bundled with Xcode
    when implementing Dark Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Core developer concepts of Dark Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at how we go about developing with Dark Mode
    by switching to it on our device. If you''ve not already done this, you can simply
    toggle it by going to **Settings** | **Display & Brightness**, and you should
    be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Display and brightness'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Display and brightness
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice the **Automatic** toggle option too, giving us the ability
    to use either **Sunset to Sunrise** or a custom schedule, which will automatically
    switch between light and dark appearance (just like our sat nav).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got that covered, let''s take a look at some options given
    to developers in the iOS simulator. Let''s start by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the simulator (**Xcode | Open Developer Tool | Simulator**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a slightly different location than the end user''s version of iOS, you''ll
    find the dark toggle under the developer settings (**Settings | Developer | Dark
    Appearance**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Dark mode developer settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Dark mode developer settings
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a fancy interface like we saw earlier, we're presented with just
    the standard toggle. Let's take a look now at what we can do as developers with
    Dark Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Dark mode from inside Xcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've taken a look at how iOS handles switching to dark mode, let's
    have a look at how we, the developer, can do the same in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, all new projects building against the iOS 13 SDK will automatically
    support dark mode; however, building against any earlier SDKs won't.
  prefs: []
  type: TYPE_NORMAL
- en: This helps out a little as your existing app may not have all the necessary
    tweaks to support dark mode yet and you don't want to release an update to find
    you have broken your app for those now running dark mode.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you update your project to the iOS 13 SDK, then you could potentially
    run into this problem, but don't worry, we'll cover getting your existing app
    ready for dark mode later, in the *Migrating existing apps to Dark Mode* section
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by having a look at storyboards – we all love them (or hate them)
    but the one thing they have done over the years is present themselves on a whiter-than-white
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode and create a new **Single View - Storyboard** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this anything you want (I'll call mine `Chapter 2 - Dark Mode`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can either follow along throughout this chapter or download the sample code
    from GitHub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once created, click on **Main.Storyboard** and you should be presented with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Xcode interface style'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Xcode interface style
  prefs: []
  type: TYPE_NORMAL
- en: I've highlighted in the preceding screenshot our area of interest – here, we
    have a preview toggle for both light and dark appearances from within the storyboard,
    so at a quick glance, we can see what the objects we've added to our canvas look
    like without the need to launch the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this won't always help us as some of our UILabels or UIButtons could be
    decorated programmatically. However, it's a great start and will most definitely
    come in useful during the development cycle of any app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our labels in action. Here, we''ve added a UILabel straight
    out of the box. **Light Appearance** is selected, and the label looks just how
    we are used to seeing things at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Main storyboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Main storyboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s switch the toggle to **Dark Appearance** and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Main storyboard – dark mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Main storyboard – dark mode
  prefs: []
  type: TYPE_NORMAL
- en: As if by magic, our canvas enters dark mode, and the color of our UILabel is
    automatically adjusted. We can see straight away, without the need to compile
    or run the app on a device or in the simulator, how it will look with each interface
    style.
  prefs: []
  type: TYPE_NORMAL
- en: I guess the million-dollar question is *how did iOS know to switch the color
    of the UILabel's font?* Good question, and we'll cover that in more detail in
    the *Working with views and Dark Mode* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, as I mentioned earlier, there are going to be occasions where you'll
    need to test your app in the simulator. Labels and views will not always be static
    and could be generated dynamically – this is where environment overrides come
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by launching our app in the simulator. Once successfully launched,
    you should see the following highlighted option available in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Environment Overrides'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Environment Overrides
  prefs: []
  type: TYPE_NORMAL
- en: Click on this icon and you'll be presented with the **Environment Overrides**
    popup. Here, you'll have the option to toggle the **Interface Style** overrides,
    which in turn will allow you to choose between light and dark appearance.
  prefs: []
  type: TYPE_NORMAL
- en: If you flick the toggle and switch between each option, you'll see your app
    in the simulator automatically update without the need to close your app, change
    the settings, and re-launch. Very nice indeed – thanks, Xcode!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last little thing to point out before we move on: we mentioned previously
    that existing apps built with previous iOS SDKs won''t be affected by dark mode,
    but should you choose to update your app to the iOS 13 SDK, you may run into a
    couple of issues.'
  prefs: []
  type: TYPE_NORMAL
- en: Tight deadlines and urgent bug fixes might not necessarily give you the chance
    to adopt dark mode in your app, so Xcode gives you the option to force light appearance
    regardless of the user's preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Info.plist` (or the `Light`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.7 – Info.plist – User Interface Style'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Info.plist – User Interface Style
  prefs: []
  type: TYPE_NORMAL
- en: You'll now see that even with the environment overrides, you won't be able to
    switch to dark mode.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we got up and running with Dark Mode in iOS and, more importantly,
    Xcode, and learned about the little things that Xcode does to get us ready for
    developing our apps in both light and dark appearance. In the next section, we'll
    begin to look at how Xcode handles views and introduce ourselves to semantic "dynamic"
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: Working with views in Dark Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've covered not only what dark mode is but also what
    it has to offer from a development perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to deep dive further into dark mode by looking
    at how Xcode dynamically handles our UIViews (and objects that are sub-classed
    from UIViews).
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by understanding the core concept behind adaptive and semantic colors,
    and by following a simple pattern, Xcode can do so much of the heavy lifting for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: We'll then dive further and take a look at the various levels of semantic colors
    available to us, including primary, secondary, and tertiary options, but more
    importantly, when we would be expected to use them.
  prefs: []
  type: TYPE_NORMAL
- en: What are adaptive colors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For me, this was a major step in getting developers on board with designing
    and developing their apps for dark mode and, of course, it was well within Apple's
    interest to make it as seamless as possible for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adaptive colors are a way of defining a single color type or style for a particular
    appearance. Let''s start by diving straight into Xcode and seeing this for ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: Head back on over to the project you previously created and highlight the UILabel
    we added in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, take a look at the **Color** property in the **Attributes Inspector**
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Label properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Label properties
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that the color selected is **Default (Label Color)** – **Label
    Color** is our adaptive color.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what does that mean? Actually, it''s very simple: it means that for one
    interface style it''s one color, and for the other, it''s a different color.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our previous example, our UILabel was black in light mode and
    white in dark mode – makes sense, right?
  prefs: []
  type: TYPE_NORMAL
- en: Well, to a degree is does, but surely it depends on what type of background
    our UILabel sits on – let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our storyboard, highlight the background of our view and again head
    over to the **Attributes Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Background color properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Background color properties
  prefs: []
  type: TYPE_NORMAL
- en: Again, here we have our adaptive color, **System Background Color**. Xcode is
    doing all the work for us when we need to switch appearances.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding parts in the section are a great example of contrasting between
    two primary colors (black and white used in our labels), which itself is the stereotypical
    understanding between what colors should be in light and dark appearance – but
    we're not always going to be using black or white, are we?
  prefs: []
  type: TYPE_NORMAL
- en: So, Apple has updated all their available system colors to be adaptive. Let's
    take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back over to Xcode and highlight our UILabel, and change **Color** to
    **System Indigo Color**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Font color properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Font color properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s switch between light and dark mode using the toggle in Xcode''s
    storyboard. What do we see? The color indigo, just as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Light mode with Indigo text color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Light mode with Indigo text color
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the screen with dark mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Dark mode with indigo text color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Dark mode with indigo text color
  prefs: []
  type: TYPE_NORMAL
- en: 'However, each system color has been specifically adapted to each appearance.
    Let''s take a look at the RGB values for each appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R 94: G 92: B 230`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R 88: G 86: B 214`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although there is a subtle difference in each RGB value, it has a massive effect
    in terms of appearance and allowing it to stand out against other adapted colors
    defined by Apple (such as our system background color).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned all about adaptive colors, let's take a look at semantic
    colors and how Apple helps us pre-define not only the colors we want to use but
    also where a type of color should be used.
  prefs: []
  type: TYPE_NORMAL
- en: What are semantic colors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To answer the questions of this section requires us to take a quick look back
    at what we already covered in the *What are adaptive colors?* section, because
    we've already touched on semantic colors.
  prefs: []
  type: TYPE_NORMAL
- en: Remember **Label Color** from our UILabel and **System Background Color**? These
    are all semantic colors – not so much by physical color, but more by their definition
    and intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: With semantic colors, Apple has created a whole pre-defined range of adaptive
    colors that are designed specifically for objects such as labels, backgrounds,
    and grouped content such as table views. Each of these has additional primary,
    secondary, and tertiary variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this into practice and update our current Xcode project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – UILabel with semantic variants'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – UILabel with semantic variants
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve added a couple more UILabels here and just done a little bit of re-arranging
    (nothing special), but what I have done is set the semantic variant for each **Label**
    with a corresponding variant – let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Color options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Color options
  prefs: []
  type: TYPE_NORMAL
- en: If we expand the color options for our UILabel, we can see a list of all the
    pre-defined adaptive/semantic and system and variant colors available to us. I've
    highlighted the colors I've chosen for each of the new labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s switch the appearance to dark and see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Semantic labels in Dark Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Semantic labels in Dark Mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go a step further and add some more adaptive content in there. Here,
    I''ve dropped in a UIView to act as a separator between content, a UIButton, which
    will be a URL link, and a UITableView:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Separators and other background colors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Separators and other background colors
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve assigned the following semantic colors to each of my new views:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separator**: **Separator Color**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Button**: **Link Color**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table View**: **Group Table View Background Color**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s fire this up in the iOS simulator and see side by side how it looks.
    You''ll notice something interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Table view in light and Dark Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Table view in light and Dark Mode
  prefs: []
  type: TYPE_NORMAL
- en: In the light appearance, you can clearly see the table view's group background
    color against the system background color; yet if we take a look at this in the
    dark appearance, you don't see it as much. That's because with a much darker primary
    background color, the separation isn't needed as much; the black on black doesn't
    get lost and looks more natural, whereas white on white does.
  prefs: []
  type: TYPE_NORMAL
- en: This all looks great built into Interface Builder, but now let's take a look
    at how we would do this programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Using the programmatic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating IBOutlets for each of our objects. If you''re unfamiliar
    with creating an outlet, simply, in `ViewController`, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare all our outlet properties first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, from the `IBOutlet` connector (just to the left of your property), press
    *Command* + *Primary Cursor Click*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold and drag this to the UIView or object you want to connect to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Opening both Interface Builder and `ViewController` in separate windows will
    really help this process too:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Creating an outlet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.18 – Creating an outlet
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll need to create these in our `ViewController.swift` file just inside
    the class declaration. Copy the following highlighted code into your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can programmatically assign our colors. Inside the `viewDidLoad()`
    function, add the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you launch the app in the simulator, you'll see that everything should stay
    the same. If we really want to test our logic, head back on over to Interface
    Builder and set one of our UILabels to **System Green Color**. Re-run the app
    and watch the programmatic code take precedence and override Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've looked at how working with views for Dark Mode either
    in Interface Builder or programmatically is possible with the use of adaptive
    and semantic colors. We also looked at and understood the value behind using color
    variations and saw the effect they both have in both light and dark appearance.
    In the next section, we'll take a look at the asset catalog and how we can create
    custom adaptive colors and images for use in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the asset catalog for Dark Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the ability to add colors to the asset catalog became available back in
    Xcode 9, there is now even more reason to take full advantage of one of Xcode's
    prized assets.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at how we can use the asset catalog not only to
    create our custom colors but also to create our own adaptive colors and images,
    allowing us to harness the power of Xcode when developing dynamic appearance applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom adaptive colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sticking with our current project, head on over to the file inspector, and
    highlight the `Assets.xcassets` folder. With the following layout visible, click
    on the **+** button highlighted in the following screenshot and select **New Color
    Set** from the list of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Creating a color set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Creating a color set
  prefs: []
  type: TYPE_NORMAL
- en: 'Add in another three color sets and name them the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`brandLabel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brandSecondaryLabel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brandTertiaryLabel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Highlight `brandLabel`, and then highlight the option in the central asset
    preview window. Notice the list of attribute options now made available to us
    in the **Attributes Inspector** pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Adding a color set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.20_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – Adding a color set
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can now define the `brandLabel` color that we want to use.
    But first, let's make it adaptive. In the **Attributes Inspector** pane, change
    **Appearance** from **None** to **Any, Light, Dark**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll have noticed on the dropdown that there was another option of **Any,
    Dark**, so let''s go through what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: This is a default color and won''t be adaptive to your selected appearance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any, Dark**: In this scenario, **Any** will support legacy versions of your
    app, along with any other variations that aren''t dark (so light, basically).
    **Dark** will be dark…'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any, Light, Dark**: Same as the preceding but will allow you to specifically
    select a value for legacy and light (along with dark).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, with that covered, let''s add some colors. Now, as mentioned before, this
    is where you can be really specific with your color choices, either by personal
    preference or brand guidelines you have to follow. For me, I''m just going to
    click **Show Color Picker** and pick my favorite colors:'
  prefs: []
  type: TYPE_NORMAL
- en: Tangerine for **Any (Legacy)** and light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A more subtle **Cantaloupe** for dark:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Choosing a color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.21_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – Choosing a color
  prefs: []
  type: TYPE_NORMAL
- en: Do the same for `brandSecondaryLabel` and `brandTertiaryLabel`, remembering
    to slightly alter the colors based on the semantic purpose you intend to use them
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done that, head back on over to Interface Builder and highlight
    `primaryLabel`, then bring open the options of colors from **Attributes Inspector**.
    You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Default label color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.22_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Default label color
  prefs: []
  type: TYPE_NORMAL
- en: 'All the color sets you created in the asset catalog are available to use right
    there in Interface Builder. Go ahead and add them in for each label and see how
    they look by switching appearance in Interface Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Color set, light mode versus dark mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.23_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23 – Color set, light mode versus dark mode
  prefs: []
  type: TYPE_NORMAL
- en: With that done, you've created your very own adaptive, semantic and dynamic
    colors for your app – all within the power of Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to use the colors programmatically, you can do that by simply
    referring to the asset name in a couple of different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'First is a direct reference to the name of the assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can select the asset directly from the media library by pressing
    *Shift* + *CMD* + *M* and selecting **show color palette** from the icon options
    and selecting the color you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will insert the color from the assets catalog as a swatch, directly inside
    your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Assigning a color set programmatically'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.24_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – Assigning a color set programmatically
  prefs: []
  type: TYPE_NORMAL
- en: 'Or another option, if you really wanted to keep your code clean, would be to
    create an extension of UIColor allowing you to define your own property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can now be used just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a nice, clean, and manageable way to look after your custom color sets
    programmatically, but this really is a personal preference, and each to their
    own. If you're working with a large alternative color guideline, making the change
    to a primary color in one extension will roll the change out to your entire app
    without the worry of missing a label or two.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at the same approach but for images.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom adaptive images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've learned a lot about how the asset catalog works with adaptive images from
    the previous section, *Custom adaptive colors*, and luckily, we can take full
    advantage of that in creating adaptive images for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that we created a new color set, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Head on back over to **Assets.xcassets**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new image set:![Figure 2.25 – New image set
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.25_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.25 – New image set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Name your new image **header**, highlight it, and change the appearance in
    the **Attributes Inspector** window to **Any, Dark**. You should now see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Add new image set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.26_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.26 – Add new image set
  prefs: []
  type: TYPE_NORMAL
- en: When adding an image to the image catalog, you'll be given the option for adding
    **1x**, **2x**, or **3x** images – these are different image scales you can set
    for various screen sizes. For further information, see the following from Apple's
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we are going to add in two different images to the **2x**
    option: one for **Any** and the other for **Dark**. You can grab the images I''ve
    used from the sample project found in GitHub or choose your own – it''s up to
    you. From the Finder, simply drag and drop the images into the **2x** placeholder
    inside Xcode. You should see the following once done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – New image set variants'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.27_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.27 – New image set variants
  prefs: []
  type: TYPE_NORMAL
- en: Now, head back on over to your storyboard and add in a UIImageView to your project.
    Add this to the top of `ViewController` to act as a header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in place, head on over to the **Attributes Inspector** pane and select
    the dropdown for the **Image** option – there, you should see your newly created
    asset, **header**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Setting header from the image set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.28_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.28 – Setting header from the image set
  prefs: []
  type: TYPE_NORMAL
- en: Select this and take a look (depending on the size of the image you chose, you
    may need to set **Content Mode** to **Aspect Fill** – these options can also be
    found in **Attributes Inspector**).
  prefs: []
  type: TYPE_NORMAL
- en: Run the simulator and have a look at everything you've achieved so far in this
    chapter, remembering to switch from light to dark appearance by using the environment
    override in Xcode… looks pretty good, right?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Header light mode versus dark mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.29_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.29 – Header light mode versus dark mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we did with color sets, we can of course handle this programmatically,
    should we wish. Let''s add another extension to our app to handle this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can again use this in just the same way as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We do this by assigning our header image directly onto our UIImageView.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we harnessed the power of the asset catalog to allow us to
    create custom adaptive and dynamic colors and images for our app. In the next
    section, we'll take a look at how best to update a legacy app to support dark
    mode with everything we've learned so far, and also how best to identify the little
    things we can do to futureproof our apps for various appearances.
  prefs: []
  type: TYPE_NORMAL
- en: Further exploring Dark Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we gave you a lot to think about when either creating
    or migrating existing apps to Dark Mode under specific circumstances. In this
    section, we'll take a look at a couple of little "nice to knows" that should always
    be in the back of your mind when approaching Dark Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dark Mode with SwiftUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the announcement of SwiftUI back in June 2019, a massive shift in focus
    on UI-based development took place. Released at the same time as Dark Mode, and
    as expected, SwiftUI takes full advantage of switching appearances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at how we could detect dark mode programmatically
    in SwiftUI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create an environment variable that allows us to access the current
    state of the appearance of the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s use a simple ternary operator to display some text based on the
    current appearance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It really is that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at the options available to us in the automatic preview
    window. SwiftUI uses `PreviewProvider`, which allows us to display dynamically
    what we are designing/developing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Dark Mode in `PreviewProvider`, simply add the following highlighted
    code and hot refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve added a modifier to set the `.colorScheme` environment variable
    to `.dark`. If we want to preview both `.light` and `.dark` side by side, we can
    simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about SwiftUI, take a look at *Learn SwiftUI*, available from
    Packt Publishing: [https://www.packtpub.com/business-other/learn-swiftui](https://www.packtpub.com/business-other/learn-swiftui).'
  prefs: []
  type: TYPE_NORMAL
- en: Programatically handling changes with trait collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the development of your new app, there could be a couple of occasions
    where you might need to handle a specific scenario based on the current appearance.
    However, we'll need to take a slightly different approach to this than what we
    did with the SwiftUI example previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface style is part of the `UITraitCollection` class (which, in turn,
    is part of UIKit). We can do a conditional check against a value using the following
    anywhere in our `ViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike SwiftUI, we can''t just use a simple ternary operator as there are more
    than two values for `userInterfaceStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Unspecified** is an option too (think **Any**, back in our asset catalog),
    so it''s best to use another approach when detecting changes to our interface
    style.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by heading back into our `ViewController.swift` file and adding
    in the following `override` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This override is called whenever a change is made to a trait (such as appearance).
    From this, we now action any changes we would like to make, but the problem we
    have is traits are used for more than just appearances, and this override could
    be called for a variety of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we are looking particularly for changes in our appearance, we can use
    the `previousTrait` property passed into our delegate function and compare against
    the current system trait – if there is a difference, we know the appearance has
    changed. Let''s take a look at how we''d do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By using the `hasDifferentColorAppearance` method, we can now easily compare
    the previous trains against the current one to see whether there have been any
    changes – the resulting method returns a Boolean, so we can use this at our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying an appearance for views, ViewControllers, and windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may, in some circumstances, wish to specify an appearance based on a particular
    area of your app or if you are migrating to dark mode (but need a little more
    time for a certain feature). Simply drop in the following appropriate code to
    meet your desire.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we''ll create and instantiate a basic UIView:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We assign either a light or dark value.
  prefs: []
  type: TYPE_NORMAL
- en: ViewController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we wanted to do this in a UIViewController, we would simply just do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, we assign either a light or dark value (usually within `viewDidLoad()`).
  prefs: []
  type: TYPE_NORMAL
- en: Window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we need to access the current window, we could do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: (This is not a recommended approach and you would be hard-pressed to find any
    real reason to want to do this…)
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility in Dark Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ask around and someone will joke about how **Dark Mode** has existed in iOS
    for years, either as the **Classic Invert** or **Smart Invert** accessibility
    feature. I even had it on one of my slides at a conference about 2 months prior
    to Dark Mode being officially announced.
  prefs: []
  type: TYPE_NORMAL
- en: But with this in mind, a lot of things started to be said about accessibility
    in iOS – some comments referring to Dark Mode as "Apple finally supporting accessibility,"
    which I have to be honest makes me very sad.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility has always played a massive part in iOS regardless of the appearance
    – but, even with the introduction of Dark Mode, this still goes unchanged as Dark
    Mode supports all accessibility features.
  prefs: []
  type: TYPE_NORMAL
- en: If you refer back to an earlier section in this chapter, *Core development concepts
    in Dark Mode*, you'll remember that we mentioned the option to schedule our light
    and dark appearances – much like you could with Nightshift that was introduced
    in iOS 9, again another element with a focus on accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went a little outside of the box with regard to Dark Mode
    and stepped away from the basic implementation, allowing us to look at the wider
    options available to use and things to think about when implementing Dark Mode
    in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered a lot about Dark Mode – not only from a programmatic
    perspective but also the theory behind the appearances and purpose of colors used
    within our apps.
  prefs: []
  type: TYPE_NORMAL
- en: We started by taking a look at how Xcode and iOS are set up for Dark Mode, learning
    about the environment overrides used in Xcode, and how we can even switch appearances
    in our storyboard while developing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered adaptive and semantic colors, and learned not only how these
    are used with Apple's default system colors but also how we can create dynamic
    and adaptive color sets ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Following on from what we learned about color sets, we applied this to images
    and harnesses the power of the assets catalog.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered some "great to know" topics, such as Dark Mode in SwiftUI,
    programmatically hailing appearances, and accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at lists in iOS 14, covering everything
    you need to know about UITableViews and UICollectionViews.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Apple human interface guidelines (dark mode)**: [https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apple human interface guidelines (color)**: [https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset catalog reference**: [https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
