<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Adding Physics with UIKit Dynamics"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Adding Physics with UIKit Dynamics</h1></div></div></div><p>This chapter will cover the basics of how UIKit Dynamics manages your application's behaviors. We will cover specific behaviors, such as gravity, bounce, and other physics properties. Additionally, we will learn how to create physical boundaries so that our views have something to collide with. Without these boundaries, our views would continue moving forever without stopping. We will cover how our views will interact with one another, including collision detection/notifications and attaching views to one another. Lastly, we will talk about motion effects and about creating a parallax effect similar to iOS 7's home screen that moves when tilting your device. We have a lot to cover, so let's get started!</p><div class="section" title="Motion and physics in UIKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Motion and physics in UIKit</h1></div></div></div><p>With the introduction of iOS 7, Apple completely removed the skeuomorphic design that has been used since the introduction of the iPhone and iOS. In its place is a new and refreshing flat design that features muted gradients and minimal interface elements. Apple has strongly encouraged developers to move away from a skeuomorphic and real-world-based design in favor of these flat designs.</p><p>Although we are guided<a id="id224" class="indexterm"/> away from a real-world <span class="emphasis"><em>look</em></span>, Apple also strongly encourages that your user interface have a real-world <span class="emphasis"><em>feel</em></span>. Some may think this is a contradiction; however, the goal is to give users a deeper connection to the user interface. UI elements that respond to touch, gestures, and changes in orientation are examples of how to apply this new design paradigm. In order to help assist in this new design approach, Apple has introduced two very nifty APIs, UIKit Dynamics and Motion Effects.</p><div class="section" title="UIKit Dynamics"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec32"/>UIKit Dynamics</h2></div></div></div><p>To put it simply, iOS 7 has a fully <a id="id225" class="indexterm"/>featured physics engine built into UIKit. You can manipulate specific properties to provide a more real-world feel to your interface. This includes gravity, springs, elasticity, bounce, and force to name a few. Each interface item will contain its own properties and the dynamic engine will abide by <a id="id226" class="indexterm"/>these properties.</p></div><div class="section" title="Motion effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec33"/>Motion effects</h2></div></div></div><p>One of the coolest features<a id="id227" class="indexterm"/> of iOS 7 on our devices is the parallax effect found on the home screen. Tilting the device in any direction will pan the background image to emphasize depth. Using motion effects<a id="id228" class="indexterm"/>, we can monitor the data supplied by the device's accelerometer to adjust our interface based on movement and orientation.</p><p>By combining these two features,<a id="id229" class="indexterm"/> you can create great looking interfaces with a realistic feel that brings it to life. To demonstrate UIKit Dynamics, we will be adding some code to our <code class="literal">FoodDetailViewController.m</code> file to create some nice effects and animations.</p></div></div></div>
<div class="section" title="Adding gravity"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Adding gravity</h1></div></div></div><p>Open <code class="literal">FoodDetailViewController.m</code> and <a id="id230" class="indexterm"/>add the following instance variables to the view controller:</p><div class="informalexample"><pre class="programlisting">UIDynamicAnimator* animator;
UIGravityBehavior* gravity;</pre></div><p>Scroll to <code class="literal">viewDidLoad</code> and add the following code to the bottom of the method:</p><div class="informalexample"><pre class="programlisting">animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
gravity = [[UIGravityBehavior alloc] initWithItems:@[self.foodImageView]];
    [animator addBehavior:gravity];</pre></div><p>Run the application, open the <span class="strong"><strong>My Foods</strong></span> view, select a food item from the table view, and watch what happens. The food image should start to accelerate towards the bottom of the screen until it eventually falls off the screen, as shown in the following set of screenshots:</p><div class="mediaobject"><img src="graphics/0319OT_08_01.jpg" alt="Adding gravity"/></div><p>Let's go over the code, specifically<a id="id231" class="indexterm"/> the two new classes that were just introduced, <code class="literal">UIDynamicAnimator</code> and <code class="literal">UIGravityBehavior</code>.</p></div>
<div class="section" title="UIDynamicAnimator"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>UIDynamicAnimator</h1></div></div></div><p>This is the core component<a id="id232" class="indexterm"/> of UIKit Dynamics. It is safe to say that the dynamic animator is the physics engine itself wrapped in a convenient <a id="id233" class="indexterm"/>and easy-to-use class. The animator will do nothing on its own, but instead keep track of behaviors assigned to it. Each behavior will interact inside of this physics engine.</p></div>
<div class="section" title="UIGravityBehavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>UIGravityBehavior</h1></div></div></div><p>Behaviors are the core <a id="id234" class="indexterm"/>compositions of UIKit Dynamics animation. These behaviors all define individual responses to<a id="id235" class="indexterm"/> the physics environment. This particular behavior mimics the effects of gravity by applying force. Each behavior is associated with a view (or views) when created. Because you explicitly define this property, you can control which views will perform the behavior.</p></div>
<div class="section" title="Behavior properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Behavior properties</h1></div></div></div><p>Almost all behaviors have multiple properties that can be adjusted to the desired effect. A good example is the gravity behavior. We can adjust its angle and magnitude. Add the following code before adding the behavior to the animator:</p><div class="informalexample"><pre class="programlisting">gravity.magnitude = 0.1f;</pre></div><p>Run the application and test it to see what happens. The picture view will start to fall; however, this time it will be at a much slower rate. Replace the preceding code line with the following line:</p><div class="informalexample"><pre class="programlisting">gravity.magnitude = 10.0f;</pre></div><p>Run the application, and this time you will notice that the image falls much faster. Feel free to play with these properties and get a feel for each value.</p></div>
<div class="section" title="Creating boundaries"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Creating boundaries</h1></div></div></div><p>When dealing with gravity, UIKit Dynamics does not conform to the boundaries of the screen. Although it is not visible, the food image continues to fall after it has passed the edge of the screen. It will continue <a id="id236" class="indexterm"/>to fall unless we set boundaries<a id="id237" class="indexterm"/> that will contain the image view. At the top of the file, create another instance variable:</p><div class="informalexample"><pre class="programlisting">UICollisionBehavior *collision;</pre></div><p>Now in our <code class="literal">viewDidLoad</code> method, add the following code below our gravity code:</p><div class="informalexample"><pre class="programlisting">collision = [[UICollisionBehavior alloc] initWithItems:@[self.foodImageView]];
collision.translatesReferenceBoundsIntoBoundary = YES;
    
[animator addBehavior:collision];</pre></div><p>Here we are creating an instance of a new class (which is a behavior), <code class="literal">UICollisionBehavior</code>. Just like our gravity behavior, we associate this behavior with our food image view.</p><p>Rather than explicitly defining the coordinates for the boundary, we use the convenient <code class="literal">translatesReferenceBoundsIntoBoundary</code> property on our collision behavior. By setting this property to <code class="literal">yes</code>, the boundary will be defined by the bounds of the reference view that we set when allocating our UIDynamics animator. Because the reference view is <code class="literal">self.view</code>, the boundary is now the visible space of our view.</p><p>Run the application and watch how the image will fall, but stop once it reaches the bottom of the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0319OT_08_02.jpg" alt="Creating boundaries"/></div></div>
<div class="section" title="Collisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Collisions</h1></div></div></div><p>With our image view responding to gravity and our screen bounds we can start detecting collisions. You may have<a id="id238" class="indexterm"/> noticed that when the image view is falling, it falls right through our two labels below it.</p><p>This is because UIKit Dynamics will only respond to <code class="literal">UIView</code> elements that have been assigned behaviors. Each behavior can<a id="id239" class="indexterm"/> be assigned to multiple objects, and each object can have multiple behaviors. Because our labels have no behaviors associated with them, the UIKit Dynamics physics engine simply ignores it.</p><p>Let's make the food image view collide with the date label. To do this, we simply need to add the label to the collision behavior allocation call. Here is what the new code looks like:</p><div class="informalexample"><pre class="programlisting">collision = [[UICollisionBehavior alloc] initWithItems:@[self.foodImageView, self.foodDateLabel]];</pre></div><p>As you can see, all we have done is add <code class="literal">self.foodDateLabel</code> to the <code class="literal">initWithItems</code> array property. As mentioned before, any single behavior can be associated with multiple items. Run your code and see what happens. When the image falls, it hits the date label but continues to fall, pushing the date label with it.</p><p>Because we didn't associate the gravity behavior with the label, it does not fall immediately. Although it does not respond to gravity, the label will still be moved because it is a physics object after all. This approach is not ideal, so let's use another awesome feature of UIKit Dynamics, invisible boundaries.</p></div>
<div class="section" title="Creating invisible boundaries"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Creating invisible boundaries</h1></div></div></div><p>We are going to take a slightly different approach to this problem. Our label is only a point of reference for where <a id="id240" class="indexterm"/>we want to add a boundary that will <a id="id241" class="indexterm"/>stop our food image view. Because of this, the label does not need to be associated with any UIKit Dynamic behaviors. Remove <code class="literal">self.foodDateLabel</code> from the following code:</p><div class="informalexample"><pre class="programlisting">collision = [[UICollisionBehavior alloc] initWithItems:@[self.foodImageView, self.foodDateLabel]];</pre></div><p>Instead, add the following code to the bottom of <code class="literal">viewDidLoad</code> but before we add our collision behavior to the animator:</p><div class="informalexample"><pre class="programlisting">// Add a boundary to the top edge
CGPoint topEdge = CGPointMake(self.foodDateLabel.frame.origin.x + self.foodDateLabel.frame.size.width, self.foodDateLabel.frame.origin.y);
[collision addBoundaryWithIdentifier:@"barrier" fromPoint:self.foodDateLabel.frame.origin toPoint:topEdge];</pre></div><p>Here we add a boundary to the collision behavior and pass some parameters. First we define an identifier, which we will use later, and then we pass the food date label's origin as the <code class="literal">fromPoint</code> property. The <code class="literal">toPoint</code> property is set to the CGPoint we created using the food date label's frame.</p><p>Go ahead and run the application, and you will see that the food image will now stop at the invisible boundary we defined. The label is still visible to the user, but the dynamic animator ignores it. <a id="id242" class="indexterm"/>Instead the animator sees the barrier <a id="id243" class="indexterm"/>we defined and responds accordingly, even though the barrier is invisible to the user.</p><p>Here is a side-by-side comparison of the before and after:</p><div class="mediaobject"><img src="graphics/0319OT_08_03.jpg" alt="Creating invisible boundaries"/></div></div>
<div class="section" title="Dynamic items"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Dynamic items </h1></div></div></div><p>When using UIKit Dynamics, it is important to understand what UIKit Dynamics items are. Rather than referencing dynamics as <a id="id244" class="indexterm"/>views, they are referenced as items, which adhere to the <code class="literal">UIDynamicItem</code> protocol. This protocol defines the center, transform, and bounds of any object that adheres to this protocol. <code class="literal">UIView</code> is the most common class that adheres to the <code class="literal">UIDynamicItem</code> protocol. Another example of a class that conforms to this protocol is the <code class="literal">UICollectionViewLayoutAttributes</code> class.</p></div>
<div class="section" title="Manipulating item properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Manipulating item properties</h1></div></div></div><p>As mentioned before, UIDynamics items have properties that can be manipulated and applied to<a id="id245" class="indexterm"/> multiple views/items in your interface. Let's see what it looks like to adjust the elasticity property and apply it to our food image view.</p><p>Scroll to <code class="literal">viewDidLoad</code> and add the following code to its end:</p><div class="informalexample"><pre class="programlisting">UIDynamicItemBehavior* itemBehaviour = [[UIDynamicItemBehavior alloc] initWithItems:@[self.foodImageView]];
itemBehaviour.elasticity = 0.6;
[animator addBehavior:itemBehaviour];</pre></div><p>Here, we create a <code class="literal">UIDynamicItemBehavior</code> instance and initialize it with our <code class="literal">self.foodImageView</code>. Next, we set the elasticity property and then add this new behavior to our animator. Go ahead and run your code, and watch how the food image view will now bounce a few extra times. Play with the elasticity value to see different results.</p><p>Elasticity is one of the many behaviors that can be altered. The following is a list of all the properties available with <code class="literal">UIDynamicItemBehavior</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Elasticity</strong></span>: <a id="id246" class="indexterm"/>This property will define how elastic a collision is. The best way to remember this is how bouncy the object will be. The higher the value, the more an item will bounce.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Friction</strong></span>: If an object slides across another surface, the friction<a id="id247" class="indexterm"/> property is used to determine how much resistance the object receives.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Density</strong></span>: This sets the overall<a id="id248" class="indexterm"/> simulated mass of the item. As with real physics, the higher the mass, the more the force required to move an item. One example of how to keep an item from moving when collided with is to give it a very high-density compared to the other items colliding with it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resistance</strong></span>: This is the resistance<a id="id249" class="indexterm"/> applied to any movement, not just sliding across another surface as in the case of friction.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>angularResistance</strong></span>: <a id="id250" class="indexterm"/>When an item rotates, this property will determine the resistance to the rotation.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>allowsRotation</strong></span>:<a id="id251" class="indexterm"/> An optional property to keep an item from rotating, regardless of what collisions and forces<a id="id252" class="indexterm"/> affect it.</li></ul></div></div>
<div class="section" title="Collision notifications"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Collision notifications</h1></div></div></div><p>So far, we have set up gravity and added some boundaries, including an invisible boundary for our date label.<a id="id253" class="indexterm"/> It is very common to respond to collisions by performing some sort of task. For instance, in a game, once an enemy collides with a bullet, we would destroy the enemy and increase the score.</p><p>We can track collisions by using collision notifications<a id="id254" class="indexterm"/>. In order to do so, we must have our class adopt <code class="literal">UICollisionBehaviorDelegate</code>. Switch to <code class="literal">FoodDetailViewController.h</code> and add the following protocol:</p><div class="informalexample"><pre class="programlisting">@interface FoodDetailViewController : UIViewController &lt;UICollisionBehaviorDelegate&gt;</pre></div><p>Now switch back to <code class="literal">FoodDetailViewController.m</code> and locate the code we wrote to create the collision behavior. Add the following line of code:</p><div class="informalexample"><pre class="programlisting">collision.collisionDelegate = self;</pre></div><p>By setting the collision delegate, we can now use the following delegate method:</p><div class="informalexample"><pre class="programlisting">- (void)collisionBehavior:(UICollisionBehavior *)behavior beganContactForItem:(id&lt;UIDynamicItem&gt;)item withBoundaryIdentifier:(id&lt;NSCopying&gt;)identifier atPoint:(CGPoint)p {
    
    NSLog(@"Boundary contact occurred - %@", identifier);
    
}</pre></div><p>This delegate method gets called every time a collision occurs, and we have set it up to output the collision identifier we defined earlier. Run the code, and your console output should look as follows:</p><div class="mediaobject"><img src="graphics/0319OT_08_04.jpg" alt="Collision notifications"/></div><p>Using a combination of identifiers and other properties passed to this delegate method, we can detect which<a id="id255" class="indexterm"/> collisions are happening and respond accordingly. For example, let's animate the alpha of the food image view when a collision occurs. Replace your delegate method code with the following code:</p><div class="informalexample"><pre class="programlisting">- (void)collisionBehavior:(UICollisionBehavior *)behavior beganContactForItem:(id&lt;UIDynamicItem&gt;)item withBoundaryIdentifier:(id&lt;NSCopying&gt;)identifier atPoint:(CGPoint)p {

    if ([(NSString *)identifier isEqualToString:@"barrier"]) {
        // The barrier was collided with
        [UIView animateWithDuration:0.3f animations:^{

            self.foodImageView.alpha = 0.0f;

        }];
    }

}</pre></div><p>Here we cast <a id="id256" class="indexterm"/>the identifier as an <code class="literal">NSString</code> and then check if it is equal to the collision identifier we want. If so, we perform a simple <code class="literal">UIView</code> animation that sets the <code class="literal">alpha</code> value of the image view to zero, thus making it invisible. Using this delegate method properly will allow you to accomplish a large number of tasks based on collisions.</p></div>
<div class="section" title="Attaching items to other items"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Attaching items to other items</h1></div></div></div><p>In addition to<a id="id257" class="indexterm"/> gravity and other<a id="id258" class="indexterm"/> physics properties, UIKit Dynamics also allows your physics objects to interact with one another as they would in the real physical world. For example, we can use the <code class="literal">UIAttachmentBehavior</code> method to link items together as if they are attached with an invisible brace. Let's have our application create a new square view and then attach it to our food image view, but only<a id="id259" class="indexterm"/> when a collision occurs. Because our food image view will bounce a couple of times, the collision will be detected each time. To keep from creating multiple squares, let's create another instance variable to keep track of the first bounce.</p><p>Add the following line of code in the implementation block in <code class="literal">FoodDetailViewController.m</code>:</p><div class="informalexample"><pre class="programlisting">BOOL firstBounce;</pre></div><p>Now replace our delegate method code with the following code:</p><div class="informalexample"><pre class="programlisting">- (void)collisionBehavior:(UICollisionBehavior *)behavior beganContactForItem:(id&lt;UIDynamicItem&gt;)item withBoundaryIdentifier:(id&lt;NSCopying&gt;)identifier atPoint:(CGPoint)p {

    if (!firstBounce) {

        firstBounce = YES;

        UIView* square = [[UIView alloc] initWithFrame:CGRectMake(self.view.bounds.size.width / 2 - 50, 400, 100, 100)];
        square.backgroundColor = [UIColor greenColor];
        [self.view addSubview:square];

        [collision addItem:square];
        [gravity addItem:square];

        UIAttachmentBehavior* attach = [[UIAttachmentBehavior alloc] initWithItem:self.foodImageView attachedToItem:square];
        [animator addBehavior:attach];

    }

}</pre></div><p>Here we<a id="id260" class="indexterm"/> detect if the <code class="literal">firstBounce</code> Boolean value is not <code class="literal">YES</code>, and then create a new <code class="literal">UIView</code>, add the gravity and collision items to it, use the <code class="literal">UIAttachmentBehavior</code> method, and attach this new view to our food image view. Run the application, and you will see that on the first bounce, a green square is created. Because we attach this new view to the food image view, you will see that as it bounces the second and third times, the square view moves with it as if attached.</p></div>
<div class="section" title="Snapping items"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Snapping items</h1></div></div></div><p>Our last behavior we will cover in this book is the <code class="literal">UISnapBehavior</code> class<a id="id261" class="indexterm"/>. UIKit Dynamics provides a built-in behavior that will snap an item from its starting point to a specified end point with<a id="id262" class="indexterm"/> built-in damping. Let's have our food image view snap from the top of the screen into its final position.</p><p>Scroll to <code class="literal">viewDidLoad</code> and remove all of our gravity and collision code (keep our animator). Add the following code to <code class="literal">viewDidLoad</code>:</p><div class="informalexample"><pre class="programlisting">UISnapBehavior *snapBehaviour = [[UISnapBehavior alloc] initWithItem:self.foodImageView snapToPoint:CGPointMake(160, 202)];
snapBehaviour.damping = 0.65f;
[animator addBehavior:snapBehaviour];</pre></div><p>Here we allocate new <code class="literal">UISnapBehavior</code> and <code class="literal">init</code> options with our food image view. We also pass the point we want the item to snap to, in this case, the final position of the image view. We set the damping value to be a bit higher to give a milder spring effect (the lower the number, the more springy the item will be).</p><p>The last thing to do is to change the starting point of the food image view. Switch to <span class="strong"><strong>Main.storyboard</strong></span> and drag the food image view to the top of the screen as high as you wish (even offscreen). It is important to note that the greater the distance of the starting point to the end point, the more springy the snap, so take this into consideration when setting the <code class="literal">damping</code> property.</p><p>Run our application and see the results. The food image view should snap into place with a nice spring effect. As you can see, using UIKit Dynamics is not only simple, but can be very powerful.</p></div>
<div class="section" title="Using motion in our app"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Using motion in our app</h1></div></div></div><p>In addition to UIKit Dynamics, we can also use <code class="literal">UIMotionEffects</code> to adjust the user interface when a device is tilted<a id="id263" class="indexterm"/> horizontally. <code class="literal">UIMotionEffects</code> is an abstract class that works best when subclassed. Apple has already made a subclass of <code class="literal">UIMotionEffects</code> that will cover almost all use cases of motion in your apps. <a id="id264" class="indexterm"/>This subclass is the <code class="literal">UIInterpolatingMotionEffect</code> class.</p><p>The <code class="literal">UIInterpolatingMotionEffect</code> instance is initialized with a key path and a type. The type is what defines vertical and horizontal motions. The class will automatically set the key value path based on the device's movements.</p><p>In our <code class="literal">viewDidLoad</code> method, add the following code at the bottom:</p><div class="informalexample"><pre class="programlisting">UIInterpolatingMotionEffect *horizontalMotionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];

horizontalMotionEffect.minimumRelativeValue = @(-30);
horizontalMotionEffect.maximumRelativeValue = @(30);

[self.foodImageView addMotionEffect:horizontalMotionEffect];
[self.foodNameLabel addMotionEffect:horizontalMotionEffect];
[self.foodDateLabel addMotionEffect:horizontalMotionEffect];</pre></div><p>Here we create our <code class="literal">UIInterpolatingMotionEffect</code> instance and assign it to the horizontal axis motion tracking. Next we set a minimum and maximum relative value. This determines how much the items will move left and right to simulate the parallax effect we want.<a id="id265" class="indexterm"/> Lastly, we add the motion effect to all<a id="id266" class="indexterm"/> views that we want. Our <code class="literal">keyPath</code> value can be assigned to a number of different values for different effects. Run the application on a device and select a food item's detailed view to see the results!</p><p>Additionally, we can go further by grouping multiple motion effects together, such as both vertical and horizontal motions. Replace the preceding code with the following:</p><div class="informalexample"><pre class="programlisting">UIInterpolatingMotionEffect *horizontalMotionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];

    horizontalMotionEffect.minimumRelativeValue = @(-30);
    horizontalMotionEffect.maximumRelativeValue = @(30);

    UIInterpolatingMotionEffect *verticalMotionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.y" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis];

    verticalMotionEffect.minimumRelativeValue = @(-30);
    verticalMotionEffect.maximumRelativeValue = @(30);

    UIMotionEffectGroup *group = [UIMotionEffectGroup new];

    group.motionEffects = @[horizontalMotionEffect, verticalMotionEffect];

    [self.foodImageView addMotionEffect:group];
    [self.foodNameLabel addMotionEffect:group];
    [self.foodDateLabel addMotionEffect:group];</pre></div><p>Here we simply duplicate the horizontal motion effect, but we set <code class="literal">keyPath</code> to <code class="literal">center.y</code> and <code class="literal">type</code> to <code class="literal">vertical</code>. Run the application and check out the results.</p><p>As great and easy as these effects are, be careful not to go overboard. Each of the items discussed in this<a id="id267" class="indexterm"/> chapter is designed to add<a id="id268" class="indexterm"/> subtle effects that work together for an overall better user experience.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Summary</h1></div></div></div><p>We have done it! From start to finish, we have built a fully functional application using many of the great new features of iOS 7 and Xcode 5. In this chapter, we topped everything off by adding some cool physical properties to our views. Stacking these behaviors and motion effects together can create some really unique interface effects. Now that we are at the conclusion of this book, you should be very comfortable stepping into iOS 7 development. Taking advantage of all the new features is the first step to building better applications with a better experience!</p></div></body></html>