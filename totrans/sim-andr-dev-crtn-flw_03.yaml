- en: '*Chapter 2*: Understanding Kotlin Coroutines'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：理解 Kotlin 协程'
- en: 'In the previous chapter, you revisited the concept of asynchronous programming
    and how it helps you execute long-running tasks in the background without freezing
    the app and annoying your app’s users. You learned how to carry out asynchronous
    programming with Threads, AsyncTasks, and Executors. Finally, you were introduced
    to the new way of doing it on Android: Kotlin Coroutines and Flows.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您回顾了异步编程的概念以及它是如何帮助您在后台执行长时间运行的任务，而不会冻结应用并烦扰应用的用户。您学习了如何使用线程、AsyncTasks
    和 Executors 进行异步编程。最后，您被介绍到 Android 上执行此操作的新方法：Kotlin 协程和流。
- en: Coroutines is a Kotlin library for multithreading and asynchronous programming,
    such as making network calls and accessing files or databases. Kotlin Coroutines
    is Google’s official recommendation for asynchronous programming on Android. Android
    Jetpack libraries, such as ViewModel, Lifecycle, WorkManager, and Room, include
    support for Kotlin Coroutines. Third-party Android libraries, such as Retrofit,
    now provide support for Kotlin Coroutines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是 Kotlin 用于多线程和异步编程的库，例如进行网络调用或访问文件或数据库。Kotlin 协程是 Google 对 Android 上异步编程的官方推荐。Android
    Jetpack 库，如 ViewModel、Lifecycle、WorkManager 和 Room，都包括对 Kotlin 协程的支持。第三方 Android
    库，如 Retrofit，现在也提供了对 Kotlin 协程的支持。
- en: In this chapter, we will dive deep into Kotlin Coroutines. You will learn how
    to use coroutines to carry out asynchronous programming in Android with simple
    code. You will also learn how to create coroutines in your Android app. Then,
    we will discuss other building blocks of coroutines, such as builders, scopes,
    dispatchers, contexts, and jobs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Kotlin 协程。您将学习如何使用协程在 Android 中通过简单的代码执行异步编程。您还将学习如何在您的 Android
    应用中创建协程。然后，我们将讨论协程的其他构建块，如构建器、作用域、调度器、上下文和任务。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating coroutines in Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 中创建协程
- en: Exploring coroutine builders, scopes, and dispatchers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索协程构建器、作用域和调度器
- en: Understanding coroutine contexts and jobs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解协程上下文和任务
- en: Exercise – using coroutines in an Android app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习 – 在Android应用中使用协程
- en: 'By the end of this chapter, you will have an understanding of using Kotlin
    coroutines. You will be able to add coroutines for various cases in your Android
    apps. You will also understand the basic building blocks of Coroutines: builders,
    scopes, dispatchers, contexts, and jobs.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何使用 Kotlin 协程。您将能够在您的 Android 应用中为各种情况添加协程。您还将了解协程的基本构建块：构建器、作用域、调度器、上下文和任务。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to download and install the latest version
    of Android Studio. You can find the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    For an optimal learning experience, a computer with the following specifications
    is recommended: Intel Core i5 or equivalent or higher, 4 GB of RAM minimum, and
    4 GB available space.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要下载并安装最新版本的 Android Studio。您可以在[https://developer.android.com/studio](https://developer.android.com/studio)找到最新版本。为了获得最佳的学习体验，建议使用以下配置的计算机：Intel
    Core i5或更高性能的处理器，至少4 GB的RAM，以及4 GB的可用空间。
- en: The code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02](https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在 GitHub 上找到，地址为[https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02](https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter02)。
- en: Creating coroutines in Android
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android 中创建协程
- en: In this section, we will start by looking at how to create coroutines in Android.
    Coroutines provide an easy way to write asynchronous code with Kotlin’s standard
    functions. You can use coroutines when making a network call or when fetching
    data from or saving data to a local database.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨如何在 Android 中创建协程。协程提供了一种使用 Kotlin 标准函数编写异步代码的简单方法。您可以在进行网络调用或从本地数据库获取或保存数据时使用协程。
- en: 'A simple coroutine looks as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的协程看起来如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It has four parts: `CoroutineScope`, `Dispatchers`, `launch`, and the lambda
    function that will be executed by the coroutine. An instance of `CoroutineScope`
    was created for the coroutine’s scope. `Dispatchers.IO` is the dispatcher that
    will specify that this coroutine will run on the I/O dispatcher, the one usually
    used for `launch` is the coroutine builder that creates the coroutine. We will
    explore these components in detail later in this chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它有四个部分：`CoroutineScope`、`Dispatchers`、`launch` 以及协程将执行的 lambda 函数。为协程的作用域创建了一个
    `CoroutineScope` 实例。`Dispatchers.IO` 是指定此协程将在 I/O 调度器上运行的调度器，通常用于 `launch` 的协程构建器是创建协程的协程构建器。我们将在本章后面详细探讨这些组件。
- en: 'The following diagram summarizes these parts of a coroutine:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了协程的这些部分：
- en: '![Figure 2.1 – Parts of a coroutine'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 协程的部分'
- en: '](img/Figure_2.1_B1773.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.1](img/Figure_2.1_B1773.jpg)'
- en: Figure 2.1 – Parts of a coroutine
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 协程的部分
- en: 'In Android Studio, the `performTask()` call has the suspend function call gutter
    icon next to it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，`performTask()` 调用旁边有暂停函数调用行号图标：
- en: '![Figure 2.2 – Android Studio suspend function call gutter icon'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – Android Studio 暂停函数调用行号图标'
- en: '](img/Figure_2.02_B17773.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.02](img/Figure_2.02_B17773.jpg)'
- en: Figure 2.2 – Android Studio suspend function call gutter icon
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Android Studio 暂停函数调用行号图标
- en: Let’s say you have an Android application that displays the list of movies that
    are currently playing in cinemas. So, let’s look at the ways you can use the `suspend`
    function and add coroutines to the project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个显示当前电影院正在上映的电影列表的 Android 应用程序。那么，让我们看看你可以使用 `suspend` 函数并将协程添加到项目中的方法。
- en: 'If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function
    as a suspending function with `suspend`, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Retrofit 2.6.0 或更高版本，你可以使用 `suspend` 将端点函数标记为暂停函数，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, you can create a coroutine that will call the `getMovies` suspending
    function and display the list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个协程，该协程将调用 `getMovies` 暂停函数并显示列表：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a coroutine that fetches the movies in the background. The
    `withContext` call will change the context of the coroutine to use `Dispatchers.Main`
    to display the fetched movies in the main thread.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个在后台获取电影的协程。`withContext` 调用将改变协程的上下文，使其使用 `Dispatchers.Main` 在主线程上显示获取到的电影。
- en: 'If you are using Room-KTX 2.1 or above, you can add the `suspend` keyword to
    your **Data Access Object** (**DAO**) functions so that the query or operation
    can be executed on the background thread and the result will be posted on the
    main thread. The following is an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Room-KTX 2.1 或更高版本，你可以在你的 **数据访问对象** (**DAO**) 函数中添加 `suspend` 关键字，这样查询或操作就可以在后台线程上执行，结果将在主线程上发布。以下是一个示例：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will make the `getMovies` query a suspending function. When you call this
    function, Room-KTX internally executes the query on a background thread. The results
    can be displayed on the main thread without it freezing your app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 `getMovies` 查询成为一个暂停函数。当你调用此函数时，Room-KTX 内部会在后台线程上执行查询。结果可以在主线程上显示，而不会冻结你的应用。
- en: 'When you create a coroutine inside another coroutine, the new coroutine becomes
    the child of the original coroutine. The original coroutine becomes the parent
    of the new coroutine. This can be seen in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在另一个协程内部创建协程时，新的协程成为原始协程的子协程。原始协程成为新协程的父协程。这可以在以下代码中看到：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The second coroutine that was launched with `performTask2` was created using
    the `Coroutine Scope` of the parent coroutine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `performTask2` 启动的第二个协程是使用父协程的 `Coroutine Scope` 创建的。
- en: 'In this section, you explored how to add coroutines to your Android project
    and learned how to create coroutines for your app. In the next section, you will
    explore some of the building blocks of coroutines: builders, scopes, and dispatchers.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你探索了如何将协程添加到你的 Android 项目中，并学习了如何为你的应用程序创建协程。在下一节中，你将探索协程的一些构建块：构建器、作用域和调度器。
- en: Exploring coroutine builders, scopes, and dispatchers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索协程构建器、作用域和调度器
- en: In this section, you will learn how to use coroutine builders and explore coroutine
    scopes and dispatchers. Coroutine builders are functions that are used to create
    coroutines. Coroutine scope is the scope with which the coroutines run. Dispatchers
    specify in what thread the coroutine will run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用协程构建器，并探索协程作用域和调度器。协程构建器是用于创建协程的函数。协程作用域是协程运行的作用域。调度器指定协程将在哪个线程上运行。
- en: Coroutine builders
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程构建器
- en: 'In the previous section, you created a coroutine with `launch`. However, there
    are other ways to create coroutines. Coroutine builders are the functions that
    you can use to create coroutines. To create a coroutine, you can use the following
    Kotlin coroutine builders:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你使用 `launch` 创建了一个协程。然而，还有其他创建协程的方法。协程构建器是你可以用来创建协程的函数。要创建一个协程，你可以使用以下
    Kotlin 协程构建器：
- en: '`launch`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch`'
- en: '`async`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`'
- en: '`runBlocking`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runBlocking`'
- en: '`async` and `launch` need to be started on a coroutine scope. Meanwhile, `runBlocking`
    doesn’t need to be started from a coroutine scope.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `launch` 需要在协程作用域中启动。同时，`runBlocking` 不需要从协程作用域中启动。'
- en: The `launch` keyword creates a coroutine and doesn’t return a value. Instead,
    it returns a `Job` object that represents the coroutine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch` 关键字创建一个协程，并且不返回任何值。相反，它返回一个表示协程的 `Job` 对象。'
- en: 'The `launch` coroutine builder is ideal to use when you want to run a task
    and then forget about it (this means you are not waiting for the result of the
    operation). Here’s an example of using the `launch` coroutine builder:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想运行一个任务然后忘记它（这意味着你不需要等待操作的结果）时，`launch` 协程构建器是理想的选择。以下是一个使用 `launch` 协程构建器的示例：
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the activity has been created, a coroutine will be launched. This coroutine
    will call the `delay` suspending function to delay the coroutine for a second,
    resume, and display the progress bar; then, it’s done.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了活动，就会启动一个协程。这个协程将调用 `delay` 暂停函数来延迟协程一秒，然后恢复，并显示进度条；然后，任务完成。
- en: 'On the other hand, the `async` builder is similar to `launch` but it returns
    a value: a `Deferred` object. Later, you can get this value with the `await` function.
    The `async` builder should be used when you want to execute a task and want to
    get the output of said task. An example of using the `async` coroutine builder
    is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`async` 构建器与 `launch` 类似，但它返回一个值：一个 `Deferred` 对象。稍后，你可以使用 `await` 函数获取这个值。当你想执行一个任务并获取该任务的输出时，应该使用
    `async` 构建器。以下是一个使用 `async` 协程构建器的示例：
- en: '[PRE38]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, a coroutine was started with `async` to call the `getText` function. This
    will return a deferred object called `text`. There will be a delay of 1 second
    and then the actual value from `text` will be called with `text.await()`, which
    will be set as the text for `textView`. With `async`, two tasks can be computed
    in parallel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，使用 `async` 启动了一个协程来调用 `getText` 函数。这将返回一个名为 `text` 的延迟对象。将会有1秒的延迟，然后使用 `text.await()`
    调用 `text` 的实际值，这将作为 `textView` 的文本设置。使用 `async`，可以并行计算两个任务。
- en: '`runBlocking` starts a new coroutine and blocks the current thread until the
    task has been executed. This is useful for cases when you need to block the thread.
    Creating unit tests is one of these cases:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`runBlocking` 启动一个新的协程并阻塞当前线程，直到任务执行完毕。这在需要阻塞线程的情况下很有用。创建单元测试就是这种情况之一：'
- en: '[PRE54]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code, the `runBlocking` code will create a coroutine and block
    the thread. After a delay of 2,000 milliseconds (2 seconds), it will display the
    progress bar.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`runBlocking` 代码将创建一个协程并阻塞线程。在延迟2,000毫秒（2秒）后，它将显示进度条。
- en: In this section, you explored how to use coroutine builders to create coroutines.
    You also learned about the `async`, `launch`, and `runBlocking` coroutine builders.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了如何使用协程构建器创建协程。你还学习了 `async`、`launch` 和 `runBlocking` 协程构建器。
- en: In the next section, you will explore coroutine scopes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将探索协程作用域。
- en: Coroutine scopes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程作用域
- en: '`CoroutineScope` is the scope with which the coroutine will run. It defines
    the life cycle of the coroutines created from it, from its start to its end. If
    you cancel a scope, it will cancel all the coroutines it created. Coroutines follow
    the principle of structured concurrency – that is, a mechanism that provides the
    structure of a coroutine.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoroutineScope` 是协程将运行的上下文。它定义了从它创建的协程的生命周期，从其开始到其结束。如果你取消一个作用域，它将取消它创建的所有协程。协程遵循结构化并发原则——即提供协程结构的机制。'
- en: The `launch` and `async` coroutine builders are extension functions from `CoroutineScope`
    for creating coroutines.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch` 和 `async` 协程构建器是 `CoroutineScope` 的扩展函数，用于创建协程。'
- en: 'For example, let’s say we have created a coroutine using `MainScope`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们使用 `MainScope` 创建了一个协程：
- en: '[PRE66]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This launches a coroutine using `MainScope` to display the progress bar.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `MainScope` 启动一个协程以显示进度条。
- en: '`MainScope` is the main `CoroutineScope` for the main thread, which uses `Dispatchers.Main`
    for its coroutine. It is normally used for creating coroutines that will update
    the user interface.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainScope` 是主线程的主要 `CoroutineScope`，它使用 `Dispatchers.Main` 进行其协程。它通常用于创建将更新用户界面的协程。'
- en: You can also create a `CoroutineScope` instead of using `MainScope` by creating
    one with the `CoroutineScope` factory function. The `CoroutineScope` function
    requires you to pass in a coroutine context. `CoroutineContext` is a collection
    of elements for the coroutines that specify how the coroutine should run.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用 `CoroutineScope` 工厂函数创建一个 `CoroutineScope` 来代替使用 `MainScope`。`CoroutineScope`
    函数需要您传递一个协程上下文。`CoroutineContext` 是协程元素集合，用于指定协程应该如何运行。
- en: You passed a dispatcher and both a dispatcher and a job in the previous examples
    for the coroutine context. Dispatchers and jobs are coroutine context elements.
    You will learn more about coroutine contexts later in this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，您为协程上下文传递了一个调度器以及一个调度器和作业。调度器和作业是协程上下文元素。您将在本章后面了解更多关于协程上下文的内容。
- en: Your `CoroutineScope` must have a job and a way for the coroutine to be canceled,
    such as when `Activity`, `Fragment`, or `ViewModel` has been closed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `CoroutineScope` 必须有一个作业以及一种取消协程的方式，例如当 `Activity`、`Fragment` 或 `ViewModel`
    被关闭时。
- en: In the next section, we will look at a built-in coroutine scope called `lifecycleScope`,
    which is part of Jetpack’s Lifecycle library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个名为 `lifecycleScope` 的内置协程作用域，它是 Jetpack 的 Lifecycle 库的一部分。
- en: lifecycleScope
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lifecycleScope
- en: '`lifecycleScope` is a `CoroutineScope` from Jetpack’s Lifecycle library that
    you can use to create coroutines. It is tied to the `Lifecycle` object (similar
    to your activity or fragment) and is automatically canceled when the life cycle
    is destroyed. Thus, you no longer need to manually cancel them.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycleScope` 是 Jetpack 的 Lifecycle 库中的一个 `CoroutineScope`，您可以使用它来创建协程。它与
    `Lifecycle` 对象（类似于您的活动或片段）相关联，并在生命周期被销毁时自动取消。因此，您不再需要手动取消它们。'
- en: '`lifecycleScope` simplifies how scopes are created, how jobs are handled, and
    how they can be canceled within your activity or fragment. A `lifecycleScope`
    uses `Dispatchers.Main.immediate` for its dispatcher and a `SupervisorJob` for
    its job, such as `viewModelScope`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycleScope` 简化了作用域的创建方式、作业的处理方式以及它们如何在您的活动或片段中被取消。`lifecycleScope` 使用
    `Dispatchers.Main.immediate` 作为其调度器，并使用 `SupervisorJob` 作为其作业，例如 `viewModelScope`。'
- en: 'To use `lifecycleScope`, you must add the following line to your `app/build.gradle`
    file dependencies:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `lifecycleScope`，您必须将以下行添加到您的 `app/build.gradle` 文件依赖项中：
- en: '[PRE78]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'An example of `lifeCycleScope` is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifeCycleScope` 的一个示例如下：'
- en: '[PRE79]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: When the activity is created, it launches a coroutine from `lifecycleScope`
    to display the progress bar.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动创建时，它从 `lifecycleScope` 启动一个协程来显示进度条。
- en: 'To change the dispatcher that the coroutine will use, you can pass in a dispatcher
    when using the `launch` and `async` coroutine builders:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改协程将使用的调度器，您可以在使用 `launch` 和 `async` 协程构建器时传递一个调度器：
- en: '[PRE90]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This will use the `Dispatchers.IO` dispatcher instead of the `lifecycleScope`
    object's default `Dispatchers.Main.immediate` for the coroutine that was launched.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `Dispatchers.IO` 调度器而不是启动的协程对象的默认 `Dispatchers.Main.immediate`。
- en: 'Aside from `launch`, `lifecycleScope` has additional coroutine builders, depending
    on the life cycle’s state:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `launch` 之外，`lifecycleScope` 还具有额外的协程构建器，这取决于生命周期状态：
- en: '`launchWhenCreated`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchWhenCreated`'
- en: '`launchWhenStarted`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchWhenStarted`'
- en: '`launchWhenResumed`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchWhenResumed`'
- en: As the name suggests, `launchWhenCreated` launches the coroutine when the life
    cycle is created, `launchWhenStarted` launches the coroutine when the life cycle
    is started, and `launchWhenResumed` launches the coroutine when the life cycle
    goes back to the **Resumed** state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`launchWhenCreated` 在生命周期创建时启动协程，`launchWhenStarted` 在生命周期启动时启动协程，而 `launchWhenResumed`
    在生命周期回到 **Resumed** 状态时启动协程。
- en: In the next section, we will look at a built-in `CoroutineScope` from `ViewModel`
    called `viewModelScope`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看从 `ViewModel` 中内置的 `CoroutineScope`，称为 `viewModelScope`。
- en: viewModelScope
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: viewModelScope
- en: '`viewModelScope` is the ViewModel’s default `CoroutineScope` for creating coroutines.
    It is ideal to use if you need to do a long-running task from `ViewModel`. This
    scope and all running jobs are automatically canceled when `ViewModel` is cleared
    (that is, when `onCleared` is invoked).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewModelScope` 是 ViewModel 创建协程的默认 `CoroutineScope`。如果你需要从 `ViewModel` 执行长时间运行的任务，这是理想的选择。当
    `ViewModel` 被清除（即调用 `onCleared`）时，此作用域和所有正在运行的任务将自动取消。'
- en: '`viewModelScope` simplifies the creation of `Scope`, handling the job, and
    canceling within `ViewModel`. A `viewModelScope` uses `Dispatchers.Main.immediate`
    for its dispatcher and uses a `SupervisorJob` for the job. A `SupervisorJob` is
    a special version of `Job` that allows its children to fail independently of each
    other.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewModelScope` 简化了 `Scope` 的创建、作业处理和 `ViewModel` 内部的取消。`viewModelScope` 使用
    `Dispatchers.Main.immediate` 作为其调度器，并使用 `SupervisorJob` 作为作业。`SupervisorJob` 是
    `Job` 的一个特殊版本，允许其子协程相互独立地失败。'
- en: 'To use `viewModelScope`, you must add the following line to your `app/build.gradle`
    file dependencies:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `viewModelScope`，你必须将以下行添加到你的 `app/build.gradle` 文件依赖项中：
- en: '[PRE91]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You can use `viewModelScope` like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用 `viewModelScope`：
- en: '[PRE93]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This launches a coroutine from `viewModelScope` that will be used to run the
    `fetchMovies()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从 `viewModelScope` 启动一个协程，用于运行 `fetchMovies()` 函数。
- en: 'To change the dispatcher that the coroutine will use, you can pass in a dispatcher
    when using the `launch` and `async` coroutine builders:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改协程将使用的调度器，你可以在使用 `launch` 和 `async` 协程构造器时传递一个调度器：
- en: '[PRE100]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This will use `Dispatchers.IO` for the coroutine, instead of viewModelScope’s
    default of `Dispatchers.Main`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `Dispatchers.IO` 为协程，而不是 viewModelScope 的默认值 `Dispatchers.Main`。
- en: coroutineScope{} and supervisorScope{}
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: coroutineScope{} 和 supervisorScope{}
- en: The `coroutineScope{}` suspending builder allows you to create a `CoroutineScope`
    with the coroutine context from its outer scope. This calls the code block inside
    and does not complete until everything is done.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`coroutineScope{}` 挂起构造器允许你创建一个具有其外部作用域协程上下文的 `CoroutineScope`。这调用代码块内部，直到所有事情都完成才完成。'
- en: 'You can use a `coroutineScope{}` builder like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个 `coroutineScope{}` 构造器，如下所示：
- en: '[PRE101]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This will create a coroutine scope that will call the `fetchMovies` function,
    set its return value to the `movies` object, and then call the `displayMovies`
    function with `movies`. Another child coroutine will call the `fetchShows` function,
    set its return value to the `shows` object, and then call the `displayShows` function
    with `shows`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个作用域，它将调用 `fetchMovies` 函数，将返回值设置为 `movies` 对象，然后使用 `movies` 调用 `displayMovies`
    函数。另一个子协程将调用 `fetchShows` 函数，将返回值设置为 `shows` 对象，然后使用 `shows` 调用 `displayShows`
    函数。
- en: When a child coroutine fails, it will cancel the parent coroutine and the sibling
    coroutines. If you do not want this to happen, you can use `supervisorScope{}`
    instead of `coroutineScope{}`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个子协程失败时，它将取消父协程和兄弟协程。如果你不希望发生这种情况，你可以使用 `supervisorScope{}` 而不是 `coroutineScope{}`。
- en: The `supervisorScope{}` builder is similar to the `coroutineScope{}` builder
    but the coroutine’s `Scope` has a `SupervisorJob`. This allows the children of
    `supervisorScope` to fail independently of each other.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisorScope{}` 构造器与 `coroutineScope{}` 构造器类似，但协程的 `Scope` 具有管理作业。这允许 `supervisorScope`
    的子协程相互独立地失败。'
- en: 'An example of `supervisorScope` is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisorScope` 的一个示例如下：'
- en: '[PRE111]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This will create a supervisor scope (with a `SupervisorJob`) that will call
    the `fetchMovies` function. When a child coroutine fails, the parent and sibling
    coroutines will continue to work and will not be affected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有 `SupervisorJob` 的管理作用域，它将调用 `fetchMovies` 函数。当一个子协程失败时，父协程和兄弟协程将继续工作，不会受到影响。
- en: GlobalScope
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GlobalScope
- en: '`GlobalScope` is a special `CoroutineScope` that is not tied to an object or
    a job. It should only be used in cases when you must run a task or tasks that
    will always be active while the application is alive. As such, if you want to
    use `GlobalScope`, you must annotate the call with `@OptIn(DelicateCoroutinesApi::class)`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalScope` 是一个特殊的 `CoroutineScope`，它与对象或作业无关。它只应在必须运行在应用程序存活期间始终活跃的任务或任务的情况下使用。因此，如果你想使用
    `GlobalScope`，你必须使用 `@OptIn(DelicateCoroutinesApi::class)` 注解调用。'
- en: For all other cases in Android, it is recommended to use `viewModelScope`, `lifecycleScope`,
    or a custom coroutine scope.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 中的所有其他情况，建议使用 `viewModelScope`、`lifecycleScope` 或自定义协程作用域。
- en: Test scopes
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试作用域
- en: Kotlin has a `kotlinx-coroutines-test` library for testing coroutines. This
    testing library includes a special coroutine scope that you can use to create
    tests for your coroutines. You will learn more about testing coroutines in [*Chapter
    4*](B17773_04_Epub.xhtml#_idTextAnchor051), *Testing Kotlin Coroutines*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有一个名为`kotlinx-coroutines-test`的库用于测试协程。这个测试库包括一个特殊的协程作用域，你可以用它来为你的协程创建测试。你将在[*第4章*](B17773_04_Epub.xhtml#_idTextAnchor051)中了解更多关于测试协程的内容，*测试
    Kotlin 协程*。
- en: In this section, you learned about `CoroutineScope`, as well as about `MainScope`
    and creating coroutine scopes with the `CoroutineScope` function. You also learned
    about built-in scopes such as `viewModelScope` and `lifecycleScope`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了`CoroutineScope`的相关知识，以及如何使用`CoroutineScope`函数创建协程作用域。你还了解了内置的作用域，例如`viewModelScope`和`lifecycleScope`。
- en: In the next section, you will learn about coroutine dispatchers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习关于协程调度器的内容。
- en: Coroutine dispatchers
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程调度器
- en: 'Coroutines have a context, which includes the coroutine dispatcher. Dispatchers
    specify what thread the coroutine will use to perform the task. The following
    dispatchers can be used:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 协程有一个上下文，其中包括协程调度器。调度器指定协程将使用哪个线程来执行任务。以下调度器可以被使用：
- en: '`Dispatchers.Main`: This is used to run on Android’s main thread, usually for
    updates to the user interface. A special version of `Dispatchers.Main`, called
    `Dispatchers.Main.immediate`, is used to immediately execute the coroutine in
    the main thread. The `viewModelScope` and `lifecycleScope` coroutine scopes use
    `Dispatchers.Main.immediate` by default.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Main`：这用于在Android的主线程上运行，通常用于用户界面的更新。`Dispatchers.Main`的一个特殊版本，称为`Dispatchers.Main.immediate`，用于立即在主线程中执行协程。`viewModelScope`和`lifecycleScope`协程作用域默认使用`Dispatchers.Main.immediate`。'
- en: '`Dispatchers.IO`: This is designed for networking operations, and for reading
    from or writing to files or databases.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.IO`：这是为网络操作设计的，用于从文件或数据库中读取或写入。'
- en: '`Dispatchers.Default`: This is used for CPU-intensive work, such as complicated
    computations or processing text, images, or videos. If you don’t set a dispatcher,
    `Dispatchers.Default` will be chosen by default.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Default`：这用于CPU密集型工作，如复杂的计算或处理文本、图像或视频。如果你没有设置调度器，默认将选择`Dispatchers.Default`。'
- en: '`Dispatchers.Unconfined`: This is a special dispatcher that is not confined
    to any specific threads. It executes the coroutine in the current thread and resumes
    it in whatever thread that is used by the suspending function.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Unconfined`：这是一个特殊的调度器，它不受任何特定线程的限制。它将在当前线程中执行协程，并在任何由挂起函数使用的线程中恢复它。'
- en: You can set the dispatchers when setting the context in `CoroutineScope` or
    when using coroutine builders.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在设置`CoroutineScope`中的上下文或使用协程构建器时设置调度器。
- en: 'When using `MainScope` as the coroutine scope for your coroutine, `Dispatchers.Main`
    is used by default:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`MainScope`作为你的协程作用域时，默认使用`Dispatchers.Main`：
- en: '[PRE122]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This coroutine will automatically use `Dispatchers.Main` so that you no longer
    need to specify it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程将自动使用`Dispatchers.Main`，因此你不再需要指定它。
- en: 'If you used a different coroutine scope, you can pass in the dispatcher that
    will be used by the coroutine:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了不同的协程作用域，你可以传递协程将使用的调度器：
- en: '[PRE123]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The preceding code creates a `CoroutineScope` that will be run using `Dispatchers.IO`
    for the dispatcher.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码创建了一个将使用`Dispatchers.IO`调度器的`CoroutineScope`。
- en: 'You can also pass in a dispatcher when using the `launch` and `async` coroutine
    builders:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在使用`launch`和`async`协程构建器时传递调度器：
- en: '[PRE126]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This will launch a coroutine using the `Dispatchers.Default` dispatcher.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`Dispatchers.Default`调度器启动一个协程。
- en: 'To change the context of your coroutine, you can use the `withContext` function
    for the code that you want to use a different thread with. For example, in your
    suspending function, `getMovies`, which gets movies from your endpoint, you can
    use `Dispatchers.IO`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改协程的上下文，你可以使用`withContext`函数来为想要使用不同线程的代码。例如，在你的挂起函数`getMovies`中，该函数从你的端点获取电影，你可以使用`Dispatchers.IO`：
- en: '[PRE127]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In the preceding code, the `getMovies` function uses `Dispatchers.IO` to fetch
    the list of movies from a network endpoint.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`getMovies`函数使用`Dispatchers.IO`从网络端点获取电影列表。
- en: In this section, you learned what dispatchers are and what dispatchers you can
    use, depending on your needs. You also learned how to use `withContext` to change
    the specific thread the coroutine runs on.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了调度器是什么，以及根据你的需求可以使用哪些调度器。你还学习了如何使用`withContext`来更改协程运行的特定线程。
- en: In the next section, you will explore coroutine contexts and jobs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将探索协程上下文和任务。
- en: Understanding coroutine contexts and jobs
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解协程上下文和任务
- en: In this section, you will learn about coroutine contexts and jobs. Coroutines
    run in a coroutine context. A job is the context of the coroutine that allows
    you to manage the coroutine’s execution.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解协程上下文和任务。协程在协程上下文中运行。任务是指协程的上下文，它允许你管理协程的执行。
- en: Coroutine contexts
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程上下文
- en: Each coroutine runs in a coroutine context. A coroutine context is a collection
    of elements for the coroutines that specifies how the coroutine should run. A
    coroutine scope has a default coroutine context; if it’s empty, it will have an
    `EmptyCoroutineContext`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协程都在协程上下文中运行。协程上下文是一组元素，用于指定协程应该如何运行。协程作用域有一个默认的协程上下文；如果它是空的，它将有一个`EmptyCoroutineContext`。
- en: 'When you create a `CoroutineScope` or use a coroutine builder, you can pass
    in a `CoroutineContext`. In the previous examples, we were passing a dispatcher:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`CoroutineScope`或使用协程构建器时，你可以传递一个`CoroutineContext`。在之前的示例中，我们传递了一个调度器：
- en: '[PRE130]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The preceding example shows how to pass a dispatcher in the `CoroutineScope`
    function or in the coroutine builder.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何在`CoroutineScope`函数或协程构建器中传递调度器。
- en: 'What you’re passing in these functions is a `CoroutineContext`. The following
    are some of the `CoroutineContext` elements you can use:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这些函数中传递的是`CoroutineContext`。以下是一些你可以使用的`CoroutineContext`元素：
- en: '`CoroutineDispatcher`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineDispatcher`'
- en: '`Job`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Job`'
- en: '`CoroutineName`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineName`'
- en: '`CoroutineExceptionHandler`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineExceptionHandler`'
- en: The main `CoroutineContext` elements are dispatchers and jobs. Dispatchers specify
    the thread where the coroutine runs, while the job of the coroutine allows you
    to manage the coroutine’s task.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`CoroutineContext`元素是调度器和任务。调度器指定协程运行的线程，而协程的任务允许你管理协程的任务。
- en: Jobs allow you to manage the life cycle of the coroutine, from the creation
    of the coroutine to the completion of the task. You can use this job to cancel
    the coroutine itself. You’ll learn more about coroutine cancelations in [*Chapter
    3*](B17773_03_Epub.xhtml#_idTextAnchor042), *Handling Coroutines Cancelations
    and Exceptions*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 任务允许你管理协程的生命周期，从协程的创建到任务的完成。你可以使用这个任务来取消协程本身。你将在[*第3章*](B17773_03_Epub.xhtml#_idTextAnchor042)中了解更多关于协程取消和异常处理的内容。
- en: '`CoroutineName` is another `CoroutineContext` you can use to set a string to
    name a coroutine. This name can be useful for debugging purposes. For example,
    you can add a `CoroutineName` using the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoroutineName`是另一个你可以使用的`CoroutineContext`，用于设置一个字符串来命名协程。这个名称对于调试目的可能很有用。例如，你可以使用以下代码添加一个`CoroutineName`：'
- en: '[PRE134]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This will give the name of `IOCoroutine` to the coroutine that was launched
    using the `Dispatchers.IO` dispatcher.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为使用`Dispatchers.IO`调度器启动的协程赋予`IOCoroutine`的名称。
- en: 'As the coroutine context is a collection of elements for the coroutine, you
    can use operators such as the `+` symbol to combine context elements to create
    a new `CoroutineContext`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协程上下文是协程元素集合，你可以使用如`+`这样的运算符来组合上下文元素以创建一个新的`CoroutineContext`：
- en: '[PRE138]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '`MainScope`, `viewModelScope`, and `lifecycleScope`, for example, use something
    like the following for the coroutine scope’s context:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`MainScope`、`viewModelScope`和`lifecycleScope`使用以下内容作为协程作用域上下文：
- en: '[PRE139]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Another coroutine context element you can use is `CoroutineExceptionHandler`,
    an element you can use to handle exceptions. You will learn more about `CoroutineExceptionHandler`
    in [*Chapter 3*](B17773_03_Epub.xhtml#_idTextAnchor042), *Handling Coroutines
    Cancelations and Exceptions*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用的另一个协程上下文元素是`CoroutineExceptionHandler`，这是一个你可以用来处理异常的元素。你将在[*第3章*](B17773_03_Epub.xhtml#_idTextAnchor042)中了解更多关于`CoroutineExceptionHandler`的内容，*处理协程取消和异常*。
- en: 'In the previous section, you used the `withContext` function to change the
    dispatcher to specify a different thread to run your coroutine. As the name implies,
    this changes the coroutine context with the dispatcher, which is a `CoroutineContext`
    element itself:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用了`withContext`函数来更改调度器以指定不同的线程来运行你的协程。正如其名所示，这会通过调度器更改协程上下文，调度器本身也是一个`CoroutineContext`元素：
- en: '[PRE140]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This changes the coroutine context with a new dispatcher, `Dispatchers.IO`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一个新的调度器`Dispatchers.IO`更改了协程上下文。
- en: In the next section, you will learn about jobs.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解任务。
- en: Coroutine jobs
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程任务
- en: A `ContextCoroutine` element that you can use for the coroutine context. You
    can use jobs to manage the coroutine’s tasks and its life cycle. Jobs can be canceled
    or joined together.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ContextCoroutine`元素，您可以使用它来创建协程上下文。您可以使用作业来管理协程的任务和其生命周期。作业可以被取消或合并。
- en: The `launch` coroutine builder creates a new job, while the `async` coroutine
    builder returns a `Deferred<T>` object. `Deferred` is itself a `Job` object –
    that is, a job that has a result.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`协程构建器创建一个新的作业，而`async`协程构建器返回一个`Deferred<T>`对象。`Deferred`本身就是一个`Job`对象——也就是说，一个有结果的作业。'
- en: 'To access the job from the coroutine, you can set it to a variable:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要从协程访问作业，您可以将其设置为一个变量：
- en: '[PRE141]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The `launch` coroutine builder creates a coroutine running in the `Dispatchers.IO`
    thread and returns a job. A job can have children jobs, making it a parent job.
    `Job` has a `children` property you can use to get the job’s children:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`协程构建器创建一个在`Dispatchers.IO`线程上运行的协程，并返回一个作业。作业可以有子作业，使其成为父作业。`Job`有一个`children`属性，您可以使用它来获取作业的子作业：'
- en: '[PRE142]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: In this example, `job2` becomes a child of `job1`, which is the parent. This
    means that `job2` will inherit the coroutine context of the parent, though you
    can also change it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`job2`成为`job1`的子作业，即父作业。这意味着`job2`将继承父作业的协程上下文，尽管您也可以更改它。
- en: If a parent job is canceled or failed, its children are also automatically canceled.
    When a child’s job is canceled or failed, its parent will also be canceled.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父作业被取消或失败，其子作业也会自动取消。当一个子作业被取消或失败时，其父作业也会被取消。
- en: A `SupervisorJob` is a special version of a job that allows its children to
    fail independently of each other.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`SupervisorJob`是作业的一个特殊版本，允许其子作业相互独立地失败。'
- en: 'Using a job also allows you to create a coroutine that you can later start
    instead of immediately running by default. To do this, you must use `CoroutineStart.LAZY`
    as the value of the `start` parameter in your coroutine builder and assign the
    result to a `Job` variable. Later, you can then use the `start()` function to
    run the coroutine, as shown here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作业还可以让您创建一个可以在以后启动的协程，而不是默认立即运行。为此，您必须在协程构建器中将`start`参数的值设置为`CoroutineStart.LAZY`，并将结果分配给一个`Job`变量。稍后，您可以使用`start()`函数来运行协程，如下所示：
- en: '[PRE149]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This will create a lazy coroutine. When you are ready to start it, you can simply
    call `lazyJob.start()`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个懒加载的协程。当您准备好启动它时，您可以简单地调用`lazyJob.start()`。
- en: 'With the `Job` object, you can also use the `join()` suspending function to
    wait for the job to be completed before continuing with another job or task:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Job`对象，您还可以使用`join()`挂起函数等待作业完成，然后再继续另一个作业或任务：
- en: '[PRE155]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: In this example, `job1` will be run first and `job2` won’t be executed until
    the former job (`job1`) has finished.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`job1`将首先运行，`job2`将不会执行，直到前面的作业（`job1`）完成。
- en: In the next section, you will learn more about the states of coroutine jobs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解更多关于协程作业的状态。
- en: Coroutine job states
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程作业状态
- en: 'A job has the following states:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作业有以下状态：
- en: New
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新建
- en: Active
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动
- en: Completing
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成状态
- en: Completed
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已完成
- en: Canceling
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消中
- en: Canceled
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已取消
- en: 'These states of a job and its life cycle are summarized in the following diagram:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了作业及其生命周期的这些状态：
- en: '![Figure 2.3 – Coroutine job life cycle'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 协程作业生命周期'
- en: '](img/Figure_2.03_B17773.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B17773.jpg)'
- en: Figure 2.3 – Coroutine job life cycle
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 协程作业生命周期
- en: When you start a coroutine, a job is created in the `start()` or `join()` function.
    The job is in the **Active** state while the job is running.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动一个协程时，`start()`或`join()`函数中会创建一个作业。作业在运行时处于**活动**状态。
- en: Completing a job moves it into the **Completing** state and then into the **Completed**
    state once its children complete their tasks.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完成作业将其移动到**完成**状态，一旦其子任务完成，则进入**已完成**状态。
- en: If a job is canceled manually or failed because of an exception, it will go
    into the **Canceling** state and then into the **Canceled** state once its children
    complete.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业被手动取消或由于异常而失败，它将进入**取消中**状态，一旦其子任务完成，则进入**已取消**状态。
- en: 'A `Job` object has three properties you can use to check the state of the job:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Job`对象有三个属性，您可以使用它们来检查作业的状态：'
- en: '`isActive`: This property is `true` when the job is running or completing,
    and `false` otherwise.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isActive`: 当作业正在运行或完成时，此属性为`true`，否则为`false`。'
- en: '`isComplete`: This property is `true` when the job has finished its task (canceled
    or completed), and `false` otherwise.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isComplete`: 当作业完成其任务（已取消或完成）时，此属性为`true`，否则为`false`。'
- en: '`isCancelled`: This property is `true` if the job has been canceled or is being
    canceled, manually or because of an exception, and `false` otherwise.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCancelled`：如果作业已被取消或正在被取消（手动或由于异常），则此属性为 `true`，否则为 `false`。'
- en: You will learn more about jobs and how they are used to cancel coroutines in
    [*Chapter 3*](B17773_03_Epub.xhtml#_idTextAnchor042), *Handling Coroutines Cancelations
    and Exceptions*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 [*第 3 章*](B17773_03_Epub.xhtml#_idTextAnchor042) 中学习更多关于作业的内容，以及它们是如何用于取消协程的，*处理协程取消和异常*。
- en: In this section, you learned about coroutine contexts and jobs. `CoroutineContext`
    is a collection of coroutine context elements for the coroutines that specifies
    how the coroutine should run. Examples of `CoroutineContext` elements are dispatchers
    and jobs. A job is created from a coroutine. You can use it to manage the coroutine’s
    tasks and life cycle.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了关于协程上下文和作业的内容。`CoroutineContext` 是协程上下文元素的集合，用于协程，它指定了协程应该如何运行。`CoroutineContext`
    元素的例子包括调度器和作业。作业是由协程创建的。你可以用它来管理协程的任务和生命周期。
- en: Now, you will use what you have learned so far to add coroutines to an Android
    project.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用到目前为止所学的内容，将协程添加到 Android 项目中。
- en: Exercise – using coroutines in an Android app
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 – 在 Android 应用中使用协程
- en: 'In this exercise, you will be working with an application that displays movies
    that are playing now in cinemas. You will be using The Movie Database API version
    3 to get the list of movies. Go to [https://developers.themoviedb.org/3](https://developers.themoviedb.org/3)
    and register for an API key. Once you’ve done that, follow these steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用一个显示当前电影院正在上映的电影的应用程序。你将使用 The Movie Database API 版本 3 来获取电影列表。访问
    [https://developers.themoviedb.org/3](https://developers.themoviedb.org/3) 并注册一个
    API 密钥。完成此操作后，按照以下步骤进行：
- en: Open the `Movie App` project in the `Chapter02` directory in this book’s code
    repository.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本书代码库中 `Chapter02` 目录下的 `Movie App` 项目。
- en: 'Open `MovieRepository` and update `apiKey` with the value from The Movie Database
    API:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieRepository` 并使用 The Movie Database API 的值更新 `apiKey`：
- en: '[PRE166]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Open the `app/build.gradle` file and add a dependency for `kotlinx-coroutines-android`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app/build.gradle` 文件，并添加 `kotlinx-coroutines-android` 的依赖项：
- en: '[PRE167]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This will add the `kotlinx-coroutines-core` and `kotlinx-coroutines-android`
    libraries to your project, allowing you to use coroutines in your code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `kotlinx-coroutines-core` 和 `kotlinx-coroutines-android` 库添加到你的项目中，允许你在代码中使用协程。
- en: 'Also, add the dependencies for the `ViewModel` extension library:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加 `ViewModel` 扩展库的依赖项：
- en: '[PRE168]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This will add the `ViewModel` KTX library to your project. It includes a `viewModelScope`
    for `ViewModel`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `ViewModel` KTX 库添加到你的项目中。它包括一个 `viewModelScope` 用于 `ViewModel`。
- en: 'Open the `MovieViewModel` class, navigate to the `fetchMovies` function, and
    add the following code:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieViewModel` 类，导航到 `fetchMovies` 函数，并添加以下代码：
- en: '[PRE169]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: This will create a coroutine that will run in `Dispatchers.IO` (on a background
    thread for network operations). The coroutine will be launched using `viewModelScope`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个将在 `Dispatchers.IO`（网络操作的后台线程）上运行的协程。协程将通过 `viewModelScope` 启动。
- en: 'In the `fetchMovies` coroutine, call the MovieRepository’s `fetchMovies` function
    to fetch the list of movies from The Movie Database API:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `fetchMovies` 协程中，调用 MovieRepository 的 `fetchMovies` 函数以从 The Movie Database
    API 获取电影列表：
- en: '[PRE170]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The coroutine will be launched and will call the `fetchMovies` function from
    `MovieRepository`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 协程将被启动，并将调用 `MovieRepository` 中的 `fetchMovies` 函数。
- en: 'Run the application. You will see that the app displays a list of movies (with
    a poster and a title), as shown in the following screenshot:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。你将看到应用程序显示了一个电影列表（带有海报和标题），如下面的截图所示：
- en: '![Figure 2.4 –The app displaying a list of movies'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 显示电影列表的应用程序]'
- en: '](img/Figure_2.04_B17773.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.04_B17773.jpg)'
- en: Figure 2.4 –The app displaying a list of movies
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 显示电影列表的应用程序
- en: In this exercise, you created a coroutine using the ViewModel’s `viewModelScope`,
    used the `launch` coroutine builder, and executed a task to fetch the movies from
    the repository.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用 ViewModel 的 `viewModelScope` 创建了一个协程，使用了 `launch` 协程构建器，并执行了一个从仓库获取电影的任务。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned more about Kotlin coroutines and how you can use
    them for asynchronous programming in Android.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了更多关于 Kotlin 协程以及如何在 Android 中使用它们进行异步编程。
- en: You learned how to create coroutines with coroutine builders such as `launch`,
    `async`, and `runBlocking`. Then, you learned about dispatchers and using them
    to set the thread that the coroutines run on. You also learned about coroutine
    scopes and built-in scopes such as `viewModelScope` and `lifecycleScope`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用 `launch`、`async` 和 `runBlocking` 等协程构建器创建协程。然后，你学习了调度器以及如何使用它们来设置协程运行的线程。你还学习了协程作用域和内置作用域，如
    `viewModelScope` 和 `lifecycleScope`。
- en: After that, you learned about coroutine contexts and jobs. `CoroutineContext`
    is the context for the coroutine and includes elements such as dispatchers that
    the coroutine will run on and a job, which you can use to manage the coroutine’s
    task.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你学习了协程上下文和任务。`CoroutineContext` 是协程的上下文，包括协程将运行的调度器等元素，以及一个任务，你可以用它来管理协程的任务。
- en: Finally, you completed an exercise where you added a coroutine to an Android
    project. You used the ViewModel’s `viewModelScope` for the coroutine scope, the
    `launch` coroutine builder, and implemented the coroutine to fetch the list of
    movies using `Dispatchers.IO`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你完成了一个练习，在其中你将一个协程添加到了 Android 项目中。你使用了 ViewModel 的 `viewModelScope` 作为协程作用域，`launch`
    协程构建器，并实现了使用 `Dispatchers.IO` 获取电影列表的协程。
- en: In the next chapter, you will learn how to handle coroutine cancelations, timeouts,
    and exceptions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何处理协程取消、超时和异常。
