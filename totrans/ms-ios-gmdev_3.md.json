["```swift\n#import <Availability.h>\n\n#ifndef __IPHONE_5_0\n#warning \"This project uses features only available in iOS SDK 5.0 and later.\"\n#endif\n\n#ifdef __OBJC__\n    #import <UIKit/UIKit.h>\n    #import <Foundation/Foundation.h>\n#endif\n```", "```swift\n#import <UIKit/UIKit.h>\n\n@interface ViewController : UIViewController\n\n@end\n```", "```swift\n#import \"ViewController.h\"\n#import \"GameLevelScene.h\"\n\n@implementation ViewController\n\n-(void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n\n    //Configure the view.\n    SKView * skView = (SKView *)self.view;\n    skView.showsFPS = YES;\n    skView.showsNodeCount = YES;\n\n    //Create and Configure the scene.\n    SKScene * scene = [GameLevelScene sceneWithSize: skView.bounds.size];\n    scene.scaleMode = SKSceneScaleModeAspectFill;\n\n    //Present (or show) le scene.\n    [skView presentScene:scene];\n}\n\n- (BOOL)shouldAutorotate\n{\n    return YES;\n}\n\n- (NSUInteger)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskLandscape;\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n```", "```swift\n#import \"ViewController.h\"\n#import \"GameLevelScene.h\"\n```", "```swift\n-(void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n\n    //Configure the view.\n    SKView * skView = (SKView *)self.view;\n    skView.showsFPS = YES;\n    skView.showsNodeCount = YES;\n\n    //Create and Configure the scene.\n    SKScene * scene = [GameLevelScene sceneWithSize: skView.bounds.size];\n    scene.scaleMode = SKSceneScaleModeAspectFill;\n\n    //Present le scene.\n    [skView presentScene:scene];\n}\n```", "```swift\n#import <SpriteKit/SpriteKit.h>\n\n@interface GameLevelScene : SKScene\n\n@end\n```", "```swift\n#import \"GameLevelScene.h\"\n\n@implementation GameLevelScene\n\n-(id)initWithSize:(CGSize)size {\n\n  if (self = [super initWithSize:size]) {\n\n  }\n  return self;\n}\n\n@end\n```", "```swift\n0x22d9a <+138>: movl   %eax, -0x10(%ebp)\n2015-04-30 11:33:20.916 Adesa[25543:4462832] -[UIView setShowsFPS:]: unrecognized selector sent to instance 0x7a660940\n2015-04-30 11:33:20.918 Adesa[25543:4462832] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView setShowsFPS:]: unrecognized selector sent to instance 0x7a660940'\n*** First throw call stack:\n(\n(LOTS OF WRITING HERE)\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n(lldb)\n```", "```swift\n#import <SpriteKit/SpriteKit.h>\n\n@interface Player : SKSpriteNode\n\n@end\n```", "```swift\n@interface GameLevelScene()\n@property (nonatomic, strong) JSTileMap *map\n@end\n```", "```swift\nself.backgroundColor = [SKColor colorWithRed:.25 green:.0 blue:.25 alpha:1.0];\n\nself.map = [JSTileMap mapNamed:@\"level1.tmx\"];\n[self addChild:self.map];\n```", "```swift\n#import \"GameLevelScene.h\"\n#import \"JSTileMap.h\"\n\n@interface GameLevelScene()\n@property (nonatomic, strong) JSTileMap *map;\n@end\n\n@implementation GameLevelScene\n\n-(id)initWithSize:(CGSize)size {\n    if (self = [super initWithSize:size]) {\n        //CUS ITS SKY FALL!...This makes the background purple...\n        self.backgroundColor = [SKColor colorWithRed:.25 green:.0 blue:.25 alpha:1.0];\n\n        self.map = [JSTileMap mapNamed:@\"level1.tmx\"];\n        [self addChild:self.map];\n    }\n    return self;\n}\n\n@end\n```", "```swift\nself.player = [[Player alloc] initWithImageNamed:@\"P1Idle\"];\nself.player.position = (CGPointMake(100, 50);\nself.player.zPosition = 15;\n[self.map addChild: self.player];\n```", "```swift\n@property (nonatomic, assign) NSTimeInterval previousTime;\n```", "```swift\n- (void)update:(NSTimeInterval)currentTime\n{\n\n    NSTimeInterval delta = currentTime - self.previousTime;\n\n    if (delta > 0.02) {\n        delta = 0.02;\n    }\n\n    self.previousTime = currentTime;\n\n    [self.player1 update:delta];\n}\n```", "```swift\n#import <SpriteKit/SpriteKit.h>\n\n@interface Player : SKSpriteNode //(These lines should be here already)\n\n@property (nonatomic, assign) CGPoint velocity;\n-(void) update:(NSTimeInterval)delta;\n@end\n```", "```swift\n#import \"Player.h\"\n\n#import \"SKTUtils.h\"\n\n@implementation Player\n\n- (instancetype)initWithImageNamed:(NSString *)name {\n    if (self == [super initWithImageNamed:name]) {\n        self.velocity = CGPointMake(0.0, 0.0);\n    }\n    return self;\n}\n\n- (void)update:(NSTimeInterval)delta {\n\n    CGPoint gravity = CGPointMake(0.0, -450.0);\n\n    CGPoint gravityStep = CGPointMultiplyScalar(gravity, delta);\n\n    self.velocity = CGPointAdd(self.velocity, gravityStep);\n    CGPoint velocityStep = CGPointMultiplyScalar(self.velocity, delta);\n\n    self.position = CGPointAdd(self.position, velocityStep);\n}\n\n@end\n```", "```swift\n-(CGRect)collisionBox;\n```", "```swift\n-(CGRect)collisionBox {\n  return CGRectInset(self.frame, 2, 0);\n}\n```", "```swift\n-(CGRect)tileRectFromTileCoords:(CGPoint)tileCoords {\n  float levelHeightInPixels = self.map.mapSize.height * self.map.tileSize.height;\n```", "```swift\n  CGPoint origin = CGPointMake(tileCoords.x * self.map.tileSize.width, levelHeightInPixels - ((tileCoords.y + 1) * self.map.tileSize.height));\n\n  return CGRectMake(origin.x, origin.y, self.map.tileSize.width, self.map.tileSize.height);\n}\n```", "```swift\n- (NSInteger)tileGIDAtTileCoord:(CGPoint)coord forLayer:(TMXLayer *)layer {\n  TMXLayerInfo *layerInfo = layer.layerInfo;\n  return [layerInfo tileGidAtCoord:coord];\n}\n```", "```swift\n- (void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer {\n\n    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};\n    for (NSUInteger i = 0; i < 8; i++) {\n        NSInteger tileIndex = indices[i];\n\n        CGRect playerRect = [player collisionBox];\n\n        CGPoint playerCoord = [layer coordForPoint:player.position];\n\n        NSInteger tileColumn = tileIndex % 3;\n        NSInteger tileRow = tileIndex / 3;\n        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));\n\n        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:layer];\n\n        if (gid) {\n\n            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];\n\n            NSLog(@\"GID %ld, Tile Coord %@, Tile Rect %@, player rect %@\", (long)gid, NSStringFromCGPoint(tileCoord), NSStringFromCGRect(tileRect), NSStringFromCGRect(playerRect));\n            //after this is where we write our collision resolving\n        }\n\n    }\n}\n```", "```swift\n// Add to the @interface section with all our other properties\n@property (nonatomic, strong) TMXLayer *walls;\n\n// Add to the init method, after the map is added to the layer\nself.walls = [self.map layerNamed:@\"walls\"];\n\n// Add to the bottom of the update method\n[self checkForAndResolveCollisionsForPlayer:self.player1 forLayer:self.walls];\n```", "```swift\n@property (nonatomic, assign) CGPoint desiredPosition;\n```", "```swift\n-(CGRect)collisionBox {\n    CGRect boundingBox = CGRectOffset(self.frame, 2, 0);\n    CGPoint difference = CGPointSubtract(self.desiredPosition, self.position);\n    return CGRectOffset(boundingBox, difference.x, difference.y);\n}\n```", "```swift\nself.position = CGPointAdd(self.position, velocityStep);\n```", "```swift\nself.desiredPosition = CGPointAdd(self.position, velocityStep);\n```", "```swift\n- (void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer\n{\n    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};\n    player.onGround = NO;  ////Here\n    for (NSUInteger i = 0; i < 8; i++) {\n        NSInteger tileIndex = indices[i];\n\n        CGRect playerRect = [player collisionBox];\n        CGPoint playerCoord = [layer coordForPoint:player.desiredPosition];\n\n        NSInteger tileColumn = tileIndex % 3;\n        NSInteger tileRow = tileIndex / 3;\n        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));\n\n        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:layer];\n        if (gid != 0) {\n            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];\n            //NSLog(@\"GID %ld, Tile Coord %@, Tile Rect %@, player rect %@\", (long)gid, NSStringFromCGPoint(tileCoord), NSStringFromCGRect(tileRect), NSStringFromCGRect(playerRect));\n\n            if (CGRectIntersectsRect(playerRect, tileRect)) {\n                CGRect intersection = CGRectIntersection(playerRect, tileRect);\n\n                if (tileIndex == 7) {\n                    //tile is directly below Player\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height);\n                    player.velocity = CGPointMake(player.velocity.x, 0.0);\n                    player.onGround = YES;\n                } else if (tileIndex == 1) {\n                    //tile is directly above Player\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y - intersection.size.height);\n                } else if (tileIndex == 3) {\n                    //tile is left of Player\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x + intersection.size.width, player.desiredPosition.y);\n                } else if (tileIndex == 5) {\n                    //tile is right of Player\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x - intersection.size.width, player.desiredPosition.y);\n                    //3\n                } else {\n                    if (intersection.size.width > intersection.size.height) {\n                        //tile is diagonal, but resolving collision vertically\n\n                        player.velocity = CGPointMake(player.velocity.x, 0.0);\n                        float intersectionHeight;\n                        if (tileIndex > 4) {\n                            intersectionHeight = intersection.size.height;\n                            player.onGround = YES;\n                        } else {\n                            intersectionHeight = -intersection.size.height;\n                        }\n                        player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height );\n                    } else {\n                        //tile is diagonal, but resolving horizontally\n                        float intersectionWidth;\n                        if (tileIndex == 6 || tileIndex == 0) {\n                            intersectionWidth = intersection.size.width;\n                        } else {\n                            intersectionWidth = -intersection.size.width;\n                        }\n\n                        player.desiredPosition = CGPointMake(player.desiredPosition.x  + intersectionWidth, player.desiredPosition.y);\n                    }\n                }\n            }\n        }\n    }\n\n    player.position = player.desiredPosition;\n}\n```", "```swift\n@property (nonatomic, assign) BOOL onGround;\n```", "```swift\n@property (nonatomic, assign) BOOL walking;\n@property (nonatomic, assign) BOOL jumping;\n```", "```swift\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n        if (touchLocation.x > self.size.width / 2.0) {\n            self.player1.jumping = YES;\n        } else {\n            self.player1.walking = YES;\n        }\n    }\n}\n\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n    for (UITouch *touch in touches) {\n\n        float halfWidth = self.size.width / 2.0;\n        CGPoint touchLocation = [touch locationInNode:self];â€©        \n        //get previous touch and convert it to node space\n        CGPoint previousTouchLocation = [touch previousLocationInNode:self];\n\n        if (touchLocation.x > halfWidth && previousTouchLocation.x <= halfWidth) {\n            self.player1.walking = NO;\n            self.player1.jumping = YES;\n        } else if (previousTouchLocation.x > halfWidth && touchLocation.x <= halfWidth) {\n            self.player1.walking = YES;\n            self.player1.jumping = NO;\n        }\n    }\n}\n\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n        if (touchLocation.x < self.size.width / 2.0) {\n            self.player1.walking = NO;\n        } else {\n            self.player1.jumping = NO;\n        }\n    }\n}\n```", "```swift\nself.userInteractionEnabled = YES;\n```", "```swift\n- (void)update:(NSTimeInterval)delta {\n\n    CGPoint gravity = CGPointMake(0.0, -450.0);\n\n    CGPoint gravityStep = CGPointMultiplyScalar(gravity, delta);\n\n CGPoint movingForward = CGPointMake(750.0, 0.0);\n CGPoint movingForwardStep = CGPointMultiplyScalar(walking, delta);\n\n    self.velocity = CGPointAdd(self.velocity, gravityStep);\n\n self.velocity = CGPointMake(self.velocity.x *0.9, self.velocity.y);\n\n //here he shall fly!\n\n if (self.walking) {\n\n self.velocity = CGPointAdd(self.velocity, movingForwardStep);\n}\n\n CGPoint minimumMovement = CGPointMake(0.0, -450);\n CGPoint maximumMovement = CGPointMake(120.0, 250.0);\n self.velocity = CGPointMake(Clamp(self.velocity.x, minimumMovement.x, maximumMovement.x), Clamp(self.velocity.y, minimumMovement.y, maximumMovement.y));\n\n    CGPoint velocityStep = CGPointMultiplyScalar(self.velocity, delta);\n\n    self.desiredPosition = CGPointAdd(self.position, velocityStep);\n}\n```", "```swift\nCGPoint jumpForce = CGPointMake(0.0, 310.0);\nfloat jumpTime = 150.0;\n\nif (self.jumping && self.onGround) {\n  self.velocity = CGPointAdd(self.velocity, jumpForce);\n} else if (!self.jumping && self.velocity.y > jumpTime) {\n  self.velocity = CGPointMake(self.velocity.x, jumpTime);\n}\n```", "```swift\n@property (nonatomic, assign) BOOL goingBackwards;\n```", "```swift\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n        if (touchLocation.x > self.size.width / 2.0) {\n            self.player1.jumping = YES;\n        }        \n        else {\n            if (touchLocation.x < self.size.width / 2.0) {\n                if (touchLocation.y > self.size.height / 2){\n                    self.player1.goingBackwards = YES;\n        self.player1.xScale = -1.0;\n                }\n                if (touchLocation.y < self.size.height / 2){\n                    self.player1.walking = YES;\n            self.player1.xScale = 1.0;\n                }\n            }\n\n        }\n    }\n}\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n    for (UITouch *touch in touches) {\n\n        float halfWidth = self.size.width / 2.0;\n        CGPoint touchLocation = [touch locationInNode:self];\n\n        //get previous touch and convert it to node space\n        CGPoint previousTouchLocation = [touch previousLocationInNode:self];\n\n        if (touchLocation.x > halfWidth && previousTouchLocation.x <= halfWidth) {\n            self.player1.walking = NO;\n            self.player1.goingBackwards = NO;\n            self.player1.jumping = YES;\n        } else if (previousTouchLocation.x > halfWidth && touchLocation.x <= halfWidth) {\n            //self.player1.walking = YES;\n            self.player1.goingBackwards = NO;\n            self.player1.jumping = NO;\n        }\n        else if (previousTouchLocation.x > halfWidth && touchLocation.x <= halfWidth) {\n            if (touchLocation.y > self.size.height / 2){\n            self.player1.walking = NO;\n            //self.player1.goingBackwards = YES;\n            self.player1.jumping = NO;\n            }\n        }\n    }\n}\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n        if (touchLocation.x < self.size.width / 2.0) {\n            //self.player1.walking = NO;\n            if (touchLocation.x < self.size.width / 2.0) {\n                if (touchLocation.y > self.size.height / 2){\n                    self.player1.goingBackwards = NO;\n                }\n                if (touchLocation.y < self.size.height / 2){\n                    self.player1.walking = NO;\n                }\n            }\n\n        } else {\n            self.player1.jumping = NO;\n        }\n    }\n}\n```", "```swift\n    CGPoint movingBackward = CGPointMake(-750.0, 0.0);\n    CGPoint movingBackwardStep = CGPointMultiplyScalar(movingBackward, delta);\n```", "```swift\n    if (self.goingBackwards) {\n        self.velocity = CGPointAdd(self.velocity, movingBackwardStep);\n    }\n  //The below value has to be changed to allow a negative x value to walk backwards.\n    CGPoint minimumMovement = CGPointMake(-750.0, -450);\n```", "```swift\n//Add this in the import section\n#import \"SKTUtils.h\"\n\n//Then add this wherever you like, after any of the methods\n- (void)setViewpointCenter:(CGPoint)position {\n  NSInteger x = MAX(position.x, self.size.width / 2);\n  NSInteger y = MAX(position.y, self.size.height / 2);\n  x = MIN(x, (self.map.mapSize.width * self.map.tileSize.width) - self.size.width / 2);\n  y = MIN(y, (self.map.mapSize.height * self.map.tileSize.height) - self.size.height / 2);\n  CGPoint actualPosition = CGPointMake(x, y);\n  CGPoint centerOfView = CGPointMake(self.size.width/2, self.size.height/2);\n  CGPoint viewPoint = CGPointSubtract(centerOfView, actualPosition);\n  self.map.position = viewPoint;\n}\n\n//Then add this in the Update method\n[self setViewpointCenter:self.player1.position];\n```", "```swift\n//Add this at the top of the code\n@property (nonatomic, strong) TMXLayer *hazards;\n\n//Add this in the initWithSize method after we set up the Walls\nself.hazards = [self.map layerNamed:@\"hazards\"];\n\n//add this in the checkForAndResolveCollisionsForPlayer\n[self handleHazardCollisions:self.player1];\n\n//Add this anywhere!\n\n- (void)handleHazardCollisions:(Player *)player\n{\n    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};\n\n    for (NSUInteger i = 0; i < 8; i++) {\n        NSInteger tileIndex = indices[i];\n\n        CGRect playerRect = [player collisionBox];\n        CGPoint playerCoord = [self.hazards coordForPoint:player.desiredPosition];\n\n        NSInteger tileColumn = tileIndex % 3;\n        NSInteger tileRow = tileIndex / 3;\n        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));\n\n        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:self.hazards];\n        if (gid != 0) {\n            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];\n            if (CGRectIntersectsRect(playerRect, tileRect)) {\n                [self gameOver:0];\n            }\n        }\n    }\n}\n```", "```swift\n//add this at the top with all the other properties\n@property (nonatomic, assign) BOOL gameOver;\n\n//Put this in the update method\nif (self.gameOver) return;\n\n//Then add this method anywhere in the GameLevelScene\n-(void)gameOver:(BOOL)won {\n\n    self.gameOver = YES;\n\n    NSString *gameText;\n    if (won) {\n        gameText = @\"Level Complete!\";\n    } else {\n        gameText = @\"You have failed!\";\n    }\n\n    SKLabelNode *endGameLabel = [SKLabelNode labelNodeWithFontNamed:@\"AvenirNext-Heavy\"];\n    endGameLabel.text = gameText;\n    endGameLabel.fontSize = 40;\n    endGameLabel.position = CGPointMake(self.size.width / 2.0, self.size.height / 1.7);\n    [self addChild:endGameLabel];\n\n    UIButton *replay = [UIButton buttonWithType:UIButtonTypeCustom];\n    replay.tag = 321;\n    UIImage *replayImage = [UIImage imageNamed:@\"replay\"];\n    [replay setImage:replayImage forState:UIControlStateNormal];\n    [replay addTarget:self action:@selector(replay:) forControlEvents:UIControlEventTouchUpInside];\n    replay.frame = CGRectMake(self.size.width / 2.0 - replayImage.size.width / 2.0, self.size.height / 2.0 - replayImage.size.height / 2.0, replayImage.size.width, replayImage.size.height);\n    [self.view addSubview:replay];\n}\n\n//Add this into the checkForAndResolveCollisionsForPlayer, after CGPoint playerCoord = [layer coordForPoint:player1.desiredPosition]; \nif (playerCoord.y >= self.map.mapSize.height - 1) {\n  [self gameOver:0];\n  return;\n}\n```", "```swift\n-(void)didHeWin {\n  if (self.player1.position.x > 3200.0) {\n    [self gameOver:1];\n  }\n}\n```", "```swift\n[self didHeWin];\n```"]