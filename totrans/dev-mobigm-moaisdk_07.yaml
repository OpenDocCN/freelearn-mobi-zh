- en: Chapter 7. Concentration Gameplay
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 集中游戏玩法
- en: After talking a little bit about assets and having our `ResourceManager` in
    place, we'll start building the *Concentration* gameplay. We'll talk about input
    handling, basic animations, and game states. These are the basis of gameplay implementation
    and will be useful from the smallest to the biggest game you develop using Moai
    SDK.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单讨论了资产并设置了我们的 `ResourceManager` 之后，我们将开始构建 *集中* 游戏玩法。我们将讨论输入处理、基本动画和游戏状态。这些都是游戏实现的基础，并且对于使用
    Moai SDK 开发的任何大小游戏都将非常有用。
- en: Grid
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格
- en: The first thing we're going to do is to display a grid of tiles that will be
    our playground. Just to start with, we'll display the back of the tiles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是显示一个瓦片网格，这将是我们玩耍的游乐场。仅为了开始，我们将显示瓦片的背面。
- en: Tilemaps
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓦片图
- en: A commonly used technique in game development is the implementation of **tilesets**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发中常用的一种技术是实现 **瓦片集**。
- en: The idea is to create one image that includes more than one asset in it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是创建一个包含多个资产的单一图像。
- en: 'We''re going to create a tileset called `tiles.png`. It consists of 12 tiles,
    11 different colors (the gray one for the back of the tiles), and the "empty tile"
    (white). It looks somewhat like the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `tiles.png` 的瓦片集。它由12个瓦片组成，11种不同的颜色（灰色用于瓦片的背面），以及“空瓦片”（白色）。它看起来有点像以下这样：
- en: '![Tilemaps](img/5064_07_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![瓦片图](img/5064_07_01.jpg)'
- en: 'You should be aware that what we''re going to do is to create a tiled image
    that will be indexed as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该意识到我们将要做的是创建一个索引如下所示的瓦片图像：
- en: '![Tilemaps](img/5064_07_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![瓦片图](img/5064_07_02.jpg)'
- en: This is the result of subdividing the actual image in two rows and six columns.
    We'll end up having twelve 62 x 62 tiles.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将实际图像分成两行和六列的结果。我们将最终拥有十二个 62 x 62 的瓦片。
- en: The implementation
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s start with the implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现开始：
- en: We need to create a file called `game.lua` that will hold all of the code for
    our gameplay.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为 `game.lua` 的文件，它将包含我们游戏玩法的所有代码。
- en: Open it and let's begin coding.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它，让我们开始编码。
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These constants will become useful as they define the grid dimensions (rows,
    columns, and tile size). The last one is used to avoid magic numbers when setting
    the default grid state. As we saw, the gray tile that we'll use as the back of
    the tiles is indexed by the number `1` (because it's the first in our tileset).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些常量将变得很有用，因为它们定义了网格尺寸（行、列和瓦片大小）。最后一个用于在设置默认网格状态时避免使用魔法数字。正如我们所见，我们将用作瓦片背面的灰色瓦片索引为数字
    `1`（因为它在我们瓦片集中是第一个）。
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This should be familiar to you now. To define our tileset, we'll use the tiled
    image called `tiles.png` that we created earlier, which has six columns and two
    rows.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这现在应该对你来说很熟悉了。为了定义我们的瓦片集，我们将使用我们之前创建的名为 `tiles.png` 的瓦片图像，它有六列和两行。
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We're creating a method called `Game:start()` that will take care of initializing
    everything and controlling the game loop. This will be called from `main.lua`
    later. For now, we will only display our grid on initialization. So what we'll
    do here is call a function named `initialize()` that will take care of all the
    actual initialization. We'll be adding more code to this method later.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为 `Game:start()` 的方法，它将负责初始化一切并控制游戏循环。这将在稍后的 `main.lua` 中被调用。现在，我们只会显示初始化时的网格。所以在这里，我们将调用一个名为
    `initialize()` 的函数，它将负责所有的实际初始化。我们稍后将在该方法中添加更多代码。
- en: 'The `initialize ()` function is as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`initialize()` 函数如下：'
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We make a layer that will handle all of the rendering from the gameplay (including
    our grid) and configure the viewport on it.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个层来处理游戏玩法中的所有渲染（包括我们的网格）并配置其视口。
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then we set the render table using that layer.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用该层设置渲染表。
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next step is to use `ResourceDefinitions` with a helper method called `setDefinitions
    ()`.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用带有辅助方法 `setDefinitions()` 的 `ResourceDefinitions`。
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After loading the resource definitions, we call another auxiliary function that
    initializes the tiles.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载资源定义后，我们调用另一个辅助函数来初始化瓦片。
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The idea behind `setDefinitions ()` is to take a table of definitions and load
    all of them at once, instead of one by one. It was not created in the previous
    chapter, but it should be pretty simple to implement. Just iterate through the
    parameter table and call `setDefinitions ()` on each entry. Please go ahead and
    try to implement it by yourself. Remember, you can always download the book's
    code, and the method will be there.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setDefinitions()`背后的想法是取一个定义表，并一次性加载所有这些定义，而不是逐个加载。它在前一章中没有创建，但应该很容易实现。只需遍历参数表，并对每个条目调用`setDefinitions()`。请尝试自己实现它。记住，你总是可以下载本书的代码，方法就在那里。'
- en: 'Now we need to take care of `initializeTiles ()`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要处理`initializeTiles()`：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First of all, we create the grid using the `MOAIGrid` class. Then we set it
    up. We use the grid and tile dimensions we defined earlier to configure our new
    `MOAIGrid`.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`MOAIGrid`类创建网格。然后我们设置它。我们使用之前定义的网格和瓦片尺寸来配置我们的新`MOAIGrid`。
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we set up the actual grid. We call the `setRow()` method with the row number
    as the first parameter. (Start from `1`; remember, we're using Lua!) The following
    parameters are the values of the tiles we want to show for each column. We will
    show the back tile across all the grids as an initial state for our game; that's
    why, we pass `BACK_TILE` as the tile number.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们设置实际的网格。我们使用行号作为第一个参数调用`setRow()`方法。（从`1`开始；记住，我们使用Lua！）以下参数是我们想要显示的每个列的瓦片值。我们将以初始状态在所有网格上显示背面瓦片，这就是为什么我们传递`BACK_TILE`作为瓦片编号的原因。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Go ahead and play a little bit, changing the values for these parameters. (Not
    the first one though; that's the row!) Put some numbers between `2` and `11`;
    you should expect to see some color on the gray sea.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，先玩一会儿，改变这些参数的值。（不过第一个参数除外；那是行！）在`2`和`11`之间输入一些数字；你应该会看到灰色海洋上出现一些颜色。
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we create a table called `tiles` and store the tileset in there, as well
    as a new Prop. The usage of a Prop is basically the same as we did earlier; the
    only difference is that we now use `setGrid ()` in order to make the Prop follow
    the size and configuration of that grid.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`tiles`的表，并将瓦片集存储在那里，以及一个新的属性。属性的使用基本上与我们之前做的一样；唯一的区别是我们现在使用`setGrid()`来使属性跟随网格的大小和配置。
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since grids don't center over their elements (they just draw them from offsets),
    we need to center them ourselves. In this case, `(0,0)` is at the bottom-left
    corner of the Prop (instead of the middle). We need to offset it, and that's what
    we do by calling the `setLoc()` method; we move it by half of its columns times
    the tile's width (in the *x* axis), and by half of its rows times the tile's height
    (in the *y* axis).
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于网格不会在其元素上居中（它们只是从偏移量绘制它们），我们需要自己居中它们。在这种情况下，`(0,0)`位于属性的左下角（而不是中间）。我们需要偏移它，这就是我们通过调用`setLoc()`方法来做的；我们通过瓦片的宽度的一半（在*x*轴上）和瓦片高度的一半（在*y*轴上）移动它。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Moai SDK has a family of methods to deal with position, rotation, and scale.
    There are three families, namely the `set*` methods (that force a specific value),
    the `move*` methods (that generate animations applying a delta over time), and
    the `seek*` methods (that generate animations by going from the actual value to
    the specified value in a certain amount of time). To modify position you use `Loc`,
    for rotation `Rot`, and for scale `Scl`. So, for example, if you wanted to rotate
    the `tiles` Prop by 30 degrees within 10 seconds, you'd call `self.tiles.prop:moveRot
    (30, 10)`.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Moai SDK有一系列处理位置、旋转和缩放的方法。有三个系列，即`set*`方法（强制设置特定值）、`move*`方法（通过在一段时间内应用增量生成动画）和`seek*`方法（通过在一段时间内从实际值到指定值生成动画）。要修改位置，使用`Loc`，旋转使用`Rot`，缩放使用`Scl`。所以，例如，如果你想将`tiles`属性在10秒内旋转30度，你会调用`self.tiles.prop:moveRot(30,
    10)`。
- en: There's some more to these methods (like the curve they use to interpolate the
    values); you should check them out at [http://getmoai.com/docs/class_m_o_a_i_transform2_d.html](http://getmoai.com/docs/class_m_o_a_i_transform2_d.html).
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法还有一些其他内容（比如它们用来插值值的曲线）；你应该在[http://getmoai.com/docs/class_m_o_a_i_transform2_d.html](http://getmoai.com/docs/class_m_o_a_i_transform2_d.html)上查看它们。
- en: '[PRE12]'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We add the Prop to the layer and we're done.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将属性添加到层中，然后就可以完成了。
- en: 'The only thing remaining is to call this from `main.lua`. Below the viewport
    definition add the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事就是从`main.lua`中调用这个函数。在视口定义下方添加以下代码：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will run our game in a separate Lua coroutine; this is done in order to allow
    it to have a game loop that is detached from the main coroutine flow. This will
    be handy for processing input.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个单独的Lua协程中运行我们的游戏；这样做是为了允许它有一个与主协程流程分离的游戏循环。这将便于处理输入。
- en: That should be it; if you run the project now, you should see the grid with
    all 20 back tiles.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够了；如果你现在运行项目，你应该能看到带有所有20个背面瓷砖的网格。
- en: Input
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入
- en: The next step in our journey is to add input handling. We have to create a file
    called `input_manager.lua`; it will be in charge of listening to input events
    and will be queried by our game when needed. We will create it so that it will
    be usable with both mouse devices and touchscreens.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的下一步是添加输入处理。我们必须创建一个名为`input_manager.lua`的文件；它将负责监听输入事件，并在需要时被我们的游戏查询。我们将创建它，使其可以与鼠标设备和触摸屏一起使用。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generally speaking, all hosts are supposed to implement their own input schema.
    We won't see this in detail in this book, but so you understand where this comes
    from, take a look at the hosts that are shipped with Moai SDK.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，所有主机都应该实现它们自己的输入模式。在这本书中，我们不会详细看到这一点，但为了您理解这从何而来，请查看随Moai SDK一起提供的宿主。
- en: Search for all the references to the `AKUReserveInputDevice*` and `AKUSetInputDevice*`
    method calls in `moai-sdk/hosts/src/GlutHost.cpp`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`moai-sdk/hosts/src/GlutHost.cpp`中搜索所有对`AKUReserveInputDevice*`和`AKUSetInputDevice*`方法调用的引用。
- en: We'll now inspect only the most important methods; please take a look at the
    full code in order to understand how everything fits together.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查最重要的方法；请查看完整的代码以了解一切是如何结合在一起的。
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, this method checks if we have a pointer, and if we do, it creates
    a callback function (`pointerCallback`) that is passed to that pointer in order
    to update the `x` and `y` positions. It also talks to the touch sensor (`MOAITouchSensor`)
    in order to do the same in case we're not using a mouse but a touch-screen instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此方法检查我们是否有指针，如果有，它将创建一个回调函数（`pointerCallback`），并将其传递给该指针以更新`x`和`y`位置。它还会与触摸传感器（`MOAITouchSensor`）通信，以便在不是使用鼠标而是触摸屏的情况下执行相同的操作。
- en: Besides this, another important method is `isDown ()`, which is used to know
    if we're clicking or touching the screen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，另一个重要的方法是`isDown()`，它用于知道我们是否在点击或触摸屏幕。
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is querying both the mouse and the touch sensor asking if we're
    clicking or touching respectively. We'll use this in our game loop to identify
    input. Remember to include this file in `main.lua` after the `require 'resource_manager'`
    statement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法正在查询鼠标和触摸传感器，询问我们是否在点击或触摸。我们将在游戏循环中使用此方法来识别输入。请记住，在`main.lua`中的`require 'resource_manager'`语句之后包含此文件。
- en: Gameplay
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法
- en: Now let's take a look at what we need in order to implement the gameplay. First
    of all, we need to create all of the structures (and initialize them) for the
    game state. We'll be using another grid, this time to store a randomized distribution
    of numbers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现游戏玩法所需的元素。首先，我们需要创建游戏状态的所有结构（并初始化它们）。我们将使用另一个网格，这次用来存储数字的随机分布。
- en: Initialization
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: Add a call at the bottom of the `Game:initialize ()` method to an auxiliary
    function.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game:initialize()`方法的底部添加对辅助函数的调用。
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add the auxiliary function as well.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加辅助函数。
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we create a grid that will hold the distribution of our colors. This
    grid also has a dimension of 5 x 4\. Note that we don't need to set the tile size
    now as this grid won't be rendered.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个网格，它将持有我们颜色的分布。这个网格也有一个5 x 4的维度。请注意，我们现在不需要设置瓷砖大小，因为这个网格不会被渲染。
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This table is just a temporary array of tiles; as you see, we start from `2`
    (`1` is the back tile, remember?) and repeat each number twice. These numbers
    represent the color (or the tile offset) on our tileset.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个表只是一个临时瓷砖数组；如您所见，我们从`2`开始（记住，`1`是背面瓷砖），每个数字重复两次。这些数字代表我们的瓷砖集中的颜色（或瓷砖偏移量）。
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next thing we do is to iterate over all of the grid cells, assign one of
    the values to the `tiles` table at random, and remove it from the table so it
    doesn't get selected more than once. In this way, we fill our `distributionGrid`
    with a randomized order of the color pairs. Nice.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步我们要做的是遍历所有的网格单元，随机地将其中一个值分配给`tiles`表，并从表中移除它，这样它就不会被选中超过一次。通过这种方式，我们以随机顺序填充了`distributionGrid`中的颜色对。
- en: '[PRE20]'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next thing we need is a place to store the cells that were selected in the
    current turn. We'll use a table called `selectedCells`, and it will start displaying
    two `nil` cells because we haven't selected anything yet.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步我们需要的是一个地方来存储当前回合中选中的单元格。我们将使用一个名为`selectedCells`的表，并且它将显示两个`nil`单元格，因为我们还没有选择任何东西。
- en: And that's it for the gameplay initialization part.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏初始化部分到此结束。
- en: Input processing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入处理
- en: Now we need to process input from the user.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理用户的输入。
- en: 'We need to append some code to the `Game:start ()` method (below the call to
    `Game:initialize ()`):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`Game:start ()`方法中添加一些代码（在调用`Game:initialize ()`之后）：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We want to know if in the previous simulation step the user was clicking or
    tapping the screen. We'll store that information in `wasClicking`.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想知道在之前的模拟步骤中，用户是否在点击或轻触屏幕。我们将该信息存储在`wasClicking`中。
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then we add an infinite loop (beware of algorithms!) that *processes input*
    and uses the magical method `coroutine.yield()` that delegates the flow to the
    main routine, allowing `MOAISim` to do another simulation step. In this way, we
    avoid having an endless loop that freezes the game. Instead, we do all the rendering,
    Action Tree and Node Graph processing; and when all of that is done, it comes
    back to our coroutine to process the input once more.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个无限循环（注意算法！）来*处理输入*并使用神奇的方法`coroutine.yield()`，该方法将流程委托给主程序，允许`MOAISim`进行另一个模拟步骤。这样，我们避免了无限循环而使游戏冻结。相反，我们完成所有的渲染、动作树和节点图处理；当所有这些都完成时，它回到我们的协程再次处理输入。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you expect your game to update the screen (render) and it's not doing it,
    it's likely that you've forgotten to run `coroutine.yield()` to allow rendering
    before continuing with your code. Think about the loading screens for example.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你期望你的游戏更新屏幕（渲染）但它没有这样做，那么很可能是你忘记运行`coroutine.yield()`来允许在继续代码之前进行渲染。例如，考虑加载屏幕。
- en: Now the next method we'll take care of is the one that actually processes the
    input.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将处理下一个方法，即实际处理输入的方法。
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the player is clicking now and was not clicking in the previous simulation
    step (to avoid selecting multiple times when holding the mouse button), we want
    to select a tile.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家现在正在点击，而在之前的模拟步骤中没有点击（为了避免在按住鼠标按钮时多次选择），我们想要选择一个方块。
- en: '[PRE24]'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The way we choose the tile is a pretty neat trick. We gather the mouse position
    that is represented in the window coordinate system.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择方块的方式是一个相当巧妙的技巧。我们收集表示在窗口坐标系中的鼠标位置。
- en: '[PRE25]'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need to transform them into model coordinates to do our trick by first converting
    them to world coordinates (through the layer). After these conversions, what we
    get in `modelX` and `modelY` is the offset in pixels from the bottom-left corner
    of our grid.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将它们转换为模型坐标，通过首先将它们转换为世界坐标（通过层）来完成我们的技巧。在这些转换之后，我们在`modelX`和`modelY`中得到的是从网格左下角开始的像素偏移。
- en: '[PRE26]'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we divide `modelX` and `modelY` by the dimensions of the cells, we''ll get
    the cell column and row indices. Nice *mathemagics*. Now it''s just a matter of
    calling an auxiliary function that will take care of the consequences of that
    click:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将`modelX`和`modelY`除以单元格的尺寸，我们将得到单元格的列和行索引。这是很棒的*数学魔法*。现在只需要调用一个辅助函数，该函数将处理点击的后果：
- en: '[PRE27]'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Oh! And don't forget to update `wasClicking`. We need to store the value of
    `InputManager:isDown ()` on it because we'll need it in the next simulation step.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哦！别忘了更新`wasClicking`。我们需要在它上面存储`InputManager:isDown ()`的值，因为我们将在下一个模拟步骤中使用它。
- en: Choosing a cell
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择单元格
- en: 'Now we have to implement the following cell-choosing method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须实现以下单元格选择方法：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If no cell was selected previously (the first one is nil), we have to select
    it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前没有选中任何单元格（第一个是nil），我们必须选中它。
- en: '[PRE29]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We always need to check that the cell we're clicking has not been removed from
    the game.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们始终需要检查我们点击的单元格是否没有被从游戏中移除。
- en: '[PRE30]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We put the selected cell's column and row in the `selectedCells` table.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将选中的单元格的列和行放入`selectedCells`表中。
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then we swap it to reveal its color.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们交换它以显示其颜色。
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We continue with the case if a tile was selected previously.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前已经选中了方块，我们继续处理该情况。
- en: '[PRE33]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the player clicked the same tile, what we want is to swap it back. Set the
    same tile as the second selected cell (`selectedCells[2]`) and reset them.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家点击了相同的方块，我们希望将其换回。将相同的方块设置为第二个选中的单元格（`selectedCells[2]`）并重置它们。
- en: '[PRE34]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember to check that the cell we're clicking has not been removed from the
    game.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住检查我们点击的单元格是否没有被从游戏中移除。
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The same logic is applied here to select the cell and swap it. (Oh no! code
    duplication!)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样的逻辑也应用于此处以选择单元格并交换它。（哦，不！代码重复！）
- en: 'Now the core of the gameplay:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是游戏的核心：
- en: '[PRE36]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We gather both values and store them in `value1` and `value2` respectively.
    These variables contain the color of the tiles that the user selected.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们收集这两个值并将它们分别存储在 `value1` 和 `value2` 中。这些变量包含用户所选瓷砖的颜色。
- en: '[PRE37]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the colors are the same, we remove the tiles.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果颜色相同，我们移除瓷砖。
- en: '[PRE38]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If they differ, we swap them back. And that's it.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们不同，我们将它们交换回来。就这样。
- en: '[PRE39]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After a nice tail of `end` sentences, we're ready to implement the auxiliary
    methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段美好的 `end` 句尾之后，我们准备实现辅助方法。
- en: Tile swapping
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓷砖交换
- en: 'To swap our tiles, we''ll create the following `swapTile ()` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了交换我们的瓷砖，我们将创建以下 `swapTile ()` 方法：
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What we do here is retrieve the color value from our `distributrionGrid` and
    set it into the rendered grid. This is really magical; don't you love it?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是从我们的 `distributrionGrid` 中检索颜色值并将其设置到渲染网格中。这真的很神奇；你不爱它吗？
- en: The result is that the tile changes its color according to the distribution
    on our `distributionGrid`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是瓷砖的颜色根据我们的 `distributionGrid` 上的分布而改变。
- en: Every distribution is randomized, so this will be different every time you play.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分布都是随机的，所以每次你玩的时候都会不同。
- en: Resetting tiles
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置瓷砖
- en: 'We need two more constants at the top of `game.lua` for the next methods (we
    will use these constants to avoid magic numbers):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `game.lua` 的顶部添加两个更多常量，用于下一个方法（我们将使用这些常量来避免魔法数字）：
- en: '[PRE41]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`EMPTY_TILE` is the white space that we have after all the tiles; we''ll use
    it to remove the tiles that are not in the game. That''s the index `12`.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EMPTY_TILE` 是我们在所有瓷砖之后剩下的空白空间；我们将用它来移除不在游戏中的瓷砖。这是索引 `12`。'
- en: '[PRE42]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`DELAY_TIME` is a time in seconds that we will use to defer the swapping back
    of the tiles, in order to allow the user to see what''s the second color he has
    chosen. (In fact, after finishing the chapter, change it to zero and see what
    happens).'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DELAY_TIME` 是我们将用来延迟瓷砖交换回的时间（秒），以便用户可以看到他选择的第二种颜色。（实际上，在完成章节后将其更改为零并看看会发生什么）。'
- en: 'And now, we create our `resetTiles ()` method:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建我们的 `resetTiles ()` 方法：
- en: '[PRE43]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We freeze the coroutine during `DELAY_TIME` seconds. We''ll implement `sleepCoroutine`
    in the following code snippet:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `DELAY_TIME` 秒内冻结协程。我们将在以下代码片段中实现 `sleepCoroutine`：
- en: '[PRE44]'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This one may seem tricky, but what we're doing is telling our rendering grid
    that the cells in `selectedCells` should render `BACK_TILE`. We use the coordinates
    of each selected cell and pass them to `setTile` as the first two parameters.
    The third one is the color, so we use `BACK_TILE`.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个可能看起来有点棘手，但我们所做的是告诉我们的渲染网格，`selectedCells` 中的单元格应该渲染 `BACK_TILE`。我们使用每个选中单元格的坐标并将它们传递给
    `setTile` 作为前两个参数。第三个是颜色，所以我们使用 `BACK_TILE`。
- en: '[PRE45]'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We clear the selected cells to start over.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们清除选中的单元格以重新开始。
- en: '[PRE46]'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That's it. Now we need to take care of removing the tiles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在我们需要注意移除瓷砖。
- en: Removing tiles
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除瓷砖
- en: The following method will be used to remove the tiles that are equal and to
    swap the user correctly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将用于移除相等的瓷砖并正确地交换用户。
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is pretty similar to the what we do when resetting tiles. The only difference
    is that we use the `EMPTY_TILE` constant here to make the tile disappear.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与我们在重置瓷砖时所做的非常相似。唯一的区别是，我们在这里使用 `EMPTY_TILE` 常量来使瓷砖消失。
- en: '[PRE48]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We clear the selected cells to start over.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们清除选中的单元格以重新开始。
- en: '[PRE49]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Other auxiliary methods
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他辅助方法
- en: 'There are two more auxiliary methods pending; one to see if a tile was already
    removed from the game and another to make the coroutine sleep. So here they are:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个辅助方法待定；一个用于检查瓷砖是否已经被从游戏中移除，另一个用于使协程休眠。所以，它们就在这里：
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This method is used to identify if we removed a given tile or not. Basically
    we compare it's color value to `EMPTY_TILE`. If it's equal, then that tile was
    removed previously.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法用于确定我们是否移除了给定的瓷砖。基本上，我们将其颜色值与 `EMPTY_TILE` 进行比较。如果它们相等，则该瓷砖之前已被移除。
- en: 'Now for the strange (and extremely useful) one:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是奇怪（但极其有用）的一个：
- en: '[PRE51]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this method, what we do is freeze the coroutine for a given time. We use
    `MOAITimer` to achieve this. The magic here is created by the fact that the timer
    inherits from `MOAIAction`, and as a consequence, we can use the built-in `MOAICoroutine.blockOnAction()`
    method, which basically waits until the action is finished, to continue execution
    on the current thread.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们所做的是冻结给定时间的协程。我们使用`MOAITimer`来实现这一点。这里的魔法在于定时器继承自`MOAIAction`，因此我们可以使用内置的`MOAICoroutine.blockOnAction()`方法，它基本上会等待动作完成，然后继续在当前线程上执行。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is an important method, as you will see. It's used to create animation
    sequences in Moai SDK, when you have to wait for an action to finish before the
    other one starts (for example, a translation and a rotation done in sequence instead
    of in parallel).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的方法，您很快就会看到。它用于在Moai SDK中创建动画序列，当您需要在另一个动作开始之前等待一个动作完成时（例如，按顺序而不是并行执行一个平移和一个旋转）。
- en: Well, the game is pretty much ready for play. You'll obviously need to add a
    couple of things to this for it to be a ready-to-ship game (for example, a winning
    condition, a nice menu, a ticking clock, and so on), but the gameplay is there,
    and that's what we were looking for.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，游戏基本上已经准备好可以玩了。显然，您需要添加一些东西才能使其成为可以发布的游戏（例如，胜利条件、一个漂亮的菜单、一个滴答作响的时钟等等），但游戏玩法已经到位，这正是我们所寻找的。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use a grid to display tiles on the screen
    and also to represent gameplay data. We learned the basics of input handling and
    how to implement the actual gameplay of *Concentration*. We also had our first
    approach to how Moai SDK uses coroutines. Now it's a good time to take some rest
    since the next chapters are juicy; we'll build a platformer prototype that uses
    Box2D for physics!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用网格在屏幕上显示瓦片，以及如何表示游戏数据。我们学习了输入处理的基础知识以及如何实现*专注力*的实际游戏玩法。我们还首次了解了Moai
    SDK如何使用协程。现在是一个休息的好时机，因为接下来的章节内容丰富；我们将构建一个使用Box2D进行物理运算的平台游戏原型！
