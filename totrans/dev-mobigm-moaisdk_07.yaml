- en: Chapter 7. Concentration Gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After talking a little bit about assets and having our `ResourceManager` in
    place, we'll start building the *Concentration* gameplay. We'll talk about input
    handling, basic animations, and game states. These are the basis of gameplay implementation
    and will be useful from the smallest to the biggest game you develop using Moai
    SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to do is to display a grid of tiles that will be
    our playground. Just to start with, we'll display the back of the tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Tilemaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A commonly used technique in game development is the implementation of **tilesets**.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create one image that includes more than one asset in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a tileset called `tiles.png`. It consists of 12 tiles,
    11 different colors (the gray one for the back of the tiles), and the "empty tile"
    (white). It looks somewhat like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tilemaps](img/5064_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should be aware that what we''re going to do is to create a tiled image
    that will be indexed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tilemaps](img/5064_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the result of subdividing the actual image in two rows and six columns.
    We'll end up having twelve 62 x 62 tiles.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a file called `game.lua` that will hold all of the code for
    our gameplay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it and let's begin coding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These constants will become useful as they define the grid dimensions (rows,
    columns, and tile size). The last one is used to avoid magic numbers when setting
    the default grid state. As we saw, the gray tile that we'll use as the back of
    the tiles is indexed by the number `1` (because it's the first in our tileset).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should be familiar to you now. To define our tileset, we'll use the tiled
    image called `tiles.png` that we created earlier, which has six columns and two
    rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We're creating a method called `Game:start()` that will take care of initializing
    everything and controlling the game loop. This will be called from `main.lua`
    later. For now, we will only display our grid on initialization. So what we'll
    do here is call a function named `initialize()` that will take care of all the
    actual initialization. We'll be adding more code to this method later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `initialize ()` function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We make a layer that will handle all of the rendering from the gameplay (including
    our grid) and configure the viewport on it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Then we set the render table using that layer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to use `ResourceDefinitions` with a helper method called `setDefinitions
    ()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: After loading the resource definitions, we call another auxiliary function that
    initializes the tiles.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind `setDefinitions ()` is to take a table of definitions and load
    all of them at once, instead of one by one. It was not created in the previous
    chapter, but it should be pretty simple to implement. Just iterate through the
    parameter table and call `setDefinitions ()` on each entry. Please go ahead and
    try to implement it by yourself. Remember, you can always download the book's
    code, and the method will be there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to take care of `initializeTiles ()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First of all, we create the grid using the `MOAIGrid` class. Then we set it
    up. We use the grid and tile dimensions we defined earlier to configure our new
    `MOAIGrid`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now we set up the actual grid. We call the `setRow()` method with the row number
    as the first parameter. (Start from `1`; remember, we're using Lua!) The following
    parameters are the values of the tiles we want to show for each column. We will
    show the back tile across all the grids as an initial state for our game; that's
    why, we pass `BACK_TILE` as the tile number.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Go ahead and play a little bit, changing the values for these parameters. (Not
    the first one though; that's the row!) Put some numbers between `2` and `11`;
    you should expect to see some color on the gray sea.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Then we create a table called `tiles` and store the tileset in there, as well
    as a new Prop. The usage of a Prop is basically the same as we did earlier; the
    only difference is that we now use `setGrid ()` in order to make the Prop follow
    the size and configuration of that grid.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Since grids don't center over their elements (they just draw them from offsets),
    we need to center them ourselves. In this case, `(0,0)` is at the bottom-left
    corner of the Prop (instead of the middle). We need to offset it, and that's what
    we do by calling the `setLoc()` method; we move it by half of its columns times
    the tile's width (in the *x* axis), and by half of its rows times the tile's height
    (in the *y* axis).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Moai SDK has a family of methods to deal with position, rotation, and scale.
    There are three families, namely the `set*` methods (that force a specific value),
    the `move*` methods (that generate animations applying a delta over time), and
    the `seek*` methods (that generate animations by going from the actual value to
    the specified value in a certain amount of time). To modify position you use `Loc`,
    for rotation `Rot`, and for scale `Scl`. So, for example, if you wanted to rotate
    the `tiles` Prop by 30 degrees within 10 seconds, you'd call `self.tiles.prop:moveRot
    (30, 10)`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There's some more to these methods (like the curve they use to interpolate the
    values); you should check them out at [http://getmoai.com/docs/class_m_o_a_i_transform2_d.html](http://getmoai.com/docs/class_m_o_a_i_transform2_d.html).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We add the Prop to the layer and we're done.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only thing remaining is to call this from `main.lua`. Below the viewport
    definition add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will run our game in a separate Lua coroutine; this is done in order to allow
    it to have a game loop that is detached from the main coroutine flow. This will
    be handy for processing input.
  prefs: []
  type: TYPE_NORMAL
- en: That should be it; if you run the project now, you should see the grid with
    all 20 back tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our journey is to add input handling. We have to create a file
    called `input_manager.lua`; it will be in charge of listening to input events
    and will be queried by our game when needed. We will create it so that it will
    be usable with both mouse devices and touchscreens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, all hosts are supposed to implement their own input schema.
    We won't see this in detail in this book, but so you understand where this comes
    from, take a look at the hosts that are shipped with Moai SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Search for all the references to the `AKUReserveInputDevice*` and `AKUSetInputDevice*`
    method calls in `moai-sdk/hosts/src/GlutHost.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now inspect only the most important methods; please take a look at the
    full code in order to understand how everything fits together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method checks if we have a pointer, and if we do, it creates
    a callback function (`pointerCallback`) that is passed to that pointer in order
    to update the `x` and `y` positions. It also talks to the touch sensor (`MOAITouchSensor`)
    in order to do the same in case we're not using a mouse but a touch-screen instead.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, another important method is `isDown ()`, which is used to know
    if we're clicking or touching the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is querying both the mouse and the touch sensor asking if we're
    clicking or touching respectively. We'll use this in our game loop to identify
    input. Remember to include this file in `main.lua` after the `require 'resource_manager'`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's take a look at what we need in order to implement the gameplay. First
    of all, we need to create all of the structures (and initialize them) for the
    game state. We'll be using another grid, this time to store a randomized distribution
    of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a call at the bottom of the `Game:initialize ()` method to an auxiliary
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the auxiliary function as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we create a grid that will hold the distribution of our colors. This
    grid also has a dimension of 5 x 4\. Note that we don't need to set the tile size
    now as this grid won't be rendered.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This table is just a temporary array of tiles; as you see, we start from `2`
    (`1` is the back tile, remember?) and repeat each number twice. These numbers
    represent the color (or the tile offset) on our tileset.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The next thing we do is to iterate over all of the grid cells, assign one of
    the values to the `tiles` table at random, and remove it from the table so it
    doesn't get selected more than once. In this way, we fill our `distributionGrid`
    with a randomized order of the color pairs. Nice.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The next thing we need is a place to store the cells that were selected in the
    current turn. We'll use a table called `selectedCells`, and it will start displaying
    two `nil` cells because we haven't selected anything yet.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: And that's it for the gameplay initialization part.
  prefs: []
  type: TYPE_NORMAL
- en: Input processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to process input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to append some code to the `Game:start ()` method (below the call to
    `Game:initialize ()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to know if in the previous simulation step the user was clicking or
    tapping the screen. We'll store that information in `wasClicking`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Then we add an infinite loop (beware of algorithms!) that *processes input*
    and uses the magical method `coroutine.yield()` that delegates the flow to the
    main routine, allowing `MOAISim` to do another simulation step. In this way, we
    avoid having an endless loop that freezes the game. Instead, we do all the rendering,
    Action Tree and Node Graph processing; and when all of that is done, it comes
    back to our coroutine to process the input once more.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you expect your game to update the screen (render) and it's not doing it,
    it's likely that you've forgotten to run `coroutine.yield()` to allow rendering
    before continuing with your code. Think about the loading screens for example.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now the next method we'll take care of is the one that actually processes the
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the player is clicking now and was not clicking in the previous simulation
    step (to avoid selecting multiple times when holding the mouse button), we want
    to select a tile.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The way we choose the tile is a pretty neat trick. We gather the mouse position
    that is represented in the window coordinate system.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We need to transform them into model coordinates to do our trick by first converting
    them to world coordinates (through the layer). After these conversions, what we
    get in `modelX` and `modelY` is the offset in pixels from the bottom-left corner
    of our grid.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If we divide `modelX` and `modelY` by the dimensions of the cells, we''ll get
    the cell column and row indices. Nice *mathemagics*. Now it''s just a matter of
    calling an auxiliary function that will take care of the consequences of that
    click:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Oh! And don't forget to update `wasClicking`. We need to store the value of
    `InputManager:isDown ()` on it because we'll need it in the next simulation step.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choosing a cell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have to implement the following cell-choosing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If no cell was selected previously (the first one is nil), we have to select
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We always need to check that the cell we're clicking has not been removed from
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We put the selected cell's column and row in the `selectedCells` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then we swap it to reveal its color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We continue with the case if a tile was selected previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the player clicked the same tile, what we want is to swap it back. Set the
    same tile as the second selected cell (`selectedCells[2]`) and reset them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember to check that the cell we're clicking has not been removed from the
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The same logic is applied here to select the cell and swap it. (Oh no! code
    duplication!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the core of the gameplay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We gather both values and store them in `value1` and `value2` respectively.
    These variables contain the color of the tiles that the user selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the colors are the same, we remove the tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If they differ, we swap them back. And that's it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After a nice tail of `end` sentences, we're ready to implement the auxiliary
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tile swapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To swap our tiles, we''ll create the following `swapTile ()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What we do here is retrieve the color value from our `distributrionGrid` and
    set it into the rendered grid. This is really magical; don't you love it?
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the tile changes its color according to the distribution
    on our `distributionGrid`.
  prefs: []
  type: TYPE_NORMAL
- en: Every distribution is randomized, so this will be different every time you play.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need two more constants at the top of `game.lua` for the next methods (we
    will use these constants to avoid magic numbers):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`EMPTY_TILE` is the white space that we have after all the tiles; we''ll use
    it to remove the tiles that are not in the game. That''s the index `12`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DELAY_TIME` is a time in seconds that we will use to defer the swapping back
    of the tiles, in order to allow the user to see what''s the second color he has
    chosen. (In fact, after finishing the chapter, change it to zero and see what
    happens).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And now, we create our `resetTiles ()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We freeze the coroutine during `DELAY_TIME` seconds. We''ll implement `sleepCoroutine`
    in the following code snippet:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This one may seem tricky, but what we're doing is telling our rendering grid
    that the cells in `selectedCells` should render `BACK_TILE`. We use the coordinates
    of each selected cell and pass them to `setTile` as the first two parameters.
    The third one is the color, so we use `BACK_TILE`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We clear the selected cells to start over.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: That's it. Now we need to take care of removing the tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Removing tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following method will be used to remove the tiles that are equal and to
    swap the user correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty similar to the what we do when resetting tiles. The only difference
    is that we use the `EMPTY_TILE` constant here to make the tile disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We clear the selected cells to start over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other auxiliary methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two more auxiliary methods pending; one to see if a tile was already
    removed from the game and another to make the coroutine sleep. So here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This method is used to identify if we removed a given tile or not. Basically
    we compare it's color value to `EMPTY_TILE`. If it's equal, then that tile was
    removed previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now for the strange (and extremely useful) one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, what we do is freeze the coroutine for a given time. We use
    `MOAITimer` to achieve this. The magic here is created by the fact that the timer
    inherits from `MOAIAction`, and as a consequence, we can use the built-in `MOAICoroutine.blockOnAction()`
    method, which basically waits until the action is finished, to continue execution
    on the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an important method, as you will see. It's used to create animation
    sequences in Moai SDK, when you have to wait for an action to finish before the
    other one starts (for example, a translation and a rotation done in sequence instead
    of in parallel).
  prefs: []
  type: TYPE_NORMAL
- en: Well, the game is pretty much ready for play. You'll obviously need to add a
    couple of things to this for it to be a ready-to-ship game (for example, a winning
    condition, a nice menu, a ticking clock, and so on), but the gameplay is there,
    and that's what we were looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use a grid to display tiles on the screen
    and also to represent gameplay data. We learned the basics of input handling and
    how to implement the actual gameplay of *Concentration*. We also had our first
    approach to how Moai SDK uses coroutines. Now it's a good time to take some rest
    since the next chapters are juicy; we'll build a platformer prototype that uses
    Box2D for physics!
  prefs: []
  type: TYPE_NORMAL
