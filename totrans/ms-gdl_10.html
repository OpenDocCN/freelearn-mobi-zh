<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Building Android Applications with Gradle</h1></div></div></div><p>With an increasing number of smartphone users in recent years, mobile application development has become one of the major areas to focus on other than big data and Cloud computing. Most of the companies are coming up with mobile apps for their products such as games, social networking, e-commerce, and so on. And this trend is surely going to increase in next few years. So, in the last chapter, we will cover the topic related to mobile technology.</p><p>In this chapter, we will discuss how to create a basic Android application with Android Studio as IDE and how to build the application with Gradle. We already know that the Gradle philosophy is based on conventions rather than configurations, and it is much easier to write a build automation infrastructure with Gradle in comparison to other build tools available in the market. This is one of the reasons why Gradle is the official build tool for Android. You just write few lines of code in the build file and the application is ready for different platforms and versions, such as free or paid. It also provides support to sign application before release. With Gradle, you can run the application on an emulator or physical devices to run unit and function tests.</p><p>In this chapter, we will primarily focus on two areas: a quick overview of Android application development with Android Studio and various aspects of Gradle as a build tool for Android. As this is a Gradle book, our discussion will be focused on understanding the Gradle features.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Creating Android project using Android Studio</h1></div></div></div><p>We will start by creating<a id="id546" class="indexterm"/> a sample Android application, which will<a id="id547" class="indexterm"/> display <code class="literal">Hello World</code> when <a id="id548" class="indexterm"/>you open it on a mobile device. You can use Eclipse with the <strong>Android Development Tool</strong> (<strong>ADT</strong>) plugin or Android Studio, which has been released by Google. Android Studio is based on IntelliJ IDEA and it is now the most preferred IDE for building Android applications. Both Eclipse with ADT and Android studio<a id="id549" class="indexterm"/> setup instructions can be found at <a class="ulink" href="http://developer.android.com/sdk/index.html">http://developer.android.com/sdk/index.html</a>.</p><p>In this chapter, we will use Android <a id="id550" class="indexterm"/>Studio for application development. Once you have downloaded and installed Android Studio on your system, start Android Studio. Android Studio also installs Android SDK, which is required to compile and execute Android applications. To create an application, navigate to <strong>File</strong> | <strong>New Project</strong>. You will see the following screen:</p><div><img src="img/B02000_10_01.jpg" alt="Creating Android project using Android Studio"/><div><p>Figure 10.1</p></div></div><p>Click on the <strong>Next</strong> button<a id="id551" class="indexterm"/> and follow the steps. On the activity screen, select <strong>Blank Activity</strong>:</p><div><img src="img/B02000_10_02.jpg" alt="Creating Android project using Android Studio"/><div><p>Figure 10.2</p></div></div><p>For this chapter, our<a id="id552" class="indexterm"/> main purpose is to create a sample application and emphasize on the build process of the Android application with Gradle. So it is not required to create a full-fledged Android application. Therefore, the sample application will do just one job, which is to display <code class="literal">Hello World</code> when you launch the application.</p><p>To complete the project<a id="id553" class="indexterm"/> setup, in the <strong>Customize the Activity</strong> screen, provide the details such as <strong>Activity Name</strong>, <strong>Title</strong>, and so on:</p><div><img src="img/B02000_10_03.jpg" alt="Creating Android project using Android Studio"/><div><p>Figure 10.3</p></div></div><p>Once you click on <strong>Finish</strong>, Android <a id="id554" class="indexterm"/>studio will create the project and the directory structure will be as follows:</p><div><img src="img/B02000_10_04.jpg" alt="Creating Android project using Android Studio"/><div><p>Figure 10.4</p></div></div><p>In the project home directory, you will find the <code class="literal">build.gradle</code> and <code class="literal">settings.gradle</code> files. This means that Android Studio has created a multi-project build structure. In <a class="link" href="ch06.html" title="Chapter 6. Working with Gradle">Chapter 6</a>, <em>Working with Gradle</em>, we have already covered the multi-project structure, in which a parent project contains one or more subprojects. The parent project contains all the common configurations <a id="id555" class="indexterm"/>and other related details that are shared among the subprojects.</p><p>Android Studio creates one <code class="literal">build.gradle</code> for the parent project and individual <code class="literal">build.gradle</code> files for the subprojects. It also creates <code class="literal">settings.gradle</code> file that includes all the subprojects that are part of this parent project. You will also find the <code class="literal">local.properties</code> file. This file has information about the location of the Android SDK. The content of this file will be as follows:</p><div><pre class="programlisting">sdk.dir=&lt;Location of Android sdk&gt;</pre></div><p>Android Studio also adds<a id="id556" class="indexterm"/> Gradle Wrapper, which means the Android project can be built on a machine where Gradle is not installed. Gradle Wrapper automatically installs Gradle and executes the build.</p><p>The actual Android application is in the <code class="literal">app</code> directory that has the source code, resource, and so on. The content of app directory is as shown here:</p><div><img src="img/B02000_10_05.jpg" alt="Creating Android project using Android Studio"/><div><p>Figure 10.5</p></div></div><p>It contains the <code class="literal">src</code> directory for the Java source code and test code.</p><p>Source and test directories<a id="id557" class="indexterm"/> are <code class="literal">src/main/java</code> and <code class="literal">src/androidTest/java,</code> respectively, as shown in the following screenshot:</p><div><img src="img/B02000_10_06.jpg" alt="Creating Android project using Android Studio"/><div><p>Figure 10.6</p></div></div><p>Already you are aware <a id="id558" class="indexterm"/>of Java plugin and its default conventions. If we include Java plugin in a project, the source structure is <code class="literal">src/main/java</code> and <code class="literal">src/main/resources</code>. For Android plugin apart from these two directories, you can also add extra files and folders specific to<a id="id559" class="indexterm"/> Android conventions, as mentioned here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AndroidManifest.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">res/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assets/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jni/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">proguard-rules.pro</code></li></ul></div><p>This can be configured in the <code class="literal">android</code> closure as <code class="literal">sourceSets</code> properties, as follows:</p><div><pre class="programlisting">android {
sourceSets {
  main {
    java {
      manifest.srcFile 'Manifest.xml' res.srcDirs = ['src/res'] assets.srcDirs = ['src/assets']
    }
  }
}
}</pre></div><p>We will discuss some of the important<a id="id560" class="indexterm"/> concepts here. You can find more details at <a class="ulink" href="https://developer.android.com/sdk/index.html">https://developer.android.com/sdk/index.html</a>.</p><p>The <code class="literal">AndroidManifest.xml</code> file is one of the important files that must be present in the application directory. It contains some important information related to the application, such as activities, content providers, permissions, and so on. Manifest file contains only predefined elements. Some values are populated from the Gradle properties. You cannot add any custom element<a id="id561" class="indexterm"/> in the manifest file. Elements such as <code class="literal">&lt;manifest&gt;</code> and <code class="literal">&lt;application&gt;</code> are mandatory and they appear only once. Other elements are optional and can be applied once or multiple times.</p><p>The <code class="literal">res</code> directory is used to place resources. You can place all the application resources, such as layout files, drawable files, and string values under<a id="id562" class="indexterm"/> the <code class="literal">res</code> directory. You can find more details about resources at <a class="ulink" href="http://developer.android.com/guide/topics/resources/providing-resources.html">http://developer.android.com/guide/topics/resources/providing-resources.html</a>.
</p><p>The directories supported inside the <code class="literal">res</code> directory are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">animator</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">anim</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">color</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">drawable</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mipmap</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">layout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">menu</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">raw</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">values</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">xml</code></li></ul></div><p>The <code class="literal">assets</code> directory may contain all the basic files. Files under this directory will be part of the <code class="literal">.apk</code> file without any modification and the original file name is preserved.</p><p>
<code class="literal">jni</code> contains native code<a id="id563" class="indexterm"/> using the Java Native Interface.</p><p>
<code class="literal">proguard-rules.pro</code> contains the ProGuard-related settings. We will discuss ProGuard settings later in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Building the Android project with Gradle</h1></div></div></div><p>We created the application <a id="id564" class="indexterm"/>with one simple activity and now we will try to build the application with Gradle. Android Studio has automatically generated two build files for the project; one <code class="literal">build.gradle</code><a id="id565" class="indexterm"/> file in the root folder of the project and other build file in the <code class="literal">app</code> directory. We will use the <code class="literal">build.gradle</code> file of the subproject (<code class="literal">app</code> folder) to build the Android application. This <code class="literal">build.gradle</code> file has the following content:</p><div><pre class="programlisting">apply plugin: 'com.android.application'

android {
  compileSdkVersion 22
  buildToolsVersion "22.0.1"

  defaultConfig {
    applicationId "ch10.androidsampleapp"
    minSdkVersion 15
    targetSdkVersion 22
    versionCode 1
    versionName "1.0"
  }
  buildTypes {
    release {
      minifyEnabled false
      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
  }
}

dependencies {
  compile fileTree(dir: 'libs', include: ['*.jar'])
  compile 'com.android.support:appcompat-v7:22.1.1'
}</pre></div><p>In the very first line, we applied a plugin with the <code class="literal">apply plugin: 'com.android.application'</code> statement. This is similar to applying any other standard Gradle plugin. But from where will this plugin jar be downloaded? If you check the <code class="literal">build.gradle</code> file in the parent project, you will find the following entry:</p><div><pre class="programlisting">buildscript {
   repositories {
       jcenter()
   }
   dependencies {
       classpath 'com.android.tools.build:gradle:1.2.3'
   }
}</pre></div><p>In the <code class="literal">buildscript</code> closure, we have defined dependencies as <code class="literal">com.android.tools.build:gradle:1.2.3</code>. This JAR file will be downloaded from the <code class="literal">jcenter</code> repository and it will be added to the classpath of the <code class="literal">build.gradle</code>.</p><p>Next part of the build file is the android closure definition where we define all the basic configurations related to the application such as SDK version, minimum SDK version supported, target SDK version, application ID, and versioning.</p><p>Next, we have the standard <code class="literal">dependencies</code> closure to define compile and runtime dependencies for the<a id="id566" class="indexterm"/> application. Here, we have included the <code class="literal">lib</code> directory and <code class="literal">appcompat-v7 jar</code> as dependencies.</p><p>With these simple<a id="id567" class="indexterm"/> configurations, we are ready to build the application with Gradle. We have applied Android plugin in the build file. Now, we will explore different tasks available to build the project. Type <code class="literal">gradle tasks</code> on the command prompt to get the list of tasks, as shown here:</p><div><pre class="programlisting">
<strong>&gt; gradle tasks</strong>

<strong>Android tasks</strong>
<strong>-------------</strong>
<strong>androidDependencies - Displays the Android dependencies of the project.</strong>
<strong>signingReport - Displays the signing info for each variant.</strong>

<strong>Build tasks</strong>
<strong>-----------</strong>
<strong>assemble - Assembles all variants of all applications and secondary packages.</strong>
<strong>assembleAndroidTest - Assembles all the Test applications.</strong>
<strong>assembleDebug - Assembles all Debug builds.</strong>
<strong>……………...</strong>
<strong>compileDebugSources</strong>
<strong>compileDebugUnitTestSources</strong>
<strong>compileReleaseSources</strong>
<strong>compileReleaseUnitTestSources</strong>
<strong>mockableAndroidJar - Creates a version of android.jar that's suitable for unit tests.</strong>
<strong>…………………….</strong>

<strong>Install tasks</strong>
<strong>-------------</strong>
<strong>installDebug - Installs the Debug build.</strong>
<strong>installDebugAndroidTest - Installs the android (on device) tests for the Debug build.</strong>
<strong>uninstallAll - Uninstall all applications.</strong>
<strong>uninstallDebug - Uninstalls the Debug build.</strong>
<strong>uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.</strong>
<strong>uninstallRelease - Uninstalls the Release build.</strong>

<strong>……………</strong>
</pre></div><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Note that to build <a id="id568" class="indexterm"/>Android project, you need Gradle 2.2.1 and above.</p></div></div><p>Following are the<a id="id569" class="indexterm"/> some of the important tasks that you might need to build an Android application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assemble</code>: This task is same as the assemble task in the Java plugin that is used to assemble the output of the application.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check</code>: This is similar to the Java plugin check task, it runs all the checks.</li><li class="listitem" style="list-style-type: disc"><code class="literal">clean</code>: This task removes all the artifacts created during build process.</li><li class="listitem" style="list-style-type: disc"><code class="literal">build</code>: This task executes the assemble and check task and builds the application artifacts.</li><li class="listitem" style="list-style-type: disc"><code class="literal">androidDependencies</code>: This task will display all the Android dependencies of the project.</li><li class="listitem" style="list-style-type: disc"><code class="literal">connectedCheck</code>: It will execute the check task on all the connected devices in parallel</li><li class="listitem" style="list-style-type: disc"><code class="literal">install&lt;buildVariant&gt;</code>: You can find various install tasks (such as <code class="literal">installDebug</code>, <code class="literal">installRelease</code>) that are used to install specific <code class="literal">buildVariant</code> on a device. We will discuss more on the <code class="literal">buildVariant</code> in a later section of the book.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec118"/>buildTypes</h2></div></div></div><p>The <code class="literal">buildTypes</code> configuration is used to define types or environments of build, such as debug, release, QA, and staging to<a id="id570" class="indexterm"/> build and package the app. By default, when you build the Android project, you can find both the debug and release versions that were created in the <code class="literal">build/outputs/apk</code> directory. By default, the debug version is signed with a key/certificate that is created automatically with a known username/password. The release build type is not signed during the build process; therefore, you can find the <code class="literal">app-release-unsigned.apk</code> file created for the release build type. Release build type needs to be signed before deploying it in any device.</p><p>You can customize both build and release build types and also extend the build types by adding your own build types, as follows:</p><div><pre class="programlisting">buildTypes {
  release {
    minifyEnabled false
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
  staging.initWith(buildTypes.release)
  staging {
    debuggable true
  }
}</pre></div><p>Here we have<a id="id571" class="indexterm"/> added one more build type <code class="literal">staging</code> (for staging environment), and configured it to be a copy of the release build type and added <code class="literal">debuggable true</code>. You can modify the following properties for any build types:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default values for debug type</p>
</th><th style="text-align: left" valign="bottom">
<p>Default values for release and other types</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debuggable</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">jniDebuggable</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">renderscriptDebuggable</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">renderscriptOptimLevel</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">3</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">3</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">applicationIdSuffix</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">versionNameSuffix</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">signingConfig (discussed later)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">android.signingConfigs.debug</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">zipAlignEnabled</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">true</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">minifyEnabled</code> (discussed later)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td></tr></tbody></table></div><div><blockquote class="blockquote"><p><em>Table 10.1</em></p></blockquote></div><p>Also, for each build type, you can define their build type-specific SourceSet such as <code class="literal">src/&lt;build type&gt;</code>. As mentioned in the preceding example, you can define a new directory <code class="literal">src/staging</code> and put the staging-related source code and resources in this directory.</p><p>Also for each build type, new tasks will be added by the Android plugin in the following format: <code class="literal">assemble&lt;buildtype&gt;</code>, <code class="literal">install&lt;buildtype&gt;</code>, <code class="literal">compile&lt;buildtype&gt;</code>, <code class="literal">jar&lt;buildtype&gt;</code>. This can be observed by executing the <code class="literal">gradle task</code> command, as shown here:</p><div><pre class="programlisting">
<strong>&gt; gradle  tasks | grep -i staging</strong>
<strong>assembleStaging - Assembles all Staging builds.</strong>
<strong>compileStagingSources</strong>
<strong>compileStagingUnitTestSources</strong>
<strong>installStaging - Installs the Staging build.</strong>
<strong>uninstallStaging - Uninstalls the Staging build.</strong>
<strong>lintStaging - Runs lint on the Staging build.</strong>
<strong>testStaging - Run unit tests for the staging build.</strong>
<strong>jarStagingClasses</strong>
</pre></div><p>As mentioned previously, these<a id="id572" class="indexterm"/> task are only associated with the staging build types.</p><div><div><div><div><h3 class="title"><a id="ch10lvl2sec119"/>ProGuard settings</h3></div></div></div><p>For <code class="literal">release</code> build type, Gradle provides access to <a id="id573" class="indexterm"/>the Proguard tool that is used to optimize and obfuscate the code. It shrinks the source code and makes the <code class="literal">.apk</code> file smaller in size. You can enable/disable this feature by setting <code class="literal">minifyEnabled</code> in the <code class="literal">buildTypes/release</code> closure. As mentioned in <em>Table 10.1</em>, the default value is set to <code class="literal">false</code>; so set it to <code class="literal">true</code> if you want to enable it.</p><p>The default setting can be obtained using the <code class="literal">getDefaultProguardFile('proguard-android.txt')</code> method. You can find the location of the ProGuard tool at <code class="literal">&lt;Android sdk dir&gt;/tools/proguard</code>. If you want to provide custom rules for the project, you can add it to the <code class="literal">proguard-rules.pro</code> file provided by Android studio. You can even add your own files with different names:</p><div><pre class="programlisting"> buildTypes {
  release {
    minifyEnabled true
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl2sec120"/>Build flavors</h3></div></div></div><p>Build flavors or product flavors are different from build type. It is another level of separation, which allows<a id="id574" class="indexterm"/> building multiple flavors of the application, such as paid version, free version, phone version, and tab version. Each version of the application can have its own separate features and different hardware requirements. The combination of <code class="literal">productFlavors</code> and <code class="literal">buildTypes</code> forms a build variant and a different APK is generated for each build variant. Product flavors are defined under the <code class="literal">productFlavors</code> closure:</p><div><pre class="programlisting">productFlavors {
  phone{
    applicationId "ch10.androidsampleapp"
    minSdkVersion 14
    targetSdkVersion 20

    versionName "1.0-phone"
  }
  tab {
    applicationId "ch10.androidsampleapp"
    minSdkVersion 15
    targetSdkVersion 22
    versionName "1.0-tab"
  }
}</pre></div><p>Now, if we build the project with the <code class="literal">gradle clean build</code> command, we will find different APK files created in the <code class="literal">build/outputs/apk/</code> directory. We have two flavors (<code class="literal">phone</code> and <code class="literal">tab</code>) with four<a id="id575" class="indexterm"/> build types (<code class="literal">debug signed</code>, <code class="literal">debug unaligned</code>, <code class="literal">staging</code>, and <code class="literal">release</code>). Therefore, total <em>2*4 = 8</em> APK files will be created in the build process.</p><div><img src="img/B02000_10_07.jpg" alt="Build flavors"/><div><p>Figure 10.7</p></div></div><p>When we added <code class="literal">staging</code> as the build type in the previous section, we observed that Gradle had automatically created some tasks. Similarly, for each flavor configuration, Gradle will add different tasks such as <code class="literal">assemblePhoneDebug</code> and <code class="literal">assembleTabDebug</code>:</p><div><pre class="programlisting">
<strong>&gt; gradle tasks | grep -i phone</strong>
<strong>assemblePhone - Assembles all Phone builds.</strong>
<strong>assemblePhoneDebug - Assembles the DebugPhone build.</strong>
<strong>assemblePhoneDebugAndroidTest - Assembles the android (on device) tests for the PhoneDebug build.</strong>
<strong>assemblePhoneRelease - Assembles the ReleasePhone build.</strong>
<strong>assemblePhoneStaging - Assembles the StagingPhone build.</strong>
<strong>compilePhoneDebugAndroidTestSources</strong>
<strong>compilePhoneDebugSources</strong>
<strong>compilePhoneDebugUnitTestSources</strong>
<strong>compilePhoneReleaseSources</strong>
<strong>compilePhoneReleaseUnitTestSources</strong>
<strong>compilePhoneStagingSources</strong>
<strong>compilePhoneStagingUnitTestSources</strong>
<strong>installPhoneDebug - Installs the DebugPhone build.</strong>
<strong>installPhoneDebugAndroidTest - Installs the android (on device) tests for the PhoneDebug build.</strong>
<strong>uninstallPhoneDebug - Uninstalls the DebugPhone build.</strong>
<strong>uninstallPhoneDebugAndroidTest - Uninstalls the android (on device) tests for the PhoneDebug build.</strong>
<strong>uninstallPhoneRelease - Uninstalls the ReleasePhone build.</strong>
<strong>uninstallPhoneStaging - Uninstalls the StagingPhone build.</strong>
<strong>connectedAndroidTestPhoneDebug - Installs and runs the tests for DebugPhone build on connected devices.</strong>
<strong>lintPhoneDebug - Runs lint on the PhoneDebug build.</strong>
<strong>lintPhoneRelease - Runs lint on the PhoneRelease build.</strong>
<strong>lintPhoneStaging - Runs lint on the PhoneStaging build.</strong>
<strong>testPhoneDebug - Run unit tests for the phoneDebug build.</strong>
<strong>testPhoneRelease - Run unit tests for the phoneRelease build.</strong>
<strong>testPhoneStaging - Run unit tests for the phoneStaging build.</strong>
<strong>jarPhoneDebugClasses</strong>
<strong>jarPhoneReleaseClasses</strong>
<strong>jarPhoneStagingClasses</strong>
</pre></div><p>Product flavors extend the configuration from the <code class="literal">defaultConfig</code> closure. You can overwrite the default configurations inside each product flavor. For each flavor, you can also have a separate <a id="id576" class="indexterm"/>source code and the required files as <code class="literal">src/&lt;flavor&gt;/java</code>, <code class="literal">src/&lt;flavor&gt;/resources</code>, and so on.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl1sec74"/>Running the application on a device/emulator</h2></div></div></div><p>Once an application is<a id="id577" class="indexterm"/> built, you will want to install or run the application, either on an emulator or a physical mobile device. For simplicity, we will <a id="id578" class="indexterm"/>run the application on an emulator. During the development phase, with the help of an emulator you can test the application on different platforms without using devices. Some of the advantages of using an emulator are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can test the application on multiple emulator devices</li><li class="listitem" style="list-style-type: disc">You can test with different hardware features such as sound, webcam, or sensors</li><li class="listitem" style="list-style-type: disc">You control battery power, phone location, network settings, such as 2G or 3G, and so on</li></ul></div><p>Emulators are very<a id="id579" class="indexterm"/> flexible, but using too many emulators <a id="id580" class="indexterm"/>can bring down your system performance. Based on your system configuration, you should carefully configure the emulators. You can add new emulator devices using AVD Manager as shown in the following screenshot:</p><div><img src="img/B02000_10_08.jpg" alt="Running the application on a device/emulator"/><div><p>Figure 10.8</p></div></div><p>It will show the existing emulator devices. You can create a new device as per application requirement. For more<a id="id581" class="indexterm"/> information, refer to this link <a class="ulink" href="http://developer.android.com/tools/help/emulator.html">http://developer.android.com/tools/help/emulator.html</a>.</p><div><img src="img/B02000_10_09.jpg" alt="Running the application on a device/emulator"/><div><p>Figure 10.9</p></div></div><p>You can start the emulator by clicking on the start symbol in the <strong>Actions</strong> column. For our example, we created a <strong>Nexus 5 API 22x86</strong> emulator to test the application. Alternatively, you can also start the <a id="id582" class="indexterm"/>emulator device by executing the following command on the command prompt:</p><div><pre class="programlisting">
<strong>&gt;%ANDROID_SDK%\tools\emulator.exe -netdelay none -netspeed full -avd Nexus_5_API_22_x86</strong>
</pre></div><p>It takes a while to<a id="id583" class="indexterm"/> initialize the emulator. Once the emulator is up and running, we should be able to run the application from Android Studio. Go to the <strong>Run</strong> menu and choose <strong>Run app</strong>.</p><div><img src="img/B02000_10_10.jpg" alt="Running the application on a device/emulator"/><div><p>Figure 10.10</p></div></div><p>This will show all the devices (connected to the system) and the emulator that is up and running. You can select any of the running devices and click <strong>OK</strong>. The application should be visible in the emulator after few seconds.</p><div><img src="img/B02000_10_11.jpg" alt="Running the application on a device/emulator"/><div><p>Figure 10.11</p></div></div><p>Alternatively, you can also install the application using the <code class="literal">gradle install&lt;buildVariant&gt;</code> command. We have already created different build variants and flavors in the <a id="id584" class="indexterm"/>previous section. Let's try to install the <code class="literal">PhoneDebug</code> variant <a id="id585" class="indexterm"/>on the emulator. This is done as follows:</p><div><pre class="programlisting">
<strong>&gt; gradle installPhoneDebug</strong>
<strong>:app:preBuild UP-TO-DATE                                                                  </strong>
<strong>:app:prePhoneDebugBuild UP-TO-DATE     </strong>
<strong>:............</strong>
<strong>.............</strong>
<strong>:app:mergePhoneDebugAssets UP-TO-DATE      </strong>
<strong>:app:compilePhoneDebugJava UP-TO-DATE      </strong>
<strong>:app:compilePhoneDebugNdk UP-TO-DATE      </strong>
<strong>:app:compilePhoneDebugSources UP-TO-DATE      </strong>
<strong>:app:preDexPhoneDebug UP-TO-DATE      </strong>
<strong>:app:dexPhoneDebug UP-TO-DATE      </strong>
<strong>:app:validateDebugSigning                 </strong>
<strong>:app:packagePhoneDebug UP-TO-DATE      </strong>
<strong>:app:zipalignPhoneDebug UP-TO-DATE      </strong>
<strong>:app:assemblePhoneDebug UP-TO-DATE      </strong>
<strong>:app:installPhoneDebug                 </strong>
<strong>Installing APK 'app-phone-debug.apk' on 'Nexus_5_API_22_x86(AVD) - 5.1'</strong>
<strong>Installed on 1 device.                 </strong>
<strong>                                       </strong>
<strong>BUILD SUCCESSFUL</strong>
<strong>               </strong>
<strong>Total time: 24.543 secs</strong>
</pre></div><p>You will be able to find the application in the phone's application list. <code class="literal">AndroidSampleApp</code> is the application that we installed using Gradle task. You can launch the application and check the output. It will display <code class="literal">Hello World</code>.</p><p>To uninstall the application using Gradle, use the gradle uninstall command as follows:</p><div><pre class="programlisting">
<strong>&gt; gradle uninstallPhoneDebug</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl2sec121"/>Signing the release version</h3></div></div></div><p>You might have observed <a id="id586" class="indexterm"/>while running <code class="literal">gradle tasks</code> that the release related install tasks are not created; for example, <code class="literal">installPhoneRelease</code>, <code class="literal">installTabRelease</code>, and so on. Release build type-related tasks will be available, if you sign the application using keystore. Now, we will try to sign an application using a keystore. If you already have a valid keystore, you can use that file to sign the application; otherwise you will need to generate a new keystore by using the following command:</p><div><pre class="programlisting">
<strong>&gt; keytool -genkey -v -keystore myCustomkey.keystore -alias customKey -keyalg RSA -keysize 2048 -validity 10000</strong>
</pre></div><p>To create the keystore, we need to provide some basic details. On entering all the details, the preceding command <a id="id587" class="indexterm"/>will generate the <code class="literal">myCustomkey.keystore</code> file. Now, we have to update <code class="literal">build.gradle</code> with the following configurations to enable the signing of the application:</p><div><pre class="programlisting">android {
  
......
signingConfigs {
  release {
    storeFile file("myCustomkey.keystore")
    storePassword "welcome"
    keyAlias "customKey"
    keyPassword "welcome"
  }
}
  ……………
buildTypes {
  release {
    minifyEnabled false
    signingConfig signingConfigs.release
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
  ………………
}</pre></div><p>Now, if we execute the <code class="literal">gradle tasks</code> command, we will find new tasks have been added for the release builds. Similarly, new APK files will be created in the <code class="literal">apk</code> folder:</p><div><pre class="programlisting">
<strong>&gt; gradle tasks | grep -i install</strong>
<strong>Install tasks</strong>
<strong>installPhoneDebug - Installs the DebugPhone build.</strong>
<strong>installPhoneDebugAndroidTest - Installs the android (on device) tests for the PhoneDebug build.</strong>
<strong>installPhoneRelease - Installs the ReleasePhone build.</strong>
<strong>installPhoneStaging - Installs the StagingPhone build.</strong>
<strong>installTabDebug - Installs the DebugTab build.</strong>
<strong>installTabDebugAndroidTest - Installs the android (on device) tests for the TabDebug build.</strong>
<strong>installTabRelease - Installs the ReleaseTab build.</strong>
<strong>installTabStaging - Installs the StagingTab build.</strong>
<strong>uninstallAll - Uninstall all applications.</strong>
<strong>....</strong>
</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Summary</h1></div></div></div><p>In this chapter, we briefly discussed Android development with Gradle as a build tool. We also discussed different closures provided by the Android plugin and how to build an Android project by following the default conventions. We also explained how to customize the build file to fulfill the new project requirements. Of course, there are a lot of things to discuss, such as Android development and Android with Gradle, and we were not able to cover everything in a single chapter. It would require a separate book to detail out all the features of the Android plugin. But we think that we covered most of the basic and important steps required to build an Android project, which will help you to get started with Gradle as an Android build system.</p></div></body></html>