- en: <st c="0">4</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">4</st>
- en: <st c="2">Advanced Navigation with SwiftUI</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用 SwiftUI 进行高级导航</st>
- en: <st c="34">In</st> [*<st c="38">Chapter 2</st>*](B21795_02.xhtml#_idTextAnchor043)<st
    c="47">, we discussed working with</st> <st c="74">the</st> **<st c="79">Observation</st>**
    <st c="90">framework.</st> <st c="102">The Observation framework helps to manage
    communication between different parts of our app and is one of the fundamental
    building blocks of SwiftUI declarative programming.</st> <st c="275">However,
    it is also one of the tools we will use to implement a good</st> <st c="344">navigation
    system.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34">在第</st> [*<st c="38">第 2 章</st>](B21795_02.xhtml#_idTextAnchor043)<st
    c="47">中，我们讨论了与</st> <st c="74">观察</st> <st c="79">框架</st> <st c="90">一起工作。</st>
    <st c="102">观察框架有助于管理我们应用程序不同部分之间的通信，并且是 SwiftUI 声明式编程的基本构建块之一。</st> <st c="275">然而，它也是我们将用于实现良好导航系统的工具之一。</st>
- en: <st c="362">Why do we have a whole chapter about navigation?</st> <st c="412">Isn’t
    it just showing a different view when the user selects an item in</st> <st c="484">a
    list?</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="362">为什么我们会有一个关于导航的整章内容？</st> <st c="412">难道不是当用户在列表中选择一个项目时只是显示不同的视图吗？</st>
- en: <st c="491">Navigation is a massive topic in mobile development.</st> <st c="545">A
    standard app may have dozens of screens, and a more extensive one may have hundreds.</st>
    <st c="632">Understanding how to manage the different routes in our app, which
    has so many screens, is crucial to our</st> <st c="738">app’s success.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="491">导航是移动开发中的一个重大主题。</st> <st c="545">一个标准应用程序可能有数十个屏幕，一个更广泛的应用程序可能有数百个。</st>
    <st c="632">了解如何管理我们应用程序中如此多的不同路由，对于我们的应用程序成功至关重要。</st>
- en: <st c="752">In this chapter, we will be doing</st> <st c="787">the following:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="752">在本章中，我们将进行以下操作：</st> <st c="787">以下操作：</st>
- en: <st c="801">Understating why SwiftUI navigation is</st> <st c="841">a challenge</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="801">理解为什么 SwiftUI 导航是</st> <st c="841">一个挑战</st>
- en: <st c="852">Exploring</st> <st c="863">SwiftUI’s</st> `<st c="873">NavigationStack</st>`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="852">探索</st> <st c="863">SwiftUI 的</st> `<st c="873">NavigationStack</st>`
- en: <st c="888">Working with different data models to</st> <st c="927">trigger navigation</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="888">使用不同的数据模型来</st> <st c="927">触发导航</st>
- en: <st c="945">Working with the Coordinator pattern to manage our</st> <st c="997">concerns
    better</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="945">使用协调者模式来更好地管理我们的</st> <st c="997">关注点</st>
- en: <st c="1012">Implementing SwiftUI’s</st> `<st c="1036">NavigationSplitView</st>`
    <st c="1055">to create a</st> <st c="1068">column-based navigation</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1012">实现 SwiftUI 的</st> `<st c="1036">NavigationSplitView</st>` <st c="1055">以创建一个</st>
    <st c="1068">基于列的导航</st>
- en: <st c="1091">We’ve got a lot to cover!</st> <st c="1118">But before we begin,
    let’s try to understand why SwiftUI navigation can be</st> <st c="1193">a challenge.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1091">我们有很多内容要介绍！</st> <st c="1118">但在我们开始之前，让我们尝试理解为什么 SwiftUI 导航可能是一个挑战。</st>
- en: <st c="1205">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1205">技术要求</st>
- en: <st c="1228">For this chapter, you’ll need to download Xcode version 16.0 or
    above from Apple’s</st> <st c="1312">App Store.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1228">对于本章，您需要从 Apple 的</st> <st c="1312">App Store</st> 下载 Xcode 版本
    16.0 或更高版本。</st>
- en: <st c="1322">You’ll also need to be running the latest version of macOS (Ventura
    or above).</st> <st c="1402">Simply search for Xcode in the App Store and select
    and download the latest version.</st> <st c="1487">Launch Xcode and follow any
    additional installation instructions that your system may prompt you with.</st>
    <st c="1590">Once Xcode has fully launched, you’re ready</st> <st c="1634">to
    go.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1322">您还需要运行最新版本的 macOS（Ventura 或更高版本）。</st> <st c="1402">只需在 App Store
    中搜索 Xcode，选择并下载最新版本。</st> <st c="1487">启动 Xcode 并遵循系统可能提示您进行的任何其他安装说明。</st> <st
    c="1590">一旦 Xcode 完全启动，您就可以开始了。</st>
- en: <st c="1640">Download the sample code from the following GitHub</st> <st c="1692">link:</st>
    [<st c="1698">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204)<st
    c="1783">.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1640">从以下 GitHub</st> <st c="1692">链接</st> 下载示例代码：[<st c="1698">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204)<st
    c="1783">。</st>
- en: <st c="1784">Understating why SwiftUI navigation is a challenge</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1784">理解为什么 SwiftUI 导航是一个挑战</st>
- en: <st c="1835">To answer that</st> <st c="1850">question, we need to understand
    how navigation works intuitively</st><st c="1915">. The user taps on a button,
    link, or some other event that may occur.</st> <st c="1986">Then, the app responds
    to that event and transitions the view to</st> <st c="2051">another screen.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答那个问题，我们需要理解导航是如何直观工作的。用户点击按钮、链接或其他可能发生的事件。然后，应用响应该事件并将视图过渡到另一个屏幕。
- en: <st c="2066">In a sense, we understand this sounds like an event-driven paradigm.</st>
    <st c="2136">When we discuss the differences between SwiftUI and UIKit, we actually
    discuss the differences between declarative and</st> <st c="2255">imperative programming</st><st
    c="2277">.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们理解这听起来像是一个事件驱动范式。当我们讨论SwiftUI和UIKit之间的区别时，我们实际上是在讨论声明式编程和`<st c="2255">imperative
    programming</st>`之间的区别。
- en: <st c="2278">Imperative UI, such as UIKit, is also event-driven, while declarative
    UI, such as SwiftUI, represents the current state.</st> <st c="2400">As a result,
    we can understand why navigation can be seen as simpler in UIKit and may feel
    more</st> <st c="2496">natural there.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式UI，如UIKit，也是事件驱动的，而声明式UI，如SwiftUI，则表示当前状态。因此，我们可以理解为什么在UIKit中导航看起来更简单，并且可能感觉更自然。
- en: <st c="2510">Many developers struggle with SwiftUI navigation.</st> <st c="2561">They
    wrap a SwiftUI view inside</st> `<st c="2593">UIHostingController</st>` <st c="2612">and
    use the UIKit navigation system.</st> <st c="2650">That’s a fair solution for
    achieving some advanced navigation techniques that are hard to do in SwiftUI.</st>
    <st c="2755">However, we need to remember that SwiftUI has evolved over the years
    and offers great</st> <st c="2841">navigation tools.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都在SwiftUI导航上挣扎。他们在一个`<st c="2593">UIHostingController</st>`中包裹一个SwiftUI视图，并使用UIKit导航系统。这是一个合理的解决方案，用于实现一些在SwiftUI中难以完成的复杂导航技术。然而，我们需要记住，SwiftUI已经发展多年，提供了优秀的导航工具。
- en: <st c="2858">Let’s start with the basic navigation tool –</st> `<st c="2904">NavigationStack</st>`<st
    c="2919">.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的导航工具`<st c="2904">NavigationStack</st>`开始。
- en: <st c="2920">Exploring NavigationStack</st>
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索`<st c="2904">NavigationStack</st>`
- en: <st c="2946">When SwiftUI was</st> <st c="2963">introduced, the basic navigation
    mechanism was based on a view called</st> `<st c="3034">NavigationView</st>`<st
    c="3048">. However,</st> `<st c="3059">NavigationView</st>` <st c="3073">was too
    simple for most apps, and</st> `<st c="3108">NavigationStack</st>` <st c="3123">replaced
    it.</st> <st c="3137">In fact, Apple deprecated</st> `<st c="3163">NavigationView</st>`<st
    c="3177">, starting with</st> <st c="3193">iOS 18.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当SwiftUI被引入时，基本的导航机制是基于一个名为`<st c="3034">NavigationView</st>`的视图。然而，`<st c="3059">NavigationView</st>`对于大多数应用来说过于简单，因此`<st
    c="3108">NavigationStack</st>`取代了它。实际上，苹果从iOS 18开始弃用了`<st c="3163">NavigationView</st>`。
- en: <st c="3200">Compared to</st> `<st c="3213">NavigationView</st>`<st c="3227">,</st>
    `<st c="3229">NavigationStack</st>` <st c="3244">adds a little bit of complexity
    to the pile, which provides us with</st> <st c="3313">new capabilitie</st><st
    c="3328">s.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与`<st c="3213">NavigationView</st>`相比，`<st c="3229">NavigationStack</st>`给这个堆栈增加了一点点复杂性，这为我们提供了新的功能。
- en: <st c="3331">Let’s see a simple example of a</st> `<st c="3364">NavigationStack</st>`
    <st c="3379">usage:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`<st c="3364">NavigationStack</st>`的一个简单用法示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3536">This code example</st> <st c="3554">looks</st> <st c="3561">pretty
    simple!</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例看起来非常简单！
- en: <st c="3575">However,</st> `<st c="3585">NavigationStack</st>` <st c="3600">is
    much more powerful than</st> <st c="3628">it seems.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`<st c="3585">NavigationStack</st>`比它看起来要强大得多。
- en: <st c="3637">How?</st> <st c="3643">The concept of</st> `<st c="3658">NavigationStack</st>`
    <st c="3673">is constructed from</st> <st c="3694">four components:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样？`<st c="3658">NavigationStack</st>`的概念是由四个组件构成的：
- en: '`<st c="3786">NavigationView</st>`<st c="3800">. In</st> `<st c="3805">NavigationStack</st>`<st
    c="3820">,</st> `<st c="3822">NavigationLink</st>` <st c="3836">describes what
    happened, and the</st> `<st c="3870">navigationDestination</st>` <st c="3891">view
    modifier describes where</st> <st c="3922">we go.</st>'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="3786">NavigationView</st>`<st c="3800">。在</st> `<st c="3805">NavigationStack</st>`<st
    c="3820">中，`<st c="3822">NavigationLink</st>` <st c="3836">描述了发生了什么，而</st> `<st
    c="3870">navigationDestination</st>` <st c="3891">视图修饰符描述了我们去哪里。</st>'
- en: '**<st c="3928">Linking between data and destinations</st>**<st c="3966">: In
    a way, this is a development of the preceding point.</st> <st c="4025">The destination
    is linked to a data type.</st> <st c="4067">This means that we can have several
    navigation links that point to the same destination just because they share the
    same</st> <st c="4188">data type.</st>'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="3928">数据与目的地之间的链接</st>**<st c="3966">：在某种程度上，这是前面点的进一步发展。</st> <st
    c="4025">目的地链接到一个数据类型。</st> <st c="4067">这意味着我们可以有多个导航链接指向同一个目的地，仅仅因为它们共享相同</st>
    <st c="4188">的数据类型。</st>'
- en: '**<st c="4198">Allowing us to read and update the path</st>**<st c="4238">:
    Here, we have another development of our idea.</st> <st c="4288">Because the data
    and the screen are now linked, we can represent the path as an array of data instances.</st>
    <st c="4393">Modifying the path array also changes our</st> <st c="4435">views
    stack.</st>'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="4198">允许我们读取和更新路径</st>**<st c="4238">：这里，我们对我们想法的另一个发展。</st> <st c="4288">因为数据和屏幕现在是链接的，我们可以将路径表示为数据实例的数组。</st>
    <st c="4393">修改路径数组也会改变我们的</st> <st c="4435">视图栈。</st>'
- en: '`<st c="4509">NavigationLink</st>` <st c="4523">also had this capability, but
    the introduction of</st> `<st c="4574">NavigationStack</st>` <st c="4589">made</st>
    <st c="4595">it obsolete.</st>'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="4509">NavigationLink</st>` <st c="4523">也具有这种能力，但</st> `<st c="4574">NavigationStack</st>`
    <st c="4589">的引入使其变得过时。</st>'
- en: <st c="4607">Let’s cover each of these four components in detail now, and we’ll
    start</st> <st c="4681">with destinations.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4607">现在让我们详细讨论这四个组件中的每一个，我们将从目的地开始。</st> <st c="4681">我们从目的地开始。</st>
- en: <st c="4699">Separating the navigation destination using the navigationDestination
    view modifier</st>
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4699">使用navigationDestination视图修饰符分离导航目标</st>
- en: <st c="4783">If you’ve read my</st> <st c="4802">previous</st> <st c="4811">books
    (</st>*<st c="4818">Pro iOS Testing</st>* <st c="4834">and</st> *<st c="4839">Mastering
    Swift Package Manager</st>* <st c="4870">by</st> *<st c="4874">Apress</st>*<st
    c="4880">, and</st> *<st c="4886">The Ultimate iOS Interview Playbook</st>* <st
    c="4921">by</st> *<st c="4925">Packt Publishing</st>*<st c="4941">) there’s an
    important principle I keep nagging about:</st> **<st c="4997">separation of concerns</st>**
    <st c="5019">(</st>**<st c="5021">SoC</st>**<st c="5024">).</st> <st c="5028">In
    SoC, we break our code into distinct modules or</st> <st c="5079">components,
    each with a specific and well-defined responsibility.</st> <st c="5145">This makes
    our code more modular, flexible, and easy</st> <st c="5198">to maintain.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4783">如果你已经阅读过我的</st> <st c="4802">上一本书</st> <st c="4811">（</st>*<st
    c="4818">《Pro iOS Testing》</st>* <st c="4834">和</st> *<st c="4839">《Mastering
    Swift Package Manager》</st>* <st c="4870">由</st> *<st c="4874">Apress</st>*<st
    c="4880">出版，以及</st> *<st c="4886">《The Ultimate iOS Interview Playbook》</st>*
    <st c="4921">由</st> *<st c="4925">Packt Publishing</st>*<st c="4941">出版）</st>，那么有一个重要的原则我一直反复强调：**<st
    c="4997">关注点分离</st>** <st c="5019">(</st>**<st c="5021">SoC</st>**<st c="5024">).</st>
    <st c="5028">在SoC中，我们将代码分解成具有特定和明确责任的独立模块或</st> <st c="5079">组件。</st> <st c="5145">这使得我们的代码更加模块化、灵活，并且易于维护。</st>
- en: <st c="5210">When we look back at</st> `<st c="5232">NavigationLink</st>`<st
    c="5246">, we can see that it has more than one responsibility – it is the actual
    control that the user taps on and also contains the next</st> <st c="5376">screen
    view.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5210">当我们回顾</st> `<st c="5232">NavigationLink</st>`<st c="5246">时，我们可以看到它有多于一个的责任——它是用户实际点击的控制，同时也包含下一个</st>
    <st c="5376">屏幕视图。</st>
- en: <st c="5388">In</st> `<st c="5392">NavigationStack</st>`<st c="5407">, there’s
    a new view modifier called</st> `<st c="5444">navigationDestination</st>`<st c="5465">,
    which allows us to define a destination separately according to a</st> <st c="5533">state
    change.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5388">在</st> `<st c="5392">NavigationStack</st>`<st c="5407">中，有一个新的视图修饰符称为</st>
    `<st c="5444">navigationDestination</st>`<st c="5465">，它允许我们根据状态变化分别定义一个目标。</st>
- en: <st c="5546">Let’s see an example of</st> `<st c="5571">navigationDestination</st>`<st
    c="5592">, based on a</st> <st c="5605">binding variable:</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5546">让我们看看</st> `<st c="5571">navigationDestination</st>`<st c="5592">的一个例子，基于一个</st>
    <st c="5605">绑定变量：</st>
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="5889">In our code example, we can see a</st> `<st c="5924">NavigationStack</st>`
    <st c="5939">view containing a button.</st> <st c="5966">Notice that there’s no</st>
    `<st c="5989">NavigationLink</st>` <st c="6003">view at all, and that’s because
    we don’t need it.</st> <st c="6054">We trigger the navigation by changing the</st>
    `<st c="6096">@State</st>` <st c="6102">property named</st> `<st c="6118">isNextScreenDisplayed</st>`
    <st c="6139">rather than using a</st> `<st c="6160">NavigationLink</st>` <st c="6174">view.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5889">在我们的代码示例中，我们可以看到一个包含按钮的</st> `<st c="5924">NavigationStack</st>`
    <st c="5939">视图。</st> <st c="5966">请注意，没有任何</st> `<st c="5989">NavigationLink</st>`
    <st c="6003">视图，这是因为我们不需要它。</st> <st c="6054">我们通过改变名为</st> `<st c="6096">@State</st>`
    <st c="6102">的`<st c="6118">isNextScreenDisplayed</st>` <st c="6139">属性来触发导航，而不是使用一个`<st
    c="6160">NavigationLink</st>` <st c="6174">视图。</st>
- en: <st c="6180">The button also has a view modifier called</st> `<st c="6224">navigationDestination</st>`<st
    c="6245">. The</st> `<st c="6251">navigationDestination</st>` <st c="6272">view
    modifier has a binding Boolean variable that is linked to the</st> `<st c="6340">isNextScreenDisplayed</st>`
    <st c="6361">state variable.</st> <st c="6378">It also has a view builder that
    contains our next screen (similar</st> <st c="6444">to</st> `<st c="6447">NavigationLink</st>`<st
    c="6461">).</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6180">按钮还有一个名为</st> `<st c="6224">navigationDestination</st>`<st c="6245">的视图修饰符。</st>
    `<st c="6251">navigationDestination</st>` <st c="6272">视图修饰符有一个绑定布尔变量，它与`<st c="6340">isNextScreenDisplayed</st>`
    <st c="6361">状态变量相关联。</st> `<st c="6378">它还有一个包含我们的下一个屏幕（类似于`<st c="6447">NavigationLink</st>`<st
    c="6461">）的视图构建器。</st>
- en: <st c="6464">Tapping on the button toggles</st> `<st c="6495">isNextScreenDisplayed</st>`
    <st c="6516">and navigates our</st> <st c="6535">next screen.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6464">点击按钮会切换`<st c="6495">isNextScreenDisplayed</st>` <st c="6516">并导航到我们的下一个屏幕。</st>
- en: <st c="6547">This capability of</st> <st c="6567">triggering</st> <st c="6578">navigation
    using</st> `<st c="6595">NavigationLink</st>` <st c="6609">was available in earlier
    versions of SwiftUI, but it is deprecated now.</st> <st c="6682">But don’t worry
    – decoupling the destination from the actual control makes our code much more
    flexible and provides us with</st> <st c="6806">more opportunities.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6547">使用`<st c="6595">NavigationLink</st>` <st c="6609">触发导航的能力在SwiftUI的早期版本中是可用的，但现在已被弃用。</st>
    <st c="6682">但不用担心——将目的地与实际控件解耦使我们的代码更加灵活，并为我们提供了更多机会。</st>
- en: <st c="6825">For example, imagine we’re doing an asynchrony operation such as
    a network request or image processing, and we want to move to the next screen
    – that can be done easily by toggling a</st> <st c="7009">Boolean variable.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6825">例如，想象我们正在进行异步操作，如网络请求或图像处理，并且我们想要移动到下一个屏幕——可以通过切换布尔变量轻松实现。</st>
- en: <st c="7026">Another important aspect of having a separate destination is that
    we can trigger the same navigation from different places.</st> <st c="7151">We
    can toggle the Boo</st><st c="7172">lean from an asynchronous operation and a
    button as well.</st> <st c="7231">Responding to a state follows a declarative
    approach rather than the</st> `<st c="7300">NavigationView</st>` <st c="7314">approach,
    which was responding to a</st> <st c="7351">button tap.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7026">拥有独立目的地的一个重要方面是，我们可以从不同的地方触发相同的导航。</st> <st c="7151">我们可以通过异步操作和按钮切换
    Boo</st><st c="7172">lean。</st> <st c="7231">响应状态遵循声明式方法，而不是</st> `<st c="7300">NavigationView</st>`
    <st c="7314">方法，后者是响应按钮点击。</st>
- en: <st c="7362">Toggling a Boolean variable is great when navigating to a new screen
    unrelated to any data.</st> <st c="7455">For example, moving to the settings from
    our main screen is a classic example of using a</st> <st c="7544">Boolean binding.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7362">当导航到与任何数据无关的新屏幕时，切换布尔变量是很有用的。</st> <st c="7455">例如，从我们的主屏幕移动到设置是一个使用布尔绑定的经典例子。</st>
    <st c="7544">Boolean binding。</st>
- en: <st c="7560">But I</st> <st c="7567">promised</st> <st c="7576">that</st> `<st
    c="7581">NavigationStack</st>` <st c="7596">has more than that,</st> <st c="7617">didn’t
    I?</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7560">但我</st> <st c="7567">承诺</st> <st c="7576">`<st c="7581">NavigationStack</st>`
    <st c="7596">不仅仅如此，</st> <st c="7617">不是吗？</st>
- en: <st c="7626">So, let’s see how we can bind our navigation destinations to</st>
    <st c="7688">data models.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7626">那么，让我们看看我们如何将导航目的地绑定到</st> <st c="7688">数据模型。</st>
- en: <st c="7700">Using data models to trigger navigation</st>
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7700">使用数据模型触发导航</st>
- en: <st c="7740">Developers who</st> <st c="7756">are used to</st> <st c="7768">UIKit
    navigation may find the idea of using data models weird.</st> <st c="7831">After
    all, toggling a Boolean for navigation is quite similar to imperative programming,
    but how does a data model have anything to do</st> <st c="7966">with navigation?</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于使用 UIKit 导航的开发者来说，使用数据模型的想法可能很奇怪。<st c="7756">毕竟，切换布尔值进行导航与命令式编程非常相似，但数据模型与导航有什么关系呢？</st>
- en: <st c="7982">We understand that many screens are related to a specific data
    model.</st> <st c="8053">For example, tapping on a movie leads us to a single
    movie screen if we have a list of movies.</st> <st c="8148">Another example is
    a trips app, where tapping on a specific trip leads us to a screen dedicated to</st>
    <st c="8247">that trip.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解到许多屏幕都与特定的数据模型相关。<st c="8053">例如，如果我们有一个电影列表，点击一个电影会带我们到一个单独的电影屏幕。</st>
    <st c="8148">另一个例子是行程应用，点击特定的行程会带我们到一个专门针对该行程的屏幕。</st> <st c="8247">（注：此处省略了代码中的特殊字符标识，实际翻译时请保留。）
- en: <st c="8257">If we think even deeper than that, we can represent many screens
    in our app using a data model.</st> <st c="8354">We can distinguish between screens
    using a data model containing</st> <st c="8419">an enum.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再深入思考，我们可以使用数据模型在我们的应用中表示许多屏幕。<st c="8354">我们可以使用包含</st> <st c="8419">枚举的数据模型来区分屏幕。</st>
- en: <st c="8427">Before we set sail with our thoughts, exploring potential possibilities
    and implementations, let’s see what basic data-based navigation</st> <st c="8564">looks
    like:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始思考探索潜在的可能性和实现方式之前，让我们看看基于基本数据导航是什么样子：<st c="8564">（注：此处省略了代码中的特殊字符标识，实际翻译时请保留。）</st>
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="8859">As always, I have highlighted the interesting parts in the preceding
    code.</st> <st c="8935">We have a SwiftUI view that displays a list of countries
    (based on a</st> <st c="9004">constant variable).</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我已经在前面代码中突出了有趣的部分。<st c="8935">我们有一个 SwiftUI 视图，显示一个国家列表（基于一个</st> <st
    c="9004">常量变量）。</st>
- en: <st c="9023">Each row has a</st> `<st c="9039">NavigationLink</st>` <st c="9053">view
    that displays the country name, but it doesn’t have its own destination this time.</st>
    <st c="9142">Instead, it uses the country as the link’s</st> <st c="9185">value
    parameter.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都有一个 `<st c="9039">NavigationLink</st>` <st c="9053">视图来显示国家名称，但这次它没有自己的目的地。</st>
    <st c="9142">相反，它使用国家作为链接的</st> <st c="9185">值参数。</st>
- en: <st c="9201">We can understand what sending the country as a value means only
    when we look down at the navigation destination.</st> <st c="9316">In the code
    example in the</st> *<st c="9343">Separating the navigation destination using
    the navigationDestination view modifier</st>* <st c="9426">section, the navigation
    destination was linked to a Boolean state variable.</st> <st c="9503">In this
    case, the navigation destination performs</st> <st c="9552">only when</st> <st
    c="9562">there’s a link with a specific data type – in this case, a string type
    (just like a</st> <st c="9647">country value).</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在查看导航目的地时才能理解将国家作为值发送的含义。<st c="9316">在 *<st c="9343">使用 navigationDestination
    视图修饰符分离导航目的地</st>* <st c="9426">部分中的代码示例中，导航目的地被链接到一个布尔状态变量。</st> <st c="9503">在这种情况下，导航目的地仅在</st>
    <st c="9552">存在特定数据类型的链接时执行</st> <st c="9562">（在这种情况下，是一个字符串类型，就像一个</st> <st c="9647">国家值）。</st>
- en: <st c="9662">In other words, tapping on a country sends its value to the navigation
    stack using</st> `<st c="9746">NavigationLink</st>`<st c="9760">. The navigation
    destination catches that and defines what will be our</st> <st c="9831">next screen.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，点击一个国家会通过 `<st c="9746">NavigationLink</st>`<st c="9760">将其值发送到导航堆栈。导航目的地捕获这个值并定义我们的下一个屏幕。<st
    c="9831">（注：此处省略了代码中的特殊字符标识，实际翻译时请保留。）</st>
- en: <st c="9843">We can use the data models to navigate to different places by defining
    multiple navigation destinations, each responding to a different data</st> <st
    c="9985">model type.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义多个导航目的地来使用数据模型导航到不同的地方，每个目的地对应不同的数据模型类型。<st c="9985">（注：此处省略了代码中的特殊字符标识，实际翻译时请保留。）
- en: <st c="9996">Here’s another example of using a navigation destination to add
    a navigation to a</st> <st c="10079">profile screen:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用导航目的地向个人资料屏幕添加导航的另一个例子：<st c="9996">（注：此处省略了代码中的特殊字符标识，实际翻译时请保留。）</st>
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="10755">In the preceding code, we see another navigation destination for
    a data model from the type of</st> `<st c="10851">Profile</st>`<st c="10858">.
    To navigate the profile screen, we added another</st> `<st c="10909">NavigationLink</st>`
    <st c="10923">view in the screen toolbar and sent the profile</st> <st c="10972">data
    model.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到一个来自`<st c="10851">Profile</st>` `<st c="10858">类型`的数据模型的另一个导航目的地。要导航到配置文件屏幕，我们在屏幕工具栏中添加了另一个`<st
    c="10909">NavigationLink</st>` `<st c="10923">视图`并发送了配置文件`<st c="10972">数据模型</st>`。
- en: <st c="10983">Our navigation system is dynamic because we can work with different
    data models.</st> <st c="11065">But that doesn’t stop</st> <st c="11087">here.</st>
    `<st c="11093">NavigationStack</st>` <st c="11108">can</st> <st c="11112">also
    reveal and even modify the current view’s stack.</st> <st c="11167">We do that
    using the path</st> <st c="11193">binding variable.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导航系统是动态的，因为我们可以使用不同的数据模型。但这并没有停止。`<st c="11093">NavigationStack</st>` `<st
    c="11108">可以</st>` `<st c="11112">揭示并甚至修改当前视图的堆栈。</st>`我们使用`<st c="11167">path</st>`
    `<st c="11193">绑定变量</st>`来做到这一点。
- en: <st c="11210">Responding to the path variable</st>
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`《st c="11210">响应路径变量</st>`'
- en: <st c="11242">Separating the</st> <st c="11258">destination</st> <st c="11269">from
    its navigation link is great, but</st> `<st c="11309">NavigationStack</st>`<st
    c="11324">’s ability to observe and update its stack of views is</st> <st c="11380">very
    powerful.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<st c="11242">目的地</st>` `<st c="11258">与其导航链接</st>`分离是很好的，但`<st c="11309">NavigationStack</st>`
    `<st c="11324">’s`观察和更新其视图堆栈的能力非常强大。
- en: <st c="11394">As mentioned, a</st> `<st c="11411">NavigationStack</st>` <st
    c="11426">view has a binding variable called</st> `<st c="11462">path</st>`<st
    c="11466">, and the</st> `<st c="11476">path</st>` <st c="11480">variable can
    contain the list of views by their</st> <st c="11529">data models.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个`<st c="11394">NavigationStack</st>` `<st c="11411">视图`有一个名为`<st c="11462">path</st>`的绑定变量，并且`<st
    c="11476">path</st>`变量可以包含通过其`<st c="11529">数据模型</st>`的视图列表。
- en: <st c="11541">It is easy to demonstrate that using a</st> <st c="11581">linked
    list:</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表很容易证明这一点：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="12045">I chose to demonstrate</st> <st c="12069">working</st> <st c="12076">with</st>
    `<st c="12082">path</st>` <st c="12086">using a linked list since it’s a great
    data structure that is similar to a navigation stack (linked items from the</st>
    <st c="12202">same type).</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用链表来演示`<st c="12082">path</st>` `<st c="12086">使用`，因为它是一个很好的数据结构，类似于导航堆栈（来自相同类型的链接项）。
- en: <st c="12213">If we observe the</st> `<st c="12232">path</st>` <st c="12236">variable
    during navigation, we can see it contains a collection of the list nodes currently
    active</st> <st c="12336">as views.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在导航期间观察`<st c="12232">path</st>` `<st c="12236">变量`，我们可以看到它包含当前作为视图活动的列表节点集合。
- en: <st c="12345">What’s great about the fact that the</st> `<st c="12383">path</st>`
    <st c="12387">variable is bound to the</st> `<st c="12413">NavigationStack</st>`
    <st c="12428">is that we can manipulate and</st> <st c="12459">modify it:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12345">path</st>` `<st c="12383">变量</st>`绑定到`<st c="12413">NavigationStack</st>`
    `<st c="12428">的事实非常棒，因为我们能够操作和`<st c="12459">修改</st>`它：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="12494">Appending a new list node to</st> `<st c="12524">path</st>` <st
    c="12528">triggers the navigation and directs the user to a</st> <st c="12579">new
    screen.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向`<st c="12524">path</st>` `<st c="12528">添加新的列表节点会触发导航并将用户引导到一个新的`<st c="12579">屏幕</st>`。
- en: <st c="12590">We can also create a whole stack using the</st> `<st c="12634">path</st>`
    <st c="12638">variable:</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`<st c="12634">path</st>` `<st c="12638">变量</st>`来创建整个堆栈：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="12682">Setting a new array of nodes creates a new stack of corresponding
    views.</st> <st c="12756">This is a great way to implement a deep link or direct
    the user to a specific location within</st> <st c="12850">the app.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设置新的节点数组会创建相应视图的新堆栈。这是一个实现深度链接或将用户引导到应用内的特定位置的好方法。
- en: <st c="12858">You are probably scratching your head right now and thinking,
    how can we implement it inside an app?</st> <st c="12960">What are the use cases
    where we navigate a few levels down the hierarchy with the same data</st> <st
    c="13052">model type?</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能正在挠头，在想我们如何在应用内部实现它？在哪些用例中，我们需要使用相同的数据模型类型在层次结构中导航几个级别？
- en: <st c="13063">So, a data model type doesn’t have to be</st> `<st c="13105">Task</st>`<st
    c="13109">,</st> `<st c="13111">Album</st>`<st c="13116">, or</st> `<st c="13121">Contact</st>`<st
    c="13128">. A data model can also describe a screen or a feature.</st> <st c="13184">In
    this way, data collection can describe a navigation path inside</st> <st c="13251">an
    app.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13063">因此，数据模型类型不一定是</st> `<st c="13105">Task</st>`<st c="13109">,</st>
    `<st c="13111">Album</st>`<st c="13116">, 或</st> `<st c="13121">Contact</st>`<st
    c="13128">。数据模型也可以描述一个屏幕或一个功能。</st> <st c="13184">这样，数据集合可以描述应用内的导航路径。</st>
- en: <st c="13258">Here’s an example</st> <st c="13276">of a data type that</st>
    <st c="13296">can describe a screen, followed by a</st> <st c="13334">navigation
    path:</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13258">以下是一个可以描述屏幕的数据类型示例，后面跟着一个</st> <st c="13276">导航路径：</st>
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="13465">The Enum</st> `<st c="13475">Screen</st>` <st c="13481">describes
    the type of screen we want to navigate to, and it’s an easy way to build</st>
    <st c="13565">a stack:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13465">枚举</st> `<st c="13475">Screen</st>` <st c="13481">描述了我们要导航到的屏幕类型，并且是构建</st>
    <st c="13565">堆栈</st> <st c="13569">的一个简单方法：</st>
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="13605">That short line of code builds a stack of views when the first
    view is the main screen followed by a</st> <st c="13707">settings screen.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13605">这一行简短的代码在第一个视图是主屏幕，后面跟着一个</st> <st c="13707">设置屏幕</st> <st c="13711">时构建了一个视图堆栈。</st>
- en: <st c="13723">Using an Enum to display different kinds of screens is great.</st>
    <st c="13786">However, working with different types of data is less convenient
    with Enum.</st> <st c="13862">To solve that issue, we have a more complex solution</st>
    <st c="13914">than</st> <st c="13919">a collection of instances, and it’s</st>
    <st c="13956">called</st> `<st c="13963">NavigationPath</st>`<st c="13977">.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13723">使用枚举来显示不同类型的屏幕是很好的。</st> <st c="13786">然而，使用枚举处理不同类型的数据不太方便。</st>
    <st c="13862">为了解决这个问题，我们有一个比实例集合更复杂的解决方案，它被称为</st> `<st c="13963">NavigationPath</st>`<st
    c="13977">。</st>
- en: <st c="13978">Working with different types of data using NavigationPath</st>
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="13978">使用 NavigationPath 处理不同类型的数据</st>
- en: '`<st c="14036">NavigationPath</st>` <st c="14051">was</st> <st c="14055">introduced
    along with</st> `<st c="14078">NavigationStack</st>`<st c="14093">, and it allows
    us to have more control of our navigation flows.</st> <st c="14158">In fact,</st>
    `<st c="14167">NavigationPath</st>` <st c="14181">makes navigation with SwiftUI
    a mix of declarative and imperative programming and is much more similar to the
    UIKit</st> <st c="14298">navigation pattern.</st>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="14036">NavigationPath</st>` <st c="14051">是与</st> `<st c="14078">NavigationStack</st>`<st
    c="14093">一起引入的，它允许我们更好地控制我们的导航流程。</st> <st c="14158">实际上，</st> `<st c="14167">NavigationPath</st>`
    <st c="14181">使得使用 SwiftUI 进行导航结合了声明式和命令式编程，并且与 UIKit</st> <st c="14298">的导航模式更为相似。</st>'
- en: <st c="14317">Let’s say we have a music app with a list of songs and albums
    on its main screen.</st> <st c="14400">Tapping on a song leads to a</st> `<st
    c="14429">song</st>` <st c="14433">view while tapping on an album navigates to
    an</st> `<st c="14481">album</st>` <st c="14486">view.</st> <st c="14493">In the
    previous section, we managed that using an Enum, trying to map the Enum value
    to a screen view.</st> <st c="14596">With</st> `<st c="14601">NavigationPath</st>`<st
    c="14615">, we can append whatever value we want to the</st> `<st c="14661">path</st>`
    <st c="14665">variable as long as its type conforms</st> <st c="14704">to</st>
    `<st c="14707">Hashable</st>`<st c="14715">.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14317">假设我们有一个音乐应用，其主屏幕上有一个歌曲和专辑列表。</st> <st c="14400">点击歌曲会跳转到</st>
    `<st c="14429">歌曲</st>` <st c="14433">视图，而点击专辑则会导航到一个</st> `<st c="14481">专辑</st>`
    <st c="14486">视图。</st> <st c="14493">在上一个部分中，我们使用枚举来管理这一点，尝试将枚举值映射到屏幕视图。</st>
    <st c="14596">使用</st> `<st c="14601">NavigationPath</st>`<st c="14615">，只要其类型符合</st>
    <st c="14661">可哈希</st> <st c="14665">，我们就可以将任何我们想要的值附加到</st> `<st c="14661">path</st>`
    <st c="14665">变量上。</st>
- en: <st c="14716">Let’s have a look at the</st> <st c="14742">following code:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14716">让我们看看下面的</st> <st c="14742">代码：</st>
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="15550">Note that the preceding code example is partial and does not include
    the</st> <st c="15623">child views.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15550">请注意，前面的代码示例是不完整的，它不包括</st> <st c="15623">子视图。</st>
- en: <st c="15635">Our music app’s main screen contains four important parts that
    handle our</st> <st c="15710">navigation system:</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15635">我们的音乐应用主屏幕包含四个重要的部分，用于处理我们的</st> <st c="15710">导航系统：</st>
- en: <st c="15728">We start with declaring a state variable that holds our</st> `<st
    c="15785">path</st>` <st c="15789">variable</st> <st c="15799">called</st> `<st
    c="15806">NavigationPath</st>`<st c="15820">:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从声明一个状态变量开始，该变量保存我们的<st c="15785">path</st> <st c="15789">变量</st> <st c="15799">，称为<st
    c="15806">NavigationPath</st><st c="15820">：</st>
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="15875">As mentioned earlier, unlike the previous</st> `<st c="15918">path</st>`
    <st c="15922">variable we used, in the</st> `<st c="15948">NavigationPath</st>`
    <st c="15962">case, we don’t need to define its type.</st> <st c="16003">It can
    hold any type we want as long as it</st> <st c="16045">conforms</st> <st c="16055">to</st>
    `<st c="16058">Hashable</st>`<st c="16066">.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，与之前我们使用的`<st c="15918">path</st>` `<st c="15922">`变量不同，在`<st c="15948">NavigationPath</st>`
    `<st c="15962">`的情况下，我们不需要定义其类型。<st c="16003">只要它符合</st> `<st c="16058">Hashable</st>`
    `<st c="16066">`，它就可以保存我们想要的任何类型。</st>
- en: <st c="16067">Next, we will initiate</st> `<st c="16091">NavigationStack</st>`
    <st c="16106">with our new</st> `<st c="16120">NavigationPath</st>` <st c="16134">similar
    to what we did in the</st> <st c="16165">previous example:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的新<st c="16120">NavigationPath</st> <st c="16134">来初始化</st> `<st
    c="16091">NavigationStack</st>` <st c="16106">，这与我们在之前的例子中做的是类似的：</st>
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="16223">Notice that we use a similar signature but with a different type
    –</st> `<st c="16291">Binding<NavigationPath></st>` <st c="16314">instead</st>
    <st c="16323">of</st> `<st c="16326">Binding<Data></st>`<st c="16339">.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了一个类似的签名，但是类型不同——使用<st c="16291">Binding<NavigationPath></st> <st c="16314">而不是</st>
    `<st c="16326">Binding<Data></st>`<st c="16339">。</st>
- en: <st c="16340">Now that we have</st> `<st c="16358">NavigationPath</st>`<st c="16372">,
    we can navigate to a</st> `<st c="16395">song</st>` <st c="16399">view or to an</st>
    `<st c="16414">album</st>` <st c="16419">view by appending the corresponding object
    to the</st> <st c="16470">navigation path:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了<st c="16358">NavigationPath</st><st c="16372">，我们可以通过将相应的对象添加到导航路径中来导航到一个<st
    c="16395">歌曲</st> <st c="16399">视图或一个<st c="16414">专辑</st> <st c="16419">视图：</st>
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="16514">Or, you can do it</st> <st c="16533">like so:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以这样做：</st>
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="16570">The appending operation triggers the</st> `<st c="16608">navigationDestination</st>`
    <st c="16629">view modifier, passing the song or the album that</st> <st c="16680">was
    selected:</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加操作会触发<st c="16608">navigationDestination</st> <st c="16629">视图修饰符，传递所选的歌曲或专辑：</st>
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="16886">In this example, we have a different</st> `<st c="16924">navigationDestination</st>`
    <st c="16945">view modifier for each type</st> <st c="16974">we pass.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为每种类型我们传递的<st c="16924">navigationDestination</st> <st c="16945">视图修饰符都不同：</st>
- en: <st c="16982">The fact that we can append any entity we want makes</st> `<st
    c="17036">NavigationPath</st>` <st c="17050">an ideal component for a flexible</st>
    <st c="17085">navigation system.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加任何我们想要的实体的事实使得<st c="17036">NavigationPath</st> <st c="17050">成为一个灵活的导航系统的理想组件。</st>
- en: <st c="17103">We can also use</st> `<st c="17120">NavigationPath</st>` <st c="17134">to
    perform a</st> `<st c="17148">Back</st>` <st c="17152">operation by removing the</st>
    <st c="17179">last component:</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用<st c="17120">NavigationPath</st> <st c="17134">通过移除最后一个组件来执行一个<st c="17148">Back</st>
    <st c="17152">操作：</st>
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="17241">In this example, we added a back button that removes the navigation
    path’s last components</st> <st c="17333">when tapped.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了一个返回按钮，当点击时移除导航路径的最后几个组件<st c="17241">。</st> <st c="17333">。</st>
- en: <st c="17345">Because we are still in</st> <st c="17370">a declarative world,
    any change we perform to the navigation stack by appending or removing components
    reflects the change in</st> <st c="17496">our UI.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们仍然处于一个声明性世界中，我们对导航栈所做的任何更改，无论是通过添加或移除组件，都会反映在我们的UI中<st c="17345">。</st>
    <st c="17370">。</st>
- en: <st c="17503">Working with the Coordinator pattern</st>
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与协调器模式一起工作
- en: <st c="17540">The</st> `<st c="17545">NavigationPath</st>` <st c="17559">and</st>
    `<st c="17564">NavigationStack</st>` <st c="17579">combination is robust and provides
    flexibility in managing</st> <st c="17639">navigation.</st> <st c="17651">However,
    as our app scales, controlling how the user moves from screen to screen becomes</st>
    <st c="17740">more complex.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17545">NavigationPath</st>` <st c="17559">和</st> `<st c="17564">NavigationStack</st>`
    <st c="17579">的组合是健壮的，并且在管理导航方面提供了灵活性。<st c="17639">然而，随着我们的应用扩展，控制用户如何从一个屏幕移动到另一个屏幕变得更加复杂。</st>
    <st c="17651">。</st>'
- en: <st c="17753">For example, let’s say we have an onboarding flow and want a different
    set of screens for different user profiles.</st> <st c="17869">Or, we want to
    reuse the same screen within different flows.</st> <st c="17930">In each flow,
    the screen should continue to a</st> <st c="17976">different screen.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17753">例如，假设我们有一个引导流程，并希望为不同的用户配置文件提供不同的屏幕集。</st> <st c="17869">或者，我们希望在不同的流程中重用相同的屏幕。</st>
    <st c="17930">在每个流程中，屏幕应该继续到</st> <st c="17976">不同的屏幕。</st>
- en: <st c="17993">In each case, it becomes difficult to understand our next view
    when we are within the screen context.</st> <st c="18096">In fact, this problem
    of managing our navigation is not related only to SwiftUI, and most developers
    know that</st> <st c="18207">from UIKit.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17993">在每种情况下，当我们处于屏幕上下文时，理解我们的下一个视图都变得很困难。</st> <st c="18096">实际上，管理我们的导航这个问题不仅与
    SwiftUI 有关，而且大多数开发者都知道</st> <st c="18207">从 UIKit。</st>
- en: <st c="18218">To try and improve our navigation mechanism, we can use what’s
    called a</st> **<st c="18291">Coordinator pattern</st>** <st c="18310">– a pattern
    that</st> <st c="18327">delegates the navigation logic to a</st> <st c="18364">dedicated
    component.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18218">为了尝试改进我们的导航机制，我们可以使用所谓的</st> **<st c="18291">协调器模式</st>** <st
    c="18310">——一种将导航逻辑委托给</st> <st c="18327">专用组件的模式。</st>
- en: <st c="18384">Let’s try to understand what</st> <st c="18414">it means.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18384">让我们尝试理解这意味着什么。</st>
- en: <st c="18423">Understandi</st><st c="18435">ng the Coordinator’s principles</st>
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="18423">理解协调器的原理</st>
- en: <st c="18467">Before we write our</st> <st c="18488">first Coordinator together,
    let’s review some</st> <st c="18534">fundamental principles:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18467">在我们编写</st> <st c="18488">第一个协调器之前，</st> <st c="18534">让我们回顾一些</st>
    <st c="18534">基本原理：</st>
- en: <st c="18557">The Coordinator is a component that holds the current navigation
    path and general context.</st> <st c="18649">It knows what screen is displayed
    and the general current flow.</st> <st c="18713">The Coordinator also adds a new
    view to the stack, pops, and shows modal or</st> <st c="18789">sheet views.</st>
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18557">协调器是一个组件，它保存当前的导航路径和一般上下文。</st> <st c="18649">它知道显示的是哪个屏幕以及一般的当前流程。</st>
    <st c="18713">协调器还会将新的视图添加到堆栈中，弹出，并显示模态或</st> <st c="18789">表单视图。</st>
- en: <st c="18801">A view doesn’t know the following view the user should navigate
    to.</st> <st c="18870">What it does know is only the action the user performed.</st>
    <st c="18927">In a way, the view is isolated from the navigation logic and is
    unaware of the</st> <st c="19006">general context.</st>
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18801">视图不知道用户应该导航到的下一个视图。</st> <st c="18870">它所知道的是用户执行的操作。</st> <st
    c="18927">从某种意义上说，视图与导航逻辑是隔离的，并且不了解</st> <st c="19006">一般上下文。</st>
- en: <st c="19022">A coordinator represents a flow.</st> <st c="19056">We can have
    several flows in our app with</st> <st c="19098">several coordinators.</st>
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19022">协调器代表一个流程。</st> <st c="19056">在我们的应用中，我们可以有多个流程，每个流程有多个协调器。</st>
- en: <st c="19119">As a result of these principles, we can understand that the Coordinator
    pattern is an improved way of separating our</st> <st c="19237">app concerns.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19119">根据这些原则，我们可以理解协调器模式是我们分离应用关注点的一种改进方式。</st> <st c="19237">应用关注点。</st>
- en: <st c="19250">Look at</st> *<st c="19259">Figure 4</st>**<st c="19267">.1</st>*<st
    c="19269">:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19250">看看</st> *<st c="19259">图 4</st>**<st c="19267">.1</st>*<st c="19269">：</st>
- en: '![Figure 4.1: The Coordinator pattern](img/B21795_04_1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：协调器模式](img/B21795_04_1.jpg)'
- en: '<st c="19391">Figure 4.1: The Coordinator pattern</st>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19391">图 4.1：协调器模式</st>
- en: '*<st c="19426">Figure 4</st>**<st c="19435">.1</st>* <st c="19437">shows a
    basic Coordinator pattern.</st> <st c="19473">We have an</st> *<st c="19484">Albums
    List</st>* <st c="19495">view, and when the user selects an album, the action
    is sent to the</st> *<st c="19564">Coordinator</st>*<st c="19575">. Then, the
    Coordinator decides to navigate to the</st> *<st c="19626">Album Detail</st>*
    <st c="19638">view by sending the action</st> <st c="19666">to</st> `<st c="19669">NavigationPath</st>`<st
    c="19683">.</st>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="19426">图 4</st>**<st c="19435">.1</st>* <st c="19437">展示了基本的协调器模式。</st>
    <st c="19473">我们有一个</st> *<st c="19484">专辑列表</st>* <st c="19495">视图，当用户选择一个专辑时，操作会被发送到</st>
    *<st c="19564">协调器</st>*<st c="19575">。然后，协调器决定通过将操作发送到</st> `<st c="19669">NavigationPath</st>`<st
    c="19683">来导航到</st> *<st c="19626">专辑详情</st>* <st c="19638">视图。</st>'
- en: <st c="19684">In this pattern, the Albums List is unaware of what should happen
    next.</st> <st c="19757">For example, the Coordinator can decide that, in some
    cases, we should show the user an upsell screen.</st> <st c="19860">Or, if it’s
    part of onboarding, the Coordinator can determine that the Albums List is just
    a demonstration and that we should proceed to the next step in the</st> <st c="20018">onboarding
    flow.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19684">在这个模式中，专辑列表不知道接下来应该发生什么。</st> <st c="19757">例如，协调器可以决定在某些情况下，我们应该向用户展示一个升级屏幕。</st>
    <st c="19860">或者，如果它是入职流程的一部分，协调器可以确定专辑列表只是一个演示，我们应该继续到入职流程的下一个步骤。</st> <st c="20018">入职流程。</st>
- en: <st c="20034">But how do we structure a Coordinator pattern?</st> <st c="20082">How
    does it work, especially in the</st> <st c="20118">SwiftUI world?</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20034">但我们如何构建一个协调器模式呢？</st> <st c="20082">它是如何工作的，尤其是在</st> <st c="20118">SwiftUI的世界中？</st>
- en: <st c="20132">There are many ways to build a Coordinator in SwiftUI.</st> <st
    c="20188">The Coordinator pattern I describe here is just an</st> <st c="20239">example
    that demonstrates the basic principles, and we can take that example and adjust
    it to our</st> <st c="20337">project’s needs.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20132">在SwiftUI中构建协调器有许多方法。</st> <st c="20188">我这里描述的协调器模式只是一个</st> <st
    c="20239">示例，用于展示基本原理，我们可以根据项目的需求调整这个示例。</st>
- en: <st c="20353">We will start with the most fundamental component – the</st> <st
    c="20410">Coordinator itself.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20353">我们将从最基本的部分开始——协调器本身。</st>
- en: <st c="20429">Building the Coordinator object</st>
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="20429">构建协调器对象</st>
- en: <st c="20461">The Coordinator is</st> <st c="20480">the central object that
    defines the different user actions and navigation options.</st> <st c="20564">It
    also holds the navigation path so it can perform the</st> <st c="20620">navigation
    operations.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20461">协调器是</st> <st c="20480">定义不同用户操作和导航选项的中心对象。</st> <st c="20564">它还持有导航路径，以便执行导航操作。</st>
- en: <st c="20642">We will start by defining a basic</st> <st c="20677">Coordinator
    class:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20642">我们将首先定义一个基本的</st> <st c="20677">协调器类：</st>
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="20774">We created a Coordinator class that holds a</st> `<st c="20819">NavigationPath</st>`
    <st c="20833">object.</st> <st c="20842">The</st> `<st c="20846">NavigationPath</st>`
    <st c="20860">object is essential – it allows the Coordinator to add more items
    to the stack, perform pop operations, and understand the current stack.</st> <st
    c="20999">Notice that the Coordinator conforms to the</st> `<st c="21043">ObservableObject</st>`
    <st c="21059">protocol and that the path is a published object – that’s because
    we want the path to be part of</st> `<st c="21157">NavigationStack</st>` <st c="21172">when
    we</st> <st c="21181">use it.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20774">我们创建了一个包含一个</st> `<st c="20819">导航路径</st>` <st c="20833">对象的协调器类。</st>
    <st c="20842">这个</st> `<st c="20846">导航路径</st>` <st c="20860">对象是必不可少的——它允许协调器向堆栈中添加更多项目，执行弹出操作，并理解当前的堆栈。</st>
    <st c="20999">请注意，协调器遵循</st> `<st c="21043">可观察对象</st>` <st c="21059">协议，并且路径是一个已发布对象——这是因为我们希望路径在使用时成为</st>
    `<st c="21157">导航堆栈</st>` <st c="21172">的一部分。</st>
- en: <st c="21188">Next, we define the different user and</st> <st c="21228">page
    actions:</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21188">接下来，我们定义不同的用户和</st> <st c="21228">页面操作：</st>
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="21414">In this example, we</st> <st c="21435">created</st> <st c="21443">two
    Enums:</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21414">在这个例子中，我们</st> <st c="21435">创建了</st> <st c="21443">两个枚举：</st>
- en: '`<st c="21453">PageAction</st>`<st c="21464">: This Enum describes a navigation
    action our Coordinator needs to perform, such as navigating to an</st> `<st c="21566">album</st>`
    <st c="21571">view or a</st> <st c="21582">settings view.</st>'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="21453">页面操作</st>`<st c="21464">：这个枚举描述了协调器需要执行的一些导航操作，例如导航到一个</st>
    `<st c="21566">专辑</st>` <st c="21571">视图或一个</st> <st c="21582">设置视图。</st>'
- en: '`<st c="21596">UserAction</st>`<st c="21607">: This Enum describes an action
    the user performed, such as tapping on an album in the Albums List or tapping
    on the</st> <st c="21725">settings button.</st>'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="21596">用户操作</st>`<st c="21607">：这个枚举描述了用户执行的操作，例如在专辑列表中点击专辑或在</st>
    <st c="21725">设置按钮上点击。</st>'
- en: <st c="21741">Notice that some Enums contain associated values, such as the
    related</st> `<st c="21812">album</st>` <st c="21817">object.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21741">请注意，一些枚举包含关联值，例如相关的</st> `<st c="21812">专辑</st>` <st c="21817">对象。</st>
- en: <st c="21825">Now that we have our Enums, we will create two</st> <st c="21873">important
    functions:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21825">现在我们有了我们的枚举，我们将创建两个</st> <st c="21873">重要的函数：</st>
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="22324">The first is the</st> `<st c="22342">performAction()</st>` <st
    c="22357">function.</st> <st c="22368">This function receives</st> `<st c="22391">UserAction</st>`
    <st c="22401">as a parameter and appends</st> <st c="22429">the corresponding
    page action to</st> `<st c="22462">NavigationPath</st>`<st c="22476">. This function
    is the Coordinator’s “brain” – where we decide where to navigate when the user
    performs a</st> <st c="22582">particular action.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22324">首先是</st> `<st c="22342">performAction()</st>` <st c="22357">函数。</st>
    <st c="22368">这个函数接收</st> `<st c="22391">UserAction</st>` <st c="22401">作为参数，并将相应的页面操作追加到</st>
    `<st c="22462">NavigationPath</st>`<st c="22476">。这个函数是协调器的“大脑”——当我们决定用户执行特定操作时要导航到哪里时。</st>
- en: <st c="22600">In this example, when the user taps the album in the Albums List,
    we navigate to the</st> `<st c="22686">album</st>` <st c="22691">view, passing
    the</st> `<st c="22710">album</st>` <st c="22715">object.</st> <st c="22724">When
    the user taps the settings button, we navigate to the settings screen.</st> <st
    c="22800">This logic may sound evident and like over-engineering.</st> <st c="22856">Still,
    in a complex world, we have permissions, A/B tests, and other changes, and a centralized
    place that handles all of these can be</st> <st c="22991">extremely valuable.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22600">在这个例子中，当用户在专辑列表中点击专辑时，我们导航到</st> `<st c="22686">专辑</st>` <st c="22691">视图，传递</st>
    `<st c="22710">专辑</st>` <st c="22715">对象。</st> <st c="22724">当用户点击设置按钮时，我们导航到设置屏幕。</st>
    <st c="22800">这种逻辑可能听起来很明显，也可能过于复杂。</st> <st c="22856">然而，在一个复杂的世界里，我们有权限、A/B
    测试和其他变化，一个集中处理所有这些的地方可以是非常宝贵的。</st>
- en: <st c="23010">The second function maps a page action to</st> <st c="23053">a
    SwiftUI view.</st> <st c="23069">We will use that now when we</st> <st c="23098">build</st>
    `<st c="23104">CoordinatorView</st>`<st c="23119">.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23010">第二个函数将页面操作映射到一个 SwiftUI 视图。</st> <st c="23053">我们现在将在构建</st> `<st
    c="23098">CoordinatorView</st>`<st c="23104">时使用它。</st>
- en: <st c="23120">Adding CoordinatorView</st>
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23120">添加 CoordinatorView</st>
- en: <st c="23143">The Coordinator</st> <st c="23159">class is robust and contains
    all of</st> <st c="23195">our navigation logic.</st> <st c="23218">However, we
    can’t use the Coordinator to perform the actual navigation.</st> <st c="23290">To
    do that, we must wrap our views with</st> `<st c="23330">CoordinatorView</st>`<st
    c="23345">, which knows how to work with</st> <st c="23376">our Coordinator.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23143">协调器</st> <st c="23159">类是健壮的，包含了我们所有的导航逻辑。</st> <st c="23195">然而，我们不能使用协调器来执行实际的导航。</st>
    <st c="23218">为了做到这一点，我们必须用</st> `<st c="23330">CoordinatorView</st>`<st c="23345">包裹我们的视图，它知道如何与</st>
    <st c="23376">我们的协调器</st>一起工作。
- en: <st c="23392">So, let’s see what</st> `<st c="23412">CoordinatorView</st>` <st
    c="23427">looks like:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23392">所以，让我们看看</st> `<st c="23412">CoordinatorView</st>` <st c="23427">是什么样子：</st>
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`<st c="23772">CoordinatorView</st>` <st c="23788">is a simple SwiftUI view
    that has</st> <st c="23823">three components:</st>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="23772">CoordinatorView</st>` <st c="23788">是一个简单的 SwiftUI 视图，它有三个组件：</st>'
- en: '`<st c="23840">coordinator</st>`<st c="23852">: In the</st> `<st c="23862">CoordinatorView</st>`<st
    c="23877">, we added an instance of our</st> `<st c="23907">Coordinator</st>`
    <st c="23918">class that we had just built.</st> <st c="23949">We made that coordinator
    an observable object so we can use its path to add and remove views from</st>
    <st c="24047">the stack.</st>'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="23840">coordinator</st>`<st c="23852">: 在</st> `<st c="23862">CoordinatorView</st>`<st
    c="23877">中，我们添加了我们刚刚构建的</st> `<st c="23907">Coordinator</st>` <st c="23918">类的一个实例。</st>
    <st c="23949">我们将该协调器制作为一个可观察对象，这样我们就可以使用其路径来添加和从</st> `<st c="24047">堆栈</st>`中移除视图。'
- en: '`<st c="24057">NavigationStack</st>`<st c="24073">: This is the same</st> `<st
    c="24093">NavigationStack</st>` <st c="24108">we met in this chapter.</st> <st
    c="24133">As mentioned, we use the coordinator path as</st> `<st c="24178">NavigationStack</st>`<st
    c="24193">, but more importantly, two additional things – we initialize the stack
    with the root view (</st>`<st c="24285">AlbumListView</st>`<st c="24299">), and
    we use the Coordinator</st> `<st c="24330">buildView</st>` <st c="24339">function
    that maps the page action to view to add the corresponding view to</st> <st c="24416">the
    stack.</st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="24057">NavigationStack</st>`<st c="24073">: 这与我们在本章中遇到的</st> `<st c="24093">NavigationStack</st>`
    <st c="24108">相同。</st> <st c="24133">如前所述，我们使用协调器路径作为</st> `<st c="24178">NavigationStack</st>`<st
    c="24193">，但更重要的是，还有两个附加事项——我们使用根视图（</st>`<st c="24285">AlbumListView</st>`<st
    c="24299">）初始化堆栈，并使用协调器</st> `<st c="24330">buildView</st>` <st c="24339">函数将页面操作映射到视图，以将相应的视图添加到</st>
    <st c="24416">堆栈。</st>'
- en: '`<st c="24426">EnvironmentObject</st>`<st c="24444">: We add an</st> `<st c="24457">environmentObject</st>`
    <st c="24474">view modifier to declare an environment object in the coordinator.</st>
    <st c="24542">We do that to provide all the views under</st> `<st c="24584">NavigationStack</st>`
    <st c="24599">with access to the Coordinator so they can call the different</st>
    <st c="24662">user actions.</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="24426">环境对象</st>`<st c="24444">：我们在协调器中添加了一个</st> `<st c="24457">environmentObject</st>`
    <st c="24474">视图修饰符来声明一个环境对象。</st> <st c="24542">我们这样做是为了让所有在</st> `<st c="24584">NavigationStack</st>`
    <st c="24599">下的视图都能访问协调器，以便它们可以调用不同的</st> <st c="24662">用户操作。</st>'
- en: <st c="24675">These three components</st> <st c="24699">are responsible for
    connecting</st> <st c="24730">our views to the Coordinator logic we</st> <st c="24768">have
    built.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24675">这三个组件</st> <st c="24699">负责将</st> <st c="24730">我们的视图连接到我们</st>
    <st c="24768">构建的协调器逻辑。</st>
- en: <st c="24779">Now, let’s see how</st> `<st c="24799">AlbumListView</st>` <st
    c="24812">works with</st> <st c="24824">the Coordinator.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24779">现在，让我们看看</st> `<st c="24799">AlbumListView</st>` <st c="24812">是如何与</st>
    <st c="24824">协调器一起工作的。</st>
- en: <st c="24840">Calling the coordinator straight from the view</st>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24840">直接从视图调用协调器</st>
- en: <st c="24887">Remember one of our</st> <st c="24908">coordinator principles
    – the view’s concern is only to say what</st> *<st c="24972">happened</st>*<st
    c="24980">, not what</st> *<st c="24991">will happen</st>* <st c="25002">next.</st>
    <st c="25009">What will happen is the</st> <st c="25033">Coordinator’s concern.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24887">记住我们的一条</st> <st c="24908">协调器原则——视图的职责只是说</st> *<st c="24972">发生了什么</st>*<st
    c="24980">，而不是</st> *<st c="24991">接下来会发生什么</st>* <st c="25002">。</st> <st c="25009">接下来会发生什么是协调器的职责。</st>
- en: <st c="25055">Let’s have a look at how</st> `<st c="25081">AlbumListView</st>`
    <st c="25094">deals</st> <st c="25101">with it:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25055">让我们看看</st> `<st c="25081">AlbumListView</st>` <st c="25094">是如何处理它的：</st>
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="25643">The</st> `<st c="25648">AlbumListView</st>` <st c="25661">struct</st>
    <st c="25668">contains a list of the user albums and a navigation bar with a</st>
    <st c="25732">settings button.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25643">`<st c="25648">AlbumListView</st>` <st c="25661">结构体</st> <st
    c="25668">包含用户专辑列表和一个带有</st> <st c="25732">设置按钮</st> <st c="25739">的导航栏。</st>
- en: <st c="25748">Tapping on one of the albums calls the Coordinator’s</st> `<st
    c="25802">performedAction()</st>` <st c="25819">function, which returns the corresponding
    Enum and the</st> <st c="25875">selected album.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25748">点击其中一个专辑会调用协调器的</st> `<st c="25802">performedAction()</st>` <st
    c="25819">函数，该函数返回相应的枚举值和</st> <st c="25875">选中的专辑。</st>
- en: <st c="25890">In addition, tapping on the settings button calls the same</st>
    `<st c="25950">performedAction()</st>` <st c="25967">function with a different</st>
    <st c="25994">Enum value.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25890">此外，点击设置按钮会调用相同的</st> `<st c="25950">performedAction()</st>` <st
    c="25967">函数，但使用不同的</st> <st c="25994">枚举值。</st>
- en: <st c="26005">Returning to the beginning of this section under the</st> *<st
    c="26059">Building the Coordinator object</st>* <st c="26090">part, we can now
    understand how everything</st> <st c="26134">is connected.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26005">回到本节的开头，在</st> *<st c="26059">构建协调器对象</st>* <st c="26090">部分，我们现在可以理解一切是如何连接起来的。</st>
- en: <st c="26147">We can also understand why the coordinator instance is an environment
    object – so we can call it straight from</st> <st c="26259">the view.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26147">我们还可以理解为什么协调器实例是一个环境对象——这样我们就可以直接从</st> <st c="26259">视图</st>
    <st c="26268">中调用它。</st>
- en: <st c="26268">Until now, we discussed</st> `<st c="26293">NavigationStack</st>`
    <st c="26308">and the Coordinator pattern.</st> <st c="26338">We might think that
    navigation is only about changing the current view.</st> <st c="26410">However,
    navigation on big screens, such as an iPad screen, often involves working with
    different columns.</st> <st c="26517">So, let’s meet</st> `<st c="26532">NavigationSplitView</st>`
    <st c="26551">to see</st> <st c="26559">how we nail that down (I told you that
    navigation is a complex topic,</st> <st c="26629">didn’t I?).</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26268">到目前为止，我们讨论了</st> `<st c="26293">NavigationStack</st>` <st c="26308">和协调器模式。</st>
    <st c="26338">我们可能会认为导航仅仅是关于改变当前视图。</st> <st c="26410">然而，在大屏幕上，如iPad屏幕上的导航，通常涉及处理不同的列。</st>
    <st c="26517">所以，让我们来认识</st> `<st c="26532">NavigationSplitView</st>` <st c="26551">，看看</st>
    <st c="26559">我们是如何将其固定下来的（我告诉你导航是一个复杂的话题，对吧？）。</st>
- en: <st c="26640">Navigating with columns with NavigationSplitView</st>
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="26640">使用NavigationSplitView进行列导航</st>
- en: <st c="26689">One of the things that</st> <st c="26712">we know when building
    apps for padOS or macOS is that we need to take advantage of the big screen.</st>
    <st c="26812">But what does it mean?</st> <st c="26835">Sometimes, it might mean
    working with a grid instead of a list.</st> <st c="26899">However, in the context
    of navigation, it means that we can work with several columns when each of the
    columns shows a different view instead of replacing the whole screen each time
    the</st> <st c="27085">user navigates.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26689">当我们为 padOS 或 macOS 开发应用时，我们知道我们需要利用大屏幕的优势。</st> <st c="26712">但这意味着什么呢？</st>
    <st c="26812">有时，它可能意味着使用网格而不是列表。</st> <st c="26835">然而，在导航的上下文中，这意味着当每个列显示不同的视图而不是每次用户导航时替换整个屏幕时，我们可以处理多个列。</st>
- en: <st c="27100">In other words – we need to split</st> <st c="27135">the screen.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27100">换句话说——我们需要</st> <st c="27135">分割屏幕。</st>
- en: <st c="27146">To do that, we can work with a view called</st> `<st c="27190">NavigationSplitView</st>`<st
    c="27209">, which presents views in two or</st> <st c="27242">three columns.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27146">为了做到这一点，我们可以使用一个名为</st> `<st c="27190">NavigationSplitView</st>`<st
    c="27209">的视图，它以两列或三列的形式展示视图。</st>
- en: <st c="27256">When a user selects an item of one view, it updates the view in
    the</st> <st c="27325">other columns.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27256">当用户选择一个视图中的一个项目时，它会更新其他列中的视图。</st>
- en: <st c="27339">Creating NavigationSplitView</st>
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27339">创建 NavigationSplitView</st>
- en: <st c="27368">To demonstrate</st> <st c="27384">how to use</st> `<st c="27395">NavigationSplitView</st>`<st
    c="27414">, we will use our music app example and adjust it</st> <st c="27464">to
    padOS.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27368">为了演示</st> <st c="27384">如何使用</st> `<st c="27395">NavigationSplitView</st>`<st
    c="27414">，我们将使用我们的音乐应用示例并将其调整</st> <st c="27464">为 padOS。</st>
- en: <st c="27473">Let’s start with some important terms – we have three different</st>
    <st c="27538">column types:</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27473">让我们从一些重要的术语开始——我们有三种不同的</st> <st c="27538">列类型：</st>
- en: '`<st c="27551">Sidebar</st>`<st c="27559">: The first column from the left.</st>
    <st c="27594">That’s the main column where we start</st> <st c="27632">our navigation.</st>'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27551">侧边栏</st>`<st c="27559">：从左侧数的第一列。</st> <st c="27594">这是我们的导航开始的主要列。</st>'
- en: '`<st c="27647">Content</st>`<st c="27655">: When there are three columns, the</st>
    `<st c="27692">Content</st>` <st c="27699">column shows data related to the selected
    item in the</st> `<st c="27754">Sidebar</st>` <st c="27761">column.</st>'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27647">内容</st>`<st c="27655">：当有三列时，</st> `<st c="27692">内容</st>` <st
    c="27699">列显示与</st> `<st c="27754">侧边栏</st>` <st c="27761">列中选定的项目相关的数据。</st>'
- en: '`<st c="27769">Detail</st>`<st c="27776">: The</st> `<st c="27783">Detail</st>`
    <st c="27789">column presents the selected item in the</st> `<st c="27831">Content</st>`
    <st c="27838">column or the</st> `<st c="27853">Sidebar</st>` <st c="27860">column.</st>
    <st c="27869">In general, it is the item that is last in the split</st> <st c="27922">view
    hierarchy.</st>'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27769">详情</st>`<st c="27776">：</st> `<st c="27783">详情</st>` <st c="27789">列展示</st>
    `<st c="27831">内容</st>` <st c="27838">列或</st> `<st c="27853">侧边栏</st>` <st c="27860">列中选定的项目。</st>
    <st c="27869">一般来说，它是分割视图层次结构中最后的项。</st>'
- en: <st c="27937">These three terms may initially sound slightly confusing, so let’s
    jump straight to the code to understand how they all fit together.</st> <st c="28072">Here’s
    an example of</st> `<st c="28093">NavigationSplitView</st>` <st c="28112">that
    shows a list of albums, and when tapping on an</st> <st c="28165">album, the app
    shows a list of</st> <st c="28196">its</st> <st c="28200">songs:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27937">这三个术语最初可能听起来有些令人困惑，所以让我们直接跳到代码，了解它们是如何相互关联的。</st> <st c="28072">以下是一个</st>
    `<st c="28093">NavigationSplitView</st>` <st c="28112">的示例，它显示了一个专辑列表，并且当点击一个</st>
    <st c="28165">专辑时，应用会显示该专辑的</st> <st c="28196">歌曲列表：</st>
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="28554">Our code shows</st> `<st c="28570">NavigationSplitView</st>` <st
    c="28589">with two parts – the sidebar (the first block) and the detail.</st>
    <st c="28653">The sidebar shows a list of albums.</st> <st c="28689">Tapping on
    an album updates the</st> `<st c="28721">selectedAlbum</st>` <st c="28734">state
    variable.</st> <st c="28751">The</st> `<st c="28755">detail</st>` <st c="28761">block
    presents a list of songs about the</st> <st c="28803">selected album.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28554">我们的代码显示了</st> `<st c="28570">NavigationSplitView</st>` <st c="28589">的两个部分——侧边栏（第一个块）和详情。</st>
    <st c="28653">侧边栏显示了一个专辑列表。</st> <st c="28689">点击一个专辑会更新</st> `<st c="28721">selectedAlbum</st>`
    <st c="28734">状态变量。</st> <st c="28751">详情</st> <st c="28755">块展示了关于</st> `<st
    c="28761">selected album</st>` <st c="28803">所选专辑的歌曲列表。</st>
- en: <st c="28818">Let’s see how it looks on an iPad within landscape orientation
    (</st>*<st c="28883">Figure 4</st>**<st c="28892">.2</st>*<st c="28894">):</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28818">让我们看看在横向排列的iPad上它看起来如何（</st>*<st c="28883">图4</st>**<st c="28892">.2</st>*<st
    c="28894">）：</st>
- en: '![Figure 4.2: Two columns in SplitView on iPad – landscape](img/B21795_04_2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2: iPad上分割视图的两个列 – 横向](img/B21795_04_2.jpg)'
- en: '<st c="28967">Figure 4.2: Two columns in SplitView on iPad – landscape</st>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="28967">图4.2: iPad上分割视图的两个列 – 横向</st>'
- en: <st c="29023">Here is how it appears in</st> <st c="29049">portrait orientation
    (</st>*<st c="29072">Figure 4</st>**<st c="29081">.3</st>*<st c="29083">):</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29023">这是它在</st> <st c="29049">竖直排列</st> <st c="29083">中的外观（</st>*<st
    c="29072">图4</st>**<st c="29081">.3</st>*<st c="29083">）：</st>
- en: '![Figure 4.3: Two columns in SplitView in portrait orientation](img/B21795_04_3.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3: 分割视图中竖直排列的两个列](img/B21795_04_3.jpg)'
- en: '<st c="29088">Figure 4.3: Two columns in SplitView in portrait orientation</st>'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="29088">图4.3: 分割视图中竖直排列的两个列</st>'
- en: '*<st c="29148">Figures 4.2</st>* <st c="29160">and</st> *<st c="29165">4.3</st>*
    <st c="29168">show how our code runs on an iPad in portrait and landscape orientations.</st>
    <st c="29243">In portrait</st> <st c="29254">orientation, the sidebar view shows
    up in a drawer, and in landscape orientation, the screen is split, and both views</st>
    <st c="29373">are visible.</st>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="29148">图4.2</st>* <st c="29160">和 *<st c="29165">图4.3</st>* <st c="29168">展示了我们的代码在iPad的竖直和横向排列中的运行情况。</st>
    <st c="29243">在竖直排列中，侧边栏视图出现在抽屉中，而在横向排列中，屏幕被分割，两个视图</st> <st c="29373">都是可见的。</st>'
- en: <st c="29385">But what happens on an iPhone?</st> <st c="29417">Do we need to
    create a dedicated view for smaller devices?</st> <st c="29476">Let’s see what
    happens with the same code on an iPhone (</st>*<st c="29532">Figure 4</st>**<st
    c="29541">.4</st>*<st c="29543">):</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29385">但在iPhone上会发生什么？</st> <st c="29417">我们需要为较小的设备创建一个专用视图吗？</st> <st
    c="29476">让我们看看相同的代码在iPhone上会发生什么（</st>*<st c="29532">图4</st>**<st c="29541">.4</st>*<st
    c="29543">）：</st>
- en: '![Figure 4.4: NavigationSplitView on an iPhone](img/B21795_04_4.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4: iPhone上的NavigationSplitView](img/B21795_04_4.jpg)'
- en: '<st c="29598">Figure 4.4: NavigationSplitView on an iPhone</st>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="29598">图4.4: iPhone上的NavigationSplitView</st>'
- en: '*<st c="29642">Figure 4</st>**<st c="29651">.4</st>* <st c="29653">shows that
    the same</st> `<st c="29674">NavigationSplitView</st>` <st c="29693">just works
    when running on an iPhone.</st> <st c="29732">On small devices, the</st> `<st
    c="29754">NavigationSplitView</st>` <st c="29773">constructs a one-page navigation
    mechanism, similar</st> <st c="29825">to what is seen in</st> `<st c="29845">NavigationStack</st>`
    <st c="29860">or even in</st> <st c="29872">UIKit’s</st> `<st c="29880">UINavigationController</st>`<st
    c="29902">.</st>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="29642">图4</st>**<st c="29651">.4</st>* <st c="29653">显示，相同的</st> `<st
    c="29674">NavigationSplitView</st>` <st c="29693">仅在iPhone上运行时有效。</st> <st c="29732">在小设备上，</st>
    `<st c="29754">NavigationSplitView</st>` <st c="29773">构建了一个单页导航机制，类似于在</st> `<st
    c="29825">NavigationStack</st>` <st c="29860">或甚至在</st> `<st c="29872">UIKit的</st>
    `<st c="29880">UINavigationController</st>`<st c="29902">》中看到的。</st>'
- en: <st c="29903">Now, let’s make things a little bit more complex and add a</st>
    <st c="29963">third column.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29903">现在，让我们使事情变得稍微复杂一些，并添加一个</st> <st c="29963">第三列。</st>
- en: <st c="29976">Moving to three columns</st>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="29976">移动到三列</st>
- en: <st c="30000">In many apps, the data</st> <st c="30024">hierarchy is based on
    two levels.</st> <st c="30058">In our example, it is albums and songs, but in
    other cases, we can find groups and users, teams and players, or projects and
    tasks.</st> <st c="30190">Based on that, we will have to work with a three-level</st>
    <st c="30245">navigation system:</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30000">在许多应用中，数据</st> <st c="30024">层次结构基于两个级别。</st> <st c="30058">在我们的例子中，它是专辑和歌曲，但在其他情况下，我们可以找到组和用户，团队和玩家，或项目和工作。</st>
    <st c="30190">基于这一点，我们将不得不与一个三级的</st> <st c="30245">导航系统</st> <st c="30245">一起工作：</st>
- en: '<st c="30263">Level 1: List of the first</st> <st c="30291">level items</st>'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="30263">第一级：第一级项目的列表</st> <st c="30291"></st>
- en: '<st c="30302">Level 2: Based on the first-level selection, the list of</st>
    <st c="30360">second-level items</st>'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="30302">第二级：基于第一级选择，第二级项目的列表</st> <st c="30360"></st>
- en: '<st c="30378">Level 3: Details of the selected</st> <st c="30412">second-level
    item</st>'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="30378">第三级：所选第二级项目的详细信息</st> <st c="30412"></st>
- en: <st c="30429">Even though we can present the details of the selected first-level
    item in a modal screen, we can consider showing it in a third column on an</st>
    <st c="30572">iPad screen.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30429">尽管我们可以在模态屏幕中呈现所选第一级项目的详细信息，但我们可以在iPad屏幕的第三列中考虑显示它。</st>
- en: <st c="30584">In the</st> *<st c="30592">Creating a NavigationSplitView</st>*
    <st c="30622">section, we said that the</st> `<st c="30649">Detail</st>` <st c="30655">column
    shows information about the last selected item.</st> <st c="30711">This means
    that if we want to add another column, it will be between the</st> `<st c="30784">Detail</st>`
    <st c="30790">column and the</st> `<st c="30806">Sidebar</st>` <st c="30813">column
    – this is the</st> `<st c="30835">Content</st>` <st c="30842">column.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30584">在</st> *<st c="30592">创建NavigationSplitView</st>* <st c="30622">部分中，我们说</st>
    `<st c="30649">Detail</st>` <st c="30655">列显示最后一个选中项的信息。</st> <st c="30711">这意味着，如果我们想添加另一个列，它将位于</st>
    `<st c="30784">Detail</st>` <st c="30790">列和</st> `<st c="30806">Sidebar</st>`
    <st c="30813">列之间——这就是</st> `<st c="30835">Content</st>` <st c="30842">列。</st>
- en: <st c="30850">So, let’s add a</st> `<st c="30867">Content</st>` <st c="30874">column
    to</st> <st c="30884">our</st> <st c="30889">music app:</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30850">因此，让我们在我们的音乐应用中添加一个</st> `<st c="30867">Content</st>` <st c="30874">列：</st>
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="31493">In the preceding code example, we put the list of songs in our
    new</st> `<st c="31561">Content</st>` <st c="31568">block and the song details
    in the</st> `<st c="31603">Detail</st>` <st c="31609">column.</st> <st c="31618">We
    also used the same technique of</st> `<st c="31653">selectedSong</st>` <st c="31665">state
    variable and updated our</st> <st c="31697">UI accordingly.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31493">在前面的代码示例中，我们将歌曲列表放在我们新的</st> `<st c="31561">Content</st>` <st
    c="31568">块中，并将歌曲详情放在</st> `<st c="31603">Detail</st>` <st c="31609">列中。</st>
    <st c="31618">我们还使用了相同的</st> `<st c="31653">selectedSong</st>` <st c="31665">状态变量，并相应地更新了我们的</st>
    <st c="31697">UI</st>。！</st>
- en: <st c="31712">Let’s see how it looks</st> <st c="31735">now on an iPad (</st>*<st
    c="31752">Figure 4</st>**<st c="31761">.5</st>*<st c="31763">):</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31712">让我们看看现在在iPad上看起来怎么样</st> <st c="31735">（</st>*<st c="31752">图4</st>**<st
    c="31761">.5</st>*<st c="31763">）：</st>
- en: '![Figure 4.5: Three-columns NavigationSplitView on an iPad](img/B21795_04_5.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：iPad上的三列NavigationSplitView](img/B21795_04_5.jpg)'
- en: '<st c="31849">Figure 4.5: Three-columns NavigationSplitView on an iPad</st>'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31849">图4.5：iPad上的三列NavigationSplitView</st>
- en: '*<st c="31905">Figure 4</st>**<st c="31914">.5</st>* <st c="31916">shows a</st>
    <st c="31925">three-column</st> `<st c="31938">NavigationSplitView</st>` <st c="31957">on
    an iPad, now with the</st> `<st c="31983">Content</st>` <st c="31990">column</st>
    <st c="31998">showing the list of albums in</st> <st c="32028">the middle.</st>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="31905">图4</st>**<st c="31914">.5</st>* <st c="31916">显示了iPad上的一个</st>
    <st c="31925">三列</st> `<st c="31938">NavigationSplitView</st>` <st c="31957">，现在中间显示的是专辑列表。</st>'
- en: <st c="32039">Summary</st>
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32039">总结</st>
- en: <st c="32047">This chapter touches on a crucial topic in mobile development.</st>
    <st c="32111">Navigation has always been an issue, also in UIKit.</st> <st c="32163">However,
    we can achieve an effective navigation mechanism with thoughtful planning based
    on the product requirements and a balanced approach to flexibility</st> <st c="32319">and
    simplicity.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32047">本章涉及移动开发中的一个关键主题。</st> <st c="32111">导航始终是一个问题，在UIKit中也是如此。</st>
    <st c="32163">然而，我们可以通过基于产品需求和平衡灵活性与简洁性的方法进行周密规划，实现有效的导航机制。</st>
- en: <st c="32334">In this chapter, we went over the reasons why SwiftUI is a challenge,
    explored</st> `<st c="32414">NavigationStack</st>`<st c="32429">, reviewed the
    Coordinator pattern,</st> <st c="32465">and even discussed a column-based navigation</st>
    <st c="32510">with</st> `<st c="32515">NavigationSplitView</st>`<st c="32534">.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32334">在本章中，我们讨论了为什么SwiftUI是一个挑战，探讨了</st> `<st c="32414">NavigationStack</st>`<st
    c="32429">，回顾了协调器模式，</st> <st c="32465">甚至讨论了基于列的导航</st> <st c="32510">，使用了</st>
    `<st c="32515">NavigationSplitView</st>`<st c="32534">。！</st>
- en: <st c="32535">By now, we are more than capable of creating an amazing navigation
    in</st> <st c="32606">our app!</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32535">到目前为止，我们完全有能力在我们的应用中创建一个令人惊叹的导航！</st> <st c="32606">！</st>
- en: '<st c="32614">Our next chapter discusses something completely different but
    exciting: how to break our app’s borders and add features outside our sandbox</st>
    <st c="32755">with WidgetKit.</st>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32614">我们下一章将讨论一个完全不同但令人兴奋的话题：如何使用WidgetKit突破我们应用的边界，并在我们的沙盒之外添加功能</st>
    <st c="32755">。！</st>
