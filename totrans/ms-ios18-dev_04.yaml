- en: <st c="0">4</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Advanced Navigation with SwiftUI</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="34">In</st> [*<st c="38">Chapter 2</st>*](B21795_02.xhtml#_idTextAnchor043)<st
    c="47">, we discussed working with</st> <st c="74">the</st> **<st c="79">Observation</st>**
    <st c="90">framework.</st> <st c="102">The Observation framework helps to manage
    communication between different parts of our app and is one of the fundamental
    building blocks of SwiftUI declarative programming.</st> <st c="275">However,
    it is also one of the tools we will use to implement a good</st> <st c="344">navigation
    system.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <st c="362">Why do we have a whole chapter about navigation?</st> <st c="412">Isn’t
    it just showing a different view when the user selects an item in</st> <st c="484">a
    list?</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <st c="491">Navigation is a massive topic in mobile development.</st> <st c="545">A
    standard app may have dozens of screens, and a more extensive one may have hundreds.</st>
    <st c="632">Understanding how to manage the different routes in our app, which
    has so many screens, is crucial to our</st> <st c="738">app’s success.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <st c="752">In this chapter, we will be doing</st> <st c="787">the following:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <st c="801">Understating why SwiftUI navigation is</st> <st c="841">a challenge</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="852">Exploring</st> <st c="863">SwiftUI’s</st> `<st c="873">NavigationStack</st>`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="888">Working with different data models to</st> <st c="927">trigger navigation</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="945">Working with the Coordinator pattern to manage our</st> <st c="997">concerns
    better</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1012">Implementing SwiftUI’s</st> `<st c="1036">NavigationSplitView</st>`
    <st c="1055">to create a</st> <st c="1068">column-based navigation</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1091">We’ve got a lot to cover!</st> <st c="1118">But before we begin,
    let’s try to understand why SwiftUI navigation can be</st> <st c="1193">a challenge.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1205">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1228">For this chapter, you’ll need to download Xcode version 16.0 or
    above from Apple’s</st> <st c="1312">App Store.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1322">You’ll also need to be running the latest version of macOS (Ventura
    or above).</st> <st c="1402">Simply search for Xcode in the App Store and select
    and download the latest version.</st> <st c="1487">Launch Xcode and follow any
    additional installation instructions that your system may prompt you with.</st>
    <st c="1590">Once Xcode has fully launched, you’re ready</st> <st c="1634">to
    go.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1640">Download the sample code from the following GitHub</st> <st c="1692">link:</st>
    [<st c="1698">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204)<st
    c="1783">.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1784">Understating why SwiftUI navigation is a challenge</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1835">To answer that</st> <st c="1850">question, we need to understand
    how navigation works intuitively</st><st c="1915">. The user taps on a button,
    link, or some other event that may occur.</st> <st c="1986">Then, the app responds
    to that event and transitions the view to</st> <st c="2051">another screen.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答那个问题，我们需要理解导航是如何直观工作的。用户点击按钮、链接或其他可能发生的事件。然后，应用响应该事件并将视图过渡到另一个屏幕。
- en: <st c="2066">In a sense, we understand this sounds like an event-driven paradigm.</st>
    <st c="2136">When we discuss the differences between SwiftUI and UIKit, we actually
    discuss the differences between declarative and</st> <st c="2255">imperative programming</st><st
    c="2277">.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们理解这听起来像是一个事件驱动范式。当我们讨论SwiftUI和UIKit之间的区别时，我们实际上是在讨论声明式编程和`<st c="2255">imperative
    programming</st>`之间的区别。
- en: <st c="2278">Imperative UI, such as UIKit, is also event-driven, while declarative
    UI, such as SwiftUI, represents the current state.</st> <st c="2400">As a result,
    we can understand why navigation can be seen as simpler in UIKit and may feel
    more</st> <st c="2496">natural there.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式UI，如UIKit，也是事件驱动的，而声明式UI，如SwiftUI，则表示当前状态。因此，我们可以理解为什么在UIKit中导航看起来更简单，并且可能感觉更自然。
- en: <st c="2510">Many developers struggle with SwiftUI navigation.</st> <st c="2561">They
    wrap a SwiftUI view inside</st> `<st c="2593">UIHostingController</st>` <st c="2612">and
    use the UIKit navigation system.</st> <st c="2650">That’s a fair solution for
    achieving some advanced navigation techniques that are hard to do in SwiftUI.</st>
    <st c="2755">However, we need to remember that SwiftUI has evolved over the years
    and offers great</st> <st c="2841">navigation tools.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都在SwiftUI导航上挣扎。他们在一个`<st c="2593">UIHostingController</st>`中包裹一个SwiftUI视图，并使用UIKit导航系统。这是一个合理的解决方案，用于实现一些在SwiftUI中难以完成的复杂导航技术。然而，我们需要记住，SwiftUI已经发展多年，提供了优秀的导航工具。
- en: <st c="2858">Let’s start with the basic navigation tool –</st> `<st c="2904">NavigationStack</st>`<st
    c="2919">.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的导航工具`<st c="2904">NavigationStack</st>`开始。
- en: <st c="2920">Exploring NavigationStack</st>
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索`<st c="2904">NavigationStack</st>`
- en: <st c="2946">When SwiftUI was</st> <st c="2963">introduced, the basic navigation
    mechanism was based on a view called</st> `<st c="3034">NavigationView</st>`<st
    c="3048">. However,</st> `<st c="3059">NavigationView</st>` <st c="3073">was too
    simple for most apps, and</st> `<st c="3108">NavigationStack</st>` <st c="3123">replaced
    it.</st> <st c="3137">In fact, Apple deprecated</st> `<st c="3163">NavigationView</st>`<st
    c="3177">, starting with</st> <st c="3193">iOS 18.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当SwiftUI被引入时，基本的导航机制是基于一个名为`<st c="3034">NavigationView</st>`的视图。然而，`<st c="3059">NavigationView</st>`对于大多数应用来说过于简单，因此`<st
    c="3108">NavigationStack</st>`取代了它。实际上，苹果从iOS 18开始弃用了`<st c="3163">NavigationView</st>`。
- en: <st c="3200">Compared to</st> `<st c="3213">NavigationView</st>`<st c="3227">,</st>
    `<st c="3229">NavigationStack</st>` <st c="3244">adds a little bit of complexity
    to the pile, which provides us with</st> <st c="3313">new capabilitie</st><st
    c="3328">s.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与`<st c="3213">NavigationView</st>`相比，`<st c="3229">NavigationStack</st>`给这个堆栈增加了一点点复杂性，这为我们提供了新的功能。
- en: <st c="3331">Let’s see a simple example of a</st> `<st c="3364">NavigationStack</st>`
    <st c="3379">usage:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`<st c="3364">NavigationStack</st>`的一个简单用法示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3536">This code example</st> <st c="3554">looks</st> <st c="3561">pretty
    simple!</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例看起来非常简单！
- en: <st c="3575">However,</st> `<st c="3585">NavigationStack</st>` <st c="3600">is
    much more powerful than</st> <st c="3628">it seems.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`<st c="3585">NavigationStack</st>`比它看起来要强大得多。
- en: <st c="3637">How?</st> <st c="3643">The concept of</st> `<st c="3658">NavigationStack</st>`
    <st c="3673">is constructed from</st> <st c="3694">four components:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样？`<st c="3658">NavigationStack</st>`的概念是由四个组件构成的：
- en: '`<st c="3786">NavigationView</st>`<st c="3800">. In</st> `<st c="3805">NavigationStack</st>`<st
    c="3820">,</st> `<st c="3822">NavigationLink</st>` <st c="3836">describes what
    happened, and the</st> `<st c="3870">navigationDestination</st>` <st c="3891">view
    modifier describes where</st> <st c="3922">we go.</st>'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="3928">Linking between data and destinations</st>**<st c="3966">: In
    a way, this is a development of the preceding point.</st> <st c="4025">The destination
    is linked to a data type.</st> <st c="4067">This means that we can have several
    navigation links that point to the same destination just because they share the
    same</st> <st c="4188">data type.</st>'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="4198">Allowing us to read and update the path</st>**<st c="4238">:
    Here, we have another development of our idea.</st> <st c="4288">Because the data
    and the screen are now linked, we can represent the path as an array of data instances.</st>
    <st c="4393">Modifying the path array also changes our</st> <st c="4435">views
    stack.</st>'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="4509">NavigationLink</st>` <st c="4523">also had this capability, but
    the introduction of</st> `<st c="4574">NavigationStack</st>` <st c="4589">made</st>
    <st c="4595">it obsolete.</st>'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="4607">Let’s cover each of these four components in detail now, and we’ll
    start</st> <st c="4681">with destinations.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4699">Separating the navigation destination using the navigationDestination
    view modifier</st>
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4783">If you’ve read my</st> <st c="4802">previous</st> <st c="4811">books
    (</st>*<st c="4818">Pro iOS Testing</st>* <st c="4834">and</st> *<st c="4839">Mastering
    Swift Package Manager</st>* <st c="4870">by</st> *<st c="4874">Apress</st>*<st
    c="4880">, and</st> *<st c="4886">The Ultimate iOS Interview Playbook</st>* <st
    c="4921">by</st> *<st c="4925">Packt Publishing</st>*<st c="4941">) there’s an
    important principle I keep nagging about:</st> **<st c="4997">separation of concerns</st>**
    <st c="5019">(</st>**<st c="5021">SoC</st>**<st c="5024">).</st> <st c="5028">In
    SoC, we break our code into distinct modules or</st> <st c="5079">components,
    each with a specific and well-defined responsibility.</st> <st c="5145">This makes
    our code more modular, flexible, and easy</st> <st c="5198">to maintain.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5210">When we look back at</st> `<st c="5232">NavigationLink</st>`<st
    c="5246">, we can see that it has more than one responsibility – it is the actual
    control that the user taps on and also contains the next</st> <st c="5376">screen
    view.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5388">In</st> `<st c="5392">NavigationStack</st>`<st c="5407">, there’s
    a new view modifier called</st> `<st c="5444">navigationDestination</st>`<st c="5465">,
    which allows us to define a destination separately according to a</st> <st c="5533">state
    change.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5546">Let’s see an example of</st> `<st c="5571">navigationDestination</st>`<st
    c="5592">, based on a</st> <st c="5605">binding variable:</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="5889">In our code example, we can see a</st> `<st c="5924">NavigationStack</st>`
    <st c="5939">view containing a button.</st> <st c="5966">Notice that there’s no</st>
    `<st c="5989">NavigationLink</st>` <st c="6003">view at all, and that’s because
    we don’t need it.</st> <st c="6054">We trigger the navigation by changing the</st>
    `<st c="6096">@State</st>` <st c="6102">property named</st> `<st c="6118">isNextScreenDisplayed</st>`
    <st c="6139">rather than using a</st> `<st c="6160">NavigationLink</st>` <st c="6174">view.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6180">The button also has a view modifier called</st> `<st c="6224">navigationDestination</st>`<st
    c="6245">. The</st> `<st c="6251">navigationDestination</st>` <st c="6272">view
    modifier has a binding Boolean variable that is linked to the</st> `<st c="6340">isNextScreenDisplayed</st>`
    <st c="6361">state variable.</st> <st c="6378">It also has a view builder that
    contains our next screen (similar</st> <st c="6444">to</st> `<st c="6447">NavigationLink</st>`<st
    c="6461">).</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6464">Tapping on the button toggles</st> `<st c="6495">isNextScreenDisplayed</st>`
    <st c="6516">and navigates our</st> <st c="6535">next screen.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6547">This capability of</st> <st c="6567">triggering</st> <st c="6578">navigation
    using</st> `<st c="6595">NavigationLink</st>` <st c="6609">was available in earlier
    versions of SwiftUI, but it is deprecated now.</st> <st c="6682">But don’t worry
    – decoupling the destination from the actual control makes our code much more
    flexible and provides us with</st> <st c="6806">more opportunities.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6825">For example, imagine we’re doing an asynchrony operation such as
    a network request or image processing, and we want to move to the next screen
    – that can be done easily by toggling a</st> <st c="7009">Boolean variable.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7026">Another important aspect of having a separate destination is that
    we can trigger the same navigation from different places.</st> <st c="7151">We
    can toggle the Boo</st><st c="7172">lean from an asynchronous operation and a
    button as well.</st> <st c="7231">Responding to a state follows a declarative
    approach rather than the</st> `<st c="7300">NavigationView</st>` <st c="7314">approach,
    which was responding to a</st> <st c="7351">button tap.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7362">Toggling a Boolean variable is great when navigating to a new screen
    unrelated to any data.</st> <st c="7455">For example, moving to the settings from
    our main screen is a classic example of using a</st> <st c="7544">Boolean binding.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7560">But I</st> <st c="7567">promised</st> <st c="7576">that</st> `<st
    c="7581">NavigationStack</st>` <st c="7596">has more than that,</st> <st c="7617">didn’t
    I?</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7626">So, let’s see how we can bind our navigation destinations to</st>
    <st c="7688">data models.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7700">Using data models to trigger navigation</st>
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7740">Developers who</st> <st c="7756">are used to</st> <st c="7768">UIKit
    navigation may find the idea of using data models weird.</st> <st c="7831">After
    all, toggling a Boolean for navigation is quite similar to imperative programming,
    but how does a data model have anything to do</st> <st c="7966">with navigation?</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7982">We understand that many screens are related to a specific data
    model.</st> <st c="8053">For example, tapping on a movie leads us to a single
    movie screen if we have a list of movies.</st> <st c="8148">Another example is
    a trips app, where tapping on a specific trip leads us to a screen dedicated to</st>
    <st c="8247">that trip.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8257">If we think even deeper than that, we can represent many screens
    in our app using a data model.</st> <st c="8354">We can distinguish between screens
    using a data model containing</st> <st c="8419">an enum.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8427">Before we set sail with our thoughts, exploring potential possibilities
    and implementations, let’s see what basic data-based navigation</st> <st c="8564">looks
    like:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="8859">As always, I have highlighted the interesting parts in the preceding
    code.</st> <st c="8935">We have a SwiftUI view that displays a list of countries
    (based on a</st> <st c="9004">constant variable).</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9023">Each row has a</st> `<st c="9039">NavigationLink</st>` <st c="9053">view
    that displays the country name, but it doesn’t have its own destination this time.</st>
    <st c="9142">Instead, it uses the country as the link’s</st> <st c="9185">value
    parameter.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9201">We can understand what sending the country as a value means only
    when we look down at the navigation destination.</st> <st c="9316">In the code
    example in the</st> *<st c="9343">Separating the navigation destination using
    the navigationDestination view modifier</st>* <st c="9426">section, the navigation
    destination was linked to a Boolean state variable.</st> <st c="9503">In this
    case, the navigation destination performs</st> <st c="9552">only when</st> <st
    c="9562">there’s a link with a specific data type – in this case, a string type
    (just like a</st> <st c="9647">country value).</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9662">In other words, tapping on a country sends its value to the navigation
    stack using</st> `<st c="9746">NavigationLink</st>`<st c="9760">. The navigation
    destination catches that and defines what will be our</st> <st c="9831">next screen.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9843">We can use the data models to navigate to different places by defining
    multiple navigation destinations, each responding to a different data</st> <st
    c="9985">model type.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9996">Here’s another example of using a navigation destination to add
    a navigation to a</st> <st c="10079">profile screen:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="10755">In the preceding code, we see another navigation destination for
    a data model from the type of</st> `<st c="10851">Profile</st>`<st c="10858">.
    To navigate the profile screen, we added another</st> `<st c="10909">NavigationLink</st>`
    <st c="10923">view in the screen toolbar and sent the profile</st> <st c="10972">data
    model.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10983">Our navigation system is dynamic because we can work with different
    data models.</st> <st c="11065">But that doesn’t stop</st> <st c="11087">here.</st>
    `<st c="11093">NavigationStack</st>` <st c="11108">can</st> <st c="11112">also
    reveal and even modify the current view’s stack.</st> <st c="11167">We do that
    using the path</st> <st c="11193">binding variable.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11210">Responding to the path variable</st>
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11242">Separating the</st> <st c="11258">destination</st> <st c="11269">from
    its navigation link is great, but</st> `<st c="11309">NavigationStack</st>`<st
    c="11324">’s ability to observe and update its stack of views is</st> <st c="11380">very
    powerful.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11394">As mentioned, a</st> `<st c="11411">NavigationStack</st>` <st
    c="11426">view has a binding variable called</st> `<st c="11462">path</st>`<st
    c="11466">, and the</st> `<st c="11476">path</st>` <st c="11480">variable can
    contain the list of views by their</st> <st c="11529">data models.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11541">It is easy to demonstrate that using a</st> <st c="11581">linked
    list:</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="12045">I chose to demonstrate</st> <st c="12069">working</st> <st c="12076">with</st>
    `<st c="12082">path</st>` <st c="12086">using a linked list since it’s a great
    data structure that is similar to a navigation stack (linked items from the</st>
    <st c="12202">same type).</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12213">If we observe the</st> `<st c="12232">path</st>` <st c="12236">variable
    during navigation, we can see it contains a collection of the list nodes currently
    active</st> <st c="12336">as views.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12345">What’s great about the fact that the</st> `<st c="12383">path</st>`
    <st c="12387">variable is bound to the</st> `<st c="12413">NavigationStack</st>`
    <st c="12428">is that we can manipulate and</st> <st c="12459">modify it:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="12494">Appending a new list node to</st> `<st c="12524">path</st>` <st
    c="12528">triggers the navigation and directs the user to a</st> <st c="12579">new
    screen.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12590">We can also create a whole stack using the</st> `<st c="12634">path</st>`
    <st c="12638">variable:</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="12682">Setting a new array of nodes creates a new stack of corresponding
    views.</st> <st c="12756">This is a great way to implement a deep link or direct
    the user to a specific location within</st> <st c="12850">the app.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12858">You are probably scratching your head right now and thinking,
    how can we implement it inside an app?</st> <st c="12960">What are the use cases
    where we navigate a few levels down the hierarchy with the same data</st> <st
    c="13052">model type?</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13063">So, a data model type doesn’t have to be</st> `<st c="13105">Task</st>`<st
    c="13109">,</st> `<st c="13111">Album</st>`<st c="13116">, or</st> `<st c="13121">Contact</st>`<st
    c="13128">. A data model can also describe a screen or a feature.</st> <st c="13184">In
    this way, data collection can describe a navigation path inside</st> <st c="13251">an
    app.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13258">Here’s an example</st> <st c="13276">of a data type that</st>
    <st c="13296">can describe a screen, followed by a</st> <st c="13334">navigation
    path:</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="13465">The Enum</st> `<st c="13475">Screen</st>` <st c="13481">describes
    the type of screen we want to navigate to, and it’s an easy way to build</st>
    <st c="13565">a stack:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="13605">That short line of code builds a stack of views when the first
    view is the main screen followed by a</st> <st c="13707">settings screen.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13723">Using an Enum to display different kinds of screens is great.</st>
    <st c="13786">However, working with different types of data is less convenient
    with Enum.</st> <st c="13862">To solve that issue, we have a more complex solution</st>
    <st c="13914">than</st> <st c="13919">a collection of instances, and it’s</st>
    <st c="13956">called</st> `<st c="13963">NavigationPath</st>`<st c="13977">.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13978">Working with different types of data using NavigationPath</st>
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`<st c="14036">NavigationPath</st>` <st c="14051">was</st> <st c="14055">introduced
    along with</st> `<st c="14078">NavigationStack</st>`<st c="14093">, and it allows
    us to have more control of our navigation flows.</st> <st c="14158">In fact,</st>
    `<st c="14167">NavigationPath</st>` <st c="14181">makes navigation with SwiftUI
    a mix of declarative and imperative programming and is much more similar to the
    UIKit</st> <st c="14298">navigation pattern.</st>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14317">Let’s say we have a music app with a list of songs and albums
    on its main screen.</st> <st c="14400">Tapping on a song leads to a</st> `<st
    c="14429">song</st>` <st c="14433">view while tapping on an album navigates to
    an</st> `<st c="14481">album</st>` <st c="14486">view.</st> <st c="14493">In the
    previous section, we managed that using an Enum, trying to map the Enum value
    to a screen view.</st> <st c="14596">With</st> `<st c="14601">NavigationPath</st>`<st
    c="14615">, we can append whatever value we want to the</st> `<st c="14661">path</st>`
    <st c="14665">variable as long as its type conforms</st> <st c="14704">to</st>
    `<st c="14707">Hashable</st>`<st c="14715">.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14716">Let’s have a look at the</st> <st c="14742">following code:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="15550">Note that the preceding code example is partial and does not include
    the</st> <st c="15623">child views.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15635">Our music app’s main screen contains four important parts that
    handle our</st> <st c="15710">navigation system:</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15728">We start with declaring a state variable that holds our</st> `<st
    c="15785">path</st>` <st c="15789">variable</st> <st c="15799">called</st> `<st
    c="15806">NavigationPath</st>`<st c="15820">:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="15875">As mentioned earlier, unlike the previous</st> `<st c="15918">path</st>`
    <st c="15922">variable we used, in the</st> `<st c="15948">NavigationPath</st>`
    <st c="15962">case, we don’t need to define its type.</st> <st c="16003">It can
    hold any type we want as long as it</st> <st c="16045">conforms</st> <st c="16055">to</st>
    `<st c="16058">Hashable</st>`<st c="16066">.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16067">Next, we will initiate</st> `<st c="16091">NavigationStack</st>`
    <st c="16106">with our new</st> `<st c="16120">NavigationPath</st>` <st c="16134">similar
    to what we did in the</st> <st c="16165">previous example:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="16223">Notice that we use a similar signature but with a different type
    –</st> `<st c="16291">Binding<NavigationPath></st>` <st c="16314">instead</st>
    <st c="16323">of</st> `<st c="16326">Binding<Data></st>`<st c="16339">.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16340">Now that we have</st> `<st c="16358">NavigationPath</st>`<st c="16372">,
    we can navigate to a</st> `<st c="16395">song</st>` <st c="16399">view or to an</st>
    `<st c="16414">album</st>` <st c="16419">view by appending the corresponding object
    to the</st> <st c="16470">navigation path:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="16514">Or, you can do it</st> <st c="16533">like so:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="16570">The appending operation triggers the</st> `<st c="16608">navigationDestination</st>`
    <st c="16629">view modifier, passing the song or the album that</st> <st c="16680">was
    selected:</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="16886">In this example, we have a different</st> `<st c="16924">navigationDestination</st>`
    <st c="16945">view modifier for each type</st> <st c="16974">we pass.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16982">The fact that we can append any entity we want makes</st> `<st
    c="17036">NavigationPath</st>` <st c="17050">an ideal component for a flexible</st>
    <st c="17085">navigation system.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17103">We can also use</st> `<st c="17120">NavigationPath</st>` <st c="17134">to
    perform a</st> `<st c="17148">Back</st>` <st c="17152">operation by removing the</st>
    <st c="17179">last component:</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="17241">In this example, we added a back button that removes the navigation
    path’s last components</st> <st c="17333">when tapped.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17345">Because we are still in</st> <st c="17370">a declarative world,
    any change we perform to the navigation stack by appending or removing components
    reflects the change in</st> <st c="17496">our UI.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17503">Working with the Coordinator pattern</st>
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="17540">The</st> `<st c="17545">NavigationPath</st>` <st c="17559">and</st>
    `<st c="17564">NavigationStack</st>` <st c="17579">combination is robust and provides
    flexibility in managing</st> <st c="17639">navigation.</st> <st c="17651">However,
    as our app scales, controlling how the user moves from screen to screen becomes</st>
    <st c="17740">more complex.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17753">For example, let’s say we have an onboarding flow and want a different
    set of screens for different user profiles.</st> <st c="17869">Or, we want to
    reuse the same screen within different flows.</st> <st c="17930">In each flow,
    the screen should continue to a</st> <st c="17976">different screen.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17993">In each case, it becomes difficult to understand our next view
    when we are within the screen context.</st> <st c="18096">In fact, this problem
    of managing our navigation is not related only to SwiftUI, and most developers
    know that</st> <st c="18207">from UIKit.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18218">To try and improve our navigation mechanism, we can use what’s
    called a</st> **<st c="18291">Coordinator pattern</st>** <st c="18310">– a pattern
    that</st> <st c="18327">delegates the navigation logic to a</st> <st c="18364">dedicated
    component.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18384">Let’s try to understand what</st> <st c="18414">it means.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18423">Understandi</st><st c="18435">ng the Coordinator’s principles</st>
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="18467">Before we write our</st> <st c="18488">first Coordinator together,
    let’s review some</st> <st c="18534">fundamental principles:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18557">The Coordinator is a component that holds the current navigation
    path and general context.</st> <st c="18649">It knows what screen is displayed
    and the general current flow.</st> <st c="18713">The Coordinator also adds a new
    view to the stack, pops, and shows modal or</st> <st c="18789">sheet views.</st>
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18801">A view doesn’t know the following view the user should navigate
    to.</st> <st c="18870">What it does know is only the action the user performed.</st>
    <st c="18927">In a way, the view is isolated from the navigation logic and is
    unaware of the</st> <st c="19006">general context.</st>
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19022">A coordinator represents a flow.</st> <st c="19056">We can have
    several flows in our app with</st> <st c="19098">several coordinators.</st>
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19119">As a result of these principles, we can understand that the Coordinator
    pattern is an improved way of separating our</st> <st c="19237">app concerns.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19250">Look at</st> *<st c="19259">Figure 4</st>**<st c="19267">.1</st>*<st
    c="19269">:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The Coordinator pattern](img/B21795_04_1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: '<st c="19391">Figure 4.1: The Coordinator pattern</st>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="19426">Figure 4</st>**<st c="19435">.1</st>* <st c="19437">shows a
    basic Coordinator pattern.</st> <st c="19473">We have an</st> *<st c="19484">Albums
    List</st>* <st c="19495">view, and when the user selects an album, the action
    is sent to the</st> *<st c="19564">Coordinator</st>*<st c="19575">. Then, the
    Coordinator decides to navigate to the</st> *<st c="19626">Album Detail</st>*
    <st c="19638">view by sending the action</st> <st c="19666">to</st> `<st c="19669">NavigationPath</st>`<st
    c="19683">.</st>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19684">In this pattern, the Albums List is unaware of what should happen
    next.</st> <st c="19757">For example, the Coordinator can decide that, in some
    cases, we should show the user an upsell screen.</st> <st c="19860">Or, if it’s
    part of onboarding, the Coordinator can determine that the Albums List is just
    a demonstration and that we should proceed to the next step in the</st> <st c="20018">onboarding
    flow.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20034">But how do we structure a Coordinator pattern?</st> <st c="20082">How
    does it work, especially in the</st> <st c="20118">SwiftUI world?</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20132">There are many ways to build a Coordinator in SwiftUI.</st> <st
    c="20188">The Coordinator pattern I describe here is just an</st> <st c="20239">example
    that demonstrates the basic principles, and we can take that example and adjust
    it to our</st> <st c="20337">project’s needs.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20353">We will start with the most fundamental component – the</st> <st
    c="20410">Coordinator itself.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20429">Building the Coordinator object</st>
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="20461">The Coordinator is</st> <st c="20480">the central object that
    defines the different user actions and navigation options.</st> <st c="20564">It
    also holds the navigation path so it can perform the</st> <st c="20620">navigation
    operations.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20642">We will start by defining a basic</st> <st c="20677">Coordinator
    class:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="20774">We created a Coordinator class that holds a</st> `<st c="20819">NavigationPath</st>`
    <st c="20833">object.</st> <st c="20842">The</st> `<st c="20846">NavigationPath</st>`
    <st c="20860">object is essential – it allows the Coordinator to add more items
    to the stack, perform pop operations, and understand the current stack.</st> <st
    c="20999">Notice that the Coordinator conforms to the</st> `<st c="21043">ObservableObject</st>`
    <st c="21059">protocol and that the path is a published object – that’s because
    we want the path to be part of</st> `<st c="21157">NavigationStack</st>` <st c="21172">when
    we</st> <st c="21181">use it.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21188">Next, we define the different user and</st> <st c="21228">page
    actions:</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="21414">In this example, we</st> <st c="21435">created</st> <st c="21443">two
    Enums:</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="21453">PageAction</st>`<st c="21464">: This Enum describes a navigation
    action our Coordinator needs to perform, such as navigating to an</st> `<st c="21566">album</st>`
    <st c="21571">view or a</st> <st c="21582">settings view.</st>'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="21596">UserAction</st>`<st c="21607">: This Enum describes an action
    the user performed, such as tapping on an album in the Albums List or tapping
    on the</st> <st c="21725">settings button.</st>'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="21741">Notice that some Enums contain associated values, such as the
    related</st> `<st c="21812">album</st>` <st c="21817">object.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21825">Now that we have our Enums, we will create two</st> <st c="21873">important
    functions:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="22324">The first is the</st> `<st c="22342">performAction()</st>` <st
    c="22357">function.</st> <st c="22368">This function receives</st> `<st c="22391">UserAction</st>`
    <st c="22401">as a parameter and appends</st> <st c="22429">the corresponding
    page action to</st> `<st c="22462">NavigationPath</st>`<st c="22476">. This function
    is the Coordinator’s “brain” – where we decide where to navigate when the user
    performs a</st> <st c="22582">particular action.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22600">In this example, when the user taps the album in the Albums List,
    we navigate to the</st> `<st c="22686">album</st>` <st c="22691">view, passing
    the</st> `<st c="22710">album</st>` <st c="22715">object.</st> <st c="22724">When
    the user taps the settings button, we navigate to the settings screen.</st> <st
    c="22800">This logic may sound evident and like over-engineering.</st> <st c="22856">Still,
    in a complex world, we have permissions, A/B tests, and other changes, and a centralized
    place that handles all of these can be</st> <st c="22991">extremely valuable.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23010">The second function maps a page action to</st> <st c="23053">a
    SwiftUI view.</st> <st c="23069">We will use that now when we</st> <st c="23098">build</st>
    `<st c="23104">CoordinatorView</st>`<st c="23119">.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23120">Adding CoordinatorView</st>
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="23143">The Coordinator</st> <st c="23159">class is robust and contains
    all of</st> <st c="23195">our navigation logic.</st> <st c="23218">However, we
    can’t use the Coordinator to perform the actual navigation.</st> <st c="23290">To
    do that, we must wrap our views with</st> `<st c="23330">CoordinatorView</st>`<st
    c="23345">, which knows how to work with</st> <st c="23376">our Coordinator.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23392">So, let’s see what</st> `<st c="23412">CoordinatorView</st>` <st
    c="23427">looks like:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`<st c="23772">CoordinatorView</st>` <st c="23788">is a simple SwiftUI view
    that has</st> <st c="23823">three components:</st>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="23840">coordinator</st>`<st c="23852">: In the</st> `<st c="23862">CoordinatorView</st>`<st
    c="23877">, we added an instance of our</st> `<st c="23907">Coordinator</st>`
    <st c="23918">class that we had just built.</st> <st c="23949">We made that coordinator
    an observable object so we can use its path to add and remove views from</st>
    <st c="24047">the stack.</st>'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="24057">NavigationStack</st>`<st c="24073">: This is the same</st> `<st
    c="24093">NavigationStack</st>` <st c="24108">we met in this chapter.</st> <st
    c="24133">As mentioned, we use the coordinator path as</st> `<st c="24178">NavigationStack</st>`<st
    c="24193">, but more importantly, two additional things – we initialize the stack
    with the root view (</st>`<st c="24285">AlbumListView</st>`<st c="24299">), and
    we use the Coordinator</st> `<st c="24330">buildView</st>` <st c="24339">function
    that maps the page action to view to add the corresponding view to</st> <st c="24416">the
    stack.</st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="24426">EnvironmentObject</st>`<st c="24444">: We add an</st> `<st c="24457">environmentObject</st>`
    <st c="24474">view modifier to declare an environment object in the coordinator.</st>
    <st c="24542">We do that to provide all the views under</st> `<st c="24584">NavigationStack</st>`
    <st c="24599">with access to the Coordinator so they can call the different</st>
    <st c="24662">user actions.</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="24675">These three components</st> <st c="24699">are responsible for
    connecting</st> <st c="24730">our views to the Coordinator logic we</st> <st c="24768">have
    built.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24779">Now, let’s see how</st> `<st c="24799">AlbumListView</st>` <st
    c="24812">works with</st> <st c="24824">the Coordinator.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24840">Calling the coordinator straight from the view</st>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="24887">Remember one of our</st> <st c="24908">coordinator principles
    – the view’s concern is only to say what</st> *<st c="24972">happened</st>*<st
    c="24980">, not what</st> *<st c="24991">will happen</st>* <st c="25002">next.</st>
    <st c="25009">What will happen is the</st> <st c="25033">Coordinator’s concern.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25055">Let’s have a look at how</st> `<st c="25081">AlbumListView</st>`
    <st c="25094">deals</st> <st c="25101">with it:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="25643">The</st> `<st c="25648">AlbumListView</st>` <st c="25661">struct</st>
    <st c="25668">contains a list of the user albums and a navigation bar with a</st>
    <st c="25732">settings button.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25748">Tapping on one of the albums calls the Coordinator’s</st> `<st
    c="25802">performedAction()</st>` <st c="25819">function, which returns the corresponding
    Enum and the</st> <st c="25875">selected album.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25890">In addition, tapping on the settings button calls the same</st>
    `<st c="25950">performedAction()</st>` <st c="25967">function with a different</st>
    <st c="25994">Enum value.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26005">Returning to the beginning of this section under the</st> *<st
    c="26059">Building the Coordinator object</st>* <st c="26090">part, we can now
    understand how everything</st> <st c="26134">is connected.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26147">We can also understand why the coordinator instance is an environment
    object – so we can call it straight from</st> <st c="26259">the view.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26268">Until now, we discussed</st> `<st c="26293">NavigationStack</st>`
    <st c="26308">and the Coordinator pattern.</st> <st c="26338">We might think that
    navigation is only about changing the current view.</st> <st c="26410">However,
    navigation on big screens, such as an iPad screen, often involves working with
    different columns.</st> <st c="26517">So, let’s meet</st> `<st c="26532">NavigationSplitView</st>`
    <st c="26551">to see</st> <st c="26559">how we nail that down (I told you that
    navigation is a complex topic,</st> <st c="26629">didn’t I?).</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26640">Navigating with columns with NavigationSplitView</st>
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="26689">One of the things that</st> <st c="26712">we know when building
    apps for padOS or macOS is that we need to take advantage of the big screen.</st>
    <st c="26812">But what does it mean?</st> <st c="26835">Sometimes, it might mean
    working with a grid instead of a list.</st> <st c="26899">However, in the context
    of navigation, it means that we can work with several columns when each of the
    columns shows a different view instead of replacing the whole screen each time
    the</st> <st c="27085">user navigates.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27100">In other words – we need to split</st> <st c="27135">the screen.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27146">To do that, we can work with a view called</st> `<st c="27190">NavigationSplitView</st>`<st
    c="27209">, which presents views in two or</st> <st c="27242">three columns.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27256">When a user selects an item of one view, it updates the view in
    the</st> <st c="27325">other columns.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27339">Creating NavigationSplitView</st>
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="27368">To demonstrate</st> <st c="27384">how to use</st> `<st c="27395">NavigationSplitView</st>`<st
    c="27414">, we will use our music app example and adjust it</st> <st c="27464">to
    padOS.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27473">Let’s start with some important terms – we have three different</st>
    <st c="27538">column types:</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="27551">Sidebar</st>`<st c="27559">: The first column from the left.</st>
    <st c="27594">That’s the main column where we start</st> <st c="27632">our navigation.</st>'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27647">Content</st>`<st c="27655">: When there are three columns, the</st>
    `<st c="27692">Content</st>` <st c="27699">column shows data related to the selected
    item in the</st> `<st c="27754">Sidebar</st>` <st c="27761">column.</st>'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27769">Detail</st>`<st c="27776">: The</st> `<st c="27783">Detail</st>`
    <st c="27789">column presents the selected item in the</st> `<st c="27831">Content</st>`
    <st c="27838">column or the</st> `<st c="27853">Sidebar</st>` <st c="27860">column.</st>
    <st c="27869">In general, it is the item that is last in the split</st> <st c="27922">view
    hierarchy.</st>'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27937">These three terms may initially sound slightly confusing, so let’s
    jump straight to the code to understand how they all fit together.</st> <st c="28072">Here’s
    an example of</st> `<st c="28093">NavigationSplitView</st>` <st c="28112">that
    shows a list of albums, and when tapping on an</st> <st c="28165">album, the app
    shows a list of</st> <st c="28196">its</st> <st c="28200">songs:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="28554">Our code shows</st> `<st c="28570">NavigationSplitView</st>` <st
    c="28589">with two parts – the sidebar (the first block) and the detail.</st>
    <st c="28653">The sidebar shows a list of albums.</st> <st c="28689">Tapping on
    an album updates the</st> `<st c="28721">selectedAlbum</st>` <st c="28734">state
    variable.</st> <st c="28751">The</st> `<st c="28755">detail</st>` <st c="28761">block
    presents a list of songs about the</st> <st c="28803">selected album.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28818">Let’s see how it looks on an iPad within landscape orientation
    (</st>*<st c="28883">Figure 4</st>**<st c="28892">.2</st>*<st c="28894">):</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Two columns in SplitView on iPad – landscape](img/B21795_04_2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '<st c="28967">Figure 4.2: Two columns in SplitView on iPad – landscape</st>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29023">Here is how it appears in</st> <st c="29049">portrait orientation
    (</st>*<st c="29072">Figure 4</st>**<st c="29081">.3</st>*<st c="29083">):</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Two columns in SplitView in portrait orientation](img/B21795_04_3.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: '<st c="29088">Figure 4.3: Two columns in SplitView in portrait orientation</st>'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="29148">Figures 4.2</st>* <st c="29160">and</st> *<st c="29165">4.3</st>*
    <st c="29168">show how our code runs on an iPad in portrait and landscape orientations.</st>
    <st c="29243">In portrait</st> <st c="29254">orientation, the sidebar view shows
    up in a drawer, and in landscape orientation, the screen is split, and both views</st>
    <st c="29373">are visible.</st>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29385">But what happens on an iPhone?</st> <st c="29417">Do we need to
    create a dedicated view for smaller devices?</st> <st c="29476">Let’s see what
    happens with the same code on an iPhone (</st>*<st c="29532">Figure 4</st>**<st
    c="29541">.4</st>*<st c="29543">):</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: NavigationSplitView on an iPhone](img/B21795_04_4.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: '<st c="29598">Figure 4.4: NavigationSplitView on an iPhone</st>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="29642">Figure 4</st>**<st c="29651">.4</st>* <st c="29653">shows that
    the same</st> `<st c="29674">NavigationSplitView</st>` <st c="29693">just works
    when running on an iPhone.</st> <st c="29732">On small devices, the</st> `<st
    c="29754">NavigationSplitView</st>` <st c="29773">constructs a one-page navigation
    mechanism, similar</st> <st c="29825">to what is seen in</st> `<st c="29845">NavigationStack</st>`
    <st c="29860">or even in</st> <st c="29872">UIKit’s</st> `<st c="29880">UINavigationController</st>`<st
    c="29902">.</st>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29903">Now, let’s make things a little bit more complex and add a</st>
    <st c="29963">third column.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29976">Moving to three columns</st>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="30000">In many apps, the data</st> <st c="30024">hierarchy is based on
    two levels.</st> <st c="30058">In our example, it is albums and songs, but in
    other cases, we can find groups and users, teams and players, or projects and
    tasks.</st> <st c="30190">Based on that, we will have to work with a three-level</st>
    <st c="30245">navigation system:</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="30263">Level 1: List of the first</st> <st c="30291">level items</st>'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="30302">Level 2: Based on the first-level selection, the list of</st>
    <st c="30360">second-level items</st>'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="30378">Level 3: Details of the selected</st> <st c="30412">second-level
    item</st>'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="30429">Even though we can present the details of the selected first-level
    item in a modal screen, we can consider showing it in a third column on an</st>
    <st c="30572">iPad screen.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30584">In the</st> *<st c="30592">Creating a NavigationSplitView</st>*
    <st c="30622">section, we said that the</st> `<st c="30649">Detail</st>` <st c="30655">column
    shows information about the last selected item.</st> <st c="30711">This means
    that if we want to add another column, it will be between the</st> `<st c="30784">Detail</st>`
    <st c="30790">column and the</st> `<st c="30806">Sidebar</st>` <st c="30813">column
    – this is the</st> `<st c="30835">Content</st>` <st c="30842">column.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30850">So, let’s add a</st> `<st c="30867">Content</st>` <st c="30874">column
    to</st> <st c="30884">our</st> <st c="30889">music app:</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="31493">In the preceding code example, we put the list of songs in our
    new</st> `<st c="31561">Content</st>` <st c="31568">block and the song details
    in the</st> `<st c="31603">Detail</st>` <st c="31609">column.</st> <st c="31618">We
    also used the same technique of</st> `<st c="31653">selectedSong</st>` <st c="31665">state
    variable and updated our</st> <st c="31697">UI accordingly.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31712">Let’s see how it looks</st> <st c="31735">now on an iPad (</st>*<st
    c="31752">Figure 4</st>**<st c="31761">.5</st>*<st c="31763">):</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Three-columns NavigationSplitView on an iPad](img/B21795_04_5.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: '<st c="31849">Figure 4.5: Three-columns NavigationSplitView on an iPad</st>'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="31905">Figure 4</st>**<st c="31914">.5</st>* <st c="31916">shows a</st>
    <st c="31925">three-column</st> `<st c="31938">NavigationSplitView</st>` <st c="31957">on
    an iPad, now with the</st> `<st c="31983">Content</st>` <st c="31990">column</st>
    <st c="31998">showing the list of albums in</st> <st c="32028">the middle.</st>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32039">Summary</st>
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="32047">This chapter touches on a crucial topic in mobile development.</st>
    <st c="32111">Navigation has always been an issue, also in UIKit.</st> <st c="32163">However,
    we can achieve an effective navigation mechanism with thoughtful planning based
    on the product requirements and a balanced approach to flexibility</st> <st c="32319">and
    simplicity.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32334">In this chapter, we went over the reasons why SwiftUI is a challenge,
    explored</st> `<st c="32414">NavigationStack</st>`<st c="32429">, reviewed the
    Coordinator pattern,</st> <st c="32465">and even discussed a column-based navigation</st>
    <st c="32510">with</st> `<st c="32515">NavigationSplitView</st>`<st c="32534">.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32535">By now, we are more than capable of creating an amazing navigation
    in</st> <st c="32606">our app!</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="32614">Our next chapter discusses something completely different but
    exciting: how to break our app’s borders and add features outside our sandbox</st>
    <st c="32755">with WidgetKit.</st>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
