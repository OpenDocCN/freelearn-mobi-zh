- en: Reactive Microservices with Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 的响应式微服务
- en: In this chapter, we'll put the skills we've learned so far to use by building
    a microservice using the Kotlin programming language. We also want this microservice
    to be reactive, and to be as close to real life as possible. For that, we'll use
    Vert.x framework, the benefits of which we'll list in the next section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用 Kotlin 编程语言构建一个微服务来运用我们迄今为止学到的技能。我们还想让这个微服务是响应式的，并且尽可能接近现实生活。为此，我们将使用
    Vert.x 框架，其优势将在下一节中列出。
- en: You're probably tired of creating to-do or shopping lists.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经厌倦了创建待办事项或购物清单。
- en: 'So, instead, the microservice will be for a *cat shelter*. The microservice
    should be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，相反，这个微服务将是一个 *猫收容所*。这个微服务应该能够做到以下事情：
- en: Supply an endpoint we can ping to check whether the service is up and running
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个我们可以ping的端点来检查服务是否正在运行
- en: List cats currently in the shelter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目前收容所中的猫咪
- en: Provide us with a means to add new cats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种方法来添加新的猫咪
- en: 'What you''ll need to get started:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要开始以下内容：
- en: JDK 1.8 or later
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8 或更高版本
- en: IntelliJ IDEA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: Gradle 4.2 or later
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle 4.2 或更高版本
- en: PostgreSQL 9.4 or later
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 9.4 或更高版本
- en: This chapter will assume that you have `PostgreSQL` already installed and that
    you have basic knowledge of working with it. If you don't, please refer to the
    official documentation: [https://www.postgresql.org/docs/9.4/static/tutorial-install.html](https://www.postgresql.org/docs/9.4/static/tutorial-install.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将假设你已经安装了 `PostgreSQL` 并且你对它有基本的工作知识。如果没有，请参阅官方文档：[https://www.postgresql.org/docs/9.4/static/tutorial-install.html](https://www.postgresql.org/docs/9.4/static/tutorial-install.html)。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with Vert.x
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Vert.x
- en: Handling requests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求
- en: Testing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Working with databases
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: EventBus
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EventBus
- en: Getting started with Vert.x
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Vert.x
- en: The framework we'll be using for our microservice is called **Vert.x**. It's
    a reactive framework that shares much in common with **reactive extensions**,
    which we discussed in [Chapter 7](part0176.html#57R300-6704093aa34748cfa77c54bdc1a20dc7),
    *Staying Reactive*. It's asynchronous and non-blocking.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的微服务使用的框架称为 **Vert.x**。它是一个与 **reactive extensions** 共享许多共同点的响应式框架，我们在
    [第 7 章](part0176.html#57R300-6704093aa34748cfa77c54bdc1a20dc7) *保持响应式* 中讨论了它。它是异步和非阻塞的。
- en: Let's understand what this means by using a concrete example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来理解这意味着什么。
- en: We'll start with a new Kotlin Gradle project. From your IntelliJ IDEA, open
    File | New | Project, and choose Gradle | Kotlin in the New Project wizard. Give
    your project a `GroupId` (I chose `me.soshin`) and an `ArtifactId` (`catsShelter`
    in my case).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的 Kotlin Gradle 项目开始。从你的 IntelliJ IDEA 中，打开 File | New | Project，在 New
    Project 向导中选择 Gradle | Kotlin，然后点击 Finish。给你的项目一个 `GroupId`（我选择了 `me.soshin`）和一个
    `ArtifactId`（在我的例子中是 `catsShelter`）。
- en: 'Gradle is a build tool, similar to Maven and Ant. It has a nice syntax and
    compiles your projects in an optimised way. You can read about it more here: [https://gradle.org/](https://gradle.org/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是一个构建工具，类似于 Maven 和 Ant。它有一个很好的语法，并以优化的方式编译你的项目。你可以在这里了解更多：[https://gradle.org/](https://gradle.org/)。
- en: On the next screen, choose Use auto-import and Create directories for empty
    content roots, then click Finish.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏上，选择 Use auto-import 和 Create directories for empty content roots，然后点击 Finish。
- en: Next, add the following dependencies to your `build.gradle`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下依赖项添加到你的 `build.gradle` 文件中。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is an explanation of each dependency:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个依赖项的解释：
- en: '`vertx-core` is the core library'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-core` 是核心库'
- en: '`vertx-web` is needed, since we want our service to be REST based'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-web` 是必需的，因为我们希望我们的服务是基于 REST 的'
- en: '`vertx-lang-kotlin` provides idiomatic ways to write Kotlin code with Vert.x'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-lang-kotlin` 提供了使用 Vert.x 编写 Kotlin 代码的惯用方法'
- en: Finally, `vertx-lang-kotlin-coroutines` integrates with the coroutines we discussed
    in detail in [Chapter 9](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7),
    *Designed for Concurrency*
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`vertx-lang-kotlin-coroutines` 与我们在 [第 9 章](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7)
    详细讨论的协程集成，*专为并发设计*
- en: Note that we defined a variable to specify which version of Vert.x we should
    use. The latest stable version to date is 3.5.1, but by the time you read this
    book, it will be 3.5.2 or even 3.6.0.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义了一个变量来指定我们应该使用 Vert.x 的哪个版本。截至目前，最新稳定版本是 3.5.1，但到你阅读这本书的时候，它将是 3.5.2
    或甚至 3.6.0。
- en: As a general rule, all Vert.x libraries should be the same version, and that's
    when the variable becomes useful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，所有 Vert.x 库应该使用相同的版本，这时变量就变得很有用了。
- en: 'Create a file called `Main.kt` in the `src/main/kotlin` folder with the following
    content:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/main/kotlin` 文件夹中创建一个名为 `Main.kt` 的文件，内容如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's all you need to start a web server that will respond *OK* when you open
    [http://localhost:8080](http://localhost:8080) in your browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要启动一个当你在浏览器中打开 [http://localhost:8080](http://localhost:8080) 时会响应 *OK*
    的网络服务器的所有内容。
- en: Now let's understand what actually happens here. We create a Vert.x instance
    using the **Factory Method** from [Chapter 3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7),
    *Understanding Structural Patterns*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们了解这里实际上发生了什么。我们使用第 3 章的 **工厂方法** 从 [Understanding Structural Patterns](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7)
    创建一个 Vert.x 实例。 '
- en: '**Handler** is just a simple listener, or a subscriber. If you don''t remember
    how it works, check [Chapter 4](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7), *Getting
    Familiar with Behavioral Patterns*, for an **Observable** design pattern. In our
    case, it will be called for each new request. That''s the asynchronous nature
    of Vert.x in action.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Handler** 只是一个简单的监听器，或者是一个订阅者。如果你不记得它是如何工作的，请查看第 4 章的 [Getting Familiar with
    Behavioral Patterns](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7)，了解
    **Observable** 设计模式。在我们的情况下，它将为每个新的请求被调用。这就是 Vert.x 的异步特性在起作用。'
- en: Notice that `requestHandler()` is a function that receives a block. Like any
    other idiomatic Kotlin code, you don't need the parentheses.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`requestHandler()` 是一个接收块的函数。像任何其他惯用的 Kotlin 代码一样，你不需要括号。
- en: 'If you are using an IDE such as IntelliJ IDEA, you can run it directly. An
    alternative would be to add the following lines to your `build.gradle`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 IntelliJ IDEA 等集成开发环境，你可以直接运行它。另一种选择是将以下行添加到你的 `build.gradle` 文件中：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And then you can simply start it with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以简单地使用以下命令启动它：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another option would be to use `VertxGradlePlugin` ([https://github.com/jponge/vertx-gradle-plugin](https://github.com/jponge/vertx-gradle-plugin)), which
    will do the same thing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用 `VertxGradlePlugin` ([https://github.com/jponge/vertx-gradle-plugin](https://github.com/jponge/vertx-gradle-plugin))，它将做同样的事情。
- en: Routing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Notice that no matter which URL we specify, we always get the same result.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论我们指定哪个 URL，我们总是得到相同的结果。
- en: Of course, that's not what we want to achieve. Let's start by adding the most
    basic endpoint, which will only tell us that the service is up and running.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是我们想要达到的目标。让我们先添加最基本的服务端点，它只会告诉我们服务正在运行。
- en: 'For that, we''ll use `Router`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用 `Router`：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Router` lets you specify handlers for different HTTP methods and URLs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router` 允许你为不同的 HTTP 方法和 URL 指定处理器。'
- en: 'But, by default, it doesn''t support coroutines. Let''s fix that by creating
    an extension function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，默认情况下，它不支持协程。让我们通过创建一个扩展函数来解决这个问题：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are familiar with modern JavaScript, this is similar to `async() => {}`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉现代 JavaScript，这类似于 `async() => {}`。
- en: 'Now we can use this new extension method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个新的扩展方法：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We saw how we return a flat text response in the very first example. So, let's
    return JSON instead. Most real-life applications use JSON for communication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何在第一个示例中返回一个平面文本响应。所以，让我们返回 JSON 代替。大多数实际应用程序使用 JSON 进行通信。
- en: 'Add the following lines to your handler:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到你的处理器中：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Yet another extension function we declare is `respond()`. It looks as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的另一个扩展函数是 `respond()`。它看起来如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now connect your router to the server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的路由器连接到服务器。
- en: 'You can do that by replacing the previous server instantiation with the following
    line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用以下行替换之前的服务器实例化来实现这一点：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now all routing will be handled by `Router`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有路由都将由 `Router` 处理。
- en: 'You can open `http://localhost:8080/alive` in your browser and make sure that
    you get `{"alive": true}` as a response.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在浏览器中打开 `http://localhost:8080/alive` 并确保你得到 `{"alive": true}` 的响应。'
- en: Congratulations! You've managed to create your first route that returns a JSON.
    From now on, whenever you're not sure whether your application is up and running,
    you can simply check it using this URL. This becomes even more important when
    you use a load balancer, which needs to know how many applications are available
    at any time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功创建了第一个返回 JSON 的路由。从现在起，无论何时你不确定你的应用程序是否正在运行，你都可以简单地使用这个 URL 来检查它。当你使用负载均衡器时，这一点尤为重要，因为负载均衡器需要知道在任何时候有多少应用程序可用。
- en: Handling requests
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: Our next task is adding the first cat to our virtual shelter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是向我们的虚拟收容所添加第一只猫。
- en: 'It should be a `POST` request, where the body of the request may look something
    like this: `{"name": "Binky", "age": 4}`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '这应该是一个 `POST` 请求，其中请求体的内容可能看起来像这样：`{"name": "Binky", "age": 4}`。'
- en: If you are familiar with tools such as **curl** or **Postman** to issue `POST`
    requests, that's great. If not, we'll write a test in the next section that will
    check exactly that scenario.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 **curl** 或 **Postman** 这样的工具来发出 `POST` 请求，那很好。如果不熟悉，我们将在下一节编写一个测试来检查这个场景。
- en: 'The first thing we''ll need to do is add the following line after we initialize
    our router:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是在我们初始化我们的路由器之后添加以下行：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will tell Vert.x to parse the request body into JSON for any request. Another
    way would be to use `router.route("/*")`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 Vert.x 将请求体解析为 JSON，适用于任何请求。另一种方法是使用 `router.route("/*")`。
- en: 'Now, let''s figure out what our URL should look like. It is good practice to
    have our API URLs versioned, so we would like it to be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确定我们的 URL 应该是什么样子。良好的实践是将我们的 API URL 进行版本控制，所以我们希望它如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, we can assume the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以假设以下：
- en: '`GET api/v1/cats` will return all cats we have in our shelter'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET api/v1/cats` 将返回我们庇护所中所有的猫。'
- en: '`POST api/v1/cats` will add a new cat'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST api/v1/cats` 将添加一只新的猫。'
- en: '`GET api/v1/cats/34` will return a cat with `ID=34` if it exists or 404 otherwise'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET api/v1/cats/34` 如果存在，将返回 `ID=34` 的猫，否则返回 404。'
- en: 'Having figured that out, we can progress as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了这一点后，我们可以继续如下操作：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last endpoint will need to receive a path argument. We use semicolon notation
    for that:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个端点需要接收一个路径参数。我们使用分号符号来表示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Verticles
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Verticles
- en: Now come across a problem, though. Our code resides in the `Main.kt` file, which
    grows bigger and bigger. We can start splitting it by using verticles.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在遇到了一个问题。我们的代码位于 `Main.kt` 文件中，它越来越大。我们可以通过使用 verticles 来开始分割它。
- en: 'You can think of a verticle as a lightweight actor.  Let''s see an example;
    look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把 verticle 看作是一个轻量级 actor。让我们看看以下代码的例子：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to start this verticle. There are different ways of doing that,
    but the simplest way is to pass the instance of this class to the `deployVerticle()`
    method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要启动这个 verticle。有几种不同的方法可以做到这一点，但最简单的方法是将这个类的实例传递给 `deployVerticle()` 方法：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now our code is split into two files, `ServerVerticle.kt` and `Main.kt`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码被分成两个文件，`ServerVerticle.kt` 和 `Main.kt`。
- en: Notice, though, how `/api/v1/cats/` is repeated every time. Isn't there a way
    to remove that redundancy? Actually, there is. And it's called **subrouter**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，但是 `/api/v1/cats/` 每次都会重复。有没有一种方法可以消除这种冗余？实际上，有。它被称为 **子路由**。
- en: Subrouting
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子路由
- en: 'We''ll leave the `/alive` endpoint as it is, but we''ll extract all the other
    endpoints into a separate function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持 `/alive` 端点不变，但我们将所有其他端点提取到一个单独的函数中：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's a more fluent way to define it, but we left it that way as it is more
    readable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更流畅的方式来定义它，但我们保留了原来的方式，因为它更易读。
- en: 'Much as we supplied our main router to the Vert.x server instance, we now supply
    our subrouter to the main router as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向 Vert.x 服务器实例提供主路由器一样，我们现在将子路由器按如下方式提供给主路由器：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Keeping our code clean and well separated is very important.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们的代码干净和良好分离非常重要。
- en: Testing
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Before we continue to add our cats to the database, let's first write some tests
    to make sure that everything works correctly so far.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续将猫添加到数据库之前，让我们首先编写一些测试来确保到目前为止一切正常。
- en: For that, we'll use the **TestNG** test framework. You can also use **JUnit**
    or **VertxUnit** for the same purpose.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用 **TestNG** 测试框架。你也可以使用 **JUnit** 或 **VertxUnit** 来达到同样的目的。
- en: 'Start by adding the following line to the **dependencies** part of your `build.gradle`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下行添加到你的 `build.gradle` 的 **dependencies** 部分：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we'll create our first test. It should be located under `/src/test/kotlin/<your_package>`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的第一个测试。它应该位于 `/src/test/kotlin/<your_package>`。
- en: 'The basic structure of all the integration tests looks something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集成测试的基本结构看起来像这样：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A good trick is to name your tests using Kotlin backtick notation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好技巧是使用 Kotlin 反引号符号来命名你的测试。
- en: 'You could name your tests like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样命名你的测试：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But it is better to name your tests like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但更好的命名测试的方式是这样的：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we want to issue an actual HTTP call to our `/alive` endpoint, for example,
    and check the response code. For that, we'll use the Vert.x web client.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要向我们的 `/alive` 端点发出实际的 HTTP 请求，例如，并检查响应代码。为此，我们将使用 Vert.x 网络客户端。
- en: 'Add it to your `build.gradle` dependencies section:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到你的 `build.gradle` 依赖项部分：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you plan to use it only in tests, you can specify `testCompile` instead of
    `compile`. But `WebClient` is so useful you'll probably end up using it in your
    code anyway.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算只在测试中使用它，你可以指定 `testCompile` 而不是 `compile`。但 `WebClient` 非常有用，你最终可能还是会将其用在代码中。
- en: Helper methods
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助方法
- en: We'll create two helper functions in our test, called `get()` and `post()`,
    which will issue `GET` and `POST` requests to our test server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将创建两个辅助函数，分别称为 `get()` 和 `post()`，它们将向我们的测试服务器发出 `GET` 和 `POST` 请求。
- en: 'We''ll start with `get()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `get()` 开始：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second method, `post()`, will look very similar, but it will also have
    a request body parameter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 `post()` 将非常相似，但它还将有一个请求体参数：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both of those functions use coroutines and the default parameter values Kotlin
    provides.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都使用了 Kotlin 提供的默认参数值协程。
- en: You should write your own helper functions or alter those according to your
    needs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该编写自己的辅助函数或根据你的需求修改它们。
- en: 'Another helper function that we''ll need is `startServer()`, which we already
    mentioned in `@BeforeClass`. It should look something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个辅助函数 `startServer()`，我们已经在 `@BeforeClass` 中提到过它。它应该看起来像这样：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll need two new extension functions for our convenience. Those functions
    will convert the server response to JSON:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个新的扩展函数来方便我们。这些函数将把服务器响应转换为 JSON：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we''re all set to write our first test:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写我们的第一个测试：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run `./gradlew test` to check that this test passes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `./gradlew test` 以检查这个测试是否通过。
- en: Next, we'll write another test; this time for the cat's creation endpoint.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写另一个测试；这次是为猫的创建端点。
- en: 'At first, it will fail:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，它将失败：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that our server returns the status code `501 Not Implemented`, and doesn't
    return the `cat` ID.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的服务器返回状态码 `501 Not Implemented`，并且没有返回 `cat` ID。
- en: We'll be fixing that in the next section when we discuss persistence in a database.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论数据库持久性时修复这个问题。
- en: Working with databases
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: We won't be able to progress much further without the ability to save our objects,
    namely cats, into some kind of persistent storage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有将我们的对象（即猫）保存到某种持久存储的能力，我们将无法取得更大的进展。
- en: For that, we'll need to connect to the database first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先需要连接到数据库。
- en: 'Add the following two lines to your `build.gradle` dependencies section:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两行添加到你的 `build.gradle` 依赖部分：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first line of code fetches the `PostgreSQL` driver. The second one adds
    the Vert.x JDBC client, which allows Vert.x, having the driver, to connect to
    any database that supports JDBC.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码获取 `PostgreSQL` 驱动。第二行添加了 Vert.x JDBC 客户端，这使得 Vert.x 在拥有驱动程序的情况下可以连接到任何支持
    JDBC 的数据库。
- en: Managing configuration
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理配置
- en: Now we want to hold database configuration somewhere. For local development,
    it may be fine to have those configurations hardcoded.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要将数据库配置存储在某个地方。对于本地开发，可能将配置硬编码是可行的。
- en: 'When we connect to the database, we need to specify the following parameters
    at the very least:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们连接到数据库时，我们至少需要指定以下参数：
- en: Username
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Password
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Host
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机
- en: Database name
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库名
- en: Where should we store them?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在哪里存储它们？
- en: One option is of course to hardcode those values. That would be fine for a local
    environment, but what about when deploying this service somewhere?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个选项当然是将这些值硬编码。这对于本地环境来说是可以的，但当我们部署这个服务到其他地方时怎么办呢？
- en: '**You''ll go, I cant come! XDSpringBoot** do, or we could attempt to read them
    from the environment variables. Anyway, we''ll need an object that would encapsulate
    this logic, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会去，我不能来！XDSpringBoot** 做的，或者我们可以尝试从环境变量中读取它们。无论如何，我们需要一个封装这个逻辑的对象，如下面的代码所示：'
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That's of course only one approach you could take.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然只是你可以采取的一种方法。
- en: 'We now will create `JDBCClient` by using this configuration code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用此配置代码创建 `JDBCClient`：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we chose an extension function that will work on all `CoroutineVerticles`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择了一个扩展函数，它将在所有 `CoroutineVerticles` 上工作。
- en: 'To simplify working with the `JDBCClient`, we''ll add a method called `query()` to
    it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化与 `JDBCClient` 一起工作，我们将向其中添加一个名为 `query()` 的方法：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll also add the `toJsonArray()` method since that''s what our `JDBCClient`
    works with:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会添加 `toJsonArray()` 方法，因为这是我们 `JDBCClient` 使用的：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note here how Kotlin generics are being used to simplify the conversion while
    *staying type-safe*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里 Kotlin 泛型是如何被用来简化转换同时保持类型安全的。
- en: 'And we''ll add a `handle()` function, which will provide us with a simple API
    to handle asynchronous errors:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会添加一个 `handle()` 函数，它将为我们提供一个简单的 API 来处理异步错误：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To make sure everything works correctly, we''ll add a check to our `/alive`
    route:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切正常工作，我们将在我们的`/alive`路由上添加一个检查：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The lines you need to add are marked in bold.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的行用粗体标出。
- en: 'After adding those lines and opening  [http://localhost:8080/alive](http://localhost:8080/alive)
    you should get the following JSON code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加这些行并打开[http://localhost:8080/alive](http://localhost:8080/alive)之后，你应该得到以下JSON代码：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Managing the database
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据库
- en: 'Of course, our test doesn''t work. That''s because we haven''t created our
    database yet. Make sure you run the following line in your command line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的测试没有通过。这是因为我们还没有创建我们的数据库。确保你在命令行中运行以下行：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After we have made sure that our database is up and running, let's implement
    our first real endpoint.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确认数据库正在运行之后，让我们实现我们的第一个真实端点。
- en: 'We''ll keep our SQL nicely separated from the actual code. Add this to your `ServerVerticle`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持我们的SQL与实际代码的清晰分离。将以下内容添加到你的`ServerVerticle`中：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We use multiline strings here, with `|` and `trimMargin()` to re-align them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用多行字符串，通过`|`和`trimMargin()`来重新对齐它们。
- en: 'Now use the following code to call this query:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用以下代码调用这个查询：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that we didn't print the error anywhere. That's because we defined the
    `handle()` function to do that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在任何地方打印错误信息。这是因为我们定义了`handle()`函数来处理这个任务。
- en: 'We also defined our own function that parses the request body, which is `JsonObject`,
    to `JsonArray`, which is expected by the `JDBCClient`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了自己的函数来解析请求体，将`JsonObject`转换为`JsonArray`，这是`JDBCClient`所期望的：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that we have two different versions of `this` here. One refers to the
    inner scope of the `apply()` function. The other refers to the outer scope of
    the `toCat()` function. To refer to outer scopes, we use the `@scopeName` notation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有两个不同的`this`版本。一个指的是`apply()`函数的内部作用域。另一个指的是`toCat()`函数的外部作用域。要引用外部作用域，我们使用`@scopeName`注解。
- en: As you can see, extension functions are extremely powerful tools for cleaning
    up your code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，扩展函数是清理代码的极其强大的工具。
- en: 'When you run our test again, you''ll notice it still fails, but with a different
    error code now. That''s because we didn''t create our table yet. Let''s do it
    now. There are a few ways to do this, but the most convenient way would be to
    simply run the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行我们的测试时，你会注意到它仍然失败，但现在有一个不同的错误代码。这是因为我们还没有创建我们的表。让我们现在就创建它。有几种方法可以做到这一点，但最方便的方法是简单地运行以下命令：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Run your test again to make sure it passes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的测试以确保它通过。
- en: EventBus
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EventBus
- en: 'This is the second time we have stumbled upon the same problem: our classes
    get bigger and bigger, which we would usually like to avoid as much as possible.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二次我们遇到了相同的问题：我们的类越来越大，我们通常尽可能避免这种情况。
- en: What if we split this creation of cats logic into a separate file yet again?
    Let's call it `CatVerticle.kt`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次将创建猫的逻辑拆分到一个单独的文件中呢？让我们称它为`CatVerticle.kt`。
- en: But then we need a way for `ServerVerticle` to communicate with `CatVerticle`.
    In frameworks such as **SpringBoot**, you would use **dependency injection** for
    that purpose. But what about reactive frameworks?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要一种方法让`ServerVerticle`与`CatVerticle`通信。在像**SpringBoot**这样的框架中，你会使用**依赖注入**来达到这个目的。但是对于响应式框架呢？
- en: Consumer
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者
- en: 'To solve communication problems, Vert.x uses **EventBus**. It''s an implementation
    of the **Observable** design pattern we discussed in [Chapter 4](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7),
    *Getting Familiar with Behavioral Patterns*. Any verticle can send a message over
    the event bus, choosing between these two modes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决通信问题，Vert.x使用**EventBus**。它是我们在[第4章](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7)中讨论的**Observable**设计模式的实现，*熟悉行为模式*。任何verticle都可以通过事件总线发送消息，在这些两种模式之间进行选择：
- en: '`send()` will send a message to only one subscriber'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()`将消息发送给单个订阅者'
- en: '`publish()` will send a message to all subscribers'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish()`将消息发送给所有订阅者'
- en: 'No matter which method is used to send the message, you subscribe to it using
    the `consumer()` method on the EventBus:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法发送消息，你都可以使用EventBus上的`consumer()`方法来订阅它：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The type specifies which object we expect to receive our message. In this case,
    it''s `JsonObject`. Constant `CATS` is the key we subscribe for. It can be any
    string. By using a namespace,  we ensure that there won''t be a collision in the
    future. If we were to add dogs to our shelter, we would use another constant with
    another namespace. For example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类型指定了我们期望接收消息的对象。在这种情况下，它是`JsonObject`。常量`CATS`是我们订阅的键。它可以是任何字符串。通过使用命名空间，我们确保未来不会发生冲突。如果我们要在我们的收容所中添加狗，我们将使用另一个具有另一个命名空间的常量。例如：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we add the following two queries, which are just multiline string constants:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加以下两个查询，它们只是多行字符串常量：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Why are we putting one inside the class and the other outside it?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在类内部放置一个，在类外部放置另一个？
- en: '`QUERY_ALL` is a short query and it fits on one line. We can allow ourselves
    to make it a constant. On the other hand, `QUERY_WITH_ID` is a longer query and
    it requires some indentation. Since we remove the indentation only at runtime,
    we can''t make it a constant. So, instead, we use a member value. In real-life
    projects, most of your queries will probably have to be private values. But it''s
    important to know the difference between the two approaches.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUERY_ALL`是一个简短的查询，它适合一行。我们可以允许自己将其作为一个常量。另一方面，`QUERY_WITH_ID`是一个较长的查询，需要一些缩进。由于我们只在运行时移除缩进，所以我们不能将其作为一个常量。因此，我们使用成员值。在现实世界的项目中，你的大部分查询可能都需要是私有值。但了解两种方法之间的区别很重要。'
- en: 'And we populate our consumer with the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下代码填充我们的消费者：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we got a cat ID in the request, we fetch this specific cat. Otherwise, we
    fetch all the cats that are available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求中包含猫的ID，我们就获取这只特定的猫。否则，我们获取所有可用的猫。
- en: We use `launch()` because we want to `await()` the result, and we don't have
    any return value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`launch()`是因为我们想要`await()`结果，并且我们没有返回值。
- en: Producer
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者
- en: 'What''s left is only to call the cat from the `ServerVerticle`. For that, we''ll
    add another method to our `CoroutineVerticle`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是从`ServerVerticle`调用猫。为此，我们将在我们的`CoroutineVerticle`中添加另一个方法：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we can handle our request like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样处理我们的请求：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that we're reusing the same constant we defined earlier, called `CATS`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在重用之前定义的同一个常量，称为`CATS`。
- en: That way, we can easily check who can send this event and who consumes it. If
    it's successful, we'll return a JSON. Otherwise, we'll return an HTTP error code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以轻松地检查谁可以发送这个事件，谁消费它。如果成功，我们将返回一个JSON。否则，我们将返回一个HTTP错误代码。
- en: 'Another method that we add is `toJson()` on `MultiMap`. `MultiMap` is an object
    that holds our query parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的另一个方法是`toJson()`在`MultiMap`上。`MultiMap`是一个包含我们的查询参数的对象：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To make sure everything works as expected, let's create two more tests for our
    new endpoints.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切按预期工作，让我们为我们的新端点创建两个额外的测试。
- en: 'Just don''t forget to add the following line to your `Main.kt` and to the `startServer()`
    function in your tests:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 只别忘了在你的`Main.kt`文件和测试中的`startServer()`函数中添加以下行：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: More testing
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多测试
- en: 'Now add the following basic test:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加以下基本测试：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To make sure you understand how everything works together, here are some more
    assignments you may wish to do:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你理解所有这些是如何协同工作的，这里有一些你可能希望完成的额外任务：
- en: Move the logic of adding a new cat to the `CatVerticle`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将添加新猫的逻辑移动到`CatVerticle`。
- en: Implement getting a single cat. Notice how the code is very similar to the one
    that gets all the cats? Refactor it to use a local function, a cool feature in
    Kotlin, which we have already discussed.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现获取单个猫的功能。注意代码与获取所有猫的代码非常相似？重构它以使用Kotlin的一个酷特性——局部函数，我们之前已经讨论过了。
- en: Implement deletion and update the cat, following the same principles.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照同样的原则实现删除和更新猫的功能。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter put together everything we've learned about Kotlin design patterns
    and idioms, to produce an extensible microservice.  And, thanks to Vert.x, it's
    also reactive, which makes it extremely scalable. It also has tested in place,
    as any real-world application should.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章汇总了我们关于Kotlin设计模式和习惯用法所学的所有内容，以生成一个可扩展的微服务。而且，多亏了Vert.x，它也是反应式的，这使得它具有极高的可扩展性。它还进行了测试，正如任何现实世界的应用程序应该的那样。
- en: In our application, classes are divided by domains, as opposed to layers, in
    the usual MVC architecture. A minimal unit of work in Vert.x is called a verticle,
    and verticles communicate using EventBus.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，类是根据领域而不是层来划分的，这与通常的MVC架构相反。Vert.x中的最小工作单元被称为verticle，verticles通过EventBus进行通信。
- en: 'Our API follows all of REST''s best practices: using HTTP verbs and meaningful
    paths to resources and consuming and producing JSON.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 遵循了所有 REST 的最佳实践：使用 HTTP 动词和有意义的路径来访问资源，以及消费和生成 JSON。
- en: You can apply the same principles to any other real application you're going
    to write, and we do hope you'll choose Vert.x and Kotlin to do so.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将同样的原则应用到你要编写的任何其他实际应用中，我们确实希望你会选择 Vert.x 和 Kotlin 来实现这一点。
