- en: Reactive Microservices with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll put the skills we've learned so far to use by building
    a microservice using the Kotlin programming language. We also want this microservice
    to be reactive, and to be as close to real life as possible. For that, we'll use
    Vert.x framework, the benefits of which we'll list in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You're probably tired of creating to-do or shopping lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, the microservice will be for a *cat shelter*. The microservice
    should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Supply an endpoint we can ping to check whether the service is up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List cats currently in the shelter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide us with a means to add new cats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What you''ll need to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle 4.2 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL 9.4 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will assume that you have `PostgreSQL` already installed and that
    you have basic knowledge of working with it. If you don't, please refer to the
    official documentation: [https://www.postgresql.org/docs/9.4/static/tutorial-install.html](https://www.postgresql.org/docs/9.4/static/tutorial-install.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Vert.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EventBus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The framework we'll be using for our microservice is called **Vert.x**. It's
    a reactive framework that shares much in common with **reactive extensions**,
    which we discussed in [Chapter 7](part0176.html#57R300-6704093aa34748cfa77c54bdc1a20dc7),
    *Staying Reactive*. It's asynchronous and non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand what this means by using a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a new Kotlin Gradle project. From your IntelliJ IDEA, open
    File | New | Project, and choose Gradle | Kotlin in the New Project wizard. Give
    your project a `GroupId` (I chose `me.soshin`) and an `ArtifactId` (`catsShelter`
    in my case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle is a build tool, similar to Maven and Ant. It has a nice syntax and
    compiles your projects in an optimised way. You can read about it more here: [https://gradle.org/](https://gradle.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, choose Use auto-import and Create directories for empty
    content roots, then click Finish.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add the following dependencies to your `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an explanation of each dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vertx-core` is the core library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertx-web` is needed, since we want our service to be REST based'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertx-lang-kotlin` provides idiomatic ways to write Kotlin code with Vert.x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `vertx-lang-kotlin-coroutines` integrates with the coroutines we discussed
    in detail in [Chapter 9](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7),
    *Designed for Concurrency*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we defined a variable to specify which version of Vert.x we should
    use. The latest stable version to date is 3.5.1, but by the time you read this
    book, it will be 3.5.2 or even 3.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, all Vert.x libraries should be the same version, and that's
    when the variable becomes useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `Main.kt` in the `src/main/kotlin` folder with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's all you need to start a web server that will respond *OK* when you open
    [http://localhost:8080](http://localhost:8080) in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's understand what actually happens here. We create a Vert.x instance
    using the **Factory Method** from [Chapter 3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7),
    *Understanding Structural Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handler** is just a simple listener, or a subscriber. If you don''t remember
    how it works, check [Chapter 4](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7), *Getting
    Familiar with Behavioral Patterns*, for an **Observable** design pattern. In our
    case, it will be called for each new request. That''s the asynchronous nature
    of Vert.x in action.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `requestHandler()` is a function that receives a block. Like any
    other idiomatic Kotlin code, you don't need the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an IDE such as IntelliJ IDEA, you can run it directly. An
    alternative would be to add the following lines to your `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you can simply start it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another option would be to use `VertxGradlePlugin` ([https://github.com/jponge/vertx-gradle-plugin](https://github.com/jponge/vertx-gradle-plugin)), which
    will do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that no matter which URL we specify, we always get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, that's not what we want to achieve. Let's start by adding the most
    basic endpoint, which will only tell us that the service is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we''ll use `Router`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Router` lets you specify handlers for different HTTP methods and URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, by default, it doesn''t support coroutines. Let''s fix that by creating
    an extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with modern JavaScript, this is similar to `async() => {}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this new extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We saw how we return a flat text response in the very first example. So, let's
    return JSON instead. Most real-life applications use JSON for communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to your handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another extension function we declare is `respond()`. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now connect your router to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do that by replacing the previous server instantiation with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now all routing will be handled by `Router`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open `http://localhost:8080/alive` in your browser and make sure that
    you get `{"alive": true}` as a response.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've managed to create your first route that returns a JSON.
    From now on, whenever you're not sure whether your application is up and running,
    you can simply check it using this URL. This becomes even more important when
    you use a load balancer, which needs to know how many applications are available
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next task is adding the first cat to our virtual shelter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be a `POST` request, where the body of the request may look something
    like this: `{"name": "Binky", "age": 4}`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with tools such as **curl** or **Postman** to issue `POST`
    requests, that's great. If not, we'll write a test in the next section that will
    check exactly that scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll need to do is add the following line after we initialize
    our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will tell Vert.x to parse the request body into JSON for any request. Another
    way would be to use `router.route("/*")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s figure out what our URL should look like. It is good practice to
    have our API URLs versioned, so we would like it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET api/v1/cats` will return all cats we have in our shelter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST api/v1/cats` will add a new cat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET api/v1/cats/34` will return a cat with `ID=34` if it exists or 404 otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having figured that out, we can progress as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The last endpoint will need to receive a path argument. We use semicolon notation
    for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Verticles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now come across a problem, though. Our code resides in the `Main.kt` file, which
    grows bigger and bigger. We can start splitting it by using verticles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of a verticle as a lightweight actor.  Let''s see an example;
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to start this verticle. There are different ways of doing that,
    but the simplest way is to pass the instance of this class to the `deployVerticle()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now our code is split into two files, `ServerVerticle.kt` and `Main.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, though, how `/api/v1/cats/` is repeated every time. Isn't there a way
    to remove that redundancy? Actually, there is. And it's called **subrouter**.
  prefs: []
  type: TYPE_NORMAL
- en: Subrouting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll leave the `/alive` endpoint as it is, but we''ll extract all the other
    endpoints into a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's a more fluent way to define it, but we left it that way as it is more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much as we supplied our main router to the Vert.x server instance, we now supply
    our subrouter to the main router as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Keeping our code clean and well separated is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue to add our cats to the database, let's first write some tests
    to make sure that everything works correctly so far.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we'll use the **TestNG** test framework. You can also use **JUnit**
    or **VertxUnit** for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the following line to the **dependencies** part of your `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll create our first test. It should be located under `/src/test/kotlin/<your_package>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of all the integration tests looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A good trick is to name your tests using Kotlin backtick notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could name your tests like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is better to name your tests like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now we want to issue an actual HTTP call to our `/alive` endpoint, for example,
    and check the response code. For that, we'll use the Vert.x web client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add it to your `build.gradle` dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you plan to use it only in tests, you can specify `testCompile` instead of
    `compile`. But `WebClient` is so useful you'll probably end up using it in your
    code anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Helper methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create two helper functions in our test, called `get()` and `post()`,
    which will issue `GET` and `POST` requests to our test server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with `get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method, `post()`, will look very similar, but it will also have
    a request body parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Both of those functions use coroutines and the default parameter values Kotlin
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: You should write your own helper functions or alter those according to your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another helper function that we''ll need is `startServer()`, which we already
    mentioned in `@BeforeClass`. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need two new extension functions for our convenience. Those functions
    will convert the server response to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re all set to write our first test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run `./gradlew test` to check that this test passes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll write another test; this time for the cat's creation endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, it will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that our server returns the status code `501 Not Implemented`, and doesn't
    return the `cat` ID.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be fixing that in the next section when we discuss persistence in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Working with databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won't be able to progress much further without the ability to save our objects,
    namely cats, into some kind of persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we'll need to connect to the database first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following two lines to your `build.gradle` dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code fetches the `PostgreSQL` driver. The second one adds
    the Vert.x JDBC client, which allows Vert.x, having the driver, to connect to
    any database that supports JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to hold database configuration somewhere. For local development,
    it may be fine to have those configurations hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we connect to the database, we need to specify the following parameters
    at the very least:'
  prefs: []
  type: TYPE_NORMAL
- en: Username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should we store them?
  prefs: []
  type: TYPE_NORMAL
- en: One option is of course to hardcode those values. That would be fine for a local
    environment, but what about when deploying this service somewhere?
  prefs: []
  type: TYPE_NORMAL
- en: '**You''ll go, I cant come! XDSpringBoot** do, or we could attempt to read them
    from the environment variables. Anyway, we''ll need an object that would encapsulate
    this logic, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That's of course only one approach you could take.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now will create `JDBCClient` by using this configuration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we chose an extension function that will work on all `CoroutineVerticles`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify working with the `JDBCClient`, we''ll add a method called `query()` to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add the `toJsonArray()` method since that''s what our `JDBCClient`
    works with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note here how Kotlin generics are being used to simplify the conversion while
    *staying type-safe*.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we''ll add a `handle()` function, which will provide us with a simple API
    to handle asynchronous errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure everything works correctly, we''ll add a check to our `/alive`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The lines you need to add are marked in bold.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding those lines and opening  [http://localhost:8080/alive](http://localhost:8080/alive)
    you should get the following JSON code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Managing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, our test doesn''t work. That''s because we haven''t created our
    database yet. Make sure you run the following line in your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After we have made sure that our database is up and running, let's implement
    our first real endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll keep our SQL nicely separated from the actual code. Add this to your `ServerVerticle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We use multiline strings here, with `|` and `trimMargin()` to re-align them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use the following code to call this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't print the error anywhere. That's because we defined the
    `handle()` function to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also defined our own function that parses the request body, which is `JsonObject`,
    to `JsonArray`, which is expected by the `JDBCClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have two different versions of `this` here. One refers to the
    inner scope of the `apply()` function. The other refers to the outer scope of
    the `toCat()` function. To refer to outer scopes, we use the `@scopeName` notation.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, extension functions are extremely powerful tools for cleaning
    up your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run our test again, you''ll notice it still fails, but with a different
    error code now. That''s because we didn''t create our table yet. Let''s do it
    now. There are a few ways to do this, but the most convenient way would be to
    simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Run your test again to make sure it passes.
  prefs: []
  type: TYPE_NORMAL
- en: EventBus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the second time we have stumbled upon the same problem: our classes
    get bigger and bigger, which we would usually like to avoid as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: What if we split this creation of cats logic into a separate file yet again?
    Let's call it `CatVerticle.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: But then we need a way for `ServerVerticle` to communicate with `CatVerticle`.
    In frameworks such as **SpringBoot**, you would use **dependency injection** for
    that purpose. But what about reactive frameworks?
  prefs: []
  type: TYPE_NORMAL
- en: Consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To solve communication problems, Vert.x uses **EventBus**. It''s an implementation
    of the **Observable** design pattern we discussed in [Chapter 4](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7),
    *Getting Familiar with Behavioral Patterns*. Any verticle can send a message over
    the event bus, choosing between these two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`send()` will send a message to only one subscriber'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish()` will send a message to all subscribers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No matter which method is used to send the message, you subscribe to it using
    the `consumer()` method on the EventBus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The type specifies which object we expect to receive our message. In this case,
    it''s `JsonObject`. Constant `CATS` is the key we subscribe for. It can be any
    string. By using a namespace,  we ensure that there won''t be a collision in the
    future. If we were to add dogs to our shelter, we would use another constant with
    another namespace. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we add the following two queries, which are just multiline string constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Why are we putting one inside the class and the other outside it?
  prefs: []
  type: TYPE_NORMAL
- en: '`QUERY_ALL` is a short query and it fits on one line. We can allow ourselves
    to make it a constant. On the other hand, `QUERY_WITH_ID` is a longer query and
    it requires some indentation. Since we remove the indentation only at runtime,
    we can''t make it a constant. So, instead, we use a member value. In real-life
    projects, most of your queries will probably have to be private values. But it''s
    important to know the difference between the two approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we populate our consumer with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we got a cat ID in the request, we fetch this specific cat. Otherwise, we
    fetch all the cats that are available.
  prefs: []
  type: TYPE_NORMAL
- en: We use `launch()` because we want to `await()` the result, and we don't have
    any return value.
  prefs: []
  type: TYPE_NORMAL
- en: Producer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What''s left is only to call the cat from the `ServerVerticle`. For that, we''ll
    add another method to our `CoroutineVerticle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can handle our request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're reusing the same constant we defined earlier, called `CATS`.
  prefs: []
  type: TYPE_NORMAL
- en: That way, we can easily check who can send this event and who consumes it. If
    it's successful, we'll return a JSON. Otherwise, we'll return an HTTP error code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method that we add is `toJson()` on `MultiMap`. `MultiMap` is an object
    that holds our query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To make sure everything works as expected, let's create two more tests for our
    new endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just don''t forget to add the following line to your `Main.kt` and to the `startServer()`
    function in your tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: More testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now add the following basic test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure you understand how everything works together, here are some more
    assignments you may wish to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the logic of adding a new cat to the `CatVerticle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement getting a single cat. Notice how the code is very similar to the one
    that gets all the cats? Refactor it to use a local function, a cool feature in
    Kotlin, which we have already discussed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement deletion and update the cat, following the same principles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter put together everything we've learned about Kotlin design patterns
    and idioms, to produce an extensible microservice.  And, thanks to Vert.x, it's
    also reactive, which makes it extremely scalable. It also has tested in place,
    as any real-world application should.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, classes are divided by domains, as opposed to layers, in
    the usual MVC architecture. A minimal unit of work in Vert.x is called a verticle,
    and verticles communicate using EventBus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our API follows all of REST''s best practices: using HTTP verbs and meaningful
    paths to resources and consuming and producing JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: You can apply the same principles to any other real application you're going
    to write, and we do hope you'll choose Vert.x and Kotlin to do so.
  prefs: []
  type: TYPE_NORMAL
