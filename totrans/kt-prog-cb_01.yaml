- en: Installation and Working with Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Kotlin Android project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Gradle to run Kotlin code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run a Kotlin compiled class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a self-executable jar with Gradle and Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading console input in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting Java code to Kotlin and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write an idiomatic logger with Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escaping for Java identifiers that are keywords in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disambiguating using the "as" keyword to locally rename the clashing entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing bit manipulations in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing String to Long, Double, or Int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using String templates in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android apps are a fascinating piece of technology. The apps developed on Android
    have worldwide appeal and audience. However, that has posed serious challenges
    for developers. The challenge is with updating APIs, platforms, and varied device
    capabilities. For example, if you are an Android developer, you have to rely on
    Java 6 if you want to support all API levels in Android. Java 6 is obsolete now,
    so much so that even its successor, Java 7, is kind of obsolete today. There was
    a great need for modern language for Android, which has built a trillion dollar
    industry around it and has influenced billions of lives. True, we have Java 8
    now, but we can only use it if we are developing Android apps for API level 24
    and above. However, that’s equivalent to targeting only 9% of Android devices
    as of 2017; clearly, this isn’t the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: All is not lost though, and thanks to the JVM, we can write Android apps using
    any language that produces JVM compatible bytecode on compilation. So theoretically,
    we can use Clojure, Groovy, Scala, and Kotlin, but Kotlin is the best alternative
    among all, why? It's because in April 2017, Google announced Kotlin as an official
    language for Android development.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the biggest tech companies such as Pinterest, Uber, Atlassian, Coursera,
    and Evernote are now using Kotlin in their Android apps. This wide adoption by
    them already speaks a huge volume for Kotlin. The 100% interoperability with Android
    and Java has helped Kotlin in its adoption. Kotlin is much easier to work with
    than Java and, apart from Android apps, you can also build web-apps with it. So,
    this chapter will introduce you to Kotlin and help you get started with this awesome
    piece of technology.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first see how to set up the environment to begin working
    with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Kotlin Android project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting started with Kotlin is really easy, especially after Google has added
    official support for the language. You can use Kotlin directly with Android Studio
    3\. Android Studio 3 is still in Beta version at the time of writing this book.
    The best thing about using Kotlin for Android is that it is interoperable with
    your existing code, be it Java or C++. While working with Kotlin, you will realize
    that code in Kotlin is concise, extensible, and powerful. It really makes Android
    development more fun. Let's see how we can start working in Kotlin by first creating
    a Kotlin project in Android Studio 3.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this recipe, you will need Android Studio installed on your
    computer. Android Studio has both Android SDK and Android Virtual device in it.
    Ensure that you have Java Development Kit installed on your system. You will need
    an android phone or Emulator for debugging your project. You will also need at
    least one Android Virtual Device installed, of your desired specifications if
    you are not using an Android phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically, here''s the checklist of the things that need to be installed
    before you move on to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: Java Development Kit (use the latest)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio 3+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android phone or emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a project in Android Studio is very simple and to create it in Kotlin
    just requires one extra click. Here''s a step-by-step process of doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, in the menu, click on File | New | New Project. Alternatively,
    if you've just opened Android Studio and see the Welcome to Android Studio window,
    click on Start a new Android Studio project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the wizard, add your Application name and Company domain, and simply check
    the box that says Include Kotlin support. Click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e23ddc9d-c1b0-4248-8e32-bf979557e1ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, you will be asked to choose your target devices and the
    minimum SDK support. So basically, it asks things like, "Do you want the application
    to run on both phone and android wear?" and "Do you want to support from Jelly
    Bean up or KitKat and up?":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d8bb3e1-e242-4760-ba2f-f20abf887a58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, you will be prompted to Add an Activity to the project.
    You can also skip this step and add an activity later, but for now, just click
    on a Basic Activity and click on Next. If you have also chosen Wear or any other
    option, you will be prompted to add activity for those components as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f91044d-30db-4b81-8ea1-68c51d218031.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, you will be prompted to **Configure the Activity** you added. Basically,
    what you have to do is to provide **Activity Name, Layout Name,** and **Title**.
    After this, click on Finish, because you are done with creating your first project
    in Kotlin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run project on your device: You need to follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your device to your development machine with a USB cable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable USB debugging on your device by going to Settings | Developer options.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On Android 4.2 and newer, Developer options are hidden by default. To make it
    available, go to Settings | About phone and tap on Build number seven times. Return
    to the previous screen to find Developer options.
  prefs: []
  type: TYPE_NORMAL
- en: Now in your Android Studio, click on the app module in the Project window and
    then select Run (or click on Run in the toolbar).
  prefs: []
  type: TYPE_NORMAL
- en: In the Select Deployment Target window, select your device, and click on OK.
    After a while, you will see the application running on your mobile or an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After clicking on the Finish button in the Create New Project window, Android
    Studio will configure things and create your project. If you added an activity
    as mentioned in Step 4, you will be greeted with the boilerplate code of the activity.
    It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0776d959-584c-41fd-aef4-f9e92cdade26.png)'
  prefs: []
  type: TYPE_IMG
- en: How to use Gradle to run Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gradle** has now become the de facto build tool for Android, and it is very
    powerful. It’s great for automating tasks without compromising on maintainability,
    usability, flexibility, extensibility, or performance. In this recipe, we will
    see how to use Gradle to run Kotlin code.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA because it provides great integration of Gradle
    with Kotlin, and it is a really great IDE to work on. You can also use Android
    Studio for it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will be creating a Kotlin project with the Gradle
    build system. First, we will select the Create New Project option from the menu.
    Then, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f365cbe-4d7e-4147-9b7c-8ab6cb9e8958.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the project with the Gradle build system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31bbd90b-193b-4c21-8e2c-0ff266d2f928.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you have created the project, you will have the `build.gradle` file,
    which will look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create a `HelloWorld` class, which will have a simple main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/297f7877-9347-49c1-9d96-2049609d8a66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it would be really cool to run this code directly. To do so, we will use
    the `gradle run` command. However, before that, we need to enable the application
    plugin, which will allow us to directly run this code. We need to add two lines
    in the `build.gradle` file to set it up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can type `gradle run` in the terminal to execute this file,
    and you will see the output of the method, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96d5b511-9231-47b9-92de-750161d4a402.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default structure of the project, when you create a new project in IntelliJ,
    is as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you want to have a different structure of the project, you should declare
    it in `build.gradle`. You can do it by adding the following lines in `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding `sourceSets` property should be updated if not using the
    default convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Though you can keep Kotlin and Java files under the same package, it’s a good
    practice to keep them separated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check out the *How to build a self-executable jar with Gradle and Kotlin* recipe
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to run a Kotlin compiled class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with the command-line compiler for any language is one of the first
    steps to get a better understanding of the language, and this knowledge comes
    handy at a lot of times. In this recipe, we will run a Kotlin program using the
    command line, and we will also play a bit with the interactive shell of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to perform this recipe, you need a Kotlin compiler installed on your
    development machine. Every Kotlin release ships with a standalone compiler. You
    can find the latest release at [https://github.com/JetBrains/kotlin/releases](https://github.com/JetBrains/kotlin/releases).
  prefs: []
  type: TYPE_NORMAL
- en: To manually install the compiler, unzip the standalone compiler into a directory
    and optionally, add the bin directory to the system path. The bin directory contains
    the scripts needed to compile and run Kotlin on Windows, OS X, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are ready to run our first program using the command line. First, we
    will create a simple application that displays Hello World! and then compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file with the name `hello.kt` and add the following lines of code
    in that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we compile the file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to create a library that can be used with other Kotlin applications;
    we can simply compile the Kotlin application in question into `.jar` executable
    without the `-include-runtime` option, that is, the new command will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check out the Kotlin interactive shell. Just run the Kotlin compiler
    without any parameters to have an interactive shell. Here''s how it looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/094ab1d4-fbc5-4ca7-99a6-ec234218c153.png)'
  prefs: []
  type: TYPE_IMG
- en: Hopefully, you must have noticed the information I am always guilty of ignoring,
    that is, the command to quit interactive shell is `:quit` and for help, it is
    `:help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run any valid Kotlin code in the interactive shell. For example, try
    some of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`3*2+(55/5)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`println("yo")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`println("check this out ${3+4}")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49cfe315-be64-4674-92d7-315f31743215.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `-include-runtime` option makes the resulting `.jar` file self-contained
    and runnable by including the Kotlin runtime library in it. Then, we use Java
    to run the `.jar` file generated.
  prefs: []
  type: TYPE_NORMAL
- en: The `-d` option in the command indicates what we want the output of the compiler
    to be called and maybe either a directory name for class files or a `.jar` filename.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin can also be used for writing shell scripts. A shell script has top-level
    executable code.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin script files have the `.kts` extension as opposed to the usual `.kt`
    for Kotlin applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a script file, just pass the `-script` option to the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to build a self-executable JAR with Gradle and Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is great for creating small command-line utilities, which can be packaged
    and distributed as normal JAR files. In this recipe, we will see how to do it
    using Gradle build system. Gradle build system is one of the most sophisticated
    build systems out there. It is the default build tool for Android and is designed
    to ease scripting of complex, multilanguage builds with a lot of dependencies
    (typical of big projects). It achieves the goal of automating your project without
    compromising on maintainability, usability, flexibility, extensibility, or performance.
    We will be using Gradle build system to create a self-extracting JAR file. This
    JAR file can be distributed to and run on any platform supporting Java.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need an IDE (preferably IntelliJ or Android Studio), and you need to tell
    it where your Kotlin files are present. You can do so by specifying it in the
    `build.gradle` file by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines are required if you have your Kotlin files separated from
    Java packages. This is optional, and you can continue working with Kotlin files
    under Java packages, but it’s a good practice to keep them separated.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be creating a very simple function that just prints `Hello World!` when
    executed. Since it’ll be a simple function, I am just adding it as a top-level
    `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through these steps, with which we can create a self-executable JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a simple class `HelloWorld.kt` having the main function, which
    just prints out “Hello world!”:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to configure a `jar` task, which Gradle build goes through to inform
    it of our entry to our project. In a Java project, this will be the path to the
    class where our `main()` function resides, so you will need to add this `jar`
    task in `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the preceding snippet to `build.gradle`, you need to run the following
    gradle command to create the jar file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The created jar file can be found in the `build/libs` folder. Now you can just
    run the `java -jar demo.jar` command to run the JAR file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you do that, you can see the output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58fe47ee-58b4-4d16-b62f-2510892deaa4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make self-executable JARs, we need a manifest file called `MANIFEST.MF` in
    the `META-INF` directory. For our purposes here, we just need to specify the name
    of the Java class that contains the Java-based extractor program's `main()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One might argue that even though we don’t have top-level class declaration,
    we are specifying it as `HelloWorldKt` in the code for the jar task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The reason for putting the preceding code block in the jar task is that Kotlin
    compiler adds all top-level functions to respective classes for back-compatibility
    with JVM. So, the class generated by Kotlin compiler will have the filename, plus
    the `Kt` suffix, which makes it `HelloWorldKt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the reason we added `from { configurations.compile.collect { it.isDirectory()
    ? it : zipTree(it) } }` in jar task is because we want Gradle to copy all of a
    JAR’s dependencies. The reason for doing so is that, by default, when Gradle (as
    well as Maven) packs some Java class files into a JAR file, it assumes that this
    JAR file will be referenced by an application, where all of its dependencies are
    also accessible in the classpath of the loading application. So, by specifying
    the preceding lines in jar task, we are telling gradle to take all of this JAR’s
    referenced dependencies and copy them as part of the JAR itself. In the Java community,
    this is known as a **fat JAR**. In a fat JAR, all the dependencies end up within
    the classpath of the loading application, so the code can be executed without
    problems. The only downside to creating fat JARs is their growing file size (which
    kind of explains the name), though it is not a big concern in most situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading console input in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many applications, user interaction is a very important part, and the most
    basic way of doing that is reading input entered by the user and giving output
    based on it. In this recipe, we will understand different ways of reading input
    and also provide output in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line to compile and run your Kotlin code,
    for which you need Kotlin compiler installed along with JDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps by which we can read console input in
    Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start simple and move to more advanced logic as we move forward. First,
    let''s start with simply printing a line as output in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will try to take String input from the console and output it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, how about we repeat the process with Int:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try a complicated code and then start with the explanations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a screenshot of compiling and running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7173076-e6a6-40dc-8193-85622cacf09f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to understand the methods by which we were able to read input in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, `Kotlin.io` uses `java.io` for the input-output. So `println`
    is basically `System.out.println`, but with additional power by Kotlin to use
    String templates and `inline` functions, which makes writing extremely simple
    and concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a part of the actual code from Kotlin `stdlib` used for Console IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Converting Java code to Kotlin and vice versa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best part about Kotlin is its interoperability with Java. Also, with IntelliJ-based
    IDE, we can directly convert our Java code to Kotlin. In this recipe, we will
    see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe needs IntelliJ-based IDE installed, which compiles and runs Kotlin
    and Java.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the steps to convert a Kotlin file to a Java file:'
  prefs: []
  type: TYPE_NORMAL
- en: In your IntelliJ IDE, open the Java file that you want to convert to Kotlin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that it has a `.java` extension. Now, in the main menu, click on Code menu
    and choose the Convert Java File to Kotlin File option. Your Java file will be
    converted into Kotlin, and the extension will now be `.kt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Shown here is an example of a Java file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59c2bb9a-cd5e-48d9-9d2a-6b08f5e0c991.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After converting to Kotlin, this is what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77c5efac-a454-4522-9b4d-42f2f6a789d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Kotlin file can be converted into Java, but it''s better if you can avoid
    it or find an alternative way to do it. If you have to absolutely convert your
    Kotlin code to Java, click on Tools | Kotlin | Show Kotlin Bytecode in the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/074a57e3-c2e3-4d03-a6d7-ac39528d9c5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on Show Kotlin Bytecode, a window will open with the title Kotlin
    Bytecode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a11d5e08-d724-4c33-ad89-20f01060d707.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Decompile and a `.java` file will be generated, containing a  decompiled
    Java bytecode from Kotlin code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6636f42-ca0c-40fc-b957-425c4710445a.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, it has a lot of unnecessary code that was not present in the original Java
    code, but that is the case with decompiled bytecode. At the moment, this is the
    only way to convert Kotlin code to Java. Copy the decompiled file into a `.java`
    file and remove the unnecessary code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is a statically-typed programming language that works on Java Virtual
    Machine and compiles into JVM compatible bytecode. This is the reason we can convert
    Java code to Kotlin and mix Java and Kotlin code together.  This is also the reason
    why you can, in a way, get Java code back from Kotlin (although the output is
    not completely desired).
  prefs: []
  type: TYPE_NORMAL
- en: How to write an idiomatic logger in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has some great powerful features packed in it that we should be making
    use of to improve our code. This involves rethinking on our old best practices
    of coding. Many of our old coding practices can be replaced by better alternatives
    from Kotlin. One of them is how we write our logger. Though there are a lot of
    libraries out there that provide logging functionality, we will try to create
    our own logger in this recipe, just by using idiomatic Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDE to write and execute our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the given steps to create an idiomatic logger in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how it was done in Java. In Java, SLF4J is used and considered
    de-facto, so much that logging seems like a solved problem in Java language. Here''s
    what a Java implementation would look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It also works fine with Kotlin, obviously with minor modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, apart from this, we can utilize the power of Kotlin using **Delegates**
    for the logger. In this case, we will be creating the logger using the `lazy` keyword.
    This way, we will create the object only when we access it. Delegates are a great
    way to postpone object creation until we use it. This improves startup time (which
    is much needed and appreciated in Android). So let us explore a method using lazy
    delegates in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use `java.util.Logging` internally, but this works for any Logging library
    of your choice. So let’s use the Kotlin’s lazy delegate to get our logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our class, we can simply call the method to get our logger and use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code, you can see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, as we can see in the output, we get the class name and method name too (if
    you are accessing logger inside a method).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, one thing to note is that we have put our logger inside a companion object.
    The reason for this is quite straightforward because we want to have only one
    instance of logger per class.
  prefs: []
  type: TYPE_NORMAL
- en: Also, `logger()` returns a delegate object, which means that the object will
    be created on its first access and will return the same value (object) on subsequent
    accesses.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anko is an Android library that uses Kotlin and makes Android development easier
    with the help of extension functions. It provides **Anko-logger**, which you can
    use if you don’t want to write your own logger. It is included in *anko-commons*,
    which also has a lot of interesting things to make it worthwhile to include it
    in your Android projects that use Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Anko, a standard implementation of logger will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you just need to implement `AnkoLogger` and you are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each method has two versions: plain and lazy (inlined):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The lambda result will be calculated only if `Log.isLoggable(tag, Log.INFO)`
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To know more about delegated properties, refer to the **Working with delegated
    Properties** recipe in [Chapter 3](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/9cdf4de5-7577-4bd5-ba2d-2bd38740957a.xhtml), *Classes
    and Objects*.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping for Java identifiers that are keywords in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin was designed with *interoperability* in mind. The existing code in Java
    can be called from Kotlin code smoothly, but since Java has different keywords
    than Kotlin, we sometimes run into issues when we call Java method with a name
    similar to Kotlin keyword. There is a workaround in Kotlin, which allows a method
    to be called having a name representing a Kotlin keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you have access to a code editor where you can write and run the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a Java class with a method name equal to any Kotlin keyword. I am using `is` as the
    method name, so my Java class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try calling that method from Kotlin code. If you are using any code editor
    with the autocomplete feature, it automatically encloses the method name in backticks
    (`` ` ` ``):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Similar is the case with other keywords in Kotlin that are qualified identifiers
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Kotlin’s documentation, some of the Kotlin keywords are valid
    identifiers in Java: `in`, `object`, `is`, and so on. If a Java library uses a
    Kotlin keyword for a method, you can still call the method, escaping it with the
    backtick (`` ` ``) character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the keywords in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '| package | as | typealias | class | this | super | val |'
  prefs: []
  type: TYPE_TB
- en: '| var | fun | for | null | true | false | is |'
  prefs: []
  type: TYPE_TB
- en: '| in | throw | return | break | continue | object | if |'
  prefs: []
  type: TYPE_TB
- en: '| try | else | while | do | when | interface | typeof |'
  prefs: []
  type: TYPE_TB
- en: Disambiguating using the "as" keyword to locally rename the clashing entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disambiguation refers to the removal of ambiguity by making something clear. Importing
    a library or a class in code is a daily routine of a programmer. It’s pretty easy
    to import files into the code in every language, thanks to the great code editors
    nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what happens if you try to import two classes into a file? Though
    you should always try to have different names for different classes, sometimes
    it’s unavoidable. For example, in the case of different libraries having the same
    name for their classes. In Java, there is a workaround; you have to use the full
    qualifier, which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Dirty, isn’t it? Now, let’s see how Kotlin addresses it gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that you have a code editor on which you can write and run the code.
    To test things out, you can create two classes with the same name but under different
    packages. Refer to the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34cb1dc3-38b1-47dd-ac11-5a20d76d0d2b.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following steps and examples, we will see how we can disambiguate classes
    of the similar name using Kotlin's keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, you can disambiguate using the `as` keyword to locally rename the
    clashing entity. So in Kotlin, it will look as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, access their methods like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s see the use of the `as` keyword to disambiguate two classes
    having the same name (`SomeClass.kt`), but in different packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SameClass.kt (packageA)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`SameClass.kt (packageB)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`HelloWorld.kt` is the class that uses classes with similar names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Doing bit manipulations in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides several functions (in infix form) to perform bitwise and bit
    shift operations. In this section, we will learn to perform bit-level operation
    in Kotlin with the help of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise and bit shift operators are used on only two integral types—Int and
    Long—to perform bit-level operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the complete list of bitwise operations (available for Int and Long
    only):'
  prefs: []
  type: TYPE_NORMAL
- en: '`shr(bits)`: signed shift right (Java''s >>)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ushr(bits)`: unsigned shift right (Java''s >>>)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and(bits)`: bitwise and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or(bits)`: bitwise or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xor(bits)`: bitwise xor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inv()`: bitwise inversion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's check out a few examples to understand the bitwise operations.
  prefs: []
  type: TYPE_NORMAL
- en: Or
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `or` function compares the corresponding bits of two values. If either of
    the two bits is 1, it gives 1, and it gives 0 if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the explanation of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 = 10 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: 3 = 11 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise `OR` of 2 and 3 that is
  prefs: []
  type: TYPE_NORMAL
- en: in binary
  prefs: []
  type: TYPE_NORMAL
- en: 10 `OR` 11
  prefs: []
  type: TYPE_NORMAL
- en: 11 = 3 (Decimal format)
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `and` function compares the corresponding bits of two values. If either
    of the two bits is 0, it gives 0, if not and both bits are 1, it gives 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 = 10 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: 3 = 11 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise `AND` of 2 and 3
  prefs: []
  type: TYPE_NORMAL
- en: in binary
  prefs: []
  type: TYPE_NORMAL
- en: 10 `AND` 11
  prefs: []
  type: TYPE_NORMAL
- en: 10 = 2 (Decimal format)
  prefs: []
  type: TYPE_NORMAL
- en: xor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `xor` function compares the corresponding bits of two values. If the corresponding
    bits are the same, it gives 0, and if they are different, it gives 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Given is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 = 10 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: 3 = 11 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise `XOR` of 2 and 3
  prefs: []
  type: TYPE_NORMAL
- en: in binary
  prefs: []
  type: TYPE_NORMAL
- en: 10 `XOR` 11
  prefs: []
  type: TYPE_NORMAL
- en: 01 = 1 (Decimal format)
  prefs: []
  type: TYPE_NORMAL
- en: inv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `inv` function simply inverts the bit patterns. If the bit is 1, it makes
    it 0 and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 = 10 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise complement of 2 = 01, but the compiler shows 2’s complement of that
    number, which is the negative notation of the binary number.
  prefs: []
  type: TYPE_NORMAL
- en: 2’s complement of an integer *n* is equal to -(*n*+1).
  prefs: []
  type: TYPE_NORMAL
- en: shl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shl` function shifts the bit pattern to the left by the specified number
    of bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 = 101 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift left by 0 bits = 101
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift left by 1 bits = 1010 (10 in Decimal)
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift left by 2 bits = 10100 (20 in Decimal)
  prefs: []
  type: TYPE_NORMAL
- en: shr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shr` function shifts the bit pattern to the right by the specified number
    of bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this example into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Given here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 = 101 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift right by 0 bits = 101
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift right by 1 bits = 010 (2 in Decimal)
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift right by 2 bits = 001 (1 in Decimal)
  prefs: []
  type: TYPE_NORMAL
- en: ushr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ushr` function shifts the bit pattern to the right by the specified number
    of bits, filling the leftmost with 0s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This is its explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 = 101 (Binary format)
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift right by 0 bits = 101
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift right by 1 bits = 010 (2 in Decimal)
  prefs: []
  type: TYPE_NORMAL
- en: 101 Shift right by 2 bits = 001 (1 in Decimal)
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bitwise operators in Kotlin aren’t built-in operators like in Java, but
    they can still be used as an operator. Why? Look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the method has the `infix` notation, which enables it to be
    called as an `infix` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing String to Long, Double, or Int
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin makes it really easy to parse String into other data types, such as Long,
    Integer, or Double.
  prefs: []
  type: TYPE_NORMAL
- en: In JAVA, `Long.parseLong()`, or the `Long.valueOf()` static method is used,
    which parses the string argument as a signed decimal long and returns a long value,
    and similarly for other data types such as Int, Double, and Boolean. Let’s see
    how to achieve it in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just need a Kotlin editor to write and run your code. We’ll use conversion
    of Long as an example to discuss parsing with string. Conversion to other data
    types is quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To parse the string to a Long data type, we use the `.toLong()` method with
    the string. It parses the string as a Long number and returns the result. It throws
    `NumberFormatException` if the string is not a valid representation of a number.
    Later, we will see examples for this.
  prefs: []
  type: TYPE_NORMAL
- en: Converting String to Long
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example that shows parsing of string to Long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, you will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want to deal with the exceptions, you can use `.toLongOrNull()`.
    This method parses the string as a Long and returns the result, or null if the
    string is not a valid representation of a number.
  prefs: []
  type: TYPE_NORMAL
- en: Converting string to Long using string.toLongOrNull()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will see how we can parse a string using the `.toLongOrNull()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding program, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Converting with special radix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the preceding examples use the base (radix) 10\. There are cases when we
    wish to convert a String to Long but using another base. Both `string.toLong()`
    and `string.toLongOrNull()` can receive a custom radix to be used in the conversion.
    Let''s take a look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string.toLong(radix)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This parses the string as a `[Long]` number and returns the result
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@throws NumberFormatException` if the string is not a valid representation
    of a number'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@throws IllegalArgumentException` when `[radix]` is not a valid radix for
    string to number conversion'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string.toLongOrNull(radix)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This parses the string as a `[Long]` number and returns the result or null if
    the string is not a valid representation of a number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@throws IllegalArgumentException` when `[radix]` is not a valid radix for
    string to number conversion'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing string to Long with special radix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we were parsing strings with radix 10, that is, decimals.
    By default, the radix is taken as 10, but there are certain situations where we
    need different radix. For example, in case of parsing a string into a binary or
    octal number. So now, we will see how to work with radix other than the decimal.
    Though you can use any valid radix, we will show examples that are most commonly
    used, such as binary and octal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**: Since a binary number is made from 0 and 1, the radix used is 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding program, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Octal**: The octal numeral system, or oct for short, is the base-8 number
    system and uses the digits 0 to 7\. Hence, we will use 8 as a radix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding program, this output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Decimal**: The decimal system has 10 numbers in it (0-9); hence, we will
    use 10 as radix. Note that radix as 10 is used by default in the methods without
    the radix arguments (`.toLong() , .toLongOrNull()`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding program, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin uses String’s extension functions such as `.toLong()` and `toLongOrNull()`
    to make things easier. Let’s dive into their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Long`, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, internally, it also calls the `Long.parseLong(string)` Java
    static method, and it is similar to the other data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Short`, it''s the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this for `Int`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For parsing with Radix, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `checkRadix` method checks whether the given `[radix]` is valid radix for
    string to number and number to string conversion.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s quickly see a few other extension functions provided by Kotlin to parse
    String:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toBoolean()`: Returns `` `true` `` if the content of this string is equal
    to the word *true*, ignoring case, and `` `false` `` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toShort()`: Parses the string as a `[Short]` number and returns the result.
    Also, it throws `NumberFormatException` if the string is not a valid representation
    of a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toShort(radix)`: Parses the string as a `[Short]` number and returns the result,
    throws `NumberFormatException` if the string is not a valid representation of
    a number, and throws `IllegalArgumentException` when `[radix]` is not a valid
    radix for the string to number conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toInt()`: Parses the string as an `[Int]` number and returns the result and
    throws `NumberFormatException` if the string is not a valid representation of
    a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toIntOrNull()`: Parses the string as an `[Int]` number and returns the result
    or `` `null` `` if the string is not a valid representation of a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toIntOrNull(radix)`: Parses the string as an `[Int]` number and returns the
    result or `` `null` `` if the string is not a valid representation of a number,
    or `@throws IllegalArgumentException` when `[radix]` is not a valid radix for
    string to number conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toFloat()`: Parses the string as a `[Float]` number and returns the result,
    and `@throws NumberFormatException` if the string is not a valid representation
    of a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toDouble()` : Parses the string as a `[Double]` number and returns the result,
    and `@throws NumberFormatException` if the string is not a valid representation
    of a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using String templates in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin packs great features with commonly used data type String. One of the
    really cool features is String templates. This feature allows Strings to contain
    template expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, you had to use **StrSubstitutor** ([https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html](https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html))
    and a map to go with it. A template expression in Java will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin eases out the pain in writing template expressions and makes it fun,
    concise, and a lot less verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Using String templates, you can embed a variable or expression inside a string
    without string concatenation. So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn how to use String templates:'
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, the template expression starts with a `$` sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The syntax of string templates is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out a few examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the example of a String template with variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding code will be `foo = 5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example of a String template with expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the example of a String template with raw string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw string**: A string consisting of newlines without writing `\n` and arbitrary
    string. It''s a raw string and is placed in triple quotes (`"""`):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the program, the output will be `Bigger number is: 6`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of String template with a variable name is quite straightforward. Earlier,
    we used to concatenate the strings, but now we can just specify the variable with
    the `$`  symbol before it.
  prefs: []
  type: TYPE_NORMAL
- en: When the string template is used as an expression, the expression inside the
    `${..}` is evaluated first and the value is concatenated with the string. In the
    preceding example (String template with raw string), the `${if (a > b) a else
    b}` expression is evaluated and its value, that is 6, is printed with the string.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String templates also come in handy with String properties and functions. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
