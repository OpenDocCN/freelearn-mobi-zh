- en: Chapter 8. Reaching a Wider Audience – Supporting Multiple Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is a mobile operating system that places very few restrictions on hardware.
    Manufacturers are free to create Android devices that are packed with high-end
    hardware such as DSLR-worthy cameras, huge internal memories, and lightning-fast
    CPUs; or they can create more budget-friendly devices that take a no-frills approach
    to hardware. Android screens can also come in all sorts of sizes, shapes, and
    screen densities.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing these devices have in common is that they all run the Android
    operating system—and even in this, Android smartphones and tablets are inconsistent.
    The current Android smartphone and tablet market is made up of lots of different
    versions of the Android operating system—from legacy versions, right through to
    the very latest release of Android. And even if two devices are running exactly
    the same version of Android, there's no guarantee that they'll be exactly the
    same, as manufacturers have a nasty habit of tweaking the Android operating system
    to come up with their own **original equipment manufacturer** (**OEM**) versions.
    A Samsung smartphone running Android 7.0 may not necessarily be the same as a
    Sony smartphone running Android 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility is great for manufacturers who can make their devices stand
    out from the competition by coming up with new and innovative hardware, software,
    and screen configurations. It's also good news for consumers who can shop around
    and find exactly the Android device that's right for them.
  prefs: []
  type: TYPE_NORMAL
- en: But is this good for developers? *Sort of*.
  prefs: []
  type: TYPE_NORMAL
- en: All these variations on hardware, software, and screen configuration mean lots
    of opportunities to innovate and come up with a truly original app. However, it
    also poses a massive challenge, as you'll need to create an app that provides
    a consistent experience across all the different hardware, software, and screen
    configurations that your app might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there's no quick fix. Essentially, the key to creating a flexible
    UI is to provide a wide range of alternate resources that are optimized for all
    the different hardware, software, screen configurations, languages, and region
    settings that your app may encounter, which is arguably the most time-consuming
    part of Android app development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I'm going to cover all the major aspects you need to bear in
    mind, if you're going to create a flexible app that's compatible with as many
    different Android devices as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different versions of Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While most new versions of the Android platform introduce exciting new features
    that you'll be desperate to use in your app, if you're going to reach the widest
    possible audience then you'll also need to support as many older versions of the
    Android platform as possible.
  prefs: []
  type: TYPE_NORMAL
- en: This is a delicate balancing act. Supporting older versions of the Android platform
    takes time and effort, and the further you go, the harder you'll have to work
    to get your app playing nicely with older versions of Android.
  prefs: []
  type: TYPE_NORMAL
- en: If you continue striving to support older and older versions of Android, at
    some point you'll inevitably find yourself compromising your app's UI, functionality,
    and general user experience as you encounter versions of Android that simply aren't
    powerful enough to support the kind of app you originally wanted to create. In
    our recipe app example, we're relying on the device being powerful enough to load
    multiple high-res images whenever the user performs a search. If the user is running
    an older version of the Android operating system, processing these images may
    cause the search results to load more slowly. Although the problem lies with the
    user's device, your typical Android user is far more likely to blame your app
    than their outdated smartphone or tablet.
  prefs: []
  type: TYPE_NORMAL
- en: We could shrink the images or even remove them completely, but would you want
    to try a recipe when you hadn't even seen a photo of the finished product? At
    this point, you should take a step back and ask yourself whether all this time,
    effort, and compromise is really *worth it*.
  prefs: []
  type: TYPE_NORMAL
- en: To identify the point at which supporting older versions of Android becomes
    more trouble than it's worth, you'll need to look at the current Android market—especially
    how many devices are running each version of the Android operating system. Once
    you have this information in front of you, you can make an informed decision about
    the point at which it no longer makes sense to keep supporting the older versions
    of Android.
  prefs: []
  type: TYPE_NORMAL
- en: One source of this information is Google's Dashboard ([http://developer.android.com/about/dashboards/index.html](http://developer.android.com/about/dashboards/index.html)),
    which gives you a percentage of the relative number of devices running each version
    of Android. Just be aware that this information is gathered in a very specific
    way. It's essentially a snapshot of all the devices that visited the Google Play
    store in the previous 7 days. This data is collected from the Google Play app,
    and is not necessarily representative of the current state of the entire Android
    market. It's also worth noting that the Google Play app is only compatible with
    Android 2.2 and higher, so any device running versions of Android lower than 2.2
    aren't included in this data; although according to Google way back in August
    2013, devices running versions lower than Android 2.2 only accounted for about
    1% of devices, so we're talking about a very small percentage here.
  prefs: []
  type: TYPE_NORMAL
- en: Spend some time exploring the Dashboard data, and come to a decision about which
    versions of Android you're going to support and which versions you aren't.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying minimum and target API levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve decided what versions of Android you''re going to support, you
    need to include this information in your project. How you add this information
    will vary depending on the IDE you''re using, so you''ll need to open one of the
    following files:'
  prefs: []
  type: TYPE_NORMAL
- en: Manifest file (Eclipse)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module-level `build.gradle` file (Android Studio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss the components of this file in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: minSdkVersion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This attribute identifies the lowest API level that your app is compatible with,
    for example, `minSdkVersion 16`. Google Play will use your app's `minSdkVersion`
    attribute to determine whether a user can install it on device.
  prefs: []
  type: TYPE_NORMAL
- en: When debating your app's `minSdkVersion` value, make sure you consult the Dashboard
    stats as this provides a snapshot of your potential audience. Ultimately, you'll
    need to decide whether supporting each additional slice of this audience is worth
    additional time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: targetSdkVersion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This attribute identifies the highest API level that you've tested your app
    against.
  prefs: []
  type: TYPE_NORMAL
- en: The `targetSdkVersion` value is particularly important for forward compatibility,
    as the system won't apply any behavior changes introduced in new Android releases
    until you update your app's `targetSdkVersion` value. To ensure your app benefits
    from the latest Android features, you should aim to set your app's `targetSdkVersion`
    value to the very latest version of Android. Updating your app to target a new
    SDK should always be a high priority whenever Google release a new version of
    Android, but you should only do this after thoroughly testing your app against
    the latest SDK release. *Never* blindly update your `targetSdkVersion` value without
    testing it first.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally your `targetSdkVersion` and `compileSdkVersion` value should always
    correspond to the very latest version of the Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: compileSdkVersion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This attribute tells Gradle what version of Android SDK it should compile your
    app with.
  prefs: []
  type: TYPE_NORMAL
- en: Your `compileSdkVersion` value is not included in your published APK; it's purely
    used at compile time. Changing your `compileSdkVersion` value does *not* change
    the runtime behavior, so it's recommended you always compile with the latest SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Check version at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you'll have a clear cut-off point where it makes sense for your app
    to stop supporting earlier versions of Android, but this line may not always be
    so clear cut.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine your app includes a non-essential feature that isn't supported on Android
    5.0 and earlier versions, but apart from this feature, your app is compatible
    with earlier versions of Android. Since this Marshmallow-and-higher feature isn't
    essential, it doesn't make sense to prevent everyone running Android 5.0 or earlier
    versions from installing your app. In this scenario, you can disable this feature
    by ensuring any code that depends on higher API levels is only executed when these
    APIs are available. Basically, this feature won't be available to users who are
    running Android 5.0 or a lower version, but these users will still be able to
    install and use your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'You achieve this using the `Build` constants class to specify when the related
    code should run; for example, the following code verifies whether your app is
    running on Lollipop or a higher version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Android provides a unique code for each platform version, which you should use
    alongside the `Build` constants class (in this example, the code is `LOLLIPOP`).
    You'll find a complete list of these codes at the official Android docs ([http://developer.android.com/reference/android/os/Build.VERSION_CODES.html](http://developer.android.com/reference/android/os/Build.VERSION_CODES.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android devices come in many different shapes and sizes. Your task, as a developer,
    is to create a UI that looks just as good on the small space available to a budget-friendly
    smartphone, as it does on the large space available to a top-of-the-line Android
    tablet and everything in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s break it down. Android categorizes screens in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen sizes**: Traditionally, Android supported four generalized screen
    sizes: `small`, `normal`, `large`, and `xlarge`. However, Android 3.2 (API level
    13) introduced some new configuration qualifiers that allow you to be more specific
    about screen sizes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen densities**: A device''s screen density is a combination of its resolution
    and display size, and is measured in **dots per inch** (**dpi**). The higher a
    device''s dpi, the smaller each individual pixel, which means greater clarity
    and more detail per inch. Android supports six generalized densities: low (`ldpi`),
    medium (`mdpi`), high (`hdpi`), extra high (`xhdpi`), extra-extra-high (`xxhdpi`),
    and extra-extra-extra-high (`xxxhdpi`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can anticipate that your app will be installed on devices spanning a wide
    range of screen sizes and densities. And you should aim high; it's not good enough
    for your app to be compatible with these different screen configurations, you
    should give users the impression that your app was designed specifically for their
    particular screen, whatever size and density that screen happens to be.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'll show you how to create an app that can handle a wide range
    of different sizes and densities. The underlying theme you'll encounter time and
    time again is that your app's layout and drawables must render at a size that's
    appropriate for the current screen. The Android system is clever enough to handle
    most of this rendering work automatically, and it will scale your layouts and
    resources to fit the current size and density, but you shouldn't rely on the Android
    system to do all the hard work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Android's automatic rendering alone won't provide the best possible user experience.
    You'll need to give it a hand by providing multiple versions of your app's resources
    that are optimized for different screen sizes and densities. These resources could
    be strings, layouts, graphics, or any other static resources that your app requires.
  prefs: []
  type: TYPE_NORMAL
- en: To add these resources to your project, you'll need to create alternate versions
    of your project's directories, and then tag them with the correct configuration
    qualifiers; for example, if you have a layout that's optimized for landscape orientation,
    you'll need to create a `res/layout-land` directory, and then place your landscape
    layout file inside this directory. Then, when a user runs your app, the Android
    system will automatically load the resource that best matches the current screen
    configuration, whether that's the default layout or your landscape-optimized `res/layout-land`
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration qualifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android supports a wide range of configuration qualifiers that you can append
    to your project's resource directories. These configuration qualifiers are the
    key to controlling which version of a resource the system displays.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration qualifiers specify the characteristics that a resource was designed
    for, such as an image that was designed for a particular screen size or screen
    density. You'll find a complete list of valid configuration qualifiers in the
    official Android docs, specifically **Table 2** of the **Providing Resources**
    page ([http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources](http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources)).
  prefs: []
  type: TYPE_NORMAL
- en: The configuration qualifiers you'll need to use will vary depending on your
    app and the kind of devices you're targeting, but as a minimum, you'll typically
    use size, density, and screen orientation qualifiers to provide drawable resources
    and layouts that are optimized for different screen configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a configuration qualifier, create a new directory in your project''s
    `res/` directory and name it using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, if you were creating a directory to hold layouts that were optimized for
    devices held in landscape mode, you'd use the `land` qualifier and create a `res/layout-land`
    directory, then place your layout-optimized layouts inside this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never place any resources directly inside your project's `res/` directory as
    this will cause a compiler error. You also cannot nest alternative resources,
    so you cannot create a `res/drawable/drawable-xxhdpi/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: You can use more than one qualifier at a time by separating each qualifier with
    a dash; for example, a `res/drawable-en-hdpi` directory would contain drawable
    resources that are designed for devices set to the English language (`en`) with
    a screen density that falls into the high-density bucket. If you do use multiple
    qualifiers, the order they appear in your directory name is crucial. They must
    appear in the same order as in the **Providing Resources** page ([http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources](http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources)).
    If you use qualifiers in the wrong order, the Android system won't recognize the
    directory, and will subsequently ignore all the resources that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about the case you use for your directory names, as the resource
    compiler converts directory names into lowercase before processing anyway. If
    your project includes directories with long-winded names consisting of multiple
    configuration qualifiers, then you may want to take advantage of this automatic
    conversion, and use capitalization to make your directory names easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Naming is also important for the resources that you place inside your directories.
    When you create multiple versions of the same resource, they must all have exactly
    the same name as the default resource. Any variation and the Android system won't
    recognize them as alternate versions of the same resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your project contains resources that the system should *never* scale to suit
    the current screen configuration, place these resources in a directory with the `nodpi`
    configuration qualifier, for example, `res/drawable-nodpi`.
  prefs: []
  type: TYPE_NORMAL
- en: How Android selects the perfect resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When your app features multiple versions of the same resource, the Android system
    follows a strict set of rules when deciding which version it should display at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When the Android system is looking for a resource based on the screen size or
    density, it starts by searching for an exact match that it can display without
    scaling. If it can't find a suitable size or the density-specific version, then
    Android switches to plan *B* and searches for a version that's designed for screens
    smaller than the current screen.
  prefs: []
  type: TYPE_NORMAL
- en: If the only available resources are larger than the current screen, the system
    will use the default version of the resource instead. The Android system assumes
    that your project's default resources are designed for the baseline screen size
    and density, which is a `normal` size and medium-density. Therefore, the system
    scales default resources up for high-density or larger screens, and down for low-density
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: If the system can't find a suitable density-specific resource, or even a default
    version of the required resource, then your app will crash—which is why it's essential
    that you provide a default version of *every* resource.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you're confident that you've provided all the alternative resources
    your project could ever need, it's possible that your app may wind up on a device
    that has hardware, software, screen size, screen density, or language settings
    that you hadn't anticipated and therefore didn't provide specific resources for.
    In this scenario, the system may fall back on your project's default resources,
    and if your app doesn't include these default resources, then your app will crash.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Default resources are all the resources that are stored in a directory without
    a configuration qualifier, such as `res/drawable`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating alias resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you'll have a resource that's suitable for more than one configuration
    qualifier; for example, you might have a drawable that you want to add to both
    your project's `res/drawable-hdpi` and `res/drawable-xhdpi` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can't create a directory that uses multiple configuration qualifiers of
    the same type, so it's not possible to create a `res/drawable-hdpi-xhdpi` directory.
  prefs: []
  type: TYPE_NORMAL
- en: You could copy/paste the resource so that it appears in both directories; but
    this isn't very efficient, plus duplicating resources increases the size of your
    project, which is bad news for your end users. The best solution is to use an
    **alias**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a `scene.png` drawable that you want to use for both `hdpi`
    and `xhdpi` screens; this is the perfect opportunity to use an alias. In this
    scenario, you need to place the default version inside your project's `res/drawable`
    folder as normal. Then, save the version of the image you want to use for `hdpi`
    and `xhdpi` screens inside the `res/drawable` folder, but give it a different
    name to the default resource, for example, `scenery_alias.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you have two drawables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res/drawable/scenery.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res/drawable/scenery_alias.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, create an XML file inside both of the density-specific directories. Inside
    these XML files, add some code that points toward your project''s `res/drawable/scenery_alias.png`
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the Android system tries to load the scenery resource from `res/drawable-hdpi`
    or `res/drawable-xhdpi`, it'll recognize the alias and display `res/drawable/scenery_alias.png`
    instead. In this way, you can replace memory-hogging and inefficient duplicate
    resources with small XML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the alias function to reuse the same layout resource files
    in multiple directories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a default layout (`main.xml`), and place it in your project's `res/layout`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the layout you want to use across multiple directories. Give this layout
    a different name to the default layout (I'm going to use `main_alias.xml`), and
    place it inside your project's `res/layout` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create XML files in all the directories where you want to use the `layout_alias.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some XML code that references `layout_alias.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although less commonly used, you can also create aliases for strings and other
    simple values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `highlightColor` is now an alias for `yellow`. You can also
    create aliases for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `appTitle` is now an alias for `title`.
  prefs: []
  type: TYPE_NORMAL
- en: Screen density
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing your UI, you should aim to achieve **density independence**.
    This is where the Android system preserves the physical size of your UI elements
    across screens with different densities.
  prefs: []
  type: TYPE_NORMAL
- en: Density independence is *crucial* to providing a good user experience. A high-density
    screen has more pixels per inch, which means the same amount of pixels fits into
    a smaller area. Low-density screens have less pixels, so the same amount of pixels
    fits into a much larger area. If you use absolute units of measure, such as specifying
    UI elements in pixels, then your UI elements are going to appear larger on low-density
    screens and smaller on high-density screens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a common misconception that devices with the same screen resolution automatically
    have the same screen density. Even if two devices have the same screen resolution,
    these screens may be different sizes. This means the screens are displaying their
    content in a different amount of space, which equates to a different number of
    dpi.
  prefs: []
  type: TYPE_NORMAL
- en: If your UI elements change sizes on different devices, then this is going to
    lead to problems in your layout and usability issues, and this will make for a
    generally poor user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you can ensure density independence by specifying your layout
    dimensions in density-independent pixels, and by replacing static, hardcoded sizes
    with more flexible elements such as `"wrap_content"` and `"match_parent"`.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to drawables, Android automatically scales each drawable based
    on the current screen's density, so your drawables render at the appropriate physical
    size for the current device. However, this automatic scaling can result in blurry
    or pixelated images. To make sure your drawables look their very best, you need
    to create alternate versions of each drawable, which are optimized for different
    screen densities.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the Android marketplace includes more screen densities than
    you could *ever* hope to support; and even if you could, providing so many alternate
    drawables would cause the size of your project to balloon out of control, to the
    point where it's unlikely it'd even fit onto your average Android smartphone or
    tablet.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why Android groups screen densities into the following generalized
    **density buckets**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldpi` (low-density): 120dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdpi` (medium-density): 160dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hdpi` (high-density): 240dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xhdpi` (extra-high-density): 320dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xxhdpi` (extra-extra-high-density): 480dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xxxhdpi` (extra-extra-extra-high-density): 640dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step to a flexible layout is to create a directory for each of these
    density buckets, for example, `res/drawable-ldpi`, `res/drawable-mdpi`, and so
    on. Then, just create a version of each resource that targets these different
    density buckets, and the Android system will handle the rest.
  prefs: []
  type: TYPE_NORMAL
- en: To create optimized drawables for each density bucket, you need to apply the
    3:4:6:8:12:16 scaling ratio across the six generalized densities. For the best
    results, start by creating a version of the image at the largest supported density,
    and then scale this graphic down proportionally for each subsequent density bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time, creating a graphic at the largest supported density means
    creating an image for the `xxhdpi` density bucket and *not* the `xxxhdpi` bucket.
    This is because the `xxxhdpi` directory is reserved for launcher icons.
  prefs: []
  type: TYPE_NORMAL
- en: Converting dpi into pixels and vice versa
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since different screens have different pixel densities, the same number of pixels
    will translate into different physical sizes on different devices. Pixels aren't
    a density-independent unit of measurement, so 40 pixels isn't the same size on
    every device.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, you should never use absolute pixels to define distances or
    sizes. Occasionally, you may need to convert dpi values into pixel values and
    vice versa. You do this using the following formula: *dpi = (width in pixels *
    160) / screen density*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android uses `mdpi` (160dpi) as its baseline density where one pixel neatly
    equates to one density-independent pixel. This is where the 160 value in the formula
    comes from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this with some numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may also want to use an online converter ([http://jennift.com/dpical.html](http://jennift.com/dpical.html))
    to play around with dpi values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to convert a dpi value into pixels, then use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Providing different layouts for different screen sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android supports a wide range of screen sizes, and it automatically resizes
    your UI to fit the current screen. As I've already mentioned, you shouldn't rely
    on the Android system to do all the hard work for you, as this autoscaling often
    doesn't make the best use of the space available on larger screens, particularly
    tablet-sized devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you thoroughly test your app across a range of different screen sizes using
    the emulator and multiple **Android Virtual Devices** (**AVDs**), you may encounter
    your app struggling to display or function correctly on certain screens. For example,
    you may discover that Android's automatic scaling makes your UI look cramped once
    the device's screen dips below a certain dpi value; or at the other end of the
    scale, you may find that your UI has large areas of empty space on larger, tablet-sized
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: If your UI is having problems with certain screen sizes, you should create layouts
    that are optimized for these screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for providing alternate layouts is the same as providing any alternate
    resource: create directories that have the appropriate configuration qualifiers.
    Then, create layout resource files that are optimized for specific screen sizes,
    and make sure these layouts have the same name as the corresponding default layout.
    The Android system will then select the appropriate layout based on the current
    screen configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the screen size configuration qualifiers aren't as straightforward
    as the density configuration qualifiers, as Android 3.2 introduced some new configuration
    qualifiers that allow you to define the specific width and/or height required
    by each of your layouts, in dpi units. These new configuration qualifiers give
    you greater control over your resources, but they are a bit more difficult to
    get your head around.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to version 3.2, Android supported screen-size groups: `small`, `normal`, `large`,
    and `xlarge`. In order to accommodate a greater variety of screen sizes, the Android
    team replaced these groups with new configuration qualifiers. This chapter focuses
    on the new configuration qualifiers, but if you want to find out more about the
    now-deprecated screen size groups, you can find more information at the official
    Android docs at ([http://developer.android.com/guide/practices/screens_support.html](http://developer.android.com/guide/practices/screens_support.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: These powerful new qualifiers are discussed in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: smallestWidth – sw<N>dp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, you use the `smallestWidth` qualifier to define the minimum
    width in dpi that must be available before the Android system can use a particular
    layout. For example, if your layout requires a minimum of 700dpi, the `smallestWidth`
    configuration qualifier would be `sw700dp`. In this scenario, you'd create a `res/layout-sw700dp`
    directory and place your layout inside. The system will only use this layout when
    the current device has at least 700dpi of available width.
  prefs: []
  type: TYPE_NORMAL
- en: This qualifier is particularly useful as width is often a major factor when
    designing your layouts. Many apps scroll vertically, but it's pretty rare to encounter
    a UI that scrolls horizontally. Most apps have strict constraints about the minimum
    space they need horizontally, and this configuration qualifier gives you a way
    of specifying that minimum as a dpi value.
  prefs: []
  type: TYPE_NORMAL
- en: A device's width is a fixed characteristic that doesn't change when the user
    switches between portrait and landscape mode. The user's perception of their screen's
    width and height may change, but the system's perception of a device's `smallestWidth`
    never does, even when users switch their device from portrait to landscape mode
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Available screen width – w<N>dp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, your app may need to react to how much width or height is currently
    available, which means taking the device's current orientation into consideration.
    For example, imagine your UI has the option to display two fragments side by side
    in a multi-pane layout. If the user is viewing your app in landscape mode, it
    makes sense to display the multi-pane layout, but as soon as the user switches
    the device into portrait mode, there may no longer be enough width available to
    display these fragments side by side.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `sw<N>dp` configuration qualifier comes in. You can use this
    qualifier to set the minimum width a resource requires, for example, `res/layout-w700dp`.
    However, unlike the `smallestWidth` qualifier, `w<N>dp` represents the width that's
    currently available to your UI, taking into account the current screen orientation.
    This allows your app to react to the width currently available to it and not just
    the device's fixed `smallestWidth` value.
  prefs: []
  type: TYPE_NORMAL
- en: Available screen height – h<number>dp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As already mentioned, your typical Android app is pretty flexible about the
    minimum height it needs. However, if you do need to specify the minimum screen
    height a layout or resource needs, you can use the `h<number>dp` qualifier, for
    example, `res/layout-h720dp`.
  prefs: []
  type: TYPE_NORMAL
- en: The value the system assigns to the screen height changes when the screen's
    orientation changes, so similar to `w<N>dp`, you can use this qualifier to detect
    whether your app is currently being viewed in portrait or landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: While using these new configuration qualifiers may appear more complicated than
    using the traditional screen size groups, they do give you more control over how
    your UI translates across different screens, and they allow you to specify the
    exact point at which your app switches from a layout that's optimized for Android
    smartphones, to a layout that's optimized for tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all versions of Android support all qualifiers, for example `sw<N>dp` was
    introduced in API level 13\. However, when you use a qualifier in your project,
    the system automatically and implicitly adds the platform version qualifier, so
    older versions of Android can at least recognize unsupported qualifiers and subsequently
    ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for different screen orientations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may also want to create versions of your layouts that are optimized for
    landscape and portrait orientations. You can provide layouts that are optimized
    for alternate orientations in the same way you provide layouts for different screen
    sizes and densities: you create an extra directory with the correct orientation
    qualifier and place your orientation-specific layouts inside that directory.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Android supports two orientations—portrait and landscape—you only
    ever need to create one additional directory, since you'll use your project's
    default `res/layout` directory for one of these orientations.
  prefs: []
  type: TYPE_NORMAL
- en: Choose which orientation you want to use as your app's default, and then create
    a directory for the other orientation, so your project may consist of a `res/layout`
    directory that contains your default/portrait layouts and a `res/layout-land`
    directory which contains your project's landscape layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you want to use landscape orientation as your project''s
    default, create a `res/layout-port` directory and use `res/layout` for your project''s
    landscape layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing for different screen orientations](img/B05061_8_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it's time to test your app, make sure you test it in both landscape and
    portrait mode across a range of screen configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to orientation changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, your app will need to register configuration changes and then modify
    its behavior accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common scenarios is reacting to whether the screen is in landscape
    or portrait mode. For example, imagine your app consists of two fragments: one
    fragment displays a list and the other fragment displays information about the
    currently-selected item. The app displays each fragment separately on smaller
    screens in a single-pane layout and side by side on larger screens in a multi-pane
    layout. When the user selects an item in the multi-pane layout, the information
    is displayed in the same activity. However, when the user selects an item in the
    single-pane layout, your app will need to display this information in a new activity.
    In this scenario, your app needs to know what layout the user is currently viewing
    (single or multi-pane), so it can react accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One method is to identify a view that''s only visible in the multi-pane layout,
    and then query whether this view is currently visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve the device''s current configuration using `getConfiguration()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the device''s current screen orientation and act on the results,
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Testing across multiple screens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before publishing your app, you should thoroughly test it across all supported
    screen sizes and screen densities, in both landscape and portrait mode. Unless
    you happen to have access to a bunch of different Android smartphones and tablets,
    the most practical way is to use the emulator that comes as part of the Android
    SDK.
  prefs: []
  type: TYPE_NORMAL
- en: When you launch the **AVD Manager** and select **Create Virtual Device...**,
    you can choose from a wide range of ready-made **Android Virtual Devices** (**AVDs**)
    that are based on real-life devices, or you can create your own by selecting **New
    Hardware Profile**. When creating a new AVD, you can then choose whether your
    AVD supports landscape and/or portrait mode, but you should typically test your
    app in both landscape and portrait orientation on *every* AVD you create.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also enter the screen size and resolution of your choice. As you enter
    these settings, you''ll see the **Density** of this particular device displayed
    in the window''s right-hand pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing across multiple screens](img/B05061_8_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To test your app's screen support, you'll need to create multiple AVDs that
    represent all the most common Android screen configurations. There's no shortcut
    here, and generally speaking, the more time you spend testing your app, the better
    the user experience will be, regardless of the device it winds up on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'll be using the emulator that comes as a part of the Android SDK throughout
    this book, but if you're not a fan of this default emulator, there are alternatives
    available. One popular alternative is Genymotion ([https://www.genymotion.com](https://www.genymotion.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Showing off your screen support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it's finally time to prepare your app's Google Play listing, you should
    use screenshots that show your app in the best possible light. Ideally, you should
    take all your screenshots on a large, high-density screen that's running the very
    latest version of Android, so potential users can see the most impressive version
    of your UI.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to create promotional images for your website, blog, social media
    accounts, or anywhere else, then you should place your screenshots in context
    by wrapping them in device artwork. The easiest way to do this is using Android's
    drag-and-drop **Device Art Generator** ([http://developer.android.com/distribute/tools/promote/device-art.html](http://developer.android.com/distribute/tools/promote/device-art.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Attracting an international audience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your Android app has the potential to reach a worldwide audience, but *only*
    if you invest time and effort into localizing your app.
  prefs: []
  type: TYPE_NORMAL
- en: Your biggest task when localizing a project is translating its text into your
    target language, but you'll also need to translate any drawables that contain
    text, any video that features text or dialogue, and audio that contains dialogue.
    You'll also need to ensure that any numbers, currency, times, or dates are formatted
    correctly for your target audience, as formatting can vary between languages and
    countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You provide these alternate resources in the same way you provide any other
    resources: create new directories and use an appropriate configuration qualifier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to localization, you''ll need to use *locale* configuration qualifiers,
    which consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A language code**: These are two-letter lowercase ISO codes, as defined by
    ISO 639-1 ([https://en.wikipedia.org/wiki/ISO_639-1](https://en.wikipedia.org/wiki/ISO_639-1)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Country or regional code (optional)**: Two-letter uppercase ISO codes as
    defined by ISO 3166-1 ([https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3))
    and proceeded by a lowercase `r`. You can use country/region codes in combination
    with the language code to provide resources that target devices set to a particular
    language and located in a specific country or region. For example, you could provide
    resources for French speakers located in Canada by combining the language code
    (`fr`) with the regional code (`CA`) plus a lowercase `r`, so your directory would
    be `res/values/fr-rCA`. You can''t use a country or regional code on its own;
    it must always be preceded by a language code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it's tempting to think of a locale as being synonymous with a country,
    this isn't always the case. While you may create a directory that uses the French
    language and country code, you can also create a directory that combines the French
    language code with the Canadian country code.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the target languages and regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to localizing your app is to identify the languages, regions,
    and countries you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put your business head on and look for locales where there''s a potential market
    for your app. In particular, you should look for languages, regions, or countries
    where:'
  prefs: []
  type: TYPE_NORMAL
- en: There's a large or growing number of Android users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: International languages, such as English, aren't widely used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a gap in the market for an app of your genre or subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding factors mean that localizing your app for this locale could
    be particularly lucrative.
  prefs: []
  type: TYPE_NORMAL
- en: Decide what countries or regions you want to target first, and then determine
    what language(s) your app needs to support in order to appeal to people in this
    part of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a list of all the locales you're going to support, grab their
    language codes from ISO 639-1 ([https://en.wikipedia.org/wiki/ISO_639-1](https://en.wikipedia.org/wiki/ISO_639-1)),
    plus any necessary region or country codes ([https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)).
  prefs: []
  type: TYPE_NORMAL
- en: Providing alternate text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since translating your app's text is usually the biggest localization task,
    we're going to tackle this first.
  prefs: []
  type: TYPE_NORMAL
- en: Open your project's `res` folder and create all the alternate `values` directories
    your app needs to support your target locales. So, if you wanted your app to support
    the Spanish language, you'd create a directory called `res/values-es`. If you
    wanted to provide Spanish text that targets Spanish-speakers in Mexico, you'd
    create a `res/values-es-Rmex` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `strings.xml` files inside each of these directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing alternate text](img/B05061_8_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Place all your translated string resources inside the corresponding `strings.xml`
    file (we'll look at some options for getting your text translated in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our Spanish theme, our `res/values-es/strings.xml` file may
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, the Android system logs the device's locale settings, checks your
    project for any suitable locale-specific resources, and then loads either the
    resources from the corresponding locale-specific directory or falls back on your
    project's default resources.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Keep your text separate from your application code**'
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice to keep the localized aspects of your app separate from your
    application code and to *never* hardcode any text into your app, as this will
    make your text far more difficult to localize. Instead, declare all your text
    as string resources, as it's easy to extract strings from your project, send them
    to a translator, and then integrate them back into your app without making any
    changes to your compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: What other resources might you need localizing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A large part of the localization process is translating your project''s text,
    specifically its sting resources, but you may also want to provide locale-specific
    versions of other resources. For example, you may want to provide translated versions
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawables that feature text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video that contains text or dialogue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio that features dialogue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also want to provide alternate versions of resources that aren't appropriate
    for the locale you're targeting. For example, you may want to provide alternatives
    to scenes that feature a particular city or scenery if this image isn't representative
    of the locale you're targeting. Sun-drenched beaches and crystal-clear seas aren't
    your typical scenery in every country (unfortunately).
  prefs: []
  type: TYPE_NORMAL
- en: You should also be aware that some images maybe considered inappropriate or
    offensive in certain cultures.
  prefs: []
  type: TYPE_NORMAL
- en: You provide locale-specific versions of any resource in exactly the same way
    you provide alternate string resources; create a new directory and use the same
    combination of the language and country/region code. For example, if you wanted
    to provide multiple versions of a `typical_highshcool.jpg` drawable, you'd create
    multiple drawable folders, such as `res/drawable-ja-rJPN`, `res/drawable-en-rUSA`,
    and `res/drawable-sv`.
  prefs: []
  type: TYPE_NORMAL
- en: Why default resources are important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to ensuring that your app runs correctly on devices with any language,
    country, or region settings is to provide a complete set of default resources.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important default resources you need to provide is `res/values/strings.xml`.
    This is where you'll define every string resource used throughout your project
    in your app's *default language*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default language is the language that's spoken by the majority of your target
    audience. This may not necessarily be your audience's first language.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't provide a default version of every string resource, then your app
    will crash whenever it winds up on a device with locale settings that you haven't
    provided a specific string resource for. Even if the user doesn't understand your
    app's default language, this is still preferable to your app crashing or refusing
    to open.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to provide a default version of every other locale-specific
    resources you use in your app, because if your project is missing one default
    resource, then it may not run on devices with unsupported locale settings.
  prefs: []
  type: TYPE_NORMAL
- en: Default string resources are also crucial when there's some text you want to
    keep consistent across your app, regardless of the device's locale settings. One
    common example is your app's title, which you may want to keep consistent across
    all versions of your app.
  prefs: []
  type: TYPE_NORMAL
- en: To use text consistently across locales, you just need to define the string
    once in your project's default `strings.xml` file, and then omit it from all your
    locale-specific `strings.xml` files. Then, when the system tries to load your
    app's title from a locale-specific strings file, it'll realize that this string
    is missing and fall back on the default version. The end result is that the same
    string resource will be used in every version of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Should I translate my app''s title?**'
  prefs: []
  type: TYPE_NORMAL
- en: There's no straightforward answer to this tricky question. Having multiple titles
    makes an app more difficult to maintain, and it can make usually straightforward
    decisions more complex; if your app goes by multiple names, then what should your
    app's Twitter handle be? Do you need to create multiple versions of your app's
    logo and app icon? Do you need to create multiple support e-mail addresses?
  prefs: []
  type: TYPE_NORMAL
- en: You'll also have to work much harder to promote a product that goes by several
    different names, particularly when it comes to things such as **Search Engine
    Optimisation **(**SEO**).
  prefs: []
  type: TYPE_NORMAL
- en: Despite all these drawbacks, there are a few good reasons why you might want
    to publish your app under multiple names. The most common reason is that your
    app's title may not make much sense to people who aren't fluent in your app's
    default language. If we decided to call our recipe app Best Student Recipes, English-speaking
    users would instantly know what to expect, but for users who speak different languages,
    *best student recipes *could be completely meaningless. A nonsensical title isn't
    particularly appealing to potential users who stumble across your app in the Google
    Play store, so you may want to consider releasing your app under multiple names.
  prefs: []
  type: TYPE_NORMAL
- en: There's no real right or wrong answer here. All that matters is that you make
    the best decision based on the app you're developing and your target locales.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever decision you do make, make sure you stick to it! Changing your app's
    name after you've launched it is only going to confuse your users.
  prefs: []
  type: TYPE_NORMAL
- en: Which configuration qualifiers are the most important?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we''ve covered quite a few different configuration qualifiers:
    locale-specific qualifiers, screen orientation, screen density, and screen size
    qualifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a mixture of these in your projects, there''s a strong possibility
    that more than one version of a resource is going to be suitable for the current
    device. Imagine your app winds up on a device with a high-density screen and Spanish
    language settings, and that''s currently being held in landscape mode. The system
    needs to display a drawable, but multiple versions of this drawable are suitable
    for the current device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res/drawable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res/drawable-es`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res/drawable-land`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res/drawable-hdpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which drawable will the system use? When Android is spoilt for choice, it follows
    a strict set of rules. Of all the qualifiers you can use, locale almost always
    gets preferential treatment. In this example, the device is configured to use
    Spanish, so Android would load the graphic from the `res/drawable-es` directory *even
    though* the device in question also has a high-density screen and is currently
    in landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only qualifiers that take precedence over locale qualifiers are **mobile
    country codes** (**MCC**) and **mobile network codes** (**MNC**). If you use any
    of these codes in your project's directories, they'll always take precedence over
    your locale qualifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your app translated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Translating your app's resources is a crucial part of the localization process,
    and unless you're fluent in the language that you're targeting, at some point
    you'll need to enlist the help of a translator, whether that's a paid professional
    or a kind volunteer.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may be tempted to go down the quick and easy route of a machine
    translator, services such as Google Translate can never compare to a human translator,
    and relying on machine translators will almost always result in a bad experience
    for your international users.
  prefs: []
  type: TYPE_NORMAL
- en: If you do decide to hire a professional translator, you should start contacting
    translators as early as possible, so you can get an idea of turnaround time and
    incorporate this information into your development plan. It also gives you time
    to shop around and find the best possible translator for your budget.
  prefs: []
  type: TYPE_NORMAL
- en: You can find translators online, or you may want to explore the Google Play
    app Translation service, which is offered through Developer Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these services, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Developer Console ([https://play.google.com/apps/publish](https://play.google.com/apps/publish)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you haven't already done so, upload your APK by selecting **Add new application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've uploaded your app, it'll appear in your **All Applications** dashboard.
    Select the app you want to purchase translation services for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure **APK** is selected in the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **APK Translation Service**, select **Start**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the source language used in your original text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Translate API**, add the XML source file that contains the strings that
    you want to translate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your target languages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a translation vendor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just be aware that even though you're making a purchase through the Developer
    Console, this is a direct business agreement between you and your chosen vendor,
    so you'll need to work with the translator directly. After purchasing a translation
    through the Developer Console, you will receive an e-mail from your vendor, and
    it's your responsibility to manage the project from there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the most out of your translations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The quality of your translations depends on the skill of the translator, but
    it also depends on the quality of your input. If you provide your chosen translator
    with a higher quality input, then it stands to reason that you're going to get
    a higher quality output.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'll show you how to increase your chances of receiving a high
    quality, accurate translation.
  prefs: []
  type: TYPE_NORMAL
- en: Putting your strings in context
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you're declaring your string resources, you should provide as much information
    about each string as possible, as this will help your translator to better understand
    your string resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very least, you should give each string a descriptive name, but ideally
    you should also supply a comment that explains what this string is for, along
    with the information about when and where the string will appear in your app,
    plus any restrictions such as the maximum amount of characters this part of your
    UI can display. For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If your app features any specialist language or technical terms, then you should
    thoroughly explain what each term means. If this turns out to be too much text
    to fit into a comment, or you find yourself explaining multiple strings, then
    you may want to create a separate glossary document that explains the meaning
    and use of all the specialist terms used throughout your `strings.xml` file. You
    can then send this additional document to the translator along with your strings.
  prefs: []
  type: TYPE_NORMAL
- en: Using terms consistently
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can greatly increase your chances of a successful and accurate translation
    by using terms consistently throughout your app. For example, if the main method
    of navigating your app is via a series of buttons that allow the user to progress
    to the next screen, you should label these buttons consistently, instead of using
    a mix of terms that all mean the same thing, such as **Forward**, **Next**, **OK**,
    and **Submit**. This will make the translator's job much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using terms consistently will improve your app's general user experience too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your strings in order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To help the translator make sense of your project's string resources, you should
    take a few moments to perform some admin on your `strings.xml` file. Remove any
    unused strings that you might have added early on and then never actually used
    in your project, and remove the strings that have disappeared from your project
    over time. You should also remove any duplicate strings, and be on the lookout
    for any spelling mistakes or typos. Finally, make sure your strings are formatted
    correctly and consistently. This housekeeping may seem simple, but it can make
    your translator's job much easier, particularly if they're not an Android developer
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Not creating unnecessary strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: More strings mean more work! Even if you're supporting several languages, you
    probably won't need to create a locale-specific version of every string in every
    language your app supports.
  prefs: []
  type: TYPE_NORMAL
- en: There may be pieces of text that you want to use consistently across all locales,
    such as your app's title, which means there's no need to add this string to every
    locale-specific `strings.xml` file. Remember, if you don't include a particular
    string in a locale-specific directory, your app will use the default string instead.
  prefs: []
  type: TYPE_NORMAL
- en: Your app may also support languages that are variations of the same parent language.
    For example, imagine your app's default language is British English, but it also
    supports American English. Chances are that most of the resources you define in
    your project's `res/values/strings.xml` file will be suitable for your American
    English audience. You should still create a `res/values-en-rUSA/strings.xml` file,
    but this file should only contain the strings where American English spelling
    differs from British English spelling.
  prefs: []
  type: TYPE_NORMAL
- en: Always marking non-translatable text
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your project may include some string resources that you don't want translating,
    such as your app's title, URLs, promotional codes, social media links, and e-mail
    addresses. You should clearly mark all the text you don't want translating before
    handing your project over to the translator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the `<xliff:g>` tags around the text that you don''t want translating,
    and use an `id` attribute to explain why this text shouldn''t be translated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you want to display a welcome message that includes your app''s title.
    You want the actual welcome text to be translated, but you want the app''s title
    to remain consistent across all locales. In this scenario, you''d use the following
    XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to prevent your project from throwing an error, you need to update
    the resources tag in your `strings.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Marking dynamic values as non-translatable**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you'll want to combine some predetermined and dynamic text in a single
    string. For example, your app could ask the student for their name, take their
    input, combine it with some of the predetermined text, and then display the **Welcome
    to the Student Recipe app, Nicole!** message.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does this have to do with translation? When you create strings that
    feature dynamic text, you represent the dynamic text with a placeholder, such
    as follows: `<string name="name">Welcome to the app %1$s</string>`'
  prefs: []
  type: TYPE_NORMAL
- en: You should make it clear to your translator that this placeholder isn't an error
    or typo, and therefore, they shouldn't try to translate it. This becomes particularly
    important when you're working with a translator who isn't familiar with Android
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it clear that a placeholder shouldn''t be translated, you can use the
    regular `<xliff:g>` tags and the `id` attribute. However, for the sake of clarity,
    you should also provide an example of the kind of content this placeholder text
    might eventually display. In our welcome message example, this looks something
    like the following: `<string name="welcomeMessage">Welcome to the Recipe App<xliff:g
    id="userName" example="Nicole">%1$s</xliff:g>!</string>`'
  prefs: []
  type: TYPE_NORMAL
- en: Other things to consider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although language may be the most obvious factor, there are several less obvious
    things you need to take into consideration if your app is really going to make
    a splash on the international market.
  prefs: []
  type: TYPE_NORMAL
- en: Right to left support
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Don't automatically assume that your audience will read left to right (LTR).
    In some countries, reading right to left (RTL) is the norm. Depending on the locales
    you're targeting, you may want to consider implementing support for RTL and LTR.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that in Android 4.2 and higher, the system automatically mirrors
    your app's UI when the user switches the system language to a right-to-left script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of this automatic mirroring, open your project''s `Manifest`
    file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change all your app''s `left/right` layout properties to the `start/end`
    equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: If you're targeting Android 4.2 and higher, use `start` and `end` instead of `left`
    and `right`, for example, `android:paddingRight` becomes `android:paddingEnd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're targeting versions of Android lower than 4.2, you should use `start`
    and `end` in addition to `left` and `right`; for example, you should use both `android:paddingRight`
    and `android:paddingEnd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keep in mind that not every locale formats values, such as dates and numbers,
    in the same way. You should *never* hardcode formats based on assumptions about
    the user's locale as this can cause problems when the user switches to another
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, always use the system-provided formats and utilities such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: DateUtils ([http://developer.android.com/reference/android/text/format/DateUtils.html](http://developer.android.com/reference/android/text/format/DateUtils.html))
    and DateFormat ([http://developer.android.com/reference/java/text/DateFormat.html](http://developer.android.com/reference/java/text/DateFormat.html))
    for dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String.format ([http://developer.android.com/reference/java/lang/String.html#format(java.lang.String,%20java.lang.Object](http://developer.android.com/reference/java/lang/String.html#format(java.lang.String,%20java.lang.Object...))
    or DecimalFormat ([http://developer.android.com/reference/java/text/DecimalFormat.html](http://developer.android.com/reference/java/text/DecimalFormat.html))
    for numbers and currency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhoneNumberUtils ([http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html](http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html))
    for phone numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localizing your app – best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Localizing your app is a powerful way of attracting potentially *millions* more
    users. Why limit yourself to just one market? Implementing the following best
    practices will increase your app's chances of connecting with a worldwide audience.
  prefs: []
  type: TYPE_NORMAL
- en: Design a single set of flexible layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the languages that you choose to support, some of your alternative
    string resources may expand or shrink dramatically during the translation process
    to the point where they no longer fit your layout.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the chances of this happening in your app, you should create flexible
    layouts that can accommodate alternate string resources of all sizes. One useful
    trick is to give your app's default text more space than it requires, so your
    UI already has some wiggle room when it comes to accommodating slight variations
    in size.
  prefs: []
  type: TYPE_NORMAL
- en: You should design UI elements that contain text to be able to expand horizontally
    and vertically in order to accommodate minor changes in text height and width,
    for example, buttons that can grow and shrink depending on the size of their button
    labels. However, you should also consider how these expanding and shrinking UI
    elements might impact the rest of your UI. Could an expanding button make your
    UI look cramped or lopsided? Or worse, could it push the neighboring buttons off
    the screen, rendering them unreachable?
  prefs: []
  type: TYPE_NORMAL
- en: Pay particular attention to UI elements that the user can interact with, such
    as buttons; if these elements change size, it can quickly impact your user experience.
    Two touchable objects that inch closer to one another as they expand can result
    in frustrated users who keep catching the wrong button by accident.
  prefs: []
  type: TYPE_NORMAL
- en: If you design your layouts with flexibility in mind, then typically you'll be
    able to use the same layout across all locales. However, if you're struggling
    to design a layout that's flexible enough to accommodate all your alternate strings,
    you may want to make some changes to your text.
  prefs: []
  type: TYPE_NORMAL
- en: Simple, straight-to-the-point text typically means less variation during the
    translation process, so if you're struggling with text that shrinks or expands
    dramatically, start at the root of the problem—your app's default text. Look for
    any opportunities to simplify this text, any unnecessary text you can remove from
    your UI, plus any words that you can replace with a universally understood picture
    or symbol, such as replacing the **OK** text with a checkmark or **Cancel** with
    a cross**.**
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simplifying your app's text and removing any words that aren't strictly necessary
    will provide a better user experience all round, regardless of whether the user
    is viewing a localized version of your app or accessing your app in its default
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the amount of text you need to display and the locales your app
    supports, it may be impossible to create a single layout that can accommodate
    text across *all* your target languages. Layouts can only flex so far after all!
  prefs: []
  type: TYPE_NORMAL
- en: As a final resort, you can create alternate layouts specifically for the language
    (or languages) that are causing your app so many problems, which leads onto the
    next point.
  prefs: []
  type: TYPE_NORMAL
- en: Create alternate languages only when needed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a layout that targets a specific language by creating a new layout
    directory with the relevant configuration qualifier. For example, if you wanted
    to create a version of your project's `main.xml` layout that's optimized to display
    your tricky German translations, you'd create a `res/layout-de/main.xml` directory,
    and then place your German layout resource file inside this directory.
  prefs: []
  type: TYPE_NORMAL
- en: However, alternate layouts do make your app harder to maintain, so only use
    them as a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your app across different locales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've created all your locale-specific layouts and resources, you need
    to make sure that your app really is ready for an international audience. This
    means testing the localized versions of your app across a wide range of AVDs with
    localization settings that correspond to your different target locales, plus at
    least one AVD that's set to a language and locale that your app *doesn't* explicitly
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'When testing your app across different locales, be sure to check for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Your project is displaying the correct string resources, layouts, and any other
    locale-specific resources for the device it's currently installed on. Placing
    a `strings.xml` file in the wrong directory and missing a configuration qualifier
    or even a simple typo is all it takes for your app to display Korean text (`res/values-ko/strings.xml`)
    when it should really be displaying Kurdish text (`res/values-ku/strings.xml`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your locale-specific resources are displaying correctly in the current layout
    and aren't causing any usability problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should also be aware that some screen configurations, hardware, and software
    may be more common in certain locales. Make sure you research the most popular
    devices in all your target locales to see whether you need to incorporate support
    for specific hardware, software, or screen configurations into the localized versions
    of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for different locales
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can test your app's language settings on a physical device by opening that
    device's **Settings** app, selecting **Language**, and then choosing a new language
    from the menu. This is useful for getting an idea of how the localized version
    of your app functions across devices with different language settings. However,
    you should also test how your app functions with different country and region
    settings, something you can't easily change on a physical Android device, which
    is where AVDs come in.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can't create an AVD with specific language, locale, or region settings,
    you can change these settings once you have an AVD up and running in the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating an AVD with the screen configuration, hardware, and software
    settings you want to test your app against, and launch your project in this AVD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Mac terminal or Windows command prompt and **change directory** (`cd`)
    so it''s pointing at the directory where the**Android Debug Bridge** (`adb`) is
    located. For example, the command I''m using is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once your AVD is up and running, you can change its locale by issuing adb commands.
    To do this, you'll need the ISO code of the language you're targeting (`ISO 639-1`),
    and any country or region code (`ISO 3166-1`) you're using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `adb` window, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few moments, you will see a `#` prompt. At this point, you can enter
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you wanted to test your app on a device that''s set to Spanish
    (`es`), you''d run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to check your app on a device that''s set to use the Spanish
    language in the Mexican locale, you''d run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the emulator will restart with the new locale settings. Relaunch
    your app and that's it—you're ready to test your app against your new locale settings.
  prefs: []
  type: TYPE_NORMAL
- en: Look for common localization issues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So, once you've set up your test environment, what *specific* issues should
    you be looking for?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you should check every screen in your app to make sure there's no instances
    of clipped text, poor line wrapping, strange-looking word or line breaks, or incorrect
    alphabetical sorting. You should also be aware of any locales where the text should
    run RTL and check that this is actually what's happening in your layouts.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be on the lookout for any unintentionally untranslated text;
    unintentional because there may be instances where you want to use the same text
    consistently across your app, such as your app's title and your contact details.
    If you spot any *unintentionally* untranslated text, then you should dig into
    your app's code to see exactly what's going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Also, be on the lookout for any wrongly translated text. This kind of error
    can be difficult to spot, as chances are that you're not fluent in all the languages
    your app supports. This is one of the few occasions where it's acceptable to use
    an online translator, such as Google Translate, as it's often the quickest and
    easiest way of double-checking that your app's Spanish text really is Spanish.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also look for any instances where text or other locale-specific
    resources don''t fit with your current layout. This could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources that are smaller than the default version, such as the text that shrinks
    dramatically during the translation process. Shrinking resources can leave gaping
    holes in your layout, or they can throw other UI elements off balance and create
    a layout that, while not completely broken, does look pretty odd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources that are present in some versions of your UI and missing in others.
    Again, this can cause awkward gaps and aesthetic problems in your layout. If you're
    intentionally omitting certain resources, you might want to look for something
    to fill the gap this resource leaves behind, or as a last resort, supply an alternative
    layout that's designed specifically for this locale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources that are much larger than the default version, which can result in
    a cluttered, cramped-looking UI or usability problems, such as touchable areas
    that are pushed too close to one another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources that aren't appropriate for the current screen configuration. As already
    mentioned, different locales may also mean different hardware, software, and screen
    configurations. If you're targeting multiple countries and regions, make sure
    you research the most popular Android devices within these specific demographics,
    and then test your app across AVDs that reflect the hardware, software, and screen
    configurations that are most commonly used within these different areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for default resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you've tested your app across all the languages, countries, and regions
    that you want to support, you should install your app on an AVD with locale settings
    that it *doesn't* explicitly support. This may sound strange, but it's the most
    effective way of checking that you've included a default version of every resource
    your app requires.
  prefs: []
  type: TYPE_NORMAL
- en: As I've mentioned several times throughout this chapter, including default resources
    means that if your app gets into difficulties, it has something to gracefully
    fall back on rather than crashing. Providing default versions of all your project's
    strings, drawables, and other resources guarantees that your app will run even
    if it winds up on a device with locale settings that it doesn't explicitly support.
  prefs: []
  type: TYPE_NORMAL
- en: To test your app, open your Terminal or Command Prompt window and tell your
    emulator to switch to a locale that your app doesn't explicitly support. If you've
    provided the necessary default resources, your app should load these resources,
    including the contents of your project's `res/values/strings.xml` file. If your
    app crashes, then this is an indication that your project is missing at least
    one default resource.
  prefs: []
  type: TYPE_NORMAL
- en: Plan a beta release in key countries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you've finished testing your app across different locales, and you're confident
    that it'll functions correctly regardless of the user's language, country, or
    region settings, then you may want to consider opening your app up to feedback
    from your potential target audience, in particular the native speakers of all
    the languages your app supports. This usually takes the form of beta testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users who install beta versions of your app cannot leave reviews on your Google
    Play page, so don't worry about these early versions of your app negatively (and
    unfairly!) impacting your Google Play rating.
  prefs: []
  type: TYPE_NORMAL
- en: Getting real-world feedback is always valuable, but this feedback becomes even
    more valuable when you're planning an international launch. Native speakers will
    be able to easily pinpoint any grammar or spelling mistakes in your text, or even
    something that just sounds a bit *off*. They can also quickly flag up anything
    about your app's content that's inappropriate, confusing, or difficult for them
    to relate to.
  prefs: []
  type: TYPE_NORMAL
- en: This is all invaluable feedback that can help you perfect the localized versions
    of your app and create something that feels like it was created specifically for
    this section of your target audience, rather than a translation that was knocked
    together in a last-minute bid to rack up some extra downloads.
  prefs: []
  type: TYPE_NORMAL
- en: If you're looking to launch a beta testing program, then Google Play can help.
    After you sign into Developer Console and upload your APK, you can set up groups
    of users for beta testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to start small with a closed beta test, where you specify a group
    of testers by entering their Gmail addresses. If you happen to have a list of
    testers to hand, you can launch a closed beta program by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Developer Console and selecting **APK** from the left-hand side
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Upload your first APK to beta** button and following the onscreen
    instructions to upload your APK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your APK is uploaded, select **Beta testing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see a **Choose a testing method** option, open the accompanying drop-down
    menu and select **Set Up Closed Beta Listing**, followed by **Create list**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the e-mail addresses of all the people who you want to participate in
    the beta test. Click on **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy **Beta opt-in URL**. You can then share this link with your testers. When
    a potential tester clicks this link, they'll see an explanation about what being
    a beta tester entails. They can then decide whether to participate in the test
    or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After copying **Beta opt-in URL**, you'll need to enter an e-mail address or
    URL that you'll use to collect feedback from your testers. Enter this information
    in the **Feedback channel** field, then click on **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Gathering tester feedback**'
  prefs: []
  type: TYPE_NORMAL
- en: Since testers can't leave reviews on your app's Google Play page, you'll need
    to provide them with an alternative way of sending you their feedback. Whenever
    you launch a testing program through Developer Console, it's crucial you complete
    the **Feedback channel** field as this is your testers' primary way of communicating
    with you.
  prefs: []
  type: TYPE_NORMAL
- en: This feedback channel could take the form of an address or URL, but you may
    also want to consider setting up a Google+ page or Google Group for your testers.
    Whatever your preferred method of gathering feedback, it's important to recognize
    that anyone who tests your app is doing you a favor, so you should make it as
    easy as possible for them to send you their feedback.
  prefs: []
  type: TYPE_NORMAL
- en: If providing feedback feels like hard work, then your testers simply won't bother—they'll
    keep their thoughts to themselves, and your project will suffer as a result.
  prefs: []
  type: TYPE_NORMAL
- en: After a round of closed beta testing, you may want to move on to open beta testing,
    where you specify a maximum number of testers but don't specify their e-mail addresses.
  prefs: []
  type: TYPE_NORMAL
- en: To launch an open beta testing program, make sure you're logged into Developer
    Console, and then select **APK** from the left-hand side menu. Select **Beta testing**,
    open the drop-down menu, select **Set up Open Beta Testing**, and then specify
    the maximum number of users who'll be able to beta test your app.
  prefs: []
  type: TYPE_NORMAL
- en: Copy **Beta opt-in URL** and share it with your testers. Again, make sure you
    enter an e-mail address or URL in **Feedback channel**, and then click on **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for lift off!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your app to make a splash in the international market, supporting
    multiple languages and locales is just the beginning. You'll also need to devise
    some form of international marketing campaign.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like the kind of thing that requires a massive budget and a dedicated
    marketing team, but you can tailor the scope of your campaign to suit your budget
    and how much free time you have to promote your app. Even if your app is a one-person
    project, there's no end to budget-friendly (and in some cases, free) ways of promoting
    your app to an international audience, especially when you're promoting your app
    online.
  prefs: []
  type: TYPE_NORMAL
- en: A marketing campaign could be as simple as writing a press release announcing
    the release of your app, and then arranging for this text to be translated into
    the various languages your app supports. You could then spread your press release
    across the World Wide Web via social networks, free news and press release websites,
    your own blog, or any other places where you can post content for free.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't get carried away and post your marketing materials absolutely everywhere
    just for the sake of it. Spamming is only going to hurt your app's reputation
    in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: You should also translate any other promotional materials you create, such as
    banners, virtual badges, adverts, or memes.
  prefs: []
  type: TYPE_NORMAL
- en: Even if your promotional graphics don't feature any text, you should still look
    for opportunities to tweak these graphics, so they're more likely to resonate
    with each of your target locales. For example, could you include any geographical
    or cultural references that would make your graphics more appealing to users in
    specific regions? In our recipe app example, this might mean identifying recipes
    that are more likely to appeal to sections of our target audience and then featuring
    these recipes more prominently in the app's promotional banners and adverts.
  prefs: []
  type: TYPE_NORMAL
- en: If you create any promotional videos, you should also create localized versions
    of these videos for every language your app supports. This may mean recording
    entirely new audio for every video or providing subtitles.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the key to attracting an international audience is to create the illusion
    that your app was designed with each user's specific locale in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Localize your Google Play store listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your app's Google Play listing is the first impression that international users
    will have of your app. To make sure this first impression is a positive one, you'll
    need to localize your store listing, which means translating its text for every
    locale your app supports.
  prefs: []
  type: TYPE_NORMAL
- en: You can create multiple localized versions of your app's Google Play listing
    via Developer Console. Then, when a user opens your app's listing, Google Play
    will automatically determine that user's location, and it'll display the version
    of your listing that's the most appropriate for their language, country, or region
    settings. If Google Play can't find a suitable locale-specific version of your
    app's listing, it'll display your app's default Google Play page instead.
  prefs: []
  type: TYPE_NORMAL
- en: To create localized Google Play listings, log into your Developer Console account,
    and select **App applications** from the left-hand side menu. Select the app you
    want to work with, followed by **Store listing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new, localized version, click on the **Manage translations** button.
    At this point, you can purchase a translation by clicking on **Purchase translations**
    and following the onscreen instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Localize your Google Play store listing](img/B05061_8_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you already have some translated text you want to add to your localized store
    listing, select **Add your own translation**. Select all the languages you want
    to create a localized listing for (don't worry, you can always add more later
    on), and click on **Add**.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, Developer Console will take you back to the store listing form,
    but now, if you click on the **Languages** button, you'll see a drop-down list
    of all the languages you've just added. Clicking on any of these languages will
    take you to a separate form where you can craft an entirely new store listing,
    which will be displayed whenever someone views your app in Google Play with these
    locale settings.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to delete one of your localized pages at any point, simply click
    on the **Manage Translations** button, followed by **Remove translations**, and
    then choose the language you want to remove. If you want to change what version
    of your Google Play page is considered the default, click on the **Manage Translations**
    button again, and select **Change default language**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a localized store listing isn't just about translating your app's description;
    you should also supply alternate graphics. Even when a user is viewing a localized
    version of your Google Play page, they may still be unsure whether your app actually
    supports their language. Don't leave any room for doubt; take screenshots of your
    UI in all the languages it supports, and then upload these screenshots to the
    corresponding version of your app's Google Play page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you're building your app's Google Play page, Developer Console will offer
    hints about how your app can reach the widest possible audience. These tips contain
    some useful information, so make sure you check them out by selecting **Optimization
    Tips** from the left-hand side menu.
  prefs: []
  type: TYPE_NORMAL
- en: After launching your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hard work doesn't end when you successfully launch your app. Once you hit
    the **Publish** button and send your app out into the big wild world, there's
    a whole new bunch of things you can do to help that app reach the widest possible
    audience.
  prefs: []
  type: TYPE_NORMAL
- en: Following a successful launch – supporting international users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you've attracted an international audience, you need to hang on to that
    audience—which means offering support in a variety of languages.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how much support you can offer will vary depending on whether you have
    created your app as part of a team, or whether you're a solo developer creating
    Android apps in your spare time. But offering *some* level of support is crucial
    if you're going to hang on to the users that you worked so hard to gain in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: At the very least, you should monitor your app's Google Play reviews. The Google
    Play store helpfully translates all reviews for you, and you should try and respond
    to any question or suggestions that come in via Google Play, regardless of the
    language they're written in.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, you should respond to Google Play reviews in the poster's
    language, even if it means resorting to an online translation tool. Just be aware
    that translation tools tend to generate responses that are a little *off,* so
    it's a good idea to let users know that you're using a translation tool, just
    so they know to overlook any clunky phrasing or grammatical errors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Create a Google Play badge**'
  prefs: []
  type: TYPE_NORMAL
- en: Once you app is live, your goal is to drive as many people to its Google Play
    page as possible. One way of doing this is to create a Google Play badge. Whenever
    someone clicks on this badge, it'll take them direct to your app's Google Play
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: You can post this badge anywhere you want—on your website, blog, social media
    accounts, or you can incorporate it into your e-mail signature. Just don't get
    carried away; no-one likes a spammer, and spamming your app's Play badge isn't
    going to earn your app a loyal following in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a badge using the Google Play Badges generator ([https://play.google.com/intl/en_us/badges](https://play.google.com/intl/en_us/badges)).
  prefs: []
  type: TYPE_NORMAL
- en: Monitor your app's international performance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you support multiple locales, your app is inevitability going to be more
    popular in one part of the world than it is in others. There's a whole host of
    reasons why this might be the case, ranging from things you can control (such
    as the quality of your translations), to thing you *can't* control (such as a
    rival app that's already dominating the market in one of your target locales).
  prefs: []
  type: TYPE_NORMAL
- en: Having a clear picture of your app's popularity across all supported locales
    is essential for identifying areas where you need to focus more time and effort,
    and areas where it might make more sense to scale back your efforts or even stop
    supporting them completely.
  prefs: []
  type: TYPE_NORMAL
- en: If your app is proving massively popular in one locale, you may decide to put
    increased effort into meeting the needs of this part of your demographic, such
    as performing more market research in this area, creating localized content specifically
    for these users, or even creating language-specific user groups, such as a Google+
    community, LinkedIn group, or Facebook page.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you identify locales where users *love* your app? Developer Console
    provides stats about the number of downloads, installs, and uninstalls that your
    app is racking up across all the different locales it supports. To access this
    information, log in to your Developer Console account, select the app you want
    to investigate, and then select **Statistics** from the left-hand side menu.
  prefs: []
  type: TYPE_NORMAL
- en: But, let's be realistic, these stats aren't always going to be good news, and
    sometimes they may reveal that your app is struggling to attract users in certain
    locales. If this is the case, then you should try and figure out what might be
    hindering your app's success.
  prefs: []
  type: TYPE_NORMAL
- en: It might be something that you can fix, such as a less-than-perfect translation,
    or the fact that your app has hardware, software, or screen configuration requirements
    that aren't representative of the Android devices commonly used in this locale.
    However, the problem may be something that isn't quite so easy to fix, such as
    a lack of interest in your app's genre or subject matter, or a rival app that's
    already dominating the marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the reasons behind your app's poor performance, you may decide
    to try and address the issue, or you may decide that it makes more sense to drop
    support for this particular locale and redirect the time and effort into areas
    where your app has already found an enthusiastic audience.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that launching your app internationally is only phase one. If
    your app is going to find global success, then you'll have to make an ongoing
    effort to support users from all over the world, as well as continuously monitor
    how your app is faring in all the different locales.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to reach the widest possible audience, from
    supporting different versions of the Android operating system, to optimizing your
    app for different hardware, software, screen sizes, screen densities, and orientations.
    We even covered translating our app into different languages. We also touched
    on how to promote your app via advertising and marketing campaigns.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to attract an audience, in the next chapter, we'll look
    at how to wow this audience by optimizing our app's UI.
  prefs: []
  type: TYPE_NORMAL
