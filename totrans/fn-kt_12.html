<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with Arrow</h1>
                
            
            
                
<p class="mce-root"><strong>Arrow</strong> (<a href="http://arrow-kt.io/">http://arrow-kt.io/</a>) is a Kotlin library that provides functional constructs, datatypes, and other abstractions. Kotlin syntax is powerful and flexible, and Arrow takes advantage of it to offer features that don't come as standard.</p>
<p>Arrow is the result of combining the two most successful and popular functional libraries, <kbd>funKTionale</kbd> and <kbd>Kategory</kbd>, into one. In late 2017, both developer groups, fearing a split that would damage the whole Kotlin community, decided to join forces and create a single, unified functional library.</p>
<p class="mce-root">In this chapter, we'll cover how to use existing functions to build new and richer functions. Some of the topics that we'll cover are as follows:</p>
<ul>
<li class="mce-root">Function composition</li>
<li class="mce-root">Partial application</li>
<li class="mce-root">Currying</li>
<li class="mce-root">Memoization</li>
<li>Pipes</li>
<li>Optics</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Function composition</h1>
                
            
            
                
<p>One big part of functional programming as a concept is to use functions in the same way that we use any other type—as values, parameters, returns, and so on. One thing that we can do with other types is to take them as construction blocks to build other types; the same concept can be applied to functions.</p>
<p>Function composition is a technique to build functions using existing functions; similar to Unix pipes or channel pipelines, the result value of a function is used as a parameter for the next one.</p>
<p>In Arrow, function composition comes as a set of the <kbd>infix</kbd> extension functions:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Function</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>compose</kbd></p>
</td>
<td>
<p>Takes the result of invoking the right-hand function as the parameter for the left-hand function.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>forwardCompose</kbd></p>
</td>
<td>
<p>Takes the result of invoking the left-hand function as the parameter for the right-hand function.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>andThen</kbd></p>
</td>
<td>
<p>Is an alias for <kbd>forwardCompose</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Let's compose some functions:</p>
<pre>import arrow.syntax.function.andThen<br/>import arrow.syntax.function.compose<br/>import arrow.syntax.function.forwardCompose<br/>import java.util.*<br/><br/>val p: (String) -&gt; String = { body -&gt; "&lt;p&gt;$body&lt;/p&gt;" }<br/><br/>val span: (String) -&gt; String = { body -&gt; "&lt;span&gt;$body&lt;/span&gt;" }<br/><br/>val div: (String) -&gt; String = { body -&gt; "&lt;div&gt;$body&lt;/div&gt;" }<br/><br/>val randomNames: () -&gt; String = {<br/>    if (Random().nextInt() % 2 == 0) {<br/>        "foo"<br/>    } else {<br/>        "bar"<br/>    }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val divStrong: (String) -&gt; String = div compose strong<br/><br/>    val spanP: (String) -&gt; String = p forwardCompose span<br/><br/>    val randomStrong: () -&gt; String = randomNames andThen strong<br/><br/>    println(divStrong("Hello composition world!"))<br/>    println(spanP("Hello composition world!"))<br/>    println(randomStrong())<br/>}</pre>
<p>To build the <kbd>divStrong: (String) -&gt; String</kbd> function, we compose <kbd>div:(String) -&gt; String</kbd> and <kbd>strong:(String) -&gt; String</kbd>. In other words, <kbd>divStrong</kbd> is equivalent to the following code snippet:</p>
<pre>val divStrong: (String) -&gt; String = { body -&gt; "&lt;div&gt;&lt;strong&gt;$body&lt;/div&gt;&lt;/strong&gt;"}</pre>
<p>For <kbd>spanP:(String) -&gt; String</kbd>, we compose <kbd>span:(String) -&gt; (String)</kbd> and <kbd>p:(String) -&gt; String</kbd> as follows:</p>
<pre>val spanP: (String) -&gt; String = { body -&gt; "&lt;span&gt;&lt;p&gt;$body&lt;/p&gt;&lt;/span&gt;"}</pre>
<p>Notice that we are using the same type <kbd>(String) -&gt; String</kbd>, but any function can be composed if it has the right return type that the other functions need.</p>
<p>Let's rewrite our <kbd>Channel</kbd> pipeline example with function composition:</p>
<pre>data class Quote(val value: Double, val client: String, val item: String, val quantity: Int)<br/><br/>data class Bill(val value: Double, val client: String)<br/><br/>data class PickingOrder(val item: String, val quantity: Int)<br/><br/>fun calculatePrice(quote: Quote) = Bill(quote.value * quote.quantity, quote.client) to PickingOrder(quote.item, quote.quantity)<br/><br/>fun filterBills(billAndOrder: Pair&lt;Bill, PickingOrder&gt;): Pair&lt;Bill, PickingOrder&gt;? {<br/>   val (bill, _) = billAndOrder<br/>   return if (bill.value &gt;= 100) {<br/>      billAndOrder<br/>   } else {<br/>      null<br/>   }<br/>}<br/><br/>fun warehouse(order: PickingOrder) {<br/>   println("Processing order = $order")<br/>}<br/><br/>fun accounting(bill: Bill) {<br/>   println("processing = $bill")<br/>}<br/><br/>fun splitter(billAndOrder: Pair&lt;Bill, PickingOrder&gt;?) {<br/>   if (billAndOrder != null) {<br/>      warehouse(billAndOrder.second)<br/>      accounting(billAndOrder.first)<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val salesSystem:(Quote) -&gt; Unit = ::calculatePrice andThen ::filterBills forwardCompose ::splitter<br/>   salesSystem(Quote(20.0, "Foo", "Shoes", 1))<br/>   salesSystem(Quote(20.0, "Bar", "Shoes", 200))<br/>   salesSystem(Quote(2000.0, "Foo", "Motorbike", 1))<br/>}<br/></pre>
<p>The <kbd>salesSystem: (Quote) -&gt; Unit</kbd> function is very complex in its behavior, but was built using other functions as building blocks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Partial application</h1>
                
            
            
                
<p>With function composition, we take two functions to create the third function; with partial application, we create a new function by passing a parameter to an existing function.</p>
<p>Arrow comes with two flavours of partial application—explicit and implicit.</p>
<p>The explicit style uses a series of extension functions called <kbd>partially1</kbd>, <kbd>partially2</kbd>, all the way up to <kbd>partially22</kbd>. The implicit style takes a series of extensions, overloading the <kbd>invoke</kbd> operator:</p>
<pre>package com.packtpub.functionalkotlin.chapter11<br/><br/>import arrow.syntax.function.invoke<br/>import arrow.syntax.function.partially3<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val strong: (String, String, String) -&gt; String = { body, id, style -&gt; "&lt;strong id=\"$id\" style=\"$style\"&gt;$body&lt;/strong&gt;" }<br/><br/>   val redStrong: (String, String) -&gt; String = strong.partially3("font: red") //Explicit<br/><br/>   val blueStrong: (String, String) -&gt; String = strong(p3 = "font: blue") //Implicit<br/><br/>   println(redStrong("Red Sonja", "movie1"))<br/>   println(blueStrong("Deep Blue Sea", "movie2"))<br/>}</pre>
<p>Both styles can be chained as follows:</p>
<pre>fun partialSplitter(billAndOrder: Pair&lt;Bill, PickingOrder&gt;?, warehouse: (PickingOrder) -&gt; Unit, accounting: (Bill) -&gt; Unit) {<br/>   if (billAndOrder != null) {<br/>      warehouse(billAndOrder.second)<br/>      accounting(billAndOrder.first)<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val splitter: (billAndOrder: Pair&lt;Bill, PickingOrder&gt;?) -&gt; Unit = ::partialSplitter.partially2 { order -&gt; println("TESTING $order") }(p2 = ::accounting)<br/><br/>   val salesSystem: (quote: Quote) -&gt; Unit = ::calculatePrice andThen ::filterBills forwardCompose splitter<br/>   salesSystem(Quote(20.0, "Foo", "Shoes", 1))<br/>   salesSystem(Quote(20.0, "Bar", "Shoes", 200))<br/>   salesSystem(Quote(2000.0, "Foo", "Motorbike", 1))<br/>}</pre>
<p>Our original <kbd>splitter</kbd> function was not very flexible as it directly invoked warehouse and accounting functions. The <kbd>partialSplitter</kbd> function resolves this problem by taking <kbd>warehouse</kbd> and <kbd>accounting</kbd> as parameters; however a <kbd>(Pair&lt;Bill, PickingOrder&gt;?, (PickingOrder) -&gt; Unit, (Bill) -&gt; Unit)</kbd> function can't be used in composition. Then, we partially apply two functions—a lambda and a reference.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binding</h1>
                
            
            
                
<p>A special case of partial application is <strong>binding</strong>. With binding, you pass a <kbd>T</kbd> parameter to the <kbd>(T) -&gt; R</kbd> function but without executing it, effectively returning an <kbd>() -&gt; R</kbd> function:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/><br/>   val footer:(String) -&gt; String = {content -&gt; "&lt;footer&amp;gt;$content&lt;/footer&gt;"}<br/>   val fixFooter: () -&gt; String = footer.bind("Functional Kotlin - 2018") //alias for partially1<br/>   println(fixFooter())<br/>}</pre>
<p>The function bind is just an alias for <kbd>partially1</kbd>, but it makes sense to have a separate name for it and make it more semantically correct.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reverse</h1>
                
            
            
                
<p><strong>Reverse</strong> takes any function and returns it with its parameter in the reverse order (in other languages, this function is known as <strong>flip</strong>). Let's look at the following code:</p>
<pre>import arrow.syntax.function.partially3<br/>import arrow.syntax.function.reverse<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val strong: (String, String, String) -&gt; String = { body, id, style -&gt; "&lt;strong id=\"$id\" style=\"$style\"&gt;$body&lt;/strong&gt;" }<br/><br/>   val redStrong: (String, String) -&gt; String = strong.partially3("font: red") //Explicit<br/><br/>   println(redStrong("Red Sonja", "movie1"))<br/><br/>   println(redStrong.reverse()("movie2", "The Hunt for Red October"))<br/><br/>}</pre>
<p>Our <kbd>redStrong</kbd> function is awkward to use, as we'll expect to have <kbd>id</kbd> first and then <kbd>body</kbd>, but, is easily fixable with the <kbd>reverse</kbd> extension function. The <kbd>reverse</kbd> function can be applied to functions from parameters <kbd>1</kbd> to <kbd>22</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pipes</h1>
                
            
            
                
<p>A <kbd>pipe</kbd> function takes a <kbd>T</kbd> value and invokes a <kbd>(T) -&gt; R</kbd> function with it:</p>
<pre>import arrow.syntax.function.pipe<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val strong: (String) -&gt; String = { body -&gt; "&lt;strong&gt;$body&lt;/strong&gt;" }<br/><br/>   "From a pipe".pipe(strong).pipe(::println)<br/>}</pre>
<p>A <strong>pipe</strong> is similar to function composition, but instead of generating new functions, we can chain function invocations to produce new values, reducing nesting calls. Pipes are known in other languages, such as <strong>Elm</strong> and <strong>Ocaml</strong>, as the operator <kbd>|&gt;</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   splitter(filterBills(calculatePrice(Quote(20.0, "Foo", "Shoes", 1)))) //Nested<br/><br/>   Quote(20.0, "Foo", "Shoes", 1) pipe ::calculatePrice pipe ::filterBills pipe ::splitter //Pipe<br/>}</pre>
<p>Both lines are equivalent, but the first one must be understood backwards and the second one should read from left to right:</p>
<pre>import arrow.syntax.function.pipe<br/>import arrow.syntax.function.pipe3<br/>import arrow.syntax.function.reverse<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val strong: (String, String, String) -&gt; String = { body, id, style -&gt; "&lt;strong id=\"$id\" style=\"$style\"&gt;$body&lt;/strong&gt;" }<br/><br/>   val redStrong: (String, String) -&gt; String = "color: red" pipe3 strong.reverse()<br/>   <br/>   redStrong("movie3", "Three colors: Red") pipe ::println<br/>}</pre>
<p>When <kbd>pipe</kbd> is applied to a multi-parameter function, using its variants <kbd>pipe2</kbd> to <kbd>pipe22</kbd>, it behaves as <kbd>partially1</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Currying</h1>
                
            
            
                
<p>Applying curried to a function of <em>n</em> parameters, for example, <kbd>(A, B) -&gt; R</kbd>, transforms it into a chain of the <kbd>n</kbd> function calls, <kbd>(A) -&gt; (B) -&gt; R</kbd>:</p>
<pre>import arrow.syntax.function.curried<br/>import arrow.syntax.function.pipe<br/>import arrow.syntax.function.reverse<br/>import arrow.syntax.function.uncurried<br/><br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>   val strong: (String, String, String) -&gt; String = { body, id, style -&gt; "&lt;strong id=\"$id\" style=\"$style\"&gt;$body&lt;/strong&gt;" }<br/><br/>   val curriedStrong: (style: String) -&gt; (id: String) -&gt; (body: String) -&gt; String = strong.reverse().curried()<br/><br/>   val greenStrong: (id: String) -&gt; (body: String) -&gt; String = curriedStrong("color:green")<br/><br/>   val uncurriedGreenStrong: (id: String, body: String) -&gt; String = greenStrong.uncurried()<br/><br/>   println(greenStrong("movie5")("Green Inferno"))<br/><br/>   println(uncurriedGreenStrong("movie6", "Green Hornet"))<br/><br/>   "Fried Green Tomatoes" pipe ("movie7" pipe greenStrong) pipe ::println<br/>}</pre>
<p>Functions on curried forms can be transformed into a normal, multi-parameter form with <kbd>uncurried()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Differences between the currying and partial application</h1>
                
            
            
                
<p>There is some confusion between currying and partial application. Some authors treat them as synonymous, but they are different:</p>
<pre>import arrow.syntax.function.curried<br/>import arrow.syntax.function.invoke<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val strong: (String, String, String) -&gt; String = { body, id, style -&gt; "&lt;strong id=\"$id\" style=\"$style\"&gt;$body&lt;/strong&gt;" }<br/><br/>   println(strong.curried()("Batman Begins")("trilogy1")("color:black")) // Curried<br/><br/>   println(strong("The Dark Knight")("trilogy2")("color:black")) // Fake curried, just partial application<br/><br/>   println(strong(p2 = "trilogy3")(p2 = "color:black")("The Dark Knight rises")) // partial application   <br/>}</pre>
<p>The differences are significant and they can help us to decide when to use one or the other:</p>
<table>
<tbody>
<tr>
<td/>
<td>
<p><strong>Currying</strong></p>
</td>
<td>
<p><strong>Partial application</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Return value</strong></p>
</td>
<td>
<p>When a function of arity <em>N</em> gets curried, it returns a chain of functions of <em>N</em> size, (curried form).</p>
</td>
<td>
<p>When a function or arity <em>N</em> gets partially applied, it returns a function of arity <em>N - 1</em>.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Parameter application</strong></p>
</td>
<td>
<p>After curried, only the first parameter of the chain can be applied.</p>
</td>
<td>
<p>Any parameter can be applied in any order.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Reverting</strong></p>
</td>
<td>
<p>It is possible to take a function on the curried form and revert it to a multi-parameter function.</p>
</td>
<td>
<p>As partial application doesn't change the function form, reverting is not applicable.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Partial application can be more flexible, but some functional styles tend to favor currying. The important thing to grasp is that both styles are different and both are supported by Arrow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Logical complement</h1>
                
            
            
                
<p>A <strong>logical complement</strong> takes any predicate (a function with a return <kbd>Boolean</kbd> type) and negates it. Let's look at the following code:</p>
<pre>import arrow.core.Predicate<br/>import arrow.syntax.function.complement<br/><br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val evenPredicate: Predicate&lt;Int&gt; = { i: Int -&gt; i % 2 == 0 }<br/>   val oddPredicate: (Int) -&gt; Boolean = evenPredicate.complement()<br/><br/>   val numbers: IntRange = 1..10<br/>   val evenNumbers: List&lt;Int&gt; = numbers.filter(evenPredicate)<br/>   val oddNumbers: List&lt;Int&gt; = numbers.filter(oddPredicate)<br/><br/>   println(evenNumbers)<br/>   println(oddNumbers)<br/>}</pre>
<p>Notice that we use a <kbd>Predicate&lt;T&gt;</kbd> type, but it is just an alias for <kbd>(T) -&gt; Boolean</kbd>. There are complement extension functions for predicates from <kbd>0</kbd> to <kbd>22</kbd> parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Memoization</h1>
                
            
            
                
<p><strong>Memoization</strong> is a technique to cache results of pure functions. A memoized function behaves as a normal function, but stores the result of previous computations associated with the parameters supplied to produce that result.</p>
<p>The classic example of memoization is Fibonacci:</p>
<pre>import arrow.syntax.function.memoize<br/>import kotlin.system.measureNanoTime<br/><br/>fun recursiveFib(n: Long): Long = if (n &lt; 2) {<br/>   n<br/>} else {<br/>   recursiveFib(n - 1) + recursiveFib(n - 2)<br/>}<br/><br/>fun imperativeFib(n: Long): Long {<br/>   return when (n) {<br/>      0L -&gt; 0<br/>      1L -&gt; 1<br/>      else -&gt; {<br/>         var a = 0L<br/>         var b = 1L<br/>         var c = 0L<br/>         for (i in 2..n) {<br/>            c = a + b<br/>            a = b<br/>            b = c<br/>         }<br/>         c<br/>      }<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>   var lambdaFib: (Long) -&gt; Long = { it } //Declared ahead to be used inside recursively<br/><br/>   lambdaFib = { n: Long -&gt;<br/>      if (n &lt; 2) n else lambdaFib(n - 1) + lambdaFib(n - 2)<br/>   }<br/><br/>   var memoizedFib: (Long) -&gt; Long = { it }<br/><br/>   memoizedFib = { n: Long -&gt;<br/>      if (n &lt; 2) n else memoizedFib(n - 1) + memoizedFib(n - 2)<br/>   }.memoize()<br/><br/>   println(milliseconds("imperative fib") { imperativeFib(40) }) //0.006<br/>   <br/>   println(milliseconds("recursive fib") { recursiveFib(40) }) //1143.167<br/>   println(milliseconds("lambda fib") { lambdaFib(40) }) //4324.890<br/>   println(milliseconds("memoized fib") { memoizedFib(40) }) //1.588<br/>}<br/><br/>inline fun milliseconds(description: String, body: () -&gt; Unit): String {<br/>   return "$description:${measureNanoTime(body) / 1_000_000.00} ms"<br/>}</pre>
<p>Our memoized version is more than 700 times faster than a recursive function version (which is almost four times faster than the lambda version). The imperative version is unbeatable, as it is heavily optimized by the compiler:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/><br/>   var lambdaFib: (Long) -&gt; Long = { it } //Declared ahead to be used inside recursively<br/><br/>   lambdaFib = { n: Long -&gt;<br/>      if (n &lt; 2) n else lambdaFib(n - 1) + lambdaFib(n - 2)<br/>   }<br/><br/>   var memoizedFib: (Long) -&gt; Long = { it }<br/><br/>   memoizedFib = { n: Long -&gt;<br/>      println("from memoized fib n = $n")<br/>      if (n &lt; 2) n else memoizedFib(n - 1) + memoizedFib(n - 2)<br/>   }.memoize()<br/>   val job = launch {<br/>      repeat(10) { i -&gt;<br/>         launch(coroutineContext) { println(milliseconds("On coroutine $i - imperative fib") { imperativeFib(40) }) }<br/>         launch(coroutineContext) { println(milliseconds("On coroutine $i - recursive fib") { recursiveFib(40) }) }<br/>         launch(coroutineContext) { println(milliseconds("On coroutine $i - lambda fib") { lambdaFib(40) }) }<br/>         launch(coroutineContext) { println(milliseconds("On coroutine $i - memoized fib") { memoizedFib(40) }) }<br/>      }<br/>   }<br/><br/>   job.join()<br/><br/>}</pre>
<p>Memoized functions, internally, use a thread-safe structure to store their results, and are therefore safe to use on coroutines or any other concurrent code.</p>
<p>There are potential downsides of using memoized functions. The first is that the process of reading the internal cache is higher than the actual computation or memory consumption, as right now, memoized functions don't expose any behavior to control their internal storage.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Partial functions</h1>
                
            
            
                
<p>A <strong>partial function</strong> (not to be confused with partial applied function) is a function that is not defined for every possible value of its parameter type. In contrast, a <strong>total function</strong> is a function that is defined for every possible value.</p>
<p>Let's have a look at the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val upper: (String?) -&gt; String = { s:String? -&gt; s!!.toUpperCase()} //Partial function, it can't transform null<br/>   <br/>   listOf("one", "two", null, "four").map(upper).forEach(::println) //NPE<br/>}</pre>
<p>The <kbd>upper</kbd> function is a partial function; it can't process a null value despite the fact that <kbd>null</kbd> is a valid <kbd>String?</kbd> value. If you try to run this code, it will throw a <kbd>NullPointerException</kbd> (<strong>NPE</strong>).</p>
<p>Arrow provides an explicit type <kbd>PartialFunction&lt;T, R&gt;</kbd> for partial functions of type <kbd>(T) -&gt; R</kbd>:</p>
<pre>import arrow.core.PartialFunction<br/><br/>fun main(args: Array&lt;String&gt;) {<br/> val upper: (String?) -&gt; String = { s: String? -&gt; s!!.toUpperCase() } //Partial function, it can't transform null<br/><br/> val partialUpper: PartialFunction&lt;String?, String&gt; = PartialFunction(definetAt = { s -&gt; s != null }, f = upper)<br/><br/> listOf("one", "two", null, "four").map(partialUpper).forEach(::println) //IAE: Value: (null) isn't supported by this function <br/>}</pre>
<p><kbd>PartialFunction&lt;T, R&gt;</kbd> receives a predicate <kbd>(T) -&gt; Boolean</kbd> as the first parameter which must return  <kbd>true</kbd> if the function is defined for that particular value. A <kbd>PartialFunction&lt;T, R&gt;</kbd> function extends from <kbd>(T) -&gt; R</kbd>, therefore it can be used as a normal function.</p>
<p>In this example, the code still throws an exception but now of type <kbd>IllegalArgumentException</kbd> (<strong>IAE</strong>), with an informative message.</p>
<p>To avoid getting exceptions, we must transform our partial function into a total one:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/><br/>   val upper: (String?) -&gt; String = { s: String? -&gt; s!!.toUpperCase() } //Partial function, it can't transform null<br/><br/>   val partialUpper: PartialFunction&lt;String?, String&gt; = PartialFunction(definetAt = { s -&gt; s != null }, f = upper)<br/><br/>   listOf("one", "two", null, "four").map{ s -&gt; partialUpper.invokeOrElse(s, "NULL")}.forEach(::println)<br/>}</pre>
<p>One option is to use the <kbd>invokeOrElse</kbd> function that returns a default value in case the value <kbd>s</kbd> isn't defined for this function:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/><br/>   val upper: (String?) -&gt; String = { s: String? -&gt; s!!.toUpperCase() } //Partial function, it can't transform null<br/><br/>   val partialUpper: PartialFunction&lt;String?, String&gt; = PartialFunction(definetAt = { s -&gt; s != null }, f = upper)<br/><br/>   val upperForNull: PartialFunction&lt;String?, String&gt; = PartialFunction({ s -&gt; s == null }) { "NULL" }<br/><br/>   val totalUpper: PartialFunction&lt;String?, String&gt; = partialUpper orElse upperForNull<br/><br/>   listOf("one", "two", null, "four").map(totalUpper).forEach(::println)<br/>}</pre>
<p>The second option is to create a total function using several partial functions with the function <kbd>orElse</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val fizz = PartialFunction({ n: Int -&gt; n % 3 == 0 }) { "FIZZ" }<br/>   val buzz = PartialFunction({ n: Int -&gt; n % 5 == 0 }) { "BUZZ" }<br/>   val fizzBuzz = PartialFunction({ n: Int -&gt; fizz.isDefinedAt(n) &amp;&amp; buzz.isDefinedAt(n) }) { "FIZZBUZZ" }<br/>   val pass = PartialFunction({ true }) { n: Int -&gt; n.toString() }<br/><br/>   (1..50).map(fizzBuzz orElse buzz orElse fizz orElse pass).forEach(::println)<br/>}</pre>
<p>Through the <kbd>isDefinedAt(T)</kbd> function we can reuse the internal predicate, in this case, to build the condition for <kbd>fizzBuzz</kbd>. When used in a chain of <kbd>orElse</kbd>, the declaration order takes precedence, the first partial function that is defined for a value will be executed, and the other functions down the chain will be ignored.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identity and constant</h1>
                
            
            
                
<p>Identity and constant are straightforward functions. The <kbd>identity</kbd> function returns the same value provided as parameter; similar to additive and multiplicative identity property, adding 0 to any number is still the same number.</p>
<p>The <kbd>constant&lt;T, R&gt;(t: T)</kbd> function returns a new function that will always return the <kbd>t</kbd> value:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/><br/>   val oneToFour = 1..4<br/><br/>   println("With identity: ${oneToFour.map(::identity).joinToString()}") //1, 2, 3, 4<br/><br/>   println("With constant: ${oneToFour.map(constant(1)).joinToString()}") //1, 1, 1, 1<br/>   <br/>}</pre>
<p>We can rewrite our <kbd>fizzBuzz</kbd> value using <kbd>constant</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val fizz = PartialFunction({ n: Int -&gt; n % 3 == 0 }, constant("FIZZ"))<br/>   val buzz = PartialFunction({ n: Int -&gt; n % 5 == 0 }, constant("BUZZ"))<br/>   val fizzBuzz = PartialFunction({ n: Int -&gt; fizz.isDefinedAt(n) &amp;&amp; buzz.isDefinedAt(n) }, constant("FIZZBUZZ"))<br/>   val pass = PartialFunction&lt;Int, String&gt;(constant(true)) { n -&gt; n.toString() }<br/><br/>   (1..50).map(fizzBuzz orElse buzz orElse fizz orElse pass).forEach(::println)<br/>}</pre>
<p>Identity and constant functions are useful in functional programming or in implementations of math algorithms, for example, constant is K in SKI combinator calculus.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optics</h1>
                
            
            
                
<p><strong>Optics</strong> are abstractions to update immutable data structures elegantly. One form of optics is <kbd>Lens</kbd> (or lenses, depending on the library implementation). A <kbd>Lens</kbd> is a functional reference that can focus (hence the name) into a structure and read, write, or modify its target:</p>
<pre>typealias GB = Int<br/><br/>data class Memory(val size: GB)<br/>data class MotherBoard(val brand: String, val memory: Memory)<br/>data class Laptop(val price: Double, val motherBoard: MotherBoard)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val laptopX8 = Laptop(500.0, MotherBoard("X", Memory(8)))<br/><br/>   val laptopX16 = laptopX8.copy(<br/>         price = 780.0,<br/>         motherBoard = laptopX8.motherBoard.copy(<br/>               memory = laptopX8.motherBoard.memory.copy(<br/>                     size = laptopX8.motherBoard.memory.size * 2<br/>               )<br/>         )<br/>   )<br/><br/>   println("laptopX16 = $laptopX16")<br/>}</pre>
<p>To create a new <kbd>Laptop</kbd> value from an existing one, we need to use several nested copy methods and references. In this example, it isn't as bad but you can imagine that in a more complex data structure, things can overgrow into madness.</p>
<p>Let's write our very first <kbd>Lens</kbd> values:</p>
<pre>val laptopPrice: Lens&lt;Laptop, Double&gt; = Lens(<br/>      get = { laptop -&gt; laptop.price },<br/>      set = { price -&gt; { laptop -&gt; laptop.copy(price = price) } }<br/>)</pre>
<p>The <kbd>laptopPrice</kbd> value is a <kbd>Lens&lt;Laptop, Double&gt;</kbd> that we initialize using the function <kbd>Lens&lt;S, T, A, B&gt;</kbd> (actually <kbd>Lens.invoke</kbd>). <kbd>Lens</kbd> takes two functions as parameters, as <kbd>get: (S) -&gt; A</kbd> and <kbd>set: (B) -&gt; (S) -&gt; T</kbd>.</p>
<p>As you can see, <kbd>set</kbd> is a curried function so that you can write your set like this:</p>
<pre>import arrow.optics.Lens<br/><br/>val laptopPrice: Lens&lt;Laptop, Double&gt; = Lens(<br/>      get = { laptop -&gt; laptop.price },<br/>      set = { price: Double, laptop: Laptop -&gt; laptop.copy(price = price) }.curried()<br/>)</pre>
<p>Which, depending on your preferences, can be easier to read and write.</p>
<p>Now that you have your first lens, it can be used to set, read, and modify a laptop's price. Not too impressive, but the magic of lenses is combining them:</p>
<pre>import arrow.optics.modify<br/><br/>val laptopMotherBoard: Lens&lt;Laptop, MotherBoard&gt; = Lens(<br/>      get = { laptop -&gt; laptop.motherBoard },<br/>      set = { mb -&gt; { laptop -&gt; laptop.copy(motherBoard = mb) } }<br/>)<br/><br/>val motherBoardMemory: Lens&lt;MotherBoard, Memory&gt; = Lens(<br/>      get = { mb -&gt; mb.memory },<br/>      set = { memory -&gt; { mb -&gt; mb.copy(memory = memory) } }<br/>)<br/><br/>val memorySize: Lens&lt;Memory, GB&gt; = Lens(<br/>      get = { memory -&gt; memory.size },<br/>      set = { size -&gt; { memory -&gt; memory.copy(size = size) } }<br/>)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val laptopX8 = Laptop(500.0, MotherBoard("X", Memory(8)))<br/><br/>   val laptopMemorySize: Lens&lt;Laptop, GB&gt; = laptopMotherBoard compose motherBoardMemory compose memorySize<br/><br/>   val laptopX16 = laptopMemorySize.modify(laptopPrice.set(laptopX8, 780.0)) { size -&gt;<br/>      size * 2<br/>   }<br/><br/>   println("laptopX16 = $laptopX16")<br/>}</pre>
<p>We created <kbd>laptopMemorySize</kbd> combining lenses from <kbd>Laptop</kbd> all the way to <kbd>memorySize</kbd>; then, we can set laptop's price and modify its memory.</p>
<p>Despite how cool lenses are, it looks like a lot of boilerplate code. Fear not, Arrow can generate those lenses for you.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Arrows code generation</h1>
                
            
            
                
<p>On a Gradle project, add a file called <kbd>generated-kotlin-sources.gradle</kbd>:</p>
<pre>apply plugin: 'idea'<br/><br/>idea {<br/>    module {<br/>        sourceDirs += files(<br/>            'build/generated/source/kapt/main',<br/>            'build/generated/source/kaptKotlin/main',<br/>            'build/tmp/kapt/main/kotlinGenerated')<br/>        generatedSourceDirs += files(<br/>            'build/generated/source/kapt/main',<br/>            'build/generated/source/kaptKotlin/main',<br/>            'build/tmp/kapt/main/kotlinGenerated')<br/>    }<br/>}</pre>
<p>Then, in the <kbd>build.gradle</kbd> file, add the following content:</p>
<pre>apply plugin: 'kotlin-kapt'<br/>apply from: rootProject.file('gradle/generated-kotlin-sources.gradle')</pre>
<p>Add a new dependency in the <kbd>build.gradle</kbd> file:</p>
<pre>dependencies {<br/>    ...<br/>    kapt    'io.arrow-kt:arrow-annotations-processor:0.5.2'<br/>    ...     <br/>}</pre>
<p>Once configured, you can generate Arrow code with a normal build command, <kbd>./gradlew build</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating lenses</h1>
                
            
            
                
<p>Once Arrow's code generation is configured, you can add the <kbd>@lenses</kbd> annotation to the data classes that you want to have lenses generated for:</p>
<pre>import arrow.lenses<br/>import arrow.optics.Lens<br/>import arrow.optics.modify<br/><br/>typealias GB = Int<br/><br/>@lenses data class Memory(val size: GB)<br/>@lenses data class MotherBoard(val brand: String, val memory: Memory)<br/>@lenses data class Laptop(val price: Double, val motherBoard: MotherBoard)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val laptopX8 = Laptop(500.0, MotherBoard("X", Memory(8)))<br/><br/>   val laptopMemorySize: Lens&lt;Laptop, GB&gt; = laptopMotherBoard() compose motherBoardMemory() compose memorySize()<br/><br/>   val laptopX16 = laptopMemorySize.modify(laptopPrice().set(laptopX8, 780.0)) { size -&gt;<br/>      size * 2<br/>   }<br/><br/>   println("laptopX16 = $laptopX16")<br/>}</pre>
<p>Arrow generates as many lenses as constructor parameters our data classes have, with the name convention <kbd>classProperty</kbd> and in the same package, so no extra imports are needed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered many features of Arrow that give us tools to create, generate, and enrich existing functions. We composed new functions using existing ones; we included partial application and currying. We also cached results of pure functions with memoization and modified data structures using lenses.</p>
<p>Arrow's features open up the possibility of creating rich and maintainable applications, using basic functional principles.</p>
<p>In the next chapter, we'll cover more Arrow features, including datatypes such as <kbd>Option</kbd>, <kbd>Either</kbd>, and <kbd>Try</kbd>. </p>


            

            
        
    </body></html>