<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Artificial Intelligence and Game Progression</h1></div></div></div><p>
<em>In the previous chapter, we learned about adding user interface elements to our game. We added a hit points representation above our ships, added buttons, and even created our own dialog.</em>
</p><p>In this chapter, we will add artificial intelligence to our game. The following are the topics we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The concepts of fuzzy logic and state machines</li><li class="listitem" style="list-style-type: disc">Enemy ships should move and attack</li><li class="listitem" style="list-style-type: disc">Adding some kind of progression to the game</li><li class="listitem" style="list-style-type: disc">Winning and losing the game</li></ul></div><p>However, before we get to the actual coding, let's see the concepts of artificial intelligence that we will implement.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec99"/>Artificial intelligence in theory</h1></div></div></div><p>The goal for the enemy ships is to move around and attack our ships if they get close enough. There are two concepts we need to look into in detail to help us implement this logic; we will discuss these in the following sections.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Explaining fuzzy logic</h2></div></div></div><p>Let's take a moving train as an example. We could use a Boolean value to describe its state. If it is set to true, it's moving fast; if it's set to false, it's not moving fast.</p><p>However, that will not be enough. Let's say the train is moving at 80 miles per hour and then at 100 miles per hour. At both speeds, our Boolean value will be true, but we have no way of differentiating it further. Also, we don't have a state if the train is not moving.</p><p>Fuzzy logic describes an interval of values put into a colloquial term. Let's take a step back and compare<a id="id371" class="indexterm"/> it to mathematical logic. Binary (two-valued) logic has two values: true and false. An expression such as <em>1 + 1 = 2</em> evaluates to "true". The expression "Adding one to one is most likely going to be two" will not make much sense in binary logic, but it will be possible in fuzzy logic.</p><p>Fuzzy logic doesn't have the two values true and false, but it has in-between values such as a bit, quite, or about. This is similar to human thinking.</p><p>To illustrate this point further, let's take a look at<a id="id372" class="indexterm"/> what our moving train example looks like if put in table form:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Term</p>
</th><th style="text-align: left" valign="bottom">
<p>Speed</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Not moving</p>
</td><td style="text-align: left" valign="top">
<p>0 miles per hour</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Really slow</p>
</td><td style="text-align: left" valign="top">
<p>1 to 9 miles per hour</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Almost fast</p>
</td><td style="text-align: left" valign="top">
<p>10 to 49 miles per hour</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Quite fast</p>
</td><td style="text-align: left" valign="top">
<p>50 to 89 miles per hour</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Really fast</p>
</td><td style="text-align: left" valign="top">
<p>90 to 119 miles per hour</p>
</td></tr></tbody></table></div><p>For our game, we can apply this to a similar value: the distance between the enemy ship and our own ship.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Explaining state machines</h2></div></div></div><p>State machines are<a id="id373" class="indexterm"/> a number of states put into a sequential logic circuit. This sounds abstract, so let's explain it in detail: a state, first of all, is a value that changes if a different state becomes active. A door has two states: locked and unlocked. If the door is locked, it stays locked until it's unlocked.</p><p>Here is an example that is closer to our game: we need a number of states, for example, <strong>Move to player</strong>, <strong>Wait 3 seconds</strong>, and <strong>Attack player</strong>.</p><p>Now, we need to put these<a id="id374" class="indexterm"/> states in some kind of order. Let's say the enemy first moves to the player, and then it attacks and waits for 3 seconds. Then, the process starts again, as demonstrated in the following diagram:</p><div><img src="img/1509OS_08_01.jpg" alt="Explaining state machines"/></div><p>So far, we know about states and state machines. Finite state machines are state machines with a finite number of states. The preceding figure is <a id="id375" class="indexterm"/>of course a simplified example of how finite state machines can work. Some of the models also have transitions to describe the action taken to move from one state to another. In illustrations, transitions are often accompanied by conditions such as "Is the player in sight?"</p><p>Most simple AIs employ this strategy. One of the most prominent examples is<a id="id376" class="indexterm"/> <strong>Quake</strong>. To be fair, different AI mechanics are used in more complex and modern games. One example is the AI adapting to the player's actions: if in a strategy game, the player chooses to attack a specific point, the AI would adapt to defend this position more and more depending on how often the player attacked.</p><p>For our purposes, a finite state machine is more than enough. So, let's see what states we need for the enemy ship:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We want the enemy ship<a id="id377" class="indexterm"/> to wander around</li><li class="listitem" style="list-style-type: disc">We want the enemy ship to move to the vicinity of the player</li><li class="listitem" style="list-style-type: disc">We want the enemy ship to attack</li><li class="listitem" style="list-style-type: disc">We want the enemy ship to wait a bit after an attack (for the player to recuperate)</li></ul></div><p>Let's put these states into a diagram as follows:</p><div><img src="img/1509OS_08_02.jpg" alt="Explaining state machines"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec100"/>Letting the enemy ship move and attack</h1></div></div></div><p>Now that we know about fuzzy logic and state machines, we can implement these as mechanics for our artificial intelligence.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Moving the ship</h2></div></div></div><p>First of all, we want the ship to move around—both wander around and move to the player ship.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec101"/>Time for action – getting the enemy ship to move around</h1></div></div></div><p>In order for<a id="id378" class="indexterm"/> the enemy ship to<a id="id379" class="indexterm"/> move around, we need to use the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open our Xcode project if it's not already open.</li><li class="listitem">Open the <code class="literal">Battlefield.h</code> file.</li><li class="listitem">Define all AI states as <code class="literal">enum</code>, as shown in the following code:<div><pre class="programlisting">typedef NS_ENUM(NSInteger, AIState) {
    StateWanderAround,
    StateMoveToPlayer,
    StateAttack,
    StateRecuperate
};</pre></div></li><li class="listitem">Inside the <code class="literal">Battlefield</code> scene, add a new instance variable called <code class="literal">_aiState</code>, which is of the <code class="literal">AIState</code> type.</li><li class="listitem">Open the <code class="literal">Ship.h</code> file.</li><li class="listitem">Add a callback block type, as shown in the following line of code:<div><pre class="programlisting">typedef void(^ShipCallback)(void);</pre></div></li><li class="listitem">Declare three new methods<a id="id380" class="indexterm"/> for the <code class="literal">Ship</code> class, as shown in the following code:<div><pre class="programlisting">-(void) moveToX:(float)x andY:(float)y withBlock:(ShipCallback) block;
-(float) checkDistanceToShip:(Ship *)ship;
-(void) moveToShip:(Ship *)ship withBlock:(ShipCallback) block;</pre></div></li><li class="listitem">Open the <code class="literal">Ship.m</code> file.</li><li class="listitem">Move the contents of the <code class="literal">-(void) moveToX:(float) x andY:(float) y</code> method into the <code class="literal">-(void) moveToX:(float)x andY:(float)y withBlock:(ShipCallback) block</code> method.</li><li class="listitem">Inside the new <code class="literal">moveTo</code> method, add the following code just after the <code class="literal">[tweenY animateProperty:@"y" targetValue:targetY];</code> line:<div><pre class="programlisting">__block BOOL isTweenXCompleted = NO;
__block BOOL isTweenYCompleted = NO;

tweenX.onComplete = ^{
  isTweenXCompleted = YES;
  
  if (isTweenXCompleted &amp;&amp; isTweenYCompleted) {
    if (block != nil) {
      [block invoke];
    }
  }
};

tweenY.onComplete = ^{
  isTweenYCompleted = YES;
  
  if (isTweenXCompleted &amp;&amp; isTweenYCompleted) {
    if (block != nil) {
      [block invoke];
    }
  }
};</pre></div></li><li class="listitem">Implement the <code class="literal">checkDistanceToShip</code> method with the following code:<div><pre class="programlisting">-(float) checkDistanceToShip:(Ship *)ship
{
SPPoint* p1 = [SPPoint pointWithX:self.x + (self.width / 2) y:self.y + (self.height / 2)];
SPPoint* p2 = [SPPoint pointWithX:ship.x + (ship.width / 2) y:ship.y + (ship.height / 2)];

float distance = [SPPoint distanceFromPoint:p1 toPoint:p2];

return distance;
}</pre></div></li><li class="listitem">The <code class="literal">moveToShip</code> method <a id="id381" class="indexterm"/>should have the following body:<div><pre class="programlisting">-(void) moveToShip:(Ship *)ship withBlock:(ShipCallback)block
{
    floatrandomX = arc4random_uniform(80) - 40.0f;
    floatrandomY = arc4random_uniform(80) - 40.0f;

    [self moveToX:ship.x + randomX andY:ship.y + randomY withBlock:block];
}</pre></div></li><li class="listitem">Reimplement the <code class="literal">moveToX:(float)x andY:(float)y</code> method, as shown in the following code:<div><pre class="programlisting">-(void) moveToX:(float)x andY:(float)y
{
 [self moveToX:x andY:y withBlock: nil];
}</pre></div></li><li class="listitem">Move on to the <code class="literal">Battlefield.m</code> file.</li><li class="listitem">Inside the initializer, set the <code class="literal">_aiState</code> instance variable to <code class="literal">StateWanderAround</code>, as shown in the following line of code:<div><pre class="programlisting">_aiState = StateWanderAround;</pre></div></li><li class="listitem">Remove the tween and the juggler.</li><li class="listitem">Let's declare a helper method for getting a random position on the screen, as shown in the following code:<div><pre class="programlisting">-(SPPoint *) randomPos
{
  return [SPPoint pointWithX:((arc4random() % (int) (Sparrow.stage.width - 80.0f)) + 40.0f) y:((arc4random() % (int) (Sparrow.stage.height - 80.0f)) + 40.0f)];
}</pre></div></li><li class="listitem">Define a method called <code class="literal">updateAI</code>, as shown in the following code:<div><pre class="programlisting">-(void) updateAI: (Ship *)ship withState: (AIState) aiState
{
switch (aiState) {
caseStateWanderAround: {
SPPoint *point = [self randomPos];
            [ship moveToX:point.x andY:point.y withBlock:^{
if ([ship checkDistanceToShip:_pirateShip] &lt; 200.0f) {
                    //In sight
                    [self updateAI:ship withState:StateMoveToPlayer];
                } else {
                    //Not in sight
                    [self updateAI:ship withState:aiState]
                }
            }];
        }
break;
caseStateMoveToPlayer: {
            [ship moveToShip:_pirateShip WithBlock:^{
if ([ship checkDistanceToShip:_pirateShip] &lt; 100.0f) {
                    // Attack
                    [self updateAI:ship withState:StateAttack];
                } else {
                    //Not in sight
                    [self updateAI:ship   withState:StateWanderAround];
                }
            }];
        }
break;
default:
break;
    }
}</pre></div></li><li class="listitem">Call the <code class="literal">updateAI</code> method <a id="id382" class="indexterm"/>at the point where we initialized the juggler previously, as shown in the following code:<div><pre class="programlisting">[self updateAI:_enemyShip withState:_aiState];</pre></div></li><li class="listitem">Run the example.<p>We now see that our own ship and the enemy ship are moving around on their own.</p><div><img src="img/1509OS_08_03.jpg" alt="Time for action – getting the enemy ship to move around"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec104"/>
<em>What just happened?</em>
</h2></div></div></div><p>In step 1, we opened our game project; in the next step, we looked into the <code class="literal">Battlefield.h</code> file. All of the AI<a id="id383" class="indexterm"/> states we previously mentioned were put into <code class="literal">enum</code>. In step 4, we defined an instance variable that holds the default AI state.</p><p>We already had a <code class="literal">moveTo</code> method in our <code class="literal">Ship</code> class which lets us move any ship around on the screen. Unfortunately, we currently don't have a way of knowing when the movement is over. We can employ an Objective-C language feature which we used in the previous chapters, that is, blocks. We defined a block as a parameter; when the movement was over, the block was called. In step 6, we defined our block type.</p><p>In the next step, we declared the general methods for our <code class="literal">Ship</code> class:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moving to a position and using a callback once the movement is done</li><li class="listitem" style="list-style-type: disc">Checking the distance between the current ship and any other ship</li><li class="listitem" style="list-style-type: disc">Moving to another ship and using a callback once the operation is over</li></ul></div><p>We then got ready to implement these methods in step 8. We first moved the contents of the old <code class="literal">moveTo</code> method to the new one with the callback.</p><p>Then, we just needed to call the callback block once the animation was over. Since the tweens could potentially have two different speeds depending on the distance between the touch point and the ship, we needed to record whether each tween was completed for both of the tweens. To check if the tween was actually complete, we added a block to the <code class="literal">onComplete</code> property of the tween. Once the tween was done, the block got called. Inside this block, we set a Boolean value to flag that the current tween was complete, and if both tweens are complete, we invoked the callback. To be able to use our local variables in the <code class="literal">onComplete</code> blocks, we needed to prefix them with <code class="literal">__blocks</code>.</p><p>In step 11, we implemented a method that calculates the distance between two ships: we took the center of both ships, converted them into <code class="literal">SPPoint</code>, and utilized the static <code class="literal">distanceFromPoint</code> method that <code class="literal">SPPoint</code> provides. We only needed to return the result.</p><p>The <code class="literal">moveToShip</code> method called the <code class="literal">moveTo</code> method with the coordinates of the ship passed in and some randomness<a id="id384" class="indexterm"/> attached to it. We used the <code class="literal">arc4random</code> function to get a random value. The <code class="literal">arc4random</code> function returned a floating point number between zero and one. The <code class="literal">arc4random_uniform</code> function took a parameter and created a random number between zero and the passed-in parameter minus one. In step 13, the <code class="literal">moveTo</code> method without the callback just called the <code class="literal">moveTo</code> version, with the callback passing through <code class="literal">nil</code> as the callback parameter.</p><p>When we moved to the <code class="literal">Battlefield.m</code> file, we set the <code class="literal">_aiState</code> instance variable to the <code class="literal">WanderState</code> AI state. We then safely removed the tween and the juggler, which were previously responsible for the enemy ships' move animation.</p><p>In step 17, we implemented a method that gets us a random position on the screen. We also set a margin so that the position was definitely within the borders of the screen. We used the <code class="literal">SPPoint</code> class factory method to store both the <code class="literal">x</code> and <code class="literal">y</code> positions.</p><p>In the next step, we implemented the method that updates the AI:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the ship is wandering around, we get a random position and move there.</li><li class="listitem" style="list-style-type: disc">If the ship has moved, it checks if the distance <a id="id385" class="indexterm"/>between the player and the ship parameter is less than 200 points. The ship then moves to the player. If that's not the case, we call the <code class="literal">updateAI</code> method again with the <code class="literal">WanderState</code> AI state.</li><li class="listitem" style="list-style-type: disc">If the ship moved to the player, it checks again for the distance. If it's lower than 100 points, it begins attacking, else it's back to wandering around.</li></ul></div><p>Inside the initializer, we called the <code class="literal">updateAI</code> method with the enemy ship and our default AI state. This should be right where we previously initialized our instance variable <code class="literal">_juggler</code>.</p><p>When we ran the example, the enemy ship moved around if it was in the correct state. It moved to the player ship if it was in sight. If the enemy ship was getting too close to the player, it just stopped.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Attacking other ships</h2></div></div></div><p>Now that the enemy ship is moving around, let's get it to attack our own ship.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec102"/>Time for action – the enemy should attack the player</h1></div></div></div><p>For the enemy to attack the players' ship, use<a id="id386" class="indexterm"/> the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Ship.h</code> file.</li><li class="listitem">Refactor our <code class="literal">_juggler</code> instance variable to be a property, as shown in the following line of code:<div><pre class="programlisting">@property SPJuggler *juggler;</pre></div></li><li class="listitem">Using the following line of code, add a method called <code class="literal">shootWithBlock</code> that should shoot and have a callback as its parameter:<div><pre class="programlisting">-(void) shootWithBlock:(ShipCallback) block;</pre></div></li><li class="listitem">Open the <code class="literal">Ship.m</code> file and move the contents of the <code class="literal">shoot</code> method into the <code class="literal">shootWithBlock</code> method.</li><li class="listitem">In the <code class="literal">shootWithBlock</code> method, invoke the callback as its last statement inside the complete listener of the <code class="literal">currentClip</code> variable.</li><li class="listitem">Update the <code class="literal">shoot</code> method to call the <code class="literal">shootWithBlock</code> method with <code class="literal">nil</code>.</li><li class="listitem">Open the <code class="literal">Battlefield.m</code> file and add a method for collision detection, as shown in the following code:<div><pre class="programlisting">-(void) checkShipCollision: (Ship *) ship1 againstShip: (Ship *) ship2
{
    SPRectangle *enemyShipBounds = [ship1 boundsInSpace:self];
    SPRectangle *ball1 = [ship2.cannonBallLeft boundsInSpace:self];
    SPRectangle *ball2 = [ship2.cannonBallRight boundsInSpace:self];
    
    if ([enemyShipBounds intersectsRectangle:ball1] || [enemyShipBounds intersectsRectangle:ball2]) {
        if (ship2.cannonBallLeft.visible || ship2.cannonBallRight.visible) {
            [ship2 abortShooting];
            [ship1 hit];
        }
    }
}</pre></div></li><li class="listitem">Inside the <code class="literal">onEnterFrame</code> method, replace the current collision detection with the <code class="literal">checkShipCollision</code> method, as shown in the following code:<div><pre class="programlisting">[self checkShipCollision:_pirateShipagainstShip:_enemyShip];
[self checkShipCollision:_enemyShipagainstShip:_pirateShip];</pre></div></li><li class="listitem">Update the <code class="literal">WanderAround</code> AI state with an additional attack opportunity, as shown in the following code:<div><pre class="programlisting">if ([ship checkDistanceToShip:_pirateShip] &lt; 200.0f) {
<strong>  if ([ship checkDistanceToShip:_pirateShip] &lt; 100.0f) {</strong>
<strong>    // Attack directly</strong>
<strong>    [self updateAI:ship withState:StateAttack];</strong>
<strong>  } else {</strong>
<strong>    //In sight</strong>
<strong>    [self updateAI:ship withState:StateMoveToPlayer];</strong>
<strong>  }</strong>
} else {
  //Not in sight
  [self updateAI:ship withState:aiState];
}</pre></div></li><li class="listitem">As shown in the<a id="id387" class="indexterm"/> following code, add these states to our <code class="literal">switch</code>-<code class="literal">case</code> statements in our <code class="literal">updateAI</code> method:<div><pre class="programlisting">case StateAttack: {
  [ship shootWithBlock:^{
    [self updateAI:ship withState:StateRecuperate];
  }];
}
case StateRecuperate: {
  [ship.juggler delayInvocationByTime:0.3f block:^{
    [self updateAI:ship withState:StateWanderAround];
  }];
}</pre></div></li><li class="listitem">Run the example to see the result.<p>If the enemy ship gets close enough to our ship and is in the attacking state, it begins to attack our ship. Refer to the following screenshot:</p><div><img src="img/1509OS_08_04.jpg" alt="Time for action – the enemy should attack the player"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec106"/>
<em>What just happened?</em>
</h2></div></div></div><p>In the <code class="literal">Ship.h</code> file, we refactored the <code class="literal">_juggler</code> instance variable into a property since we needed to access it from the battlefield scene and its access should not be limited to a <code class="literal">Ship</code> instance. We added the <code class="literal">shootWithBlock</code> method, which we implemented in step 4, where we moved the contents of the <code class="literal">shoot</code> method to the new <code class="literal">shootWithBlock</code> method.</p><p>We then invoked the<a id="id388" class="indexterm"/> callback that should now be the last statement in the event listener where the <code class="literal">currentClip</code> tween is completed. In step 6, we updated the <code class="literal">shoot</code> method to call the <code class="literal">shootWithBlock</code> method with an empty block, just like we did in the previous example.</p><p>Since we used collision detection more than once, we put it into a separate method in the next step. Now, we can replace our old collision detection logic by calling the new collision detection. We need to call it twice, once with <code class="literal">_pirateShip</code> as the first parameters and <code class="literal">_enemyShip</code> as the second parameter. The order of the parameter needs to be the other way around when we call <code class="literal">checkShipCollision</code> for the second time.</p><p>In step 9, we added an additional state transition. If the distance between the pirate ship and the enemy ship was less than 100 points, it attacked directly instead of moving to the player first. In the following steps, we added the following two missing states:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the attack state, we called the <code class="literal">shootWithBlock</code> method, and when the shooting was complete, we moved to the recuperating state</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">StateRecuperate</code> AI state, we waited for 0.3 seconds and then moved on to wandering around</li></ul></div><p>When we ran the example, our state machine was completely finished and all states were being used.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Adding fuzzy values to the AI</h2></div></div></div><p>Our AI works so far, but we don't have any fuzzy logic yet.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec103"/>Time for action – spicing up the AI with fuzzy values</h1></div></div></div><p>To replace our <a id="id389" class="indexterm"/>hardcoded values, we need<a id="id390" class="indexterm"/> to use the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Battlefield.m</code> file.</li><li class="listitem">Add a new method called <code class="literal">fuzzyValue</code>, as shown in the following code:<div><pre class="programlisting">-(float) fuzzyValue: (NSString *) value
{
  if ([value isEqualToString:@"Very near"]) {
    return (float) (arg4random() % 40) + 40.0f;
  } else if ([value isEqualToString:@"Quite near"]) {
    result = (float) (arc4random() % 30) + 70.0f;
  } else {
    result = (float) (arc4random() % 50) + 150.0f;
  }
}</pre></div></li><li class="listitem">Using the following code, update<a id="id391" class="indexterm"/> the hardcoded values with the values from the <code class="literal">fuzzyValue</code> method:<div><pre class="programlisting">if ([ship checkDistanceToShip:_pirateShip] &lt; [self fuzzyValue:@"Near"]) {
if ([ship checkDistanceToShip:_pirateShip] &lt; [self fuzzyValue:@"Very near"]) {
if ([ship checkDistanceToShip:_pirateShip] &lt; [self fuzzyValue:@"Quite near"]) {</pre></div></li><li class="listitem">Run the example. If <a id="id392" class="indexterm"/>we were to insert logging to see what the values actually are, we would see the following output:<div><img src="img/1509OS_08_05.jpg" alt="Time for action – spicing up the AI with fuzzy values"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec108"/>
<em>What just happened?</em>
</h2></div></div></div><p>The goal for this example is to replace our hardcoded values with something that resembles fuzzy logic. In step 2, we added a method that checks against the value and returns a new random value each time. The randomness is not a necessary factor of fuzzy logic, but it is used in this case so that the values are inside a specific range.</p><p>If we were to have more fuzzy values, it would be a good idea to hold those values inside <code class="literal">NSDictionary</code>. This dictionary would have a colloquial term as its key and a block for its value. Inside the block would be logic to return a random number. If the fuzzy value gets passed in, we call the block and get a random number.</p><p>Next up, we updated the hardcoded values with the <code class="literal">fuzzyValue</code> method and put it in a colloquial term each time.</p><p>When we ran the example, the AI worked like it did before, but it had additional randomness now.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Have a go hero</h2></div></div></div><p>We can improve the AI quite a bit by moving the AI logic away from the battlefield scene into a separate class. Since we used the strings for our fuzzy values quite a lot, it may be a good idea to move them into constants or even create our own macros.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec104"/>Adding progression to our game</h1></div></div></div><p>Now that our AI is implemented, let's add some progression to our game. We will need to add levels. Each level should have one more<a id="id393" class="indexterm"/> enemy ship, and we can upgrade the damage and hit points of our ship in between the levels.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Adding a World class</h2></div></div></div><p>We need to keep some values, such as the current level, in a separate entity, which we will describe as a <code class="literal">World</code> class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec105"/>Time for action – adding a World class</h1></div></div></div><p>To implement our <code class="literal">World</code> class, we <a id="id394" class="indexterm"/>need to use the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new Objective-C class <a id="id395" class="indexterm"/>called <code class="literal">World</code>, which is derived from <code class="literal">NSObject</code>.</li><li class="listitem">To add a <code class="literal">level</code> property from the <code class="literal">int</code> type, do the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add a static variable called <code class="literal">level</code> in <code class="literal">World.h</code>, as shown in the following line of code:<div><pre class="programlisting">static int level;</pre></div></li><li class="listitem" style="list-style-type: disc">Add a static getter with the same name that returns the static variable, as shown in the following line of code:<div><pre class="programlisting">+(int) level;</pre></div></li><li class="listitem" style="list-style-type: disc">Add a static setter (<code class="literal">setLevel</code>) that sets the static variable, as shown in the following line of code:<div><pre class="programlisting">+(void) setLevel:(int)value;</pre></div></li></ul></div></li><li class="listitem">Repeat step 2 for the properties <code class="literal">gold</code>, <code class="literal">hitpoints</code>, and <code class="literal">damage</code>.</li><li class="listitem">We also need a <code class="literal">levelMax</code> property, but this one does not have a setter.</li><li class="listitem">We need to import the <code class="literal">Assets.h</code> file inside the <code class="literal">World.m</code> file.</li><li class="listitem">Add a static <code class="literal">reset</code> method that needs to be declared in <code class="literal">World.h</code>. It should look like the following piece of code:<div><pre class="programlisting">+(void) reset
{
    level = 1;
    levelMax = 3;
    gold = 200;
    damage = [(NSNumber *) [Assets dictionaryFromJSON:@"gameplay.json"][@"damage"] intValue];
    hitpoints = [(NSNumber *) [Assets dictionaryFromJSON:@"gameplay.json"][@"hitpoints"] intValue];
}</pre></div></li><li class="listitem">We also need a <code class="literal">log</code> method. It needs to be<a id="id396" class="indexterm"/> declared in <code class="literal">World.h</code> and needs to look like the following code:<div><pre class="programlisting">+(void) log
{
    NSLog(@"Level %d of %d", level, levelMax);
    NSLog(@"Gold: %d", gold);
    NSLog(@"Players' hit points: %d", hitpoints);
    NSLog(@"Players' damage: %d", damage);
}</pre></div></li><li class="listitem">In <code class="literal">Game.m</code>, we need to call the <code class="literal">World</code> methods inside its initializer, as shown in the following code:<div><pre class="programlisting">[director addScene:battlefield];

<strong>[World reset];</strong>
<strong>[World log];</strong>

[director showScene:@"battlefield"];</pre></div></li><li class="listitem">Run the example to see the result. We should now see the following output in the console:<div><img src="img/1509OS_08_06.jpg" alt="Time for action – adding a World class"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec111"/>
<em>What just happened?</em>
</h2></div></div></div><p>First of all, we created the <code class="literal">World</code> class. Objective-C does not support static properties. We can imitate that behavior of having a static property if we add static methods that have <code class="literal">methodName</code> as their name where we return a value. We also need to define a method called <code class="literal">setMethodName</code> that has a parameter. Now we can access <code class="literal">methodName</code> just like a property. However, inside the pseudo-getter, we can only access static variables.</p><p>After we were done with the setup, we<a id="id397" class="indexterm"/> needed to import the <code class="literal">Assets</code> class in step 5. After that, we added a <code class="literal">reset</code> method, which loaded the damage and hit points from our <code class="literal">gameplay.json</code> file. We set the <code class="literal">gold</code>, <code class="literal">level</code>, and <code class="literal">levelMax</code> variables to default values. In our case, the current level was the first one; we had a maximum of three levels, and 200 was the amount we had at our disposal at the start for the <code class="literal">gold</code> variable.</p><p>The <code class="literal">log</code> method that we implemented later logged all values except for the <code class="literal">levelMax</code> value. In step 8, we called the <code class="literal">reset</code> method, and we called <code class="literal">log</code> directly after that. When we ran the example, we saw the log output in the console.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Have a go hero</h2></div></div></div><p>Right now, the <code class="literal">gold</code>, <code class="literal">level</code>, and <code class="literal">levelMax</code> variables are being set directly in the code. It's a better idea to load them from the <code class="literal">gameplay.json</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec113"/>Updating the scene and dialog classes</h2></div></div></div><p>Before we move on to implementing the progression system, there are a few small things we need to refactor. Let's tackle these issues:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have no way of resetting a scene if it's being shown again</li><li class="listitem" style="list-style-type: disc">Multiline strings in dialogs are not displayed correctly</li><li class="listitem" style="list-style-type: disc">We cannot access the dialog's buttons outside the <code class="literal">Dialog</code> class</li><li class="listitem" style="list-style-type: disc">The dialog doesn't close after clicking on the buttons</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec106"/>Time for action – updating the scene and dialog classes</h1></div></div></div><p>To add our first buttons, use<a id="id398" class="indexterm"/> the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Dialog.h</code> file.</li><li class="listitem">Add properties for <a id="id399" class="indexterm"/>both <strong>Yes</strong> and <strong>No</strong> buttons using the following code:<div><pre class="programlisting">@propertySPButton *buttonYes;
@propertySPButton *buttonNo;</pre></div></li><li class="listitem">Switch to <code class="literal">Dialog.m</code>.</li><li class="listitem">Refactor all references from the local variables to use the properties.</li><li class="listitem">Update the positions of <code class="literal">_title</code> and <code class="literal">_content</code> using the following code:<div><pre class="programlisting">content = [SPTextField textFieldWithWidth:background.width - <strong>96.0f </strong>height:background.height - 150.0f text:@"Dialog default text"];
_content.x = <strong>52.0f</strong>;
_content.y = <strong>66.0f</strong>;

[SPTextField registerBitmapFontFromFile:@"PirateFont.fnt"];

_title = [SPTextField textFieldWithWidth:background.width * 0.6 height:30.0f text:@"Dialog"];
_title.fontName = @"PirateFont";
_title.color = SP_WHITE;

_title.x = <strong>36.0f</strong>;
_title.y = 26.0f;</pre></div></li><li class="listitem">In both <code class="literal">onButtonYes</code> and <code class="literal">onButtonNo</code>, add <code class="literal">self.visible = NO;</code> as the first statement.</li><li class="listitem">In <code class="literal">Scene.h</code>, declare a method called <code class="literal">reset</code> using the following line of code:<div><pre class="programlisting">-(void) reset;</pre></div></li><li class="listitem">In <code class="literal">Scene.m</code>, implement the <code class="literal">reset</code> method with an empty body.</li><li class="listitem">In <code class="literal">SceneDirector.m</code>, update this portion of code in the <code class="literal">showScene</code> method:<div><pre class="programlisting">if (_dict[name] != nil) {
  ((Scene *) _dict[name]).visible = YES;
<strong>  [((Scene *) _dict[name]) reset];</strong>
  
}</pre></div></li><li class="listitem">Run the example.<p>If we were to implement the <code class="literal">reset</code> method to the battlefield scene and add a logger message to the <code class="literal">reset</code> method of the battlefield scene, our output would change to this:</p><div><img src="img/1509OS_08_07.jpg" alt="Time for action – updating the scene and dialog classes"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec114"/>
<em>What just happened?</em>
</h2></div></div></div><p>We tackled the dialog issues first. In steps 2 to 4, we moved the buttons to be properties and updated all references inside the <code class="literal">Dialog</code> implementation. We then updated the position of the title and the message content. Long strings were not wider than the bounds of the dialog. In step 6, we hid the dialog once we tapped on any button.</p><p>For a scene to be able to reset itself, we first needed to add the <code class="literal">reset</code> method and just implement it as an empty method in <code class="literal">Scene.m</code>. We then needed to update the scene director to call the <code class="literal">reset</code> method from the current scene just after the scene turned visible.</p><p>If we ran the example now, and if we implemented the <code class="literal">reset</code> method in the battlefield scene and added a logger message, we would see that the <code class="literal">reset</code> method from the battlefield scene would actually be called.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec115"/>Adding game mechanics to the pirate cove</h2></div></div></div><p>Now that we have a <code class="literal">World</code> class and we have updated the <code class="literal">Dialog</code> and <code class="literal">Scene</code> classes to fit our needs, we can add some game mechanics to the pirate cove. The pirate cove is the place where we can upgrade our ship.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec107"/>Time for action – making the pirate cove playable</h1></div></div></div><p>To add game mechanics<a id="id400" class="indexterm"/> to the pirate cove, use the <a id="id401" class="indexterm"/>following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Move the line of code <code class="literal">[SPTextField registerBitmapFontFromFile:@"PirateFont.fnt"];</code> from <code class="literal">Dialog.m</code> to the beginning of the <code class="literal">Game.m</code> file.</li><li class="listitem">Add a button<a id="id402" class="indexterm"/> in <code class="literal">PirateCove.m</code>, as shown in the following code:<div><pre class="programlisting">SPButton *buttonBattle = [SPButton buttonWithUpState:[[Assets textureAtlas:@"ui.xml"] textureByName:@"dialog_yes"]; 
text:@"Begin battle"];

buttonBattle.y = Sparrow.stage.height - buttonBattle.height - 8.0f;
buttonBattle.x = (Sparrow.stage.width - buttonBattle.width) / 2;

[buttonBattle addEventListenerForType:SP_EVENT_TYPE_TRIGGERED block:^(SPEvent *event){
  [((SceneDirector *) self.director) showScene:@"battlefield"];
}];</pre></div></li><li class="listitem">Add the button to the display tree using the following line of code:<div><pre class="programlisting">[self addChild:buttonBattle];</pre></div></li><li class="listitem">In the following code, we add a text field to display the current amount of gold, which needs to<a id="id403" class="indexterm"/> be declared as an instance variable first:<div><pre class="programlisting">_goldTextField = [SPTextField textFieldWithWidth:Sparrow.stage.width - 16.0f height:30.0f text:@"Gold"];
_goldTextField.fontName = @"PirateFont";
_goldTextField.color = SP_WHITE;

_goldTextField.x = 8.0f;
_goldTextField.y = 8.0f;</pre></div></li><li class="listitem">Add the text field to the display tree using the following line of code:<div><pre class="programlisting">[self addChild:_goldTextField];</pre></div></li><li class="listitem">Add a method<a id="id404" class="indexterm"/> that updates the amount of gold on the screen using the following code:<div><pre class="programlisting">-(void) updateGoldTextField
{
    _goldTextField.text = [NSString stringWithFormat:@"Gold: %d", World.gold];
}</pre></div></li><li class="listitem">Inside the <code class="literal">PirateCove.h</code> file, add an instance variable called<code class="literal">_dialogUpdateDamage</code> using the following line of code:<div><pre class="programlisting">Dialog *_dialogUpdateDamage;</pre></div></li><li class="listitem">Add an instance variable called <code class="literal">_goldDamage</code> as shown in the following line of code:<div><pre class="programlisting">int _goldDamage;</pre></div></li><li class="listitem">Inside the initializer, add the following piece of code for the first dialog:<div><pre class="programlisting">_dialogUpdateDamage = [[Dialog alloc] init];

_dialogUpdateDamage.title.text = @"Update damage?";

_dialogUpdateDamage.x = (Sparrow.stage.width - _dialogUpdateDamage.width) / 2;
_dialogUpdateDamage.y = (Sparrow.stage.height - _dialogUpdateDamage.height) / 2;

_dialogUpdateDamage.visible = NO;

[weaponsmith addEventListenerForType:SP_EVENT_TYPE_TOUCH block:^(SPEvent *event){
  if (World.gold &lt; _goldDamage) {
    _dialogUpdateDamage.buttonYes.enabled = NO;
  }
  
  _dialogUpdateDamage.visible = YES;
}];

[_dialogUpdateDamage addEventListener:@selector(onUpdateDamage:) atObject:self forType:EVENT_TYPE_YES_TRIGGERED];</pre></div></li><li class="listitem">Add the dialog to the display tree using the following line of code:<div><pre class="programlisting">[self addChild:_dialogUpdateDamage];</pre></div></li><li class="listitem">Add the <a id="id405" class="indexterm"/>method <code class="literal">onUpdateDamage</code> as follows:<div><pre class="programlisting">-(void) onUpdateDamage: (SPEvent *) event
{
World.damage = World.damage + (int) (World.damage / 10);
World.gold = World.gold - _goldDamage;
    [self updateGoldTextField];
}</pre></div></li><li class="listitem">Repeat steps 7 to 11 for the dialog that upgrades the hit points.</li><li class="listitem">Add a <code class="literal">reset</code> method to<a id="id406" class="indexterm"/> the pirate cove scene as follows:<div><pre class="programlisting">-(void) reset
{
    _goldDamage = (150 + (50 * (World.level - 1)));
    _dialogUpdateDamage.content.text = [NSString stringWithFormat:@"Increasing damage costs %d gold. Do you wish to proceed?", _goldDamage];

    _goldHitpoints = (200 + (75 * (World.level - 1)));
    _dialogUpdateHitpoints.content.text = [NSString stringWithFormat:@"Increasing hitpoints costs %d gold. Do you wish to proceed?", _goldHitpoints];

    [self updateGoldTextField];
}</pre></div></li><li class="listitem">Update the statement in the <code class="literal">Game.m</code> file to show the pirate cove when starting the game.</li><li class="listitem">Run the example to see the result. We can now upgrade our ship in the pirate cove, as shown in the following screenshot:<div><img src="img/1509OS_08_08.jpg" alt="Time for action – making the pirate cove playable"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec116"/>
<em>What just happened?</em>
</h2></div></div></div><p>In step 1, we moved the registration of the bitmap font to the <code class="literal">Game</code> class. We only needed it once. Since we only had one dialog <a id="id407" class="indexterm"/>previously, it didn't really matter where we registered the font. However, as we now have multiple dialogs, the initializer of the dialog would register the font multiple times.</p><p>In step 2, we added a button that will be able to switch to the battlefield scene when we tap it. After we added the button to the display tree, we also added a text field to display the current amount of gold. We subsequently added the text field to the display tree. We also added a method that <a id="id408" class="indexterm"/>updates the text field.</p><p>In steps 6 to 11, we added a dialog to the screen that pops up when we tap the weaponsmith. It checks if we have enough gold at our disposal and lets us upgrade our damage if we do.</p><p>In step 13, we implemented the <code class="literal">reset</code> method. The intention is to make upgrading the ship more and more expensive depending on the current level.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec117"/>Adding progression to the game</h2></div></div></div><p>Everything is set in place for adding <a id="id409" class="indexterm"/>progression to the game.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Have a go hero –turning our game into a real game</h2></div></div></div><p>Let's go ahead and implement game progression. The following are a few things you should keep in mind:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">World</code> values need to be reset before the battlefield instance is created</li><li class="listitem" style="list-style-type: disc">Update the amount of gold once the player gets to a higher level</li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">reset</code> method of the battlefield scene to reset position and hit points</li><li class="listitem" style="list-style-type: disc">There needs to be a way to keep track of all the sunken ships</li><li class="listitem" style="list-style-type: disc">The enemies should probably be array-like objects</li><li class="listitem" style="list-style-type: disc">The game itself should not start when the battlefield is initialized</li></ul></div><p>After considering<a id="id410" class="indexterm"/> the preceding points, the game should look like what is shown in the following screenshot:</p><div><img src="img/1509OS_08_09.jpg" alt="Have a go hero –turning our game into a real game"/></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Take a look at how the preceding points can be implemented, and take these source files as the base for the following exercises:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Battlefield.h</code>: <a class="ulink" href="https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h">https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">Battlefield.m</code>: <a class="ulink" href="https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m">https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">Game.m</code>: <a class="ulink" href="https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m">https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">Ship.h</code>: <a class="ulink" href="https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h">https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">Ship.m</code>: <a class="ulink" href="https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m">https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">gameplay.json</code>: <a class="ulink" href="https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json">https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json</a></li></ul></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec108"/>Adding win and lose conditions</h1></div></div></div><p>The last thing we will do in this chapter is add win and lose conditions for our game. Right now, we will just show a text field that displays whether we have won or lost.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec109"/>Time for action – being able to win or lose</h1></div></div></div><p>To be able to win or lose the game, use<a id="id411" class="indexterm"/> the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">Ship.h</code>, add a callback <a id="id412" class="indexterm"/>property using the following line of code:<div><pre class="programlisting">@property (nonatomic, copy) ShipCallbackonDead;</pre></div></li><li class="listitem">This callback <a id="id413" class="indexterm"/>property gets invoked if the ship is equal to or <a id="id414" class="indexterm"/>less than zero hit points, as shown in the following code:<div><pre class="programlisting">if (_hitpoints&lt;= 0) {
  self.visible = FALSE;
  
<strong>  if (self.onDead) {</strong>
<strong>    [_onDead invoke];</strong>
<strong>  }</strong>
}</pre></div></li><li class="listitem">In the <code class="literal">Battlefield.h</code> file, add two properties for our new text fields as shown:<div><pre class="programlisting">@property SPTextField *textGameWon;
@property SPTextField *textGameLost;</pre></div></li><li class="listitem">In the initializer, add the following piece of code:<div><pre class="programlisting">_textGameLost = [SPTextField textFieldWithWidth:Sparrow.stage.width height:Sparrow.stage.height text:@"Game Over"];
_textGameLost.fontName = @"PirateFont";
_textGameLost.color = SP_WHITE;
_textGameLost.visible = NO;

_textGameWon = [SPTextField textFieldWithWidth:Sparrow.stage.width height:Sparrow.stage.height text:@"You won the game. Well done"];
_textGameWon.fontName = @"PirateFont";
_textGameWon.color = SP_WHITE;
_textGameWon.visible = NO;

__weak typeof(self) weakSelf = self;
_pirateShip.onDead = ^{
  weakSelf.textGameLost.visible = YES;
};
//...
[self addChild:_textGameLost];
[self addChild:_textGameWon];</pre></div></li><li class="listitem">Inside the <code class="literal">onEnterFrame</code> method, update<a id="id415" class="indexterm"/> the progression system by adding the winning condition as shown:<div><pre class="programlisting">if (deadCount == World.level) {
<strong>  if (World.level == World.levelMax) {</strong>
<strong>    self.textGameWon.visible = YES;</strong>
<strong>  } else {</strong>
    World.gold = World.gold + (250 * World.level);
    World.level++;
    self.paused = YES;
    [((SceneDirector *) self.director) showScene:@"piratecove"];
  }
}</pre></div></li><li class="listitem">Run the example<a id="id416" class="indexterm"/> to see the result.<p>If we now win or lose the game, a text field will be displayed on the screen, as shown in the following screenshot:</p><div><img src="img/1509OS_08_10.jpg" alt="Time for action – being able to win or lose"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec119"/>
<em>What just happened?</em>
</h2></div></div></div><p>We needed to know the exact point when a ship gets destroyed, so we added a callback in steps 1 and 2. Precisely at the moment when the player ship gets destroyed, we wanted to display something to inform that the player has lost the game.</p><p>We then added the text fields in <a id="id417" class="indexterm"/>steps 3 and 4. The only thing we needed to consider here is that we need to access <code class="literal">self</code> (the instance itself) inside the block. Typically, we can't access any property from <code class="literal">self</code> in the block, but we do need this because the text field is a property on the instance itself. So, we needed to use an unsafe reference by using<a id="id418" class="indexterm"/> the <code class="literal">__weak</code> keyword. This is something that should be used with caution and, in general, only as a last resort. We also needed to make sure that the text fields were added as the last elements to the display tree so that they were always on top of all other elements. After we added the lose condition, we added the win condition in step 5. When we ran the example, we saw a text popping up if we either lost or won the game.</p><p>Technically, we could also have created the text field dynamically once we won. It is best practice, however, to create everything at the beginning, especially with complex projects.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec120"/>Pop quiz</h2></div></div></div><p>Q1. <code class="literal">SPPoint</code> provides a method to get the distance between two points.</p><div><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q2. A finite state machine always needs transitions.</p><div><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q3. If we want to modify a local variable inside a block, what do we need to do?</p><div><ol class="orderedlist arabic"><li class="listitem">Make it a weak reference</li><li class="listitem">Prefix the variable with <code class="literal">__block</code></li><li class="listitem">Refactor it to a property</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec110"/>Summary</h1></div></div></div><p>In this chapter, we learned about artificial intelligence. Specifically, we covered fuzzy logic and finite state machines, and we also added more gameplay elements.</p><p>Now that our game is feature-complete but rough around the edges, let's add some audio to our game—which is the topic of the next chapter.</p></div></body></html>