<html><head></head><body><div class="appendix" title="Appendix&#xA0;A.&#xA0;Scripting Languages"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix A. Scripting Languages</h1></div></div></div><p>Scripting languages were originally <a id="id333" class="indexterm"/>intended to be lightweight languages for scripting common tasks, hence the name. They were thought of as languages for command-line utilities or as embedded languages to allow for easy customization of the control flow of a larger program. This appendix introduces how they can work with LevelDB, keeping things simple to help you draw analogies with the code you've learned. It doesn't debate the suitability of LevelDB as a database solution for scripting—the assumption is you're already interested in, or are already using LevelDB and just want to use it with other tools.</p><p>In the scientific world, the usability of Python made it increasingly popular for more complex programs and it has an enjoyed growth in web apps with frameworks such as Django. Ruby on Rails contributed substantially to the popularity of Ruby, to the extent where some people don't consider Ruby as a separate language. JavaScript, more officially ECMAScript, started as a browser language which has also grown into server-side programming. The popular Node.js environment packages it using Google's V8 engine to provide a standalone programming environment easily invoked from native code. In all these cases, the languages offer a relatively low overhead way to call C functions and thus to use external libraries that provide a C or C++ interface.</p><p>Whether writing web applications or local data crunching, database access is often useful. A typical web application uses a database server, and while that may be backed in turn by LevelDB, can't be said to be using LevelDB directly. However, if you need a single-access database, it's convenient to call it from a scripting language and so there have been multiple access layers written for LevelDB from these languages.</p><p>It's important to remember that the primary interface for LevelDB is C++ and that doesn't change just because you're programming in a scripting language. As you've learned through the Objective-C samples in this book, the C++ interface of LevelDB is a very lightweight one. You can regard the scripting language interfaces we look at here as being peers of the Objective-C frameworks we have been using.</p><p>We've seen in several chapters how using a custom comparator can add value to your database especially if you're using composite keys, or for case-insensitive searching. While many of the wrapper projects promise comparators as a future feature, it seems to be a weak point that they lack. Remember a comparator is a C++ object invoked by the core LevelDB code. To be able to implement them in a scripting language would require writing a coding bridge that can call back to the script from C++. Such <code class="literal">callback</code> functions are a lot more complex than the <a id="id334" class="indexterm"/>normal calling direction from script to database library. However, if you were hosting your script interpreter inside a larger native program, you could still write a custom comparator in C++ and have it work with the database.</p><div class="section" title="Using LevelDB from Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec55"/>Using LevelDB from Node.js</h1></div></div></div><p>We went through the installation of <a id="id335" class="indexterm"/>Node.js and the LevelUP and <a id="id336" class="indexterm"/>LevelDOWN wrappers in <a class="link" href="ch07.html" title="Chapter 7. Debugging with REPLs and Command Lines">Chapter 7</a>, <span class="emphasis"><em>Debugging with REPLs and Command Lines</em></span>, as part of the <a id="id337" class="indexterm"/>installation of the <span class="strong"><strong>lev</strong></span> utility. <a id="id338" class="indexterm"/>LevelDOWN is basically a republishing of the C++ interface into <a id="id339" class="indexterm"/>Node.js JavaScript syntax. Both are available, as you saw in the installer, by installing using <span class="strong"><strong>npm</strong></span>, the <span class="strong"><strong>Node Package Manager</strong></span>, and are now bundled into the level package. The homepage, with more installation options is <a class="ulink" href="https://github.com/rvagg/node-levelup">https://github.com/rvagg/node-levelup</a> from which you can also clone the GIT repository if you want to contribute to the project.</p><p>The interesting evolution of LevelUP has been as an abstraction layer hiding the use of LevelDB underneath to the point where it no longer requires an installation of LevelDOWN, but can also work against other implementations including an in-memory store MemDown (see the previously mentioned home page for more details).</p><p>Node.js programs are written as a series of callbacks invoked asynchronously, which makes sense considering its origin as a server-side language for web apps. A simple program that writes some data and reads it back is therefore structured as nested calls:</p><div class="informalexample"><pre class="programlisting">var levelup = require('levelup')
// open a data store
var db = levelup('/tmp/testleveldb11_node.db')
// a simple Put operation
db.put('name', 'William Bloggs', function (err) {
  // a Batch operation made up of 3 Puts (after 1st Put finished)
  db.batch([
      { type: 'put', key: 'spouse', value: 'Josephine Bloggs' }
    , { type: 'put', key: 'dog', value: 'Kilroy' }
    , { type: 'put', key: 'occupation', value: Dev' }
  ], function (err) {
    // asynch after batch put finishes, another nest
    // read store as a stream and print each entry to stdout
    db.createReadStream()
      .on('data', console.log)
      .on('close', function () {
        db.close()
      })
  })  // end of batch Put
})  // end of top-level Put</pre></div><p>There's a huge eco-system of node packages using LevelDB as a modular database. One particularly interesting one is <span class="strong"><strong>levelgraph</strong></span>. <a id="id340" class="indexterm"/>You can download it from the home page <a class="ulink" href="https://github.com/mcollina/levelgraph">https://github.com/mcollina/levelgraph</a> and use with LevelUP to provide the database layer. It provides a full-blown <a id="id341" class="indexterm"/>graph database abstraction using paired keys in a similar manner as our schema support described in <a class="link" href="ch08.html" title="Chapter 8. Richer Keys and Data Structures">Chapter 8</a>, <span class="emphasis"><em>Richer Keys and Data Structures</em></span>. However, levelgraph goes further to support classic triplet operations from graph database theory. It can be extended to <a id="id342" class="indexterm"/>support full RDF triplets with the <a id="id343" class="indexterm"/>levelgraph-n3 plugin from <a class="ulink" href="https://github.com/mcollina/levelgraph-n3">https://github.com/mcollina/levelgraph-n3</a> which enables the compact N3 notation. See <a class="ulink" href="http://www.w3.org/TeamSubmission/n3/">http://www.w3.org/TeamSubmission/n3/</a> if you're interested in graph databases and triplet-based knowledge representation.</p></div></div>
<div class="section" title="Using LevelDB from Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec56"/>Using LevelDB from Python</h1></div></div></div><p>There are a number of Python wrappers <a id="id344" class="indexterm"/>for LevelDB that use the <a id="id345" class="indexterm"/>
<code class="literal">Cython</code> tool <a id="id346" class="indexterm"/>set to generate an interface layer to talk to the C++ classes. The most recent and often recommended is <a id="id347" class="indexterm"/>plyvel: <a class="ulink" href="https://plyvel.readthedocs.org/en/latest/installation.html">https://plyvel.readthedocs.org/en/latest/installation.html</a>.</p><p>However, there's also an even lower-level pure C API for LevelDB that allows you to call directly into functions in the shared library. One simple <a id="id348" class="indexterm"/>Python wrapper <a class="ulink" href="https://code.google.com/p/leveldb-py/">https://code.google.com/p/leveldb-py/</a> is so simple that it is implemented with a single file. That file, <code class="literal">leveldb.py</code>, and the unit tests <code class="literal">test_leveldb.py</code> are included in the sample code for this chapter. You don't need to use a <code class="literal">pip</code> install or other command but just include the file alongside your call.</p><p>This simple wrapper, like many other scripting language wrappers, expects to have a dynamic library in a standard system location. This reflects their Unix heritage. Many installers actually rebuild LevelDB and push it into this location but this one requires you to do that work. To provide this library, go back to the build instructions in <a class="link" href="ch01.html" title="Chapter 1. Downloading LevelDB and Building with OS X">Chapter 1</a>, <span class="emphasis"><em>Downloading LevelDB and Building with OS X</em></span>, but this time, after you have built LevelDB, instead of renaming the static <a id="id349" class="indexterm"/>library, copy four files to <code class="literal">/usr/local/lib</code>:</p><div class="informalexample"><pre class="programlisting">libleveldb.a
libleveldb.dylib
libleveldb.dylib.1
libleveldb.1.12</pre></div><p>This ensures there is a dynamic library in the standard location so that an attempt to open a dynamic library named <code class="literal">leveldb</code> will work.</p><p>The code to write a database similar to the <a id="id350" class="indexterm"/>previous Node.js code seen, looks a lot more like the C++ samples we've seen already:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
import leveldb

# open a data store
db = leveldb.DB("/tmp/testleveldb11_py.db",
 create_if_missing=True)

# a simple Put operation
db.put('name', 'William Bloggs')

# a Batch operation made up of 3 Puts
b = db.newBatch()
db.putTo(b, key = 'spouse', val= 'Josephine Bloggs')
db.putTo(b, key = 'dog', val= 'Kilroy')
db.putTo(b, key = 'occupation', val= 'Dev')
db.write(b, sync=True)
db.close()</pre></div><p>To read that back we can just iterate through all of the keys and get their associated value:</p><div class="informalexample"><pre class="programlisting">for k in db.keys(): 
  print k, db.get(k)</pre></div><p>Apart from supporting all of the basic LevelDB features we've seen so far, <code class="literal">leveldb.py</code> includes prefixing logic similar to that we added in Objective-C so you can get a subset of keys. The unit tests in <code class="literal">test_leveldb.py</code> include code such as:</p><div class="informalexample"><pre class="programlisting">def testPutGet(self):
    db = self.db_class(self.db_path, create_if_missing=True)
    db.put("key1", "val1")
    db.put("key2", "val2", sync=True)
    self.assertEqual(db.get("key1"), "val1")
...
    self.assertEqual(list(db.keys()), ["key1", "key2"])
    self.assertEqual(list(db.keys(prefix="key")), ["1", "2"])</pre></div><p>You can see from the last line that a <a id="id351" class="indexterm"/>prefixed retrieval of keys automatically strips the prefix, similar to what our code was doing to get keys <a id="id352" class="indexterm"/>for the <code class="literal">TableView</code> in Objective-C.</p></div>
<div class="section" title="Using LevelDB from Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec57"/>Using LevelDB from Ruby</h1></div></div></div><p>The most commonly recommended <a id="id353" class="indexterm"/>Ruby wrapper for LevelDB is from <a class="ulink" href="https://github.com/wmorgan/leveldb-ruby">https://github.com/wmorgan/leveldb-ruby</a> and can be installed, as seen in the log file included in the code <a id="id354" class="indexterm"/>samples for this chapter, with a gem command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo gem install leveldb-ruby</strong></span>
</pre></div><p>Note that it has been stalled since 2011 and is minimal, not even including batch support. However, it supports the basics with code similar to the previous Python code:</p><div class="informalexample"><pre class="programlisting">require 'leveldb'
# open a data store
db = LevelDB::DB.new("/tmp/testleveldb11_ruby.db")
# a simple Put operation
db.put('name', 'William Bloggs')
db.put('spouse', 'Josephine Bloggs')
db.put('dog', 'Kilroy')
db.put('occupation', 'Dev')
db.close()</pre></div><p>Unlike the Python code, reading back is idiomatically Ruby code where you can just treat the database as a dictionary and apply a block to it:</p><div class="informalexample"><pre class="programlisting">db.each do |k,v|
  puts "Key=#{k}, Value=#{v}"
end</pre></div><p>A much more useful and complete wrapper is <a class="ulink" href="https://github.com/DAddYE/leveldb">https://github.com/DAddYE/leveldb</a> which includes nicer iterators and batches but has a more complex install and needs Ruby 2.0. It adds batch support:</p><div class="informalexample"><pre class="programlisting">db.batch do |b|
  b.put 'spouse', 'Josephine Bloggs'
  b.put 'dog', 'Kilroy'
  b.delete 'name'
end</pre></div><p>This sample as a Ruby style of <a id="id355" class="indexterm"/>code blocks uses the idiom that the block contains all the logic to apply to the batch <a id="id356" class="indexterm"/>so implies a write at the end of the block.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec58"/>Summary</h1></div></div></div><p>We saw a little of the different styles of coding in the three dominant scripting languages. Take the opportunity to explore those links further and consider using a scripting language as a REPL to explore ideas with LevelDB. You might want to use one to quickly generate massive databases or play with different key structures.</p></div></body></html>