- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Word Game (Part 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will start creating a “complete the word” game, which we
    will then finish in the next chapter. The word game will require the user to find
    words using the letters within a given word. To add a little twist to the game,
    we’ll offer it in three different languages – English, Spanish, and Italian.
  prefs: []
  type: TYPE_NORMAL
- en: Some new things that you will learn are how to add and customize a `PickerView`,
    implement user feedback in a few different ways (including with pop-up alerts,
    haptics, and sound), and add various animations to the user interface, including
    spring animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and creating a data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building out the UI by adding a text field and list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a character count next to each word in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the entered words for duplicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a random word with a button press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the user’s entered word is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the user’s entered word is a real word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the user’s entered work is valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `HeaderView` with an `info` button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `PickerView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 12` `and
    13` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and creating a data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, create a new Xcode project and call it `Find Words`. Then, in the GitHub
    repository, go to the `Chapter 12`and `Chapter 13` folders; this folder will include
    three subfolders called `Language Data`, `Images`, and `Sound`. Add the `Images`
    folder to the Assets catalog, and the other folders to the Project navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a data model file to hold the data for the [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)
    app – to do this, press *Command + N*, choose the `DataModel`. In this file, import
    SwiftUI by adding the following code at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have done before, we add a class to hold all of the properties and methods.
    We’ll call the class `DataModel`, and it needs to conform to the `ObservableObject`
    protocol in order for us to access this data later on. Then, we’ll add the properties
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have an array called `allWordsInFile`, which will hold all of the
    words needed to play the game. We will use three separate files, one for English,
    one for Spanish, and one for Italian. This array will be loaded with whichever
    language is selected to play the game with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is a `baseWord` property, which will contain the word the user is working
    with and trying to find new words from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have another property called `userEnteredWord` that will hold the user’s
    word when they type it into the text field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is another array called `userEnteredWordsArray`, which will hold all of
    the user’s guessed words so that we can keep track of what they have completed
    so far.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is a property called `letterCount`, which will be used to keep track of
    the number of letters per word being used so that we can tally an average number
    of letters per word. For example, if the user is only choosing three-letter words,
    we will display that word letter average on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the Boolean that will open `SettingsView`, allowing the user to change
    the game’s language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next are three error properties we will use to show an alert when the user misspells
    words or enters duplicate words, which are words that are already in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next are what are called `AppStorage` properties. These are used to save the
    user’s language settings in memory, so when they close the app and then come back
    later, their settings are preserved. When we prefix a property with the `AppStorage`
    wrapper, a place in memory on the phone will preserve the user settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, a property to display a splash screen. A splash screen is an opening scene
    that the user will see briefly as the app loads in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s continue and add all the methods we need for the project now into `DataModel`,
    right under the properties we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this code down too:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a method to grab a random word from the language files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a function to set the word length – either 7, 8, or 9 letters – and
    language – either English, Spanish, or Italian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a function to add the user’s word to a list so that they can see all
    the words that they have found so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then a function to check whether their word is a duplicate; we don’t want duplicates
    in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, a function to check to see whether the word is possible given the word
    they’re working with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have a function to check to see whether the word is a real word in the
    language of choice (we don’t want made-up words!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then finally, a function to display an error message to the user if they
    type in a word that doesn’t exist or cannot be made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you see from the code, I have filled out only one function for now, and the
    rest of the functions are just known as `return` statement. This is helpful because
    we can still continue writing code in the interface, call these functions stubs,
    and the code will still build cleanly, even though it won’t do anything yet.
  prefs: []
  type: TYPE_NORMAL
- en: We will fill out the body of the other functions soon enough, but let’s look
    at the one function I did add code into – `getRandomWord()`. This function starts
    by trying to access the app bundle, which is where we placed our language files.
    When we add files to the project, they are put into the app bundle. The app bundle
    is a folder where all the app files are stored and used to make the app work.
    We need to access the bundle and find the path to those language files so we can
    load the words they contain and use them in the game.
  prefs: []
  type: TYPE_NORMAL
- en: To access them, Swift gives us a method called `url(forResource)` for locating
    the path of a file – we simply type the name of the file into the first parameter
    and the extension into the second parameter. For now, we’re just going to load
    up the seven-letter word file in the English language (but later on, we’ll be
    accessing words of other sizes and other languages’ files).
  prefs: []
  type: TYPE_NORMAL
- en: For the extension, I put in `txt` for a text file. If we find that file, then
    we proceed to the next step where we attempt to convert that file into a string
    so that we can manipulate it. If the code is able to complete that task, then
    it will separate the words in the file using the `components(separatedBy)` method
    and pass in the new line character, so each word will be on its own line. This
    is helpful so we can access these words later, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to get a random word from the file and store it in the `baseWord`
    property. Notice that we need to use the ternary operator here. That’s because
    the `randomElement` function is an optional function. For this reason, it might
    not have a word to get, so, we offer an alternative word to keep the code from
    crashing in case there are no words in the file (this would only happen if the
    file became corrupt, which is rare).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we do come across a problem along the way, we’ll use the `assert`
    function. `assert` takes two arguments: a condition to check, and a message to
    display if the condition is `false`. If the condition is `false`, the message
    will be displayed and the app will halt in a debugging environment. In a production
    environment, the `assert` statement will be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `getRandomWord()` function later to get a random word that the
    user can play with and try to find new words from.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that’s all the properties and functions in place, with one function complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s go into the `App.Swift` file and create an instance of the `DataModel`
    class, and then inject that instance into `ContentView` so that the data model
    is available from anywhere in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be familiar to you – we have created the `DataModel` instance and
    passed it into the root view, `ContentView`. We will also get an error because
    we now need to update `ContentView`, and the `Previews`. Let’s add the following
    modifications in `ContentView` and finish off implementing the `Observable` object
    protocol by adding a `DataModel` instance so that we can pass the data into the
    views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s add a property to display a random word at the top of `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `wordToPlayFrom` property will be set to a random word, which will be the
    user’s word to start playing with and finding new words to make with. It’s being
    set to a string that will prompt the user to start the game.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, our data model is now set up here in `ContentView`; let’s focus on building
    out the user interface next.
  prefs: []
  type: TYPE_NORMAL
- en: Building out the UI by adding a text field and list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build out our UI, first, we’ll add a text field view so the user can enter
    their answers, and then we’ll add a list view, so all of the user’s words can
    be listed in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, go into the `body` property of `ContentView` and remove the existing
    boilerplate code for the `Text` and `Image` views, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added a text field so we can grab the user’s input, while changing
    `.textInputAutocapitalization` to `never` so that auto-capitalize won’t capitalize
    what the user types into the text field. The word files we imported into the project
    are all written in lowercase, so turning auto-capitalization off helps with accessing
    those words and checking the letters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the text field gets a little styling and a little padding, before we call
    the `onSubmit` modifier and pass the `addWordToList` property into it. What this
    modifier does is add an action to be performed when the user types in a word and
    hits *Enter*. That action being performed is a call to the `addWordToList` method
    that we have in our data model. That method will process the user’s input and
    see whether their word is allowed to be used based on certain criteria, such as
    whether the word is even possible in the chosen language and whether they make
    it from the letters present in the base word.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in order to access our data model, we have to use our `DataModel`
    instance’s `appData` that we created at the top of this file; this gives us access
    to all the methods and properties we created in `DataModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the code, we then move on to the `List` view, which creates
    a list to display the user’s words. This uses the `id` parameter to uniquely identify
    each word in the `guessedWords` array. When we iterate (loop) through `userEnteredWordsArray`,
    we need a way of identifying its content – each element in that array has to be
    unique to be able to use it and fortunately, every word is indeed unique (no two
    words are the same). So, what the `id` parameter you see here is saying is that
    it will use the word’s own name as its identifier (the `self` part), and we can
    access the elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we did a bit more styling. We set the text color of the words to
    `black` and their size to `18` points. Then, we set the frame size of the `List`
    view, as well as changing the color to `blue` and providing a `cornerRadius` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run the app, we can type words into the text field, but when we
    press *Enter*, the word isn’t being placed into the `List` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Words typed into the text field ](img/B18674_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Words typed into the text field'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason the words are not going into the list is that we just haven’t filled
    out the empty `addWordToList` function in the `DataModel` class yet. Let’s fill
    out that method now with some code that will allow the user’s typed-in word to
    be displayed inside the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `userWord` constant, which is going to store the new word
    that the user adds to the list. We first check the user’s word for white spaces.
    This way, if the user types some extra spaces in the text field by mistake, the
    `trimmingCharacters` function will eliminate them. Next, the word is made lowercase
    using the `lowercased` function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `guard` statement, which is very similar to the `if` statement,
    which checks to see whether the word that the user entered has more than one letter.
    If it does, it will proceed to the next line of code. Otherwise, the method will
    return right there and not run any more code. When the code “returns” from a method,
    that means the code is finished running that method, and even if there’s more
    code inside that method, it won’t run. The reason why we’re checking to see whether
    there need to be at least two letters in the user’s word is because those are
    too easy. Even though there aren’t many one-letter words in any given language,
    why not simply remove them altogether?
  prefs: []
  type: TYPE_NORMAL
- en: After the user’s word has been trimmed and made lowercase, it’s then added to
    `userEnteredWordsArray`, and inserted at index zero using the `insert(at)` method.
    This index is at the beginning of the array, and the reason why we insert the
    word at the beginning and don’t append it to the end of the array is that we want
    each new word to appear at the top of the list so that it’s readily visible.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the `newWord` property back to an empty string, which effectively
    clears out the `Text` view when the user presses *Enter*, so they can type in
    another word when ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run the project, we can see that when we type words into the text
    field and press *Enter*, they now appear in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Words are now entered into the list ](img/B18674_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Words are now entered into the list'
  prefs: []
  type: TYPE_NORMAL
- en: New words will appear at the top of the list. The `List` view, by default, is
    also scrollable, so the user can easily scroll up and down to see previously entered
    words.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue with the UI and display the number of characters each word contains.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a character count next to each word in the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I also want to add a number next to each word that indicates how many letters
    are in the word that the user has entered. Later, we will take this number from
    each word and add them together to get an average of how the user is doing in
    terms of the length of words they are entering.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put this number inside a circle, and luckily this is very easy, as Swift
    gives us system images of circles with numbers in them that are already created;
    all we have to do is call them up. So, back in `ContentView`, then inside the
    `List` view, let’s put the `Text` view inside of an `HStack` (so they are side
    by side), and add an `Image` view for the number circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Image` view gets a system image of a circle. The `word.count` code statement
    gets the number of letters in the user’s word and displays that number inside
    of a circle. Now if we run the code, all the words that are typed in will have
    their letter counts displayed in a circle to the left of the given words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The letter count displayed in a circle ](img/B18674_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The letter count displayed in a circle'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to now checking the user’s words for duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the entered words for duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’re displaying the words that the user enters, how about we check
    them to make sure they are real words in a dictionary and that there are no duplicate
    words in the list? We have all the function stubs in place for these checks, so
    let’s start filling them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function we’ll fill out is `isWordDuplicate`, which we’ll modify
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What this does is to check `userEnteredWordsArray` to see whether it contains
    the word the user has typed into the `Text` field. Here’s how it works. The `return`
    statement in this function uses the `filter` method on the `userEnteredWordsArray`
    array. The `filter` method takes a closure as its argument, which is evaluated
    for each element of the array. In this case, the closure checks whether the current
    element of the array (`$0`) is equal to the word passed as an argument to the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this `filter` operation is a new array that contains all the elements
    of `userEnteredWordsArray` that match the given condition. If this new array is
    not empty, that means that the word already exists in the `userEnteredWordsArray`,
    so the function returns `false`. If the new array is empty, that means that the
    word is not duplicated, so the function returns `true`. The `isEmpty` property
    of the array is used to check whether the array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just filling out the function is not enough to have it check for duplicates;
    we have to call this function inside of the `addWordToList` function so that we
    can use it to check the new words before they are added to the list. Let’s do
    that now – inside the `addWordToList` function, add the following, right after
    the `userWord` instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code checks the `isWordDuplicate` function to see whether it’s returning
    `true` by using the `!` operator in front of it. Remember, the `isWordDuplicate`
    function returns a Boolean value, either `true` or `false`, so if this function
    returns `false`, then the `if` statement runs the code in its body, which is another
    function called `displayErrorMessage`. This will display an error message to the
    user telling them that their word is a duplicate (we haven’t set up our error
    messaging system yet, but we will soon!).
  prefs: []
  type: TYPE_NORMAL
- en: Now I’d like you to come back into `ContentView` and run the app, enter a word,
    and see it appear in the list. Then, try entering that same word again, and you’ll
    notice you’re not able to. The `guard` statement stops it from happening because
    it checks and sees that the word has already been entered into the list.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to add a button that will grab a random word from the word files
    we imported into the project, which gives the user a word to play with and try
    to find words from.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a random word with a button press
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue with the methods and fill them out, we need a button to provide
    a random word that the user can play off and try to find words from. After all,
    it’s not a challenge to just type random words and for them to appear in the list
    currently.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by supplying a file of thousands of seven-letter words, from which
    one will be shown on the screen randomly when a button is pressed. We will also
    give the user the choice to choose a seven-, eight-, or nine-letter word, and
    the option to select another language later, but right now, let’s just stick with
    seven-letter English words.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t done so already, go to the GitHub folder, select the `Language`
    files folder, and drop the contents of that folder into the Project navigator.
    Once done, select them all, right-click, and choose `Languages` – this helps keep
    everything organized in the Project navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now those files are added to the project and we have already built out the
    `getRandomWord` function, which will get us a random word from a specified file,
    so now we need to call this function so that we can show the word to the user
    – we can do that with a button. Add the following code directly in `VStack`, above
    the `Text` field code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a button. Inside the `action` parameter for the button, we
    use our `appData` instance and call the `getRandomWord` function. We also set
    the `wordToPlayFrom` property to the `baseWord` value because `baseWord` contains
    the random word that will appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now every time the button is pressed, a randomized word from our text file is
    placed into `baseWord`, which then gets placed into the `wordToPlayFrom` property
    to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the button code, we create a `Text` view that displays `wordToPlayFrom`
    on the screen. The button is then styled with a wood background image, a slight
    corner radius, a little bit of shadow, and the words **New Word**.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding that code, the button should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: A button to create a random word ](img/B18674_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: A button to create a random word'
  prefs: []
  type: TYPE_NORMAL
- en: Now, press the button, and you will get a random word that a user can work with.
    Also, notice that when you press the button, it actually looks like it’s being
    pressed down; we get this behavior by default, which really adds to the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The game is coming along, but we want to continue checking the word the user
    enters to see whether it can be made from the randomized word. Let’s do that up
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if the user’s entered word is possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking for duplicate words is not enough. Now that we have generated a random
    seven-letter word, we want to make sure that the user’s entered word can be made
    from the letters that are in the random word. For example, if the random word
    is `books`, that would be invalid because `s` is not in the random word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the `DataModel` class and add code to the `isWordFoundInBaseWord`
    function so that we can check that the word can be made from `baseWord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how this function works. The `isWordFoundInBaseWord` function takes a
    `String` parameter, `userGuessWord`, and returns a `Bool` value indicating whether
    or not `userGuessWord` can be made by removing letters from the `baseWord` string.
  prefs: []
  type: TYPE_NORMAL
- en: The function starts by creating a `comparisonWord` variable equal to `baseWord`.
    The `comparisonWord` variable is used to keep track of the remaining letters in
    `baseWord` that haven’t been matched by `userGuessWord`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the function uses the `allSatisfy` method of `String` to check that all
    the letters in `userGuessWord` can be found in `comparisonWord`. The `allSatisfy`
    method iterates over each character in the string and returns `true` if the closure
    passed to it returns `true` for all characters.
  prefs: []
  type: TYPE_NORMAL
- en: The closure takes a single parameter letter, representing the current letter
    in `userGuessWord` being processed. It first uses the `firstIndex(of:)` method
    to find the index of a letter in `comparisonWord`. If a letter is not found in
    `comparisonWord`, the closure immediately returns `false`, which will make the
    overall `allSatisfy` call return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If a letter is found in `comparisonWord`, the closure removes that letter from
    `comparisonWord` using the `remove(at:)` method. Finally, the closure returns
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `allSatisfy` call returns true, the function returns `true`, indicating
    that `userGuessWord` can be made by removing letters from `baseWord`. If `allSatisfy`
    returns `false`, the function returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The logic for this can be a little tricky to understand at first, but it basically
    looks at each letter in the user’s word and compares it to `baseWord`. Any letter
    that’s not in `baseWord` will cause the method to return `false`, meaning the
    user’s word is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this method written out, let’s put it to work. We need to
    call this method in the `addWordToList` function, so place this code after the
    `if` statement’s closing brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What we’re doing here is calling the `isWordFoundInBaseWord` function, and it
    will have `userGuessedWord` passed into it. The function checks whether the word
    is possible to create – if not, we’re going to display an alert message to the
    user using the `displayErrorMessage` method (again, the alert messages will be
    created later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this out. Come back into `ContentView` and run the program. You will
    see that you cannot enter a word unless those letters are also present in `baseWord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Checking whether the word is possible using the base word’s
    letters ](img/B18674_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Checking whether the word is possible using the base word’s letters'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I entered `set` into the list because that can be made from `sent` because
    there is no `n` in `isWordFoundInBaseWord` function is working perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the user’s entered word is a real word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one final check we need to do, and that is to see whether the word
    is an actual word in the dictionary. This check is important because the user
    could rearrange letters in `baseWord`, make up their own word, and enter it into
    the list. We want to prevent that and check each of the words against an actual
    dictionary. To do that, we can use the `UITextChecker` class. This class has methods
    and properties we can use to check whether a word is an actual word in the dictionary,
    and what’s especially nice is it will work with misspellings and authenticity
    in Spanish and Italian as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s go into the `DataModel` class and add the following code to the `isWordInDictionary`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re going to get an error here because I am adding this `isNotFound` property.
    So, let’s fix that error first, and then we can go over what the code is doing.
    Outside the class’s closing brace, add the following extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back now, the `isWordInDictionary` function checks whether a given word
    exists in the English dictionary. It does so by creating an instance of `UITextChecker`
    and calling the `rangeOfMisspelledWord` method on it. This method takes several
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`word`: The word to check for spelling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`: The range of the word to check, specified as `NSRange`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startingAt`: The starting position of the word to check within the specified
    range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wrap`: A Boolean value indicating whether to wrap around the end of the range
    to the beginning when checking for misspelled words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`language`: The language to use for spell checking – in this case, `"en"` for
    English'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method then returns an `NSRange` that indicates the range of the first misspelled
    word found. If no misspelled word is found, the `location` property of the returned
    range is set to `NSNotFound`.
  prefs: []
  type: TYPE_NORMAL
- en: The `isNotFound` computed property is an extension on `NSRange` that returns
    `true` if the `location` property is equal to `NSNotFound`, and `false` otherwise.
    This makes it more readable and allows us to write `isNotFound` instead of comparing
    the location of `NSNotFound` in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Summing it up, the function creates an instance of the `UITextChecker` class.
    `UITextChecker` looks through its dictionary for any misspelling to make sure
    the word is real – if it is in the dictionary, `true` is returned and the word
    will be entered into the user’s list; otherwise, `false` will be returned, and
    we show a message to the user saying that this is not an actual word in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the function is complete, let’s use it. Add the following code directly
    after the closing brace of the previous `guard` statement in the `addWordToList`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With that code in place, give the app another go and make up your own word
    using the given letters in `baseWord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Checking whether the word is in the dictionary ](img/B18674_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Checking whether the word is in the dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I made up a word using the letters from `baseWord` – `tesh` – however,
    I wasn’t allowed to add the word to the list because there is no such word in
    the English language, so we know the function is working.
  prefs: []
  type: TYPE_NORMAL
- en: And that really completes all of the word-checking functionality for the app;
    we will add pop-up alerts for when a user’s word doesn’t pass any of those checks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on building out the UI some more. We’re going to add a text string
    at the top that will be the name of the app, and we can style this in a separate
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HeaderView with an info button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s continue building out the UI and add a header title, which will be the
    name of our app. We can create this header in a separate file so we can keep our
    `ContentView` clutter free.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of `HeaderView` is twofold – to set the title of the app, and to
    add an `info` button that opens a user settings page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *Command + N*, choose a `HeaderView`. Then, add a `Binding` property
    in the `HeaderView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code inside the `body` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we added a `ZStack` to hold two views, an image displaying the title
    of the app, and a button that we will set up to take the user to a settings page,
    where they can choose another language to play the game in. Also added was the
    `shadow` modifier on the image to help make it stand out a little more.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the button closure, we use the system image of an info circle, then some
    top padding on it to align the button vertically with the image, and then we colored
    the button black using the `accent` modifier. After that, we offset the button
    to the right `150` points so that it’s next to the image on the right side of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When the `info` button is pressed, a settings page will open, giving the user
    three language options for the game. The `showSettings` property will be used
    to open up `SettingsView`, but we don’t have `SettingsView` yet, so let’s make
    one. Press *Command + N*, choose `SettingsView`. And just like that, we now have
    our `SettingsView`. Let’s come back into the `SettingsView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the button, we need to toggle the `showSettings` state variable, so
    add the following line of code to the button body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in order to open up a sheet over another view, we need to call
    the `sheet` modifier on the button, so add the code to the end of the button’s
    closing brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `sheet` modifier is used in SwiftUI to open a sheet, which is simply another
    view that opens by sliding up from the bottom of the screen. The sheet is triggered
    by the `isPresented` parameter – when the value of `isPresented` becomes `true`,
    the code in the `sheet` modifier’s body will run. In the `sheet` modifier’s closure,
    there is a call to `SettingsView`; this is the view (sheet) that gets presented
    over `ContentView`. To dismiss the sheet, the user slides it back down with their
    finger.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, we need to add two more lines of code inside `ContentView`.
    First, go into that file, and add a `State` property that can connect to the `Bindin`g
    variable of `HeaderView`. Add this `State` variable right after the previous property
    at the top in `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I’m calling it `showSettings`, the same as the variable it’s binding to from
    `HeaderView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to add a call to `HeaderView` to get the `info` button working.
    Add this line of code inside `VStack` at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s all we need to get `SettingsView` working. Try it out – press the
    information button in `ContentView` and `SettingsView` opens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: SettingsView ](img/B18674_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: SettingsView'
  prefs: []
  type: TYPE_NORMAL
- en: To dismiss the view, simply slide down on the opened view. This “sliding to
    close” behavior is automatically baked into the `sheet` modifier, so we don’t
    have to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have `SettingView` working, although it doesn’t do much right now other
    than open up and show `PickerView` that the user can press on to set the size
    of the words they want to play with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating PickerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `PickerView` is a view that displays various options to the user. The picker
    can either be a single button with a drop-down list, a segmented list with multiple
    buttons, or a wheel that the user can spin to select an option.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main differences between these three pickers in terms of style.
    The first is how they appear in your app. The second is the number of options
    available to the user – the wheel can hold many, many options for the user, whereas
    a button picker or a segmented control picker is limited by the amount of space
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be offering just three options to the user, a seven-, eight-,
    or nine-letter word option, we’ll go with the segmented control.
  prefs: []
  type: TYPE_NORMAL
- en: Adding PickerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by adding a new `PickerView`. Next, let’s add an instance of the
    `DataModel` class at the top of the struct so we have access to the data properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a `VStack`, and inside that, add a `topBar` image that we have in
    the Assets catalog, which will help to frame the picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we add the `topBar` image and put a little padding and shadow around
    it to help it stand out against the background (which will be added soon). Then,
    we use `10` points of center spacing on the `VStack` to keep some space between
    the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `Picker` control underneath the last line of code we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code adds the picker and uses the `selectedSegment` property in `DataModel`,
    which is used to keep track of which segment of the picker has been selected by
    the user. The picker is set to three different titles, and we use the `tag` modifier
    to distinguish which title goes where on the picker control. Now, the user can
    choose between `7`, `8`, or `9` letters for the word they will work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the default button look, which offers options to the user when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: The button picker ](img/B18674_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: The button picker'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at how we can style the picker to something more suitable for
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: Styling PickerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned, I feel that segmented control looks better, so let’s change
    the styling to that picker option instead. Add the following code after the closing
    brace of `PickerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the picker to the segmented style, and added a rounded rectangle with
    a corner radius of `8` points, with a black stroke around the picker control to
    give it a nice border. Then, we finished it off with some shadow and padding,
    and this is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: The completed PickerView ](img/B18674_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: The completed PickerView'
  prefs: []
  type: TYPE_NORMAL
- en: '`PickerView` is done, but to complete the work in the `PickerView` file, let’s
    add a `bottomBar` image to the scene. After the `shadow` modifier, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This just sets `bottomBar` like `topBar`, and helps frame out `PickerView`
    in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: The bottom bar image added ](img/B18674_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: The bottom bar image added'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back into `ContentView`, where we need to call `PickerView` to bring
    it into the scene. Add the following just below the `HeaderView` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we have our `PickerView` that can offer the user some choices. It doesn’t
    do anything yet because we need to fill out the `setWordLengthAndLanguage` method,
    so let’s do that. Back in `DataModel`, add the following code inside the `setWordLengthAndLanguage`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the `setWordLengthAndLanguage` function works. It starts by defining
    two dictionaries, `language` and `wordLength`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `language` dictionary maps the names of different languages to their abbreviations.
    In this case, `"English"` is mapped to `"En"`, `"Spanish"` is mapped to `"ES"`,
    and `"Italian"` is mapped to `"It"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `wordLength` dictionary maps integer values to their corresponding word
    lengths. For example, `1` is mapped to `"7"`, `2` is mapped to `"8"`, and `3`
    is mapped to `"9"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the function checks the value of the `selectedSegment` variable. This
    variable holds an integer that represents the user’s selected word length (seven
    letters, eight letters, or nine letters).
  prefs: []
  type: TYPE_NORMAL
- en: Based on the value of `selectedSegment`, the function retrieves the corresponding
    word length from the `wordLength` dictionary using the square bracket notation,
    `wordLength[selectedSegment]`. This gives us the word length as a string, such
    as `7`, `8`, or `9`.
  prefs: []
  type: TYPE_NORMAL
- en: The function then checks the values of the `englishIsOn`, `spanishIsOn`, and
    `italianIsOn` variables. These variables hold Booleans that indicate whether the
    user has selected the corresponding language.
  prefs: []
  type: TYPE_NORMAL
- en: If one of these language variables is true, then the function uses the corresponding
    language abbreviation (retrieved from the `language` dictionary) and the word
    length (retrieved from the `wordLength` dictionary) to construct the filename
    of the data file that contains the words for that language and word length. For
    example, if the user has selected English with seven letters, the filename will
    be `7LetterWordsEn`.
  prefs: []
  type: TYPE_NORMAL
- en: The function sets the value of the `letterCount` variable to a string that provides
    a description of the selected language and word length, such as `7 letter word
    -` `American English`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function returns the constructed filename as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other bit of code we need to add to `ContentView` in order to get
    the language word count string working for the picker control. Add the following
    code directly after the `shadow` modifier of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we added a `VStack` and then displayed the `letterCount` property
    in a `Text` view by using the `appData` instance. Then, we applied a font size
    and weight and a white foreground, made it bold, and added a shadow to the `Text`
    view. What I want you to do now is to cut out the `Text` view that displays the
    `wordToPlayFrom` property, and paste it inside the `VStack` just added, at the
    very end. This keeps both text views horizontally organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to test the picker out and see it display the letter word string, as well
    as a word in a different language, we need to come to our data file and set one
    of the `language` variables to `true`; just for testing purposes, we will later
    toggle these variables in the settings page. So, in `DataModel`, change the `spanishIsOn`
    variable to `true`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, come into `ContentView` and select the length of the word that you want
    to use from the picker control. Press the button and you will see a Spanish word
    of the length you chose and the `letterCount` string displaying the chosen language’s
    flag and picker selection for the word size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: Choosing the word size and language for the game ](img/B18674_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Choosing the word size and language for the game'
  prefs: []
  type: TYPE_NORMAL
- en: You can check it for the other two languages as well by just setting one of
    those languages to `true` and keeping the others set to `false`. Also, if you
    don’t set one of the `AppStorage` variables to `true`, then the picker will not
    pick the length of the word; it will default to an eight-letter word (this behavior
    will work itself out when we finish adding the rest of the code in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: After you’re done testing things out, make sure to set the `data` variable back
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we’ve come to the end of this chapter, and have done quite a bit of work.
  prefs: []
  type: TYPE_NORMAL
- en: We started building out our game, allowing the user to enter words to play the
    game, and adding checks to validate their choices. We also added a button that
    the user can press to bring up a random word from a file of thousands of words,
    a button that brings up a settings page, a picker control, and a letter count
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will continue building out the app, specifically building out the user
    interface, the settings page so it contains those three buttons that the user
    can select for the languages, and adding error messages when the user’s entered
    word is not valid. So, let’s continue with the second part of this project in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
