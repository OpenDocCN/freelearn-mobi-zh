- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Creating a Word Game (Part 1)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个文字游戏（第一部分）
- en: In this project, we will start creating a “complete the word” game, which we
    will then finish in the next chapter. The word game will require the user to find
    words using the letters within a given word. To add a little twist to the game,
    we’ll offer it in three different languages – English, Spanish, and Italian.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将开始创建一个“完成单词”游戏，我们将在下一章中完成它。这个单词游戏将要求用户使用给定单词中的字母来查找单词。为了给游戏增加一点变化，我们将提供三种不同的语言
    – 英语、西班牙语和意大利语。
- en: Some new things that you will learn are how to add and customize a `PickerView`,
    implement user feedback in a few different ways (including with pop-up alerts,
    haptics, and sound), and add various animations to the user interface, including
    spring animations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习到的一些新内容包括如何添加和自定义`PickerView`，以几种不同的方式实现用户反馈（包括弹出警报、触觉和声音），以及向用户界面添加各种动画，包括弹簧动画。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Setting up the project and creating a data model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目和创建数据模型
- en: Building out the UI by adding a text field and list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加文本字段和列表来构建UI
- en: Displaying a character count next to each word in the list
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中的每个单词旁边显示字符计数
- en: Checking the entered words for duplicates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查输入的单词是否有重复
- en: Adding a random word with a button press
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按钮点击添加随机单词
- en: Checking whether the user’s entered word is possible
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户输入的单词是否可行
- en: Checking whether the user’s entered word is a real word
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户输入的单词是否为真实单词
- en: Checking whether the user’s entered work is valid
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户输入的单词是否有效
- en: Creating `HeaderView` with an `info` button
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有“info”按钮的`HeaderView`
- en: Creating `PickerView`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`PickerView`
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the resources and finished project from the `Chapter 12` `and
    13` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub上的`Chapter 12`和`Chapter 13`文件夹下载资源和完善的项目：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Setting up the project and creating a data model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目和创建数据模型
- en: First, create a new Xcode project and call it `Find Words`. Then, in the GitHub
    repository, go to the `Chapter 12`and `Chapter 13` folders; this folder will include
    three subfolders called `Language Data`, `Images`, and `Sound`. Add the `Images`
    folder to the Assets catalog, and the other folders to the Project navigator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Xcode项目，并将其命名为`Find Words`。然后，在GitHub仓库中，转到`Chapter 12`和`Chapter 13`文件夹；这个文件夹将包括三个子文件夹，分别称为`Language
    Data`、`Images`和`Sound`。将`Images`文件夹添加到资产库中，将其他文件夹添加到项目导航器中。
- en: 'Next, we will create a data model file to hold the data for the [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)
    app – to do this, press *Command + N*, choose the `DataModel`. In this file, import
    SwiftUI by adding the following code at the top of the file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个数据模型文件来保存[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)应用程序的数据
    – 要这样做，请按*Command + N*，选择`DataModel`。在这个文件中，通过在文件顶部添加以下代码来导入SwiftUI：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we have done before, we add a class to hold all of the properties and methods.
    We’ll call the class `DataModel`, and it needs to conform to the `ObservableObject`
    protocol in order for us to access this data later on. Then, we’ll add the properties
    we need:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们添加一个类来保存所有属性和方法。我们将把这个类命名为`DataModel`，并且它需要遵守`ObservableObject`协议，以便我们稍后可以访问这些数据。然后，我们将添加所需的属性：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s break down the code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码：
- en: First, we have an array called `allWordsInFile`, which will hold all of the
    words needed to play the game. We will use three separate files, one for English,
    one for Spanish, and one for Italian. This array will be loaded with whichever
    language is selected to play the game with.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有一个名为`allWordsInFile`的数组，它将保存游戏所需的所有单词。我们将使用三个单独的文件，一个用于英语，一个用于西班牙语，一个用于意大利语。这个数组将根据所选的语言加载以进行游戏。
- en: Next is a `baseWord` property, which will contain the word the user is working
    with and trying to find new words from.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个`baseWord`属性，它将包含用户正在处理并尝试从中找到新单词的单词。
- en: Then, we have another property called `userEnteredWord` that will hold the user’s
    word when they type it into the text field.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们还有一个名为`userEnteredWord`的属性，它将在用户将单词输入到文本字段时保存用户的单词。
- en: Next is another array called `userEnteredWordsArray`, which will hold all of
    the user’s guessed words so that we can keep track of what they have completed
    so far.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是另一个名为`userEnteredWordsArray`的数组，它将保存所有用户的猜测单词，这样我们就可以跟踪他们已经完成了哪些内容。
- en: Next is a property called `letterCount`, which will be used to keep track of
    the number of letters per word being used so that we can tally an average number
    of letters per word. For example, if the user is only choosing three-letter words,
    we will display that word letter average on the screen.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个名为`letterCount`的属性，它将用于跟踪每个单词使用的字母数量，这样我们就可以计算每个单词的平均字母数。例如，如果用户只选择三个字母的单词，我们将在屏幕上显示该单词的平均字母数。
- en: Next is the Boolean that will open `SettingsView`, allowing the user to change
    the game’s language.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个布尔值，它将打开`SettingsView`，允许用户更改游戏的语言。
- en: Next are three error properties we will use to show an alert when the user misspells
    words or enters duplicate words, which are words that are already in the list.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是三个错误属性，我们将使用它们在用户拼写单词错误或输入重复单词时显示警告，这些单词已经在列表中。
- en: Next are what are called `AppStorage` properties. These are used to save the
    user’s language settings in memory, so when they close the app and then come back
    later, their settings are preserved. When we prefix a property with the `AppStorage`
    wrapper, a place in memory on the phone will preserve the user settings.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是所谓的`AppStorage`属性。这些用于在内存中保存用户的语言设置，这样当他们在稍后关闭应用并返回时，他们的设置会被保留。当我们给属性加上`AppStorage`包装器时，手机上的一个内存位置会保留用户设置。
- en: Next, a property to display a splash screen. A splash screen is an opening scene
    that the user will see briefly as the app loads in the background.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个用于显示启动屏幕的属性。启动屏幕是用户在应用在后台加载时将短暂看到的开场场景。
- en: 'Let’s continue and add all the methods we need for the project now into `DataModel`,
    right under the properties we just added:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，现在将我们需要的所有方法添加到`DataModel`中，就在我们刚刚添加的属性下面：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break this code down too:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将这段代码分解一下：
- en: We have a method to grab a random word from the language files
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个方法可以从语言文件中获取一个随机单词
- en: We have a function to set the word length – either 7, 8, or 9 letters – and
    language – either English, Spanish, or Italian
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个设置单词长度的函数——可以是7、8或9个字母——以及语言选择——可以是英语、西班牙语或意大利语
- en: There’s a function to add the user’s word to a list so that they can see all
    the words that they have found so far
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个函数用于将用户的单词添加到列表中，这样他们就可以看到他们迄今为止找到的所有单词
- en: Then a function to check whether their word is a duplicate; we don’t want duplicates
    in the list
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是一个检查他们的单词是否重复的函数；我们不希望在列表中有重复项
- en: Then, a function to check to see whether the word is possible given the word
    they’re working with
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，一个函数用于检查根据他们正在处理的单词，这个单词是否可能
- en: We also have a function to check to see whether the word is a real word in the
    language of choice (we don’t want made-up words!)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个函数用于检查单词是否是所选语言中的真实单词（我们不希望有虚构的单词！）
- en: And then finally, a function to display an error message to the user if they
    type in a word that doesn’t exist or cannot be made
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后最后，一个函数用于向用户显示错误信息，如果他们输入了一个不存在的单词或无法构成的单词
- en: As you see from the code, I have filled out only one function for now, and the
    rest of the functions are just known as `return` statement. This is helpful because
    we can still continue writing code in the interface, call these functions stubs,
    and the code will still build cleanly, even though it won’t do anything yet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中看到的，我现在只填写了一个函数，其余的函数只是作为`return`语句而存在。这很有帮助，因为我们仍然可以在界面中继续编写代码，将这些函数称为占位符，代码仍然可以干净地构建，即使它目前还没有任何功能。
- en: We will fill out the body of the other functions soon enough, but let’s look
    at the one function I did add code into – `getRandomWord()`. This function starts
    by trying to access the app bundle, which is where we placed our language files.
    When we add files to the project, they are put into the app bundle. The app bundle
    is a folder where all the app files are stored and used to make the app work.
    We need to access the bundle and find the path to those language files so we can
    load the words they contain and use them in the game.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会填写其他函数的主体，但现在让我们看看我添加代码的那个函数——`getRandomWord()`。这个函数首先尝试访问应用包，这是我们放置语言文件的地方。当我们向项目中添加文件时，它们会被放入应用包中。应用包是一个文件夹，其中存储并使用所有应用文件，用于使应用工作。我们需要访问包并找到那些语言文件的路径，这样我们就可以加载它们包含的单词并在游戏中使用它们。
- en: To access them, Swift gives us a method called `url(forResource)` for locating
    the path of a file – we simply type the name of the file into the first parameter
    and the extension into the second parameter. For now, we’re just going to load
    up the seven-letter word file in the English language (but later on, we’ll be
    accessing words of other sizes and other languages’ files).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问它们，Swift为我们提供了一个名为`url(forResource:)`的方法来定位文件的路径——我们只需将文件名输入第一个参数，扩展名输入第二个参数。目前，我们只是将要加载的七个字母的英文单词文件（但稍后我们将访问其他大小和不同语言的文件）。
- en: For the extension, I put in `txt` for a text file. If we find that file, then
    we proceed to the next step where we attempt to convert that file into a string
    so that we can manipulate it. If the code is able to complete that task, then
    it will separate the words in the file using the `components(separatedBy)` method
    and pass in the new line character, so each word will be on its own line. This
    is helpful so we can access these words later, one by one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展名，我将其设置为`txt`以表示文本文件。如果我们找到该文件，那么我们将进入下一步，尝试将该文件转换为字符串，以便我们可以对其进行操作。如果代码能够完成这个任务，那么它将使用`components(separatedBy:)`方法将文件中的单词分开，并传入换行符，这样每个单词都会单独在一行上。这有助于我们稍后逐个访问这些单词。
- en: Next, we need to get a random word from the file and store it in the `baseWord`
    property. Notice that we need to use the ternary operator here. That’s because
    the `randomElement` function is an optional function. For this reason, it might
    not have a word to get, so, we offer an alternative word to keep the code from
    crashing in case there are no words in the file (this would only happen if the
    file became corrupt, which is rare).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从文件中获取一个随机单词并将其存储在`baseWord`属性中。注意，我们需要在这里使用三元运算符。这是因为`randomElement`函数是一个可选函数。因此，它可能没有单词可以获取，所以，我们提供了一个备选单词，以防文件中没有单词（这种情况只会发生在文件损坏的情况下，这种情况很少发生）。
- en: 'Finally, if we do come across a problem along the way, we’ll use the `assert`
    function. `assert` takes two arguments: a condition to check, and a message to
    display if the condition is `false`. If the condition is `false`, the message
    will be displayed and the app will halt in a debugging environment. In a production
    environment, the `assert` statement will be ignored.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们在这个过程中遇到问题，我们将使用`assert`函数。`assert`函数接受两个参数：一个要检查的条件，以及如果条件为`false`时显示的消息。如果条件为`false`，则将显示消息，并且应用程序将在调试环境中停止。在生产环境中，`assert`语句将被忽略。
- en: We will use the `getRandomWord()` function later to get a random word that the
    user can play with and try to find new words from.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将会使用`getRandomWord()`函数来获取一个用户可以玩耍并尝试从中找到新单词的随机单词。
- en: Okay, that’s all the properties and functions in place, with one function complete.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所有属性和函数都已就位，其中一个函数已完成。
- en: 'Now let’s go into the `App.Swift` file and create an instance of the `DataModel`
    class, and then inject that instance into `ContentView` so that the data model
    is available from anywhere in the app:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入`App.Swift`文件，创建`DataModel`类的实例，然后将该实例注入到`ContentView`中，以便数据模型可以在应用程序的任何地方使用：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should be familiar to you – we have created the `DataModel` instance and
    passed it into the root view, `ContentView`. We will also get an error because
    we now need to update `ContentView`, and the `Previews`. Let’s add the following
    modifications in `ContentView` and finish off implementing the `Observable` object
    protocol by adding a `DataModel` instance so that we can pass the data into the
    views:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对你来说很熟悉——我们已经创建了`DataModel`实例并将其传递到根视图`ContentView`中。我们还将得到一个错误，因为我们现在需要更新`ContentView`和`Previews`。让我们在`ContentView`中添加以下修改，并通过添加`DataModel`实例来完成实现`Observable`对象协议，这样我们就可以将数据传递到视图中：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let’s add a property to display a random word at the top of `ContentView`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加一个属性来在`ContentView`顶部显示一个随机单词：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `wordToPlayFrom` property will be set to a random word, which will be the
    user’s word to start playing with and finding new words to make with. It’s being
    set to a string that will prompt the user to start the game.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordToPlayFrom`属性将被设置为随机单词，这将作为用户开始玩耍并寻找新单词的单词。它被设置为会提示用户开始游戏的字符串。'
- en: Okay, our data model is now set up here in `ContentView`; let’s focus on building
    out the user interface next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的数据模型现在已经在`ContentView`中设置好了；让我们接下来专注于构建用户界面。
- en: Building out the UI by adding a text field and list
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加文本字段和列表构建UI
- en: To build out our UI, first, we’ll add a text field view so the user can enter
    their answers, and then we’ll add a list view, so all of the user’s words can
    be listed in a table.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的用户界面，首先，我们将添加一个文本字段视图，以便用户可以输入他们的答案，然后我们将添加一个列表视图，以便将所有用户的单词列在表格中。
- en: 'To do that, go into the `body` property of `ContentView` and remove the existing
    boilerplate code for the `Text` and `Image` views, and add the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，进入`ContentView`的`body`属性，移除现有的`Text`和`Image`视图的样板代码，并添加以下代码：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we added a text field so we can grab the user’s input, while changing
    `.textInputAutocapitalization` to `never` so that auto-capitalize won’t capitalize
    what the user types into the text field. The word files we imported into the project
    are all written in lowercase, so turning auto-capitalization off helps with accessing
    those words and checking the letters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个文本字段，以便我们可以获取用户的输入，同时将`.textInputAutocapitalization`设置为`never`，这样自动大写就不会将用户输入到文本字段中的内容自动大写。我们导入到项目中的单词文件都是小写的，因此关闭自动大写有助于访问这些单词并检查字母。
- en: Next, the text field gets a little styling and a little padding, before we call
    the `onSubmit` modifier and pass the `addWordToList` property into it. What this
    modifier does is add an action to be performed when the user types in a word and
    hits *Enter*. That action being performed is a call to the `addWordToList` method
    that we have in our data model. That method will process the user’s input and
    see whether their word is allowed to be used based on certain criteria, such as
    whether the word is even possible in the chosen language and whether they make
    it from the letters present in the base word.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，文本字段获得一点样式和一点填充，然后我们调用`onSubmit`修饰符并将`addWordToList`属性传递给它。这个修饰符的作用是在用户输入一个单词并按下*Enter*键时执行一个动作。执行的动作是调用我们数据模型中的`addWordToList`方法。该方法将处理用户的输入并查看他们的单词是否允许使用，基于某些标准，例如单词是否在所选语言中是可能的，以及他们是否由基本单词中的字母组成。
- en: Notice that in order to access our data model, we have to use our `DataModel`
    instance’s `appData` that we created at the top of this file; this gives us access
    to all the methods and properties we created in `DataModel`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了访问我们的数据模型，我们必须使用我们在文件顶部创建的`DataModel`实例的`appData`；这使我们能够访问我们在`DataModel`中创建的所有方法和属性。
- en: Continuing with the code, we then move on to the `List` view, which creates
    a list to display the user’s words. This uses the `id` parameter to uniquely identify
    each word in the `guessedWords` array. When we iterate (loop) through `userEnteredWordsArray`,
    we need a way of identifying its content – each element in that array has to be
    unique to be able to use it and fortunately, every word is indeed unique (no two
    words are the same). So, what the `id` parameter you see here is saying is that
    it will use the word’s own name as its identifier (the `self` part), and we can
    access the elements in the array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写代码，我们接下来转向`List`视图，它创建一个列表来显示用户的单词。这使用`id`参数来唯一标识`guessedWords`数组中的每个单词。当我们遍历（循环）`userEnteredWordsArray`时，我们需要一种方法来识别其内容——该数组中的每个元素都必须是唯一的，才能使用它，幸运的是，每个单词确实是唯一的（没有两个单词是相同的）。所以，这里看到的`id`参数所说的是，它将使用单词的自身名称作为其标识符（`self`部分），并且我们可以访问数组中的元素。
- en: After that, we did a bit more styling. We set the text color of the words to
    `black` and their size to `18` points. Then, we set the frame size of the `List`
    view, as well as changing the color to `blue` and providing a `cornerRadius` property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们做了一些更多的样式调整。我们将单词的文本颜色设置为`black`，大小设置为`18`点。然后，我们设置了`List`视图的框架大小，以及将其颜色更改为`blue`并提供`cornerRadius`属性。
- en: 'Now, if we run the app, we can type words into the text field, but when we
    press *Enter*, the word isn’t being placed into the `List` view:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用程序，我们可以在文本字段中输入单词，但当我们按下*Enter*键时，单词并没有被放置到`List`视图中：
- en: '![Figure 12.1: Words typed into the text field ](img/B18674_12_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：输入到文本字段中的单词](img/B18674_12_01.jpg)'
- en: 'Figure 12.1: Words typed into the text field'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：输入到文本字段中的单词
- en: 'The reason the words are not going into the list is that we just haven’t filled
    out the empty `addWordToList` function in the `DataModel` class yet. Let’s fill
    out that method now with some code that will allow the user’s typed-in word to
    be displayed inside the list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单词没有进入列表的原因是我们还没有在`DataModel`类中填写空的`addWordToList`函数。现在让我们用一些代码来填写这个方法，这样用户的输入单词就可以在列表中显示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we created a `userWord` constant, which is going to store the new word
    that the user adds to the list. We first check the user’s word for white spaces.
    This way, if the user types some extra spaces in the text field by mistake, the
    `trimmingCharacters` function will eliminate them. Next, the word is made lowercase
    using the `lowercased` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`userWord`常量，它将存储用户添加到列表中的新单词。我们首先检查用户的单词中是否有空格。这样，如果用户在文本字段中不小心输入了一些额外的空格，`trimmingCharacters`函数将消除它们。接下来，使用`lowercased`函数将单词转换为小写。
- en: Then, we use the `guard` statement, which is very similar to the `if` statement,
    which checks to see whether the word that the user entered has more than one letter.
    If it does, it will proceed to the next line of code. Otherwise, the method will
    return right there and not run any more code. When the code “returns” from a method,
    that means the code is finished running that method, and even if there’s more
    code inside that method, it won’t run. The reason why we’re checking to see whether
    there need to be at least two letters in the user’s word is because those are
    too easy. Even though there aren’t many one-letter words in any given language,
    why not simply remove them altogether?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`guard`语句，它与`if`语句非常相似，用于检查用户输入的单词是否有超过一个字母。如果有，它将进入下一行代码。否则，方法将立即返回，不再运行任何更多代码。当代码“从”一个方法“返回”时，这意味着该方法的代码已经运行完毕，即使在该方法内部还有更多代码，也不会运行。我们之所以检查用户的单词是否至少有两个字母，是因为这些单词太简单了。尽管在任何给定语言中，单字母单词并不多，但为什么不把它们全部删除呢？
- en: After the user’s word has been trimmed and made lowercase, it’s then added to
    `userEnteredWordsArray`, and inserted at index zero using the `insert(at)` method.
    This index is at the beginning of the array, and the reason why we insert the
    word at the beginning and don’t append it to the end of the array is that we want
    each new word to appear at the top of the list so that it’s readily visible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户的单词被修剪并转换为小写后，它就被添加到`userEnteredWordsArray`中，并使用`insert(at:)`方法插入到索引零的位置。这个索引位于数组的开始处，我们之所以在数组开头插入单词而不是将其添加到数组的末尾，是因为我们希望每个新单词都出现在列表的顶部，以便它能够立即被看到。
- en: Finally, we set the `newWord` property back to an empty string, which effectively
    clears out the `Text` view when the user presses *Enter*, so they can type in
    another word when ready.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`newWord`属性重置为空字符串，这样当用户按下*Enter*键时，实际上就清除了`Text`视图，因此他们可以在准备好时输入另一个单词。
- en: 'Now, if we run the project, we can see that when we type words into the text
    field and press *Enter*, they now appear in the list:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个项目，我们可以看到当我们将单词输入到文本字段并按下*Enter*键时，它们现在会出现在列表中：
- en: '![Figure 12.2: Words are now entered into the list ](img/B18674_12_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：单词现在被输入到列表中](img/B18674_12_02.jpg)'
- en: 'Figure 12.2: Words are now entered into the list'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：单词现在被输入到列表中
- en: New words will appear at the top of the list. The `List` view, by default, is
    also scrollable, so the user can easily scroll up and down to see previously entered
    words.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 新单词将出现在列表的顶部。默认情况下，`List`视图也是可滚动的，因此用户可以轻松地上下滚动以查看之前输入的单词。
- en: Let’s continue with the UI and display the number of characters each word contains.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行UI设计，并显示每个单词包含的字符数。
- en: Displaying a character count next to each word in the list
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在列表中的每个单词旁边显示字符计数
- en: I also want to add a number next to each word that indicates how many letters
    are in the word that the user has entered. Later, we will take this number from
    each word and add them together to get an average of how the user is doing in
    terms of the length of words they are entering.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想要在每个单词旁边添加一个数字，表示用户输入的单词中有多少个字母。稍后，我们将从每个单词中取出这个数字并将它们相加，以得到用户在输入单词长度方面的平均表现。
- en: 'We can put this number inside a circle, and luckily this is very easy, as Swift
    gives us system images of circles with numbers in them that are already created;
    all we have to do is call them up. So, back in `ContentView`, then inside the
    `List` view, let’s put the `Text` view inside of an `HStack` (so they are side
    by side), and add an `Image` view for the number circle:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个数字放在一个圆圈里，幸运的是，这非常简单，因为Swift为我们提供了带有数字的系统圆形图像，这些图像已经创建好了；我们只需要调用它们。所以，回到`ContentView`，然后在`List`视图中，让我们将`Text`视图放在一个`HStack`（这样它们就是并排的）中，并添加一个用于数字圆圈的`Image`视图：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Image` view gets a system image of a circle. The `word.count` code statement
    gets the number of letters in the user’s word and displays that number inside
    of a circle. Now if we run the code, all the words that are typed in will have
    their letter counts displayed in a circle to the left of the given words:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`视图获取一个圆形的系统图像。`word.count`代码语句获取用户单词中的字母数，并在圆圈中显示这个数字。现在如果我们运行代码，所有输入的单词都将显示它们的字母计数，位于给定单词的左侧圆圈中：'
- en: '![Figure 12.3: The letter count displayed in a circle ](img/B18674_12_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：圆圈中显示的字母计数](img/B18674_12_03.jpg)'
- en: 'Figure 12.3: The letter count displayed in a circle'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：圆圈中显示的字母计数
- en: Let’s move on to now checking the user’s words for duplicates.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查用户的单词是否有重复。
- en: Checking the entered words for duplicates
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查输入的单词是否有重复
- en: Now that we’re displaying the words that the user enters, how about we check
    them to make sure they are real words in a dictionary and that there are no duplicate
    words in the list? We have all the function stubs in place for these checks, so
    let’s start filling them out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在显示用户输入的单词，那么我们检查它们以确保它们是字典中的真实单词，并且列表中没有重复的单词怎么样？我们已经为这些检查设置了所有函数的框架，所以让我们开始填充它们。
- en: 'The first function we’ll fill out is `isWordDuplicate`, which we’ll modify
    to look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先填充的函数是`isWordDuplicate`，我们将对其进行修改，使其看起来像这样：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What this does is to check `userEnteredWordsArray` to see whether it contains
    the word the user has typed into the `Text` field. Here’s how it works. The `return`
    statement in this function uses the `filter` method on the `userEnteredWordsArray`
    array. The `filter` method takes a closure as its argument, which is evaluated
    for each element of the array. In this case, the closure checks whether the current
    element of the array (`$0`) is equal to the word passed as an argument to the
    function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是检查`userEnteredWordsArray`是否包含用户在`Text`字段中输入的单词。这是它的工作原理。这个函数中的`return`语句使用`filter`方法对`userEnteredWordsArray`数组进行操作。`filter`方法接受一个闭包作为其参数，该闭包对数组的每个元素进行评估。在这种情况下，闭包检查数组的当前元素（`$0`）是否等于传递给函数的单词。
- en: The result of this `filter` operation is a new array that contains all the elements
    of `userEnteredWordsArray` that match the given condition. If this new array is
    not empty, that means that the word already exists in the `userEnteredWordsArray`,
    so the function returns `false`. If the new array is empty, that means that the
    word is not duplicated, so the function returns `true`. The `isEmpty` property
    of the array is used to check whether the array is empty.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`filter`操作的结果是一个新数组，它包含所有与给定条件匹配的`userEnteredWordsArray`中的元素。如果这个新数组不为空，这意味着单词已经存在于`userEnteredWordsArray`中，所以函数返回`false`。如果新数组为空，这意味着单词没有重复，所以函数返回`true`。使用数组的`isEmpty`属性来检查数组是否为空。
- en: 'Now, just filling out the function is not enough to have it check for duplicates;
    we have to call this function inside of the `addWordToList` function so that we
    can use it to check the new words before they are added to the list. Let’s do
    that now – inside the `addWordToList` function, add the following, right after
    the `userWord` instance is created:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仅仅填充函数还不够，我们需要在`addWordToList`函数中调用这个函数，这样我们就可以在单词被添加到列表之前使用它来检查新单词。让我们现在就做这件事——在`addWordToList`函数中，在创建`userWord`实例之后，添加以下内容：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code checks the `isWordDuplicate` function to see whether it’s returning
    `true` by using the `!` operator in front of it. Remember, the `isWordDuplicate`
    function returns a Boolean value, either `true` or `false`, so if this function
    returns `false`, then the `if` statement runs the code in its body, which is another
    function called `displayErrorMessage`. This will display an error message to the
    user telling them that their word is a duplicate (we haven’t set up our error
    messaging system yet, but we will soon!).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过在`isWordDuplicate`函数前使用`!`运算符来检查它是否返回`true`。记住，`isWordDuplicate`函数返回一个布尔值，要么是`true`要么是`false`，所以如果这个函数返回`false`，那么`if`语句就会运行其体内的代码，这是一个名为`displayErrorMessage`的另一个函数。这将向用户显示一个错误消息，告诉他们他们的单词是重复的（我们还没有设置我们的错误消息系统，但我们很快就会这么做！）。
- en: Now I’d like you to come back into `ContentView` and run the app, enter a word,
    and see it appear in the list. Then, try entering that same word again, and you’ll
    notice you’re not able to. The `guard` statement stops it from happening because
    it checks and sees that the word has already been entered into the list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想让你回到`ContentView`中运行应用，输入一个单词，并看到它在列表中显示。然后，再次输入相同的单词，你会注意到你无法这样做。`guard`语句阻止了这种情况的发生，因为它检查并看到该单词已经被输入到列表中。
- en: Next, we want to add a button that will grab a random word from the word files
    we imported into the project, which gives the user a word to play with and try
    to find words from.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要添加一个按钮，该按钮可以从我们导入到项目中的单词文件中随机获取一个单词，这给用户提供了一个单词来玩耍并尝试找到单词。
- en: Adding a random word with a button press
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过按钮点击添加随机单词
- en: Before we continue with the methods and fill them out, we need a button to provide
    a random word that the user can play off and try to find words from. After all,
    it’s not a challenge to just type random words and for them to appear in the list
    currently.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续填充方法和内容之前，我们需要一个按钮来提供一个用户可以用来玩耍并尝试找到单词的随机单词。毕竟，只是输入随机单词并在列表中显示它们目前并不是一个挑战。
- en: We’ll start by supplying a file of thousands of seven-letter words, from which
    one will be shown on the screen randomly when a button is pressed. We will also
    give the user the choice to choose a seven-, eight-, or nine-letter word, and
    the option to select another language later, but right now, let’s just stick with
    seven-letter English words.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先提供一个包含数千个七个字母的单词文件，当按下按钮时，其中一个单词会随机显示在屏幕上。我们还将给用户选择七个、八个或九个字母的单词，以及稍后选择其他语言的选择，但现在，让我们只坚持使用七个字母的英语单词。
- en: If you haven’t done so already, go to the GitHub folder, select the `Language`
    files folder, and drop the contents of that folder into the Project navigator.
    Once done, select them all, right-click, and choose `Languages` – this helps keep
    everything organized in the Project navigator.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请转到GitHub文件夹，选择`Language`文件文件夹，并将该文件夹的内容拖放到项目导航器中。完成后，选择所有文件，右键单击并选择`Languages`——这有助于在项目导航器中保持一切井井有条。
- en: 'Now those files are added to the project and we have already built out the
    `getRandomWord` function, which will get us a random word from a specified file,
    so now we need to call this function so that we can show the word to the user
    – we can do that with a button. Add the following code directly in `VStack`, above
    the `Text` field code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些文件已经添加到项目中，并且我们已经构建了`getRandomWord`函数，该函数可以从指定的文件中获取随机单词，所以现在我们需要调用这个函数，以便向用户显示单词——我们可以通过按钮来实现这一点。直接在`VStack`中`Text`字段代码上方添加以下代码：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code creates a button. Inside the `action` parameter for the button, we
    use our `appData` instance and call the `getRandomWord` function. We also set
    the `wordToPlayFrom` property to the `baseWord` value because `baseWord` contains
    the random word that will appear on the screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个按钮。在按钮的`action`参数中，我们使用`appData`实例调用`getRandomWord`函数。我们还把`wordToPlayFrom`属性设置为`baseWord`的值，因为`baseWord`包含将在屏幕上显示的随机单词。
- en: Now every time the button is pressed, a randomized word from our text file is
    placed into `baseWord`, which then gets placed into the `wordToPlayFrom` property
    to be displayed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次按下按钮时，都会从我们的文本文件中随机选择一个单词放入`baseWord`，然后该单词被放入`wordToPlayFrom`属性以供显示。
- en: At the end of the button code, we create a `Text` view that displays `wordToPlayFrom`
    on the screen. The button is then styled with a wood background image, a slight
    corner radius, a little bit of shadow, and the words **New Word**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮代码的末尾，我们创建了一个`Text`视图，在屏幕上显示`wordToPlayFrom`。按钮随后被赋予木纹背景图片、轻微的圆角、一点阴影和**新单词**字样。
- en: 'After adding that code, the button should look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这段代码后，按钮应该看起来像这样：
- en: '![Figure 12.4: A button to create a random word ](img/B18674_12_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：创建随机单词的按钮](img/B18674_12_04.jpg)'
- en: 'Figure 12.4: A button to create a random word'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：创建随机单词的按钮
- en: Now, press the button, and you will get a random word that a user can work with.
    Also, notice that when you press the button, it actually looks like it’s being
    pressed down; we get this behavior by default, which really adds to the user experience.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按下按钮，你将得到一个用户可以处理的随机单词。同时，请注意，当你按下按钮时，它实际上看起来像是被按下了；我们默认获得这种行为，这实际上增加了用户体验。
- en: The game is coming along, but we want to continue checking the word the user
    enters to see whether it can be made from the randomized word. Let’s do that up
    next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏正在进行中，但我们想要继续检查用户输入的单词，看看它是否可以由随机单词组成。接下来我们就来做这件事。
- en: Checking if the user’s entered word is possible
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查用户输入的单词是否可行
- en: Looking for duplicate words is not enough. Now that we have generated a random
    seven-letter word, we want to make sure that the user’s entered word can be made
    from the letters that are in the random word. For example, if the random word
    is `books`, that would be invalid because `s` is not in the random word.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 仅查找重复的单词是不够的。现在我们已经生成了一个随机的七个字母的单词，我们想要确保用户输入的单词可以由随机单词中的字母组成。例如，如果随机单词是`books`，那么这是无效的，因为`s`不在随机单词中。
- en: 'Let’s go back to the `DataModel` class and add code to the `isWordFoundInBaseWord`
    function so that we can check that the word can be made from `baseWord`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`DataModel`类，并在`isWordFoundInBaseWord`函数中添加代码，以便我们可以检查单词是否可以由`baseWord`组成：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here’s how this function works. The `isWordFoundInBaseWord` function takes a
    `String` parameter, `userGuessWord`, and returns a `Bool` value indicating whether
    or not `userGuessWord` can be made by removing letters from the `baseWord` string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的工作原理是这样的。`isWordFoundInBaseWord`函数接受一个`String`参数`userGuessWord`，并返回一个`Bool`值，指示`userGuessWord`是否可以通过从`baseWord`字符串中删除字母来创建。
- en: The function starts by creating a `comparisonWord` variable equal to `baseWord`.
    The `comparisonWord` variable is used to keep track of the remaining letters in
    `baseWord` that haven’t been matched by `userGuessWord`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先创建一个`comparisonWord`变量，其值等于`baseWord`。`comparisonWord`变量用于跟踪`baseWord`中尚未与`userGuessWord`匹配的剩余字母。
- en: Next, the function uses the `allSatisfy` method of `String` to check that all
    the letters in `userGuessWord` can be found in `comparisonWord`. The `allSatisfy`
    method iterates over each character in the string and returns `true` if the closure
    passed to it returns `true` for all characters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数使用`String`的`allSatisfy`方法来检查`userGuessWord`中的所有字母是否都可以在`comparisonWord`中找到。`allSatisfy`方法遍历字符串中的每个字符，如果传递给它的闭包对所有字符都返回`true`，则返回`true`。
- en: The closure takes a single parameter letter, representing the current letter
    in `userGuessWord` being processed. It first uses the `firstIndex(of:)` method
    to find the index of a letter in `comparisonWord`. If a letter is not found in
    `comparisonWord`, the closure immediately returns `false`, which will make the
    overall `allSatisfy` call return `false`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包接受一个参数字母，代表正在处理的`userGuessWord`中的当前字母。它首先使用`firstIndex(of:)`方法在`comparisonWord`中查找字母的索引。如果字母在`comparisonWord`中未找到，闭包立即返回`false`，这将使整个`allSatisfy`调用返回`false`。
- en: If a letter is found in `comparisonWord`, the closure removes that letter from
    `comparisonWord` using the `remove(at:)` method. Finally, the closure returns
    `true`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`comparisonWord`中找到字母，闭包使用`remove(at:)`方法从`comparisonWord`中移除该字母。最后，闭包返回`true`。
- en: If the `allSatisfy` call returns true, the function returns `true`, indicating
    that `userGuessWord` can be made by removing letters from `baseWord`. If `allSatisfy`
    returns `false`, the function returns `false`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`allSatisfy`调用返回`true`，则函数返回`true`，表示`userGuessWord`可以通过从`baseWord`中删除字母来创建。如果`allSatisfy`返回`false`，则函数返回`false`。
- en: The logic for this can be a little tricky to understand at first, but it basically
    looks at each letter in the user’s word and compares it to `baseWord`. Any letter
    that’s not in `baseWord` will cause the method to return `false`, meaning the
    user’s word is incorrect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑一开始可能有点难以理解，但它基本上是查看用户单词中的每个字母，并将其与`baseWord`进行比较。任何不在`baseWord`中的字母都会导致方法返回`false`，这意味着用户的单词是不正确的。
- en: 'Now that we have this method written out, let’s put it to work. We need to
    call this method in the `addWordToList` function, so place this code after the
    `if` statement’s closing brace:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了这个方法，让我们来使用它。我们需要在`addWordToList`函数中调用这个方法，所以将此代码放在`if`语句的闭合括号之后：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What we’re doing here is calling the `isWordFoundInBaseWord` function, and it
    will have `userGuessedWord` passed into it. The function checks whether the word
    is possible to create – if not, we’re going to display an alert message to the
    user using the `displayErrorMessage` method (again, the alert messages will be
    created later).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是调用`isWordFoundInBaseWord`函数，并将`userGuessedWord`传递给它。该函数检查单词是否可以创建——如果不能，我们将使用`displayErrorMessage`方法（再次提醒，警告消息将稍后创建）向用户显示警告信息。
- en: 'Let’s try this out. Come back into `ContentView` and run the program. You will
    see that you cannot enter a word unless those letters are also present in `baseWord`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个。回到`ContentView`并运行程序。你会看到，除非那些字母也出现在`baseWord`中，否则你不能输入一个单词：
- en: '![Figure 12.5: Checking whether the word is possible using the base word’s
    letters ](img/B18674_12_05.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：使用基本单词的字母检查单词是否可能](img/B18674_12_05.jpg)'
- en: 'Figure 12.5: Checking whether the word is possible using the base word’s letters'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：使用基本单词的字母检查单词是否可能
- en: Here, I entered `set` into the list because that can be made from `sent` because
    there is no `n` in `isWordFoundInBaseWord` function is working perfectly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将`set`放入列表中，因为可以从`sent`中创建它，因为`isWordFoundInBaseWord`函数中没有`n`，它正在完美地工作。
- en: Checking whether the user’s entered word is a real word
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查用户输入的单词是否是真实单词
- en: There is one final check we need to do, and that is to see whether the word
    is an actual word in the dictionary. This check is important because the user
    could rearrange letters in `baseWord`, make up their own word, and enter it into
    the list. We want to prevent that and check each of the words against an actual
    dictionary. To do that, we can use the `UITextChecker` class. This class has methods
    and properties we can use to check whether a word is an actual word in the dictionary,
    and what’s especially nice is it will work with misspellings and authenticity
    in Spanish and Italian as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要进行一个最后的检查，那就是查看单词是否是词典中的实际单词。这个检查很重要，因为用户可能会在`baseWord`中重新排列字母，自己造一个单词并输入到列表中。我们想要防止这种情况，并检查每个单词是否与实际的词典相匹配。为此，我们可以使用`UITextChecker`类。这个类有我们可以用来检查单词是否是词典中实际单词的方法和属性，而且特别好的是，它还可以与西班牙语和意大利语的拼写错误和真实性一起工作。
- en: 'So, let’s go into the `DataModel` class and add the following code to the `isWordInDictionary`
    function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们进入`DataModel`类，并在`isWordInDictionary`函数中添加以下代码：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We’re going to get an error here because I am adding this `isNotFound` property.
    So, let’s fix that error first, and then we can go over what the code is doing.
    Outside the class’s closing brace, add the following extension:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里会得到一个错误，因为我正在添加这个`isNotFound`属性。所以，让我们先修复这个错误，然后再来看代码在做什么。在类的闭合括号外，添加以下扩展：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Going back now, the `isWordInDictionary` function checks whether a given word
    exists in the English dictionary. It does so by creating an instance of `UITextChecker`
    and calling the `rangeOfMisspelledWord` method on it. This method takes several
    arguments:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 回过头来看，`isWordInDictionary`函数检查给定的单词是否存在于英语词典中。它是通过创建一个`UITextChecker`实例并在其上调用`rangeOfMisspelledWord`方法来做到这一点的。此方法接受几个参数：
- en: '`word`: The word to check for spelling'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word`：要检查拼写的单词'
- en: '`range`: The range of the word to check, specified as `NSRange`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`：要检查的单词的范围，指定为`NSRange`'
- en: '`startingAt`: The starting position of the word to check within the specified
    range'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startingAt`：要检查的单词在指定范围内的起始位置'
- en: '`wrap`: A Boolean value indicating whether to wrap around the end of the range
    to the beginning when checking for misspelled words'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrap`：一个布尔值，指示在检查拼写错误的单词时是否将范围环绕到范围的开始处'
- en: '`language`: The language to use for spell checking – in this case, `"en"` for
    English'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language`：用于拼写检查的语言 – 在这种情况下，为`"en"`表示英语'
- en: The method then returns an `NSRange` that indicates the range of the first misspelled
    word found. If no misspelled word is found, the `location` property of the returned
    range is set to `NSNotFound`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法返回一个`NSRange`，指示找到的第一个拼写错误的单词的范围。如果没有找到拼写错误的单词，则返回范围的`location`属性被设置为`NSNotFound`。
- en: The `isNotFound` computed property is an extension on `NSRange` that returns
    `true` if the `location` property is equal to `NSNotFound`, and `false` otherwise.
    This makes it more readable and allows us to write `isNotFound` instead of comparing
    the location of `NSNotFound` in the function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNotFound`计算属性是`NSRange`的一个扩展，如果`location`属性等于`NSNotFound`，则返回`true`，否则返回`false`。这使得代码更易读，并允许我们用`isNotFound`代替在函数中比较`NSNotFound`的位置。'
- en: Summing it up, the function creates an instance of the `UITextChecker` class.
    `UITextChecker` looks through its dictionary for any misspelling to make sure
    the word is real – if it is in the dictionary, `true` is returned and the word
    will be entered into the user’s list; otherwise, `false` will be returned, and
    we show a message to the user saying that this is not an actual word in the dictionary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，该函数创建了一个 `UITextChecker` 类的实例。`UITextChecker` 会检查其字典中是否有任何拼写错误，以确保单词是真实的——如果它在字典中，则返回
    `true`，并将单词添加到用户的列表中；否则，返回 `false`，并向用户显示一条消息，说明这不是字典中的实际单词。
- en: 'Now that the function is complete, let’s use it. Add the following code directly
    after the closing brace of the previous `guard` statement in the `addWordToList`
    function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数已经完成，让我们来使用它。在 `addWordToList` 函数中上一个 `guard` 语句的闭合大括号之后直接添加以下代码：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With that code in place, give the app another go and make up your own word
    using the given letters in `baseWord`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好代码后，再次运行应用程序，并使用 `baseWord` 中提供的字母创建自己的单词：
- en: '![Figure 12.6: Checking whether the word is in the dictionary ](img/B18674_12_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6：检查单词是否在字典中](img/B18674_12_06.jpg)'
- en: 'Figure 12.6: Checking whether the word is in the dictionary'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：检查单词是否在字典中
- en: Here, I made up a word using the letters from `baseWord` – `tesh` – however,
    I wasn’t allowed to add the word to the list because there is no such word in
    the English language, so we know the function is working.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我使用 `baseWord` 中的字母创建了一个单词——`tesh`——然而，我不允许将这个单词添加到列表中，因为英语中没有这样的单词，所以我们知道该函数正在正常工作。
- en: And that really completes all of the word-checking functionality for the app;
    we will add pop-up alerts for when a user’s word doesn’t pass any of those checks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就真的完成了应用程序的所有单词检查功能；我们将为用户单词未通过任何检查时添加弹出警报。
- en: Let’s focus on building out the UI some more. We’re going to add a text string
    at the top that will be the name of the app, and we can style this in a separate
    file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建 UI。我们将在顶部添加一个文本字符串，这将作为应用程序的名称，我们可以在一个单独的文件中对其进行样式化。
- en: Creating HeaderView with an info button
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有信息按钮的 HeaderView
- en: Let’s continue building out the UI and add a header title, which will be the
    name of our app. We can create this header in a separate file so we can keep our
    `ContentView` clutter free.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建 UI 并添加一个标题，这将是我们应用程序的名称。我们可以在一个单独的文件中创建这个标题，这样我们就可以保持 `ContentView`
    的整洁。
- en: The purpose of `HeaderView` is twofold – to set the title of the app, and to
    add an `info` button that opens a user settings page.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeaderView` 的目的是双重的——设置应用程序的标题，并添加一个打开用户设置页面的 `info` 按钮。'
- en: 'Press *Command + N*, choose a `HeaderView`. Then, add a `Binding` property
    in the `HeaderView` struct:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Command + N*，选择一个 `HeaderView`。然后，在 `HeaderView` 结构体中添加一个 `Binding` 属性：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, add the following code inside the `body` property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `body` 属性内部添加以下代码：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we added a `ZStack` to hold two views, an image displaying the title
    of the app, and a button that we will set up to take the user to a settings page,
    where they can choose another language to play the game in. Also added was the
    `shadow` modifier on the image to help make it stand out a little more.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个 `ZStack` 来容纳两个视图，一个显示应用程序标题的图像，以及一个我们将设置以将用户带到设置页面（在那里他们可以选择在游戏中使用的另一种语言）的按钮。还添加了图像上的
    `shadow` 修饰符，以帮助使其更加突出。
- en: Inside the button closure, we use the system image of an info circle, then some
    top padding on it to align the button vertically with the image, and then we colored
    the button black using the `accent` modifier. After that, we offset the button
    to the right `150` points so that it’s next to the image on the right side of
    the screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮闭合内部，我们使用系统信息圆圈图标，然后在上边添加一些顶部填充以使按钮垂直对齐图像，然后使用 `accent` 修饰符将按钮染成黑色。之后，我们将按钮向右偏移
    `150` 点，使其位于屏幕右侧的图像旁边。
- en: When the `info` button is pressed, a settings page will open, giving the user
    three language options for the game. The `showSettings` property will be used
    to open up `SettingsView`, but we don’t have `SettingsView` yet, so let’s make
    one. Press *Command + N*, choose `SettingsView`. And just like that, we now have
    our `SettingsView`. Let’s come back into the `SettingsView`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下 `info` 按钮时，将打开一个设置页面，为用户提供三种游戏语言选项。将使用 `showSettings` 属性来打开 `SettingsView`，但我们还没有
    `SettingsView`，所以让我们创建一个。按下 *Command + N*，选择 `SettingsView`。就这样，我们现在有了 `SettingsView`。让我们回到
    `SettingsView`。
- en: 'Inside the button, we need to toggle the `showSettings` state variable, so
    add the following line of code to the button body:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮内部，我们需要切换 `showSettings` 状态变量，因此需要在按钮体中添加以下代码行：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And finally, in order to open up a sheet over another view, we need to call
    the `sheet` modifier on the button, so add the code to the end of the button’s
    closing brace:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在另一个视图上打开一个表单，我们需要在按钮上调用 `sheet` 修饰符，因此将代码添加到按钮的闭合括号末尾：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `sheet` modifier is used in SwiftUI to open a sheet, which is simply another
    view that opens by sliding up from the bottom of the screen. The sheet is triggered
    by the `isPresented` parameter – when the value of `isPresented` becomes `true`,
    the code in the `sheet` modifier’s body will run. In the `sheet` modifier’s closure,
    there is a call to `SettingsView`; this is the view (sheet) that gets presented
    over `ContentView`. To dismiss the sheet, the user slides it back down with their
    finger.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中，`sheet` 修饰符用于打开一个表单，它是一个从屏幕底部滑上打开的另一个视图。表单是通过 `isPresented` 参数触发的——当
    `isPresented` 的值变为 `true` 时，`sheet` 修饰符体中的代码将执行。在 `sheet` 修饰符的闭包中，有一个对 `SettingsView`
    的调用；这是覆盖 `ContentView` 的视图（表单）。要关闭表单，用户只需用手指将其滑回即可。
- en: 'To see this in action, we need to add two more lines of code inside `ContentView`.
    First, go into that file, and add a `State` property that can connect to the `Bindin`g
    variable of `HeaderView`. Add this `State` variable right after the previous property
    at the top in `ContentView`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个功能在实际中的效果，我们需要在 `ContentView` 中添加两行额外的代码。首先，进入该文件，并在 `ContentView` 的顶部添加一个可以连接到
    `HeaderView` 的 `Binding` 变量的 `State` 属性。将这个 `State` 变量添加到 `ContentView` 中上一个属性之后：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I’m calling it `showSettings`, the same as the variable it’s binding to from
    `HeaderView`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其命名为 `showSettings`，与它从 `HeaderView` 绑定的变量同名。
- en: 'Now, we just need to add a call to `HeaderView` to get the `info` button working.
    Add this line of code inside `VStack` at the top:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在 `VStack` 的顶部添加对 `HeaderView` 的调用，以使 `info` 按钮正常工作。在 `VStack` 的顶部添加以下代码行：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And that’s all we need to get `SettingsView` working. Try it out – press the
    information button in `ContentView` and `SettingsView` opens:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就需要所有内容来使 `SettingsView` 正常工作。试试看——在 `ContentView` 中按信息按钮，`SettingsView`
    就会打开：
- en: '![Figure 12.7: SettingsView ](img/B18674_12_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7：SettingsView](img/B18674_12_07.jpg)'
- en: 'Figure 12.7: SettingsView'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：SettingsView
- en: To dismiss the view, simply slide down on the opened view. This “sliding to
    close” behavior is automatically baked into the `sheet` modifier, so we don’t
    have to implement it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭视图，只需在打开的视图中向下滑动。这种“滑动关闭”的行为是自动嵌入到 `sheet` 修饰符中的，因此我们不需要实现它。
- en: So, we have `SettingView` working, although it doesn’t do much right now other
    than open up and show `PickerView` that the user can press on to set the size
    of the words they want to play with.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`SettingView` 正在正常工作，尽管它现在除了打开并显示用户可以点击以设置他们想要玩的单词大小的 `PickerView` 外，没有做太多。
- en: Creating PickerView
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 PickerView
- en: A `PickerView` is a view that displays various options to the user. The picker
    can either be a single button with a drop-down list, a segmented list with multiple
    buttons, or a wheel that the user can spin to select an option.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickerView` 是一个向用户展示各种选项的视图。选择器可以是带有下拉列表的单个按钮，一个带有多个按钮的分段列表，或者用户可以旋转以选择选项的轮盘。'
- en: There are two main differences between these three pickers in terms of style.
    The first is how they appear in your app. The second is the number of options
    available to the user – the wheel can hold many, many options for the user, whereas
    a button picker or a segmented control picker is limited by the amount of space
    on the screen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在风格方面，这三个选择器有两个主要区别。第一个是它们在你的应用中是如何出现的。第二个是用户可用的选项数量——轮盘可以为用户提供许多许多选项，而按钮选择器或分段控制器选择器则受屏幕空间大小的限制。
- en: Since we will be offering just three options to the user, a seven-, eight-,
    or nine-letter word option, we’ll go with the segmented control.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只向用户提供三个选项，即七、八或九个字母的单词选项，我们将使用分段控制器。
- en: Adding PickerView
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 PickerView
- en: 'Let’s start by adding a new `PickerView`. Next, let’s add an instance of the
    `DataModel` class at the top of the struct so we have access to the data properties:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个新的 `PickerView` 开始。接下来，让我们在结构体的顶部添加 `DataModel` 类的实例，这样我们就可以访问数据属性：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then add a `VStack`, and inside that, add a `topBar` image that we have in
    the Assets catalog, which will help to frame the picker:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一个 `VStack`，并在其中添加我们位于 Assets 目录中的 `topBar` 图片，这将有助于为选择器提供框架：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the code, we add the `topBar` image and put a little padding and shadow around
    it to help it stand out against the background (which will be added soon). Then,
    we use `10` points of center spacing on the `VStack` to keep some space between
    the views.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们添加了`topBar`图像，并在其周围添加了一些填充和阴影，以帮助它突出显示在背景（即将添加）上。然后，我们在`VStack`上使用`10`点的中心间距来保持视图之间的空间。
- en: 'Now, add the `Picker` control underneath the last line of code we just added:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在刚刚添加的代码最后一行下方添加`Picker`控件：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code adds the picker and uses the `selectedSegment` property in `DataModel`,
    which is used to keep track of which segment of the picker has been selected by
    the user. The picker is set to three different titles, and we use the `tag` modifier
    to distinguish which title goes where on the picker control. Now, the user can
    choose between `7`, `8`, or `9` letters for the word they will work with.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了选择器并使用`DataModel`中的`selectedSegment`属性，该属性用于跟踪用户选择了选择器的哪个部分。选择器被设置为三个不同的标题，我们使用`tag`修饰符来区分选择器控件上的哪个标题。现在，用户可以在`7`、`8`或`9`个字母之间进行选择。
- en: 'This is the default button look, which offers options to the user when pressed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认按钮外观，当按下时为用户提供选项：
- en: '![Figure 12.8: The button picker ](img/B18674_12_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8：按钮选择器](img/B18674_12_08.jpg)'
- en: 'Figure 12.8: The button picker'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：按钮选择器
- en: Let’s now look at how we can style the picker to something more suitable for
    our game.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何将选择器样式调整为更适合我们游戏的形式。
- en: Styling PickerView
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PickerView样式
- en: 'As I mentioned, I feel that segmented control looks better, so let’s change
    the styling to that picker option instead. Add the following code after the closing
    brace of `PickerView`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，我觉得分段控件看起来更好，所以让我们将样式更改为那个选择器选项。在`PickerView`的闭合括号之后添加以下代码：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We set the picker to the segmented style, and added a rounded rectangle with
    a corner radius of `8` points, with a black stroke around the picker control to
    give it a nice border. Then, we finished it off with some shadow and padding,
    and this is what it looks like:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择器设置为分段样式，并添加了一个边角半径为`8`点的圆角矩形，在选择器控件周围有黑色描边，以给它一个漂亮的边框。然后，我们用一些阴影和填充来完成它，这就是它的样子：
- en: '![Figure 12.9: The completed PickerView ](img/B18674_12_09.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9：完成的PickerView](img/B18674_12_09.jpg)'
- en: 'Figure 12.9: The completed PickerView'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：完成的PickerView
- en: '`PickerView` is done, but to complete the work in the `PickerView` file, let’s
    add a `bottomBar` image to the scene. After the `shadow` modifier, add the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickerView`已完成，但为了完成`PickerView`文件中的工作，让我们在场景中添加一个`bottomBar`图像。在`shadow`修饰符之后，添加以下内容：'
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This just sets `bottomBar` like `topBar`, and helps frame out `PickerView`
    in the UI:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是像`topBar`一样设置`bottomBar`，并帮助在UI中构建`PickerView`：
- en: '![Figure 12.10: The bottom bar image added ](img/B18674_12_10.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10：已添加底部栏图像](img/B18674_12_10.jpg)'
- en: 'Figure 12.10: The bottom bar image added'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：已添加底部栏图像
- en: 'Let’s go back into `ContentView`, where we need to call `PickerView` to bring
    it into the scene. Add the following just below the `HeaderView` code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`ContentView`，在那里我们需要调用`PickerView`来将其引入场景。在`HeaderView`代码下方添加以下内容：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now we have our `PickerView` that can offer the user some choices. It doesn’t
    do anything yet because we need to fill out the `setWordLengthAndLanguage` method,
    so let’s do that. Back in `DataModel`, add the following code inside the `setWordLengthAndLanguage`
    method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以提供用户选择的`PickerView`。它目前还没有做任何事情，因为我们还需要填写`setWordLengthAndLanguage`方法，所以让我们来做这件事。回到`DataModel`，在`setWordLengthAndLanguage`方法内部添加以下代码：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is how the `setWordLengthAndLanguage` function works. It starts by defining
    two dictionaries, `language` and `wordLength`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`setWordLengthAndLanguage`函数的工作方式。它首先定义了两个字典，`language`和`wordLength`：
- en: The `language` dictionary maps the names of different languages to their abbreviations.
    In this case, `"English"` is mapped to `"En"`, `"Spanish"` is mapped to `"ES"`,
    and `"Italian"` is mapped to `"It"`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language`字典将不同语言的名称映射到它们的缩写。在这种情况下，`"English"`映射到`"En"`，`"Spanish"`映射到`"ES"`，`"Italian"`映射到`"It"`。'
- en: The `wordLength` dictionary maps integer values to their corresponding word
    lengths. For example, `1` is mapped to `"7"`, `2` is mapped to `"8"`, and `3`
    is mapped to `"9"`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordLength`字典将整数值映射到它们对应的单词长度。例如，`1`映射到`"7"`，`2`映射到`"8"`，`3`映射到`"9"`。'
- en: Next, the function checks the value of the `selectedSegment` variable. This
    variable holds an integer that represents the user’s selected word length (seven
    letters, eight letters, or nine letters).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数检查`selectedSegment`变量的值。该变量包含一个整数，表示用户选择的单词长度（七个字母、八个字母或九个字母）。
- en: Based on the value of `selectedSegment`, the function retrieves the corresponding
    word length from the `wordLength` dictionary using the square bracket notation,
    `wordLength[selectedSegment]`. This gives us the word length as a string, such
    as `7`, `8`, or `9`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`selectedSegment`的值，函数使用方括号表示法从`wordLength`字典中检索相应的单词长度，即`wordLength[selectedSegment]`。这给我们提供了单词长度作为字符串，例如`7`、`8`或`9`。
- en: The function then checks the values of the `englishIsOn`, `spanishIsOn`, and
    `italianIsOn` variables. These variables hold Booleans that indicate whether the
    user has selected the corresponding language.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后检查`englishIsOn`、`spanishIsOn`和`italianIsOn`变量的值。这些变量包含布尔值，表示用户是否选择了相应的语言。
- en: If one of these language variables is true, then the function uses the corresponding
    language abbreviation (retrieved from the `language` dictionary) and the word
    length (retrieved from the `wordLength` dictionary) to construct the filename
    of the data file that contains the words for that language and word length. For
    example, if the user has selected English with seven letters, the filename will
    be `7LetterWordsEn`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些语言变量中的任何一个为真，则函数使用相应的语言缩写（从`language`字典中检索）和单词长度（从`wordLength`字典中检索）来构造包含该语言和单词长度的单词数据文件的文件名。例如，如果用户选择了七个字母的英语，则文件名将是`7LetterWordsEn`。
- en: The function sets the value of the `letterCount` variable to a string that provides
    a description of the selected language and word length, such as `7 letter word
    -` `American English`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将`letterCount`变量的值设置为字符串，该字符串提供了所选语言和单词长度的描述，例如`7 letter word -` `American
    English`。
- en: Finally, the function returns the constructed filename as a string.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数返回构造的文件名作为字符串。
- en: 'There’s one other bit of code we need to add to `ContentView` in order to get
    the language word count string working for the picker control. Add the following
    code directly after the `shadow` modifier of the button:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让语言单词计数字符串在选择器控件中工作，我们需要在`ContentView`中添加一段代码。将以下代码直接添加到按钮的`shadow`修饰符之后：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this code, we added a `VStack` and then displayed the `letterCount` property
    in a `Text` view by using the `appData` instance. Then, we applied a font size
    and weight and a white foreground, made it bold, and added a shadow to the `Text`
    view. What I want you to do now is to cut out the `Text` view that displays the
    `wordToPlayFrom` property, and paste it inside the `VStack` just added, at the
    very end. This keeps both text views horizontally organized.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们添加了一个`VStack`，然后通过使用`appData`实例在`Text`视图中显示了`letterCount`属性。然后，我们应用了字体大小和粗细，设置了白色前景，使其加粗，并给`Text`视图添加了阴影。现在我想让你做的是，剪切显示`wordToPlayFrom`属性的`Text`视图，并将其粘贴到刚刚添加的`VStack`中，放在最末尾。这样就可以使两个文本视图水平排列。
- en: 'Now, to test the picker out and see it display the letter word string, as well
    as a word in a different language, we need to come to our data file and set one
    of the `language` variables to `true`; just for testing purposes, we will later
    toggle these variables in the settings page. So, in `DataModel`, change the `spanishIsOn`
    variable to `true`, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试选择器并查看它显示字母单词字符串以及不同语言的单词，我们需要来到我们的数据文件，并将其中一个`language`变量设置为`true`；仅用于测试目的，我们将在设置页面中稍后切换这些变量。所以，在`DataModel`中，将`spanishIsOn`变量更改为`true`，如下所示：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, come into `ContentView` and select the length of the word that you want
    to use from the picker control. Press the button and you will see a Spanish word
    of the length you chose and the `letterCount` string displaying the chosen language’s
    flag and picker selection for the word size:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入`ContentView`并从选择器控件中选择你想要使用的单词长度。按下按钮，你将看到你选择的长度的一个西班牙语单词，以及显示所选语言标志和单词大小选择器的`letterCount`字符串：
- en: '![Figure 12.11: Choosing the word size and language for the game ](img/B18674_12_11.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11：选择游戏的单词大小和语言](img/B18674_12_11.jpg)'
- en: 'Figure 12.11: Choosing the word size and language for the game'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：选择游戏的单词大小和语言
- en: You can check it for the other two languages as well by just setting one of
    those languages to `true` and keeping the others set to `false`. Also, if you
    don’t set one of the `AppStorage` variables to `true`, then the picker will not
    pick the length of the word; it will default to an eight-letter word (this behavior
    will work itself out when we finish adding the rest of the code in the next chapter).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过将其中一个语言设置为`true`，而将其他设置为`false`来检查其他两种语言。另外，如果您没有将`AppStorage`变量之一设置为`true`，那么选择器将不会选择单词的长度；它将默认为八个字母的单词（当我们在下一章完成添加其余代码时，这种行为将自行解决）。
- en: After you’re done testing things out, make sure to set the `data` variable back
    to `false`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试完所有内容后，请确保将`data`变量设置回`false`。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, we’ve come to the end of this chapter, and have done quite a bit of work.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经到达了这一章节的结尾，并且完成了很多工作。
- en: We started building out our game, allowing the user to enter words to play the
    game, and adding checks to validate their choices. We also added a button that
    the user can press to bring up a random word from a file of thousands of words,
    a button that brings up a settings page, a picker control, and a letter count
    string.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始构建我们的游戏，允许用户输入单词来玩游戏，并添加检查来验证他们的选择。我们还添加了一个按钮，用户可以按下它来从包含数千个单词的文件中随机获取一个单词，一个弹出设置页面的按钮，一个选择控件，以及一个字母计数字符串。
- en: Next, we will continue building out the app, specifically building out the user
    interface, the settings page so it contains those three buttons that the user
    can select for the languages, and adding error messages when the user’s entered
    word is not valid. So, let’s continue with the second part of this project in
    the next chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续构建应用程序，具体来说，是构建用户界面，设置页面，使其包含用户可以选择的语言的三个按钮，并在用户输入的单词无效时添加错误信息。那么，让我们在下一章继续这个项目的第二部分。
