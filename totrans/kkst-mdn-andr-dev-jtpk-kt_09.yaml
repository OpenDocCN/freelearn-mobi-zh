- en: '*Chapter 7*: Introducing Presentation Patterns in Android'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：介绍 Android 中的展示模式'
- en: In this chapter, we're continuing our journey of exploring ways to architect
    Android applications. More precisely, we will be making sure that our applications
    split responsibilities correctly with the introduction of presentation patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探索构建 Android 应用程序的方法。更确切地说，我们将通过引入展示模式来确保我们的应用程序正确地划分了责任。
- en: In the first section, *Introducing MVC, MVP, and MVVM as presentation patterns*,
    we will provide a short overview on why we need presentation patterns, and we
    will explore how most common patterns are implemented in Android projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*介绍 MVC、MVP 和 MVVM 作为展示模式*，我们将简要概述为什么我们需要展示模式，并探讨这些最常见模式在 Android 项目中的实现方式。
- en: Next up, in the *Refactoring our Restaurants App to fit a presentation pattern*
    section, we will refactor our Restaurants App to fit the MVVM presentation pattern,
    while also understanding why MVVM is best suited for our Compose-based app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *将我们的餐厅应用重构为适合展示模式* 部分，我们将重构我们的餐厅应用以适应 MVVM 展示模式，同时理解为什么 MVVM 最适合我们的基于
    Compose 的应用。
- en: In the last section, *Improving state encapsulation in ViewModel*, we will see
    why it's important for the `ViewModel`, and we will explore how to achieve that.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，*在 ViewModel 中改进状态封装*，我们将看到为什么这对于 `ViewModel` 很重要，并且我们将探讨如何实现这一点。
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主要主题：
- en: Introducing **Model-View-Controller** (**MVC**), **Model-View-Presenter** (**MVP**),
    and **Model-View-ViewModel** (**MVVM**) as presentation patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 **模型-视图-控制器**（**MVC**）、**模型-视图-表示者**（**MVP**）和 **模型-视图-视图模型**（**MVVM**）作为展示模式
- en: Refactoring our Restaurants app to a presentation pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的餐厅应用重构为展示模式
- en: Improving state encapsulation in ViewModel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ViewModel 中改进状态封装
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为这一章节设置技术要求。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects for this chapter usually requires your
    day-to-day tools. However, to follow along smoothly, make sure you have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本章的基于 Compose 的 Android 项目，通常需要你日常使用的工具。然而，为了顺利跟进，请确保你拥有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds, but note that the IDE interface
    and other generated code files might differ from the ones used throughout this
    book.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1 版本的 Android Studio。你也可以使用更新的 Android Studio 版本，甚至是 Canary
    构建，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or newer plugin installed in Android Studio.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中安装了 Kotlin 1.6.10 或更高版本的插件。
- en: The Restaurants app code from the previous chapter.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个章节中的餐厅应用代码。
- en: The starting point for this chapter is represented by the Restaurants app developed
    in the previous chapter. If you haven't followed the implementation from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_06`
    directory of the repository and importing the Android project entitled `chapter_6_restaurants_app`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是上一章开发的餐厅应用。如果你没有跟随上一章的实现，可以通过导航到存储库的 `Chapter_06` 目录并导入名为 `chapter_6_restaurants_app`
    的 Android 项目来访问本章的起点。
- en: To access the solution code for this chapter, navigate to the `Chapter_07` directory
    at [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app)
    中的 `Chapter_07` 目录。
- en: Introducing MVC, MVP, and MVVM as presentation patterns
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MVC、MVP 和 MVVM 作为展示模式
- en: In the beginning, most Android projects were designed as a bunch of `Activity`
    or `Fragment` classes that were setting content to their corresponding **Extensible
    Markup Language** (**XML**) layouts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，大多数 Android 项目都是设计成一系列设置对应**可扩展标记语言**（**XML**）布局的 `Activity` 或 `Fragment`
    类。
- en: As projects grew and new features were requested, developers had to add more
    logic inside the `Activity` or `Fragment` class, development cycle after development
    cycle. This means that anything from a new feature, improvement, or bug fix for
    a particular screen would have to be done inside those `Activity` or `Fragment`
    classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的增长和新功能的请求，开发者必须在`Activity`或`Fragment`类中添加更多逻辑，一个开发周期接着一个开发周期。这意味着任何针对特定屏幕的新功能、改进或错误修复都必须在这些`Activity`或`Fragment`类中进行。
- en: 'After some time, these classes became larger and larger, and at some point,
    adding an improvement or fixing a bug could become a nightmare. The reason for
    this would be that the `Activity` or `Fragment` classes were burdened with all
    the responsibilities from within a particular project. These classes would be
    doing the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，这些类变得越来越大，在某个时候，添加改进或修复错误可能变得像噩梦一样。原因在于`Activity`或`Fragment`类承担了特定项目内的所有责任。这些类会执行以下操作：
- en: Defining the UI
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义UI
- en: Preparing the data to be displayed and defining different UI states
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备要显示的数据并定义不同的UI状态
- en: Obtaining data from different sources
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的来源获取数据
- en: Applying different business rules to data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同的业务规则应用于数据
- en: '*This approach introduces coupling between distinct responsibilities and concerns
    of a project*. For such projects, if—for example—a portion of the UI must be changed,
    your changes could easily impact other concerns of the app: the way data is presented,
    the logic of obtaining that data, business rules, and so on.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种方法在项目的不同责任和关注点之间引入了耦合。对于这样的项目，例如，如果需要更改UI的一部分，你的更改可能会轻易影响应用程序的其他关注点：数据展示的方式、获取数据逻辑、业务规则等等。'
- en: The worst part of this happening is that when you need to change only a part
    (say, part of the UI) and you end up changing other parts (say, the presentation,
    or data logic) you risk breaking unrelated things that worked, therefore possibly
    introducing new bugs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况最糟糕的部分是，当你只需要更改一部分（比如UI的一部分）时，你最终会改变其他部分（比如表示层或数据逻辑），你可能会破坏原本正常工作的相关部分，因此可能引入新的错误。
- en: 'Having such an approach where all the code of a project is bundled inside the
    `Activity` or `Fragment` class, causes your project to develop the following issues:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 采用所有项目代码都捆绑在`Activity`或`Fragment`类中的方法，会导致你的项目出现以下问题：
- en: '**Fragile and difficult to scale**: Adding new features or improvements can
    break other parts of your app.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脆弱且难以扩展**：添加新功能或改进可能会破坏应用程序的其他部分。'
- en: '**Difficult to test**: Since all the logic of the app is bundled in one place,
    testing only one part of the logic is very difficult because all your logic is
    tangled and tied to platform-related dependencies.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以测试**：由于应用程序的所有逻辑都捆绑在一个地方，因此仅测试逻辑的一部分非常困难，因为所有逻辑都纠缠在一起，并且与平台相关的依赖项紧密相连。'
- en: '**Difficult to debug**: When responsibilities are intertwined, then parts of
    your code base are also intertwined and coupled. Debugging one specific issue
    becomes extremely difficult because it''s hard to track the exact culprit.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以调试**：当责任交织在一起时，你的代码库的各个部分也会交织并耦合。调试一个特定问题变得极其困难，因为很难追踪到确切的罪魁祸首。'
- en: To alleviate these issues, we can try to identify the core responsibilities
    of an app and then separate their corresponding logic and code into distinct components
    (or classes) that are part of specific layers. This way, we are trying to follow
    the principle of **separation of concerns** (**SoC**), whereby each layer will
    contain classes whose responsibilities are tightly related only to their corresponding
    layer's concern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些问题，我们可以尝试确定应用程序的核心责任，然后将相应的逻辑和代码分离到不同的组件（或类）中，这些组件（或类）是特定层的组成部分。这样，我们试图遵循**关注点分离**（**SoC**）的原则，其中每个层将包含仅与其对应层关注点紧密相关的类。
- en: 'To make sure that our projects obey the SoC principle, we can split the app''s
    responsibilities into two major ones and define a layer for each of them, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的项目遵守SoC原则，我们可以将应用程序的责任分为两大类，并为每一类定义一个层，如下所示：
- en: The **Presentation layer** contains classes (or other components) responsible
    for defining the UI and preparing the data to be presented.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**包含负责定义UI和准备要展示的数据的类（或其他组件）。'
- en: The **Model layer** contains classes where the application's data is obtained,
    modeled, and updated.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型层**包含获取、建模和更新应用程序数据的类。'
- en: Even though the two layers seem to do more than one thing, all these actions
    define a broader dedicated responsibility that encapsulates a specific concern.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这两层似乎要做的事情不止一件，但所有这些行为定义了一个更广泛的专用责任，它封装了特定的关注点。
- en: In this chapter, while we will be mostly focusing on structuring the Presentation
    layer, we will also start working on the Model layer. We will continue refactoring
    the Model layer in [*Chapter 8*](B17788_08_ePub.xhtml#_idTextAnchor285), *Getting
    Started with Clean Architecture in Android*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，虽然我们将主要关注结构化表示层，但我们也将开始构建模型层。我们将在[*第8章*](B17788_08_ePub.xhtml#_idTextAnchor285)中继续重构模型层，*Android中的Clean
    Architecture入门*。
- en: To separate concerns within the Presentation layer, you can make use of presentation
    design patterns. **Presentation design patterns** are architectural patterns that
    define how the Presentation layer is structured in our applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在表示层内部分离关注点，你可以使用表示设计模式。**表示设计模式**是定义我们的应用程序中表示层结构的架构模式。
- en: 'The Presentation layer is a part of our project that is tied to what the user
    sees: the UI and the presentation of that UI. In other words, the Presentation
    layer handles two granular, yet related responsibilities associated with two types
    of logic, as outlined here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层是我们项目中与用户所见内容相关联的部分：UI及其表示。换句话说，表示层处理与两种类型逻辑相关的两个粒度细小但相关的责任，如下所述：
- en: '**UI logic**: Defines the ability to display content on a device in a specific
    way for one screen or flow. For example, when building an XML layout or a composable
    hierarchy for a screen, we''re defining the UI logic for that specific screen
    since we''re defining its UI elements.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI逻辑**：定义了在单个屏幕或流程中以特定方式显示内容的能力。例如，当为屏幕构建XML布局或组合层次结构时，我们正在定义该特定屏幕的UI逻辑，因为我们正在定义其UI元素。'
- en: '**Presentation logic**: The logic that defines the state of the UI (for one
    screen or flow) and how it mutates when the user interacts with our UI, therefore
    defining how the data is being presented to the UI. We''re writing presentation
    logic when, for example, we must do the following:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示逻辑**：定义UI（对于单个屏幕或流程）的状态以及当用户与我们的UI交互时如何变化，从而定义数据如何呈现给UI。当我们必须执行以下操作时，我们正在编写表示逻辑：'
- en: Ensure that the screen is in a loading state or error state at specific times
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保屏幕在特定时间处于加载状态或错误状态
- en: Present content for a screen in a specific manner by formatting it to some standards
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以特定方式格式化内容以呈现屏幕
- en: 'For the Presentation layer to define UI logic and presentation logic, it needs
    some data to work with. That''s why it must be connected to the Model layer, which
    provides it with raw data, be it from web services, local databases, or other
    sources. You can see an illustration of this in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义UI逻辑和表示逻辑，表示层需要一些数据来工作。这就是为什么它必须连接到模型层，模型层提供原始数据，无论是来自网络服务、本地数据库还是其他来源。以下图表展示了这一过程：
- en: '![Figure 7.1 – Composition of the Presentation layer and its relation to the
    Model layer'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 表示层及其与模型层的关系](img/B17788_07_1.jpg)'
- en: '](img/B17788_07_1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 表示层及其与模型层的关系](img/B17788_07_1.jpg)'
- en: Figure 7.1 – Composition of the Presentation layer and its relation to the Model
    layer
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 表示层及其与模型层的关系
- en: For now, we will consider the Model layer a black box that just provides us
    with data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将模型层视为一个黑盒，它只是为我们提供数据。
- en: We can say that such separations allow the UI to become a representation of
    the model's data through transformations that happen inside the Presentation layer
    while having components whose responsibilities don't overlap.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，这样的分离使得UI可以通过表示层内部发生的转换成为模型数据的表示，同时拥有责任不重叠的组件。
- en: 'In Android, transformations from within the Presentation layer are modeled
    through three popular presentation patterns that are used in other technology
    stacks as well, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，从表示层内部进行的转换是通过以下三种流行的表示模式来建模的，这些模式在其他技术堆栈中也被广泛使用：
- en: MVC
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC
- en: MVP
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVP
- en: MVVM
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: As Android developers, we have adjusted the implementation of these presentation
    patterns to the specific needs of Android. That's why the way we will exemplify
    or implement them may vary from their original definitions given by their founders—all
    this is in pursuit of observing their common usages in Android projects.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为 Android 开发者，我们已经调整了这些展示模式的实现，以适应 Android 的特定需求。这就是为什么我们展示或实现它们的方式可能与创始人给出的原始定义有所不同——所有这些都是为了观察它们在
    Android 项目中的常见用法。
- en: These presentation patterns will allow us to separate UI logic from presentation
    logic for each screen or flow within our app. By doing so, we are ensuring that
    our Presentation layer has less coupled code that is easier to maintain, easier
    to scale with new features, and easier to test.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些展示模式将使我们能够将每个屏幕或应用内流程的 UI 逻辑与展示逻辑分离。通过这样做，我们确保我们的表示层具有更少的耦合代码，更容易维护，更容易随着新功能扩展，更容易测试。
- en: Historically, most Android projects have transitioned from MVC to MVP and, nowadays,
    to MVVM. Regardless of their structure, though, it's important to mention that
    the SoC promoted by these presentation patterns often translates into each UI
    flow being broken into classes or components that are instructed to do something
    specific, tightly related to their responsibility.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，大多数 Android 项目已经从 MVC 转向 MVP，如今又转向 MVVM。然而，无论它们的结构如何，重要的是要提到，这些展示模式所推崇的
    SoC（分离关注点）通常意味着每个 UI 流程都被分解成执行特定任务的类或组件，这些组件与它们的职责紧密相关。
- en: To see what I'm talking about, let's briefly cover them, starting out with MVC.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我在说什么，让我们简要地介绍一下它们，从 MVC 开始。
- en: MVC
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC
- en: 'A common implementation in Android projects of the MVC pattern defines its
    layers like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 项目中，MVC 模式的常见实现定义其层如下：
- en: '**View**: Views inflated from the XML layouts as a representation of the UI.
    This layer would only be rendering the content it receives from the Controller
    onto the screen.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：从 XML 布局中填充的视图，作为 UI 的表示。这一层只会将控制器接收到的内容渲染到屏幕上。'
- en: '`Activity` or `Fragment`. This component would define the state of the UI by
    preparing data received from the Model layer for presentation, or by intercepting
    UI events that in turn would mutate the state. Additionally, the Controller would
    be in charge of setting actual data to the View layer.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity` 或 `Fragment`。这个组件将通过准备从模型层接收到的数据以供展示，或通过拦截 UI 事件（这些事件反过来会改变状态）来定义
    UI 的状态。此外，控制器将负责将实际数据设置到视图层。'
- en: '**Model**: The entry point of data. The actual structure doesn''t depend on
    MVC, but we can think of it as the layer that obtains content needed by the Presentation
    layer, by querying a local database or remote sources such as web **application
    programming interfaces** (**APIs**).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：数据的入口点。实际的结构不依赖于 MVC，但我们可以将其视为通过查询本地数据库或远程来源（如 Web **应用程序编程接口** (**API**)）获取所需内容的层。'
- en: 'Let''s visualize the actual separation brought by this pattern, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下方式可视化这种模式带来的实际分离：
- en: '![Figure 7.2 – Presentation layer in the MVC pattern'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – MVC 模式中的表示层'
- en: '](img/B17788_07_2.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_07_2.jpg)'
- en: Figure 7.2 – Presentation layer in the MVC pattern
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – MVC 模式中的表示层
- en: This implementation of the MVC pattern achieves a proper separation between
    the Presentation layer and the Model layer, therefore liberating `Activity` and
    `Fragment` controllers from being the ones that obtain data from **REpresentational
    State Transfer** (**REST**) APIs or local databases. Yet at least in this form
    factor, MVC doesn't shine where it should because the actual separation within
    the Presentation layer could be improved.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 MVC 模式的实现实现了表示层和模型层之间的适当分离，因此解放了 `Activity` 和 `Fragment` 控制器，不再需要它们从 **REpresentational
    State Transfer** (**REST**) API 或本地数据库中获取数据。然而，至少在这个形式因素中，MVC 并没有在它应该发光的地方发光，因为表示层内部的实际分离可以进一步改进。
- en: 'Disadvantages of this pattern may include the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点可能包括以下内容：
- en: High coupling between the Controller (`Activity` or `Fragment` controllers)
    and the View layer. Since the Controller is a component with a lifecycle and it
    also must provide the infrastructure of building and setting up Android views
    with content (such as building `Adapter` classes and passing data), testing it
    becomes difficult because it's tightly coupled with Android APIs.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器（`Activity` 或 `Fragment` 控制器）和视图层之间的高耦合。由于控制器是一个具有生命周期的组件，它还必须提供构建和设置 Android
    视图的基础设施，包括内容（如构建 `Adapter` 类和传递数据），因此测试它变得困难，因为它与 Android API 紧密耦合。
- en: 'The Controller has two responsibilities: it handles the state of the UI (presentation
    logic) while also providing infrastructure for the View layer to function (UI
    logic). The two responsibilities become tangled up—when testing one, you would
    be testing the other too.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器有两个职责：它处理UI的状态（表示逻辑），同时也为视图层提供基础设施以使其功能（UI逻辑）。这两个职责变得纠缠在一起——当你测试其中一个时，你也会测试另一个。
- en: Let's move on to another popular presentation pattern in Android.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨Android中另一种流行的表示模式。
- en: MVP
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP
- en: 'A common implementation in Android projects of the MVP pattern defines its
    layers like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Android项目中MVP模式的一种常见实现定义其层如下：
- en: '`Activity` or `Fragment` class and their corresponding inflated views from
    XML. This layer now encapsulates the entire UI logic: it provides the infrastructure
    of building and setting up rendered Android views with content.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity`或`Fragment`类及其从XML中膨胀的视图。这一层现在封装了整个UI逻辑：它提供了构建和设置渲染Android视图的基础设施，并包含内容。'
- en: '`Activity` or `Fragment`) is established. The interface allows the Presenter
    to pass data that is ready for presentation to the UI layer and to directly mutate
    the UI state at the UI level.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity`或`Fragment`）被建立。该接口允许表示者将准备好的用于表示的数据传递给UI层，并在UI级别直接修改UI状态。'
- en: Unlike the Controller in MVC, the Presenter is no longer coupled to lifecycle
    components or Android View APIs, so it becomes much easier to test the presentation
    logic that it contains.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与MVC中的控制器不同，表示者不再与生命周期组件或Android View API耦合，因此测试它包含的表示逻辑变得更加容易。
- en: '**Model**: The same as in MVC.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：与MVC中的相同。'
- en: 'Let''s visualize the actual separation brought by this pattern, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化这种模式带来的实际分离，如下所示：
- en: '![Figure 7.3 – Presentation layer in the MVP pattern'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – MVP模式中的表示层'
- en: '](img/B17788_07_3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_07_3.jpg)'
- en: Figure 7.3 – Presentation layer in the MVP pattern
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – MVP模式中的表示层
- en: Unlike MVC, `Activity` and `Fragment` are now part of the View layer, which
    seems more natural because they are both tightly related to the Android UI. This
    approach allows the Presenter to be the one that prepares data that must be presented,
    while imperatively mutating the UI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与MVC不同，`Activity`和`Fragment`现在是视图层的一部分，这看起来更自然，因为它们都与Android UI紧密相关。这种方法允许表示者准备必须表示的数据，并命令式地修改UI。
- en: Since we now have a separate entity that is in charge of presenting data to
    the UI, we can say that, unlike MVC, MVP performs the SoC inside the Presentation
    layer somewhat better.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有一个负责向UI表示数据的独立实体，我们可以说，与MVC不同，MVP在表示层内部执行SoC（分离关注点）做得更好。
- en: 'However, there are still some issues with this approach, as outlined here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法仍然存在一些问题，如下所述：
- en: The imperative approach of having the Presenter manually update the UI directly
    in the `Activity` or `Fragment` class can be prone to bugs and can cause illegal
    UI states (such as showing an error message and a loading status at the same time)
    as a project grows and new features are added. This is similar to how a UI controller
    (such as `Activity`) also imperatively mutates XML views—an approach that we deemed
    as prone to issues when we introduced Compose with its declarative paradigm.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示者手动直接在`Activity`或`Fragment`类中更新UI的命令式方法可能会随着项目的增长和新功能的添加而容易出错，并可能导致非法UI状态（例如同时显示错误信息和加载状态）。这与UI控制器（如`Activity`）也命令式地修改XML视图的方法类似——当我们引入具有声明性范式的Compose时，我们认为这种方法容易出问题。
- en: If the interface contract between the Presenter and the View layer is not well
    designed or is missing entirely, the two would become coupled, and reusing the
    Presenter for other `Activity` or `Fragment` controllers might be difficult.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表示层和视图层之间的接口合同设计不当或完全缺失，两者将变得耦合，为其他`Activity`或`Fragment`控制器重用表示者可能会很困难。
- en: Let's move on to another important presentation pattern.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨另一种重要的表示模式。
- en: MVVM
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM
- en: MVVM is a very popular presentation pattern in Android, mostly because it addresses
    the concerns stated with the previously mentioned implementation of MVP.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM是Android中非常流行的一种表示模式，主要是因为它解决了之前提到的MVP实现中提到的问题。
- en: 'A common implementation in Android projects of MVVM defines its layers like
    so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Android项目中MVVM的一种常见实现定义其层如下：
- en: '![Figure 7.4 – Presentation layer in the MVVM pattern'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – MVVM模式中的表示层'
- en: '](img/B17788_07_4.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_07_4.jpg)'
- en: Figure 7.4 – Presentation layer in the MVVM pattern
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – MVVM模式中的表示层
- en: 'Let''s look at how the layers are defined:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看层是如何定义的：
- en: '`Activity` or `Fragment` class and its XML views, just as in MVP. Unlike in
    MVP, though, the View layer observes either an observable state or observable
    fields from the `ViewModel`, both containing UI data. Whenever new updates are
    received from those observable entities, the View layer updates the UI with the
    content received.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity`或`Fragment`类及其XML视图，就像在MVP中一样。不过，与MVP不同的是，视图层观察来自`ViewModel`的可观察状态或可观察字段，两者都包含UI数据。每当从这些可观察实体接收到新更新时，视图层就会使用接收到的内容更新UI。'
- en: '`ViewModel` defines the UI state as an observable property (or multiple observable
    fields) and is totally decoupled from the View layer as it has no reference to
    it.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`将UI状态定义为可观察属性（或多个可观察字段），并且与视图层完全解耦，因为它没有对其的引用。'
- en: '**Model**: The same as in MVC or MVP.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：与MVC或MVP相同。'
- en: One advantage of the `ViewModel`, as opposed to the Presenter in MVP, is that
    it's no longer coupled to the View layer, so it can be reused much more easily.
    In contrast with MVP, the View layer is responsible for referencing the `ViewModel`
    for obtaining and observing the observable state, and so the `ViewModel` no longer
    needs to reference the View layer, becoming totally independent.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与MVP中的Presenter相比，`ViewModel`的一个优点是它不再与视图层耦合，因此可以更容易地重用。与MVP相比，视图层负责引用`ViewModel`以获取和观察可观察状态，因此`ViewModel`不再需要引用视图层，变得完全独立。
- en: In other words, the `ViewModel` in MVVM forces the View layer to subscribe to
    data, which is different from MVP, where the Presenter was manually setting up
    the View layer with data. This approach allows multiple Views to bind to the same
    `ViewModel`, therefore *sharing* the same UI state within the same `ViewModel`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，MVVM中的`ViewModel`强制视图层订阅数据，这与MVP不同，在MVP中，Presenter手动设置视图层与数据。这种方法允许多个视图绑定到同一个`ViewModel`，因此在同一`ViewModel`内*共享*相同的UI状态。
- en: Another advantage is that since the View layer observes the UI state from the
    `ViewModel` and binds the received data as an effect, the `ViewModel` doesn't
    imperatively update the UI as the Presenter did through an interface in MVP. In
    other words, the View layer obtains the UI state from the `ViewModel` and binds
    it to the UI—this results in a unidirectional flow of data that is less likely
    to introduce bugs or illegal states.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，由于视图层从`ViewModel`观察UI状态并将其作为效果绑定，`ViewModel`不再像MVP中的Presenter那样通过接口强制更新UI。换句话说，视图层从`ViewModel`获取UI状态并将其绑定到UI——这导致数据流向单向，不太可能引入错误或非法状态。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While considering the original definition of MVVM, the ViewModel shouldn't be
    confused with the Jetpack ViewModel component—the ViewModel can be a simple class
    that presents the data through an observable state. For us on Android, though,
    it's convenient to consider the Jetpack ViewModel as the actual ViewModel from
    MVVM because it brings some advantages out of the box.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑MVVM的原始定义时，不应将ViewModel与Jetpack ViewModel组件混淆——ViewModel可以是一个简单的类，通过可观察状态来呈现数据。对于我们来说，然而，将Jetpack
    ViewModel视为MVVM的实际ViewModel是方便的，因为它带来了一些即开即用的优点。
- en: However, the pattern's implementation that is commonly used in Android considers
    the Jetpack ViewModel as the ViewModel from MVVM, and this brings both a set of
    advantages and disadvantages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Android中常用模式实现中，将Jetpack ViewModel视为MVVM中的ViewModel，这既带来了一系列优点，也带来了一些缺点。
- en: 'Using the Jetpack ViewModel as the `ViewModel` from MVVM is beneficial for
    the following reasons:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jetpack ViewModel作为MVVM中的`ViewModel`有以下好处：
- en: The Jetpack ViewModel is scoped to the lifetime of the View and provides convenient
    APIs for canceling work such as the `onCleared()` callback or the `viewModelScope`
    coroutine scope, therefore providing a convenient API for canceling asynchronous
    jobs and minimizing the risk of memory leaks.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack ViewModel的作用域与View的生命周期相同，并提供方便的API来取消工作，例如`onCleared()`回调或`viewModelScope`协程作用域，因此提供了一个方便的API来取消异步任务并最小化内存泄漏的风险。
- en: The Jetpack ViewModel survives configuration changes, therefore allowing you
    to preserve the UI state automatically if the user changes the orientation of
    the device, for example.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack ViewModel能够存活于配置更改中，因此允许你在用户更改设备方向等情况下自动保留UI状态。
- en: You can easily restore the UI state after system-initiated process death because
    the Jetpack ViewModel is providing us with a `SavedStateHandle` object.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Jetpack ViewModel提供了`SavedStateHandle`对象，你可以轻松地在系统启动的进程死亡后恢复UI状态。
- en: 'Unfortunately, this approach comes with the following downsides:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法存在以下缺点：
- en: The `ViewModel` is now a library dependency (the Jetpack ViewModel) that introduces
    coupling with the Android platform (as it exposes APIs such as `SavedStateHandle`).
    This prevents us from reusing presentation components for cross-platform projects
    with **Kotlin Multiplatform** (**KMP**).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，`ViewModel`已经成为一个库依赖（Jetpack ViewModel），它引入了与Android平台的耦合（因为它暴露了如`SavedStateHandle`之类的API）。这阻止了我们为跨平台项目使用**Kotlin
    Multiplatform**（**KMP**）重用表示组件。
- en: Because the Jetpack ViewModel is a library dependency that handles other responsibilities
    apart from data presentation, such as restoring the UI state after system-initiated
    process death, we could argue that the Presentation layer concerns are not very
    well separated.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Jetpack ViewModel是一个除了数据表示之外还处理其他责任的库依赖，例如在系统启动进程死亡后恢复UI状态，我们可以认为表示层的关注点并没有很好地分离。
- en: Now that we have had a quick overview of presentation patterns, it's time for
    a practical example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对表示模式有了快速的了解，是时候来一个实际例子了。
- en: Refactoring our Restaurants app to fit a presentation pattern
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的餐厅应用程序重构以适应表示模式
- en: We plan to refactor our Restaurants app to fit a presentation pattern. From
    our previous comparison, we can consider that MVVM is best suited for our Compose-based
    app. Don't worry—we will talk about this decision in more detail a bit later.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划将我们的餐厅应用程序重构以适应表示模式。从我们之前的比较中，我们可以认为MVVM最适合我们的基于Compose的应用程序。不用担心——我们稍后会详细讨论这个决定。
- en: But before we do that, let's add more functionality inside the application to
    better highlight how mingling responsibilities can lead to unmaintainable code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，让我们在应用程序中添加更多功能，以更好地突出责任混合可能导致代码难以维护。
- en: 'To summarize, in this section, we''re going to be doing the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们将进行以下操作：
- en: Adding more functionality inside our Restaurants app
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的餐厅应用程序中添加更多功能
- en: Refactoring our Restaurants app to MVVM
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的餐厅应用程序重构为MVVM
- en: Let's begin!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Adding more functionality inside our Restaurants app
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的餐厅应用程序中添加更多功能
- en: When the Restaurants application is launched, the `RestaurantsScreen()` composable
    is rendered. Inside this screen, we are loading a bunch of restaurants from the
    server, and then we're displaying them to the user.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当餐厅应用程序启动时，`RestaurantsScreen()`可组合组件被渲染。在这个屏幕内部，我们正在从服务器加载一系列餐厅，然后我们将它们展示给用户。
- en: Yet while our app waits for the network request to finish and for the local
    caching to Room to happen (in order for it to receive restaurants for the UI),
    the screen remains blank, and the user has no idea what's going on. To provide
    a better **user experience** (**UX**), we should somehow suggest to the user the
    fact that we're waiting for content from the server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序正在等待网络请求完成以及本地缓存到Room的操作（以便它能够为UI接收餐厅信息），但屏幕仍然保持空白，用户对正在发生的事情一无所知。为了提供更好的**用户体验**（**UX**），我们应该以某种方式向用户暗示我们正在等待从服务器获取内容。
- en: We could do that through a loading progress bar! Inside the `RestaurantsScreen()`
    composable, we could add a loading UI element that is displayed until the `LazyColumn`
    composable that renders a list of restaurants is populated. When the content arrives,
    we should hide it, thereby letting the user know that the application has loaded
    its content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个加载进度条来实现这一点！在`RestaurantsScreen()`可组合组件内部，我们可以添加一个在`LazyColumn`可组合组件（渲染餐厅列表）填充之前显示的加载UI元素。当内容到达时，我们应该隐藏它，从而让用户知道应用程序已经加载了其内容。
- en: 'Let''s do that right now, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即按照以下方式执行：
- en: 'First, inside the `RestaurantsScreen()` composable, save the restaurant list
    from the state (retrieved from `RestaurantsViewModel`) inside a `restaurants`
    variable, like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsScreen()`可组合组件内部，将状态中的餐厅列表（从`RestaurantsViewModel`检索）保存到`restaurants`变量中，如下所示：
- en: '[PRE0]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure to also pass the `restaurants` variable to the `LazyColumn` composable's
    `items` **domain-specific language** (**DSL**) function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确保还将`restaurants`变量传递给`LazyColumn`可组合组件的`items`**领域特定语言**（**DSL**）函数。
- en: 'We need to define a condition that lets us know when to show a loading indicator.
    As a first attempt, we could say that when the `restaurants` variable contains
    an empty `List<Restaurant>` as a value, which means that restaurants haven''t
    arrived yet, the content is still loading. Add an `isLoading` variable that accounts
    for this, as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义一个条件，让我们知道何时显示加载指示器。作为一个初步尝试，我们可以说当 `restaurants` 变量包含一个空的 `List<Restaurant>`
    作为值时，这意味着餐厅尚未到达，内容仍在加载。添加一个 `isLoading` 变量来考虑这一点，如下所示：
- en: '[PRE1]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If, however, restaurants arrive from the server, the `state` variable is updated,
    and the `restaurants` variable no longer contains an empty list of restaurants.
    At this point, the `isLoading` variable becomes `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果餐厅从服务器到达，`state` 变量将被更新，并且 `restaurants` 变量不再包含空的餐厅列表。此时，`isLoading` 变量变为
    `false`。
- en: 'We want to display a loading indicator while the `isLoading` variable is `true`.
    To do that, wrap the `LazyColumn` composable in a `Box` composable, and below
    the `LazyColumn` code, check if the `isLoading` variable is `true` and pass a
    `CircularProgressIndicator` composable. The code is illustrated in the following
    snippet:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在 `isLoading` 变量为 `true` 时显示加载指示器。要做到这一点，将 `LazyColumn` 可组合组件包裹在一个 `Box`
    可组合组件中，并在 `LazyColumn` 代码下方检查 `isLoading` 变量是否为 `true`，并传递一个 `CircularProgressIndicator`
    可组合组件。代码如下所示：
- en: '[PRE2]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Box` composable allows us to overlay two composables: `LazyColumn` and
    `CircularProgressIndicator`. Because of the `if` condition that we''ve added,
    we now have the following two cases:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box` 可组合组件允许我们叠加两个可组合组件：`LazyColumn` 和 `CircularProgressIndicator`。由于我们添加了
    `if` 条件，我们现在有以下两种情况：'
- en: '`isLoading` is `true` (the app is waiting for restaurants), so both composables
    are composed. While the `CircularProgressIndicator` composable is displayed on
    top of the `LazyColumn` composable, the `LazyColumn` composable contains no elements,
    so it''s not visible.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading` 为 `true`（应用正在等待餐厅），因此两个可组合组件都被组合。当 `CircularProgressIndicator`
    可组合组件显示在 `LazyColumn` 可组合组件之上时，`LazyColumn` 可组合组件不包含任何元素，因此不可见。'
- en: '`isLoading` is `false` (the app now has restaurants to display), so only the
    `LazyColumn` composable is composed and visible.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading` 为 `false`（应用现在有要显示的餐厅），因此只有 `LazyColumn` 可组合组件被组合并可见。'
- en: 'To center the `CircularProgressIndicator` composable, add the `Alignment.Center`
    alignment to the `contentAlignment` parameter of the `Box` composable, while also
    passing a `Modifier.fillMaxSize()` modifier. The code is illustrated in the following
    snippet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使 `CircularProgressIndicator` 可组合组件居中，请将 `Alignment.Center` 对齐方式添加到 `Box` 可组合组件的
    `contentAlignment` 参数中，同时传递一个 `Modifier.fillMaxSize()` 修饰符。代码如下所示：
- en: '[PRE3]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Build and run the app. For a moment (until restaurants are loaded), you should
    see a loading progress indicator. When restaurants are displayed, this should
    go away.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。在一段时间内（直到餐厅加载完成），你应该看到一个加载进度指示器。当餐厅显示时，这个指示器应该消失。
- en: Inside the UI layer, we have now added a loading indicator as well as the logic
    that decides when to display it. In this simple scenario, our logic works, but
    what happens if the server (or local database) returns an empty list of restaurants?
    Then the loading indicator will never go away.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 层中，我们现在已经添加了加载指示器以及决定何时显示它的逻辑。在这个简单场景中，我们的逻辑是有效的，但如果服务器（或本地数据库）返回一个空的餐厅列表，会发生什么呢？那么加载指示器将永远不会消失。
- en: Or, what happens if an error occurs? Our `RestaurantsScreen` composable has
    no idea that an error was generated. This means that not only does it not know
    when to display the error, but it also doesn't know when to hide the loading indicator
    if such an error were to occur.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果发生错误会发生什么？我们的 `RestaurantsScreen` 可组合组件并不知道错误已被生成。这意味着它不仅不知道何时显示错误，而且也不知道如果发生此类错误，何时隐藏加载指示器。
- en: These issues arise from the fact that we're trying to define presentation logic
    (when to show or hide a loading indicator; when to show an error message) inside
    the UI layer (where composables reside), thereby mixing UI logic with presentation
    logic.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题源于我们试图在 UI 层（可组合组件所在之处）中定义展示逻辑（何时显示或隐藏加载指示器；何时显示错误消息），从而将 UI 逻辑与展示逻辑混合在一起。
- en: 'We can now see just some limitations that derive from mixing UI logic with
    presentation logic, yet there''s also the fact that in the previous chapters,
    we''ve mixed the presentation logic with the data logic. The long-term implications
    for our current approach are scary: debugging will be difficult, and testing even
    more so.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到一些由将 UI 逻辑与展示逻辑混合而产生的限制，但还有一个事实是，在前几章中，我们已经将展示逻辑与数据逻辑混合了。我们当前方法的长远影响是令人恐惧的：调试将变得困难，测试更是如此。
- en: It's time to refactor our Restaurants app to MVVM so that we can better separate
    its responsibilities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候重构我们的餐厅应用为 MVVM，以便我们更好地分离其职责。
- en: Refactoring our Restaurants app to MVVM
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构我们的餐厅应用为 MVVM
- en: 'To better separate responsibilities, we will choose the most popular presentation
    pattern: MVVM. Despite its flaws, when you compare it to MVC and MVP following
    the definition we previously gave them, it''s the best candidate so far for the
    following reasons:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地分离职责，我们将选择最流行的展示模式：MVVM。尽管它有缺陷，但当你将其与我们之前给出的 MVC 和 MVP 定义进行比较时，它目前是最佳候选人，以下是一些原因：
- en: It provides a pretty good separation between the UI logic and the presentation
    logic.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在 UI 逻辑和展示逻辑之间提供了很好的分离。
- en: Our UI layer (the composables) is designed to expect an observable state (more
    precisely, the Compose `State` object), just like the one the `ViewModel` in MVVM
    is set to expose.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 UI 层（可组合组件）被设计成期望一个可观察的状态（更确切地说，是 Compose `State` 对象），就像 MVVM 中的 `ViewModel`
    被设置为暴露的那样。
- en: Now, our Restaurants app already uses the Jetpack ViewModel (that exposes a
    Compose `State` object that is observed and consumed inside the composables),
    so we can say that we unknowingly started implementing this modified version of
    the pattern, whereby the Jetpack ViewModel is the ViewModel from MVVM.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的餐厅应用已经使用了 Jetpack ViewModel（它暴露了一个 Compose `State` 对象，该对象在可组合组件内部被观察和消费），因此我们可以这样说，我们不知不觉地开始实现这个修改后的模式，其中
    Jetpack ViewModel 是 MVVM 中的 ViewModel。
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will consider for now that the advantages of using the Jetpack ViewModel
    as the `ViewModel` in MVVM are outweighing the disadvantages that it brings, so
    we will keep it as it is.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们认为使用 Jetpack ViewModel 作为 MVVM 中的 `ViewModel` 的优点超过了它带来的缺点，因此我们将保持现状。
- en: 'However, just because we used a `ViewModel`, that doesn''t mean we also implemented
    the MVVM presentation pattern correctly. Let''s first have a look at how we structured
    our components and classes for the first screen displaying a list of restaurants.
    You can see how this looks here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为我们使用了 `ViewModel`，并不意味着我们也正确实现了 MVVM 展示模式。让我们首先看看我们如何为显示餐厅列表的第一个屏幕构建组件和类。你可以看到这里的样子：
- en: '![Figure 7.5 – Components with poorly separated responsibilities per layer
    in the MVVM pattern'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – MVVM 模式中每层组件职责分离不良]'
- en: '](img/B17788_07_5.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_07_5.jpg]'
- en: Figure 7.5 – Components with poorly separated responsibilities per layer in
    the MVVM pattern
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – MVVM 模式中每层组件职责分离不良
- en: 'For this screen, we notice two violations where layers contain more than one
    responsibility, as outlined here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个屏幕，我们注意到两个违反规则的地方，即层包含超过一个职责，如下所述：
- en: 'The View layer (represented by the `RestaurantsScreen()` composable) performs
    both UI logic and presentation logic. While this composable should only contain
    UI logic (the stateless composables that consume the state content), some presentation
    logic lurked in when the `isLoading` variable was calculated, as illustrated in
    the following code snippet:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图层（由 `RestaurantsScreen()` 可组合组件表示）执行 UI 逻辑和展示逻辑。虽然这个可组合组件应该只包含 UI 逻辑（消费状态内容的无状态可组合组件），但当计算
    `isLoading` 变量时，一些展示逻辑隐藏在其中，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The composables shouldn't be in charge of deciding their own state as in this
    case—the `RestaurantsScreen()` composable shouldn't hold presentation logic; instead,
    this should be moved inside the `ViewModel`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合组件不应该负责决定它们自己的状态，就像在这个案例中——`RestaurantsScreen()` 可组合组件不应该持有展示逻辑；相反，这应该移动到
    `ViewModel` 内部。
- en: 'The `RestaurantsViewModel` class contains both presentation logic (such as
    holding and updating the state of the UI) and data logic (as it works with the
    Retrofit service Room **Data Access Object** (**DAO**) when it obtains and caches
    restaurants), as illustrated in the following code snippet:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RestaurantsViewModel` 类包含展示逻辑（例如，持有和更新 UI 的状态）和数据逻辑（因为它在获取和缓存餐厅时与 Retrofit
    服务 Room **数据访问对象**（**DAO**）一起工作），如下面的代码片段所示：'
- en: '[PRE5]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's clear that presentation logic occurs when the `state` variable is updated,
    but there's also a lot of data logic when restaurants are obtained from the `restInterface`
    variable, then cached and updated in the `restaurantsDao` variable, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，当 `state` 变量更新时会发生表示逻辑，但还有大量的数据逻辑，当从 `restInterface` 变量获取餐厅信息，然后将其缓存在 `restaurantsDao`
    变量中，等等。
- en: All this data logic shouldn't reside inside the `ViewModel` but instead inside
    the Model layer because the `ViewModel` should only present the data and not care
    to know about the data sources and how they are used—it only knows that it should
    receive some data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据逻辑不应位于 `ViewModel` 内部，而应位于模型层，因为 `ViewModel` 应仅呈现数据，而不关心数据源及其使用方式——它只知道它应该接收一些数据。
- en: 'Now, let''s have a look at how we should correctly structure our classes (to
    follow MVVM) for the first flow of displaying a list of restaurants. The components
    should look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们应该如何正确地构建我们的类（遵循 MVVM）以显示餐厅列表的第一流程。组件应该看起来像这样：
- en: '![Figure 7.6 – Components with well-separated responsibilities per layer in
    the MVVM pattern'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – MVVM 模式中每层具有良好分离责任的组件'
- en: '](img/B17788_07_6.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_07_6.jpg)'
- en: Figure 7.6 – Components with well-separated responsibilities per layer in the
    MVVM pattern
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – MVVM 模式中每层具有良好分离责任的组件
- en: 'In the previous diagram, each component handles its own responsibility, as
    follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，每个组件都处理自己的责任，如下所示：
- en: The View component contains only composables (`RestaurantsScreen`) with UI logic
    (consuming the UI state).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: View 组件仅包含具有 UI 逻辑的可组合项（`RestaurantsScreen`）（消费 UI 状态）。
- en: The ViewModel component (`RestaurantsViewModel`) contains only presentation
    logic (holds the UI state and mutates it).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModel 组件（`RestaurantsViewModel`）仅包含表示逻辑（持有 UI 状态并对其进行修改）。
- en: The Model component (where we will create a `RestaurantsRepository` class—more
    on that soon) contains only data logic (obtains restaurants from remote sources,
    caches them into a local source, and so on).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型组件（我们将创建一个 `RestaurantsRepository` 类——稍后会更详细地介绍）仅包含数据逻辑（从远程源获取餐厅信息，将其缓存在本地源中等）。
- en: 'To achieve this separation, in this section, we will be doing the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种分离，在本节中，我们将执行以下操作：
- en: Separating UI logic from presentation logic
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 UI 逻辑与表示逻辑分离
- en: Separating presentation logic from data logic
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表示逻辑与数据逻辑分离
- en: Let's start!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Separating UI logic from presentation logic
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 UI 逻辑与表示逻辑分离
- en: The UI logic (rendering composables) is already at the UI level (Compose UI),
    so we don't have to do anything from this point of view. However, we need to extract
    the presentation logic from the UI layer to the `ViewModel`, where it should reside.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: UI 逻辑（渲染可组合项）已经在 UI 层（Compose UI）中，因此我们从这个角度来看不需要做任何事情。然而，我们需要将表示逻辑从 UI 层提取到
    `ViewModel` 中，那里应该是它的位置。
- en: More specifically, from within the `RestaurantsScreen()` composable, we want
    to move the calculation of the `isLoading` variable to the `RestaurantsViewModel`
    class, simply because the `ViewModel` should decide and also know better when
    the screen should be in a loading state.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，从 `RestaurantsScreen()` 可组合项内部，我们希望将 `isLoading` 变量的计算移动到 `RestaurantsViewModel`
    类中，仅仅因为 `ViewModel` 应该决定并且更清楚地知道屏幕何时应该处于加载状态。
- en: 'To do that, we will create a `state` class that will hold all the information
    the UI needs in order to render the correct state. This approach is much more
    efficient because the `ViewModel` is responsible for requesting data and therefore
    knows better when content arrives, and so on. Because of this, later on, it will
    be very simple for us to also allow the `ViewModel` to also dictate when the screen
    must show an error state. Proceed as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个 `state` 类，它将保存 UI 需要的所有信息，以便渲染正确的状态。这种方法更有效率，因为 `ViewModel`
    负责请求数据，因此更清楚地知道何时内容到达等。因此，稍后我们将非常容易地允许 `ViewModel` 决定屏幕何时必须显示错误状态。按照以下步骤进行操作：
- en: 'Create a class that will model the UI state for the `RestaurantsScreen()` composable.
    Do that by clicking on the application package, selecting `RestaurantsScreenState`
    as the name and select `restaurants` list, and an `isLoading` flag. The code is
    illustrated in the following snippet:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将模拟 `RestaurantsScreen()` 可组合的 UI 状态的类。通过点击应用程序包，将 `RestaurantsScreenState`
    作为名称，并选择 `restaurants` 列表和 `isLoading` 标志。以下代码片段展示了这一过程：
- en: '[PRE6]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we've used a `data class` instead of a regular `class`, we will be able
    to easily perform mutation on this object with the `.copy()` function, thereby
    ensuring that since the Compose `state` object will receive a new object, it will
    know to trigger recomposition.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`data class`而不是常规的`class`，我们将能够轻松地使用`.copy()`函数对这个对象进行修改，从而确保Compose的`state`对象将接收到一个新的对象，并知道触发重新组合。
- en: 'Inside the `RestaurantsViewModel` class, update the initial state value of
    the `state` variable and pass a `RestaurantsScreenState` object, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`类中，更新`state`变量的初始状态值并传递一个`RestaurantsScreenState`对象，如下所示：
- en: '[PRE7]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've marked the `restaurants` field as an empty list, and `isLoading` is `true`
    because from this point on, we're waiting for restaurants and the UI should render
    a loading state.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`restaurants`字段标记为空列表，并且`isLoading`为`true`，因为从这一点开始，我们正在等待餐厅信息，UI应该渲染加载状态。
- en: 'Still inside the `RestaurantsViewModel` class, find the `getRestaurants()`
    method and update the way we update the `state` variable, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`RestaurantsViewModel`类中，找到`getRestaurants()`方法并更新我们更新`state`变量的方式，如下所示：
- en: '[PRE8]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We first stored restaurants inside a `restaurants` variable. Then, we used the
    `copy()` function to pass a new restaurants list that we received to the `restaurants`
    field, and also marked the `isLoading` field to `false` because the data has arrived
    and the UI should no longer render a loading state.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将餐厅信息存储在`restaurants`变量中。然后，我们使用`copy()`函数将接收到的新的餐厅列表传递给`restaurants`字段，并将`isLoading`字段标记为`false`，因为数据已经到达，UI不再需要渲染加载状态。
- en: 'Still in the `RestaurantsViewModel` class, make sure that the `toggleFavorite()`
    method is correctly updating the `state` variable object using the `copy()` function,
    as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`RestaurantsViewModel`类中，确保`toggleFavorite()`方法正确地使用`copy()`函数更新`state`变量对象，如下所示：
- en: '[PRE9]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All right—we've added all the presentation logic within the `ViewModel`, and
    it's now time to update the UI (our composables) to render new possible UI states.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 好了——我们已经在`ViewModel`中添加了所有的展示逻辑，现在是时候更新UI（我们的composables）以渲染新的可能的UI状态。
- en: 'Refactor the `RestaurantsScreen()` composable to consume the new UI state content,
    as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构`RestaurantsScreen()` composable以消费新的UI状态内容，如下所示：
- en: '[PRE10]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down what we''ve done, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们所做的工作，如下所示：
- en: We renamed the `restaurants` variable as `state` to better suggest that this
    variable holds the state of this screen.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`restaurants`变量重命名为`state`，以更好地表明这个变量持有这个屏幕的状态。
- en: We passed `state.restaurants` to the `LazyColumn` composable's `items` DSL function.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`state.restaurants`传递给`LazyColumn` composable的`items` DSL函数。
- en: 'We deleted this line: `val isLoading = restaurants.isEmpty()`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们删除了这一行：`val isLoading = restaurants.isEmpty()`。
- en: We updated the condition for when to show `CircularProgressIndicator()` based
    on the `state.isLoading` value—no more decision-making logic inside this composable.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根据`state.isLoading`的值更新了显示`CircularProgressIndicator()`的条件——在这个composable中不再需要决策逻辑。
- en: Build and run the app.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。
- en: You should be able to see the loading indicator, just as before, yet the difference
    is that the presentation logic is better separated and held by the `ViewModel`.
    With our new approach, if for any reason we receive an empty list from our data
    sources (Retrofit and Room), the application won't misbehave and show a loading
    state because the UI is checking whether the list is empty or not.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够看到加载指示器，就像之前一样，但不同之处在于展示逻辑更好地分离并由`ViewModel`持有。使用我们的新方法，如果出于任何原因我们从数据源（Retrofit和Room）收到空列表，应用程序不会表现不佳并显示加载状态，因为UI正在检查列表是否为空。
- en: To see how simple it is to add a new state to our Compose-based UI, let's continue
    by setting an error state when any error is thrown inside the `ViewModel`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何简单地向我们的Compose-based UI添加新状态，让我们继续设置在`ViewModel`内部抛出任何错误时的错误状态。
- en: 'Inside the `RestaurantsScreenState` class, add an `error: String` parameter
    that will hold an error message if any error occurs, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`RestaurantsScreenState`类中，添加一个`error: String`参数，用于存储可能发生的错误信息，如下所示：'
- en: '[PRE11]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To simplify our work with state handling inside the `ViewModel`, we've set a
    default value of `null` to the `error` field, since the initial state of the screen
    shouldn't ever contain an error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们在`ViewModel`内部处理状态的工作，我们将`error`字段的默认值设置为`null`，因为屏幕的初始状态不应该包含任何错误。
- en: 'Inside the `RestaurantsViewModel` class, find the `errorHandler` variable that
    we use to catch any exception that might be thrown by our coroutines, and update
    the `state` object by passing an `exception.message` error message to the `error`
    field. The code is illustrated in the following snippet:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`类中，找到我们用来捕获可能由我们的协程抛出的任何异常的`errorHandler`变量，并通过传递`exception.message`错误消息到`error`字段来更新`state`对象。代码如下所示：
- en: '[PRE12]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Additionally, we've set the `isLoading` field to `false` on the new state simply
    because if an error is thrown, we don't want the UI to be in a loading state.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已将新状态中的`isLoading`字段设置为`false`，仅仅是因为如果抛出错误，我们不想让UI保持在加载状态。
- en: If, however, you want to add a retry button that is pressed after an error has
    occurred and was shown, you would have to set the `error` field to `null` when
    that button is pressed so that the UI won't remain in an error state indefinitely.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在错误发生后显示并按下重试按钮，您必须在按下该按钮时将`error`字段设置为`null`，这样UI就不会无限期地保持在错误状态。
- en: 'Inside the `RestaurantsScreen()` composable, add another `if` statement in
    the `Box` composable. This statement checks whether the `state` object contains
    an error message to be shown, and if that is `true`, add a `Text` composable that
    will display the error message. The code is illustrated in the following snippet:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen()`可组合函数中，在`Box`可组合函数内添加另一个`if`语句。此语句检查`state`对象是否包含要显示的错误消息，如果是`true`，则添加一个`Text`可组合函数来显示错误消息。代码如下所示：
- en: '[PRE13]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Build the project, and now, let's test the error scenario. Yet to see the error
    message, we need to simulate an error.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目，现在，让我们测试错误场景。要看到错误消息，我们需要模拟一个错误。
- en: 'If you remember, inside our `RestaurantsViewModel` class''s `getAllRestaurants()`
    method, we check if we failed in retrieving restaurants from the server (Retrofit
    client), and if this happens while the Room DAO is also empty, we throw this error
    message: `"Something went wrong. We have no data."`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在我们的`RestaurantsViewModel`类的`getAllRestaurants()`方法中，我们检查是否从服务器（Retrofit客户端）检索餐厅失败，并且如果Room
    DAO也为空，我们抛出此错误消息：“出了点问题。我们没有数据。”
- en: 'To reproduce this scenario, make sure that the following applies:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重现此场景，请确保以下条件成立：
- en: You have cleared the cache of the application. To do that, inside your device
    or emulator, go to **Settings**, then **Applications**, and search for our Restaurants
    app and press on it. Then, press **Storage and Cache** and then **Clear Storage**.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已清除应用程序的缓存。为此，在您的设备或模拟器中，进入**设置**，然后进入**应用程序**，搜索我们的餐厅应用并点击它。然后，点击**存储和缓存**，然后点击**清除存储**。
- en: Your device/emulator is disconnected from the internet.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的设备/模拟器已断开互联网连接。
- en: 'Run the application. You should see this message in the center of the screen:
    `"Something went wrong. We have no data."`.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您应该在屏幕中央看到此消息：“出了点问题。我们没有数据。”
- en: Note
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, we made sure that the UI logic is separated from
    the presentation logic only within the first screen of our app. When you're looking
    to move logic to corresponding classes, thereby ensuring SoC, you need to make
    sure to do so for all other screens within the app, together with their `ViewModel`
    classes, and so on.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化，我们确保UI逻辑仅在我们应用程序的第一个屏幕中与展示逻辑分离。当您想要将逻辑移动到相应的类中，从而确保SoC时，您需要确保为应用程序中的所有其他屏幕以及它们的`ViewModel`类等执行此操作。
- en: Now that we've separated UI logic from presentation logic, it's time to separate
    some data logic.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将UI逻辑与展示逻辑分离，是时候分离一些数据逻辑了。
- en: Separating presentation logic from data logic
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离展示逻辑和数据逻辑
- en: While the `RestaurantsViewModel` class contains data logic because it interacts
    with the Retrofit service and the Room DAO to obtain and cache restaurants, it
    should only hold presentation logic because its core responsibility is to govern
    the UI state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`RestaurantsViewModel`类因为与Retrofit服务和Room DAO交互以获取和缓存餐厅数据而包含数据逻辑，但它应该只包含展示逻辑，因为其核心责任是管理UI状态。
- en: Another sign that our `RestaurantsViewModel` has piled up a lot of logic is
    that it currently stands at around 90 lines of code—this might not seem much yet,
    remember that our application is pretty simple and we have little presentation
    logic, so 90 lines will definitely turn into thousands for production-ready applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`RestaurantsViewModel`积累了大量逻辑的另一个迹象是，它目前大约有90行代码——这看起来可能并不多，但请记住，我们的应用程序相当简单，我们只有很少的展示逻辑，所以90行对于生产就绪的应用程序来说肯定会变成数千行。
- en: We want to move the data logic out of the `RestaurantsViewModel` into a different
    class. Since data logic is part of the Model layer of our application, in this
    section, we will start exploring how to define the Model layer with the help of
    Repository classes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将数据逻辑从`RestaurantsViewModel`移入一个不同的类。由于数据逻辑是应用程序模型层的一部分，在本节中，我们将开始探讨如何借助`Repository`类来定义模型层。
- en: The **Repository** pattern represents a strategy for abstracting data access
    inside your application. In other words, Repository classes hide away from the
    caller all the complexity associated with parsing data from the server, storing
    it in local databases, or performing any caching/refreshing mechanisms.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Repository**模式代表了一种在应用程序内部抽象数据访问的策略。换句话说，Repository类隐藏了从服务器解析数据、将其存储在本地数据库或执行任何缓存/刷新机制的所有复杂性。'
- en: 'In our app, the `RestaurantsViewModel` class must decide whether to get data
    from the `restInterface` (remote) source or from the `restaurantsDao` (local)
    source, while also making sure to refresh the cache. The following snippet shows
    the code that is executed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，`RestaurantsViewModel`类必须决定是否从`restInterface`（远程）源或从`restaurantsDao`（本地）源获取数据，同时确保刷新缓存。以下代码片段显示了执行的相关代码：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is obviously wrong. The `ViewModel` shouldn't care which particular data
    source to call as it shouldn't need to be the one that initiates caching to local
    sources. The `ViewModel` should only care about receiving some content that it
    will prepare for presentation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的。`ViewModel`不应该关心调用哪个特定的数据源，因为它不应该需要是那个启动本地源缓存的源。`ViewModel`应该只关心接收一些内容，它将为展示做准备。
- en: 'Let''s lift this burden from the `RestaurantsViewModel` class by creating a
    Repository class that will abstract all the data logic, as it will be interacting
    with the two data sources (web API and Room DAO) to do the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个将抽象所有数据逻辑的`Repository`类来从`RestaurantsViewModel`类中移除这个负担，因为它将与两个数据源（网络API和Room
    DAO）交互以执行以下操作：
- en: Provide a `List<Restaurant>` object to the Presentation layer
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向表示层提供一个`List<Restaurant>`对象
- en: Handle any caching logic such as retrieving restaurants from the web API and
    caching them to the Room local database
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理任何缓存逻辑，例如从网络API检索餐厅并将其缓存到Room本地数据库
- en: Define a **single source of truth** (**SSOT**) for data—the Room database
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据的**单一事实来源**（**SSOT**）——Room数据库
- en: 'To do that, we must only move the data logic out of the `ViewModel` and separate
    it in a Repository class. Let''s begin, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须只将数据逻辑从`ViewModel`中移出，并在`Repository`类中将其分离。让我们开始，如下所示：
- en: 'Create a Repository class by clicking on the application package, selecting
    `RestaurantsRepository` as the name and select **Class** as the type:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击应用程序包，将名称设置为`RestaurantsRepository`并选择**类**作为类型来创建一个`Repository`类：
- en: '[PRE15]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's start moving some code!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始移动一些代码！
- en: 'From inside the `RestaurantsViewModel` class, cut the `restInterface` variable
    and its initialization logic from the `init` block and paste it inside `RestaurantsRepository`,
    as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`类内部，从`init`块中剪切`restInterface`变量及其初始化逻辑，并将其粘贴到`RestaurantsRepository`中，如下所示：
- en: '[PRE16]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do the same for the `restaurantsDao` variable, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`restaurantsDao`变量，也执行相同的操作，如下所示：
- en: '[PRE17]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside the `RestaurantsViewModel` class, add a `repository` variable and instantiate
    it with the `RestaurantsRepository()` constructor, like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`类内部，添加一个`repository`变量，并使用`RestaurantsRepository()`构造函数对其进行实例化，如下所示：
- en: '[PRE18]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure that the `RestaurantsViewModel` no longer contains the `restInterface`
    variable, the `restaurantsDao` variable, or their initialization code from within
    the `init` block.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`RestaurantsViewModel`不再包含`restInterface`变量、`restaurantsDao`变量或它们在`init`块中的初始化代码。
- en: 'Move the `toggleFavoriteRestaurant()`, `getAllRestaurants()`, and `refreshCache()`
    methods of the `RestaurantsViewModel` class to the `RestaurantsRepository` class,
    as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RestaurantsViewModel`类的`toggleFavoriteRestaurant()`、`getAllRestaurants()`和`refreshCache()`方法移动到`RestaurantsRepository`类，如下所示：
- en: '[PRE19]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Make sure that apart from the `init { }` block, the `RestaurantsViewModel`
    class only contains the `toggleFavorite()` and `getRestaurants()` methods, as
    follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保除了`init { }`块之外，`RestaurantsViewModel`类只包含`toggleFavorite()`和`getRestaurants()`方法，如下所示：
- en: '[PRE20]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `RestaurantsRepository` class, remove the `private` modifier for
    the `getAllRestaurants()` and `toggleFavoriteRestaurant()` methods as `RestaurantsViewModel`
    will need to call them, so they must be public. The code is illustrated in the
    following snippet:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsRepository` 类中，移除 `getAllRestaurants()` 和 `toggleFavoriteRestaurant()`
    方法的 `private` 修饰符，因为 `RestaurantsViewModel` 需要调用它们，所以它们必须是公开的。代码如下所示：
- en: '[PRE21]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Going back inside the `RestaurantsViewModel` class, update the `getRestaurants()`
    method to now call `repository.getAllRestaurants()`, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `RestaurantsViewModel` 类内部，更新 `getRestaurants()` 方法，现在调用 `repository.getAllRestaurants()`，如下所示：
- en: '[PRE22]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Still inside the `RestaurantsViewModel` class, update the `toggleFavorite()`
    method to now call `repository.toggleFavoriteRestaurant()`, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `RestaurantsViewModel` 类中，更新 `toggleFavorite()` 方法，现在调用 `repository.toggleFavoriteRestaurant()`，如下所示：
- en: '[PRE23]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And we're done! While the functionality of the first screen should stay the
    same, we have now divided the responsibilities within this first flow not only
    within the Presentation layer but also between the Presentation layer and the
    Model layer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！虽然第一个屏幕的功能应该保持不变，但我们现在已经在这个第一个流程中划分了责任，不仅是在展示层内部，而且在展示层和模型层之间。
- en: Assignment
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 任务
- en: You can try to practice what we've learned in this section on the details screen
    of the Restaurants application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在“餐厅”应用的详情屏幕上尝试练习本节学到的内容。
- en: Next up, let's return for a while to the Presentation layer and inspect how
    the UI state is exposed from within our `ViewModel`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们暂时回到展示层，检查 UI 状态是如何从我们的 `ViewModel` 中暴露出来的。
- en: Improving state encapsulation in ViewModel
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高 ViewModel 中的状态封装
- en: 'Let''s have a look at how the UI state is defined in the `RestaurantsViewModel`
    class, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `RestaurantsViewModel` 类中 UI 状态的定义，如下所示：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `RestaurantsViewModel`, we are holding the state within the `state`
    variable with the `MutableState<RestaurantsScreenState>` inferred type. This variable
    is public, so inside the UI layer, from within the `RestaurantsScreen()` composable,
    we can consume it by accessing the `viewModel` variable and directly obtaining
    the `state` object, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，我们使用 `MutableState<RestaurantsScreenState>` 推断类型在
    `state` 变量中持有状态。这个变量是公开的，因此在内层 UI 中，从 `RestaurantsScreen()` 组合函数内部，我们可以通过访问 `viewModel`
    变量并直接获取 `state` 对象来消费它，如下所示：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The problem with this approach might not be obvious, but since the `state` variable
    is of type `MutableState`, not only can we read its value but we can also write
    its value. In other words, from within the composable UI layer, we have write
    access to the `state` variable through the `.value` accessor.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题可能并不明显，但既然 `state` 变量是 `MutableState` 类型，我们不仅能够读取它的值，还能够写入它的值。换句话说，从组合
    UI 层内部，我们通过 `.value` 访问器对 `state` 变量有写访问权限。
- en: 'The danger here is that then we (or other colleagues within our development
    team) could mistakenly update the UI state from within the UI layer, like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的危险在于，我们（或我们开发团队中的其他同事）可能会错误地从 UI 层更新 UI 状态，如下所示：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*You can try to add the previously highlighted line of code but remove it afterwards!*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以尝试添加之前突出显示的代码行，但之后要将其删除！*'
- en: 'This represents a violation of responsibilities within the Presentation layer:
    the UI layer shouldn''t perform presentation logic. In other words, the UI layer
    shouldn''t be able to mutate its own state that is stored inside the `ViewModel`;
    instead, only the `ViewModel` should have the right to do so.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了展示层内责任的违反：UI 层不应该执行展示逻辑。换句话说，UI 层不应该能够修改存储在 `ViewModel` 中的自己的状态；相反，只有 `ViewModel`
    应该有这个权利。
- en: This way, the `ViewModel` is the only entity responsible for presentation logic
    such as defining or mutating the UI state. At the same time, the responsibilities
    within our presentation patterns would be properly divided and respected.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`ViewModel` 是唯一负责展示逻辑的实体，例如定义或修改 UI 状态。同时，我们展示模式内的责任将得到适当的划分和尊重。
- en: To fix this, we must somehow force the `RestaurantsViewModel` class to expose
    a public `state` variable of type `State` instead of `MutableState`. This will
    prevent the UI layer from accidentally mutating its own state.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须以某种方式强制 `RestaurantsViewModel` 类公开一个类型为 `State` 的 `state` 变量，而不是
    `MutableState`。这将防止 UI 层意外地修改自己的状态。
- en: We can do this by having the Kotlin `state` variable. This feature states that
    if a class has two properties that are conceptually the same, yet one of them
    is part of the public API and the other one is an implementation detail, we can
    use an underscore to prefix the private property.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Kotlin的`state`变量来实现这一点。这个特性表明，如果一个类有两个在概念上相同的属性，但其中一个属于公共API，另一个是实现细节，我们可以使用下划线作为私有属性的名称前缀。
- en: 'Let''s see what this means by applying it directly in code, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过直接在代码中应用它来了解这意味着什么，如下所示：
- en: 'First, within the `RestaurantsViewModel` class, let''s prevent our `state`
    variable from being accessed because it''s of type `MutableState`, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsViewModel`类中，让我们防止我们的`state`变量被访问，因为它属于`MutableState`类型，如下所示：
- en: '[PRE27]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, still in the `RestaurantsViewModel` class, rename the `state` variable
    `_state`. You can do that by selecting the `state` variable, and then pressing
    *Shift* + *F6*. Make sure that all previous usages of `state` are now called `_state`.
    The code is illustrated in the following snippet:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，仍然在`RestaurantsViewModel`类中，将`state`变量重命名为`_state`。你可以通过选择`state`变量，然后按*Shift*
    + *F6*来实现这一点。确保所有之前的`state`使用现在都称为`_state`。代码在以下片段中展示：
- en: '[PRE28]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `_state` variable is now the private state of type `MutableState`, so it's
    the variable that we referred to as the implementation detail. This means that
    the `ViewModel` can mutate it, but it shouldn't be exposed to the outer world.
    Yet what should we expose to the UI layer?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`_state`变量现在是类型为`MutableState`的私有状态，因此它是我们所说的实现细节。这意味着`ViewModel`可以更改它，但它不应该暴露给外部世界。那么我们应该向UI层暴露什么？'
- en: 'Still inside the `RestaurantsViewModel`, create another `state` variable called
    `state` of type `State<RestaurantsScreenState>` and define its custom getter through
    the `get()` syntax, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`RestaurantsViewModel`中，创建另一个类型为`State<RestaurantsScreenState>`的`state`变量，并通过`get()`语法定义其自定义获取器，如下所示：
- en: '[PRE29]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `state` variable is now the public state of type `State` (so, it's part
    of the public API), and this means that when the UI layer will try to get its
    value, the `get()` syntax will be called and the content within the `_state` variable
    will be returned.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`变量现在是公共状态类型`State`（因此它是公共API的一部分），这意味着当UI层尝试获取其值时，将调用`get()`语法，并返回`_state`变量中的内容。'
- en: Behind the scenes, the `_state` variable's type `MutableState` is downcasted
    to type `State` of the `state` variable. This means that composables won't be
    able to ever mutate the state within the `ViewModel`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`_state`变量的类型`MutableState`被转换为`state`变量的`State`类型。这意味着可组合组件将无法在`ViewModel`内部更改状态。
- en: Conceptually, both the `state` variable and the `_state` variable are the same,
    yet `state` is used as part of a public contract with the outside world (so that
    it can be consumed by the UI layer), and `_state` is used as an internal implementation
    detail (a `MutableState` object that can be updated by the `ViewModel`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，`state`变量和`_state`变量是相同的，但`state`用作与外部世界的公共契约的一部分（因此它可以被UI层消费），而`_state`用作内部实现细节（一个可以被`ViewModel`更新的`MutableState`对象）。
- en: 'Finally, inside the `RestaurantsScreen()` composable, make sure that the `state`
    variable is consumed, like this:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`RestaurantsScreen()`可组合函数中，确保`state`变量被消费，如下所示：
- en: '[PRE30]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you now try to mutate the `state` variable''s value, as we did at the beginning
    of this section, then the `val` variable, as illustrated in the following code
    snippet:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试更改`state`变量的值，就像我们在本节开头所做的那样，那么`val`变量，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This effectively means that our UI can't mutate its own state by accident anymore.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着我们的UI不再可能意外地更改其自身的状态。
- en: Assignment
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 作业
- en: You can try to practice what we've learned in this section on the details screen
    of the Restaurants application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在餐厅应用的详细信息屏幕上尝试练习本节中学到的内容。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a first look at the SoC principle. We understood why
    we must split an application's responsibilities across several layers and explored
    how we can do that with the help of presentation design patterns.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首次了解了SoC原则。我们理解了为什么我们必须将应用程序的责任分割到几个层次，并探讨了如何通过展示设计模式来实现这一点。
- en: 'In the first part of this chapter, we had a quick look over the implementations
    for the most common presentation patterns in Android: MVC, MVP, and MVVM.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们简要回顾了Android中最常见的展示模式实现：MVC、MVP和MVVM。
- en: After that, we established that MVVM might be an appropriate choice for our
    Compose-based Restaurants application. We understood in which layer each type
    of logic must reside, and then tried to achieve SoC as well as possible in our
    application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们确定MVVM可能适合我们的基于Compose的餐厅应用程序。我们了解了每种类型的逻辑必须位于哪个层，然后尝试在我们的应用程序中尽可能实现SoC（单一职责原则）。
- en: In the last part of this chapter, we noticed how easy it is for our UI layer
    to extend its responsibilities and start performing presentation logic by mutating
    the UI state within the `ViewModel`. To counter that, we learned how to better
    encapsulate the UI state by using backed properties.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们注意到我们的UI层如何容易地扩展其职责，并通过在`ViewModel`中修改UI状态来开始执行展示逻辑。为了应对这种情况，我们学习了如何通过使用后置属性来更好地封装UI状态。
- en: Let's continue our journey of improving our application's architecture in the
    next chapter where we will try to adopt some design decisions from the well-known
    Clean Architecture software design philosophy.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一章继续我们的旅程，提高我们应用程序的架构。在这一章中，我们将尝试从著名的清洁架构软件设计哲学中采纳一些设计决策。
