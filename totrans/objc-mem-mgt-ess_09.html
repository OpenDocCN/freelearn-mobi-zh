<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Memory Management and Debugging</h1></div></div></div><p class="calibre8">Back in the good old days of iOS 3 and previous versions, the management of computer memory was a laborious affair as every pointer and memory allocation needed to be tracked precisely, lest you experienced the dreaded situation of memory leaks due to a missing <code class="email">release</code> keycode in your code and so on. However, with the release of iOS 4 and higher, Apple introduced ARC and developers all over the world rejoiced as they thought that the days of memory management were over. However, sadly, this is not the case as Objective-C is not like other programming languages such as Java or C#, where there is a garbage collector that will do the memory management and garbage collection for you. ARC only serves as an enabler to simplify memory management for us so that we do not need to explicitly call the <code class="email">release</code> method such as <code class="email">[myArray release]</code>, since ARC handles these for us. So while there are less brain cells that we need to allocate for memory management when developing an iOS app, we must still do some basic memory management even with the introduction of ARC, and this chapter will help you along the way with that. So to get things off the ground, here are the topics that we will cover in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Memory leaks</li><li class="listitem">Strong/weak references</li><li class="listitem">Retain cycles</li><li class="listitem">Memory overuse</li><li class="listitem">Using the debugger and breakpoints</li><li class="listitem">Collecting data on your AppPlumbing leaks</li><li class="listitem">Using the LLVM / Clang Static Analyzer</li><li class="listitem">Using NSZombie</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec66" class="calibre1"/>Memory leaks</h1></div></div></div><p class="calibre8">If you <a id="id299" class="calibre1"/>are used to calling the <code class="email">release</code> method after an <code class="email">alloc</code>/<code class="email">init</code> method or a <code class="email">retain</code> statement, ARC allows you to forgo all that as you can still call your <code class="email">alloc</code>/<code class="email">init</code> methods or <code class="email">retain</code> statements and not add in a <code class="email">release</code> statement <a id="id300" class="calibre1"/>as ARC takes care of this for you. This introduces brevity and makes your code more concise. Here is an example:</p><p class="calibre8">Before ARC:</p><div><pre class="programlisting">Class1 *obj1 = [[Class1 alloc] init];
Class1 *obj2 = [obj1 retain];
[obj2 release];
[obj1 release];</pre></div><p class="calibre8">After ARC:</p><div><pre class="programlisting">Class1 *obj1 = [[Class1 alloc] init];
Class1 *obj2 = obj1;</pre></div><p class="calibre8">If you wrote the code without calling the <code class="email">release</code> methods as seen under <em class="calibre9">After ARC</em>, you will have two memory leaks that will appear in your code due to you forgetting to put in the two <code class="email">release</code> methods. You will notice that the number of lines has been reduced and the code is easier to understand, as there is no need to call any <code class="email">release</code> statements. So with ARC, people will be fooled into thinking that their memory management woes are over, but actually, memory leaks can still happen with ARC and I will show you how.</p><p class="calibre8">ARC helps in that it automates the addition of <code class="email">retain</code>/<code class="email">release</code>/<code class="email">autorelease</code> statements to your code, but memory leaks can still occur with ARC. It is not so obvious to spot because people think that with ARC, there will not be any memory leaks. However, that is not the case and memory leaks can still occur with the presence of ARC, but there are some methods that you can use to find memory leaks. However, first, let's go through some terms.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec38" class="calibre1"/>Strong/weak references</h2></div></div></div><p class="calibre8">A strong reference<a id="id301" class="calibre1"/> is synonymous with the <code class="email">retain</code> property where you increment the reference <a id="id302" class="calibre1"/>count of an object by 1. In the world of ARC, the <code class="email">retain</code> and <code class="email">assign</code> properties are no longer used and are replaced with <code class="email">strong</code> and <code class="email">weak</code> respectively.</p><p class="calibre8">A <a id="id303" class="calibre1"/><code class="email">strong</code> reference is the default property of objects as it means that you want to get ownership of an object while a <code class="email">weak</code> reference<a id="id304" class="calibre1"/> means that another object is holding ownership to the object you want and then you can't stop it from being deallocated since ownership does not belong to you.</p><p class="calibre8">The <code class="email">strong</code> and<a id="id305" class="calibre1"/> <code class="email">weak</code> references are <a id="id306" class="calibre1"/>denoted by the Objective-C <code class="email">strong</code> and <code class="email">weak</code> keyword respectively. Even with ARC, you can still have memory leaks appearing and some causes of memory leaks using ARC are:</p><div><ul class="itemizedlist"><li class="listitem">Retain cycles</li><li class="listitem">Creating secondary threads and not providing it with its own autorelease pool</li><li class="listitem">Using frameworks that have non-ARC code</li><li class="listitem">Referencing itself within a block, which creates a strong reference</li></ul></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec39" class="calibre1"/>Retain cycles</h2></div></div></div><p class="calibre8">A <a id="id307" class="calibre1"/>retain cycle<a id="id308" class="calibre1"/> occurs when two objects such as a parent and child object have strong references to each other. A simple example would be the following code:</p><div><pre class="programlisting">@interface MyParent : NSObject
@property (strong) MyChild *myChild;
@end

@interface MyChild : NSObject
@property (strong) MyParent *myParent;
@end</pre></div><p class="calibre8">You can create an object of the type <code class="email">MyParent</code> with the following code:</p><div><pre class="programlisting">MyParent *myParent = [[MyParent alloc] init];</pre></div><p class="calibre8">A retain cycle is created with the preceding line of code and here is how it looks:</p><div><img src="img/00035.jpeg" alt="Retain cycles" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the<a id="id309" class="calibre1"/> preceding <a id="id310" class="calibre1"/>diagram, you can quickly see what is called a retain cycle since <strong class="calibre2">myParent</strong> has a strong reference to <strong class="calibre2">myChild</strong>, and <strong class="calibre2">myChild</strong> has a strong reference to <strong class="calibre2">myParent</strong>. This is a form of memory leak where if an object tries to release an instance of the first object, it can't be released because the second object has a strong reference to the first object and a retain cycle is created. Do note that ARC will not fix all memory leaks for you, so you, the developer have to fix this type of memory leaks using some tools, which we will cover later on. As this type of memory leak is not very obvious, fixing it will require more effort and thinking, but thankfully, Apple has provided some tools that will aid us greatly in this.</p><p class="calibre8">A general rule of thumb to avoid a situation where a retain cycle can occur is to remember this—if object A wants to retain object B indefinitely, then object A has to be higher up in the hierarchy tree than object B, where object A has to have a strong reference to object B. If you have objects that are on the same level in the hierarchy tree, then you should put a weak reference to avoid a retain cycle. So in the preceding diagram, to avoid a retain cycles, <code class="email">mySecondObject</code> should not have a strong reference to <code class="email">myFirstObject</code>. However, if you do need to let <code class="email">mySecondObject</code> have a reference to <code class="email">myFirstObject</code>, then make it a weak reference instead of a strong reference. Tree hierarchies are safe and do remember that putting weak references will avoid a retain cycle and memory leaks.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec40" class="calibre1"/>Memory overuse</h2></div></div></div><p class="calibre8">If you <a id="id311" class="calibre1"/>used enough iOS apps, you will notice that some apps will just force close themselves after you innocuously tap on a button or do some action. This is an iOS way of handling memory issues as it basically just says, "this app has a memory leak and you do not have enough memory to handle it, so this app has to be closed."</p><p class="calibre8">Altogether there are three memory warning levels for iOS. Level 1 and 2 will be displayed in your Xcode console when memory is running low, as shown in the following diagram. Level 3 occurs when your application crashes and goes back to Springboard, which is the term used to refer to the iOS home screen:</p><div><img src="img/00036.jpeg" alt="Memory overuse" class="calibre10"/></div><p class="calibre11"> </p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>Using the debugger and breakpoints</h1></div></div></div><p class="calibre8">One of the most fundamental debugging concepts of using an IDE, such as Xcode, is the concept of <a id="id312" class="calibre1"/>breakpoints, where you<a id="id313" class="calibre1"/> can stop your running program at a particular point in time as denoted by the breakpoint where your code is. Using the breakpoint is very simple; you just open up your Xcode project and click on the left side of the window where you code it and a blue indicator will appear, as shown here:</p><div><img src="img/00037.jpeg" alt="Using the debugger and breakpoints" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Next, when you <a id="id314" class="calibre1"/>run your application and when the program hits line number <strong class="calibre2">26</strong> at the <code class="email">while(true)</code> statement, the program will halt and you can move your cursor over any variable before line number <strong class="calibre2">26</strong>, and Xcode will show you the value that the variable contains at that point in time. Breakpoints are useful in debugging memory leaks where you have an idea of where a leak appears and you want to see the value or memory address of that variable. You can put multiple breakpoints and use the Step Over command to step over each line of code to see how your program is executing. Here is a list of icons, that<a id="id315" class="calibre1"/> you will come across when debugging using breakpoints:</p><div><img src="img/00038.jpeg" alt="Using the debugger and breakpoints" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The four icons from the left to right in the preceding screenshot that you can use for <a id="id316" class="calibre1"/>breakpoint debugging are as follows:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Icons</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Continue program execution</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This will let your program continue executing until it encounters the next breakpoint, or the program ends</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Step Over</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This will let your program execute the next line of code in the current scope</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Step Into</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This will let your program follow the method into its own code and view the code for the method</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Step Out</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This will take you out of the current context and into calling a method one step up into the program stack</p>
</td></tr></tbody></table></div><p class="calibre8">Breakpoints<a id="id317" class="calibre1"/> are very useful for checking the values of your variables at a specific point in time when your program is halted due to the breakpoint and the four icons for breakpoint debugging will aid you in debugging memory-related and other logic bugs.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec68" class="calibre1"/>Collecting data on your app</h1></div></div></div><p class="calibre8">Do note that a <a id="id318" class="calibre1"/>memory warning level does not necessarily mean that your application is leaking memory. There could be a situation where your application is loading or performing operations on large resources such as data files, images, videos, and so on and this will trigger the memory warning. ARC will handle the cleaning up later. However, if you see a memory warning level 2, then you should start to look at your code as the next memory warning level will be the actual application crash.</p><p class="calibre8">Debugging crashes and memory leaks are like the game of hide and seek or playing detective. There will be a lot of clues lying around, which will lead you to the culprit in your code that is causing a bothersome crash or memory leak. Apple has provided us with a lot of tools and logs, which will be useful for us in debugging our code. We will cover some of the commonly used methods here so that you can get cracking with regards to fixing those problems as soon as possible.</p><p class="calibre8">One of the easier ways is to plug your device into your machine via your cable, fire up Xcode, which will automatically detect your plugged-in device and then press <em class="calibre9">Shift</em> + <em class="calibre9">Command</em> + <em class="calibre9">C</em> <a id="id319" class="calibre1"/>to activate your debug console, which is a black screen on the bottom right of your Xcode screen. Or you can select <strong class="calibre2">View</strong> | <strong class="calibre2">Debug Area</strong> | <strong class="calibre2">Activate Console</strong> from your Xcode menu as shown here:</p><div><img src="img/00039.jpeg" alt="Collecting data on your app" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This will show all NSLog and crash output when you are running your app via a cable connection to Xcode.</p><p class="calibre8">However, there are occasions when you are testing your application, when it is not connected to your Xcode and it crashes at that moment. The preceding method does not work in this case, so what can you do? Do not fret, as there is another way to get your crash log once you are at your table and have plugged your iOS device into your machine and fired up Xcode.</p><p class="calibre8">Once you have started Xcode and plugged in your device where your app crashed, Xcode will actually be able to access your crash log on the device. To do so, all you need to do is click on the window and select <strong class="calibre2">Organizer</strong> from your Xcode menu, as shown in the following screenshot:</p><div><img src="img/00040.jpeg" alt="Collecting data on your app" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This will open your <strong class="calibre2">Organizer</strong>, which actually is a repository of all the devices that have been connected to Xcode and shows information such as the application's provisioning profile and screenshots. However, what we are really interested in is the crash logs.</p><p class="calibre8">So, click <a id="id320" class="calibre1"/>on the <strong class="calibre2">Devices</strong> button at the top and you will be shown all the developer information about all the devices that have connected to your device so far.</p><p class="calibre8">Click on your currently connected device, which is denoted by a green circle. Then, select the <strong class="calibre2">Device Logs</strong> option, which will then open another list of apps that have crashed. There you can sort the results by <strong class="calibre2">Process</strong>, which is the application name, <strong class="calibre2">Type</strong>, or <strong class="calibre2">Date/Time</strong>. Clicking on an item will reveal the crash log on the right side of the screen. There you can see the backtrace, which is actually a listing of all the methods that were called leading up to your crash. The last section of the code that caused your crash will be at the top of the backtrace, and you should start by looking from the bottom up to see how your app works and see all the functions and methods that it traversed through leading up to the crash:</p><div><img src="img/00041.jpeg" alt="Collecting data on your app" class="calibre10"/></div><p class="calibre11"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec69" class="calibre1"/>Plumbing memory leaks</h1></div></div></div><p class="calibre8">Next, we <a id="id321" class="calibre1"/>will look at a special tool present in Xcode to get in-depth information about your app while it is running. This special tool is actually a suite of tools that can perform the following functions:</p><div><ul class="itemizedlist"><li class="listitem">Examine and monitor one or more processes</li><li class="listitem">Record a sequence of user actions and replay them, just like a video recorder</li><li class="listitem">Save user interface recordings and then access them from Xcode</li><li class="listitem">This set of tools is known collectively as Instruments and they are more useful than NSLogs when tracking down difficult-to-reproduce bugs, such as random crashes and debugging memory leaks</li><li class="listitem">Analyze the performance of your app</li><li class="listitem">Perform stress testing on your app</li><li class="listitem">Gain a better understanding of how your application works</li></ul></div><p class="calibre8">In this section, I will<a id="id322" class="calibre1"/> teach you the <a id="id323" class="calibre1"/>basics of Instruments and how<a id="id324" class="calibre1"/> to debug some code using it. So, to start off, you just need to follow these three simple steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Click the <strong class="calibre2">Xcode</strong> menu on the top left of your Xcode IDE.</li><li class="listitem" value="2">Select <strong class="calibre2">Open Developer Tool</strong> from the list that appears.</li><li class="listitem" value="3">A submenu will appear with the <strong class="calibre2">Instruments</strong> item, which you should click on:<div><img src="img/00042.jpeg" alt="Plumbing memory leaks" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="4">Then, you should see a pop-up window with the following options:<div><img src="img/00043.jpeg" alt="Plumbing memory leaks" class="calibre10"/></div><p class="calibre23"> </p><p class="calibre25">There are<a id="id325" class="calibre1"/> options such as <strong class="calibre2">Leaks</strong>, <strong class="calibre2">Allocations</strong>, and <strong class="calibre2">Time Profiler</strong>, which show all the various tools.</p></li><li class="listitem" value="5">To have <a id="id326" class="calibre1"/>a little test run, open the <code class="email">Instruments.xcodeproj</code> file, which has very leaky code and we will see how to use the Xcode debugging tool called <strong class="calibre2">Instruments</strong> to understand how the memory allocation spikes up when the code is running. So, to start things off, let's use the Xcode profiling tool to see our memory spike by clicking on the <strong class="calibre2">Product</strong> | <strong class="calibre2">Profile</strong> menu option as shown here:<div><img src="img/00044.jpeg" alt="Plumbing memory leaks" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="6">Then, Xcode<a id="id327" class="calibre1"/> will show the <strong class="calibre2">Instruments</strong> window and then you need to select <strong class="calibre2">Allocations</strong> options and click on the <strong class="calibre2">Profile</strong> button. Once you have<a id="id328" class="calibre1"/> clicked the <strong class="calibre2">Profile</strong> button, the leaky app will start executing and you will see the following screen. Keep an eye on the graph that you will see spiking up rapidly and also the <strong class="calibre2">All Heap Allocations</strong> row, which will show the amount of memory being consumed increasing in a very fast rate:<div><img src="img/00045.jpeg" alt="Plumbing memory leaks" class="calibre10"/></div><p class="calibre23"> </p></li></ol><div></div><p class="calibre8">So, to<a id="id329" class="calibre1"/> reiterate<a id="id330" class="calibre1"/> the steps, we need to do the following:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open Xcode.</li><li class="listitem" value="2">Click on <strong class="calibre2">Product</strong> | <strong class="calibre2">Profile</strong>.</li><li class="listitem" value="3">Click on <strong class="calibre2">Allocations</strong> | <strong class="calibre2">Profile</strong>.</li><li class="listitem" value="4">Look at the <strong class="calibre2">All Heap Allocations</strong> section.</li><li class="listitem" value="5">Look at the memory allocation on the graph.</li><li class="listitem" value="6">Check for retain cycles or usages of itself within blocks that can hint or create a retain cycle.</li></ol><div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec70" class="calibre1"/>Using the LLVM / Clang Static Analyzer</h1></div></div></div><p class="calibre8">The Instruments <a id="id331" class="calibre1"/>suite of tools is meant to be used when your app is running. However, sometimes, as the saying goes, <em class="calibre9">an ounce of prevention is worth a pound of cure</em>. So, before you pull up Instruments to debug your app during runtime, there is a good step that you should follow and which is performing a static analysis on your code base.</p><p class="calibre8">Static analysis is<a id="id332" class="calibre1"/> a mechanism where a collection of algorithms and techniques are used to analyze your source code to find bugs. This may sound like what you do during the compilation stage, but there is an important difference. The act of compiling your code will tell Xcode to check your code base for syntax errors and flag out any errors or warnings that it detects. Static analysis goes one step deeper in that it analyzes your code to find potential bugs that will surface during runtime. Static analysis lets the program calculate all possible executions of a program, and the code is analyzed for quality, safety, and security so that you are alerted to bugs such as overflows, divide by zero, pointer errors, and so on. So, think of static analysis as runtime testing, but before your code has begun executing.</p><p class="calibre8">As static analysis goes deeper into your code, the amount of time Xcode takes to do the static analysis will be longer. So, use static analysis only for debugging hard-to-fix bugs or as a final step before submitting your app to the iTunes App Store. To activate static analysis of your app, click on <strong class="calibre2">Product</strong> | <strong class="calibre2">Analyze</strong> to let Xcode start its static analysis of your code:</p><div><img src="img/00046.jpeg" alt="Using the LLVM / Clang Static Analyzer" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Depending on the <a id="id333" class="calibre1"/>size of your code base, static analysis can take seconds to even minutes while it dives deep into your code to ferret out any potential issues. A project that has only a few lines of code will take a few seconds to do the static analysis while a large project with thousands of lines of code will take a few minutes or more, depending on the size of the project. Then, click on the left side of your Xcode screen as shown in the preceding screenshot, to see the potential issues that Xcode found through static analysis.</p><p class="calibre8">By default, static analysis goes down to a deep level to analyze every corner of your code base. This consumes a lot of resources on your machine, and if you have a large code base or a slow machine, the amount of time used for static analysis can be quite big. Hence, you can adjust the level of static analysis that Xcode uses if you don't want an in-depth analysis, which may not find as many issues as a deep static analysis, but can still help surface some issues. Static analysis is useful as it can surface errors such as overflows, divide by zero, and so on, which a compiler can't detect. To change the level of static analysis, click on your project on the left, then select <strong class="calibre2">Build Settings</strong> and then look for the <strong class="calibre2">Mode of analysis for 'Analyze'</strong> option and set it to <strong class="calibre2">Shallow (faster)</strong> as shown here:</p><div><img src="img/00047.jpeg" alt="Using the LLVM / Clang Static Analyzer" class="calibre10"/></div><p class="calibre11"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec41" class="calibre1"/>Using NSZombie</h2></div></div></div><p class="calibre8">Last but<a id="id334" class="calibre1"/> not least, let me introduce you to the concept of NSZombie. NSZombie is a memory debugging aid that helps you in debugging memory leaks. As you may know, when an object has a retain count of 0, that object will be deallocated and not exist anymore. However, if you enable NSZombie, the object with a retain count of 0 will turn into a NSZombie instance instead. Then, when this NSZombie receives a message from another place in your code, it will show a warning instead of crashing your app or exhibiting unpredictable behavior.</p><p class="calibre8">NSZombie is useful for debugging subtle overrelease or autorelease bugs as these types of bugs tend to manifest itself in crashes or weird behavior. NSZombie will show these crashes and weird behavior as a warning instead, which will help in your debugging.</p><p class="calibre8">NSZombies exist in a strange half-alive/half-dead state as they are not deallocated when the retain count is 0, but they are not fully alive either. So, NSZombie is an apt term to use to describe these half-living/half-dead objects.</p><p class="calibre8">However, an important point to note is that NSZombies are to be disabled once you have finished debugging. NSZombies consume memory like any object with a retain count of 0, which is turned into NSZombie, which still occupies memory instead of being deallocated. So, if you do not disable NSZombie it will occupy more memory. In order to harness the power of NSZombie where it will log a warning instead of crashing your app or exhibiting unpredictable behavior, just follow these simple steps to activate NSZombie:</p><div><ol class="orderedlist"><li class="listitem" value="1">Click on the <strong class="calibre2">Product</strong> menu in your Xcode IDE.</li><li class="listitem" value="2">Select the <strong class="calibre2">Scheme</strong> menu item.</li><li class="listitem" value="3">Proceed to click on <strong class="calibre2">Edit Scheme...</strong> to open the popup to enable NSZombie:<div><img src="img/00048.jpeg" alt="Using NSZombie" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="4">Then, you <a id="id335" class="calibre1"/>will see a popup appear with an <strong class="calibre2">Enable Zombie Objects</strong> option. Click on this checkbox and NSZombie will be enabled.</li><li class="listitem" value="5">Finally, run your project and you will see NSZombie in action:<div><img src="img/00049.jpeg" alt="Using NSZombie" class="calibre10"/></div><p class="calibre23"> </p></li></ol><div></div><p class="calibre8">Finally, here is a table <a id="id336" class="calibre1"/>outlining which debugging tools should be used in which context so that you can use the right tool for the right situation:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Debugging tool</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Appropriate context</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Xcode Instruments</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This is <a id="id337" class="indexterm"/>used to find memory leaks that cause crashes during runtime</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Static Analyzer</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This is <a id="id338" class="indexterm"/>used to analyze your code base for issues such as divide by 0, memory issues before the code is executed, and so on</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">NSZombie</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This<a id="id339" class="indexterm"/> is used to show warnings instead of crashing due to memory leaks</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec71" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We covered some aspects of the theory of memory management, such as retain cycles and strong/weak references. Then, we moved to the repercussions of memory leaks and the various warning levels. Following this, we discovered how to get crash logs to help you get information about your app and code. We then looked at a list of the various tools that Xcode possesses, such as Instruments and NSZombies, which will help us to debug memory leaks that can be caused by a myriad of causes, such as not releasing objects or releasing objects prematurely. Finally, we closed off with a description of static analysis and enabling NSZombies and their uses. With all these tools and information at your fingertips, I hope debugging memory leaks and errors have been made much easier for you since you have the tools required to make this a less painful journey.</p><p class="calibre8">In the next chapter, we will cover some developer tips for memory management, such as getters, setters, and other tips. So, let's head to the next chapter.</p></div></body></html>