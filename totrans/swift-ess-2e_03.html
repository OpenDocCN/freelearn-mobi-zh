<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Creating an iOS Swift App</h1></div></div></div><p class="calibre8">After the release of Xcode 6 in 2014, it has been possible to build Swift applications for iOS and OS X and submit them to the App Store for publication. This chapter will present both a single view application and a master-detail application, and use these to explain the concepts behind iOS applications, as well as introduce classes in Swift.</p><p class="calibre8">This chapter will present the following topics:</p><div><ul class="itemizedlist"><li class="listitem">How iOS applications are structured</li><li class="listitem">Single-view iOS applications</li><li class="listitem">Creating classes in Swift</li><li class="listitem">Protocols and enums in Swift</li><li class="listitem">Using <code class="literal">XCTest</code> to test Swift code</li><li class="listitem">Master-detail iOS applications</li><li class="listitem">The <code class="literal">AppDelegate</code> and <code class="literal">ViewController</code> classes</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec22" class="calibre1"/>Understanding iOS applications</h1></div></div></div><p class="calibre8">An iOS application is <a id="id120" class="calibre1"/>a compiled executable along with a set of supporting files in a bundle. The application bundle is packaged into an archive file to be installed onto a device or upload to the App Store.</p><div><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre8">Xcode can be used to run iOS applications in a simulator, as well as testing them on a local device. Submitting an application to the App Store requires a developer signing key, which is included as part of the Apple Developer Program at <a class="calibre1" href="https://developer.apple.com">https://developer.apple.com</a>.</p></div><p class="calibre8">Most iOS applications to date have been written in Objective-C, a crossover between C and Smalltalk. With the advent of Swift, it is likely that many developers will move at least parts of their applications to Swift for performance and maintenance reasons.</p><p class="calibre8">Although Objective-C is likely to be around for a while, it is clear that Swift is the future of iOS development and probably OS X as well. Applications contain a number of different types of files, which <a id="id121" class="calibre1"/>are used both at compile time and also at runtime. These files include the following:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">Info.plist</code> file, which contains information about which languages the application is localized for, what the identity of the application is, and the configuration requirements, such as the supported interface types (iPad, iPhone, and Universal), and orientations (Portrait, Upside Down, Landscape Left, and Landscape Right)</li><li class="listitem">Zero or more <em class="calibre11">interface builder</em> files with a <code class="literal">.xib</code> extension, which contain user interface screens (which supersedes the previous <code class="literal">.nib</code> files)</li><li class="listitem">Zero or more <em class="calibre11">image asset</em> files with a <code class="literal">.xcassets</code> extension, which store groups of related icons at different sizes, such as the application icon or graphics for display on screen (which supersedes the previous <code class="literal">.icns</code> files)</li><li class="listitem">Zero or more <em class="calibre11">storyboard</em> files with a <code class="literal">.storyboard</code> extension, which are used to coordinate between different screens in an application</li><li class="listitem">One or more <code class="literal">.swift</code> files that contain application code</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec23" class="calibre1"/>Creating a single-view iOS application</h1></div></div></div><p class="calibre8">A single-view iOS application is <a id="id122" class="calibre1"/>one where the application is presented in a single screen, without any transitions or other views. This section will show how to create an application that uses a single view without storyboards. (Storyboards are covered in <a class="calibre1" title="Chapter 4. Storyboard Applications with Swift and iOS" href="part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b">Chapter 4</a>, <em class="calibre11">Storyboard Applications with Swift and iOS</em>.)</p><p class="calibre8">When Xcode starts, it<a id="id123" class="calibre1"/> displays a welcome message that includes the ability to create a new project. This welcome message can be redisplayed at any time by navigating to <strong class="calibre2">Window</strong> | <strong class="calibre2">Welcome to Xcode</strong> or by pressing <em class="calibre11">Command</em> + <em class="calibre11">Shift</em> + <em class="calibre11">1</em>.</p><p class="calibre8">Using the welcome dialog's <strong class="calibre2">Create a new Xcode project</strong> option, or navigating to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> | <strong class="calibre2">Project...</strong>, or by pressing <em class="calibre11">Command</em> + <em class="calibre11">Shift</em> + <em class="calibre11">N</em>, create a new <strong class="calibre2">iOS</strong> project with <strong class="calibre2">Single View Application</strong> as the template, as shown in the following screenshot:</p><div><img src="img/00023.jpeg" alt="Creating a single-view iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When the <strong class="calibre2">Next</strong> button is pressed, the new project dialog will ask for more details. The product name <a id="id124" class="calibre1"/>here is <code class="literal">SingleView</code> with appropriate values for <strong class="calibre2">Organization Name</strong> and <strong class="calibre2">Identifier</strong>. Ensure that the language selected is <strong class="calibre2">Swift</strong> and the device type is <strong class="calibre2">Universal</strong>:</p><div><img src="img/00024.jpeg" alt="Creating a single-view iOS application" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre8">The <strong class="calibre2">Organization Identifier</strong> is a reverse domain name representation of the organization, and the <strong class="calibre2">Bundle Identifier</strong> is the concatenation of the <strong class="calibre2">Organization Identifier</strong> with the <strong class="calibre2">Product Name</strong>. Publishing to the App Store requires that the <strong class="calibre2">Organization Identifier</strong> be owned by the publisher and is managed in the online developer center at <a class="calibre1" href="https://developer.apple.com/membercenter/">https://developer.apple.com/membercenter/</a>.</p></div><p class="calibre8">When <strong class="calibre2">Next</strong> is pressed, Xcode will ask where to save the project and whether a repository should be created. The selected location will be used to create the product directory, and an option to create a Git repository will be offered.</p><div><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre8">In 2014, Git became the most widely used version control system, surpassing all other distributed and centralized version control systems. It would be foolish not to create a Git repository when creating a new Xcode project.</p></div><p class="calibre8">When <strong class="calibre2">Create</strong> is pressed, Xcode will create the project, set up template files, and then initialize the Git repository locally or on a shared server.</p><p class="calibre8">Press the triangular play button at the top-left of Xcode to launch the simulator:</p><div><img src="img/00025.jpeg" alt="Creating a single-view iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If everything <a id="id125" class="calibre1"/>has been set up correctly, the simulator will start with a white screen and the time and battery shown at the top of the screen:</p><div><img src="img/00026.jpeg" alt="Creating a single-view iOS application" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec41" class="calibre1"/>Removing the storyboard</h2></div></div></div><p class="calibre8">The default<a id="id126" class="calibre1"/> template for a single-view application includes a <em class="calibre11">storyboard</em>. This creates the view for the first (only) screen and performs some additional setup behind the scenes. To understand what happens, the storyboard will be removed and replaced with code instead.</p><div><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">Most applications are built with one or more storyboards. It is being removed here for demonstration purposes only; refer to the <a class="calibre1" title="Chapter 4. Storyboard Applications with Swift and iOS" href="part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b">Chapter 4</a>, <em class="calibre11">Storyboard Applications with Swift and iOS</em>, for more information on how to use storyboards.</p></div><p class="calibre8">The storyboard can be deleted by going to the project navigator, finding the <code class="literal">Main.storyboard</code> file, and pressing the <em class="calibre11">Delete</em> key or selecting <strong class="calibre2">Delete</strong> from the context-sensitive menu. When the confirmation dialog is shown, select the <strong class="calibre2">Move to Trash</strong> option to ensure that the file is deleted rather than just being removed from the list of files that Xcode knows about.</p><div><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre8">To see the project navigator, press <em class="calibre11">Command</em> + <em class="calibre11">1</em> or navigate to <strong class="calibre2">View</strong> | <strong class="calibre2">Navigators</strong> | <strong class="calibre2">Show Project Navigator</strong>.</p></div><p class="calibre8">Once the <code class="literal">Main.storyboard</code> file has been deleted, it needs to be removed from <code class="literal">Info.plist</code>, to prevent iOS from trying to open it at startup. Open the <code class="literal">Info.plist</code> file under the <code class="literal">Supporting</code> <code class="literal">Files</code> folder of <code class="literal">SingleView</code>. A set of key-value pairs will be displayed; clicking <a id="id127" class="calibre1"/>on the <strong class="calibre2">Main storyboard file base name</strong> row will present the (<strong class="calibre2">+</strong>) and (<strong class="calibre2">-</strong>) options. Clicking on the delete icon (<strong class="calibre2">-</strong>) will remove the line:</p><div><img src="img/00027.jpeg" alt="Removing the storyboard" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Now when the application is started, a black screen will be displayed.</p><div><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre8">There are multiple <code class="literal">Info.plist</code> files that are created by Xcode's template; one file is used for the real application, while the other files are used for the test applications that get built when running tests. Testing is covered in the <em class="calibre11">Subclasses and testing in Swift</em> section later in this chapter.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec42" class="calibre1"/>Setting up the view controller</h2></div></div></div><p class="calibre8">The <em class="calibre11">view controller</em> is <a id="id128" class="calibre1"/>responsible for setting up the view when it is activated. Typically, this is done through either the storyboard or the interface file. As these have been removed, the window and the view controller need to be instantiated manually.</p><p class="calibre8">When <a id="id129" class="calibre1"/>iOS applications start, <code class="literal">application:didFinishLaunchingWithOptions:</code> is called on the corresponding <code class="literal">UIApplicationDelegate</code>. The optional <code class="literal">window</code> variable is initialized automatically when it is loaded from an interface file or a storyboard, but it needs to be explicitly initialized if the user interface is being implemented in code.</p><p class="calibre8">Implement the <code class="literal">application:didFinishLaunchingWithOptions:</code> method in the <code class="literal">AppDelegate</code> class as follows:</p><div><pre class="programlisting">@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  var window: UIWindow?
  func application(application: UIApplication,
   didFinishLaunchingWithOptions launchOptions:
   [NSObject:AnyObject]?) -&gt; Bool {
    window = UIWindow()
    window?.rootViewController = ViewController()
    window?.makeKeyAndVisible()
    return true
  }
}</pre></div><div><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre8">To open a class by name, press <em class="calibre11">Command</em> + <em class="calibre11">Shift</em> + <em class="calibre11">O</em> and type in the class name. Alternatively, navigate to <strong class="calibre2">File</strong> | <strong class="calibre2">Open Quickly...</strong>
</p></div><p class="calibre8">The final step is to create the view's content, which is typically done in the <code class="literal">viewDidLoad</code> method of the <code class="literal">ViewController</code> class. As an example user interface, a <code class="literal">UILabel</code> will be created and added to the view. Each view controller has an associated <code class="literal">view</code> property, and child views can be added with the <code class="literal">addSubview</code> method. To make the view stand out, the background of the view will be changed to black and the text color will be changed to white:</p><div><pre class="programlisting">class ViewController: UIViewController {
  override func viewDidLoad() {
    super.viewDidLoad()
<strong class="calibre2">    view.backgroundColor = UIColor.blackColor()</strong>
<strong class="calibre2">    let label = UILabel(frame:view.bounds)</strong>
<strong class="calibre2">    label.textColor = UIColor.whiteColor()</strong>
<strong class="calibre2">    label.textAlignment = .Center</strong>
<strong class="calibre2">    label.text = "Welcome to Swift"</strong>

<strong class="calibre2">    view.addSubview(label)</strong>
  }
}</pre></div><p class="calibre8">This creates a label, which is sized to the full size of the screen, with a white text color and a centered<a id="id130" class="calibre1"/> text alignment. When run, this displays <strong class="calibre2">Welcome to Swift</strong> on the screen.</p><div><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre8">Typically, views will be implemented in their own class rather than being in-lined into the view controller. This allows the views to be reused in other controllers. This technique will be demonstrated in the next chapter.</p><p class="calibre8">When the screen is rotated, the label will be rotated off screen. Logic would need to be added in a real application to handle rotation changes in the view controller, such as <code class="literal">willRotateToInterfaceOrientation</code>, and to appropriately add rotations to the views using the <code class="literal">transform</code> property of the view. Usually, an interface builder file or storyboard would be used so that this is handled automatically.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>Swift classes, protocols, and enums</h1></div></div></div><p class="calibre8">Almost<a id="id131" class="calibre1"/> all Swift applications will be object oriented. <a class="calibre1" title="Chapter 1. Exploring Swift" href="part0016_split_000.html#F8901-d7e55eb5242648e89c396442afe4f84b">Chapter 1</a>, <em class="calibre11">Exploring Swift</em>, and <a class="calibre1" title="Chapter 2. Playing with Swift" href="part0023_split_000.html#LTSU2-d7e55eb5242648e89c396442afe4f84b">Chapter 2</a>, <em class="calibre11">Playing with Swift</em>, both demonstrated functional and procedural Swift code. Classes, such as <code class="literal">Process</code> from the <code class="literal">CoreFoundation</code> framework, and <code class="literal">UIColor</code> and <code class="literal">UIImage</code> from the <code class="literal">UIKit</code> framework, were used to demonstrate how classes can be used in applications. This section describes how to create classes, protocols, and enums in Swift.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec43" class="calibre1"/>Classes in Swift</h2></div></div></div><p class="calibre8">A class is created <a id="id132" class="calibre1"/>in Swift using the <code class="literal">class</code> keyword, and braces are used to enclose the class body. The body can contain variables called <a id="id133" class="calibre1"/>
<em class="calibre11">properties</em>, as well as functions called <a id="id134" class="calibre1"/>
<em class="calibre11">methods</em>, which are collectively referred to as <a id="id135" class="calibre1"/>
<em class="calibre11">members</em>. Instance members are unique to each instance, while static members are shared between all instances of that class.</p><p class="calibre8">Classes are <a id="id136" class="calibre1"/>typically defined in a file named for the class; so a <code class="literal">GitHubRepository</code> class would typically be defined in a <code class="literal">GitHubRepository.swift</code> file. A new Swift file can be created by navigating to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> | <strong class="calibre2">File…</strong> and selecting the <strong class="calibre2">Swift File</strong> option under <strong class="calibre2">iOS</strong>. Ensure that it is added to the <strong class="calibre2">Tests</strong> and <strong class="calibre2">UITests</strong> targets as well. Once created, implement the class as follows:</p><div><pre class="programlisting">class GitHubRepository {
  var id:UInt64 = 0
  var name:String = ""
  func detailsURL() -&gt; String {
    return "https://api.github.com/repositories/\(id)"
  }
}</pre></div><p class="calibre8">This class can be instantiated and used as follows:</p><div><pre class="programlisting">let repo = GitHubRepository()
repo.id = 1
repo.name = "Grit"
repo.detailsURL() // returns https://api.github.com/repositories/1</pre></div><p class="calibre8">It is <a id="id137" class="calibre1"/>possible<a id="id138" class="calibre1"/> to create static members, which are the same for all instances of a class. In the <code class="literal">GitHubRepository</code> class, the <code class="literal">api</code> URL is likely to remain the same for all invocations, so it can be refactored into a <code class="literal">static</code> property:</p><div><pre class="programlisting">class GitHubRepository {
  // does not work in Swift 1.0 or 1.1
  static let api = "https://api.github.com"
  …
  class func detailsURL(id:String) -&gt; String {
    return "\(api)/repositories/\(id)"
  }
}</pre></div><p class="calibre8">Now, if the <code class="literal">api</code> URL needs to be changed (for example, to support mock testing or to support an in-house GitHub Enterprise server), there is a single place to change it. Before Swift 2, a<strong class="calibre2"> class variables are not yet supported </strong>error message may be displayed.</p><p class="calibre8">To use static variables in Swift prior to version 2, a different approach must be used. It is possible to define <em class="calibre11">computed properties</em>, which are not stored but are calculated on demand. These have a <em class="calibre11">getter</em> (also known as an <em class="calibre11">accessor</em>) and optionally a <em class="calibre11">setter</em> (also known as a <em class="calibre11">mutator</em>). The previous example can be rewritten as follows:</p><div><pre class="programlisting">class GitHubRepository {
  class var api:String {
    get {
      return "https://api.github.com"
    }
  }
  func detailsURL() -&gt; String {
    return "\(GitHubRepository.api)/repositories/\(id)"
  }
}</pre></div><p class="calibre8">Although this is logically a read-only constant (there is no associated <code class="literal">set</code> block), it is not possible to define the <code class="literal">let</code> constants with accessors.</p><p class="calibre8">To refer to a class variable, use the type name—which in this case is <code class="literal">GitHubRepository</code>. When the <code class="literal">GitHubRepository.api</code> expression is evaluated, the body of the getter is called.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec44" class="calibre1"/>Subclasses and testing in Swift</h2></div></div></div><p class="calibre8">A <a id="id139" class="calibre1"/>simple <a id="id140" class="calibre1"/>Swift class with no explicit parent is known as a <em class="calibre11">base class</em>. However, classes in Swift frequently <em class="calibre11">inherit</em> from another class by specifying a superclass after the class name. The syntax for this is <code class="literal">class</code> <code class="literal">SubClass:SuperClass{...}</code>.</p><p class="calibre8">Tests in Swift<a id="id141" class="calibre1"/> are written using the <a id="id142" class="calibre1"/>
<strong class="calibre2">XCTest</strong> framework, which <a id="id143" class="calibre1"/>is included by default in Xcode templates. This allows an application to have tests written and then executed in place to confirm that no bugs have been introduced.</p><div><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre8">XCTest replaces the previous testing framework OCUnit.</p></div><p class="calibre8">The <code class="literal">XCTest</code> framework has a base class called <code class="literal">XCTestCase</code> that all tests inherit from. Methods beginning with <code class="literal">test</code> (and that take no arguments) in the test case class are invoked automatically when the tests are run. Test code can indicate success or failure by calling the <code class="literal">XCTAssert*</code> functions, such as <code class="literal">XCTAssertEquals</code> and <code class="literal">XCTAssertGreaterThan</code>.</p><p class="calibre8">Tests for the <code class="literal">GitHubRepository</code> class conventionally exist in a corresponding <code class="literal">GitHubRepositoryTest</code> class, which will be a subclass of <code class="literal">XCTestCase</code>. Create a new Swift file by navigating to <strong class="calibre2">File | New | File...</strong> and choosing a <strong class="calibre2">Swift File</strong> under the <strong class="calibre2">Source</strong> category for <strong class="calibre2">iOS</strong>. Ensure that the <strong class="calibre2">Tests</strong> and <strong class="calibre2">UITests</strong> targets are selected but the application target is not. It can be implemented as follows:</p><div><pre class="programlisting">import XCTest
class GitHubRepositoryTest: XCTestCase {
  func testRepository() {
    let repo = GitHubRepository()
    repo.id = 1
    repo.name = "Grit"
    XCTAssertEqual(
      repo.detailsURL(),
      "https://api.github.com/repositories/1",
      "Repository details"
    )
  }
}</pre></div><p class="calibre8">Make sure that the <code class="literal">GitHubRepositoryTest</code> class is added to the test targets. If not added when the file is<a id="id144" class="calibre1"/> created, it can be done by selecting the file and pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">1</em> to show the <strong class="calibre2">File Inspector</strong>. The checkbox next to the test target should be selected. Tests should <a id="id145" class="calibre1"/>never be added to the main target. The <code class="literal">GitHubRepository</code> class should be added to both test targets:</p><div><img src="img/00028.jpeg" alt="Subclasses and testing in Swift" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When the tests are run by pressing <em class="calibre11">Command</em> + <em class="calibre11">U</em> or by navigating to <strong class="calibre2">Product</strong> | <strong class="calibre2">Test</strong>, the results of the test will be displayed. Changing either the implementation or the expected test result will demonstrate whether the test is being executed correctly.</p><div><h3 class="title2"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre8">Always check whether a failing test causes the build to fail; this will confirm that the test is actually being run. For example, in the <code class="literal">GitHubRepositoryTest</code> class, modify the URL to remove <code class="literal">https</code> from the front and check whether a test failure is shown. There is nothing more useless than a correctly implemented test that never runs.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec45" class="calibre1"/>Protocols in Swift</h2></div></div></div><p class="calibre8">A <strong class="calibre2">protocol</strong>
<a id="id146" class="calibre1"/> is <a id="id147" class="calibre1"/>similar to an interface in other languages; it is a named type that has method signatures but no method implementations. Classes<a id="id148" class="calibre1"/> can implement zero or more protocols; when they do, they are said to <strong class="calibre2">adopt</strong> or <strong class="calibre2">conform</strong> to the protocol. A protocol may have a number of methods that are either <strong class="calibre2">required</strong> (the default) or <strong class="calibre2">optional</strong> (marked with the <code class="literal">optional</code> keyword).</p><div><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre8">Optional protocol methods are only supported when the protocol is marked with the <code class="literal">@objc</code> attribute. This declares that the class will be backed by an <code class="literal">NSObject</code> class for interoperability with Objective-C. Pure Swift protocols cannot have optional methods.</p></div><p class="calibre8">The syntax <a id="id149" class="calibre1"/>to define a protocol looks similar to the following:</p><div><pre class="programlisting">protocol GitHubDetails {
  func detailsURL() -&gt; String
  // protocol needs @objc if using optional protocols
  // optional doNotNeedToImplement()
}</pre></div><div><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre8">Protocols cannot have functions with default arguments. Protocols can be used with the <code class="literal">struct</code>, <code class="literal">class</code>, and <code class="literal">enum</code> types unless the <code class="literal">@objc</code> class attribute is used; in which case, they can only be used against Objective-C classes or enums.</p></div><p class="calibre8">Classes conform to protocols by listing the protocol names after the class name, similar to a superclass.</p><div><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre8">When a class has both a superclass and one or more protocols, the superclass must be listed first.</p></div><div><pre class="programlisting">class GitHubRepository: GitHubDetails {
  func detailsURL() -&gt; String {
    // implementation as before
  }
}</pre></div><p class="calibre8">The <code class="literal">GitHubDetails</code> protocol can be used as a type in the same places as an existing Swift type, such as a variable type, method return type, or argument type.</p><div><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre8">Protocols are widely used in Swift to allow callbacks from frameworks that would, otherwise, not know about specific callback handlers. If a superclass was required instead, then a single class cannot be used to implement multiple callbacks. Common protocols include <code class="literal">UIApplicationDelegate</code>, <code class="literal">Printable</code>, and <code class="literal">Comparable</code>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec46" class="calibre1"/>Enums in Swift</h2></div></div></div><p class="calibre8">The<a id="id150" class="calibre1"/> final <a id="id151" class="calibre1"/>concept to understand in Swift is <em class="calibre11">enumeration</em>, or <em class="calibre11">enum</em> for short. An enum is a closed set of values, such as <code class="literal">North</code>, <code class="literal">East</code>, <code class="literal">South</code>, and <code class="literal">West</code>, or <code class="literal">Up</code>, and <code class="literal">Down</code>.</p><p class="calibre8">An enumeration is defined using the <code class="literal">enum</code> keyword, followed by a type name, and a block, which contains the <code class="literal">case</code> keywords followed by comma-separated values as follows:</p><div><pre class="programlisting">enum Suit {
  case Clubs, Diamonds, Hearts // many on one line
  case Spades // or each on separate lines
}</pre></div><p class="calibre8">Unlike C, enumerated values do not have a specific type by default, so they cannot generally be converted to and from an integer value. Enumerations can be defined with <strong class="calibre2">raw values</strong> that allow conversion to and from integer values. Enum values are assigned to variables using the type name and the <code class="literal">enum</code> name:</p><div><pre class="programlisting">var suit:Suit = Suit.Clubs</pre></div><p class="calibre8">However, if the type of the expression is known, then the type prefix does not need to be explicitly specified; the following form is much more common in Swift code:</p><div><pre class="programlisting">var suit:Suit = .Clubs</pre></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec04" class="calibre1"/>Raw values</h3></div></div></div><p class="calibre8">For <a id="id152" class="calibre1"/>the <code class="literal">enum</code> values that have specific meanings, it is possible to extend the <code class="literal">enum</code> from a different type, such as <code class="literal">Int</code>. These are known as <em class="calibre11">raw values</em>:</p><div><pre class="programlisting">enum Rank: Int {
  case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
  case Jack, Queen, King, Ace
}</pre></div><p class="calibre8">A raw value enum can be converted to and from its raw value with the <code class="literal">rawValue</code> property and the failable initializer <code class="literal">Rank(rawValue:)</code> as follows:</p><div><pre class="programlisting">Rank.Two.rawValue == 2
Rank(rawValue:14)! == .Ace</pre></div><div><h3 class="title2"><a id="tip31" class="calibre1"/>Tip</h3><p class="calibre8">The failable initializer returns an optional <code class="literal">enum</code> value, because the equivalent <code class="literal">Rank</code> may not exist. The expression <code class="literal">Rank(rawValue:0)</code> will return <code class="literal">nil</code>, for example.</p></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec05" class="calibre1"/>Associated values</h3></div></div></div><p class="calibre8">Enums can also have <a id="id153" class="calibre1"/>
<em class="calibre11">associated values</em>, such as a value or case class in other languages. For example, a combination of a <code class="literal">Suit</code> and a <code class="literal">Rank</code> can be combined to form a <code class="literal">Card</code>:</p><div><pre class="programlisting">enum Card {
  case Face(Rank, Suit)
  case Joker
}</pre></div><p class="calibre8">Instances can be created by passing values into an <code class="literal">enum</code> initializer:</p><div><pre class="programlisting">var aceOfSpades: Card = .Face(.Ace,.Spades)
var twoOfHearts: Card = .Face(.Two,.Hearts)
var theJoker: Card = .Joker</pre></div><p class="calibre8">The associated values of an <code class="literal">enum</code> instance cannot be extracted (as they can with properties of a <code class="literal">struct</code>), but the <code class="literal">enum</code> value can be accessed by pattern matching in a <code class="literal">switch</code> statement:</p><div><pre class="programlisting">var card = aceOfSpades // or theJoker or twoOfHearts ...
switch card {
  case .Face(let rank, let suit): 
    print("Got a face card \(rank) of \(suit)");
  case .Joker: 
    print("Got the joker card")
}</pre></div><p class="calibre8">The Swift compiler will require that the <code class="literal">switch</code> statement be exhaustive. As the <code class="literal">enum</code> only contains these two types, no <code class="literal">default</code> block is needed. If another <code class="literal">enum</code> value is added to <code class="literal">Card</code> in the future, the compiler will report an error in this <code class="literal">switch</code> statement.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>Creating a master-detail iOS application</h1></div></div></div><p class="calibre8">Having<a id="id154" class="calibre1"/> covered how classes, protocols, and enums are defined in Swift, a more complex <a id="id155" class="calibre1"/>master-detail application can be created. A master-detail application is a specific type of iOS application that initially presents a master table view, and when an individual element is selected, a secondary details view will show more information about the selected item.</p><p class="calibre8">Using the <strong class="calibre2">Create a new Xcode project</strong> option from the welcome screen, or by navigating to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> | <strong class="calibre2">Project…</strong> or by pressing <em class="calibre11">Command</em> + <em class="calibre11">Shift</em> + <em class="calibre11">N</em>, create a new project and select <strong class="calibre2">Master-Detail Application</strong> from the <strong class="calibre2">iOS Application</strong> category:</p><div><img src="img/00029.jpeg" alt="Creating a master-detail iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">In the <a id="id156" class="calibre1"/>subsequent dialog, enter appropriate values for the project, such as the name (<code class="literal">MasterDetail</code>), the organization identifier (typically based on the reverse DNS name), ensure that the <strong class="calibre2">Language</strong> dropdown reads <strong class="calibre2">Swift</strong> and that it is targeted for <strong class="calibre2">Universal</strong> devices:</p><div><img src="img/00030.jpeg" alt="Creating a master-detail iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When the project is created, an Xcode window will open containing all the files that are created by the wizard itself, including the <code class="literal">MasterDetail.app</code> and <code class="literal">MasterDetailTests.xctest</code> products. The <code class="literal">MasterDetail.app</code> is a bundle that is executed by the simulator or a connected device, while the <code class="literal">MasterDetailTests.xctest</code> and <code class="literal">MasterDetailsUITests.xctest</code> products are used to execute unit tests for the application's code.</p><p class="calibre8">The application can be launched by pressing the triangular play button on the top-left corner of Xcode or by pressing <em class="calibre11">Command</em> + <em class="calibre11">R</em>, which will run the application against the currently selected target.</p><div><img src="img/00031.jpeg" alt="Creating a master-detail iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">After a brief <a id="id157" class="calibre1"/>compile and build cycle, the iOS Simulator will open with a master page that contains an empty table, as shown in the following screenshot:</p><div><img src="img/00032.jpeg" alt="Creating a master-detail iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The default <code class="literal">MasterDetail</code> application can be used to add items to the list by clicking on the add (<strong class="calibre2">+</strong>) button on the top-right corner of the screen. This will add a new timestamped entry to the list.</p><div><img src="img/00033.jpeg" alt="Creating a master-detail iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When this item is clicked, the screen will switch to the details view, which, in this case, presents the time in the center of the screen:</p><div><img src="img/00034.jpeg" alt="Creating a master-detail iOS application" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">This kind of master-detail application is common in iOS applications for displaying a top-level list (such as a shopping list, a set of contacts, to-do notes, and so on) while allowing the user to tap to see the details.</p><p class="calibre8">There are<a id="id158" class="calibre1"/> three main classes in the master-detail application:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">AppDelegate</code> class is defined in the <code class="literal">AppDelegate.swift</code> file, and it is responsible for starting the application and set up the initial state</li><li class="listitem">The <code class="literal">MasterViewController</code> class is defined in the <code class="literal">MasterViewController.swift</code> file, and it is used to manage the first (master) screen's content and interactions</li><li class="listitem">The <code class="literal">DetailViewController</code> class is defined in the <code class="literal">DetailViewController.swift</code> file, and it is used to manage the second (detail) screen's content</li></ul></div><p class="calibre8">In order to understand what the classes do in more detail, the next three sections will present each of them in turn.</p><div><h3 class="title2"><a id="tip32" class="calibre1"/>Tip</h3><p class="calibre8">The code that is generated in this section was created from Xcode 7.0, so the templates might differ slightly if using a different version of Xcode. An exact copy of the corresponding code can be acquired from the Packt website or from this book's GitHub repository at <a class="calibre1" href="https://github.com/alblue/com.packtpub.swift.essentials/">https://github.com/alblue/com.packtpub.swift.essentials/</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec47" class="calibre1"/>The AppDelegate class</h2></div></div></div><p class="calibre8">The <code class="literal">AppDelegate</code> class<a id="id159" class="calibre1"/> is the main entry point to the application. When a set of Swift source files are compiled, if the <code class="literal">main.swift</code> file exists, it is used as the entry point for the application by running that code. However, to simplify setting up an application for iOS, a <code class="literal">@UIApplicationMain</code> special attribute exists that will both synthesize the <code class="literal">main</code> method and set up the associated class as the application delegate.</p><p class="calibre8">The <code class="literal">AppDelegate</code> class <a id="id160" class="calibre1"/>for iOS extends the <code class="literal">UIResponder</code> class, which is the parent of all the UI content on iOS. It also adopts two protocols, <code class="literal">UIApplicationDelegate</code>, and <code class="literal">UISplitViewControllerDelegate</code>, which are used to provide callbacks when certain events occur:</p><div><pre class="programlisting">@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate,
   UISplitViewControllerDelegate {
  var window: UIWindow?
  ...
}</pre></div><div><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre8">On OS X, the <code class="literal">AppDelegate</code> class will be a subclass of <code class="literal">NSApplication</code> and will adopt the <code class="literal">NSApplicationDelegate</code> protocol.</p></div><p class="calibre8">The<a id="id161" class="calibre1"/> synthesized <code class="literal">main</code> function calls the <code class="literal">UIApplicationMain</code> method that reads the <code class="literal">Info.plist</code> file. If the <code class="literal">UILaunchStoryboardName</code> key exists and points to a suitable file (the <code class="literal">LaunchScreen.xib</code> interface file in this case), it will be shown as a splash screen before doing any further work. After the rest of the application has loaded, if the <code class="literal">UIMainStoryboardFile</code> key exists and points to a suitable file (the <code class="literal">Main.storyboard</code> file in this case), the storyboard is launched and the initial view controller is shown.</p><p class="calibre8">The storyboard has <a id="id162" class="calibre1"/>references to the <code class="literal">MasterViewController</code> and <code class="literal">DetailViewController</code> classes. The <code class="literal">window</code> variable is assigned to the storyboard's window.</p><p class="calibre8">The <code class="literal">application:didFinishLaunchingWithOptions</code> is called once the application has started. It is passed with a reference to the <code class="literal">UIApplication</code> instance and a dictionary of options that notifies how the application has been started:</p><div><pre class="programlisting">func application(
 application: UIApplication,
 didFinishLaunchingWithOptions launchOptions:
  [NSObject: AnyObject]?) -&gt; Bool {
  // Override point for customization after application launch.
  ...
}</pre></div><p class="calibre8">In the sample <code class="literal">MasterDetail</code> application, the <code class="literal">application:didFinishLaunchingWithOptions</code> method acquires a reference to the <code class="literal">splitViewController</code> from the explicitly unwrapped optional <code class="literal">window</code>, and the <code class="literal">AppDelegate</code> is set as its delegate:</p><div><pre class="programlisting">let splitViewController = 
 self.window!.rootViewController as! UISplitViewController
splitViewController.delegate = self</pre></div><div><h3 class="title2"><a id="tip33" class="calibre1"/>Tip</h3><p class="calibre8">The <code class="literal">… as! UISplitViewController</code> syntax performs a type cast so that the generic <code class="literal">rootViewController</code> can be assigned to the more specific type; in this case, <code class="literal">UISplitViewController</code>. An alternative version <code class="literal">as?</code> provides a runtime checked cast, and it returns an optional value that either contains the value with the correctly casted type or <code class="literal">nil</code> otherwise. The difference with <code class="literal">as!</code> is a runtime error will occur if the item is not of the correct type.</p></div><p class="calibre8">Finally, a <a id="id163" class="calibre1"/>
<code class="literal">navigationController</code> is acquired from the <code class="literal">splitViewController</code>, which stores an array of <code class="literal">viewControllers</code>. This allows the <code class="literal">DetailView</code> to display a button on the left-hand side to expand the details view if necessary:</p><div><pre class="programlisting">let navigationController = splitViewController.viewController
 [splitViewController.viewControllers.count-1]
 as! UINavigationController
navigationController.topViewController
 .navigationItem.leftBarButtonItem =
 splitViewController.displayModeButtonItem()</pre></div><p class="calibre8">The only<a id="id164" class="calibre1"/> difference this makes is when running on a wide-screen device, such as an iPhone 6 Plus or an iPad, where the views are displayed side-by-side in landscape mode. This is a new feature in iOS 8 applications.</p><div><img src="img/00035.jpeg" alt="The AppDelegate class" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Otherwise, when the device is in portrait mode, it will be rendered as a standard back button:</p><div><img src="img/00036.jpeg" alt="The AppDelegate class" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The method concludes with <code class="literal">return</code> <code class="literal">true</code> to let the OS know that the application has opened successfully.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec48" class="calibre1"/>The MasterViewController class</h2></div></div></div><p class="calibre8">The <a id="id165" class="calibre1"/>
<code class="literal">MasterViewController</code> class is responsible for coordinating the data that is shown on the first screen (when the device is in portrait orientation) or the left-half of the screen (when a large <a id="id166" class="calibre1"/>device is in landscape orientation). This is rendered with a <code class="literal">UITableView</code>, and data is coordinated through the parent <code class="literal">UITableViewController</code> class:</p><div><pre class="programlisting">class MasterViewController: UITableViewController {
  var detailViewcontroller: DetailViewController? = nil
  var objects = [AnyObject]()
  override func viewDidLoad() {…}
  func insertNewObject(sender: AnyObject) {…}
  …
}</pre></div><p class="calibre8">The <code class="literal">viewDidLoad</code> method <a id="id167" class="calibre1"/>is used to set up or initialize the view after it has loaded. In this case, a <code class="literal">UIBarButtonItem</code> is created so that the user can add new entries to the table. The <code class="literal">UIBarButtonItem</code> takes a <code class="literal">@selector</code> in Objective-C, and in Swift is treated as a string literal convertible (so that <code class="literal">"insertNewObject:"</code> will result in a call to the <code class="literal">insertNewObject</code> method). Once created, the button is added to the navigation on the right-hand side, using the standard <code class="literal">.Add</code> type which will be rendered as a <strong class="calibre2">+</strong> sign on the screen:</p><div><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()
  self.navigationItem.leftBarButtonItem = self.editButtonItem()
  let addButton = UIBarButtonItem(
    barButtonSystemItem: .Add, target: self, 
    action: "insertNewObject:")
  self.navigationItem.rightBarButtonItem = addButton
  if let split = self.splitViewController {
    let controllers = split.viewControllers
    self.detailViewController = (controllers[controllers.count-1] as! UINavigationController).topViewController as? DetailViewController
}</pre></div><p class="calibre8">The objects are <code class="literal">NSDate</code> values, and are stored inside the class as an Array of <code class="literal">AnyObject</code> elements. The <code class="literal">insertNewObject</code> method is called when the <strong class="calibre2">+</strong> button is pressed, and it creates a new <code class="literal">NSDate</code> instance which is then inserted into the array. The <code class="literal">sender</code> event is passed as an argument of the <code class="literal">AnyObject</code> type, which will be a reference to the <code class="literal">UIBarButtonItem</code> (although it is not needed or used here):</p><div><pre class="programlisting">func insertNewObject(sender: AnyObject) {
  objects.insertObject(NSDate.date(), atIndex: 0)
  let indexPath = NSIndexPath(forRow: 0, inSection: 0)
  self.tableView.insertRowsAtIndexPaths(
   [indexPath], withRowAnimation: .Automatic)
}</pre></div><div><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">UIBarButtonItem</code> class was created before blocks were available on iOS devices, so it uses the older Objective-C <code class="literal">@selector</code> mechanism. A future release of iOS may provide an alternative that takes a block, in which case Swift functions can be passed instead.</p></div><p class="calibre8">The <a id="id168" class="calibre1"/>parent <a id="id169" class="calibre1"/>class contains a reference to the <code class="literal">tableView</code>, which is automatically created by the storyboard. When an item is inserted, the <code class="literal">tableView</code> is notified that a new object is available. Standard <code class="literal">UITableViewController</code> methods are used to access the data from the array:</p><div><pre class="programlisting">override func numberOfSectionsInTableView(
 tableView: UITableView) -&gt; Int {
  return 1
}
override func tableView(tableView: UITableView,
 numberOfRowsInSection section: Int) -&gt; Int {
  return objects.count
}
override func tableView(tableView: UITableView,
 cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell{
  let cell = tableView.dequeueReusableCellWithIdentifier(
   "Cell", forIndexPath: indexPath)
  let object = objects[indexPath.row] as! NSDate
  cell.textLabel!.text = object.description
  return cell
}
override func tableView(tableView: UITableView,
 canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
  return true
}</pre></div><p class="calibre8">The <code class="literal">numberOfSectionsInTableView</code> function returns <code class="literal">1</code> in this case, but a <code class="literal">tableView</code> can have multiple sections; for example, to permit a contacts application having a different section for A, B, C through Z. The <code class="literal">numberOfRowsInSection</code> method returns the number of elements in each section; in this case, as there is only one section, the number of objects in the array.</p><div><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre8">The reason why each method is called <code class="literal">tableView</code> and takes a <code class="literal">tableView</code> argument is a result of the Objective-C heritage of UIKit. The Objective-C convention combined the method name as the first named argument, so the original method was <code class="literal">[delegate</code> <code class="literal">tableView:UITableView,</code> <code class="literal">numberOfRowsInSection:NSInteger]</code>. As a result, the name of the first argument is reused as the name of the method in Swift.</p></div><p class="calibre8">The <code class="literal">cellForRowAtIndexPath</code> method<a id="id170" class="calibre1"/> is expected to return <code class="literal">UITableViewCell</code> for an object. In this case, a cell is acquired from the <code class="literal">tableView</code> using the <code class="literal">dequeueReusableCellWithIdentifier</code> method (which caches cells as they go off screen to save object instantiation), and then the <code class="literal">textLabel</code> is populated with the object's <code class="literal">description</code> (which is a <code class="literal">String</code> representation of the object; in this case, the date).</p><p class="calibre8">This is <a id="id171" class="calibre1"/>enough to display elements in the table, but in order to permit editing (or just removal, as in the sample application), there are some additional protocol methods that are required:</p><div><pre class="programlisting">override func tableView(tableView: UITableView,
 canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
  return true
}
override func tableView(tableView: UITableView,
 commitEditingStyle editingStyle: UITableViewCellEditingStyle,
 forRowAtIndexPath indexPath: NSIndexPath) {
  if editingStyle == .Delete {
    objects.removeObjectAtIndex(indexPath.row)
    tableView.deleteRowsAtIndexPaths([indexPath],
     withRowAnimation: .Fade)
  }
}</pre></div><p class="calibre8">The <code class="literal">canEditRowAtIndexPath</code> method returns <code class="literal">true</code> if the row is editable; if all the rows can be edited, then this will return <code class="literal">true</code> for all the values.</p><p class="calibre8">The <code class="literal">commitEditingStyle</code> method takes a table, a path, and a style, which is an enumeration that indicates which operation occurred. In this case, <code class="literal">UITableViewCellEditingStyle.Delete</code> is passed in order to delete the item from both the underlying object array and also from the <code class="literal">tableView</code>. (The enumeration can be abbreviated to <code class="literal">.Delete</code> because the type of <code class="literal">editingStyle</code> is known to be <code class="literal">UITableViewCellEditingStyle</code>.)</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec49" class="calibre1"/>The DetailViewController class</h2></div></div></div><p class="calibre8">The <a id="id172" class="calibre1"/>detail view is shown <a id="id173" class="calibre1"/>when an element is selected in the <code class="literal">MasterViewController</code>. The transition is managed by the storyboard controller; the views are connected with a <em class="calibre11">segue</em> (pronounced <em class="calibre11">seg-way</em>; the product of the same name based it on the word <em class="calibre11">segue</em> which is derived from the Italian word for <em class="calibre11">follows</em>).</p><p class="calibre8">To pass the selected item between controllers, a property exists in the <code class="literal">DetailViewController</code> class called <code class="literal">detailItem</code>. When the value is changed, additional code is run, which is implemented in a <code class="literal">didSet</code> property notification:</p><div><pre class="programlisting">class DetailViewController: UIViewController {
  var detailItem: AnyObject? {
    didSet {
      self.configureView()
    }
  }
  … 
}</pre></div><p class="calibre8">When <code class="literal">DetailViewController</code> has the <code class="literal">detailItem</code> set, the <code class="literal">configureView</code> method will be invoked. The <code class="literal">didSet</code> body is run after the value has been changed, but before the setter returns to the caller. This is triggered by the <code class="literal">segue</code> in the <code class="literal">MasterViewController</code>:</p><div><pre class="programlisting">class MasterViewController: UIViewController {
  …
  override func prepareForSegue(
   segue: UIStoryboardSegue, sender: AnyObject?) {
    super.prepareForSegue(segue, sender: sender)
    if segue.identifier == "showDetail" {
      if let indexPath = 
       self.tableView.indexPathForSelectedRow() {
        let object = objects[indexPath.row] as! NSDate
        let controller = (segue.destinationViewController 
         as! UINavigationController)
         .topViewController as! DetailViewController
        <strong class="calibre2">controller.detailItem = object</strong>
        controller.navigationItem.leftBarButtonItem =
         self.splitViewController?.displayModeButtonItem()
        controller.navigationItem.leftItemsSupplementBackButton =
         true
      }
    } 
  }
}</pre></div><p class="calibre8">The <code class="literal">prepareForSegue</code> method is called when the user selects an item in the table. In this case, it grabs the selected row index from the table and uses this to acquire the selected date object. The navigation controller hierarchy is searched to acquire the <code class="literal">DetailViewController</code>, and once this has been obtained, the selected value is set with <code class="literal">controller.detailItem</code> <code class="literal">=</code> <code class="literal">object</code>, which triggers the update.</p><p class="calibre8">The label is <a id="id174" class="calibre1"/>ultimately displayed in the <code class="literal">DetailViewController</code> through the <code class="literal">configureView</code> method, which stamps the <code class="literal">description</code> of the object onto the <code class="literal">label</code> in the center:</p><div><pre class="programlisting">class DetailViewController {
  ...
  @IBOutlet weak var detailDescriptionLabel: UILabel!
  function configureView() {
    if let detail: AnyObject = self.detailItem {
      if let label = self.detailDescriptionLabel {
        label.text = detail.description
      }
    }
  }
}</pre></div><p class="calibre8">The <code class="literal">configureView</code> method is called both when the <code class="literal">detailItem</code> is changed and when the view is loaded for the first time. If the <code class="literal">detailItem</code> has not been set, then this has no effect.</p><p class="calibre8">The implementation introduces <a id="id175" class="calibre1"/>some new concepts, which are worth highlighting:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">@IBOutlet</code> attribute indicates that the property will be exposed in interface builder and can be wired up to the object instance. This will be covered in more detail in <a class="calibre1" title="Chapter 4. Storyboard Applications with Swift and iOS" href="part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b">Chapter 4</a>, <em class="calibre11">Storyboard Applications with Swift and iOS</em>, and in <a class="calibre1" title="Chapter 5. Creating Custom Views in Swift" href="part0039_split_000.html#1565U1-d7e55eb5242648e89c396442afe4f84b">Chapter 5</a>, <em class="calibre11">Creating Custom Views in Swift</em>.</li><li class="listitem">The <code class="literal">weak</code> attribute indicates that the property will not store a <em class="calibre11">strong</em> reference to the object; in other words, the detail view will not own the object but merely reference it. Generally, all <code class="literal">@IBOutlet</code> references should be declared as <code class="literal">weak</code> to avoid cyclic dependency references.</li><li class="listitem">The type is defined as <code class="literal">UILabel!</code> which is an <em class="calibre11">implicitly unwrapped optional</em>. When accessed, it performs an explicit unwrapping of the optional value; otherwise the <code class="literal">@IBOutlet</code> will be wired up as a <code class="literal">UILabel?</code> optional type. Implicitly unwrapped optional types are used when the variable is known to never be <code class="literal">nil</code> at runtime, which is usually the case for the <code class="literal">@IBOutlet</code> references. Generally, all <code class="literal">@IBOutlet</code> references should be implicitly unwrapped optionals.</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter presented two sample iOS applications; one in which the UI was created programmatically, and another in which the UI was loaded from a storyboard. Together with an overview of classes, protocols, and enums, and an explanation of how iOS applications start, this chapter gives a springboard to understand the Xcode templates that are frequently used to start new projects.</p><p class="calibre8">The next chapter, <em class="calibre11">Storyboard Applications with Swift and iOS</em>, will go into more detail about how storyboards are created and how an application can be built from scratch.</p></div></body></html>