- en: Chapter 8. Adding Physics with UIKit Dynamics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover the basics of how UIKit Dynamics manages your application's
    behaviors. We will cover specific behaviors, such as gravity, bounce, and other
    physics properties. Additionally, we will learn how to create physical boundaries
    so that our views have something to collide with. Without these boundaries, our
    views would continue moving forever without stopping. We will cover how our views
    will interact with one another, including collision detection/notifications and
    attaching views to one another. Lastly, we will talk about motion effects and
    about creating a parallax effect similar to iOS 7's home screen that moves when
    tilting your device. We have a lot to cover, so let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Motion and physics in UIKit
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the introduction of iOS 7, Apple completely removed the skeuomorphic design
    that has been used since the introduction of the iPhone and iOS. In its place
    is a new and refreshing flat design that features muted gradients and minimal
    interface elements. Apple has strongly encouraged developers to move away from
    a skeuomorphic and real-world-based design in favor of these flat designs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Although we are guided away from a real-world *look*, Apple also strongly encourages
    that your user interface have a real-world *feel*. Some may think this is a contradiction;
    however, the goal is to give users a deeper connection to the user interface.
    UI elements that respond to touch, gestures, and changes in orientation are examples
    of how to apply this new design paradigm. In order to help assist in this new
    design approach, Apple has introduced two very nifty APIs, UIKit Dynamics and
    Motion Effects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: UIKit Dynamics
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put it simply, iOS 7 has a fully featured physics engine built into UIKit.
    You can manipulate specific properties to provide a more real-world feel to your
    interface. This includes gravity, springs, elasticity, bounce, and force to name
    a few. Each interface item will contain its own properties and the dynamic engine
    will abide by these properties.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Motion effects
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the coolest features of iOS 7 on our devices is the parallax effect found
    on the home screen. Tilting the device in any direction will pan the background
    image to emphasize depth. Using motion effects, we can monitor the data supplied
    by the device's accelerometer to adjust our interface based on movement and orientation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: By combining these two features, you can create great looking interfaces with
    a realistic feel that brings it to life. To demonstrate UIKit Dynamics, we will
    be adding some code to our `FoodDetailViewController.m` file to create some nice
    effects and animations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Adding gravity
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `FoodDetailViewController.m` and add the following instance variables
    to the view controller:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Scroll to `viewDidLoad` and add the following code to the bottom of the method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the application, open the **My Foods** view, select a food item from the
    table view, and watch what happens. The food image should start to accelerate
    towards the bottom of the screen until it eventually falls off the screen, as
    shown in the following set of screenshots:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding gravity](img/0319OT_08_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Let's go over the code, specifically the two new classes that were just introduced,
    `UIDynamicAnimator` and `UIGravityBehavior`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: UIDynamicAnimator
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the core component of UIKit Dynamics. It is safe to say that the dynamic
    animator is the physics engine itself wrapped in a convenient and easy-to-use
    class. The animator will do nothing on its own, but instead keep track of behaviors
    assigned to it. Each behavior will interact inside of this physics engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: UIGravityBehavior
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behaviors are the core compositions of UIKit Dynamics animation. These behaviors
    all define individual responses to the physics environment. This particular behavior
    mimics the effects of gravity by applying force. Each behavior is associated with
    a view (or views) when created. Because you explicitly define this property, you
    can control which views will perform the behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Behavior properties
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost all behaviors have multiple properties that can be adjusted to the desired
    effect. A good example is the gravity behavior. We can adjust its angle and magnitude.
    Add the following code before adding the behavior to the animator:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the application and test it to see what happens. The picture view will
    start to fall; however, this time it will be at a much slower rate. Replace the
    preceding code line with the following line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the application, and this time you will notice that the image falls much
    faster. Feel free to play with these properties and get a feel for each value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creating boundaries
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with gravity, UIKit Dynamics does not conform to the boundaries
    of the screen. Although it is not visible, the food image continues to fall after
    it has passed the edge of the screen. It will continue to fall unless we set boundaries
    that will contain the image view. At the top of the file, create another instance
    variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now in our `viewDidLoad` method, add the following code below our gravity code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are creating an instance of a new class (which is a behavior), `UICollisionBehavior`.
    Just like our gravity behavior, we associate this behavior with our food image
    view.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Rather than explicitly defining the coordinates for the boundary, we use the
    convenient `translatesReferenceBoundsIntoBoundary` property on our collision behavior.
    By setting this property to `yes`, the boundary will be defined by the bounds
    of the reference view that we set when allocating our UIDynamics animator. Because
    the reference view is `self.view`, the boundary is now the visible space of our
    view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and watch how the image will fall, but stop once it reaches
    the bottom of the screen, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating boundaries](img/0319OT_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Collisions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our image view responding to gravity and our screen bounds we can start
    detecting collisions. You may have noticed that when the image view is falling,
    it falls right through our two labels below it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This is because UIKit Dynamics will only respond to `UIView` elements that have
    been assigned behaviors. Each behavior can be assigned to multiple objects, and
    each object can have multiple behaviors. Because our labels have no behaviors
    associated with them, the UIKit Dynamics physics engine simply ignores it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the food image view collide with the date label. To do this, we
    simply need to add the label to the collision behavior allocation call. Here is
    what the new code looks like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, all we have done is add `self.foodDateLabel` to the `initWithItems`
    array property. As mentioned before, any single behavior can be associated with
    multiple items. Run your code and see what happens. When the image falls, it hits
    the date label but continues to fall, pushing the date label with it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Because we didn't associate the gravity behavior with the label, it does not
    fall immediately. Although it does not respond to gravity, the label will still
    be moved because it is a physics object after all. This approach is not ideal,
    so let's use another awesome feature of UIKit Dynamics, invisible boundaries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Creating invisible boundaries
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to take a slightly different approach to this problem. Our label
    is only a point of reference for where we want to add a boundary that will stop
    our food image view. Because of this, the label does not need to be associated
    with any UIKit Dynamic behaviors. Remove `self.foodDateLabel` from the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, add the following code to the bottom of `viewDidLoad` but before we
    add our collision behavior to the animator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we add a boundary to the collision behavior and pass some parameters. First
    we define an identifier, which we will use later, and then we pass the food date
    label's origin as the `fromPoint` property. The `toPoint` property is set to the
    CGPoint we created using the food date label's frame.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the application, and you will see that the food image will
    now stop at the invisible boundary we defined. The label is still visible to the
    user, but the dynamic animator ignores it. Instead the animator sees the barrier
    we defined and responds accordingly, even though the barrier is invisible to the
    user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a side-by-side comparison of the before and after:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating invisible boundaries](img/0319OT_08_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Dynamic items
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using UIKit Dynamics, it is important to understand what UIKit Dynamics
    items are. Rather than referencing dynamics as views, they are referenced as items,
    which adhere to the `UIDynamicItem` protocol. This protocol defines the center,
    transform, and bounds of any object that adheres to this protocol. `UIView` is
    the most common class that adheres to the `UIDynamicItem` protocol. Another example
    of a class that conforms to this protocol is the `UICollectionViewLayoutAttributes`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating item properties
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, UIDynamics items have properties that can be manipulated
    and applied to multiple views/items in your interface. Let's see what it looks
    like to adjust the elasticity property and apply it to our food image view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to `viewDidLoad` and add the following code to its end:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create a `UIDynamicItemBehavior` instance and initialize it with our
    `self.foodImageView`. Next, we set the elasticity property and then add this new
    behavior to our animator. Go ahead and run your code, and watch how the food image
    view will now bounce a few extra times. Play with the elasticity value to see
    different results.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Elasticity is one of the many behaviors that can be altered. The following
    is a list of all the properties available with `UIDynamicItemBehavior`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticity**: This property will define how elastic a collision is. The best
    way to remember this is how bouncy the object will be. The higher the value, the
    more an item will bounce.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction**: If an object slides across another surface, the friction property
    is used to determine how much resistance the object receives.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Density**: This sets the overall simulated mass of the item. As with real
    physics, the higher the mass, the more the force required to move an item. One
    example of how to keep an item from moving when collided with is to give it a
    very high-density compared to the other items colliding with it.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resistance**: This is the resistance applied to any movement, not just sliding
    across another surface as in the case of friction.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**angularResistance**: When an item rotates, this property will determine the
    resistance to the rotation.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**allowsRotation**: An optional property to keep an item from rotating, regardless
    of what collisions and forces affect it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision notifications
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have set up gravity and added some boundaries, including an invisible
    boundary for our date label. It is very common to respond to collisions by performing
    some sort of task. For instance, in a game, once an enemy collides with a bullet,
    we would destroy the enemy and increase the score.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'We can track collisions by using collision notifications. In order to do so,
    we must have our class adopt `UICollisionBehaviorDelegate`. Switch to `FoodDetailViewController.h`
    and add the following protocol:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now switch back to `FoodDetailViewController.m` and locate the code we wrote
    to create the collision behavior. Add the following line of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By setting the collision delegate, we can now use the following delegate method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This delegate method gets called every time a collision occurs, and we have
    set it up to output the collision identifier we defined earlier. Run the code,
    and your console output should look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision notifications](img/0319OT_08_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Using a combination of identifiers and other properties passed to this delegate
    method, we can detect which collisions are happening and respond accordingly.
    For example, let''s animate the alpha of the food image view when a collision
    occurs. Replace your delegate method code with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we cast the identifier as an `NSString` and then check if it is equal to
    the collision identifier we want. If so, we perform a simple `UIView` animation
    that sets the `alpha` value of the image view to zero, thus making it invisible.
    Using this delegate method properly will allow you to accomplish a large number
    of tasks based on collisions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Attaching items to other items
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to gravity and other physics properties, UIKit Dynamics also allows
    your physics objects to interact with one another as they would in the real physical
    world. For example, we can use the `UIAttachmentBehavior` method to link items
    together as if they are attached with an invisible brace. Let's have our application
    create a new square view and then attach it to our food image view, but only when
    a collision occurs. Because our food image view will bounce a couple of times,
    the collision will be detected each time. To keep from creating multiple squares,
    let's create another instance variable to keep track of the first bounce.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code in the implementation block in `FoodDetailViewController.m`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now replace our delegate method code with the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we detect if the `firstBounce` Boolean value is not `YES`, and then create
    a new `UIView`, add the gravity and collision items to it, use the `UIAttachmentBehavior`
    method, and attach this new view to our food image view. Run the application,
    and you will see that on the first bounce, a green square is created. Because
    we attach this new view to the food image view, you will see that as it bounces
    the second and third times, the square view moves with it as if attached.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Snapping items
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last behavior we will cover in this book is the `UISnapBehavior` class.
    UIKit Dynamics provides a built-in behavior that will snap an item from its starting
    point to a specified end point with built-in damping. Let's have our food image
    view snap from the top of the screen into its final position.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to `viewDidLoad` and remove all of our gravity and collision code (keep
    our animator). Add the following code to `viewDidLoad`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we allocate new `UISnapBehavior` and `init` options with our food image
    view. We also pass the point we want the item to snap to, in this case, the final
    position of the image view. We set the damping value to be a bit higher to give
    a milder spring effect (the lower the number, the more springy the item will be).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do is to change the starting point of the food image view.
    Switch to **Main.storyboard** and drag the food image view to the top of the screen
    as high as you wish (even offscreen). It is important to note that the greater
    the distance of the starting point to the end point, the more springy the snap,
    so take this into consideration when setting the `damping` property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Run our application and see the results. The food image view should snap into
    place with a nice spring effect. As you can see, using UIKit Dynamics is not only
    simple, but can be very powerful.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Using motion in our app
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to UIKit Dynamics, we can also use `UIMotionEffects` to adjust the
    user interface when a device is tilted horizontally. `UIMotionEffects` is an abstract
    class that works best when subclassed. Apple has already made a subclass of `UIMotionEffects`
    that will cover almost all use cases of motion in your apps. This subclass is
    the `UIInterpolatingMotionEffect` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `UIInterpolatingMotionEffect` instance is initialized with a key path and
    a type. The type is what defines vertical and horizontal motions. The class will
    automatically set the key value path based on the device's movements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `viewDidLoad` method, add the following code at the bottom:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we create our `UIInterpolatingMotionEffect` instance and assign it to the
    horizontal axis motion tracking. Next we set a minimum and maximum relative value.
    This determines how much the items will move left and right to simulate the parallax
    effect we want. Lastly, we add the motion effect to all views that we want. Our
    `keyPath` value can be assigned to a number of different values for different
    effects. Run the application on a device and select a food item's detailed view
    to see the results!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can go further by grouping multiple motion effects together,
    such as both vertical and horizontal motions. Replace the preceding code with
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we simply duplicate the horizontal motion effect, but we set `keyPath`
    to `center.y` and `type` to `vertical`. Run the application and check out the
    results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: As great and easy as these effects are, be careful not to go overboard. Each
    of the items discussed in this chapter is designed to add subtle effects that
    work together for an overall better user experience.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have done it! From start to finish, we have built a fully functional application
    using many of the great new features of iOS 7 and Xcode 5\. In this chapter, we
    topped everything off by adding some cool physical properties to our views. Stacking
    these behaviors and motion effects together can create some really unique interface
    effects. Now that we are at the conclusion of this book, you should be very comfortable
    stepping into iOS 7 development. Taking advantage of all the new features is the
    first step to building better applications with a better experience!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！从开始到结束，我们使用iOS 7和Xcode 5的许多新特性构建了一个功能齐全的应用程序。在这一章中，我们给我们的视图添加了一些酷炫的物理属性。将这些行为和动态效果叠加在一起，可以创造出一些非常独特的界面效果。现在，随着这本书的结束，你应该非常熟悉iOS
    7的开发了。利用所有这些新特性是构建具有更好体验的更好应用程序的第一步！
