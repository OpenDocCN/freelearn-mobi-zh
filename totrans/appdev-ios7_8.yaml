- en: Chapter 8. Adding Physics with UIKit Dynamics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用UIKit Dynamics添加物理效果
- en: This chapter will cover the basics of how UIKit Dynamics manages your application's
    behaviors. We will cover specific behaviors, such as gravity, bounce, and other
    physics properties. Additionally, we will learn how to create physical boundaries
    so that our views have something to collide with. Without these boundaries, our
    views would continue moving forever without stopping. We will cover how our views
    will interact with one another, including collision detection/notifications and
    attaching views to one another. Lastly, we will talk about motion effects and
    about creating a parallax effect similar to iOS 7's home screen that moves when
    tilting your device. We have a lot to cover, so let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍UIKit Dynamics如何管理应用程序的行为的基础知识。我们将涵盖特定的行为，如重力、弹跳和其他物理属性。此外，我们还将学习如何创建物理边界，以便我们的视图可以与之碰撞。如果没有这些边界，我们的视图将永远继续移动而不会停止。我们将介绍我们的视图将如何相互交互，包括碰撞检测/通知和将视图相互连接。最后，我们将讨论动态效果以及创建类似于iOS
    7主屏幕的视差效果，当倾斜设备时，该效果会移动。我们有很多内容要介绍，所以让我们开始吧！
- en: Motion and physics in UIKit
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIKit中的运动和物理
- en: With the introduction of iOS 7, Apple completely removed the skeuomorphic design
    that has been used since the introduction of the iPhone and iOS. In its place
    is a new and refreshing flat design that features muted gradients and minimal
    interface elements. Apple has strongly encouraged developers to move away from
    a skeuomorphic and real-world-based design in favor of these flat designs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着iOS 7的推出，苹果完全移除了自iPhone和iOS推出以来一直使用的拟物化设计。取而代之的是一种新颖且清新的扁平化设计，其特点为柔和的渐变和最少的界面元素。苹果强烈鼓励开发者远离拟物化和基于现实世界的界面设计，转而采用这些扁平化设计。
- en: Although we are guided away from a real-world *look*, Apple also strongly encourages
    that your user interface have a real-world *feel*. Some may think this is a contradiction;
    however, the goal is to give users a deeper connection to the user interface.
    UI elements that respond to touch, gestures, and changes in orientation are examples
    of how to apply this new design paradigm. In order to help assist in this new
    design approach, Apple has introduced two very nifty APIs, UIKit Dynamics and
    Motion Effects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们被引导远离现实世界的**外观**，但苹果也强烈鼓励你的用户界面具有现实世界的**感觉**。有些人可能会认为这是矛盾的；然而，目标是让用户与用户界面建立更深的联系。对触摸、手势和方向变化做出响应的UI元素是应用这种新设计范例的例子。为了帮助辅助这种新的设计方法，苹果引入了两个非常巧妙的API，即UIKit
    Dynamics和动态效果。
- en: UIKit Dynamics
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UIKit Dynamics
- en: To put it simply, iOS 7 has a fully featured physics engine built into UIKit.
    You can manipulate specific properties to provide a more real-world feel to your
    interface. This includes gravity, springs, elasticity, bounce, and force to name
    a few. Each interface item will contain its own properties and the dynamic engine
    will abide by these properties.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，iOS 7在UIKit中集成了一个功能齐全的物理引擎。你可以操作特定的属性，为你的界面提供更真实世界的感受。这包括重力、弹簧、弹性、弹跳和力等。每个界面元素都将包含其自身的属性，动态引擎将遵循这些属性。
- en: Motion effects
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态效果
- en: One of the coolest features of iOS 7 on our devices is the parallax effect found
    on the home screen. Tilting the device in any direction will pan the background
    image to emphasize depth. Using motion effects, we can monitor the data supplied
    by the device's accelerometer to adjust our interface based on movement and orientation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设备上，iOS 7最酷的功能之一是主屏幕上的视差效果。将设备向任何方向倾斜都会平移背景图像以强调深度。通过使用动态效果，我们可以监控设备加速度计提供的数据，根据运动和方向调整我们的界面。
- en: By combining these two features, you can create great looking interfaces with
    a realistic feel that brings it to life. To demonstrate UIKit Dynamics, we will
    be adding some code to our `FoodDetailViewController.m` file to create some nice
    effects and animations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这两个功能，你可以创建出看起来很棒、感觉真实的界面，使其栩栩如生。为了演示UIKit Dynamics，我们将在`FoodDetailViewController.m`文件中添加一些代码来创建一些很好的效果和动画。
- en: Adding gravity
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加重力
- en: 'Open `FoodDetailViewController.m` and add the following instance variables
    to the view controller:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`FoodDetailViewController.m`文件，并将以下实例变量添加到视图控制器中：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Scroll to `viewDidLoad` and add the following code to the bottom of the method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到`viewDidLoad`方法底部，并添加以下代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the application, open the **My Foods** view, select a food item from the
    table view, and watch what happens. The food image should start to accelerate
    towards the bottom of the screen until it eventually falls off the screen, as
    shown in the following set of screenshots:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，打开 **我的食物** 视图，从表格视图中选择一个食物项，观察会发生什么。食物图片应该开始加速向屏幕底部移动，直到最终从屏幕上掉落，如下面的截图所示：
- en: '![Adding gravity](img/0319OT_08_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![添加重力](img/0319OT_08_01.jpg)'
- en: Let's go over the code, specifically the two new classes that were just introduced,
    `UIDynamicAnimator` and `UIGravityBehavior`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下代码，特别是刚刚介绍的两个新类，`UIDynamicAnimator` 和 `UIGravityBehavior`。
- en: UIDynamicAnimator
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIDynamicAnimator
- en: This is the core component of UIKit Dynamics. It is safe to say that the dynamic
    animator is the physics engine itself wrapped in a convenient and easy-to-use
    class. The animator will do nothing on its own, but instead keep track of behaviors
    assigned to it. Each behavior will interact inside of this physics engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 UIKit Dynamics 的核心组件。可以说，动态动画器本身就是一个物理引擎，被封装在一个方便且易于使用的类中。动画器本身不会做任何事情，而是跟踪分配给它的行为。每个行为都会在这个物理引擎内部进行交互。
- en: UIGravityBehavior
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIGravityBehavior
- en: Behaviors are the core compositions of UIKit Dynamics animation. These behaviors
    all define individual responses to the physics environment. This particular behavior
    mimics the effects of gravity by applying force. Each behavior is associated with
    a view (or views) when created. Because you explicitly define this property, you
    can control which views will perform the behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 行为是 UIKit Dynamics 动画的核心组成部分。这些行为都定义了个体对物理环境的响应。这个特定的行为通过施加力来模拟重力效果。每个行为在创建时都与一个视图（或多个视图）相关联。由于你明确地定义了这个属性，你可以控制哪些视图将执行该行为。
- en: Behavior properties
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为属性
- en: 'Almost all behaviors have multiple properties that can be adjusted to the desired
    effect. A good example is the gravity behavior. We can adjust its angle and magnitude.
    Add the following code before adding the behavior to the animator:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有行为都有多个可以调整以达到所需效果的属性。一个很好的例子是重力行为。我们可以调整其角度和大小。在将行为添加到动画器之前添加以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the application and test it to see what happens. The picture view will
    start to fall; however, this time it will be at a much slower rate. Replace the
    preceding code line with the following line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并测试它，看看会发生什么。图片视图将开始下落；然而，这次下落的速度要慢得多。将前面的代码行替换为以下行：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the application, and this time you will notice that the image falls much
    faster. Feel free to play with these properties and get a feel for each value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，这次你会注意到图片下落得更快。你可以随意调整这些属性，感受每个值。
- en: Creating boundaries
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建边界
- en: 'When dealing with gravity, UIKit Dynamics does not conform to the boundaries
    of the screen. Although it is not visible, the food image continues to fall after
    it has passed the edge of the screen. It will continue to fall unless we set boundaries
    that will contain the image view. At the top of the file, create another instance
    variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理重力时，UIKit Dynamics 不遵循屏幕的边界。尽管它不可见，食物图片在穿过屏幕边缘后仍然继续下落。除非我们设置包含图片视图的边界，否则它将继续下落。在文件顶部创建另一个实例变量：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now in our `viewDidLoad` method, add the following code below our gravity code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `viewDidLoad` 方法中，在我们的重力代码下方添加以下代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are creating an instance of a new class (which is a behavior), `UICollisionBehavior`.
    Just like our gravity behavior, we associate this behavior with our food image
    view.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新类（这是一个行为）的实例，`UICollisionBehavior`。就像我们的重力行为一样，我们将这个行为与我们的食物图片视图相关联。
- en: Rather than explicitly defining the coordinates for the boundary, we use the
    convenient `translatesReferenceBoundsIntoBoundary` property on our collision behavior.
    By setting this property to `yes`, the boundary will be defined by the bounds
    of the reference view that we set when allocating our UIDynamics animator. Because
    the reference view is `self.view`, the boundary is now the visible space of our
    view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是明确地定义边界的坐标，而是使用碰撞行为上的方便的 `translatesReferenceBoundsIntoBoundary` 属性。通过将此属性设置为
    `yes`，边界将由我们分配 UIDynamics 动画器时设置的参考视图的边界定义。因为参考视图是 `self.view`，所以边界现在是视图的可视空间。
- en: 'Run the application and watch how the image will fall, but stop once it reaches
    the bottom of the screen, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并观察图片如何下落，但一旦到达屏幕底部就停止，如下面的截图所示：
- en: '![Creating boundaries](img/0319OT_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![创建边界](img/0319OT_08_02.jpg)'
- en: Collisions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞
- en: With our image view responding to gravity and our screen bounds we can start
    detecting collisions. You may have noticed that when the image view is falling,
    it falls right through our two labels below it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的图像视图对重力以及屏幕边界做出响应，我们可以开始检测碰撞。你可能已经注意到，当图像视图下落时，它会直接穿过其下方的两个标签。
- en: This is because UIKit Dynamics will only respond to `UIView` elements that have
    been assigned behaviors. Each behavior can be assigned to multiple objects, and
    each object can have multiple behaviors. Because our labels have no behaviors
    associated with them, the UIKit Dynamics physics engine simply ignores it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为UIKit Dynamics只会对被分配了行为的`UIView`元素做出响应。每个行为可以被分配给多个对象，每个对象也可以有多个行为。由于我们的标签没有与之关联的行为，UIKit
    Dynamics物理引擎简单地忽略它。
- en: 'Let''s make the food image view collide with the date label. To do this, we
    simply need to add the label to the collision behavior allocation call. Here is
    what the new code looks like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让食物图像视图与日期标签发生碰撞。为此，我们只需将标签添加到碰撞行为分配调用中。以下是新代码的示例：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, all we have done is add `self.foodDateLabel` to the `initWithItems`
    array property. As mentioned before, any single behavior can be associated with
    multiple items. Run your code and see what happens. When the image falls, it hits
    the date label but continues to fall, pushing the date label with it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们所做的只是将`self.foodDateLabel`添加到`initWithItems`数组属性中。如前所述，任何单一的行为都可以与多个项目关联。运行你的代码，看看会发生什么。当图像下落时，它会击中日期标签，但继续下落，推动日期标签。
- en: Because we didn't associate the gravity behavior with the label, it does not
    fall immediately. Although it does not respond to gravity, the label will still
    be moved because it is a physics object after all. This approach is not ideal,
    so let's use another awesome feature of UIKit Dynamics, invisible boundaries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有将重力行为与标签关联，它不会立即下落。尽管它不会对重力做出反应，但标签仍然会被移动，因为毕竟它是一个物理对象。这种方法并不理想，所以让我们使用UIKit
    Dynamics的另一个酷炫功能，不可见边界。
- en: Creating invisible boundaries
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建不可见边界
- en: 'We are going to take a slightly different approach to this problem. Our label
    is only a point of reference for where we want to add a boundary that will stop
    our food image view. Because of this, the label does not need to be associated
    with any UIKit Dynamic behaviors. Remove `self.foodDateLabel` from the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取一种稍微不同的方法来解决这个问题。我们的标签只是我们想要添加一个将阻止食物图像视图停止的边界的参考点。因此，标签不需要与任何UIKit Dynamic行为相关联。从以下代码中移除`self.foodDateLabel`：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, add the following code to the bottom of `viewDidLoad` but before we
    add our collision behavior to the animator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将以下代码添加到`viewDidLoad`的底部，但在我们向动画器添加碰撞行为之前：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we add a boundary to the collision behavior and pass some parameters. First
    we define an identifier, which we will use later, and then we pass the food date
    label's origin as the `fromPoint` property. The `toPoint` property is set to the
    CGPoint we created using the food date label's frame.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向碰撞行为添加一个边界并传递一些参数。首先我们定义一个标识符，稍后我们将使用它，然后我们传递食物日期标签的原点作为`fromPoint`属性。`toPoint`属性设置为使用食物日期标签的框架创建的CGPoint。
- en: Go ahead and run the application, and you will see that the food image will
    now stop at the invisible boundary we defined. The label is still visible to the
    user, but the dynamic animator ignores it. Instead the animator sees the barrier
    we defined and responds accordingly, even though the barrier is invisible to the
    user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你会看到食物图像现在会在我们定义的不可见边界处停止。标签对用户仍然可见，但动态动画器会忽略它。相反，动画器看到我们定义的障碍物，并相应地做出反应，尽管障碍物对用户来说是不可见的。
- en: 'Here is a side-by-side comparison of the before and after:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前后对比：
- en: '![Creating invisible boundaries](img/0319OT_08_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![创建不可见边界](img/0319OT_08_03.jpg)'
- en: Dynamic items
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态元素
- en: When using UIKit Dynamics, it is important to understand what UIKit Dynamics
    items are. Rather than referencing dynamics as views, they are referenced as items,
    which adhere to the `UIDynamicItem` protocol. This protocol defines the center,
    transform, and bounds of any object that adheres to this protocol. `UIView` is
    the most common class that adheres to the `UIDynamicItem` protocol. Another example
    of a class that conforms to this protocol is the `UICollectionViewLayoutAttributes`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用UIKit Dynamics时，了解UIKit Dynamics项目非常重要。它们不是作为视图引用动力学，而是作为项目引用，这些项目遵循`UIDynamicItem`协议。这个协议定义了遵循此协议的任何对象的中心、变换和边界。`UIView`是最常见的遵循`UIDynamicItem`协议的类。另一个符合此协议的类的例子是`UICollectionViewLayoutAttributes`类。
- en: Manipulating item properties
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作项目属性
- en: As mentioned before, UIDynamics items have properties that can be manipulated
    and applied to multiple views/items in your interface. Let's see what it looks
    like to adjust the elasticity property and apply it to our food image view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，UIDynamics项目具有可以操作并应用于界面中多个视图/项目的属性。让我们看看调整弹性属性并将其应用于我们的食物图像视图会是什么样子。
- en: 'Scroll to `viewDidLoad` and add the following code to its end:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到`viewDidLoad`并在其末尾添加以下代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create a `UIDynamicItemBehavior` instance and initialize it with our
    `self.foodImageView`. Next, we set the elasticity property and then add this new
    behavior to our animator. Go ahead and run your code, and watch how the food image
    view will now bounce a few extra times. Play with the elasticity value to see
    different results.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`UIDynamicItemBehavior`实例，并用我们的`self.foodImageView`初始化它。然后我们设置弹性属性，然后将这种新行为添加到我们的动画器中。运行你的代码，看看食物图像视图现在会多弹跳几次。调整弹性值以查看不同的结果。
- en: 'Elasticity is one of the many behaviors that can be altered. The following
    is a list of all the properties available with `UIDynamicItemBehavior`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是许多可以改变的行为之一。以下是一个使用`UIDynamicItemBehavior`的所有可用属性的列表：
- en: '**Elasticity**: This property will define how elastic a collision is. The best
    way to remember this is how bouncy the object will be. The higher the value, the
    more an item will bounce.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这个属性将定义碰撞的弹性。最好的记住方式是看物体有多弹。值越高，项目就会弹得越远。'
- en: '**Friction**: If an object slides across another surface, the friction property
    is used to determine how much resistance the object receives.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦**：如果一个物体在另一个表面上滑动，摩擦属性用于确定物体所受到的阻力有多大。'
- en: '**Density**: This sets the overall simulated mass of the item. As with real
    physics, the higher the mass, the more the force required to move an item. One
    example of how to keep an item from moving when collided with is to give it a
    very high-density compared to the other items colliding with it.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**：这设置了项目的整体模拟质量。与真实物理一样，质量越高，移动项目所需的力就越大。一个防止项目在碰撞时移动的例子是给它一个非常高的密度，相对于与之碰撞的其他项目。'
- en: '**Resistance**: This is the resistance applied to any movement, not just sliding
    across another surface as in the case of friction.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻力**：这是施加在任何运动上的阻力，不仅仅是像摩擦那样在另一个表面上滑动。'
- en: '**angularResistance**: When an item rotates, this property will determine the
    resistance to the rotation.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**angularResistance**：当项目旋转时，这个属性将确定旋转的阻力。'
- en: '**allowsRotation**: An optional property to keep an item from rotating, regardless
    of what collisions and forces affect it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allowsRotation**：一个可选属性，用于防止项目旋转，无论什么碰撞和力如何影响它。'
- en: Collision notifications
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞通知
- en: So far, we have set up gravity and added some boundaries, including an invisible
    boundary for our date label. It is very common to respond to collisions by performing
    some sort of task. For instance, in a game, once an enemy collides with a bullet,
    we would destroy the enemy and increase the score.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了重力并添加了一些边界，包括我们日期标签的无形边界。通过执行某种任务来响应碰撞是非常常见的。例如，在一个游戏中，一旦敌人与子弹碰撞，我们会摧毁敌人并增加分数。
- en: 'We can track collisions by using collision notifications. In order to do so,
    we must have our class adopt `UICollisionBehaviorDelegate`. Switch to `FoodDetailViewController.h`
    and add the following protocol:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用碰撞通知来跟踪碰撞。为了做到这一点，我们必须让我们的类采用`UICollisionBehaviorDelegate`。切换到`FoodDetailViewController.h`并添加以下协议：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now switch back to `FoodDetailViewController.m` and locate the code we wrote
    to create the collision behavior. Add the following line of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回`FoodDetailViewController.m`并找到我们创建碰撞行为的代码。添加以下代码行：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By setting the collision delegate, we can now use the following delegate method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置碰撞代理，我们现在可以使用以下代理方法：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This delegate method gets called every time a collision occurs, and we have
    set it up to output the collision identifier we defined earlier. Run the code,
    and your console output should look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生碰撞时，此代理方法都会被调用，并且我们已经将其设置为输出我们之前定义的碰撞标识符。运行代码，你的控制台输出应该如下所示：
- en: '![Collision notifications](img/0319OT_08_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞通知](img/0319OT_08_04.jpg)'
- en: 'Using a combination of identifiers and other properties passed to this delegate
    method, we can detect which collisions are happening and respond accordingly.
    For example, let''s animate the alpha of the food image view when a collision
    occurs. Replace your delegate method code with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将标识符和其他传递给此代理方法的属性组合起来，我们可以检测正在发生的碰撞，并相应地做出反应。例如，让我们在发生碰撞时动画食物图像视图的alpha值。将你的代理方法代码替换为以下代码：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we cast the identifier as an `NSString` and then check if it is equal to
    the collision identifier we want. If so, we perform a simple `UIView` animation
    that sets the `alpha` value of the image view to zero, thus making it invisible.
    Using this delegate method properly will allow you to accomplish a large number
    of tasks based on collisions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将标识符转换为`NSString`，然后检查它是否等于我们想要的碰撞标识符。如果是这样，我们执行一个简单的`UIView`动画，将图像视图的`alpha`值设置为零，从而使其不可见。正确使用此代理方法将允许你根据碰撞完成大量任务。
- en: Attaching items to other items
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将项目附加到其他项目
- en: In addition to gravity and other physics properties, UIKit Dynamics also allows
    your physics objects to interact with one another as they would in the real physical
    world. For example, we can use the `UIAttachmentBehavior` method to link items
    together as if they are attached with an invisible brace. Let's have our application
    create a new square view and then attach it to our food image view, but only when
    a collision occurs. Because our food image view will bounce a couple of times,
    the collision will be detected each time. To keep from creating multiple squares,
    let's create another instance variable to keep track of the first bounce.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重力和其他物理属性之外，UIKit Dynamics还允许你的物理对象以它们在现实物理世界中的方式相互交互。例如，我们可以使用`UIAttachmentBehavior`方法将项目连接起来，就像它们被一个不可见的支架连接一样。让我们让我们的应用程序创建一个新的方块视图，并将其附加到我们的食物图像视图上，但仅在发生碰撞时。因为我们的食物图像视图会弹跳几次，所以每次都会检测到碰撞。为了避免创建多个方块，让我们创建另一个实例变量来跟踪第一次弹跳。
- en: 'Add the following line of code in the implementation block in `FoodDetailViewController.m`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FoodDetailViewController.m`的实现块中添加以下代码行：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now replace our delegate method code with the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将我们的代理方法代码替换为以下代码：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we detect if the `firstBounce` Boolean value is not `YES`, and then create
    a new `UIView`, add the gravity and collision items to it, use the `UIAttachmentBehavior`
    method, and attach this new view to our food image view. Run the application,
    and you will see that on the first bounce, a green square is created. Because
    we attach this new view to the food image view, you will see that as it bounces
    the second and third times, the square view moves with it as if attached.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检测`firstBounce`布尔值是否不是`YES`，然后创建一个新的`UIView`，将重力和碰撞项添加到其中，使用`UIAttachmentBehavior`方法，并将此新视图附加到我们的食物图像视图上。运行应用程序，你将看到在第一次弹跳时，创建了一个绿色方块。因为我们将这个新视图附加到食物图像视图上，所以当你第二次和第三次弹跳时，方块视图会随着它移动，就像被附着一样。
- en: Snapping items
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照项
- en: Our last behavior we will cover in this book is the `UISnapBehavior` class.
    UIKit Dynamics provides a built-in behavior that will snap an item from its starting
    point to a specified end point with built-in damping. Let's have our food image
    view snap from the top of the screen into its final position.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中介绍的最后一个行为是`UISnapBehavior`类。UIKit Dynamics提供了一个内置的行为，可以将一个项目从其起始点快速移动到指定的终点，并具有内置的阻尼。让我们让我们的食物图像视图从屏幕顶部快速移动到其最终位置。
- en: 'Scroll to `viewDidLoad` and remove all of our gravity and collision code (keep
    our animator). Add the following code to `viewDidLoad`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到`viewDidLoad`并移除我们所有的重力和碰撞代码（保留我们的动画器）。将以下代码添加到`viewDidLoad`中：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we allocate new `UISnapBehavior` and `init` options with our food image
    view. We also pass the point we want the item to snap to, in this case, the final
    position of the image view. We set the damping value to be a bit higher to give
    a milder spring effect (the lower the number, the more springy the item will be).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为食物图像视图分配新的`UISnapBehavior`和`init`选项。我们还传递了想要项目弹回的点，在这种情况下，是图像视图的最终位置。我们将阻尼值设置得稍高一些，以产生较温和的弹簧效果（数字越低，项目越有弹性）。
- en: The last thing to do is to change the starting point of the food image view.
    Switch to **Main.storyboard** and drag the food image view to the top of the screen
    as high as you wish (even offscreen). It is important to note that the greater
    the distance of the starting point to the end point, the more springy the snap,
    so take this into consideration when setting the `damping` property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是改变食物图像视图的起始点。切换到**Main.storyboard**，并将食物图像视图拖动到屏幕顶部，尽可能高（甚至超出屏幕）。需要注意的是，起始点到终点的距离越大，弹跳效果越明显，因此在设置`damping`属性时要考虑这一点。
- en: Run our application and see the results. The food image view should snap into
    place with a nice spring effect. As you can see, using UIKit Dynamics is not only
    simple, but can be very powerful.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序并查看结果。食物图像视图应该以漂亮的弹簧效果弹回位置。正如你所看到的，使用UIKit Dynamics不仅简单，而且非常强大。
- en: Using motion in our app
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用中使用运动
- en: In addition to UIKit Dynamics, we can also use `UIMotionEffects` to adjust the
    user interface when a device is tilted horizontally. `UIMotionEffects` is an abstract
    class that works best when subclassed. Apple has already made a subclass of `UIMotionEffects`
    that will cover almost all use cases of motion in your apps. This subclass is
    the `UIInterpolatingMotionEffect` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了UIKit Dynamics，我们还可以使用`UIMotionEffects`来调整设备水平倾斜时的用户界面。`UIMotionEffects`是一个抽象类，在子类化时效果最佳。苹果已经为`UIMotionEffects`创建了一个子类，几乎可以覆盖你应用中所有运动的用例。这个子类是`UIInterpolatingMotionEffect`类。
- en: The `UIInterpolatingMotionEffect` instance is initialized with a key path and
    a type. The type is what defines vertical and horizontal motions. The class will
    automatically set the key value path based on the device's movements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIInterpolatingMotionEffect`实例使用一个键路径和一个类型进行初始化。类型定义了垂直和水平运动。该类将根据设备的运动自动设置键值路径。'
- en: 'In our `viewDidLoad` method, add the following code at the bottom:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`viewDidLoad`方法中，在底部添加以下代码：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we create our `UIInterpolatingMotionEffect` instance and assign it to the
    horizontal axis motion tracking. Next we set a minimum and maximum relative value.
    This determines how much the items will move left and right to simulate the parallax
    effect we want. Lastly, we add the motion effect to all views that we want. Our
    `keyPath` value can be assigned to a number of different values for different
    effects. Run the application on a device and select a food item's detailed view
    to see the results!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`UIInterpolatingMotionEffect`实例，并将其分配给水平轴运动跟踪。然后我们设置最小和最大相对值。这决定了项目将向左或向右移动多少以模拟我们想要的视差效果。最后，我们将运动效果添加到我们想要的所有视图中。我们的`keyPath`值可以分配给多个不同的值以产生不同的效果。在设备上运行应用程序，并选择一个食物项目的详细视图以查看结果！
- en: 'Additionally, we can go further by grouping multiple motion effects together,
    such as both vertical and horizontal motions. Replace the preceding code with
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过组合多个运动效果来进一步扩展，例如垂直和水平运动。用以下代码替换前面的代码：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we simply duplicate the horizontal motion effect, but we set `keyPath`
    to `center.y` and `type` to `vertical`. Run the application and check out the
    results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地复制了水平运动效果，但我们将`keyPath`设置为`center.y`，将`type`设置为`vertical`。运行应用程序并查看结果。
- en: As great and easy as these effects are, be careful not to go overboard. Each
    of the items discussed in this chapter is designed to add subtle effects that
    work together for an overall better user experience.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些效果虽然既伟大又简单，但要注意不要过度使用。本章讨论的每个项目都是为了添加微妙的视觉效果，这些效果共同作用，从而提升整体的用户体验。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have done it! From start to finish, we have built a fully functional application
    using many of the great new features of iOS 7 and Xcode 5\. In this chapter, we
    topped everything off by adding some cool physical properties to our views. Stacking
    these behaviors and motion effects together can create some really unique interface
    effects. Now that we are at the conclusion of this book, you should be very comfortable
    stepping into iOS 7 development. Taking advantage of all the new features is the
    first step to building better applications with a better experience!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！从开始到结束，我们使用iOS 7和Xcode 5的许多新特性构建了一个功能齐全的应用程序。在这一章中，我们给我们的视图添加了一些酷炫的物理属性。将这些行为和动态效果叠加在一起，可以创造出一些非常独特的界面效果。现在，随着这本书的结束，你应该非常熟悉iOS
    7的开发了。利用所有这些新特性是构建具有更好体验的更好应用程序的第一步！
