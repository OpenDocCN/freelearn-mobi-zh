- en: Overview of Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is a powerful, lightweight application framework that provides support
    for various frameworks, such as Hibernate, Struts, and JSF. Spring Framework is
    one of the top enterprise frameworks for building the most complex, secure and
    robust products. This framework is very popular for Java developers, as most developers
    working in Java Enterprise are working with Spring. Nowadays, Spring supports
    the Kotlin language, so it's becoming more popular with other language users.
    In this book, we'll develop Spring projects in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about the basics of Spring Framework. We'll discuss the basics
    of Spring and also see some examples of how to implement them with Spring MVC
    and SpringBoot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SpringBoot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](bfdcd6b3-5a5a-4fc7-af79-67e780f46ccb.xhtml), *About the Environment,* we
    demonstrated how to set up the environment and what tools, software, and IDE are
    needed in order to develop Spring. To begin, visit [https://start.spring.io/](https://start.spring.io/) and
    create your very first project. The following options will be available there:'
  prefs: []
  type: TYPE_NORMAL
- en: A Maven project or a Gradle project (we've chosen Maven)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: Java or Kotlin (we''ve chosen Kotlin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Boot version**: 2.1.1 (SNAPSHOT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you click on Create, you need to give information, such as **Group**, **Artifact**,
    **Name**, **Description**, **Package Name**, **Packaging**, and **Java Version**.
  prefs: []
  type: TYPE_NORMAL
- en: For this stage, there's no need to add any dependencies. Lastly, generate the
    project and import this into your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The source code with an example for this chapter is available on GitHub: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework is an open source framework. This is written in Java and developed
    by Pivotal software. Any Java-based enterprise applications can use the core of
    this framework. Spring Framework uses the **Plain Old Java Object** (**POJO**),
    which makes it easier to build an enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: A POJO is a Java object that isn't bound by any restriction other than those
    forced by the Java language specification. POJOs are used to increase the readability
    and reusability of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn the advantages of Spring and architectures in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework is a component-rich framework with the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring can be utilized for independent applications, web applications, and mobile
    applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring has given an answer for free coupling through the creation of **dependency
    injection **(**DI**). This gives a configuration file (or annotation) to rearrange
    the conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It utilizes **aspect-oriented programming** (**AOP**) and makes it possible to
    isolate cross-cutting concerns, such as logging, reserving, and security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It limits boilerplate code. Spring has a huge amount of bundles and classes
    that decrease coding and keep away from the boilerplate code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It bolsters different frameworks, such as *ORM*, *Hibernate*, *Logging*, and *JEE*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring provides a simple and secure approach to dealing with login frameworks,
    forms, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles *autowiring*, which can be a nightmare when building a complex web
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Web Framework has a web *MVC framework*, which gives leverage, rather
    than a legacy web framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the ability to take out the creation of singleton and factory classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Framework incorporates support for overseeing business objects and presenting
    their administrations to the introduction-level segments with the aim.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It underpins both *XML* and *annotation* arrangements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework is a layered architecture that's composed of a few modules.
    All modules are based on the highest point of its core container. These modules
    give a developer everything they may require for use in the enterprise application
    development. In any case, developers allowed to pick the highlights they need
    and dispose of the modules that are of no use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular programming** is a software design technique. This separates the
    functionality of a program into independent modules so that each contains one
    specific functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram of the Spring architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c8913af-0b5c-4ccf-80d0-d9d3e457296c.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Framework has about 20 modules, which are grouped into **Core Containers**,
    **Data Access/Integration**, **Web**, **AOP**, **Instrumentation**, and **Test.**
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about the components of Spring architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Core containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section consists of **Core**, **Beans**, **Context**, and **Expression
    Language** modules.
  prefs: []
  type: TYPE_NORMAL
- en: The **Core** module is the center of the Spring architecture. This provides
    the implementation for features such as **Inversion of Control** (**IoC**) and  **Dependency
    Injection** (**DI**). IoC is one of the center containers of the Spring core. DI
    is another known name of IoC. This container is responsible for creating forms
    of objects and controls the complete life cycle. During this life cycle, the system
    creates a dependency and the container injects those dependencies while it creates
    the bean. This inverse process of DI is basically called IoC.
  prefs: []
  type: TYPE_NORMAL
- en: '`org.springframework.beans` and `org.springframework.context` are the two containers
    of Spring Framework''s IoC. IoC has a root interface, called `BeanFactory`, which
    is executed by the items and holds various bean definitions, each bean being recognized
    by a String name. A propelled configuration component is given by this interface
    to deal with items. `ApplicationContext` is a sub-interface of `BeanFactory`,
    which includes more application-layer settings. For example, it includes `WebApplicationContext`
    for use in web applications. `ApplicationContext` is in charge of instantiating,
    designing, and collecting the beans.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks of object instantiation, configuration, and object assembling are
    specified for the container in the configuration metadata. There are three ways
    to configure the metadata: through XML, annotation, or code. This occurs in spite
    of the way that we work with Kotlin, so we''ll write code and metadata in the
    Kotlin language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple diagram of the flow of the **Core** container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/660caf35-f1b3-4ca7-8571-aba84e886953.png)'
  prefs: []
  type: TYPE_IMG
- en: The core container is the process of getting the Spring project ready to see
    the output. With the help of **Java POJO Classes**, which are mainly the business
    objects and the **Metadata** (the configuration metadata), the **Spring Container**
    represents the ready application as output.
  prefs: []
  type: TYPE_NORMAL
- en: The **Bean** module represents a bean, which is an object that's assembled,
    managed, and instantiated by the IoC Container.
  prefs: []
  type: TYPE_NORMAL
- en: The **Context** module supports EJB, JMS, Basic Remoting, and so on. The `ApplicationContext` interface
    is the point of concurrence of the **Context** module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The** Expression Language** module is normally used to execute logic, such
    as data query, sum, divide, and mod, in the application. To execute the logic,
    this module provides powerful expressions, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arithmetic** | `+`, `-`, `*`, `/`, `%`, `^` |'
  prefs: []
  type: TYPE_TB
- en: '| **Relational** | `<=`, `>=`,`<`, `>`, `==`, `!=` |'
  prefs: []
  type: TYPE_TB
- en: '| **Logical** | `&&`, `&#124;&#124;`, `!` |'
  prefs: []
  type: TYPE_TB
- en: '| **Conditional** | `?`, `:` |'
  prefs: []
  type: TYPE_TB
- en: '| **Regex** | `matches` |'
  prefs: []
  type: TYPE_TB
- en: Data Access/Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data Access/Integration** is responsible for setting and getting public or
    private data. It acts as a bridge between the data-access layer and the business
    layer. Here are some names of the data modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JDBC**: **Java Database Connectivity** (**JDBC**) helps the application to
    connect with the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-relational mapping**: This uses as an integration layer for **object-relational
    mapping** (**ORM**) APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object/XML mapping:** This uses as an integration layer for **object/XML
    mapping** (**OXM**) implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '** Java Messaging Service**: This is used to provide support in Spring for the
    **Java Messaging Service** (**JMS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactions**: This is used to provide programmatic and declarative transaction
    management for the POJO classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **web** is the center of the Spring MVC framework. We can also integrate
    other technologies, such as JSF and Spring MVC. The web provides some basic integration
    features, such as login, logout, and uploading or downloading files. The web layer
    has four modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web**: This provides the basic web-oriented integration features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web-servlet**: This module contains Spring''s MVC implementation for the
    web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web-struts**: This module provides an enhanced and improved framework to
    make web development easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web-portlet**: This module is an identical representation of the web MVC
    framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming** (**AOP**) is a key component of Spring Framework.
    This provides a new way to think about the structure of a program. AOP can be
    implemented in Java and Kotlin. It can be configured in the bean.'
  prefs: []
  type: TYPE_NORMAL
- en: AOP splits program logic into certain parts, called **affirmed concerns**. In
    any enterprise application, there are cross-cutting concerns, which should to
    be separate from the basic business logic. Logging, transaction handling, performance
    observing, and security are known as cross-cutting concerns within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instrumentation is the capacity to screen the level of an item's performance,
    to analyze mistakes, and to compose the trace information. Instrumentation is
    one of the key highlights of Spring Framework for auditing application performance. Spring
    supports instrumentation through AOP and logging.
  prefs: []
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the essential parts of an enterprise software development is **testing**.
    JUnit or TestNG can be used to test Spring components. This supports the unit
    and integration testing of Spring elements.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A bean is an object that can be instantiated and assembled by the Spring IoC.
    These beans are created by configuring Spring''s metadata. Here''s a set of properties
    that represent each bean definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor-arg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn about the configured metadata's uses in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Spring configuration metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three major functions that provide configuration metadata with the Spring
    container are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: XML-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin/Java-annotation-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin/Java-code-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The XML-based configuration was introduced in Spring 2.0, and enhanced and extended
    in Spring 2.5 and 3.0\. The main reason for moving to XML-based configuration
    files was to make Spring XML configuration easier. The *classic* `<bean/>` based
    approach is good, but also adds some more configuration that can become complex
    in the big project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of an XML-based setup document with various
    bean definitions, including the scope, initialization technique, and destruction
    strategy, and then we''ll discuss this. Here''s a piece of code for `bean.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can choose to proclaim an extension for a bean while defining it. For instance,
    if we constrain Spring to deliver another bean occasion each time, we can initialize
    a prototype scope as an attribute of a bean. Additionally, if we need Spring to
    restore a similar bean example, we should proclaim the bean's scope attribute
    to be a *singleton*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Framework underpins the accompanying five scopes, three of which are
    accessible in the event that we utilize a web-aware `ApplicationContext`. Here
    are some common scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton**: Returns the same instance that''s used by default every time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: Returns a different instance every time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request**: Defines an HTTP request that''s visible in a single JSP page of
    the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session**: Defines an HTTP session that''s visible in all JSP pages of the
    application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default scope is always a `singleton`. This is a bean definition of the
    Spring IoC container that returns a single object instance in every object initialization. Here''s
    a piece of code for the singleton scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at an example of a `singleton` scope.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spring project in the IDE. To do this, create two `kt` files and a
    bean XML configuration file under the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a piece of the code of `CreateUserGreeting.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of **`BeansScopeApplication.kt` **is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `beans.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this project, you will find this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Prototype scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `prototype` scope creates a new instance of a bean in every object initialization.
    This scope is preferred for the stateful beans. The container doesn''t manage
    the full life cycle of this `prototype` scope. Here''s a code piece for a `prototype`
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at an example of a `prototype` scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reuse the previous project and modify the bean XML configuration file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we finish creating the source and bean configuration files, we can run
    the application. If there''s no error, we''ll get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Bean life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, we need to instate assets in the bean classes. For instance, this
    is possible by making database associations or approving third-party services
    at the season of initialization before any customer request. Spring Framework
    gives distinctive courses through which we can give post-introduction and pre-annihilation
    techniques in a Spring bean life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: By actualizing the `InitializingBean` and `DisposableBean` interfaces—both of
    these interfaces announce a solitary strategy where we can instate/close assets
    in the bean. For `post-instatement`, we can execute the `InitializingBean` interface
    and provide an implementation of the `afterPropertiesSet()` function. For `pre-destroy`,
    we can actualize the `DisposableBean` interface and provide an implementation
    of the `destroy()` function. These functions are the callback techniques, which
    are similar to servlet audience implementations. This functionality is easy to
    utilize, yet it's not recommended, as it will cause tight coupling with Spring
    Framework in our bean implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving `init-function` and `destroy-function` quality values for the bean in
    the Spring bean configuration file. This is the prescribed functionality as there's
    no immediate dependency to Spring Framework. We can also make our own functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the `post-init` and `pre-destroy` functions shouldn't have any contentions,
    but they can throw exceptions. We would also have to get the bean occasion from
    the Spring application setting for these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of the life cycle of a bean. Here, we''ll look at how
    to initialize and destroy the bean function. Reuse the previous project and modify
    the bean XML configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add two functions in `UserGreeting.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `registerShutdownHook()` after the task is completed in the `main` function
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is a system where dependencies of an object are provided by outside containers.
    Spring DI helps in wiring a class with its dependencies and keeping them decoupled
    so that we can inject these dependencies at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies are characterized in the bean configuration. The two most common
    approaches to injecting objects utilizing XML are *constructor* *injection* *and
    setter injection,* which we'll take a look at now*:*Constructor injection
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor injections inject dependencies to the class constructor. Let''s
    take a look at an example of the constructor injection. Reuse the previous project
    and modify the content of `beans.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`constructor-arg` is utilized to inject dependencies. The reference of `constructor-arg`
    is an object of the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class of `UserSurname.kt` to see the use of the constructor injection**.**
    We''ll get the surname from this class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `UserSurname` and add the `getUserSurname()` function to `CreateUserGreeting.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we call the `getUserSurname()` function in `BeansScopeApplication`,
    we'll get the `UserSurname`class.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the sample code of `BeansScopeApplication.kt`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Setter injection**'
  prefs: []
  type: TYPE_NORMAL
- en: In Spring, a setter injection is a kind of DI in which the framework injects
    the objects that are dependent on another object into the customer using a `setter`
    function. The container first calls the no contention constructor and then calls
    the setters. The setter-based injection will work regardless of whether a few
    dependencies have been injected utilizing the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of the `setter` injection. Here, reuse the previous project
    and modify the content of `beans.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying the bean file, add a setter and getter of `UserSurname` to
    the `CreateUserGreeting.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of an empty string or `null` value is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Auto-wiring beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been utilizing `<constructor-arg>` and `<property>` to inject dependencies.
    Instead, we can `autowire` the dependencies, which helps to diminish the measure
    of configurations that should be composed.
  prefs: []
  type: TYPE_NORMAL
- en: There are diverse choices for auto-wiring that manage the Spring container on
    the most proficient method to infuse the conditions. A bean has no auto-wiring
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two major types of auto-wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byName`: To `autowire` a bean, the Spring container chooses the bean by the
    class name. Here''s an example of the use of `byName`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`byType`: To autowire a bean, the Spring container chooses the bean according
    to the class type. Here is an example of the use of `byType`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If there are multiple implementing classes for a `Service` interface, you'll
    find two types of scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `services` (a cluster of `services` execute the `Service` interface), bean won't
    allow us to execute the `autowire` of `byName`. If there isn't an occurrence of
    `byName`, it will inject all the executing objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of **`mainService`** (an object actualizes the `Service` interface), for
    the `byType`/constructor, allocate the autowire-applicant attribute in the `<bean>`
    tag of all executing classes as `false`, keeping one of them as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how to handle multiple implementing classes for a `Service`
    interface in `beans.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For `byName`, either rename `mainService` in the application class to one of
    the actualizing classes (that is, `userSurname`), or rename the bean `id` of that
    class in the XML configuration to `mainService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some limitations of auto-wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overriding possibility**: To specify the dependencies, you can use the `<constructor-arg>`
    and `<property>` settings, which will override auto-wiring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitive data types**: Primitives, strings, and classes can''t be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confusing nature**: Auto-wiring is less accurate than unequivocal wiring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations are the new technology of DI**.** This started being used with Spring
    2.5\. There was no need for any XML files to maintain the configuration. To use
    the annotation-based configuration, you need to create a component class in which
    you can implement bean configurations. Annotations are unique names or markers
    on the pertinent class, function, or field revelation.
  prefs: []
  type: TYPE_NORMAL
- en: Presumably, you're familiar with `@Override`, which is an annotation that tells
    the compiler that this annotation is an abrogated function.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding annotations, the conduct of Spring Framework was to a great
    extent controlled through XML configuration. Today, the utilization of annotations
    gives us many advantages through the way we design the practices of Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a piece of `bean.xml` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we use `<context:annotation-config/>` in `bean.xml`, we can begin annotating
    the code to wire values into properties, functions, or constructors. We'll learn
    about a few essential annotations in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The @Required annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@Required` annotation is applied to bean property-setter functions. The
    bean property must be populated in the XML configuration file at configuration-time. This
    annotation essentially shows that the setter function must be arranged to be dependency-injected
    with a value at configuration-time.
  prefs: []
  type: TYPE_NORMAL
- en: Add a user model and the `Main` class with a `bean.xml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the`bean.xml` configuration file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `UsersForReq.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `AnnotationBasedReqApp.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this project will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The @Autowired annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@Autowired` annotation helps us to connect constructors, fields, and setter
    functions. This annotation injects object dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sample code of how to use `@Autowired` on a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the sample code of how to use `@Autowired` on a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `UserDetails.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the project will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can utilize the `@Autowired` annotation on properties to dispose of the
    setter functions. When we pass values of autowired properties utilizing `<property>`,
    Spring will allocate those properties with the passed values or references. So
    with the utilization of `@Autowired` on properties, the `UsersForAutowired.kt`
    file will become as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can also apply `@Autowired` to constructors. An `@Autowired` constructor annotation
    demonstrates that the constructor should be autowired when making the bean. This
    should be the case regardless of whether any `<constructor-arg>` components are
    utilized when configuring the bean in the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the modified content of`UsersForAutowired.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The @Qualifier annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might create an excess of one bean of a similar type and need to wire just
    a single one of them with the property. In such cases, you can utilize the `@Qualifier`
    annotation alongside `@Autowired` to evacuate the disarray by determining which
    correct bean will be wired. In this section, we'll look at a precedent to demonstrate
    the utilization of a `@Qualifier` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the`bean.xml` configuration file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the content of `AnnotationBasedQualifierApp.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add another class. Here''s the content for `UsersForQualifier.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `Fighters.kt` class. Here''s the content ofthis class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the output, it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the qualifier value like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Code-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to design Spring beans by utilizing the XML configuration file. If
    you are used to XML configuration, you can ignore this topic.
  prefs: []
  type: TYPE_NORMAL
- en: The code-based configuration alternative empowers you to compose the majority
    of your Spring configuration without XML.
  prefs: []
  type: TYPE_NORMAL
- en: The @Configuration and @Bean annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the `@Configuration` annotation on a class, implies that this class
    will be utilized by the Spring IoC container and will be considered a source of
    bean definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a `@Bean` annotation on a function means the function will return
    an object that's enrolled as a bean in the Spring application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample code of `@Configuration` and `@Bean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will be equivalent to the following XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function name is commented on with the `@Bean` annotation, which creates
    and returns the bean definition. Your configuration class can have a presentation
    for in excess of one `@Bean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `GreetingConfigurationConfBean.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `GreetingConfBean.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `MainAppConfBean.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotate the `@Bean` annotation to inject dependencies. Here's the content of
    `GreetingConfigurationDIBean.kt`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When two `@Beans` are dependent on each other, the dependency is as simplistic
    as having one bean method call another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `GreetingDIBean.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `GreetingDetailsDIBean.kt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `MainApp.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The @Import annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring's `@Import` annotation offers functions such as `<import/>` an element
    in Spring XML. By utilizing the `@Import` annotation, you can import at least
    one `@Configuration` class. It can also import classes that contain no less than
    one `@Bean` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `Boo.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `ConfigBoo.kt`is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t need to specify both `ConfigFoo.class` and `ConfigBoo.class` when
    instantiating the context, so the following code isn''t required when you initialize
    `AnnotationConfigApplicationContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As bean definitions of `ConfigFoo` are already loaded by using the `@Import`
    annotation with the `ConfigBoo` bean, only `ConfigBoo` needs to be explicitly specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the modified complete code of the `main` function of  `MainAppImport.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Life cycle callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `@Bean` annotation supports determining discretionary introductions and obliteration
    callback functions. If you noticed `beans.xml` in the `XMLBasedSpringConfiguration`
    project, you can find the `init-method` and `destroy-method` attributes. Here''s
    an example of how to initialize the `init-method` and `destroy-method` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the modified code of `MainAppLifeCall.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified code of `Foo.kt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a configuration class for `Foo`. The modified code of `ConfigFoo.kt` is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this project will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Creating a scope bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `@Scope` bean to make a prototype scope with `@Configuration`. `@Configuration`
    represents the configure file of a SpringBoot project. Here''s a piece of code
    that shows how to use the `@Scope` prototype annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Web MVC framework uses the **model-view-controller** (**MVC**) architecture,
    which manages the web applications. This provides a ready component that can be
    used by developers to develop a robust and loosely-coupled web application. With
    the presentation of Spring 3.0, the `@Controller` component additionally enables
    you to make peaceful web locales and applications through the `@PathVariable`
    annotation and different features. The MVC pattern separates the different aspects,
    such as input, business, and UI logic of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three parts to MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: The **model** is at the core of MVC applications. This is where the primary
    logic and information objects that comprise the core usefulness of the application
    are produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **view**is the place the information given by the model is introduced to
    the client. A view regulates the visual (or other) interface components – it chooses,
    filters, and arranges data provided by the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **controller** is in charge of preparing client requests, building a proper
    model, and passing it to the view for rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the advantages of Spring MVC framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC helps to separate each role, such as the model object and controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing and deploying an application, it helps developers to use the
    lightweight servlet container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a robust and powerful configuration for the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can develop a project very quickly and in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is very easy and you can inject test data using a setter function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DispatcherServlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DispatcherServlet` is one of the core components of the Spring MVC. This works
    as a front-controller in an application. A front-controller means the Spring MVC receives
    all incoming requests and forwards these to the Spring MVC controller for processing. This
    is totally coordinated with the Spring IoC container and accordingly enables you
    to utilize each element of Spring.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DispatcherServlet` handles all the HTTP requests and responses that are designed
    under the Spring MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram to illustrate `DispatcherServlet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94318afd-4eef-42b2-b829-cbb1af7802a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The succession of occasions relating to an approaching HTTP request to `DispatcherServlet`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application (as a client) sends a request to `DispatcherServlet`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DispatcherServlet`asks the related `Handler Mapping` to call the `Controller`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Controller` takes requests from `DispatcherServlet` and calls a relevant
    service function based on the `GET` or `POST` function. The service function sets
    the model data based on the business logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ViewResolver` selects the defined `View`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The defined `View` is executed on the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll learn about the MVC framework with Kotlin. Although this project
    is a web application and we need to utilize Maven for dependencies administration,
    we need to make a dynamic web application and then change it to a Maven venture first.
    The following screenshot demonstrates how to prepare our task skeleton structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57358265-433c-4cec-8502-a571cb33f1c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we're going to learn how to convert this project into a Maven project.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to a Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the skeleton code for our Maven web-application venture is prepared,
    we can begin rolling out improvements to it, as well as making our Spring MVC
    HELLO WORLD application.
  prefs: []
  type: TYPE_NORMAL
- en: The created project is a non-Maven project. We need to convert the project into
    the Maven project.
  prefs: []
  type: TYPE_NORMAL
- en: To convert this project into a Maven project, open the existing project. In
    the project tool window, right-click your project and select Add Framework Support.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dialog that opens, select Maven from the options on the left and click
    OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b68d747-7842-4054-936e-d1d30706ed50.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring MVC dependencies to pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to include `spring-web` and `spring**-**webmvc` dependencies in `pom.xml`,
    as well as including a servlet-programming interface, JSP-programming interface,
    and JSTL dependencies. Here''s part of the `pom.xml` file (the full version is
    on GitHub) of our project with the `Spring Core`, `Kotlin`, and `Web` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Creating Spring configuration beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the `/WebContent/WEB-INF/` directory and create an XML file called `spring-mvc-kotlin-servlet.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `spring-mvc-kotlin-servlet.xml` configuration file, we mentioned a `<context:component-scan>`tag. All
    the components from the `mvckotlin` package and all its child packages will now
    be loaded by the Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: This will load our `MVCKotlinApp.class` and also assign a `viewResolver` bean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<property name="prefix" value="/WEB-INF/jsp/" />` will resolve the view and
    add a prefix string named `/WEB-INF/jsp/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we have returned a `ModelAndView` object with the view name `welcome`in
    our `MVCKotlinApp` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will be resolved to the `/WEB-INF/jsp/greeting.jsp` path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a `web.xml` file under the `/WebContent/WEB-INF/` directory. If you
    don''t find it, create it in the `/WebContent/WEB-INF/` directory. Here''s a piece
    of code from `web.xml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`web.xml` will map `DispatcherServlet` with the `/greeting.jsp` URL pattern.
    Furthermore, note that we have mentioned `index.jsp` as a greeting file.'
  prefs: []
  type: TYPE_NORMAL
- en: After initialization, `DispatcherServlet` will look for a file named `[servlet-name]-servlet.xml`
    in the `WEB-INF` folder. The value of the servlet XML file prefix name, and value
    of the `<servlet-name>` tag in `web.xml`, have to be the same. In our example, the
    name of the servlet is `spring-mvc-kotlin-servlet.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a controller class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to `src` | `main` | `java` in the project and create the package name that
    we mentioned in `spring-mvc-kotlin-servlet.xml`*.* Assume that our package name
    is `mvckotlin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c0ad46a-d8c1-43c5-81d7-8176714cc961.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a controller `.kt` file. We call this `MVCKotlinAppController.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We have a class named `MVCKotlinAppController.kt` and annotated this with `@Controller`,
    which means that this class is a controller class. After initializing the project,
    Spring starts to search the bundle from here.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RequestMapping("/greeting")` annotation will map a web request and `/greeting`
    will create a base URI.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a function named `greetingMessage()` that will return a `ModelAndView`
    object. Here we just create a sample `HTML` code for greeting. If we go to `http://localhost:8080/greeting`,
    this will return a view based on `greetingMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file named `/WebContent/index.jsp`,with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create another file named `/WebContent/WEB-INF/jsp/greeting.jsp`, with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: IntelliJ Ultimate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the project, you need to set up the run configuration. Follow these
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the Run...button from the toolbar and then add Maven with the **`clean`
    `install`** comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b1fb350-9e38-46e9-9c1d-7cd2c7268015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `TomCat Server` --> `Local` and add the `SpringMVCKotlin:war` build from
    Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/ed512f7c-261c-4335-a2e9-cc8b690efe21.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Click the RUN button on the menu bar to start the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: To run the project, right-click on Project | Run As | Maven Build....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Goals—**clean install*.***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Apply and Run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there are no errors, you''ll see the following **BUILD SUCCESS** message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbde584e-8221-4b7d-b140-a2df0c96df39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Visit  `http://localhost:8080/SpringMVCKotlin/`, where you''ll see the following
    output of the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca36df6f-c34e-4aea-a135-1c0cee098fef.png)'
  prefs: []
  type: TYPE_IMG
- en: SpringBoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SpringBoot** is a Spring Framework module that has some features to help
    developers create a production-class application. SpringBoot is a combination
    of two words—**BOOT** is from bootstrap, while **SPRING** is a framework used
    to build Java enterprise applications. This is a large framework that''s also
    supported by numerous other frameworks. SpringBoot is similar in that it lets
    you bootstrap a spring application from scratch, which is how it gets the name
    SpringBoot. According to `spring.io`, here''s the definition of SpringBoot—"Spring
    Boot makes it easy to create stand-alone, production-grade, Spring-based applications
    that you can just run." This means that it helps you to create a runnable project
    without the help of others. In addition, we showed a **production-grade** project here, which is
    a ready-product application. SpringBoot minimizes the pain of setting up an application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The features of SpringBoot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to create a standalone Spring application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It comes with Tomcat, Jetty, or Undertow, and so there's no need to worry about
    setting up the server environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the use of SpringBoot, you don't need to deploy WAR files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party frameworks can be imported automatically with their configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML configuration isn't required if you use SpringBoot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SpringBoot doesn't produce code or make changes to your files. Instead, when
    you start up your application, SpringBoot dynamically wires up beans and settings,
    and applies them to your application context.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a SpringBoot project to learn about its dependencies and features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a Spring Boot project, let''s generate a sample project from [https://start.spring.io/](https://start.spring.io/).
    Here, you can add your required dependencies, such as `Web`, `Thymeleaf`, `JPA`
    , and `DevTools`. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the drop-down menus at the top, select **Maven Project** with **Kotlin** and
    Spring Boot **2.1.1 (SNAPSHOT)**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d65f510d-7aba-49c6-ae62-5dc840d50fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Give the name of **Group**, **Artifact**, **Package Name**, and add **Dependencies**.
    Then hit Generate Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and unzip the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the downloaded project into your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After following these steps, you're ready to use and modify the project. Let's
    see what's inside this project. You'll find a controller file under `src/main/kotlin/{packageName}/AppController.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a piece of code from the `controller` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `HtmlController.kt` and annotate it with the `@RestController`
    annotation to make it a controller class in which we'll deal with web requests.
    `@RestController` is the combination of `@Controller` and `@ResponseBody`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function named `blog(model: Model)` and annotate it with `@GetMappingmaps("/")`.
    This will return `index.xml` as output.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under **`src/main/kotlin/{packageName}`**,create an application class named
    `SpringBootKotlinApplication.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`@SpringBootApplication` is utilized to empower the following three features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration` enables Java-based configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration` enables the auto-configuration feature of SpringBoot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan` enables component scanning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` function utilizes SpringBoot's `SpringApplication.run()` method
    to dispatch an application. This web application is 100% unadulterated Kotlin
    and there's no need to arrange any pipes or foundations here.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there's a `CommandLineRunner` function set apart as `@Bean` and this
    keeps running on startup. It recovers every one of the beans that were made either
    by your application or were naturally added by SpringBoot. It then sorts and prints
    these out.
  prefs: []
  type: TYPE_NORMAL
- en: In the code of the `SpringBootKotlinApplication` class, in contrast with Java,
    you can see the absence of semicolons, the absence of sections in an empty class
    (you can add a few, in case you have to proclaim beans by means of a `@Bean` annotation),
    and the utilization of a `runApplication` top-level function. `runApplication<SpringBootKotlinApplication>(*args)`
    is Kotlin's informal option in contrast to `SpringApplication.run(SpringBootKotlinApplication::class.java,
    *args)`, and this can be utilized to customize the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now create an HTML file in the folder underneath `src/main/resources/templates/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `index.html` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the web application by running the `main` function of `SpringBootKotlinApplication.kt`.
    If everything is fine, you''ll see this in the logcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8497d12c-2632-4b56-8b74-7036ee7c725a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, go to `http://localhost:8080/`. Here, you should see a web page with
    a SpringBoot Kotlin application headline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea5af8b3-1f45-47d1-9f6b-42ac4b9572fe.png)'
  prefs: []
  type: TYPE_IMG
- en: We've covered the basics of SpringBoot. Later, we'll go into this in more depth
    with more dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Spring and its modules, dependencies, and use of
    functions. We attempted to cover all the essential information that will be required
    for the rest of this book. We looked at the steady and solid architecture of Spring
    Framework with Core, Information Access, Web, AOP, Instrumentation, and Test.
    Furthermore, we figured out the life cycle of a bean and how to design beans in
    three different ways. We found out about the depth of bean configurations, and
    we learned about the use of beans in XML, annotation, and code. Now we know how
    to inject the dependencies into the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explored two noteworthy frameworks: Spring MVC and SpringBoot. We''ll now
    be able to make an MVC-based venture with its dependencies and modules. In addition,
    we learned out about the use of SpringBoot and created a web application that
    uses Boot, allowing us to make a web page without an HTML file. We also explored
    the contrasts between Spring MVC and SpringBoot. You can now create a Spring project
    in the Kotlin language.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about the required Android and Spring modules
    to build a client application on the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Spring Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is aspect-oriented programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Spring IoC container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Spring bean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a controller in Spring MVC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `DispatcherServlet`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `ContextLoaderListener`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the boilerplate code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Learning Spring Application Development* ([https://www.packtpub.com/application-development/learning-spring-application-development](https://www.packtpub.com/application-development/learning-spring-application-development))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spring MVC: Beginner''s Guide - Second Edition* ([https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition](https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spring: Microservices with Spring Boot* ([https://www.packtpub.com/application-development/spring-microservices-spring-boot](https://www.packtpub.com/application-development/spring-microservices-spring-boot))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
