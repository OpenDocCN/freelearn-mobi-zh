- en: Chapter 1. OpenGL ES 3.0 on Android/iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming shaders in OpenGL ES shading language 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and compiling a shader program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking a shader program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking errors in OpenGL ES 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the per-vertex attribute to send data to a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uniform variables to send data to a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming OpenGL ES 3.0 Hello World Triangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JNI on Android to communicate with C/C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an Android OpenGL ES 3.0 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an iOS OpenGL ES 3.0 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 stands for Open Graphics Library for embedded systems version
    3.0\. It is a set of standard API specifications established by the Khronos Group.
    The Khronos Group is an association of members and organizations that are focused
    on producing open standards for royalty-free APIs. OpenGL ES 3.0 specifications
    were publicly released in August 2012\. These specifications are backward compatible
    with OpenGL ES 2.0, which is a well-known de facto standard for embedded systems
    to render 2D and 3D graphics. Embedded operating systems such as Android, iOS,
    BlackBerry, Bada, Windows, and many others support OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 3D APIs are the stripped-down version of OpenGL, which is a cross-platform
    standard 3D API on a desktop environment for Linux, various flavors of UNIX, Mac
    OS, and Windows. This stripped-down version is mainly focused on providing the
    capabilities of 3D graphics as per embedded system requirements such as low-power
    consumption, limited processing capabilities, and small memory footprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenGL ES 2.0/3.0 graphics library is shading-language compliant, unlike
    its predecessor 1.1\. The major difference between OpenGL ES 1.1 and OpenGL ES
    2.0/3.0 is the graphics pipeline architecture. The graphics pipeline framework
    for the former is known as a fixed function pipeline, and for the latter, it is
    a programmable pipeline. These frameworks are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| OpenGL ES version | Architecture pipeline type | Need shader |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1.1 | Fixed function pipeline | No |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 and 3.0 | Programmable pipeline | Yes |'
  prefs: []
  type: TYPE_TB
- en: A pipeline is a set of events that occur in a predefined fixed sequence, from
    the moment input data is given to the graphic engine to the output generated data
    for rendering the frame. A frame refers to an image produced as an output on the
    screen by the graphics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Each frame in a fixed function pipeline architecture is generated by a fixed
    set of algorithms, calculations, and sequences of events. You can only specify
    what you want, but not how it will be calculated. For example, if you are interested
    in applying some light shading on your solid sphere model, then you will need
    to specify the light position, its intensity, material properties, and other similar
    attributes. The fixed pipeline uses these inputs and takes care of all the physics
    and mathematics required to generate the light shading. Therefore, you don't need
    to worry, as the how factor is fully abstracted. The good side of the fixed function
    pipeline is that it is very easy to understand and quick to program.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, with the programmable pipeline architecture, you not only need
    to specify what you want to achieve, but you also need to mention how to implement
    it. This pipeline also provides extraordinary capabilities through shaders. Shaders
    are the special programs that control your scene's geometry and shading appearance.
    For example, in order to achieve the same light-shading effect on solid sphere,
    you must know the basics of physics and mathematics in order to program the light-shading
    techniques. Since you are programming the behavior of light shading, you can fully
    control it. This opens up endless possibilities to create infinite shading effects.
    Shaders are super fast. They execute rendering in parallel-processing mode using
    **Graphics Processing Unit** (**GPU**).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the question is if fixed function pipeline is doing all the light physics
    and mathematical abstraction, then why do we need to understand it for programmable
    pipelines? The reason is with fixed pipeline, we can only do finite graphics capabilities,
    and it cannot be used to produce realistic graphics effectively. However, the
    programmable pipeline opens endless possibilities and opportunities to produce
    state-of-art graphics rendering.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide OpenGL ES 3.0 development on Android and iOS. We will
    begin this chapter by understanding the basic programming of the OpenGL ES 3.0
    with the help of a simple example to render a triangle on the screen. You will
    learn how to set up and create your first application on both platforms step by
    step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding EGL**: The OpenGL ES APIs require the EGL as a prerequisite
    before they can effectively be used on the hardware devices. The EGL provides
    an interface between the OpenGL ES APIs and the underlying native windowing system.
    Different OS vendors have their own ways to manage the creation of drawing surfaces,
    communication with hardware devices, and other configurations to manage the rendering
    context. EGL provides an abstraction, how the underlying system needs to be implemented
    in a platform-independent way. The platform vendor''s SDK provides an implementation
    of EGL through their own framework. These can be directly used in the application
    to accomplish the development task quickly. For example, the iOS provides EGL
    through the EAGL (`EAGLContext`) class in conjunction with `GLkit` to create `GLSurface`.
    On the Android platform, the `GLView` class provides interfaces for EGL through
    `GLView.EGLContextFactory` and `GLView.EGLConfigChooser`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The EGL provides two important things to OpenGL ES APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rendering context**: This stores the data structure and important OpenGL
    ES states that are essentially required for rendering purpose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drawing surface**: This provides the drawing surface to render primitives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the programmable pipeline architecture of OpenGL
    ES 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B02491_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: EGL works on top of the native windowing system, such as WGL (Windows), GLX,
    or X-Windows (Linux), or Mac OS X's Quartz. With EGL specifications, cross-platform
    development becomes easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'EGL provides the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the available configuration to create rendering context of the device
    windowing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the OpenGL rendering surface for drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility and interfacing with other graphics APIs such as OpenVG, OpenAL,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing resources such as texture mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can refer to the following link for more information on EGL [http://www.khronos.org/egl](http://www.khronos.org/egl).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Programming shaders in OpenGL ES shading language 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES shading language 3.0 (also called as GLSL) is a C-like language that
    allows us to writes shaders for programmable processors in the OpenGL ES processing
    pipeline. Shaders are the small programs that run on the GPU in parallel. Without
    these programs, it is impossible to write OpenGL ES 3.0 programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL ES 3.0 supports two type of shaders: vertex shader and fragment shader.
    Each shader has specific responsibilities. For example, the vertex shader is used
    to process geometric vertices; however, the fragment shader processes the pixels
    or fragment color information. More specially, the vertex shader processes the
    vertex information by applying 2D/3D transformation. The output of the vertex
    shader goes to the rasterizer where the fragments are produced. The fragments
    are processed by the fragment shader, which is responsible for coloring them.'
  prefs: []
  type: TYPE_NORMAL
- en: The order of execution of the shaders is fixed; the vertex shader is always
    executed first, followed by the fragment shader. Each shader can share its processed
    data with the next stage in the pipeline. The GLSL facilitates user-defined variables
    such as C language; these variables are used for input and output purposes. There
    are also inbuilt variables that track the states in the shaders to make decisions
    while processing data in these shaders. For example, the fragment shader provides
    a state where the incoming fragment can be tested to see if it belongs to the
    front face or back face of a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of processors in the OpenGL ES 3.0 processing pipeline
    to execute vertex shader and fragment shader executables; it is called programmable
    processing unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex processor**: The vertex processor is a programmable unit that operates
    on the incoming vertices and related data. It uses the vertex shader executable
    and run it on the vertex processor. The vertex shader needs to be programmed,
    compiled, and linked first in order to generate an executable, which can then
    be run on the vertex processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment processor**: This is another programmable unit in the OpenGL ES
    pipeline that operates on fragments and related data. The fragment processor uses
    the fragment shader executable to process fragment or pixel data. The fragment
    processor is responsible for calculating colors of the fragment. They cannot change
    the position of the fragments. They also cannot access neighboring fragments.
    However, they can discard the pixels. The computed color values from this shader
    are used to update the framebuffer memory and texture memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the sample codes for vertex and fragment shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Program the following vertex shader and store it into the `vertexShader` character
    type array variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Program the following fragment shader and store it into another character array
    type variable called `fragmentShader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most of the languages, the shader program also starts its control from
    the `main()` function. In both shader programs, the first line, `#version 300
    es`, specifies the GLES shading language version number, which is 3.0 in the present
    case. The vertex shader receives a per-vertex input variable `VertexPosition`.
    The data type of this variable is `vec4`, which is one of the inbuilt data types
    provided by OpenGL ES Shading Language. The `in` keyword in the beginning of the
    variable specifies that it is an incoming variable and it receives some data outside
    the scope of our current shader program. Similarly, the `out` keyword specifies
    that the variable is used to send some data value to the next stage of the shader.
    Similarly, the color information data is received in `VertexColor`. This color
    information is passed to `TriangleColor`, which sends this information to the
    fragment shader, and is the next stage of the processing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The `RadianAngle` is a uniform type of variable that contains the rotation angle.
    This angle is used to calculate rotation matrix into `rotation`. Refer to following
    *See also* section to get reference for the `per-vertex` attribute and `uniform`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: The input values received by `VertexPosition` are multiplied using the rotation
    matrix, which will rotate the geometry of our triangle. This value is assigned
    to `gl_Position`. The `gl_Position` is an inbuilt variable of the vertex shader.
    This variable is supposed to write the vertex position in the homogeneous form.
    This value can be used by any of the fixed functionality stages, such as primitive
    assembly, rasterization, culling, and so on. Refer to the *The fixed function
    and programmable pipeline architecture* recipe in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0,*
    for more information on the fixed stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fragment shader, the precision keyword specifies the default precision
    of all floating types (and aggregates, such as `mat4` and `vec4`) to be `mediump`.
    The acceptable values of such declared types need to fall within the range specified
    by the declared precision. OpenGL ES Shading Language supports three types of
    the precision: `lowp`, `mediump` and `highp`. Specifying the precision in the
    fragment shader is compulsory. However, for vertex, if the precision is not specified,
    it is consider to be highest (`highp`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`FragColor` is an `out` variable, which sends the calculated color values for
    each fragment to the next stage. It accepts the value in the RGBA color format.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned there are three types of precision qualifiers, the following table
    describes these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Qualifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `highp` | These variables provide the maximum range and precision. But they
    can cause operations to run more slowly on some implementations; generally, vertices
    have high precision. |'
  prefs: []
  type: TYPE_TB
- en: '| `lowp` | These variables may typically be used to store high dynamic range
    colors and low precision geometry. |'
  prefs: []
  type: TYPE_TB
- en: '| `mediump` | These variables may typically be used to store 8-bit color values.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The range and precision of these precision qualifiers are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B02491_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is taken from page 48 of [https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf](https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Loading and compiling a shader program*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the per-vertex attribute to send data to a shader*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using uniform variables to send data to a shader*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and compiling a shader program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shader program created in the previous recipe needs to be loaded and compiled
    into a binary form. This recipe will be helpful in understanding the procedure
    of loading and compiling a shader program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiling and linking a shader is necessary so that these programs are understandable
    and executable by the underlying graphics hardware/platform (that is, the vertex
    and fragment processors).
  prefs: []
  type: TYPE_NORMAL
- en: The following figure provides an overview of the complete process of creating
    a shader executable. The different number labels help us understand the order
    of flow in the build process. Each stage within the build process is marked with
    the respective OpenGL ES APIs responsible for it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B02491_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to load and compile the shader source, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `NativeTemplate.h`/`NativeTemplate.cpp` and define a function named
    `loadAndCompileShader` in it. Use the following code, and proceed to the next
    step for detailed information about this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function is responsible for loading and compiling a shader source. The
    argument `shaderType` accepts the type of shader that needs to be loaded and compiled;
    it can be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. The `sourceCode` specifies
    the source program of the corresponding shader.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an empty shader object using the `glCreateShader` OpenGL ES 3.0 API.
    This shader object is responsible for loading the vertex or fragment source code
    depending on the specified `shaderType` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'This API returns a non-zero value if the object is successfully created. This
    value is used as a handle to reference this object. On failure, this function
    returns `0`. The `shaderType` argument specifies the type of the shader to be
    created. It must be either `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike in C++, where object creation is transparent, in OpenGL ES, the objects
    are created behind the curtains. You can access, use, and delete the objects as
    and when required. All the objects are identified by a unique identifier, which
    can be used for programming purposes.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The created empty shader object (`shader`) needs to be bound first with the
    shader source in order to compile it. This binding is performed by using the `glShaderSource`
    API:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The API sets the shader code string in the shader object, `shader`. The source
    string is simply copied in the shader object; it is not parsed or scanned.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `shader` | This is the handle of the shader object whose source code needs
    to bind |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `count` | This is the number of elements in the string and length arrays
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `string` | This specifies the array of pointers to strings containing source
    code that needs to be loaded |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `length` | This specifies the array of string lengths |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: The count specifies the number of strings in the array. If the length array
    is `NULL`, this means that all the strings are null terminated. If the values
    inside in this array are non-zero, it specifies the length of the corresponding
    string. Any value less than `0` is assumed it to be a null-terminated string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compile the shader using the `glCompileShader` API. It accepts a shader object
    handle shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `shader` | This is the handle of the shader object that needs to be compiled
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The compilation status of the shader is stored as a state of the shader object.
    This state can be retrieved using the `glGetShaderiv` OpenGL ES API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `glGetShaderiv` API accepts the handle of the shader and `GL_COMPILE_STATUS`
    as an argument to check the status of the compilation. It retrieves the status
    in params. The params returns `GL_TRUE` if the last compilation was successful.
    Otherwise, it returns `GL_FALSE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `shader` | This is the handle of the shader object whose compilation status
    needs to be checked. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `pname` | This specifies the object''s state parameter. The symbolic names
    accepted are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`,
    and `GL_SHADER_SOURCE_LENGTH`. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `params` | This returns the requested object parameter state. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'In the case of compilation failure, the `glGetShaderiv` API can also be used
    to retrieve the information log from the OpenGL ES state machine by passing `GL_INFO_LOG_LENGTH`
    as the parameter. The `infoLen` returns the length of the information log. If
    the returned value is `0`, it means there is no information log. If the `infoLen`
    value is greater than `0`, then the information log message can be retrieved using
    `glGetShaderInfoLog`:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `glGetShaderInfoLog` to get the error report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `shader` | This is the handle of the shader object whose information log
    is required |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `maxLength` | This is the size of the character buffer to store the returned
    information log |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `length` | This is the length of the string returned by the information length
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `infoLog` | This specifies array of characters |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: The shader is deleted if the shader source cannot be compiled. Delete the shader
    object using the `glDeleteShader` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `shader` | This is the handle of the shader object that needs to be deleted
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Return the shader object ID if the shader is compiled successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `loadAndCompileShader` function first creates an empty shader object. This
    empty object is referenced by the `shader` variable. This object is bound with
    the source code of the corresponding shader. The source code is compiled through
    a shader object using the `glCompileShader` API. If the compilation is successful,
    the shader object handle is returned successfully. Otherwise, the shader object
    returns `0` and needs to be deleted explicitly using `glDeleteShader`. The status
    of the compilation can be checked using `glGetShaderiv` with `GL_COMPILE_STATUS`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to differentiate among various versions of OpenGL ES and GL Shading
    Language, it is useful to get this information from the current driver of your
    device. This will be helpful to make the program robust and manageable by avoiding
    errors caused by version upgrade or application being installed on older versions
    of OpenGL ES and GLSL. The other vital information can be queried from the current
    driver, such as the vendor, renderer, and available extensions supported by the
    device driver. This information can be queried using the `glGetString` API. This
    API accepts a symbolic constant and returns the queried system metrics in the
    string form. The `printGLString` wrapper function in our program helps in printing
    device metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Linking a shader program*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking a shader program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linking is a process of aggregating a set (vertex and fragment) of shaders into
    one program that maps to the entirety of the programmable phases of the OpenGL
    ES 3.0 graphics pipeline. The shaders are compiled using shader objects, as we
    created in the previous recipe. These objects are used to create special objects
    called program objects to link it to the OpenGL ES 3.0 pipeline. In this recipe,
    you will understand the shader linking process.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following instructions provides a step-by-step procedure to link as shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function, `linkShader`, in `NativeTemplate.cpp`.This will be the
    wrapper function to link a shader program to the OpenGL ES 3.0 pipeline. Follow
    these steps to understand this program in detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a program object with `glCreateProgram`. This API creates an empty program
    object using which the shader objects will be linked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach shader objects to the program object using the `glAttachShader` API.
    It is necessary to attach the shaders to the program object in order to create
    the program executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the syntax of the `glAttachShader` API:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This specifies the program object to which the shader object
    (shader) will be attached |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `shader` | This specifies the program object that is to be attached |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The shader must be linked to the program in order to create the program executable.
    The linking process is performed using `glLinkProgram`. This API links the program
    object, specified by the `program` identifier, which must contain the attached
    vertex and fragment shaders objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The status of the link operation can be checked using `glGetShaderiv`. This
    API accepts program and `GL_LINK_STATUS` as arguments. This will return `GL_TRUE`
    if the last link on program was successful; otherwise, it will return `GL_FALSE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This specifies the program object to be queried |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `pname` | This specifies symbolic state parameters |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `params` | This returns the requested program object parameter state |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: If link status is returned `GL_FALSE`, the program object must release its allocated
    memory using `glDeleteProgram`. This API undoes all the effects of `glCreateProgram`.
    It also invalidates the handle with which it was associated.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This specifies the handle of program that needs to be deleted
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `linkShader` wrapper function links the shader. It accepts two parameters:
    `vertShaderID` and `fragShaderID`. They are identifiers of the compiled shader
    objects. The `createProgram` function creates a program object. It is another
    OpenGL ES object to which shader objects are attached using `glAttachShader`.
    The shader objects can be detached from the program object if they are no longer
    in need. The program object is responsible for creating the executable program
    that runs on the programmable processor. A program in OpenGL ES is an executable
    in the OpenGL ES 3.0 pipeline that runs on the vertex and fragment processors.'
  prefs: []
  type: TYPE_NORMAL
- en: The program object is linked using `glLinkShader`. If the linking fails, the
    program object must be deleted using `glDeleteProgram`. When a program object
    is deleted it automatically detached the shader objects associated with it. The
    shader objects need to be deleted explicitly. If a program object is requested
    for deletion, it will only be deleted until it's not being used by some other
    rendering context in the current OpenGL ES state.
  prefs: []
  type: TYPE_NORMAL
- en: If the program's object link successfully, then one or more executable will
    be created, depending on the number of shaders attached with the program. The
    executable can be used at runtime with the help of the `glUseProgram` API. It
    makes the executable a part of the current OpenGL ES state.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Checking errors in OpenGL ES 3.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking errors in OpenGL ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While programming, it is very common to get unexpected results or errors in
    the programmed source code. It's important to make sure that the program does
    not generate any error. In such a case, you would like to handle the error gracefully.
    This section will guide us to track errors in the OpenGL ES 3.0 and GL shading
    language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenGL ES 3.0 allows us to check the error using a simple routine called `getGlError`.
    The following wrapper function prints all the error messages occurred in the programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getGlError` returns an error code. The following table describes these
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Error code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_NO_ERROR` | This indicates if no error found |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_INVALID_ENUM` | This indicates if the `GLenum` argument is out of range
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_INVALID_VALUE` | This indicates if the numeric argument is out of range
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_INVALID_OPERATION` | This indicates if the operation illegal in current
    state |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_STACK_OVERFLOW` | This indicates if the command would cause a stack overflow
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_STACK_UNDERFLOW` | This indicates if the command would cause a stack
    underflow |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_OUT_OF_MEMORY` | This indicates if there is not enough memory left to
    execute the command |'
  prefs: []
  type: TYPE_TB
- en: 'Here are few examples of code that produce OpenGL ES errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When OpenGL ES detects an error, it records the error into an error flag. Each
    error has a unique numeric code and symbolic name. OpenGL ES does not track each
    time an error has occurred. Due to performance reasons, detecting errors may degrade
    the rendering performance therefore, the error flag is not set until the `glGetError`
    routine is called. If there is no error detected, this routine will always return
    `GL_NO_ERRORS`. In distributed environment, there may be several error flags,
    therefore, it is advisable to call the `glGetError` routine in the loop, as this
    routine can record multiple error flags.
  prefs: []
  type: TYPE_NORMAL
- en: Using the per-vertex attribute to send data to a shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The per-vertex attribute in the shader programming helps receive data in the
    vertex shader from OpenGL ES program for each unique vertex attribute. The received
    data value is not shared among the vertices. The vertex coordinates, normal coordinates,
    texture coordinates, color information, and so on are the example of per-vertex
    attributes. The per-vertex attributes are meant for vertex shaders only, they
    cannot be directly available to the fragment shader. Instead, they are shared
    via the vertex shader through out variables.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the shaders are executed on the GPU that allows parallel processing
    of several vertices at the same time using multicore processors. In order to process
    the vertex information in the vertex shader, we need some mechanism that sends
    the data residing on the client side (CPU) to the shader on the server side (GPU).
    This recipe will be helpful to understand the use of per-vertex attributes to
    communicate with shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The vertex shader in the *Programming shaders in GL shading language 3.0* recipe
    contains two per-vertex attributes named `VertexPosition` and `VertexColor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `VertexPosition` contains the 3D coordinates of the triangle that defines
    the shape of the object that we intend to draw on the screen. The `VertexColor`
    contains the color information on each vertex of this geometry.
  prefs: []
  type: TYPE_NORMAL
- en: In the vertex shader, a non-negative attribute location ID uniquely identifies
    each vertex attribute. This attribute location is assigned at the compile time
    if not specified in the vertex shader program. For more information on specifying
    the ID, refer to the *See also* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, the logic of sending data to their shader is very simple. It''s
    a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query attribute**: Query the vertex attribute location ID from the shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attach data to the attribute**: Attach this ID to the data. This will create
    a bridge between the data and the per-vertex attribute specified using the ID.
    The OpenGL ES processing pipeline takes care of sending data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow this procedure to send data to a shader using the per-vertex attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare two global variables in `NativeTemplate.cpp` to store the queried attribute
    location IDs of `VertexPosition` and `VertexColor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Query the vertex attribute location using the `glGetAttribLocation` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This API provides a convenient way to query an attribute location from a shader.
    The return value must be greater than or equals to `0` in order to ensure that
    attribute with given name exists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This is the handle of a successfully linked OpenGL program |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | This is the name of the vertex attribute in the shader source program
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Send the data to the shader using the `glVertexAttribPointer` OpenGL ES API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The data associated with geometry is passed in the form of an array using the
    generic vertex attribute with the help of the `glVertexAttribPointer` API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `index` | This is the index of the generic vertex attribute. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `size` | This specifies the number of components per generic vertex attribute.
    The number must be `1`, `2`, `3`,or `4`. The initial value is `4`. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `type` | This is the data type of each component in the array containing
    geometry info. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `normalized` | This specifies whether any fixed-point data values should
    be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`)
    when they are accessed. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `stride` | This is used for consecutive generic attribute; it specifies the
    offset between them. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `pointer` | These are pointers to the first attribute of the array data.
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The generic vertex attributes in the shaders must be enabled by using the `glEnableVertexAttribArray`
    OpenGL ES API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's important to enable the attribute location. This allows us to access data
    on the shader side. By default, the vertex attributes are disabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `index` | This is the index of the generic vertex attribute to be enabled
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: Similarly, the attribute can be disabled using `glDisableVertexAttribArray`.
    This API has the same syntax as that of `glEnableVertexAttribArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store the incoming per-vertex attribute color `VertexColor` into the outgoing
    attribute `TriangleColor` in order to send it to the next stage (fragment shader):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Receive the color information from the vertex shader and set the fragment color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The per-vertex attribute variables `VertexPosition` and `VertexColor` defined
    in the vertex shader are the lifelines of the vertex shader. These lifelines constantly
    provide the data information form the client side (OpenGL ES program or CPU) to
    server side (GPU). Each per-vertex attribute has a unique attribute location available
    in the shader that can be queried using `glGetAttribLocation`. The per-vertex
    queried attribute locations are stored in `positionAttribHandle`; `colorAttribHandle`
    must be bound with the data using attribute location with `glVertexAttribPointer`.
    This API establishes a logical connection between client and server side. Now,
    the data is ready to flow from our data structures to the shader. The last important
    thing is the enabling of the attribute on the shader side for optimization purposes.
    By default, all the attribute are disabled. Therefore, even if the data is supplied
    for the client side, it is not visible at the server side. The `glEnableVertexAttribArray`
    API allows us to enable the per-vertex attributes on the shader side.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Managing variable attributes with qualifiers* recipe in [Chapter
    3](ch03.html "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL
    ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uniform variables to send data to a shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The uniform variables contain the data values that are global. They are shared
    by all vertices and fragments in the vertex and fragment shaders. Generally, some
    information that is not specific to the per-vertex is treated in the form of uniform
    variables. The uniform variable could exist in both the vertex and fragment shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The vertex shader we programmed in the *Programming shaders in OpenGL ES shading
    language 3.0 recipe* contains a uniform variable `RadianAngle`. This variable
    is used to rotate the rendered triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This variable will be updated on the client side (CPU) and send to the shader
    at server side (GPU) using special OpenGL ES 3.0 APIs. Similar to per-vertex attributes
    for uniform variables, we need to query and bind data in order to make it available
    in the shader.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to send data to a shader using uniform variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a global variable in `NativeTemplate.cpp` to store the queried attribute
    location IDs of `radianAngle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Query the uniform variable location using the `glGetUniformLocation` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This API will return a value greater than or equal to `0` to ensure that a uniform
    variable with the given name exists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This is the handle of a successfully linked OpenGL ES program
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | This is the name of the uniform variable in the shader source program
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Send the updated radian value to the shader using the `glUniform1f` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are many variants of the `glUniform` API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `location` | This is the index of the uniform variable in the shader |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `v0` | This is the data value of type float that needs to be sent |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on other variants, refer to OpenGL ES 3.0 Reference Pages
    at [http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use a general form of 2D rotation to apply on the entire incoming vertex coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The uniform variable `RadianAngle` defined in the vertex shader is used to
    apply rotation transformation on the incoming per-vertex attribute `VertexPosition`.
    On the client side, this uniform variable is queried using `glGetUniformLocation`.
    This API returns the index of the uniform variable and stores it in `radianAngle`.
    This index will be used to bind the updated data information that is stored the
    radian with the `glUniform1f` OpenGL ES 3.0 API. Finally, the updated data reaches
    the vertex shader executable, where the general form of the Euler rotation is
    calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The rotation transformation is calculated in the form of 2 x 2 matrix rotation,
    which is later promoted to a 4 x 4 matrix when multiplied by `VertexPosition`.
    The resultant vertices cause to rotate the triangle in a 2D space.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Grouping uniforms and creating buffer objects* recipe in [Chapter
    3](ch03.html "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL
    ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming OpenGL ES 3.0 Hello World Triangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe basically comprises of all the knowledge we gathered from our previous
    recipes in this chapter. The output of this recipe will be a `NativeTemplate.h/cpp`
    file that contains OpenGL ES 3.0 code, which demonstrates a rotating colored triangle.
    The output of this recipe is not executable on its own. It needs a host application
    that provides the necessary OpenGL ES 3.0 prerequisites to render this program
    on a device screen. Therefore, this recipe will be used later by the following
    two recipes, which will provide the host environment for OpenGL ES 3.0 in Android
    and iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing Android OpenGL ES 3.0 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing iOS OpenGL ES 3.0 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe will provide all the necessary prerequisites that are required to
    set up OpenGL ES, rendering and querying necessary attributes from shaders to
    render our OpenGL ES 3.0 "Hello World Triangle" program. In this program, we will
    render a simple colored triangle on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL ES requires a physical size (pixels) to define a 2D rendering surface
    called a viewport. This is used to define the OpenGL ES Framebuffer size.
  prefs: []
  type: TYPE_NORMAL
- en: 'A buffer in OpenGL ES is a 2D array in the memory that represents pixels in
    the viewport region. OpenGL ES has three types of buffers: color buffer, depth
    buffer, and stencil buffer. These buffers are collectively known as a framebuffer.
    All the drawings commands effect the information in the framebuffer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The life cycle of this recipe is broadly divided into three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: Shaders are compiled and linked to create program objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resizing**: This state defines the viewport size of rendering surface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering**: This state uses the shader program object to render geometry
    on screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, these states are represented by the `GraphicsInit()`, `GraphicsResize()`,
    and `GraphicsRender()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to program this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `NativeTemplate.cpp` file and create a `createProgramExec` function.
    This is a high-level function to load, compile, and link a shader program. This
    function will return the program object ID after successful execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visit the loading and compiling a shader program and linking a shader program
    recipes for more information on the working of `loadAndCompileShader` and `linkShader`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `NativeTemplate.cpp`, create a function `GraphicsInit` and create the shader
    program object by calling `createProgramExec`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new function `GraphicsResize`. This will set the viewport region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The viewport determines the portion of the OpenGL ES surface window on which
    the rendering of the primitives will be performed. The viewport in OpenGL ES is
    set using the `glViewPort` API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `x`, `y` | These represent lower-left rectangle for viewport specified in
    pixels |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `width`, `height` | This specifies the width and height of the viewport in
    pixels |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Create the `gTriangleVertices` global variable that contains the vertices of
    the triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `GraphicsRender` renderer function. This function is responsible
    for rendering the scene. Add the following code in it and perform the following
    steps to understand this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose the appropriate buffer from the framebuffer (color, depth, and stencil)
    that we want to clear each time the frame is rendered using the `glClear` API.
    In our recipe, we want to clear color buffer. The `glClear` API can be used to
    select the buffers that needs to be cleared. This API accepts a bitwise `OR` argument
    mask that can be used to set any combination of buffers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `mask` | Bitwise `OR` masks, each mask points to a specific buffer. These
    masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`.
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: The possible value mask could be a bitwise or of `GL_COLOR_BUFFER_BIT` (color
    buffer), `GL_DEPTH_BUFFER_BIT` (depth buffer) and `GL_STENCIL_BUFFER_BIT` (stencil
    buffer).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Clear the color buffer with black color using the `glClearColor` API. This buffer
    is responsible for storing color information of the scene. It accepts the argument
    as RGBA space that ranges between 0.0 and 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a shader program and set as the current rendering state using the `glUseProgram`
    API. The `glUseProgram` API installs the program object specified by the program
    as the current rendering state. The program's executable for the vertex shader
    runs on the programmable vertex processor. Similarly, the fragment shader executable
    runs on the programmable fragment processor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This specifies the handle (ID) of the shader program. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Query the `VertexPosition` generic vertex attribute location ID from the vertex
    shader into `positionAttribHandle` using `glGetAttribLocation`. This location
    will be used to send triangle vertex data that is stored in `gTriangleVertices`
    to the shader using `glVertexAttribPointer`. Follow the same instruction in order
    to get the handle of `VertexColor` into `colorAttributeHandle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the generic vertex attribute location using `positionAttribHandle` before
    the rendering call and render the triangle geometry. Similarly, for the per-vertex
    color information, use `colorAttribHandle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the application starts, the control begins with `GraphicsInit`, where the
    system metrics are printed out to make sure that the device supports OpenGL ES
    3.0\. The OpenGL ES programmable pipeline requires vertex shader and fragment
    shader program executables in the rendering pipeline. The program object contains
    one or more executables after attaching the compiled shader objects and linking
    them to program. In the `createProgramExec` function the vertex and fragment shaders
    are compiled and linked, in order to generate the program object.
  prefs: []
  type: TYPE_NORMAL
- en: The `GraphicsResize` function generates the viewport of the given dimension.
    This is used internally by OpenGL ES 3.0 to maintain the framebuffer. In our current
    application, it is used to manage color buffer. Refer to the *There's more …*
    section for more information on other available buffers in OpenGL ES 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the rendering of the scene is performed by `GraphicsRender`, this function
    clears the color buffer with black background and renders the triangle on the
    screen. It uses a shader object program and sets it as the current rendering state
    using the `glUseProgram` API.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a frame is rendered, data is sent from the client side (CPU) to the
    shader executable on the server side (GPU) using `glVertexAttribPointer`. This
    function uses the queried generic vertex attribute to bind the data with OpenGL
    ES pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other buffers also available in OpenGL ES 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Depth buffer**: This is used to prevent background pixels from rendering
    if there is a closer pixel available. The rule of prevention of the pixels can
    be controlled using special depth rules provided by OpenGL ES 3.0\. For more information
    on this, refer to [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"),
    *OpenGL ES 3.0 Essentials*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stencil buffer**: The stencil buffer stores the per-pixel information and
    is used to limit the area of rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenGL ES API allows us to control each buffer separately. These buffers
    can be enabled and disabled as per the requirement of the rendering. The OpenGL
    ES can use any of these buffers (including color buffer) directly to act differently.
    These buffers can be set via preset values by using OpenGL ES APIs, such as `glClearColor`,
    `glClearDepthf`, and `glClearStencil`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can refer to [http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/)
    for more information on `glClearDepthf`, `glClearStencilAPI` and all other APIs.
    The same link can be used to explore OpenGL ES 3.0 official API specifications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Depth testing in OpenGL ES 3.0* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Developing an Android OpenGL ES 3.0 application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Developing an iOS OpenGL ES 3.0 application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JNI on Android to communicate with C/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications are typically developed in Java. However, at times, there
    could be requirements for the development of C/C++ code or for reusing an existing
    C/C++ library in Android. For example, if you are looking to develop for cross-platform
    deployment, then there is no better option than choosing C/C++ as the development
    language. The code in this book is written in C/C++ to meet cross-platform requirements.
    This recipe will provide a demo to communicate with C/C++ code from an Android
    Java application. You will learn how to call the C/C++ method from Java using
    **Java Native Interface** (**JNI**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JNI creates a bridge between Java and native code via JNI interfaces. The Android
    NDK provides all the necessary tools such as libraries, source files, and compilers
    to help in building native code. It is believed that the development of the native
    code is faster, compared to Java code. Therefore, native development is better
    for memory management, performance, and cross-platform development.
  prefs: []
  type: TYPE_NORMAL
- en: In our first recipe, you will learn to program C/C++ code in the Android Java
    application. In this recipe, we will create a UI `TextView` control in the Android
    framework and display its contents as a string message sent from the C/C++ code.
    Java communicates with C/C++ through static/shared libraries, the NDK uses JNI
    and provides a means to develop these libraries under a Java environment.
  prefs: []
  type: TYPE_NORMAL
- en: As a prerequisite for NDK development, you must add Android NDK into the PATH
    environment variable, so that the NDK APIs are directly accessible from the command-line
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an Android application with JNI support:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a New Android application project by going to **New** | **Android Application
    Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Application Name** as `HelloNativeDev`, **Project Name** as `CookbookNativeDev`,
    and **Package Name** as `com.cookbookgles`. You can provide the names as per your
    choice—there is no restriction:![How to do it...](img/B02491_01_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default settings and click on **Next** until the **Create Activity**
    page appears. Select **Blank Activity** from the given options and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the last **Blank Activity** page, change **Activity Name** to `NativeDevActivity`,
    and click on **Finish**. This will create the project solution, as shown here:![How
    to do it...](img/B02491_01_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The project solution contains various files and folders in it. Each of these
    has a specific role and responsibility, which is shown in the preceding image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to `src` | `com.cookbookgles` | `NativeDevActivity.java` and replace the
    code with the following code snippet. Compile and execute the program. This will
    generate the necessary classes, which will be used by JNI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new folder named `JNI` in the project solution. This folder will contain
    all the C/C++ files. Create another new folder `include` inside `JNI`. This will
    be used for header files. Add `HelloCookbookJNI.h` and `HelloCookbookJNI.c` under
    `include` and `JNI` folders, respectively. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HelloCookbookJNI.h`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`HelloCookbookJNI.c`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The JNI function syntax is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function name under JNI contains the complete hierarchical path of the
    location where it is defined in the project. The rules are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function name should be prefixed by `Java_`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting from the package name (`com.cookbookgles`), each hierarchical folder
    and filename must be concatenated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each concatenation must contain an underscore (`_`) between two consecutive
    names
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The name of the function will be defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full signature and name are given here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This process can be automated using the javah tool. For more information, refer
    to the *There more …* section):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add `Android.mk` under JNI. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The native code build process uses `Android.mk` for compilation of files. This
    makefile instructs the NDK compiler list of all the files that need to be compiled.
    It also maintains the order of files in which they need to be compiled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`LOCAL_PATH` is a predefined variable. It sets the path of the build system
    to the path of the current working directory. In other words, it is used to locate
    source files in the development tree It is specified with the current directory
    path using `$(call my-dir)`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `include $(CLEAR_VARS)` helps the build system to remove any previous existing
    variables. It makes sure that no system or local variables are used from other
    modules. Such a multiple declaration of the same variable across different makefiles
    can confuse the build system. This command cleans all the local predefined variables,
    such as `LOCAL_PATH`, `LOCAL_MODULE`, and `LOCAL_SRC_FILES`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE` is a system variable that contains the name of the library exported
    by JNI. On successful compilation of the native code, JNI will generate a library
    with the name specified in `LOCAL_MODULE`. In the current recipe, it is `JNINativeDev.so`.
    `LOCAL_SRC_FILE` helps the JNI compiler understand which files need to undergo
    compilation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include $(BUILD_SHARED_LIBRARY)` helps the compiler build the library into
    a dynamic form (for example, `.dll` on Windows or `.so` on Linux). These libraries
    can also be built into static form using `include $(BUILD_STATIC_LIBRARY)`. This
    recipe uses the shared library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a command-line terminal. Go to the current `JNI` folder path and execute
    `ndk-build`. This command, with the help of `Android.mk`, compiles the source
    files and generates the shared library called `JNINativeDev.so` in the `CookbookNativeDev\libs\armeabi`
    folder path:![How to do it...](img/B02491_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `NativeDevActivity.java`, you need to load the library before using
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Connect your physical Android device to the system and execute the Android project
    with *Ctrl* + *F11*. This will display the following output on the screen. You
    can access the first example in the sample code folder `simpleJNI`:![How to do
    it...](img/B02491_01_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the recipes in this book use the Android device as a target. You can
    also make use of Android emulators. The primary reason to avoid the use of emulation
    here is the spotty support available for Android emulator and slower performance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The regular Java code needs to know how to call the native C code. This is done
    by declaring functions in Java files where each function's signature is prefixed
    with a `native` keyword. The definition of these functions is defined in C/C++
    source files. These functions need to redeclare in the header files, which must
    be located in the `JNI` folder. These declarations are in a special syntax rule
    that the `ndk` build understands. The functions are finally made available to
    Java in the form of shared or static libraries. You need to call this shared/static
    library within the Java code to use these exported functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you learned the convention to produce the JNI function's native
    method signatures. While working on large projects, sometimes, it is cumbersome
    to make such changes as the code could be significantly large. Additionally, the
    chances of human errors are also substantially high.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately, the **javah tool** can be used to automate this process. It generates
    the C header and source files that are needed to implement native methods. It
    reads a Java class file and creates a C-language header file in the current working
    directory. The generated header and source files are used by C programs to reference
    an object's instance variables from the native source code. A detailed description
    of the usage of this tool is beyond the scope of this book. However, I highly
    recommend that you refer to the *See also* section for more information on this.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn JNI programming (JNI specification) in detail from [http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The javah tool reference is available at [http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an Android OpenGL ES 3.0 application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the NDK and JNI knowledge from the previous recipe to develop
    our first Android OpenGL ES 3.0 application. We will use our source code for `NativeTemplate.h`/`NativeTemplate.cpp`
    that we programmed in the *Programming OpenGL ES 3.0 Hello World Triangle* recipe.
    This recipe uses the Android framework to provide the necessary services to host
    the OpenGL ES program in it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our first Android OpenGL ES 3.0 recipe, we advise you to locate the sample
    `AndroidHelloWorldTriangle` recipe with this chapter. It will be helpful to import
    the contents to quickly build the application. To import recipes, refer to the
    *Opening a sample project in Android ADT and iOS* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the step-by-step procedure to program our first OpenGL ES 3.0 application
    in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a blank activity project by going to **New** | **Android Project**. Provide
    a proper name for the application and project. For example, specify **Application
    Name** as `AndroidBlueTriangle`, **Project Name** as `AndroidBlueTriangle`, and
    specify **Package Name** as `cookbookgles`. The package name in Java is equivalent
    to the namespace concept in C/C++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the last page, specify **Activity Name** as `GLESActivity`, **Layout Name**
    as `activity_gles`, and **Navigation Type** as `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Package Explorer**, browse to `AndroidBlueTriangle` | `src` | `cookbook.gles`.
    Here, you will find our `GLESActivity` class. Under the same package called `cookbook.gles`,
    add two new classes called `GLESView` and `GLESNativeLib`. In order to add a new
    class, right-click on the `cookbookgles` package in the package explorer and go
    to **New** | **Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the sample recipe `AndroidBlueTriangle` and copy/paste the contents of `GLESActivity.java`,
    `GLESView.java`, and `GLESNativeLib.java` to the respective files of your project.
    In the next section, you will better understand these files and the classes contained
    in them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called JNI under this project. Inside this folder, create `Android.mk`,
    `Application.mk`, `NativeTemplate.h`, and `NativeTemplate.cpp`. The `android.mk`
    native code makefile is used by the JNI, as discussed in the previous recipe.
    Use `HelloWorldAndroid` to copy the contents of these two files from source to
    their respective files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For OpenGL ES 3.0, `Android.mk` must contain the `-lEGL` and `-lGLESv3` flags
    in order to link with the EGL and OpenGL ES 3.0 libraries. Also, as we target
    Android devices running Android version 18 (Jelly Bean), the `Applicaton.mk` must
    contain the `APP_PLATFORM:=android-18` platform.![How to do it...](img/B02491_01_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the command-line terminal and run `ndk-build` inside the `jni` folder.
    Under Eclipse, refresh **Package Explorer** so that the library created by `ndk-build`
    is updated in the project. Here is the rendering output upon execution:![How to
    do it...](img/B02491_01_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first Android recipe for OpenGL ES 3.0 contains two OpenGL ES classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GLESActivity` is an extended version of Activity. Activity is an application
    component that allows various types of views on the screen. Each activity has
    a window region, within which various type of views are rendered. For our requirements,
    we need a surface where we can render OpenGL ES. Therefore, the `GLESActivity`
    class is using `GLESView` for viewing purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLESView` is our custom class that is extended from `GLSurfaceView`. It provides
    a surface for OpenGL ES rendering. It helps OpenGL ES know about various events,
    such as the status of activity, whether it is in active or sleep mode, whether
    it has changed its dimensions, and so on. `GLSurfaceView` provides some important
    class interfaces. Among them, the three most important ones are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLSurfaceView.EGLConfigChooser`: This class is responsible for choosing the
    correct EGL configuration, as per our requirements. Basically, an EGL is an interface
    between the OpenGL ES APIs and the rendering context. In order to use the correct
    rendering context, we should know the EGL configuration that suits our requirements.
    In this recipe, we have extended `ConfigChooser` from `GLSurfaceView.EGLconfigChooser`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLSurfaceView.EGLContextFactory`: The rendering context is very much dependent
    on the device hardware configuration. OpenGL ES APIs do not know or care about
    creating the rendering context. Your local SDK provider is responsible for providing
    an interface to create it and attach it to your local application system. In Android,
    it is accomplished with the `EGLContextFactory` class. This requires EGL configuration.
    We have already seen how the `EGLConfigChooser` class gave us the correct EGL
    configuration, as per our requirement. You need to use this configuration to create
    your custom `ContextFactory`, which is the extended version of `GLSurfaceView.EGLContextFactory`
    in our recipe.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create OpenGL ES 3.0 context, use the `eglCreateContext` function. This
    function accepts an attribute list where the second item belongs to the OpenGL
    ES version, which must be 3.0\. See the sample code give here for OpenGL ES 3.0
    support:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`GLSurfaceView.Renderer`: This provides the interface to manage OpenGL ES calls
    to render a frame. It calls the render function in loop.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeTemplate.cpp`: This is the native code file that contains OpenGL ES
    commands responsible for rendering the blue triangle on screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the Android OpenGL ES framework launches an activity, it first checks the
    available EGL configurations on device and chooses the one best suited to our
    requirements. This configuration is used to create OpenGL ES rendering context.
    Finally, rendering is performed by `GLSurfaceRenderer,` where it calls the native
    OpenGL ES code with the help of the `GLESNativeLib` class.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL ES rendering source is coded in `NativeTemplate.cpp`, which is exposed
    to the Android framework via the `libglNative.so` static library. This library
    is compiled from the NDK using the `ndk-build` command and is automatically stored
    under the folder `AndroidBlueTriangle` | `libs` | `armeabi` | `libglNative.so`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After compilation of an NDK build, the library generated is prefixed with `lib`.
    If the name mentioned in `Android.mk` is already prefixed with `lib`, then this
    prefixing is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can explore more about the official Android OpenGL ES and its framework
    classes at [http://developer.android.com/reference/android/opengl/package-summary.html](http://developer.android.com/reference/android/opengl/package-summary.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Software requirements for OpenGL ES 3.0 – Android ADT* recipe
    in [Appendix](apa.html "Appendix A. Supplementary Information on OpenGL ES 3.0"),
    *Supplementary Information on OpenGL ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using JNI on Android to communicate with C/C++*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an iOS OpenGL ES 3.0 application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Development of OpenGL ES applications on iOS is much simpler compared to Android.
    The iOS 7 SDK, Xcode 5.0, and later versions support OpenGL ES 3.0\. Using App
    Wizard in Xcode 5.0, the OpenGL ES 3.0 applications can be developed effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you should have iOS 7 support in your Xcode IDE. For more information,
    refer to the *Software requirements for OpenGL ES 3.0 – Android ADT* recipe in
    [Appendix](apa.html "Appendix A. Supplementary Information on OpenGL ES 3.0"),
    *Supplementary Information on OpenGL ES 3.0*. It's advisable to import the sample
    recipe `iOSHelloWorldTriangle` in the Xcode. This will be helpful in understanding
    the theory quickly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the step-by-step descriptions of the first iOS OpenGL ES 3.0 application:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development of an OpenGL ES 3.0 application uses Xcode App Wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Open Xcode, go to **File** | **New** | **Project**, select **OpenGL Game**,
    and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give **Product Name**, **Organization Name**, and **Company Identifier** as
    per your choice. For example, we are using `iOSBlueTriangle`, `macbook`, and `Cookbook`,
    respectively. Go to the **Next** page, select the location, and create project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete `ViewController.m` from the project navigator. Instead, we will use our
    own file. Go to **File** | **Add Files** to `iOSBlueTriangle`. Now, locate the
    source code provided with this book and open the `HelloWorldiOS` folder. Select
    `ViewController.mm`, `NativeTemplate.cpp`, and `NativeTemplate.h`, and add these
    into the project. Feel free to explore these added files. Build (*command* + *B*)
    and execute (*command* + *R*) the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The development of OpenGL ES in Xcode makes sure that the correct version of
    OpenGL ES is used. It is automatically resolved by the Xcode build system using
    **Deployment Target**. If the deployment target is iOS 7, then OpenGL ES 3.0 libraries
    are used; otherwise, OpenGL ES 2.0 libraries are used. If the code in source files
    uses fixed function pipeline programming APIs, then it is understood that OpenGL
    ES 1.1 is used. For our current recipe, make sure you have set **Deployment Target**
    to **7.0**:![How to do it...](img/B02491_01_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program handles reference counting by itself. Therefore, it is advised
    that you disable the **automatic** **reference count** (**ARC**) to build the
    program. Otherwise, the compilation may fail. Follow these steps to disable the
    ARC:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on you project in the organizer on the left-hand side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select your target in the next column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **Build Settings** tab at the top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll down to **Objective-C Automatic Reference Counting** (it may be listed
    as `CLANG_ENABLE_OBJC_ARC` under the **User-Defined** settings group) and set
    it to **NO**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Xcode provides an app wizard to the build the applications for iOS 7.0\.
    The OpenGL ES development uses GLKit, which was introduced in iOS 5.0\. The GLKit
    is an OpenGL ES development framework in objective C/C++. It is used to develop
    3D graphics applications for programmable pipeline architecture. Since we are
    developing a portable application that works across platforms, this kit might
    not be fully helpful for us (GLKit is in Objective C/C++) in that direction. We
    will create our custom graphics development framework, which will be helpful for
    portable applications across Android and iOS. We will use GLKit to build the bridge
    between our graphics development framework kit and iOS. We will introduce this
    framework in [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL
    ES 3.0 Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app wizard creates two classes for us, `AppDelegate` and `ViewController`.
    These classes are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppDelegate`: This class is inherited from `UIResponder<UIApplicationDelegate>`,
    which defines the interfaces for a `UIobject` that respond to touch and motion
    events. `UIApplication` and `UIView` are also derived from `UIResponder`. In iOS,
    the `UIApplication` class provides a centralized point of control to the underlying
    OS to coordinate with applications. Each `UIApplication` must implement some methods
    for `UIApplicationDelegate`, which provides the information on the key event happening
    with in an application. For example, such key events could be application launching,
    termination, memory status, and state transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewController`: GLKit provides a standard `View` and `Controller` analogy,
    through `GLKitView` and `GLKitController`. `ViewController` is derived from `GLKitController`.
    Both classes work together to accomplish the rendering job. `GLKitView` manages
    the frame buffer object for the application. It takes the responsibility of rendering
    a draw command into the framebuffer when it is updated. However, `GLKitController`
    provides the necessary interfaces to control the pace of frames and their rendering
    loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When iOS launches an application, it creates an instance of `UIResponder`,
    which basically creates the application object. This application object is a service
    for the application to provide a physical space in the screen window. This windowing
    is provided by the object of `UIWindow`, which will be created during the construction
    of `UIApplication`. This window object contains the desired view to display something
    on screen. In our case, this view should be some OpenGL rendering surface, which
    is provided by `GLKitController` to display. When the class object of `GLKitController`
    is created, it automatically creates the view associated with it. This helps the
    application to provide the necessary OpenGL rendering surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `didFinishLaunchingWithOptions` interface from `UIApplicationDelete` informs
    the event status of the application that it has completed loading. Within this
    event, we created the window and set the `ViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a subclass from `GLKitController` is extended, it''s very important that
    we override the `viewDidLoad` and `viewDidUnload` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `viewDidLoad` method helps create the rendering context and set up all its
    drawable properties for an appropriate configuration. To create an OpenGL ES 3.0
    render context, we use `initWithAPI`. It accepts `kEAGLRenderingAPIOpenGLES3`
    as an argument. This argument makes sure that the rendering context is meant for
    OpenGL ES 3.0 version.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify the rendering context properties to configure the format of the
    drawable frame buffer object, such as `drawableColorFormat`, `drawableDepthFormat`,
    `drawableStencilFormat` and `drawableMultisample`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is also a good place for initialization and other resource allocations.
    The last line is calling the setupGL `function[self setupGL]` in the objective
    C++ language syntax. Therefore, it is equivalent to this `setupGL()` in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The setupGL function sets the current context with the one we created in `viewDidApplication`.
    This is very important to make the OpenGL ES APIs work. The `glBindFramebuffer`
    and `glBindRenderbuffer` APIs help the other APIs to know which target framebuffer
    to render on. In OpenGLES, the data is rendered in a rectangular array of information
    buffer container called a framebuffer. A framebuffer comprises many other helping
    buffers, such as color, depth, and stencil buffer, to accomplish rendering on
    the screen window. Sometimes, there could be cases where we may lose framebuffer
    or the render buffer. In such cases, it is advisable to bind these buffers with
    these two functions before you call any OpenGL ES3.0 API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to render our application, we must override the `drawRect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `renderFrame` function contains all the necessary code to render blue triangle.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *The fixed function and programmable pipeline architecture* recipe
    in [Appendix](apa.html "Appendix A. Supplementary Information on OpenGL ES 3.0"),
    *Supplementary Information on OpenGL ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Software requirements for OpenGL ES 3.0 – iOS* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Building prototypes using the GLPI framework* recipe, [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
