- en: Chapter 1. OpenGL ES 3.0 on Android/iOS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Android/iOS 上的 OpenGL ES 3.0
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Programming shaders in OpenGL ES shading language 3.0
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenGL ES 着色语言 3.0 编程着色器
- en: Loading and compiling a shader program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和编译着色器程序
- en: Linking a shader program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接着色器程序
- en: Checking errors in OpenGL ES 3.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 OpenGL ES 3.0 中的错误
- en: Using the per-vertex attribute to send data to a shader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点属性将数据发送到着色器
- en: Using uniform variables to send data to a shader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统一变量将数据发送到着色器
- en: Programming OpenGL ES 3.0 Hello World Triangle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程 OpenGL ES 3.0 的 Hello World 三角形
- en: Using JNI on Android to communicate with C/C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 上使用 JNI 与 C/C++ 通信
- en: Developing an Android OpenGL ES 3.0 application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Android OpenGL ES 3.0 应用程序
- en: Developing an iOS OpenGL ES 3.0 application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 iOS OpenGL ES 3.0 应用程序
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: OpenGL ES 3.0 stands for Open Graphics Library for embedded systems version
    3.0\. It is a set of standard API specifications established by the Khronos Group.
    The Khronos Group is an association of members and organizations that are focused
    on producing open standards for royalty-free APIs. OpenGL ES 3.0 specifications
    were publicly released in August 2012\. These specifications are backward compatible
    with OpenGL ES 2.0, which is a well-known de facto standard for embedded systems
    to render 2D and 3D graphics. Embedded operating systems such as Android, iOS,
    BlackBerry, Bada, Windows, and many others support OpenGL ES.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 代表嵌入式系统版 Open Graphics Library 3.0。它是由 Khronos Group 建立的一套标准 API
    规范。Khronos Group 是一个由成员和组织组成的协会，专注于为免版税 API 产生开放标准。OpenGL ES 3.0 规范于 2012 年 8
    月公开发布。这些规范与 OpenGL ES 2.0 兼容，OpenGL ES 2.0 是嵌入式系统渲染 2D 和 3D 图形的公认事实标准。嵌入式操作系统，如
    Android、iOS、BlackBerry、Bada、Windows 以及许多其他操作系统都支持 OpenGL ES。
- en: OpenGL ES 3D APIs are the stripped-down version of OpenGL, which is a cross-platform
    standard 3D API on a desktop environment for Linux, various flavors of UNIX, Mac
    OS, and Windows. This stripped-down version is mainly focused on providing the
    capabilities of 3D graphics as per embedded system requirements such as low-power
    consumption, limited processing capabilities, and small memory footprints.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3D API 是 OpenGL 的简化版本，OpenGL 是一个跨平台的桌面环境 3D API，适用于 Linux、各种 UNIX
    版本、Mac OS 和 Windows。这个简化版本主要专注于根据嵌入式系统需求提供 3D 图形功能，如低功耗、有限的处理能力和小的内存占用。
- en: 'The OpenGL ES 2.0/3.0 graphics library is shading-language compliant, unlike
    its predecessor 1.1\. The major difference between OpenGL ES 1.1 and OpenGL ES
    2.0/3.0 is the graphics pipeline architecture. The graphics pipeline framework
    for the former is known as a fixed function pipeline, and for the latter, it is
    a programmable pipeline. These frameworks are explained in the following table:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 2.0/3.0 图形库与着色语言兼容，与其前身 1.1 不同。OpenGL ES 1.1 和 OpenGL ES 2.0/3.0 之间的主要区别是图形管线架构。前者的图形管线框架被称为固定功能管线，而后者的则是可编程管线。以下表格中解释了这些框架：
- en: '| OpenGL ES version | Architecture pipeline type | Need shader |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| OpenGL ES 版本 | 架构管线类型 | 需要着色器 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1.1 | Fixed function pipeline | No |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1.1 | 固定功能管线 | 否 |'
- en: '| 2.0 and 3.0 | Programmable pipeline | Yes |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 和 3.0 | 可编程管线 | 是 |'
- en: A pipeline is a set of events that occur in a predefined fixed sequence, from
    the moment input data is given to the graphic engine to the output generated data
    for rendering the frame. A frame refers to an image produced as an output on the
    screen by the graphics engine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 管线是一系列在预定义的固定顺序中发生的事件，从向图形引擎提供输入数据到生成用于渲染帧的输出数据。帧是指图形引擎在屏幕上生成的输出图像。
- en: Each frame in a fixed function pipeline architecture is generated by a fixed
    set of algorithms, calculations, and sequences of events. You can only specify
    what you want, but not how it will be calculated. For example, if you are interested
    in applying some light shading on your solid sphere model, then you will need
    to specify the light position, its intensity, material properties, and other similar
    attributes. The fixed pipeline uses these inputs and takes care of all the physics
    and mathematics required to generate the light shading. Therefore, you don't need
    to worry, as the how factor is fully abstracted. The good side of the fixed function
    pipeline is that it is very easy to understand and quick to program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定功能管线架构中，每一帧都是由一组固定的算法、计算和事件序列生成的。你只能指定你想要的内容，但不能指定如何计算。例如，如果你对在你的实心球体模型上应用一些光照着色感兴趣，那么你需要指定光照位置、其强度、材料属性和其他类似属性。固定管线使用这些输入，并负责生成光照着色所需的全部物理和数学。因此，你不必担心，因为“如何”因素已经完全抽象化。固定功能管线的优点是它非常容易理解，编程也很快。
- en: In contrast, with the programmable pipeline architecture, you not only need
    to specify what you want to achieve, but you also need to mention how to implement
    it. This pipeline also provides extraordinary capabilities through shaders. Shaders
    are the special programs that control your scene's geometry and shading appearance.
    For example, in order to achieve the same light-shading effect on solid sphere,
    you must know the basics of physics and mathematics in order to program the light-shading
    techniques. Since you are programming the behavior of light shading, you can fully
    control it. This opens up endless possibilities to create infinite shading effects.
    Shaders are super fast. They execute rendering in parallel-processing mode using
    **Graphics Processing Unit** (**GPU**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在可编程管线架构中，你不仅需要指定你想要实现的目标，还需要说明如何实现它。这个管线还通过着色器提供了非凡的能力。着色器是控制你的场景几何形状和着色外观的特殊程序。例如，为了在实心球体上实现相同的光照着色效果，你必须了解物理和数学的基本知识，以便编程光照着色技术。由于你正在编程光照着色的行为，你可以完全控制它。这为创建无限着色效果打开了无限可能。着色器非常快。它们使用**图形处理单元**（**GPU**）并行处理模式执行渲染。
- en: Now, the question is if fixed function pipeline is doing all the light physics
    and mathematical abstraction, then why do we need to understand it for programmable
    pipelines? The reason is with fixed pipeline, we can only do finite graphics capabilities,
    and it cannot be used to produce realistic graphics effectively. However, the
    programmable pipeline opens endless possibilities and opportunities to produce
    state-of-art graphics rendering.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是如果固定功能管线正在执行所有轻量级物理和数学抽象，那么为什么我们还需要理解它对于可编程管线呢？原因在于，使用固定管线，我们只能执行有限的图形功能，并且它不能有效地用于生成逼真的图形。然而，可编程管线为生成最先进的图形渲染提供了无限的可能性和机会。
- en: This chapter will provide OpenGL ES 3.0 development on Android and iOS. We will
    begin this chapter by understanding the basic programming of the OpenGL ES 3.0
    with the help of a simple example to render a triangle on the screen. You will
    learn how to set up and create your first application on both platforms step by
    step.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍在Android和iOS上使用OpenGL ES 3.0进行开发。我们将通过一个简单的示例来渲染屏幕上的三角形，了解OpenGL ES 3.0的基本编程。你将逐步学习如何在两个平台上设置和创建你的第一个应用程序。
- en: '**Understanding EGL**: The OpenGL ES APIs require the EGL as a prerequisite
    before they can effectively be used on the hardware devices. The EGL provides
    an interface between the OpenGL ES APIs and the underlying native windowing system.
    Different OS vendors have their own ways to manage the creation of drawing surfaces,
    communication with hardware devices, and other configurations to manage the rendering
    context. EGL provides an abstraction, how the underlying system needs to be implemented
    in a platform-independent way. The platform vendor''s SDK provides an implementation
    of EGL through their own framework. These can be directly used in the application
    to accomplish the development task quickly. For example, the iOS provides EGL
    through the EAGL (`EAGLContext`) class in conjunction with `GLkit` to create `GLSurface`.
    On the Android platform, the `GLView` class provides interfaces for EGL through
    `GLView.EGLContextFactory` and `GLView.EGLConfigChooser`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解 EGL**：OpenGL ES API 在能够有效地在硬件设备上使用之前，需要 EGL 作为先决条件。EGL 提供了 OpenGL ES API
    和底层本地窗口系统之间的接口。不同的操作系统供应商有自己的方式来管理绘图表面的创建、与硬件设备的通信以及其他配置来管理渲染上下文。EGL 提供了一种抽象，即底层系统需要以平台无关的方式实现。平台供应商的
    SDK 通过他们自己的框架提供了 EGL 的实现。这些可以直接在应用程序中使用，以快速完成开发任务。例如，iOS 通过 `EAGL (`EAGLContext`)
    类与 `GLkit` 一起提供 EGL 来创建 `GLSurface`。在 Android 平台上，`GLView` 类通过 `GLView.EGLContextFactory`
    和 `GLView.EGLConfigChooser` 提供了 EGL 的接口。'
- en: 'The EGL provides two important things to OpenGL ES APIs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: EGL 为 OpenGL ES API 提供了两件重要的事情：
- en: '**Rendering context**: This stores the data structure and important OpenGL
    ES states that are essentially required for rendering purpose'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染上下文**：这存储了渲染目的所必需的数据结构和重要的 OpenGL ES 状态'
- en: '**Drawing surface**: This provides the drawing surface to render primitives'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图表面**：这提供了渲染原语所需的绘图表面'
- en: 'The following screenshot shows the programmable pipeline architecture of OpenGL
    ES 3.0:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 OpenGL ES 3.0 的可编程管道架构：
- en: '![Introduction](img/B02491_01_12.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/B02491_01_12.jpg)'
- en: EGL works on top of the native windowing system, such as WGL (Windows), GLX,
    or X-Windows (Linux), or Mac OS X's Quartz. With EGL specifications, cross-platform
    development becomes easier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: EGL 在原生窗口系统之上运行，例如 WGL（Windows）、GLX 或 X-Windows（Linux）、或 Mac OS X 的 Quartz。有了
    EGL 规范，跨平台开发变得更加容易。
- en: 'EGL provides the following responsibilities:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: EGL 负责以下任务：
- en: Checking the available configuration to create rendering context of the device
    windowing system
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可用的配置以创建设备窗口系统的渲染上下文
- en: Creating the OpenGL rendering surface for drawing
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于绘图的 OpenGL 渲染表面
- en: Compatibility and interfacing with other graphics APIs such as OpenVG, OpenAL,
    and so on
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他图形 API（如 OpenVG、OpenAL 等）的兼容性和接口
- en: Managing resources such as texture mapping
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理资源，如纹理映射
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to the following link for more information on EGL [http://www.khronos.org/egl](http://www.khronos.org/egl).
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以参考以下链接获取有关 EGL 的更多信息 [http://www.khronos.org/egl](http://www.khronos.org/egl)。
- en: Programming shaders in OpenGL ES shading language 3.0
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenGL ES 着色语言 3.0 编程着色器
- en: OpenGL ES shading language 3.0 (also called as GLSL) is a C-like language that
    allows us to writes shaders for programmable processors in the OpenGL ES processing
    pipeline. Shaders are the small programs that run on the GPU in parallel. Without
    these programs, it is impossible to write OpenGL ES 3.0 programs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 着色语言 3.0（也称为 GLSL）是一种类似于 C 的语言，允许我们为 OpenGL ES 处理管道中的可编程处理器编写着色器。着色器是在
    GPU 上并行运行的程序。没有这些程序，编写 OpenGL ES 3.0 程序是不可能的。
- en: 'OpenGL ES 3.0 supports two type of shaders: vertex shader and fragment shader.
    Each shader has specific responsibilities. For example, the vertex shader is used
    to process geometric vertices; however, the fragment shader processes the pixels
    or fragment color information. More specially, the vertex shader processes the
    vertex information by applying 2D/3D transformation. The output of the vertex
    shader goes to the rasterizer where the fragments are produced. The fragments
    are processed by the fragment shader, which is responsible for coloring them.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 支持两种类型的着色器：顶点着色器和片段着色器。每个着色器都有特定的职责。例如，顶点着色器用于处理几何顶点；然而，片段着色器处理像素或片段颜色信息。更特别的是，顶点着色器通过应用
    2D/3D 变换来处理顶点信息。顶点着色器的输出传递到光栅化器，在那里生成片段。片段由片段着色器处理，它负责为它们上色。
- en: The order of execution of the shaders is fixed; the vertex shader is always
    executed first, followed by the fragment shader. Each shader can share its processed
    data with the next stage in the pipeline. The GLSL facilitates user-defined variables
    such as C language; these variables are used for input and output purposes. There
    are also inbuilt variables that track the states in the shaders to make decisions
    while processing data in these shaders. For example, the fragment shader provides
    a state where the incoming fragment can be tested to see if it belongs to the
    front face or back face of a polygon.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的执行顺序是固定的；顶点着色器总是首先执行，然后是片段着色器。每个着色器都可以将其处理后的数据与管道中的下一阶段共享。GLSL支持用户定义的变量，如C语言；这些变量用于输入和输出目的。还有内置变量，用于跟踪着色器中的状态，以便在处理这些着色器中的数据时做出决策。例如，片段着色器提供了一个状态，可以测试传入的片段是否属于多边形的正面或背面。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are two types of processors in the OpenGL ES 3.0 processing pipeline
    to execute vertex shader and fragment shader executables; it is called programmable
    processing unit:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES 3.0处理管道中，有两种类型的处理器用于执行顶点着色器和片段着色器可执行文件；它被称为可编程处理单元：
- en: '**Vertex processor**: The vertex processor is a programmable unit that operates
    on the incoming vertices and related data. It uses the vertex shader executable
    and run it on the vertex processor. The vertex shader needs to be programmed,
    compiled, and linked first in order to generate an executable, which can then
    be run on the vertex processor.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点处理器**：顶点处理器是一个可编程单元，它对传入的顶点和相关数据进行操作。它使用顶点着色器可执行文件并在顶点处理器上运行它。顶点着色器需要首先进行编程、编译和链接，以生成可执行文件，然后可以在顶点处理器上运行。'
- en: '**Fragment processor**: This is another programmable unit in the OpenGL ES
    pipeline that operates on fragments and related data. The fragment processor uses
    the fragment shader executable to process fragment or pixel data. The fragment
    processor is responsible for calculating colors of the fragment. They cannot change
    the position of the fragments. They also cannot access neighboring fragments.
    However, they can discard the pixels. The computed color values from this shader
    are used to update the framebuffer memory and texture memory.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段处理器**：这是OpenGL ES管道中的另一个可编程单元，它对片段和相关数据进行操作。片段处理器使用片段着色器可执行文件来处理片段或像素数据。片段处理器负责计算片段的颜色。它们不能改变片段的位置。它们也不能访问相邻的片段。然而，它们可以丢弃像素。从这个着色器计算出的颜色值用于更新帧缓冲区内存和纹理内存。'
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the sample codes for vertex and fragment shaders:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是顶点和片段着色器的示例代码：
- en: 'Program the following vertex shader and store it into the `vertexShader` character
    type array variable:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程以下顶点着色器并将其存储到`vertexShader`字符类型数组变量中：
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Program the following fragment shader and store it into another character array
    type variable called `fragmentShader`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程以下片段着色器并将其存储到另一个名为`fragmentShader`的字符数组类型变量中：
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Like most of the languages, the shader program also starts its control from
    the `main()` function. In both shader programs, the first line, `#version 300
    es`, specifies the GLES shading language version number, which is 3.0 in the present
    case. The vertex shader receives a per-vertex input variable `VertexPosition`.
    The data type of this variable is `vec4`, which is one of the inbuilt data types
    provided by OpenGL ES Shading Language. The `in` keyword in the beginning of the
    variable specifies that it is an incoming variable and it receives some data outside
    the scope of our current shader program. Similarly, the `out` keyword specifies
    that the variable is used to send some data value to the next stage of the shader.
    Similarly, the color information data is received in `VertexColor`. This color
    information is passed to `TriangleColor`, which sends this information to the
    fragment shader, and is the next stage of the processing pipeline.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，着色器程序也是从`main()`函数开始控制的。在两个着色器程序中，第一行`#version 300 es`指定了GLES着色语言版本号，在本例中为3.0。顶点着色器接收一个每个顶点的输入变量`VertexPosition`。这个变量的数据类型是`vec4`，它是OpenGL
    ES着色语言提供的内置数据类型之一。变量开头的`in`关键字指定它是一个传入变量，并接收一些数据，这些数据超出了我们当前着色器程序的作用域。同样，`out`关键字指定该变量用于将一些数据值发送到着色器的下一阶段。同样，颜色信息数据在`VertexColor`中接收。这些颜色信息传递给`TriangleColor`，它将此信息发送到片段着色器，这是处理管道的下一阶段。
- en: The `RadianAngle` is a uniform type of variable that contains the rotation angle.
    This angle is used to calculate rotation matrix into `rotation`. Refer to following
    *See also* section to get reference for the `per-vertex` attribute and `uniform`
    variables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadianAngle` 是一种包含旋转角度的统一类型变量。这个角度用于将旋转矩阵计算到 `rotation` 中。参考以下 *也参见* 部分，以获取关于
    `per-vertex` 属性和 `uniform` 变量的参考信息。'
- en: The input values received by `VertexPosition` are multiplied using the rotation
    matrix, which will rotate the geometry of our triangle. This value is assigned
    to `gl_Position`. The `gl_Position` is an inbuilt variable of the vertex shader.
    This variable is supposed to write the vertex position in the homogeneous form.
    This value can be used by any of the fixed functionality stages, such as primitive
    assembly, rasterization, culling, and so on. Refer to the *The fixed function
    and programmable pipeline architecture* recipe in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0,*
    for more information on the fixed stages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexPosition` 接收到的输入值通过旋转矩阵相乘，这将旋转我们三角形的几何形状。此值被分配给 `gl_Position`。`gl_Position`
    是顶点着色器的一个内置变量。这个变量应该以齐次形式写入顶点位置。此值可以被任何固定功能阶段使用，例如原语装配、光栅化、裁剪等。有关固定阶段的更多信息，请参考
    [附录](apa.html "附录 A. OpenGL ES 3.0 补充信息") 中的 *固定功能和可编程管道架构* 菜谱。'
- en: 'In the fragment shader, the precision keyword specifies the default precision
    of all floating types (and aggregates, such as `mat4` and `vec4`) to be `mediump`.
    The acceptable values of such declared types need to fall within the range specified
    by the declared precision. OpenGL ES Shading Language supports three types of
    the precision: `lowp`, `mediump` and `highp`. Specifying the precision in the
    fragment shader is compulsory. However, for vertex, if the precision is not specified,
    it is consider to be highest (`highp`).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，精度关键字指定了所有浮点类型（以及聚合，如 `mat4` 和 `vec4`）的默认精度为 `mediump`。此类声明的类型的可接受值需要落在声明的精度指定的范围内。OpenGL
    ES 着色语言支持三种精度类型：`lowp`、`mediump` 和 `highp`。在片段着色器中指定精度是强制性的。然而，对于顶点，如果未指定精度，则默认为最高精度（`highp`）。
- en: '`FragColor` is an `out` variable, which sends the calculated color values for
    each fragment to the next stage. It accepts the value in the RGBA color format.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragColor` 是一个 `out` 变量，它将每个片段计算出的颜色值发送到下一阶段。它接受 RGBA 颜色格式的值。'
- en: There's more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'As mentioned there are three types of precision qualifiers, the following table
    describes these:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有三种精度限定符类型，以下表格描述了这些类型：
- en: '| Qualifier | Description |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 限定符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `highp` | These variables provide the maximum range and precision. But they
    can cause operations to run more slowly on some implementations; generally, vertices
    have high precision. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `highp` | 这些变量提供最大范围和精度。但它们可能导致某些实现中的操作运行得更慢；通常，顶点具有高精度。|'
- en: '| `lowp` | These variables may typically be used to store high dynamic range
    colors and low precision geometry. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `lowp` | 这些变量通常用于存储高动态范围颜色和低精度几何形状。|'
- en: '| `mediump` | These variables may typically be used to store 8-bit color values.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `mediump` | 这些变量通常用于存储 8 位颜色值。|'
- en: 'The range and precision of these precision qualifiers are shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些精度限定符的范围和精度如下所示：
- en: '![There''s more…](img/B02491_01_18.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/B02491_01_18.jpg)'
- en: The preceding image is taken from page 48 of [https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf](https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片来自 [https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf](https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf)
    的第 48 页。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: '**Downloading the example code**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以直接将文件通过电子邮件发送给您。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: See also
- en: '*Loading and compiling a shader program*'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载和编译着色器程序*'
- en: '*Using the per-vertex attribute to send data to a shader*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点属性将数据发送到着色器* '
- en: '*Using uniform variables to send data to a shader*'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用统一变量向着色器发送数据*'
- en: Loading and compiling a shader program
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和编译着色器程序
- en: The shader program created in the previous recipe needs to be loaded and compiled
    into a binary form. This recipe will be helpful in understanding the procedure
    of loading and compiling a shader program.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中创建的着色器程序需要加载并编译成二进制形式。本菜谱将有助于理解加载和编译着色器程序的过程。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Compiling and linking a shader is necessary so that these programs are understandable
    and executable by the underlying graphics hardware/platform (that is, the vertex
    and fragment processors).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和链接着色器是必要的，这样这些程序才能被底层图形硬件/平台（即顶点和片段处理器）理解和执行。
- en: The following figure provides an overview of the complete process of creating
    a shader executable. The different number labels help us understand the order
    of flow in the build process. Each stage within the build process is marked with
    the respective OpenGL ES APIs responsible for it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下图提供了创建着色器可执行文件的完整过程的概述。不同的数字标签帮助我们理解构建过程中的流程顺序。构建过程中的每个阶段都标记了负责它的相应 OpenGL
    ES API。
- en: '![Getting ready](img/B02491_01_13.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/B02491_01_13.jpg)'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to load and compile the shader source, use the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载和编译着色器源代码，请按照以下步骤操作：
- en: 'Create a `NativeTemplate.h`/`NativeTemplate.cpp` and define a function named
    `loadAndCompileShader` in it. Use the following code, and proceed to the next
    step for detailed information about this function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `NativeTemplate.h`/`NativeTemplate.cpp` 文件，并在其中定义一个名为 `loadAndCompileShader`
    的函数。使用以下代码，然后继续下一步以获取有关此函数的详细信息：
- en: '[PRE2]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is responsible for loading and compiling a shader source. The
    argument `shaderType` accepts the type of shader that needs to be loaded and compiled;
    it can be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. The `sourceCode` specifies
    the source program of the corresponding shader.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数负责加载和编译着色器源代码。参数 `shaderType` 接受需要加载和编译的着色器类型；可以是 `GL_VERTEX_SHADER` 或 `GL_FRAGMENT_SHADER`。`sourceCode`
    指定了相应着色器的源程序。
- en: 'Create an empty shader object using the `glCreateShader` OpenGL ES 3.0 API.
    This shader object is responsible for loading the vertex or fragment source code
    depending on the specified `shaderType` parameter:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 OpenGL ES 3.0 API 的 `glCreateShader` 创建一个空着色器对象。此着色器对象负责根据指定的 `shaderType`
    参数加载顶点或片段源代码：
- en: '**Syntax**:'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE3]'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This API returns a non-zero value if the object is successfully created. This
    value is used as a handle to reference this object. On failure, this function
    returns `0`. The `shaderType` argument specifies the type of the shader to be
    created. It must be either `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果对象成功创建，此 API 返回非零值。此值用作引用此对象的句柄。如果失败，此函数返回 `0`。`shaderType` 参数指定要创建的着色器类型。它必须是
    `GL_VERTEX_SHADER` 或 `GL_FRAGMENT_SHADER`：
- en: '[PRE4]'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike in C++, where object creation is transparent, in OpenGL ES, the objects
    are created behind the curtains. You can access, use, and delete the objects as
    and when required. All the objects are identified by a unique identifier, which
    can be used for programming purposes.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 C++ 中的对象创建是透明的不同，在 OpenGL ES 中，对象是在幕后创建的。您可以根据需要访问、使用和删除对象。所有对象都由一个唯一的标识符识别，可用于编程目的。
- en: 'The created empty shader object (`shader`) needs to be bound first with the
    shader source in order to compile it. This binding is performed by using the `glShaderSource`
    API:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建的空着色器对象（`shader`）需要首先与着色器源绑定，以便进行编译。此绑定是通过使用 `glShaderSource` API 实现的：
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The API sets the shader code string in the shader object, `shader`. The source
    string is simply copied in the shader object; it is not parsed or scanned.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 API 在着色器对象 `shader` 中设置着色器代码字符串。源字符串简单地复制到着色器对象中；它不会被解析或扫描。
- en: '**Syntax**:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| Variable | Description |'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `shader` | This is the handle of the shader object whose source code needs
    to bind |'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `shader` | 这是需要绑定的着色器对象的句柄 |'
- en: '| `count` | This is the number of elements in the string and length arrays
    |'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `count` | 这是字符串和长度数组中的元素数量 |'
- en: '| `string` | This specifies the array of pointers to strings containing source
    code that needs to be loaded |'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `string` | 这指定了包含需要加载的源代码的字符串指针数组 |'
- en: '| `length` | This specifies the array of string lengths |'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `length` | 这指定了字符串长度的数组 |'
- en: The count specifies the number of strings in the array. If the length array
    is `NULL`, this means that all the strings are null terminated. If the values
    inside in this array are non-zero, it specifies the length of the corresponding
    string. Any value less than `0` is assumed it to be a null-terminated string.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计数指定了数组中的字符串数量。如果长度数组是 `NULL`，这意味着所有字符串都是空终止的。如果此数组中的值非零，则指定对应字符串的长度。任何小于 `0`
    的值都假定它是一个空终止的字符串。
- en: 'Compile the shader using the `glCompileShader` API. It accepts a shader object
    handle shader:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glCompileShader` API 编译着色器。它接受一个着色器对象句柄 shader：
- en: '[PRE7]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Syntax**:'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE8]'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Variable | Description |'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `shader` | This is the handle of the shader object that needs to be compiled
    |'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `shader` | 这是需要编译的着色器对象的句柄 |'
- en: 'The compilation status of the shader is stored as a state of the shader object.
    This state can be retrieved using the `glGetShaderiv` OpenGL ES API:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器的编译状态存储为着色器对象的状态。可以使用 `glGetShaderiv` OpenGL ES API 检索此状态：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `glGetShaderiv` API accepts the handle of the shader and `GL_COMPILE_STATUS`
    as an argument to check the status of the compilation. It retrieves the status
    in params. The params returns `GL_TRUE` if the last compilation was successful.
    Otherwise, it returns `GL_FALSE`.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`glGetShaderiv` API 接受着色器句柄和 `GL_COMPILE_STATUS` 作为参数来检查编译状态。它将状态检索到 params
    中。如果最后的编译成功，params 返回 `GL_TRUE`。否则，它返回 `GL_FALSE`。'
- en: '**Syntax**:'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Variable | Description |'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `shader` | This is the handle of the shader object whose compilation status
    needs to be checked. |'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `shader` | 这是需要检查编译状态的着色器对象的句柄。 |'
- en: '| `pname` | This specifies the object''s state parameter. The symbolic names
    accepted are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`,
    and `GL_SHADER_SOURCE_LENGTH`. |'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `pname` | 这指定了对象的状态参数。接受的符号名称是 `GL_SHADER_TYPE`、`GL_DELETE_STATUS`、`GL_COMPILE_STATUS`、`GL_INFO_LOG_LENGTH`
    和 `GL_SHADER_SOURCE_LENGTH`。 |'
- en: '| `params` | This returns the requested object parameter state. |'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `params` | 这返回请求的对象参数状态。 |'
- en: 'In the case of compilation failure, the `glGetShaderiv` API can also be used
    to retrieve the information log from the OpenGL ES state machine by passing `GL_INFO_LOG_LENGTH`
    as the parameter. The `infoLen` returns the length of the information log. If
    the returned value is `0`, it means there is no information log. If the `infoLen`
    value is greater than `0`, then the information log message can be retrieved using
    `glGetShaderInfoLog`:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果编译失败，可以使用 `glGetShaderiv` API 通过传递 `GL_INFO_LOG_LENGTH` 作为参数从 OpenGL ES 状态机检索信息日志。`infoLen`
    返回信息日志的长度。如果返回的值是 `0`，则表示没有信息日志。如果 `infoLen` 值大于 `0`，则可以使用 `glGetShaderInfoLog`
    检索信息日志消息：
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use `glGetShaderInfoLog` to get the error report:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glGetShaderInfoLog` 获取错误报告：
- en: '**Syntax**:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Variable | Description |'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `shader` | This is the handle of the shader object whose information log
    is required |'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `shader` | 这是需要获取信息日志的着色器对象的句柄 |'
- en: '| `maxLength` | This is the size of the character buffer to store the returned
    information log |'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `maxLength` | 这是存储返回的信息日志的字符缓冲区的大小 |'
- en: '| `length` | This is the length of the string returned by the information length
    |'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `length` | 这是信息长度返回的字符串长度 |'
- en: '| `infoLog` | This specifies array of characters |'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `infoLog` | 这指定了字符数组 |'
- en: The shader is deleted if the shader source cannot be compiled. Delete the shader
    object using the `glDeleteShader` API.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果着色器源无法编译，则删除着色器。使用 `glDeleteShader` API 删除着色器对象。
- en: '**Syntax**:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE13]'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| Variable | Description |'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `shader` | This is the handle of the shader object that needs to be deleted
    |'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `shader` | 这是需要删除的着色器对象的句柄 |'
- en: 'Return the shader object ID if the shader is compiled successfully:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果着色器编译成功，则返回着色器对象 ID：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `loadAndCompileShader` function first creates an empty shader object. This
    empty object is referenced by the `shader` variable. This object is bound with
    the source code of the corresponding shader. The source code is compiled through
    a shader object using the `glCompileShader` API. If the compilation is successful,
    the shader object handle is returned successfully. Otherwise, the shader object
    returns `0` and needs to be deleted explicitly using `glDeleteShader`. The status
    of the compilation can be checked using `glGetShaderiv` with `GL_COMPILE_STATUS`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadAndCompileShader`函数首先创建一个空的着色器对象。这个空对象由`shader`变量引用。此对象与相应着色器的源代码绑定。源代码通过着色器对象使用`glCompileShader`
    API进行编译。如果编译成功，则成功返回着色器对象句柄。否则，着色器对象返回`0`，需要显式使用`glDeleteShader`删除。可以使用`glGetShaderiv`与`GL_COMPILE_STATUS`检查编译状态。'
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In order to differentiate among various versions of OpenGL ES and GL Shading
    Language, it is useful to get this information from the current driver of your
    device. This will be helpful to make the program robust and manageable by avoiding
    errors caused by version upgrade or application being installed on older versions
    of OpenGL ES and GLSL. The other vital information can be queried from the current
    driver, such as the vendor, renderer, and available extensions supported by the
    device driver. This information can be queried using the `glGetString` API. This
    API accepts a symbolic constant and returns the queried system metrics in the
    string form. The `printGLString` wrapper function in our program helps in printing
    device metrics:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分不同版本的OpenGL ES和GL着色语言，从您设备的当前驱动程序中获取此信息是有用的。这将有助于使程序健壮且易于管理，避免由于版本升级或安装在较旧版本的OpenGL
    ES和GLSL上的应用程序而引起的错误。其他关键信息也可以从当前驱动程序中查询，例如供应商、渲染器和设备驱动程序支持的可用扩展。可以使用`glGetString`
    API查询这些信息。此API接受一个符号常量，并以字符串形式返回查询的系统度量值。我们程序中的`printGLString`包装函数有助于打印设备度量：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Linking a shader program*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将着色器程序链接*'
- en: Linking a shader program
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将着色器程序链接
- en: Linking is a process of aggregating a set (vertex and fragment) of shaders into
    one program that maps to the entirety of the programmable phases of the OpenGL
    ES 3.0 graphics pipeline. The shaders are compiled using shader objects, as we
    created in the previous recipe. These objects are used to create special objects
    called program objects to link it to the OpenGL ES 3.0 pipeline. In this recipe,
    you will understand the shader linking process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是一个将一组（顶点和片段）着色器聚合为一个程序的过程，该程序映射到OpenGL ES 3.0图形管道的可编程阶段的全集。着色器使用我们在前面的菜谱中创建的着色器对象进行编译。这些对象用于创建称为程序对象的特殊对象，以将其链接到OpenGL
    ES 3.0管道。在本菜谱中，您将了解着色器链接过程。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following instructions provides a step-by-step procedure to link as shader:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令提供了一步一步的过程来链接一个着色器：
- en: 'Create a new function, `linkShader`, in `NativeTemplate.cpp`.This will be the
    wrapper function to link a shader program to the OpenGL ES 3.0 pipeline. Follow
    these steps to understand this program in detail:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemplate.cpp`中创建一个新的函数`linkShader`。这将是将着色器程序链接到OpenGL ES 3.0管道的包装函数。按照以下步骤详细了解此程序：
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a program object with `glCreateProgram`. This API creates an empty program
    object using which the shader objects will be linked:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glCreateProgram`创建一个程序对象。此API使用一个空的程序对象创建，该对象用于链接着色器对象：
- en: '[PRE17]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Syntax**:'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE18]'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Attach shader objects to the program object using the `glAttachShader` API.
    It is necessary to attach the shaders to the program object in order to create
    the program executable:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glAttachShader` API将着色器对象附加到程序对象。为了创建可执行程序，必须将着色器附加到程序对象：
- en: '[PRE19]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the syntax of the `glAttachShader` API:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是`glAttachShader` API的语法：
- en: '**Syntax**:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| Variable | Description |'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This specifies the program object to which the shader object
    (shader) will be attached |'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这指定了将要附加着色器对象（着色器）的程序对象 |'
- en: '| `shader` | This specifies the program object that is to be attached |'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `shader` | 这指定了将要附加的程序对象 |'
- en: 'The shader must be linked to the program in order to create the program executable.
    The linking process is performed using `glLinkProgram`. This API links the program
    object, specified by the `program` identifier, which must contain the attached
    vertex and fragment shaders objects:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建程序可执行文件，着色器必须链接到程序。链接过程是通过 `glLinkProgram` 执行的。此API通过 `program` 标识符链接程序对象，该标识符必须包含附加的顶点和片段着色器对象：
- en: '[PRE21]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The status of the link operation can be checked using `glGetShaderiv`. This
    API accepts program and `GL_LINK_STATUS` as arguments. This will return `GL_TRUE`
    if the last link on program was successful; otherwise, it will return `GL_FALSE`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `glGetShaderiv` 来检查链接操作的状态。此API接受程序和 `GL_LINK_STATUS` 作为参数。如果程序上的最后一个链接成功，它将返回
    `GL_TRUE`；否则，它将返回 `GL_FALSE`。
- en: '**Syntax**:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE22]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Variable | Description |'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This specifies the program object to be queried |'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这指定了要查询的程序对象 |'
- en: '| `pname` | This specifies symbolic state parameters |'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `pname` | 这指定了符号状态参数 |'
- en: '| `params` | This returns the requested program object parameter state |'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `params` | 这返回请求的程序对象参数状态 |'
- en: If link status is returned `GL_FALSE`, the program object must release its allocated
    memory using `glDeleteProgram`. This API undoes all the effects of `glCreateProgram`.
    It also invalidates the handle with which it was associated.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果返回的链接状态是 `GL_FALSE`，则必须使用 `glDeleteProgram` 释放程序对象占用的内存。此API撤销了 `glCreateProgram`
    的所有效果。它还使与之关联的句柄无效。
- en: '**Syntax**:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE23]'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Variable | Description |'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This specifies the handle of program that needs to be deleted
    |'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这指定了需要删除的程序句柄 |'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `linkShader` wrapper function links the shader. It accepts two parameters:
    `vertShaderID` and `fragShaderID`. They are identifiers of the compiled shader
    objects. The `createProgram` function creates a program object. It is another
    OpenGL ES object to which shader objects are attached using `glAttachShader`.
    The shader objects can be detached from the program object if they are no longer
    in need. The program object is responsible for creating the executable program
    that runs on the programmable processor. A program in OpenGL ES is an executable
    in the OpenGL ES 3.0 pipeline that runs on the vertex and fragment processors.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`linkShader` 包装函数用于链接着色器。它接受两个参数：`vertShaderID` 和 `fragShaderID`。它们是编译后的着色器对象的标识符。`createProgram`
    函数创建程序对象。这是另一个OpenGL ES对象，着色器对象通过 `glAttachShader` 附加到该对象上。如果不再需要，着色器对象可以从程序对象中分离。程序对象负责创建在可编程处理器上运行的可执行程序。在OpenGL
    ES中，程序是OpenGL ES 3.0管道中运行的、在顶点和片段处理器上运行的可执行文件。'
- en: The program object is linked using `glLinkShader`. If the linking fails, the
    program object must be deleted using `glDeleteProgram`. When a program object
    is deleted it automatically detached the shader objects associated with it. The
    shader objects need to be deleted explicitly. If a program object is requested
    for deletion, it will only be deleted until it's not being used by some other
    rendering context in the current OpenGL ES state.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 程序对象是通过 `glLinkShader` 链接的。如果链接失败，则必须使用 `glDeleteProgram` 删除程序对象。当程序对象被删除时，它将自动断开与其关联的着色器对象。需要显式删除着色器对象。如果请求删除程序对象，它将仅在当前OpenGL
    ES状态中不被其他渲染上下文使用时被删除。
- en: If the program's object link successfully, then one or more executable will
    be created, depending on the number of shaders attached with the program. The
    executable can be used at runtime with the help of the `glUseProgram` API. It
    makes the executable a part of the current OpenGL ES state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序的对象链接成功，则将创建一个或多个可执行文件，具体取决于与程序附加的着色器的数量。可执行文件可以在运行时通过 `glUseProgram` API
    的帮助使用。这使得可执行文件成为当前OpenGL ES状态的组成部分。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Checking errors in OpenGL ES 3.0*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查OpenGL ES 3.0中的错误*'
- en: Checking errors in OpenGL ES 3.0
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查OpenGL ES 3.0中的错误
- en: While programming, it is very common to get unexpected results or errors in
    the programmed source code. It's important to make sure that the program does
    not generate any error. In such a case, you would like to handle the error gracefully.
    This section will guide us to track errors in the OpenGL ES 3.0 and GL shading
    language.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，遇到意外的结果或错误在源代码中是非常常见的。确保程序不生成任何错误非常重要。在这种情况下，您可能希望优雅地处理错误。本节将指导我们跟踪OpenGL
    ES 3.0和GL着色语言中的错误。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'OpenGL ES 3.0 allows us to check the error using a simple routine called `getGlError`.
    The following wrapper function prints all the error messages occurred in the programming:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 允许我们使用一个简单的名为 `getGlError` 的例程来检查错误。以下包装函数会打印出编程过程中发生的所有错误信息：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `getGlError` returns an error code. The following table describes these
    errors:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGlError` 返回一个错误代码。以下表格描述了这些错误：'
- en: '**Syntax**:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Error code | Description |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 错误代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GL_NO_ERROR` | This indicates if no error found |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `GL_NO_ERROR` | 这表示没有发现错误 |'
- en: '| `GL_INVALID_ENUM` | This indicates if the `GLenum` argument is out of range
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `GL_INVALID_ENUM` | 这表示 `GLenum` 参数超出了范围 |'
- en: '| `GL_INVALID_VALUE` | This indicates if the numeric argument is out of range
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `GL_INVALID_VALUE` | 这表示数值参数超出了范围 |'
- en: '| `GL_INVALID_OPERATION` | This indicates if the operation illegal in current
    state |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `GL_INVALID_OPERATION` | 这表示在当前状态下操作非法 |'
- en: '| `GL_STACK_OVERFLOW` | This indicates if the command would cause a stack overflow
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `GL_STACK_OVERFLOW` | 这表示命令会导致栈溢出 |'
- en: '| `GL_STACK_UNDERFLOW` | This indicates if the command would cause a stack
    underflow |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `GL_STACK_UNDERFLOW` | 这表示命令会导致栈下溢 |'
- en: '| `GL_OUT_OF_MEMORY` | This indicates if there is not enough memory left to
    execute the command |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `GL_OUT_OF_MEMORY` | 这表示执行命令时没有足够的内存 |'
- en: 'Here are few examples of code that produce OpenGL ES errors:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些产生 OpenGL ES 错误的代码示例：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When OpenGL ES detects an error, it records the error into an error flag. Each
    error has a unique numeric code and symbolic name. OpenGL ES does not track each
    time an error has occurred. Due to performance reasons, detecting errors may degrade
    the rendering performance therefore, the error flag is not set until the `glGetError`
    routine is called. If there is no error detected, this routine will always return
    `GL_NO_ERRORS`. In distributed environment, there may be several error flags,
    therefore, it is advisable to call the `glGetError` routine in the loop, as this
    routine can record multiple error flags.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当 OpenGL ES 检测到错误时，它会将错误记录到错误标志中。每个错误都有一个唯一的数值代码和符号名称。OpenGL ES 不会跟踪每次错误发生的情况。由于性能原因，检测错误可能会降低渲染性能，因此，错误标志不会在调用
    `glGetError` 例程之前设置。如果没有检测到错误，此例程将始终返回 `GL_NO_ERRORS`。在分布式环境中，可能有多个错误标志，因此，建议在循环中调用
    `glGetError` 例程，因为此例程可以记录多个错误标志。
- en: Using the per-vertex attribute to send data to a shader
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点属性向着色器发送数据
- en: The per-vertex attribute in the shader programming helps receive data in the
    vertex shader from OpenGL ES program for each unique vertex attribute. The received
    data value is not shared among the vertices. The vertex coordinates, normal coordinates,
    texture coordinates, color information, and so on are the example of per-vertex
    attributes. The per-vertex attributes are meant for vertex shaders only, they
    cannot be directly available to the fragment shader. Instead, they are shared
    via the vertex shader through out variables.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器编程中，每个顶点的属性有助于从 OpenGL ES 程序接收每个唯一顶点属性的数据。接收到的数据值不会在顶点之间共享。顶点坐标、法线坐标、纹理坐标、颜色信息等都是顶点属性的例子。顶点属性仅用于顶点着色器，它们不能直接提供给片段着色器。相反，它们通过顶点着色器中的变量进行共享。
- en: Typically, the shaders are executed on the GPU that allows parallel processing
    of several vertices at the same time using multicore processors. In order to process
    the vertex information in the vertex shader, we need some mechanism that sends
    the data residing on the client side (CPU) to the shader on the server side (GPU).
    This recipe will be helpful to understand the use of per-vertex attributes to
    communicate with shaders.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，着色器在 GPU 上执行，允许使用多核处理器并行处理多个顶点。为了在顶点着色器中处理顶点信息，我们需要一些机制将位于客户端（CPU）上的数据发送到服务器端（GPU）上的着色器。这个配方将有助于理解使用顶点属性与着色器通信的使用方法。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The vertex shader in the *Programming shaders in GL shading language 3.0* recipe
    contains two per-vertex attributes named `VertexPosition` and `VertexColor`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *GL 着色语言 3.0 中编写着色器* 的配方中，顶点着色器包含两个名为 `VertexPosition` 和 `VertexColor` 的顶点属性：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `VertexPosition` contains the 3D coordinates of the triangle that defines
    the shape of the object that we intend to draw on the screen. The `VertexColor`
    contains the color information on each vertex of this geometry.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexPosition` 包含定义我们要在屏幕上绘制的物体形状的三角形的 3D 坐标。`VertexColor` 包含该几何体每个顶点的颜色信息。'
- en: In the vertex shader, a non-negative attribute location ID uniquely identifies
    each vertex attribute. This attribute location is assigned at the compile time
    if not specified in the vertex shader program. For more information on specifying
    the ID, refer to the *See also* section of this recipe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，一个非负属性位置ID唯一标识每个顶点属性。如果未在顶点着色器程序中指定，则该属性位置在编译时分配。有关指定ID的更多信息，请参阅本食谱的*另请参阅*部分。
- en: 'Basically, the logic of sending data to their shader is very simple. It''s
    a two-step process:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，将数据发送到其着色器的逻辑非常简单。这是一个两步的过程：
- en: '**Query attribute**: Query the vertex attribute location ID from the shader.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询属性**: 从着色器中查询顶点属性位置ID。'
- en: '**Attach data to the attribute**: Attach this ID to the data. This will create
    a bridge between the data and the per-vertex attribute specified using the ID.
    The OpenGL ES processing pipeline takes care of sending data.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将数据附加到属性**: 将此ID附加到数据。这将创建数据与使用ID指定的每个顶点属性之间的桥梁。OpenGL ES处理管道负责发送数据。'
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow this procedure to send data to a shader using the per-vertex attribute:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用每个顶点属性将数据发送到着色器：
- en: 'Declare two global variables in `NativeTemplate.cpp` to store the queried attribute
    location IDs of `VertexPosition` and `VertexColor`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemplate.cpp`中声明两个全局变量以存储查询到的`VertexPosition`和`VertexColor`的属性位置ID：
- en: '[PRE28]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Query the vertex attribute location using the `glGetAttribLocation` API:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glGetAttribLocation` API查询顶点属性位置：
- en: '[PRE29]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This API provides a convenient way to query an attribute location from a shader.
    The return value must be greater than or equals to `0` in order to ensure that
    attribute with given name exists.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此API提供了一个方便的方法来从着色器查询属性位置。返回值必须大于或等于`0`，以确保存在具有给定名称的属性。
- en: '**Syntax**:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| Variable | Description |'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This is the handle of a successfully linked OpenGL program |'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这是成功链接的OpenGL程序的句柄 |'
- en: '| `name` | This is the name of the vertex attribute in the shader source program
    |'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `name` | 这是着色器源程序中顶点属性的名字 |'
- en: 'Send the data to the shader using the `glVertexAttribPointer` OpenGL ES API:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glVertexAttribPointer` OpenGL ES API将数据发送到着色器：
- en: '[PRE31]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The data associated with geometry is passed in the form of an array using the
    generic vertex attribute with the help of the `glVertexAttribPointer` API.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与几何数据相关联的数据以数组的格式通过`glVertexAttribPointer` API使用通用顶点属性传递。
- en: '**Syntax**:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE32]'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| Variable | Description |'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `index` | This is the index of the generic vertex attribute. |'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `index` | 这是通用顶点属性的索引。 |'
- en: '| `size` | This specifies the number of components per generic vertex attribute.
    The number must be `1`, `2`, `3`,or `4`. The initial value is `4`. |'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `size` | 这指定了每个通用顶点属性中组件的数量。该数字必须是`1`、`2`、`3`或`4`。初始值是`4`。 |'
- en: '| `type` | This is the data type of each component in the array containing
    geometry info. |'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `type` | 这是包含几何信息数组的每个组件的数据类型。 |'
- en: '| `normalized` | This specifies whether any fixed-point data values should
    be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`)
    when they are accessed. |'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `normalized` | 这指定了在访问时是否应该规范化（`GL_TRUE`）或直接转换为定点值（`GL_FALSE`）的任何定点数据值。 |'
- en: '| `stride` | This is used for consecutive generic attribute; it specifies the
    offset between them. |'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `stride` | 这用于连续的通用属性；它指定它们之间的偏移量。 |'
- en: '| `pointer` | These are pointers to the first attribute of the array data.
    |'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `pointer` | 这些是指向数组数据中第一个属性指针的指针。 |'
- en: 'The generic vertex attributes in the shaders must be enabled by using the `glEnableVertexAttribArray`
    OpenGL ES API:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器中的通用顶点属性必须通过使用`glEnableVertexAttribArray` OpenGL ES API启用：
- en: '[PRE33]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's important to enable the attribute location. This allows us to access data
    on the shader side. By default, the vertex attributes are disabled.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用属性位置非常重要。这允许我们在着色器侧访问数据。默认情况下，顶点属性是禁用的。
- en: '**Syntax**:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE34]'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| Variable | Description |'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `index` | This is the index of the generic vertex attribute to be enabled
    |'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `index` | 这是将要启用的通用顶点属性的索引 |'
- en: Similarly, the attribute can be disabled using `glDisableVertexAttribArray`.
    This API has the same syntax as that of `glEnableVertexAttribArray`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，可以使用`glDisableVertexAttribArray`禁用属性。此API与`glEnableVertexAttribArray`具有相同的语法。
- en: 'Store the incoming per-vertex attribute color `VertexColor` into the outgoing
    attribute `TriangleColor` in order to send it to the next stage (fragment shader):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传入的每个顶点的属性颜色`VertexColor`存储到输出的属性`TriangleColor`中，以便将其发送到下一阶段（片段着色器）：
- en: '[PRE35]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Receive the color information from the vertex shader and set the fragment color:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶点着色器接收颜色信息并设置片段颜色：
- en: '[PRE36]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The per-vertex attribute variables `VertexPosition` and `VertexColor` defined
    in the vertex shader are the lifelines of the vertex shader. These lifelines constantly
    provide the data information form the client side (OpenGL ES program or CPU) to
    server side (GPU). Each per-vertex attribute has a unique attribute location available
    in the shader that can be queried using `glGetAttribLocation`. The per-vertex
    queried attribute locations are stored in `positionAttribHandle`; `colorAttribHandle`
    must be bound with the data using attribute location with `glVertexAttribPointer`.
    This API establishes a logical connection between client and server side. Now,
    the data is ready to flow from our data structures to the shader. The last important
    thing is the enabling of the attribute on the shader side for optimization purposes.
    By default, all the attribute are disabled. Therefore, even if the data is supplied
    for the client side, it is not visible at the server side. The `glEnableVertexAttribArray`
    API allows us to enable the per-vertex attributes on the shader side.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中定义的每个顶点属性变量`VertexPosition`和`VertexColor`是顶点着色器的生命线。这些生命线不断从客户端（OpenGL
    ES程序或CPU）向服务器端（GPU）提供数据信息。每个顶点属性都有一个唯一的属性位置，可以在着色器中使用`glGetAttribLocation`查询。每个顶点查询的属性位置存储在`positionAttribHandle`；`colorAttribHandle`必须使用属性位置与数据绑定，使用`glVertexAttribPointer`。此API在客户端和服务器端之间建立逻辑连接。现在，数据已准备好从我们的数据结构流向着色器。最后一件重要的事情是，为了优化目的，在着色器端启用属性。默认情况下，所有属性都是禁用的。因此，即使为客户端提供了数据，在服务器端也是不可见的。`glEnableVertexAttribArray`
    API允许我们在着色器端启用每个顶点的属性。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the *Managing variable attributes with qualifiers* recipe in [Chapter
    3](ch03.html "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL
    ES 3.0*
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第3章](ch03.html "第3章。OpenGL ES 3.0的新特性")中*使用限定符管理变量属性*的配方，*OpenGL ES 3.0的新特性*
- en: Using uniform variables to send data to a shader
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常量变量将数据发送到着色器
- en: The uniform variables contain the data values that are global. They are shared
    by all vertices and fragments in the vertex and fragment shaders. Generally, some
    information that is not specific to the per-vertex is treated in the form of uniform
    variables. The uniform variable could exist in both the vertex and fragment shaders.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 常量变量包含全局的数据值。它们在顶点和片段着色器中由所有顶点和片段共享。通常，一些不特定于每个顶点的信息以常量变量的形式处理。常量变量可以存在于顶点和片段着色器中。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The vertex shader we programmed in the *Programming shaders in OpenGL ES shading
    language 3.0 recipe* contains a uniform variable `RadianAngle`. This variable
    is used to rotate the rendered triangle:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在*OpenGL ES着色语言3.0配方中的着色器编程*中编写的顶点着色器包含一个常量变量`RadianAngle`。该变量用于旋转渲染的三角形：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This variable will be updated on the client side (CPU) and send to the shader
    at server side (GPU) using special OpenGL ES 3.0 APIs. Similar to per-vertex attributes
    for uniform variables, we need to query and bind data in order to make it available
    in the shader.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量将在客户端（CPU）更新，并通过特殊的OpenGL ES 3.0 API发送到服务器端（GPU）。类似于每个顶点的属性对于常量变量，我们需要查询和绑定数据，以便使其在着色器中可用。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to send data to a shader using uniform variables:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用常量变量将数据发送到着色器：
- en: 'Declare a global variable in `NativeTemplate.cpp` to store the queried attribute
    location IDs of `radianAngle`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemplate.cpp`中声明一个全局变量以存储查询到的`radianAngle`属性位置ID：
- en: '[PRE38]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Query the uniform variable location using the `glGetUniformLocation` API:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glGetUniformLocation` API查询常量变量的位置：
- en: '[PRE39]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This API will return a value greater than or equal to `0` to ensure that a uniform
    variable with the given name exists.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此API将返回一个大于或等于`0`的值，以确保存在具有给定名称的常量变量。
- en: '**Syntax**:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE40]'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| Variable | Description |'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This is the handle of a successfully linked OpenGL ES program
    |'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这是成功链接的OpenGL ES程序的句柄 |'
- en: '| `name` | This is the name of the uniform variable in the shader source program
    |'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `name` | 这是着色器源程序中常量变量的名称 |'
- en: 'Send the updated radian value to the shader using the `glUniform1f` API:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glUniform1f` API将更新的弧度值发送到着色器：
- en: '[PRE41]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are many variants of the `glUniform` API.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`glUniform` API有许多变体。'
- en: '**Syntax**:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE42]'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| Variable | Description |'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `location` | This is the index of the uniform variable in the shader |'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `location` | 这是着色器中均匀变量的索引 |'
- en: '| `v0` | This is the data value of type float that needs to be sent |'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `v0` | 这是需要发送的浮点类型数据值 |'
- en: Note
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on other variants, refer to OpenGL ES 3.0 Reference Pages
    at [http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/).
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关其他变体的更多信息，请参阅[OpenGL ES 3.0参考页面](http://www.khronos.org/opengles/sdk/docs/man3/)。
- en: 'Use a general form of 2D rotation to apply on the entire incoming vertex coordinates:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用2D旋转的一般形式应用于所有传入的顶点坐标：
- en: '[PRE43]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The uniform variable `RadianAngle` defined in the vertex shader is used to
    apply rotation transformation on the incoming per-vertex attribute `VertexPosition`.
    On the client side, this uniform variable is queried using `glGetUniformLocation`.
    This API returns the index of the uniform variable and stores it in `radianAngle`.
    This index will be used to bind the updated data information that is stored the
    radian with the `glUniform1f` OpenGL ES 3.0 API. Finally, the updated data reaches
    the vertex shader executable, where the general form of the Euler rotation is
    calculated:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中定义的均匀变量 `RadianAngle` 用于对传入的每个顶点属性 `VertexPosition` 应用旋转变换。在客户端，此均匀变量通过
    `glGetUniformLocation` 查询。此API返回均匀变量的索引并将其存储在 `radianAngle` 中。此索引将用于绑定存储在 `radian`
    中的更新数据信息，使用 `glUniform1f` OpenGL ES 3.0 API。最后，更新后的数据达到顶点着色器可执行文件，其中计算了欧拉旋转的一般形式：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The rotation transformation is calculated in the form of 2 x 2 matrix rotation,
    which is later promoted to a 4 x 4 matrix when multiplied by `VertexPosition`.
    The resultant vertices cause to rotate the triangle in a 2D space.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转变换以2 x 2矩阵旋转的形式计算，随后在乘以 `VertexPosition` 时提升为4 x 4矩阵。结果顶点导致三角形在2D空间中旋转。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Grouping uniforms and creating buffer objects* recipe in [Chapter
    3](ch03.html "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL
    ES 3.0*
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第3章](ch03.html "第3章。OpenGL ES 3.0的新特性")中的*分组均匀变量和创建缓冲区对象*配方，*OpenGL ES 3.0的新特性*
- en: Programming OpenGL ES 3.0 Hello World Triangle
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程OpenGL ES 3.0 Hello World 三角形
- en: 'This recipe basically comprises of all the knowledge we gathered from our previous
    recipes in this chapter. The output of this recipe will be a `NativeTemplate.h/cpp`
    file that contains OpenGL ES 3.0 code, which demonstrates a rotating colored triangle.
    The output of this recipe is not executable on its own. It needs a host application
    that provides the necessary OpenGL ES 3.0 prerequisites to render this program
    on a device screen. Therefore, this recipe will be used later by the following
    two recipes, which will provide the host environment for OpenGL ES 3.0 in Android
    and iOS:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基本上包含了我们在此章节中之前配方中收集的所有知识。此配方的输出将是一个 `NativeTemplate.h/cpp` 文件，其中包含OpenGL
    ES 3.0代码，演示了一个旋转的彩色三角形。此配方的输出本身不可执行。它需要一个提供必要OpenGL ES 3.0先决条件的主应用程序，以便在设备屏幕上渲染此程序。因此，此配方将在以下两个配方中使用，这两个配方将为Android和iOS中的OpenGL
    ES 3.0提供主机环境：
- en: Developing Android OpenGL ES 3.0 application
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Android OpenGL ES 3.0应用程序
- en: Developing iOS OpenGL ES 3.0 application
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发iOS OpenGL ES 3.0应用程序
- en: This recipe will provide all the necessary prerequisites that are required to
    set up OpenGL ES, rendering and querying necessary attributes from shaders to
    render our OpenGL ES 3.0 "Hello World Triangle" program. In this program, we will
    render a simple colored triangle on the screen.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将提供设置OpenGL ES、渲染以及从着色器查询所需属性以渲染我们的OpenGL ES 3.0 "Hello World 三角形"程序所需的所有必要先决条件。在此程序中，我们将在屏幕上渲染一个简单的彩色三角形。
- en: Getting ready
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: OpenGL ES requires a physical size (pixels) to define a 2D rendering surface
    called a viewport. This is used to define the OpenGL ES Framebuffer size.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES需要一个物理尺寸（像素）来定义一个名为视口的2D渲染表面。这用于定义OpenGL ES帧缓冲区的大小。
- en: 'A buffer in OpenGL ES is a 2D array in the memory that represents pixels in
    the viewport region. OpenGL ES has three types of buffers: color buffer, depth
    buffer, and stencil buffer. These buffers are collectively known as a framebuffer.
    All the drawings commands effect the information in the framebuffer.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL ES 中，缓冲区是内存中的 2D 数组，它表示视口区域中的像素。OpenGL ES 有三种类型的缓冲区：颜色缓冲区、深度缓冲区和模板缓冲区。这些缓冲区统称为帧缓冲区。所有绘图命令都会影响帧缓冲区中的信息。
- en: 'The life cycle of this recipe is broadly divided into three states:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的生命周期大致分为三个状态：
- en: '**Initialization**: Shaders are compiled and linked to create program objects'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：着色器被编译并链接以创建程序对象'
- en: '**Resizing**: This state defines the viewport size of rendering surface'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整大小**：此状态定义了渲染表面的视口大小'
- en: '**Rendering**: This state uses the shader program object to render geometry
    on screen'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染**：此状态使用着色器程序对象在屏幕上渲染几何图形'
- en: In our recipe, these states are represented by the `GraphicsInit()`, `GraphicsResize()`,
    and `GraphicsRender()` functions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，这些状态由 `GraphicsInit()`、`GraphicsResize()` 和 `GraphicsRender()` 函数表示。
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to program this recipe:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来编程这个配方：
- en: 'Use the `NativeTemplate.cpp` file and create a `createProgramExec` function.
    This is a high-level function to load, compile, and link a shader program. This
    function will return the program object ID after successful execution:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NativeTemplate.cpp` 文件并创建一个 `createProgramExec` 函数。这是一个高级函数，用于加载、编译和链接着色器程序。此函数在成功执行后将返回程序对象
    ID：
- en: '[PRE45]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Visit the loading and compiling a shader program and linking a shader program
    recipes for more information on the working of `loadAndCompileShader` and `linkShader`.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问加载和编译着色器程序以及链接着色器程序的配方，以获取有关 `loadAndCompileShader` 和 `linkShader` 工作原理的更多信息。
- en: 'Use `NativeTemplate.cpp`, create a function `GraphicsInit` and create the shader
    program object by calling `createProgramExec`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NativeTemplate.cpp`，创建一个 `GraphicsInit` 函数并通过调用 `createProgramExec` 创建着色器程序对象：
- en: '[PRE46]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new function `GraphicsResize`. This will set the viewport region:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数 `GraphicsResize`。这将设置视口区域：
- en: '[PRE47]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The viewport determines the portion of the OpenGL ES surface window on which
    the rendering of the primitives will be performed. The viewport in OpenGL ES is
    set using the `glViewPort` API.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 视口决定了在 OpenGL ES 表面窗口上执行原语渲染的部分。OpenGL ES 中的视口是通过 `glViewPort` API 设置的。
- en: '**Syntax**:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE48]'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '| Variable | Description |'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x`, `y` | These represent lower-left rectangle for viewport specified in
    pixels |'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `x`, `y` | 这些代表以像素为单位的视口指定的左下角矩形 |'
- en: '| `width`, `height` | This specifies the width and height of the viewport in
    pixels |'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `width`, `height` | 这指定了视口的宽度和高度（以像素为单位） |'
- en: 'Create the `gTriangleVertices` global variable that contains the vertices of
    the triangle:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含三角形顶点的全局变量 `gTriangleVertices`：
- en: '[PRE49]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create the `GraphicsRender` renderer function. This function is responsible
    for rendering the scene. Add the following code in it and perform the following
    steps to understand this function:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `GraphicsRender` 渲染器函数。此函数负责渲染场景。在它里面添加以下代码，并执行以下步骤来理解此函数：
- en: '[PRE50]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Choose the appropriate buffer from the framebuffer (color, depth, and stencil)
    that we want to clear each time the frame is rendered using the `glClear` API.
    In our recipe, we want to clear color buffer. The `glClear` API can be used to
    select the buffers that needs to be cleared. This API accepts a bitwise `OR` argument
    mask that can be used to set any combination of buffers.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每次渲染帧时想要清除的帧缓冲区（颜色、深度和模板）中适当的缓冲区，使用 `glClear` API。在我们的配方中，我们想要清除颜色缓冲区。`glClear`
    API 可以用来选择需要清除的缓冲区。此 API 接受一个位或（`OR`）参数掩码，可以用来设置任何组合的缓冲区。
- en: '**Syntax**:'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE51]'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| Variable | Description |'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mask` | Bitwise `OR` masks, each mask points to a specific buffer. These
    masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`.
    |'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `mask` | 位或（`OR`）掩码，每个掩码指向一个特定的缓冲区。这些掩码是 `GL_COLOR_BUFFER_BIT`、`GL_DEPTH_BUFFER_BIT`
    和 `GL_STENCIL_BUFFER_BIT`。 |'
- en: The possible value mask could be a bitwise or of `GL_COLOR_BUFFER_BIT` (color
    buffer), `GL_DEPTH_BUFFER_BIT` (depth buffer) and `GL_STENCIL_BUFFER_BIT` (stencil
    buffer).
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能的值掩码可以是 `GL_COLOR_BUFFER_BIT`（颜色缓冲区）、`GL_DEPTH_BUFFER_BIT`（深度缓冲区）和 `GL_STENCIL_BUFFER_BIT`（模板缓冲区）的位或。
- en: '[PRE52]'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Clear the color buffer with black color using the `glClearColor` API. This buffer
    is responsible for storing color information of the scene. It accepts the argument
    as RGBA space that ranges between 0.0 and 1.0.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glClearColor` API以黑色清除颜色缓冲区。这个缓冲区负责存储场景的颜色信息。它接受RGBA空间作为参数，范围在0.0到1.0之间。
- en: Use a shader program and set as the current rendering state using the `glUseProgram`
    API. The `glUseProgram` API installs the program object specified by the program
    as the current rendering state. The program's executable for the vertex shader
    runs on the programmable vertex processor. Similarly, the fragment shader executable
    runs on the programmable fragment processor.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用着色器程序，并通过`glUseProgram` API将其设置为当前渲染状态。`glUseProgram` API将指定的程序对象安装为当前渲染状态。顶点着色器的程序可执行文件在可编程顶点处理器上运行。同样，片段着色器的程序可执行文件在可编程片段处理器上运行。
- en: '**Syntax**:'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE53]'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| Variable | Description |'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This specifies the handle (ID) of the shader program. |'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这指定了着色器程序的句柄（ID）。|'
- en: 'Query the `VertexPosition` generic vertex attribute location ID from the vertex
    shader into `positionAttribHandle` using `glGetAttribLocation`. This location
    will be used to send triangle vertex data that is stored in `gTriangleVertices`
    to the shader using `glVertexAttribPointer`. Follow the same instruction in order
    to get the handle of `VertexColor` into `colorAttributeHandle`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glGetAttribLocation`从顶点着色器查询`VertexPosition`通用顶点属性位置ID到`positionAttribHandle`。这个位置将用于通过`glVertexAttribPointer`将存储在`gTriangleVertices`中的三角形顶点数据发送到着色器。按照相同的说明来获取`VertexColor`的句柄到`colorAttributeHandle`：
- en: '[PRE54]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Enable the generic vertex attribute location using `positionAttribHandle` before
    the rendering call and render the triangle geometry. Similarly, for the per-vertex
    color information, use `colorAttribHandle`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染调用之前，使用`positionAttribHandle`启用通用顶点属性位置，并渲染三角形几何形状。同样，对于每个顶点的颜色信息，使用`colorAttribHandle`：
- en: '[PRE55]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the application starts, the control begins with `GraphicsInit`, where the
    system metrics are printed out to make sure that the device supports OpenGL ES
    3.0\. The OpenGL ES programmable pipeline requires vertex shader and fragment
    shader program executables in the rendering pipeline. The program object contains
    one or more executables after attaching the compiled shader objects and linking
    them to program. In the `createProgramExec` function the vertex and fragment shaders
    are compiled and linked, in order to generate the program object.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，控制从`GraphicsInit`开始，其中打印系统度量以确保设备支持OpenGL ES 3.0。OpenGL ES可编程管道需要在渲染管道中包含顶点着色器和片段着色器程序的可执行文件。在附加编译后的着色器对象并将它们链接到程序之后，程序对象包含一个或多个可执行文件。在`createProgramExec`函数中，编译并链接顶点和片段着色器，以生成程序对象。
- en: The `GraphicsResize` function generates the viewport of the given dimension.
    This is used internally by OpenGL ES 3.0 to maintain the framebuffer. In our current
    application, it is used to manage color buffer. Refer to the *There's more …*
    section for more information on other available buffers in OpenGL ES 3.0.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphicsResize`函数生成给定维度的视口。OpenGL ES 3.0内部使用它来维护帧缓冲区。在我们的当前应用程序中，它用于管理颜色缓冲区。有关OpenGL
    ES 3.0中其他可用缓冲区的更多信息，请参阅*更多内容…*部分。'
- en: Finally, the rendering of the scene is performed by `GraphicsRender`, this function
    clears the color buffer with black background and renders the triangle on the
    screen. It uses a shader object program and sets it as the current rendering state
    using the `glUseProgram` API.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过`GraphicsRender`函数执行场景的渲染，这个函数使用黑色背景清除颜色缓冲区，并在屏幕上渲染三角形。它使用着色器对象程序，并通过`glUseProgram`
    API将其设置为当前渲染状态。
- en: Each time a frame is rendered, data is sent from the client side (CPU) to the
    shader executable on the server side (GPU) using `glVertexAttribPointer`. This
    function uses the queried generic vertex attribute to bind the data with OpenGL
    ES pipeline.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 每次渲染一帧时，数据都会通过`glVertexAttribPointer`从客户端（CPU）发送到服务器端（GPU）上的着色器可执行文件。这个函数使用查询到的通用顶点属性将数据与OpenGL
    ES管道绑定。
- en: There's more...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'There are other buffers also available in OpenGL ES 3.0:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES 3.0中，还有其他缓冲区可供使用：
- en: '**Depth buffer**: This is used to prevent background pixels from rendering
    if there is a closer pixel available. The rule of prevention of the pixels can
    be controlled using special depth rules provided by OpenGL ES 3.0\. For more information
    on this, refer to [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"),
    *OpenGL ES 3.0 Essentials*.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度缓冲区**：当存在更近的像素时，此功能用于防止背景像素的渲染。可以通过OpenGL ES 3.0提供的特殊深度规则来控制像素的预防规则。有关更多信息，请参阅[第2章](ch02.html
    "第2章。OpenGL ES 3.0基础")，*OpenGL ES 3.0基础*。'
- en: '**Stencil buffer**: The stencil buffer stores the per-pixel information and
    is used to limit the area of rendering.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板缓冲区**：模板缓冲区存储每个像素的信息，并用于限制渲染区域。'
- en: The OpenGL ES API allows us to control each buffer separately. These buffers
    can be enabled and disabled as per the requirement of the rendering. The OpenGL
    ES can use any of these buffers (including color buffer) directly to act differently.
    These buffers can be set via preset values by using OpenGL ES APIs, such as `glClearColor`,
    `glClearDepthf`, and `glClearStencil`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES API允许我们分别控制每个缓冲区。根据渲染需求，这些缓冲区可以被启用或禁用。OpenGL ES可以直接使用这些缓冲区（包括颜色缓冲区）以不同的方式操作。可以通过OpenGL
    ES API，如`glClearColor`、`glClearDepthf`和`glClearStencil`，使用预设值来设置这些缓冲区。
- en: Note
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to [http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/)
    for more information on `glClearDepthf`, `glClearStencilAPI` and all other APIs.
    The same link can be used to explore OpenGL ES 3.0 official API specifications.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考[http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/)以获取有关`glClearDepthf`、`glClearStencilAPI`以及所有其他API的更多信息。相同的链接可以用来探索OpenGL
    ES 3.0官方API规范。
- en: See also
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Depth testing in OpenGL ES 3.0* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。OpenGL ES 3.0基础")中的*OpenGL ES 3.0深度测试*配方，*OpenGL ES
    3.0基础*。
- en: '*Developing an Android OpenGL ES 3.0 application*'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发Android OpenGL ES 3.0应用程序*'
- en: '*Developing an iOS OpenGL ES 3.0 application*'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发iOS OpenGL ES 3.0应用程序*'
- en: Using JNI on Android to communicate with C/C++
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上使用JNI与C/C++通信
- en: Android applications are typically developed in Java. However, at times, there
    could be requirements for the development of C/C++ code or for reusing an existing
    C/C++ library in Android. For example, if you are looking to develop for cross-platform
    deployment, then there is no better option than choosing C/C++ as the development
    language. The code in this book is written in C/C++ to meet cross-platform requirements.
    This recipe will provide a demo to communicate with C/C++ code from an Android
    Java application. You will learn how to call the C/C++ method from Java using
    **Java Native Interface** (**JNI**).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序通常是用Java开发的。然而，有时可能需要开发C/C++代码或重用Android中的现有C/C++库。例如，如果您正在寻找跨平台部署的开发，那么选择C/C++作为开发语言将是一个更好的选择。本书中的代码是用C/C++编写的，以满足跨平台需求。本配方将提供一个示例，演示如何从Android
    Java应用程序中与C/C++代码进行通信。您将学习如何使用**Java本地接口**（**JNI**）从Java调用C/C++方法。
- en: Getting ready
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: JNI creates a bridge between Java and native code via JNI interfaces. The Android
    NDK provides all the necessary tools such as libraries, source files, and compilers
    to help in building native code. It is believed that the development of the native
    code is faster, compared to Java code. Therefore, native development is better
    for memory management, performance, and cross-platform development.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: JNI通过JNI接口在Java和本地代码之间创建了一座桥梁。Android NDK提供了所有必要的工具，如库、源文件和编译器，以帮助构建本地代码。据信，与Java代码相比，本地代码的开发速度更快。因此，本地开发在内存管理、性能和跨平台开发方面更为优越。
- en: In our first recipe, you will learn to program C/C++ code in the Android Java
    application. In this recipe, we will create a UI `TextView` control in the Android
    framework and display its contents as a string message sent from the C/C++ code.
    Java communicates with C/C++ through static/shared libraries, the NDK uses JNI
    and provides a means to develop these libraries under a Java environment.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个配方中，您将学习如何在Android Java应用程序中编程C/C++代码。在本配方中，我们将在Android框架中创建一个UI `TextView`控件，并显示从C/C++代码发送的字符串消息。Java通过静态/共享库与C/C++通信，NDK使用JNI，并提供在Java环境下开发这些库的方法。
- en: As a prerequisite for NDK development, you must add Android NDK into the PATH
    environment variable, so that the NDK APIs are directly accessible from the command-line
    terminal.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 NDK 开发的先决条件，您必须将 Android NDK 添加到 PATH 环境变量中，以便可以从命令行终端直接访问 NDK API。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create an Android application with JNI support:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个具有 JNI 支持的 Android 应用程序：
- en: Create a New Android application project by going to **New** | **Android Application
    Project**.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **新建** | **Android 应用程序项目** 创建一个新的 Android 应用程序项目。
- en: Set **Application Name** as `HelloNativeDev`, **Project Name** as `CookbookNativeDev`,
    and **Package Name** as `com.cookbookgles`. You can provide the names as per your
    choice—there is no restriction:![How to do it...](img/B02491_01_14.jpg)
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **应用程序名称** 设置为 `HelloNativeDev`，**项目名称** 设置为 `CookbookNativeDev`，**包名称** 设置为
    `com.cookbookgles`。您可以根据自己的选择提供名称——没有限制：![如何操作...](img/B02491_01_14.jpg)
- en: Accept the default settings and click on **Next** until the **Create Activity**
    page appears. Select **Blank Activity** from the given options and click on **Next**.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受默认设置并点击 **下一步**，直到出现 **创建活动** 页面。从提供的选项中选择 **空白活动** 并点击 **下一步**。
- en: On the last **Blank Activity** page, change **Activity Name** to `NativeDevActivity`,
    and click on **Finish**. This will create the project solution, as shown here:![How
    to do it...](img/B02491_01_15.jpg)
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后的 **空白活动** 页面上，将 **活动名称** 更改为 `NativeDevActivity`，然后点击 **完成**。这将创建项目解决方案，如图所示：![如何操作...](img/B02491_01_15.jpg)
- en: The project solution contains various files and folders in it. Each of these
    has a specific role and responsibility, which is shown in the preceding image.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 项目解决方案中包含各种文件和文件夹，每个都有其特定的角色和责任，如前图所示。
- en: 'Go to `src` | `com.cookbookgles` | `NativeDevActivity.java` and replace the
    code with the following code snippet. Compile and execute the program. This will
    generate the necessary classes, which will be used by JNI:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `src` | `com.cookbookgles` | `NativeDevActivity.java` 并将代码替换为以下代码片段。编译并执行程序。这将生成必要的类，这些类将被
    JNI 使用：
- en: '[PRE56]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a new folder named `JNI` in the project solution. This folder will contain
    all the C/C++ files. Create another new folder `include` inside `JNI`. This will
    be used for header files. Add `HelloCookbookJNI.h` and `HelloCookbookJNI.c` under
    `include` and `JNI` folders, respectively. Add the following code:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目解决方案中添加一个名为 `JNI` 的新文件夹。这个文件夹将包含所有的 C/C++ 文件。在 `JNI` 内部创建另一个新文件夹 `include`。这个文件夹将用于头文件。分别在
    `include` 和 `JNI` 文件夹下添加 `HelloCookbookJNI.h` 和 `HelloCookbookJNI.c`。添加以下代码：
- en: '`HelloCookbookJNI.h`:'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloCookbookJNI.h`：'
- en: '[PRE57]'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`HelloCookbookJNI.c`:'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloCookbookJNI.c`：'
- en: '[PRE58]'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The JNI function syntax is as follows:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JNI 函数的语法如下：
- en: '[PRE59]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The function name under JNI contains the complete hierarchical path of the
    location where it is defined in the project. The rules are as follows:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JNI 下的函数名包含它在项目中定义位置的完整层次路径。规则如下：
- en: The function name should be prefixed by `Java_`
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名应该以 `Java_` 为前缀。
- en: Starting from the package name (`com.cookbookgles`), each hierarchical folder
    and filename must be concatenated
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包名 (`com.cookbookgles`) 开始，每个层次文件夹和文件名必须连接起来
- en: Each concatenation must contain an underscore (`_`) between two consecutive
    names
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接必须包含两个连续名称之间的下划线 (`_`)。
- en: 'For example:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE60]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The name of the function will be defined as follows:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数的名称将如下定义：
- en: '[PRE61]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The full signature and name are given here:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整签名和名称如下：
- en: '[PRE62]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This process can be automated using the javah tool. For more information, refer
    to the *There more …* section):'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此过程可以使用 javah 工具自动化。有关更多信息，请参阅 *更多内容…* 部分）：
- en: 'Add `Android.mk` under JNI. Add the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JNI 下添加 `Android.mk`。添加以下代码：
- en: '[PRE63]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The native code build process uses `Android.mk` for compilation of files. This
    makefile instructs the NDK compiler list of all the files that need to be compiled.
    It also maintains the order of files in which they need to be compiled.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本地代码构建过程使用 `Android.mk` 进行文件编译。此 makefile 指示 NDK 编译器列出所有需要编译的文件。它还维护了需要编译的文件顺序。
- en: '`LOCAL_PATH` is a predefined variable. It sets the path of the build system
    to the path of the current working directory. In other words, it is used to locate
    source files in the development tree It is specified with the current directory
    path using `$(call my-dir)`.'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PATH` 是一个预定义变量。它将构建系统的路径设置为当前工作目录的路径。换句话说，它用于在开发树中定位源文件。它使用 `$(call
    my-dir)` 通过当前目录路径指定。'
- en: The `include $(CLEAR_VARS)` helps the build system to remove any previous existing
    variables. It makes sure that no system or local variables are used from other
    modules. Such a multiple declaration of the same variable across different makefiles
    can confuse the build system. This command cleans all the local predefined variables,
    such as `LOCAL_PATH`, `LOCAL_MODULE`, and `LOCAL_SRC_FILES`.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include $(CLEAR_VARS)`帮助构建系统删除任何之前存在的变量。它确保不会使用来自其他模块的系统或本地变量。这种在不同makefile中多次声明相同变量可能会使构建系统困惑。此命令清除所有本地预定义变量，例如`LOCAL_PATH`、`LOCAL_MODULE`和`LOCAL_SRC_FILES`。'
- en: '`LOCAL_MODULE` is a system variable that contains the name of the library exported
    by JNI. On successful compilation of the native code, JNI will generate a library
    with the name specified in `LOCAL_MODULE`. In the current recipe, it is `JNINativeDev.so`.
    `LOCAL_SRC_FILE` helps the JNI compiler understand which files need to undergo
    compilation.'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`是一个系统变量，包含JNI导出的库的名称。在原生代码成功编译后，JNI将生成一个名为`LOCAL_MODULE`中指定的库。在当前菜谱中，它是`JNINativeDev.so`。`LOCAL_SRC_FILE`帮助JNI编译器理解哪些文件需要编译。'
- en: '`include $(BUILD_SHARED_LIBRARY)` helps the compiler build the library into
    a dynamic form (for example, `.dll` on Windows or `.so` on Linux). These libraries
    can also be built into static form using `include $(BUILD_STATIC_LIBRARY)`. This
    recipe uses the shared library.'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include $(BUILD_SHARED_LIBRARY)`帮助编译器将库构建为动态形式（例如，Windows上的`.dll`或Linux上的`.so`）。这些库也可以使用`include
    $(BUILD_STATIC_LIBRARY)`构建为静态形式。这个菜谱使用的是共享库。'
- en: Open a command-line terminal. Go to the current `JNI` folder path and execute
    `ndk-build`. This command, with the help of `Android.mk`, compiles the source
    files and generates the shared library called `JNINativeDev.so` in the `CookbookNativeDev\libs\armeabi`
    folder path:![How to do it...](img/B02491_01_03.jpg)
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端。转到当前`JNI`文件夹路径并执行`ndk-build`。这个命令，在`Android.mk`的帮助下，编译源文件，并在`CookbookNativeDev\libs\armeabi`文件夹路径下生成名为`JNINativeDev.so`的共享库：![如何操作...](img/B02491_01_03.jpg)
- en: 'Inside `NativeDevActivity.java`, you need to load the library before using
    it:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeDevActivity.java`内部，在使用之前需要加载库：
- en: '[PRE64]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Connect your physical Android device to the system and execute the Android project
    with *Ctrl* + *F11*. This will display the following output on the screen. You
    can access the first example in the sample code folder `simpleJNI`:![How to do
    it...](img/B02491_01_04.jpg)
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的物理Android设备连接到系统，并使用*Ctrl* + *F11*执行Android项目。这将在屏幕上显示以下输出。你可以访问示例代码文件夹`simpleJNI`中的第一个示例：![如何操作...](img/B02491_01_04.jpg)
- en: Note
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of the recipes in this book use the Android device as a target. You can
    also make use of Android emulators. The primary reason to avoid the use of emulation
    here is the spotty support available for Android emulator and slower performance.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中的所有菜谱都使用Android设备作为目标。你也可以使用Android模拟器。避免使用模拟器的主要原因是Android模拟器的支持不完整，性能较慢。
- en: How it works...
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The regular Java code needs to know how to call the native C code. This is done
    by declaring functions in Java files where each function's signature is prefixed
    with a `native` keyword. The definition of these functions is defined in C/C++
    source files. These functions need to redeclare in the header files, which must
    be located in the `JNI` folder. These declarations are in a special syntax rule
    that the `ndk` build understands. The functions are finally made available to
    Java in the form of shared or static libraries. You need to call this shared/static
    library within the Java code to use these exported functions.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Java常规代码需要知道如何调用原生C代码。这是通过在Java文件中声明函数来实现的，每个函数的签名前都带有`native`关键字。这些函数的定义在C/C++源文件中定义。这些函数需要在头文件中重新声明，这些头文件必须位于`JNI`文件夹中。这些声明遵循`ndk`构建系统理解的特殊语法规则。这些函数最终以共享或静态库的形式提供给Java。您需要在Java代码中调用这个共享/静态库来使用这些导出的函数。
- en: There's more…
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: In this recipe, you learned the convention to produce the JNI function's native
    method signatures. While working on large projects, sometimes, it is cumbersome
    to make such changes as the code could be significantly large. Additionally, the
    chances of human errors are also substantially high.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你学习了生成JNI函数原生方法签名的约定。在处理大型项目时，有时进行这样的更改可能会很繁琐，因为代码可能非常大。此外，人为错误的可能性也相当高。
- en: Alternately, the **javah tool** can be used to automate this process. It generates
    the C header and source files that are needed to implement native methods. It
    reads a Java class file and creates a C-language header file in the current working
    directory. The generated header and source files are used by C programs to reference
    an object's instance variables from the native source code. A detailed description
    of the usage of this tool is beyond the scope of this book. However, I highly
    recommend that you refer to the *See also* section for more information on this.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用**javah工具**来自动化此过程。它生成实现本地方法所需的C头文件和源文件。它读取Java类文件，并在当前工作目录中创建一个C语言头文件。生成的头文件和源文件被C程序用于从本地源代码中引用对象的实例变量。关于此工具的详细描述超出了本书的范围。然而，我强烈建议您参考*另请参阅*部分以获取更多相关信息。
- en: See also
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can learn JNI programming (JNI specification) in detail from [http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从[http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)详细了解JNI编程（JNI规范）。
- en: The javah tool reference is available at [http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html)
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javah工具参考文档可在[http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html)找到。
- en: Developing an Android OpenGL ES 3.0 application
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Android OpenGL ES 3.0应用程序
- en: This recipe uses the NDK and JNI knowledge from the previous recipe to develop
    our first Android OpenGL ES 3.0 application. We will use our source code for `NativeTemplate.h`/`NativeTemplate.cpp`
    that we programmed in the *Programming OpenGL ES 3.0 Hello World Triangle* recipe.
    This recipe uses the Android framework to provide the necessary services to host
    the OpenGL ES program in it.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用前一个菜谱中的NDK和JNI知识来开发我们的第一个Android OpenGL ES 3.0应用程序。我们将使用在*编程OpenGL ES 3.0
    Hello World三角形*菜谱中编写的`NativeTemplate.h`/`NativeTemplate.cpp`源代码。本菜谱使用Android框架来提供必要的服务，以在其中托管OpenGL
    ES程序。
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For our first Android OpenGL ES 3.0 recipe, we advise you to locate the sample
    `AndroidHelloWorldTriangle` recipe with this chapter. It will be helpful to import
    the contents to quickly build the application. To import recipes, refer to the
    *Opening a sample project in Android ADT and iOS* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个Android OpenGL ES 3.0菜谱，我们建议您在本章中找到示例`AndroidHelloWorldTriangle`菜谱。将内容导入以快速构建应用程序将非常有帮助。有关导入菜谱的说明，请参阅[附录](apa.html
    "附录 A. OpenGL ES 3.0补充信息")中的*在Android ADT和iOS中打开示例项目*菜谱，*OpenGL ES 3.0补充信息*。
- en: How to do it...
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here is the step-by-step procedure to program our first OpenGL ES 3.0 application
    in Android:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是逐步编程我们的第一个Android OpenGL ES 3.0应用程序的步骤：
- en: Create a blank activity project by going to **New** | **Android Project**. Provide
    a proper name for the application and project. For example, specify **Application
    Name** as `AndroidBlueTriangle`, **Project Name** as `AndroidBlueTriangle`, and
    specify **Package Name** as `cookbookgles`. The package name in Java is equivalent
    to the namespace concept in C/C++.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**新建** | **Android项目**创建一个空白活动项目。为应用程序和项目提供合适的名称。例如，将**应用程序名称**指定为`AndroidBlueTriangle`，**项目名称**指定为`AndroidBlueTriangle`，并将**包名**指定为`cookbookgles`。Java中的包名与C/C++中的命名空间概念等效。
- en: On the last page, specify **Activity Name** as `GLESActivity`, **Layout Name**
    as `activity_gles`, and **Navigation Type** as `None`.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一页，将**活动名称**指定为`GLESActivity`，**布局名称**指定为`activity_gles`，**导航类型**指定为`None`。
- en: In **Package Explorer**, browse to `AndroidBlueTriangle` | `src` | `cookbook.gles`.
    Here, you will find our `GLESActivity` class. Under the same package called `cookbook.gles`,
    add two new classes called `GLESView` and `GLESNativeLib`. In order to add a new
    class, right-click on the `cookbookgles` package in the package explorer and go
    to **New** | **Class**.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**包资源管理器**中，浏览到`AndroidBlueTriangle` | `src` | `cookbook.gles`。在这里，您将找到我们的`GLESActivity`类。在同一个名为`cookbook.gles`的包下，添加两个新类，分别命名为`GLESView`和`GLESNativeLib`。为了添加一个新类，在包资源管理器中右键单击`cookbookgles`包，然后转到**新建**
    | **类**。
- en: Use the sample recipe `AndroidBlueTriangle` and copy/paste the contents of `GLESActivity.java`,
    `GLESView.java`, and `GLESNativeLib.java` to the respective files of your project.
    In the next section, you will better understand these files and the classes contained
    in them.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用示例菜谱`AndroidBlueTriangle`并将`GLESActivity.java`、`GLESView.java`和`GLESNativeLib.java`的内容复制/粘贴到项目中的相应文件。在下一节中，你将更好地理解这些文件以及它们包含的类。
- en: Add a new folder called JNI under this project. Inside this folder, create `Android.mk`,
    `Application.mk`, `NativeTemplate.h`, and `NativeTemplate.cpp`. The `android.mk`
    native code makefile is used by the JNI, as discussed in the previous recipe.
    Use `HelloWorldAndroid` to copy the contents of these two files from source to
    their respective files.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此项目下添加一个名为JNI的新文件夹。在此文件夹内，创建`Android.mk`、`Application.mk`、`NativeTemplate.h`和`NativeTemplate.cpp`。`android.mk`原生代码makefile由JNI使用，如前一个菜谱中所述。使用`HelloWorldAndroid`将这两个文件的源内容复制到相应的文件中。
- en: For OpenGL ES 3.0, `Android.mk` must contain the `-lEGL` and `-lGLESv3` flags
    in order to link with the EGL and OpenGL ES 3.0 libraries. Also, as we target
    Android devices running Android version 18 (Jelly Bean), the `Applicaton.mk` must
    contain the `APP_PLATFORM:=android-18` platform.![How to do it...](img/B02491_01_16.jpg)
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于OpenGL ES 3.0，`Android.mk`必须包含`-lEGL`和`-lGLESv3`标志，以便与EGL和OpenGL ES 3.0库进行链接。此外，由于我们针对运行Android版本18（Jelly
    Bean）的Android设备，`Application.mk`必须包含`APP_PLATFORM:=android-18`平台。![如何操作...](img/B02491_01_16.jpg)
- en: Open the command-line terminal and run `ndk-build` inside the `jni` folder.
    Under Eclipse, refresh **Package Explorer** so that the library created by `ndk-build`
    is updated in the project. Here is the rendering output upon execution:![How to
    do it...](img/B02491_01_07.jpg)
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，在`jni`文件夹内运行`ndk-build`。在Eclipse中，刷新**Package Explorer**，以便由`ndk-build`创建的库在项目中更新。以下是执行后的渲染输出：![如何操作...](img/B02491_01_07.jpg)
- en: How it works...
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first Android recipe for OpenGL ES 3.0 contains two OpenGL ES classes:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个OpenGL ES 3.0的Android菜谱包含两个OpenGL ES类：
- en: '`GLESActivity` is an extended version of Activity. Activity is an application
    component that allows various types of views on the screen. Each activity has
    a window region, within which various type of views are rendered. For our requirements,
    we need a surface where we can render OpenGL ES. Therefore, the `GLESActivity`
    class is using `GLESView` for viewing purpose.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLESActivity`是Activity的扩展版本。Activity是一个应用程序组件，允许在屏幕上显示各种类型的视图。每个活动都有一个窗口区域，在其中渲染各种类型的视图。为了满足我们的需求，我们需要一个可以渲染OpenGL
    ES的表面。因此，`GLESActivity`类使用`GLESView`进行查看。'
- en: '`GLESView` is our custom class that is extended from `GLSurfaceView`. It provides
    a surface for OpenGL ES rendering. It helps OpenGL ES know about various events,
    such as the status of activity, whether it is in active or sleep mode, whether
    it has changed its dimensions, and so on. `GLSurfaceView` provides some important
    class interfaces. Among them, the three most important ones are as follows:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLESView`是我们从`GLSurfaceView`扩展的自定义类。它提供了一个OpenGL ES渲染的表面。它帮助OpenGL ES了解各种事件，例如活动状态、是否处于活动或睡眠模式、是否改变了其尺寸等等。`GLSurfaceView`提供了一些重要的类接口。其中，最重要的三个如下：'
- en: '`GLSurfaceView.EGLConfigChooser`: This class is responsible for choosing the
    correct EGL configuration, as per our requirements. Basically, an EGL is an interface
    between the OpenGL ES APIs and the rendering context. In order to use the correct
    rendering context, we should know the EGL configuration that suits our requirements.
    In this recipe, we have extended `ConfigChooser` from `GLSurfaceView.EGLconfigChooser`.'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLSurfaceView.EGLConfigChooser`：这个类负责根据我们的需求选择正确的EGL配置。基本上，EGL是OpenGL ES API和渲染上下文之间的接口。为了使用正确的渲染上下文，我们应该知道适合我们需求的EGL配置。在这个菜谱中，我们扩展了`ConfigChooser`自`GLSurfaceView.EGLconfigChooser`。'
- en: '`GLSurfaceView.EGLContextFactory`: The rendering context is very much dependent
    on the device hardware configuration. OpenGL ES APIs do not know or care about
    creating the rendering context. Your local SDK provider is responsible for providing
    an interface to create it and attach it to your local application system. In Android,
    it is accomplished with the `EGLContextFactory` class. This requires EGL configuration.
    We have already seen how the `EGLConfigChooser` class gave us the correct EGL
    configuration, as per our requirement. You need to use this configuration to create
    your custom `ContextFactory`, which is the extended version of `GLSurfaceView.EGLContextFactory`
    in our recipe.'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLSurfaceView.EGLContextFactory`：渲染上下文在很大程度上取决于设备硬件配置。OpenGL ES API 不会知道或关心创建渲染上下文。您的本地
    SDK 提供者负责提供创建它的接口并将其附加到您的本地应用程序系统中。在 Android 上，这是通过 `EGLContextFactory` 类实现的。这需要
    EGL 配置。我们已经看到 `EGLConfigChooser` 类如何根据我们的要求提供正确的 EGL 配置。您需要使用此配置来创建您的自定义 `ContextFactory`，这是我们配方中
    `GLSurfaceView.EGLContextFactory` 的扩展版本。'
- en: 'To create OpenGL ES 3.0 context, use the `eglCreateContext` function. This
    function accepts an attribute list where the second item belongs to the OpenGL
    ES version, which must be 3.0\. See the sample code give here for OpenGL ES 3.0
    support:'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建 OpenGL ES 3.0 上下文，请使用 `eglCreateContext` 函数。此函数接受一个属性列表，其中第二个项目属于 OpenGL
    ES 版本，必须是 3.0。请参阅此处提供的示例代码，了解 OpenGL ES 3.0 的支持情况：
- en: '[PRE65]'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`GLSurfaceView.Renderer`: This provides the interface to manage OpenGL ES calls
    to render a frame. It calls the render function in loop.'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLSurfaceView.Renderer`：这提供了管理 OpenGL ES 调用来渲染一帧的接口。它循环调用渲染函数。'
- en: '`NativeTemplate.cpp`: This is the native code file that contains OpenGL ES
    commands responsible for rendering the blue triangle on screen.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeTemplate.cpp`：这是包含负责在屏幕上渲染蓝色三角形的 OpenGL ES 命令的原生代码文件。'
- en: When the Android OpenGL ES framework launches an activity, it first checks the
    available EGL configurations on device and chooses the one best suited to our
    requirements. This configuration is used to create OpenGL ES rendering context.
    Finally, rendering is performed by `GLSurfaceRenderer,` where it calls the native
    OpenGL ES code with the help of the `GLESNativeLib` class.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android OpenGL ES 框架启动活动时，它首先检查设备上的可用 EGL 配置，并选择最适合我们要求的配置。此配置用于创建 OpenGL
    ES 渲染上下文。最后，通过 `GLSurfaceRenderer` 执行渲染，其中它通过 `GLESNativeLib` 类调用原生 OpenGL ES
    代码。
- en: The OpenGL ES rendering source is coded in `NativeTemplate.cpp`, which is exposed
    to the Android framework via the `libglNative.so` static library. This library
    is compiled from the NDK using the `ndk-build` command and is automatically stored
    under the folder `AndroidBlueTriangle` | `libs` | `armeabi` | `libglNative.so`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 渲染源代码在 `NativeTemplate.cpp` 中编写，该文件通过 `libglNative.so` 静态库暴露给 Android
    框架。此库使用 `ndk-build` 命令从 NDK 编译，并自动存储在 `AndroidBlueTriangle` | `libs` | `armeabi`
    | `libglNative.so` 文件夹下。
- en: Note
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After compilation of an NDK build, the library generated is prefixed with `lib`.
    If the name mentioned in `Android.mk` is already prefixed with `lib`, then this
    prefixing is discarded.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译 NDK 构建后，生成的库以 `lib` 为前缀。如果 `Android.mk` 中提到的名称已经以 `lib` 为前缀，则此前缀将被丢弃。
- en: There's more...
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can explore more about the official Android OpenGL ES and its framework
    classes at [http://developer.android.com/reference/android/opengl/package-summary.html](http://developer.android.com/reference/android/opengl/package-summary.html).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://developer.android.com/reference/android/opengl/package-summary.html](http://developer.android.com/reference/android/opengl/package-summary.html)
    上探索官方 Android OpenGL ES 及其框架类。
- en: See also
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Software requirements for OpenGL ES 3.0 – Android ADT* recipe
    in [Appendix](apa.html "Appendix A. Supplementary Information on OpenGL ES 3.0"),
    *Supplementary Information on OpenGL ES 3.0*
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [附录](apa.html "附录 A. OpenGL ES 3.0 补充信息") 中的 *OpenGL ES 3.0 – Android ADT
    软件要求* 配方，*OpenGL ES 3.0 补充信息*
- en: '*Using JNI on Android to communicate with C/C++*'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Android 上使用 JNI 与 C/C++ 通信*'
- en: Developing an iOS OpenGL ES 3.0 application
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 iOS OpenGL ES 3.0 应用程序
- en: Development of OpenGL ES applications on iOS is much simpler compared to Android.
    The iOS 7 SDK, Xcode 5.0, and later versions support OpenGL ES 3.0\. Using App
    Wizard in Xcode 5.0, the OpenGL ES 3.0 applications can be developed effortlessly.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Android 相比，在 iOS 上开发 OpenGL ES 应用程序要简单得多。iOS 7 SDK、Xcode 5.0 及更高版本支持 OpenGL
    ES 3.0。使用 Xcode 5.0 中的 App Wizard，可以轻松开发 OpenGL ES 3.0 应用程序。
- en: Getting ready
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you should have iOS 7 support in your Xcode IDE. For more information,
    refer to the *Software requirements for OpenGL ES 3.0 – Android ADT* recipe in
    [Appendix](apa.html "Appendix A. Supplementary Information on OpenGL ES 3.0"),
    *Supplementary Information on OpenGL ES 3.0*. It's advisable to import the sample
    recipe `iOSHelloWorldTriangle` in the Xcode. This will be helpful in understanding
    the theory quickly.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的Xcode IDE中应有iOS 7支持。更多信息，请参阅[附录](apa.html "附录 A. OpenGL ES 3.0补充信息")中的*OpenGL
    ES 3.0 – Android ADT软件要求*配方，*OpenGL ES 3.0补充信息*。建议在Xcode中导入示例配方`iOSHelloWorldTriangle`。这将有助于快速理解理论。
- en: How to do it...
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the step-by-step descriptions of the first iOS OpenGL ES 3.0 application:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一个iOS OpenGL ES 3.0应用程序的逐步描述：
- en: Note
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The development of an OpenGL ES 3.0 application uses Xcode App Wizard.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 开发OpenGL ES 3.0应用程序使用Xcode App Wizard。
- en: Open Xcode, go to **File** | **New** | **Project**, select **OpenGL Game**,
    and then click on **Next**.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xcode，转到**文件** | **新建** | **项目**，选择**OpenGL游戏**，然后点击**下一步**。
- en: Give **Product Name**, **Organization Name**, and **Company Identifier** as
    per your choice. For example, we are using `iOSBlueTriangle`, `macbook`, and `Cookbook`,
    respectively. Go to the **Next** page, select the location, and create project.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的选择提供**产品名称**、**组织名称**和**公司标识符**。例如，我们分别使用`iOSBlueTriangle`、`macbook`和`Cookbook`。转到**下一页**，选择位置，并创建项目。
- en: Delete `ViewController.m` from the project navigator. Instead, we will use our
    own file. Go to **File** | **Add Files** to `iOSBlueTriangle`. Now, locate the
    source code provided with this book and open the `HelloWorldiOS` folder. Select
    `ViewController.mm`, `NativeTemplate.cpp`, and `NativeTemplate.h`, and add these
    into the project. Feel free to explore these added files. Build (*command* + *B*)
    and execute (*command* + *R*) the project.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目导航器中删除`ViewController.m`。相反，我们将使用自己的文件。转到**文件** | **添加文件**到`iOSBlueTriangle`。现在，定位本书提供的源代码并打开`HelloWorldiOS`文件夹。选择`ViewController.mm`、`NativeTemplate.cpp`和`NativeTemplate.h`，并将这些添加到项目中。随意探索这些添加的文件。构建（*command*
    + *B*）并执行（*command* + *R*）项目。
- en: The development of OpenGL ES in Xcode makes sure that the correct version of
    OpenGL ES is used. It is automatically resolved by the Xcode build system using
    **Deployment Target**. If the deployment target is iOS 7, then OpenGL ES 3.0 libraries
    are used; otherwise, OpenGL ES 2.0 libraries are used. If the code in source files
    uses fixed function pipeline programming APIs, then it is understood that OpenGL
    ES 1.1 is used. For our current recipe, make sure you have set **Deployment Target**
    to **7.0**:![How to do it...](img/B02491_01_17.jpg)
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode中OpenGL ES的开发确保使用正确的OpenGL ES版本。它由Xcode构建系统自动通过**部署目标**解决。如果部署目标是iOS 7，则使用OpenGL
    ES 3.0库；否则，使用OpenGL ES 2.0库。如果源文件中的代码使用固定功能管线编程API，则表示使用OpenGL ES 1.1。对于我们当前的配方，请确保您已将**部署目标**设置为**7.0**：![如何操作...](img/B02491_01_17.jpg)
- en: 'The program handles reference counting by itself. Therefore, it is advised
    that you disable the **automatic** **reference count** (**ARC**) to build the
    program. Otherwise, the compilation may fail. Follow these steps to disable the
    ARC:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会自行处理引用计数。因此，建议您禁用**自动**引用计数（**ARC**）来构建程序。否则，编译可能会失败。按照以下步骤禁用ARC：
- en: Click on you project in the organizer on the left-hand side
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击左侧组织器中的你的项目
- en: Select your target in the next column
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一列选择你的目标
- en: Select the **Build Settings** tab at the top
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择顶部的**构建设置**选项卡
- en: Scroll down to **Objective-C Automatic Reference Counting** (it may be listed
    as `CLANG_ENABLE_OBJC_ARC` under the **User-Defined** settings group) and set
    it to **NO**
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动到**Objective-C自动引用计数**（可能在**用户定义**设置组下列为`CLANG_ENABLE_OBJC_ARC`）并将其设置为**否**。
- en: How it works...
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Xcode provides an app wizard to the build the applications for iOS 7.0\.
    The OpenGL ES development uses GLKit, which was introduced in iOS 5.0\. The GLKit
    is an OpenGL ES development framework in objective C/C++. It is used to develop
    3D graphics applications for programmable pipeline architecture. Since we are
    developing a portable application that works across platforms, this kit might
    not be fully helpful for us (GLKit is in Objective C/C++) in that direction. We
    will create our custom graphics development framework, which will be helpful for
    portable applications across Android and iOS. We will use GLKit to build the bridge
    between our graphics development framework kit and iOS. We will introduce this
    framework in [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL
    ES 3.0 Essentials*.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 为构建 iOS 7.0 的应用程序提供了一个应用程序向导。OpenGL ES 开发使用 GLKit，该框架是在 iOS 5.0 中引入的。GLKit
    是一个 Objective C/C++ 的 OpenGL ES 开发框架。它用于开发适用于可编程管道架构的 3D 图形应用程序。由于我们正在开发一个跨平台工作的可移植应用程序，这个套件可能对我们来说（GLKit
    是 Objective C/C++）在那一方向上并不完全有帮助。我们将创建我们自己的自定义图形开发框架，这将有助于跨 Android 和 iOS 的可移植应用程序。我们将使用
    GLKit 来构建我们的图形开发框架套件和 iOS 之间的桥梁。我们将在 [第 2 章](ch02.html "第 2 章。OpenGL ES 3.0 基础")，*OpenGL
    ES 3.0 基础* 中介绍这个框架。
- en: 'The app wizard creates two classes for us, `AppDelegate` and `ViewController`.
    These classes are described here:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序向导为我们创建了两个类，`AppDelegate` 和 `ViewController`。这些类在此处描述如下：
- en: '`AppDelegate`: This class is inherited from `UIResponder<UIApplicationDelegate>`,
    which defines the interfaces for a `UIobject` that respond to touch and motion
    events. `UIApplication` and `UIView` are also derived from `UIResponder`. In iOS,
    the `UIApplication` class provides a centralized point of control to the underlying
    OS to coordinate with applications. Each `UIApplication` must implement some methods
    for `UIApplicationDelegate`, which provides the information on the key event happening
    with in an application. For example, such key events could be application launching,
    termination, memory status, and state transition.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDelegate`: 这个类继承自 `UIResponder<UIApplicationDelegate>`，它定义了响应触摸和运动事件的 `UIobject`
    接口。`UIApplication` 和 `UIView` 也都是 `UIResponder` 的子类。在 iOS 中，`UIApplication` 类为底层操作系统提供了一个集中的控制点，以协调应用程序。每个
    `UIApplication` 都必须实现一些 `UIApplicationDelegate` 的方法，这些方法提供了关于应用程序中发生的键事件的信息。例如，这些关键事件可以是应用程序启动、终止、内存状态和状态转换。'
- en: '`ViewController`: GLKit provides a standard `View` and `Controller` analogy,
    through `GLKitView` and `GLKitController`. `ViewController` is derived from `GLKitController`.
    Both classes work together to accomplish the rendering job. `GLKitView` manages
    the frame buffer object for the application. It takes the responsibility of rendering
    a draw command into the framebuffer when it is updated. However, `GLKitController`
    provides the necessary interfaces to control the pace of frames and their rendering
    loop:'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewController`: GLKit 通过 `GLKitView` 和 `GLKitController` 提供了一个标准的 `View`
    和 `Controller` 类比。`ViewController` 是从 `GLKitController` 继承而来的。这两个类共同完成渲染任务。`GLKitView`
    管理应用程序的帧缓冲区对象。当它更新时，它负责将绘制命令渲染到帧缓冲区中。然而，`GLKitController` 提供了必要的接口来控制帧的节奏和它们的渲染循环：'
- en: '[PRE66]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When iOS launches an application, it creates an instance of `UIResponder`,
    which basically creates the application object. This application object is a service
    for the application to provide a physical space in the screen window. This windowing
    is provided by the object of `UIWindow`, which will be created during the construction
    of `UIApplication`. This window object contains the desired view to display something
    on screen. In our case, this view should be some OpenGL rendering surface, which
    is provided by `GLKitController` to display. When the class object of `GLKitController`
    is created, it automatically creates the view associated with it. This helps the
    application to provide the necessary OpenGL rendering surface:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当 iOS 启动一个应用程序时，它创建了一个 `UIResponder` 的实例，这基本上创建了应用程序对象。这个应用程序对象为应用程序提供了一个在屏幕窗口中的物理空间的服务。这种窗口化是由
    `UIWindow` 对象提供的，该对象将在 `UIApplication` 的构建过程中创建。这个窗口对象包含要在屏幕上显示的视图。在我们的情况下，这个视图应该是某些
    OpenGL 渲染表面，由 `GLKitController` 提供。当 `GLKitController` 的类对象被创建时，它会自动创建与之关联的视图。这有助于应用程序提供必要的
    OpenGL 渲染表面：
- en: '[PRE67]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `didFinishLaunchingWithOptions` interface from `UIApplicationDelete` informs
    the event status of the application that it has completed loading. Within this
    event, we created the window and set the `ViewController`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`didFinishLaunchingWithOptions` 接口从 `UIApplicationDelete` 通知应用程序已完成加载的事件状态。在此事件中，我们创建了窗口并设置了
    `ViewController`。'
- en: 'When a subclass from `GLKitController` is extended, it''s very important that
    we override the `viewDidLoad` and `viewDidUnload` methods:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `GLKitController` 扩展子类时，重写 `viewDidLoad` 和 `viewDidUnload` 方法非常重要：
- en: '[PRE68]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `viewDidLoad` method helps create the rendering context and set up all its
    drawable properties for an appropriate configuration. To create an OpenGL ES 3.0
    render context, we use `initWithAPI`. It accepts `kEAGLRenderingAPIOpenGLES3`
    as an argument. This argument makes sure that the rendering context is meant for
    OpenGL ES 3.0 version.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad` 方法有助于创建渲染上下文并为其设置所有可绘制属性以进行适当的配置。为了创建 OpenGL ES 3.0 渲染上下文，我们使用
    `initWithAPI`。它接受 `kEAGLRenderingAPIOpenGLES3` 作为参数。此参数确保渲染上下文是为 OpenGL ES 3.0
    版本设计的。'
- en: We can modify the rendering context properties to configure the format of the
    drawable frame buffer object, such as `drawableColorFormat`, `drawableDepthFormat`,
    `drawableStencilFormat` and `drawableMultisample`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改渲染上下文属性以配置可绘制帧缓冲对象格式，例如 `drawableColorFormat`、`drawableDepthFormat`、`drawableStencilFormat`
    和 `drawableMultisample`。
- en: 'This method is also a good place for initialization and other resource allocations.
    The last line is calling the setupGL `function[self setupGL]` in the objective
    C++ language syntax. Therefore, it is equivalent to this `setupGL()` in C++:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也是初始化和其他资源分配的好地方。最后一行是在 Objective C++ 语法中调用 `setupGL `函数`[self setupGL]`。因此，它等同于
    C++ 中的 `setupGL()`：
- en: '[PRE69]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The setupGL function sets the current context with the one we created in `viewDidApplication`.
    This is very important to make the OpenGL ES APIs work. The `glBindFramebuffer`
    and `glBindRenderbuffer` APIs help the other APIs to know which target framebuffer
    to render on. In OpenGLES, the data is rendered in a rectangular array of information
    buffer container called a framebuffer. A framebuffer comprises many other helping
    buffers, such as color, depth, and stencil buffer, to accomplish rendering on
    the screen window. Sometimes, there could be cases where we may lose framebuffer
    or the render buffer. In such cases, it is advisable to bind these buffers with
    these two functions before you call any OpenGL ES3.0 API.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupGL` 函数使用我们在 `viewDidApplication` 中创建的上下文设置当前上下文。这对于使 OpenGL ES APIs 工作非常重要。`glBindFramebuffer`
    和 `glBindRenderbuffer` API 帮助其他 API 知道要在哪个目标帧缓冲区上渲染。在 OpenGLES 中，数据在称为帧缓冲区的信息缓冲容器矩形数组中渲染。帧缓冲区由许多其他辅助缓冲区组成，如颜色、深度和模板缓冲区，以在屏幕窗口上完成渲染。有时，可能会出现丢失帧缓冲区或渲染缓冲区的情况。在这种情况下，在调用任何
    OpenGL ES 3.0 API 之前，建议使用这两个函数绑定这些缓冲区。'
- en: 'In order to render our application, we must override the `drawRect` method:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染我们的应用程序，我们必须重写 `drawRect` 方法：
- en: '[PRE70]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `renderFrame` function contains all the necessary code to render blue triangle.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderFrame` 函数包含渲染蓝色三角形的所有必要代码。'
- en: See also
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *The fixed function and programmable pipeline architecture* recipe
    in [Appendix](apa.html "Appendix A. Supplementary Information on OpenGL ES 3.0"),
    *Supplementary Information on OpenGL ES 3.0*
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [附录](apa.html "附录 A. OpenGL ES 3.0 补充信息") 中的 *固定功能管道和可编程管道架构* 配方，*OpenGL
    ES 3.0 补充信息*
- en: Refer to the *Software requirements for OpenGL ES 3.0 – iOS* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [附录](apa.html "附录 A. OpenGL ES 3.0 补充信息") 中的 *OpenGL ES 3.0 – iOS 的软件要求*
    配方，*OpenGL ES 3.0 补充信息*
- en: Refer to the *Building prototypes using the GLPI framework* recipe, [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 *使用 GLPI 框架构建原型* 的配方，[第 2 章](ch02.html "第 2 章。OpenGL ES 3.0 基础"), *OpenGL
    ES 3.0 基础*
