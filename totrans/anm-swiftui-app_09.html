<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-121"><a id="_idTextAnchor125"/>9</h1>
<h1 id="_idParaDest-122"><a id="_idTextAnchor126"/>Animating Strokes around Shapes</h1>
<p>In this project, we will take three images, create outlines around them, and then animate strokes along those outlines. A stroke is a line that follows the outline (or contours) of a shape, which we can give any color and thickness and animate to move around the image.</p>
<p>To do this, you’ll learn how to convert bitmap images into vector images using the Inkscape software, and then take those vectors and convert them into Swift code using Sketch and Kite. We will then insert this code back into Xcode so that we can start animating our project.</p>
<p>The following are the objectives for this project:</p>
<ul>
<li>Converting images into Swift code</li>
<li>Animating images with the <code>stroke</code> modifier</li>
</ul>
<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>Technical requirements</h1>
<p>You can download the resources and finished project from the <code>Chapter 9</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<p>You will also need the following:</p>
<ul>
<li>The Remove Background software, which is a free online tool you can access here: <a href="https://www.remove.bg/upload">https://www.remove.bg/upload</a></li>
<li>Inkscape, which is free and you can install here: <a href="https://inkscape.org/release/inkscape-1.2.1/">https://inkscape.org/release/inkscape-1.2.1/</a></li>
<li>Sketch, which you can install here: <a href="https://www.sketch.com/switch-to-sketch/">https://www.sketch.com/switch-to-sketch/</a></li>
<li>Kite, which you can install here: <a href="https://kiteapp.co">https://kiteapp.co</a></li>
</ul>
<h1 id="_idParaDest-124"><a id="_idTextAnchor128"/>Converting images into Swift code</h1>
<p>In order to create<a id="_idIndexMarker475"/> the three outlines<a id="_idIndexMarker476"/> that we need, we first have to convert images into vectors and then convert those vectors into Swift code. Why do we have to convert an image into Swift code? </p>
<p>Well, in order to place an animating stroke around an image, we need a path for the animation to follow. When the image has been translated into code, it will then be easy to use Swift to follow the image outline.</p>
<p>However, there’s a problem: bitmaps. A <strong class="bold">bitmap</strong>, also called a <strong class="bold">raster image</strong>, is a graphic that<a id="_idIndexMarker477"/> is created from different<a id="_idIndexMarker478"/> colored pixels, which together form an image. Bitmaps can be very simple, just made up of two colors (those would be black and white), or they can have many thousands or millions of colors that produce photograph-quality images. Some examples of bitmap formats that you will see use the file extensions PNG, JPEG, and TIFF. With a bitmap image, there is no defined outline for any code to follow, and thus it cannot have an animating stroke around it.</p>
<p><strong class="bold">Vector images</strong>, on the other hand, are images<a id="_idIndexMarker479"/> created from code that have sharply defined edges and never get blurry like a bitmap when you zoom in on them. Since they are created with code, we can animate strokes around those images.</p>
<p>If you want to animate a stroke around a bitmap image, there are three main steps that you need to undertake:</p>
<ul>
<li>Removing the background of the image you want to use</li>
<li>Vectorizing the image into an SVG file</li>
<li>Translating the SVG file into Swift code</li>
</ul>
<p>So, let’s go through those steps now.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Removing the image backgrounds</h2>
<p>Many images have a white<a id="_idIndexMarker480"/> or colored background, and in many cases, the background is not needed. It’s easier to convert images into vectors if they are against a transparent background. </p>
<p>In our project, the images that we will be using are an image of the word “WE,” an image of a heart, and an image of the SwiftUI logo. We will combine them in Swift so that they say, “We Love SwiftUI,” like so:</p>
<div><div><img alt="Figure 9.1: The images we will use in our project " src="img/B18674_09_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: The images we will use in our project</p>
<p>You can download<a id="_idIndexMarker481"/> these from the GitHub repository, where you will notice that the backgrounds have already been removed. However, if you are going to use your own images, you will need to do this yourself.</p>
<p>We already explored how to remove backgrounds in <a href="B18674_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a> when we animated the girl on the swing. You can refer back to that<a id="_idIndexMarker482"/> chapter; however, to recap, you can use an online<a id="_idIndexMarker483"/> tool called Remove Background: <a href="https://www.remove.bg/upload">https://www.remove.bg/upload</a>. You just have to click <strong class="bold">Upload Image</strong> and choose the one you want to use. And that’s it – in about 20 seconds, the website’s algorithms will find the background and remove it, leaving only your subject. Then, all you have to do is download the new image file and you’re good to go.</p>
<p>Alternatively, you can use Mac’s Preview app to remove the background, or you can use paid software such as Affinity Designer. How you decide to remove the background is up to you; experiment and try to see what works best for the image you are using.</p>
<p>Also, although it’s not strictly<a id="_idIndexMarker484"/> necessary, it’s a good idea to crop your image, as we only want to work with the image and not any surrounding space. You can do this in pretty much any graphics editing program, including the Preview app.</p>
<p>Now you can proceed to the next step, which is vectorizing the image.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor130"/>Vectorizing the images</h2>
<p>The second step will be to create vectors<a id="_idIndexMarker485"/> from the bitmap image. To do this, we will need software with the proper algorithms to detect pixels, remove them, and replace them with code that will draw<a id="_idIndexMarker486"/> the shapes instead. The resulting code file will be a <code>.svg</code>) file. One of the best software options on the market is called Vector Magic. This software is easy to use<a id="_idIndexMarker487"/> and automates the vectorization process with a click of a button to start the process, but the downside is it costs around $300.</p>
<p>Alternatively, we can use Inkscape, which is free<a id="_idIndexMarker488"/> software that does a really good job of tracing out a bitmap image and converting all its parts into vectors. This is what we will use, and you can download the latest version (at the time of writing) from the following link: <a href="https://inkscape.org/release/inkscape-1.2.1/">https://inkscape.org/release/inkscape-1.2.1/</a>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Even though Inkscape can work with color images, it’s usually better to have your images in black and white; the algorithms work better with these two colors. If you have color images, though, that’s not a problem – you can still convert<a id="_idIndexMarker489"/> them into black and white by using a graphics program such as Affinity Designer.</p>
<p class="callout">If you look at the images we are using for this project, two of them are in color, but that’s okay because they have a limited number of colors and are simple shapes. If you have more complicated shapes, for instance, such as a portrait photograph with many colors in it, then it’s better to convert them into black and white first. </p>
<p>Once you have Inkscape<a id="_idIndexMarker490"/> installed, you can get started. Grab one of your images (in my case, I am choosing the “WE” image), right-click on it, and open it in Inkscape. You will see this pop-up window:</p>
<div><div><img alt="Figure 9.2: Importing an image into Inkscape " src="img/B18674_09_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Importing an image into Inkscape</p>
<p>Set <strong class="bold">Image Import Type</strong> to <strong class="bold">Embed</strong>, <strong class="bold">Image DPI</strong> to <strong class="bold">Default import resolution</strong>, and <strong class="bold">Image Rendering Mode</strong> to <strong class="bold">None (auto)</strong>. Then, click <strong class="bold">OK</strong>. You will then see this screen:</p>
<div><div><img alt="Figure 9.3: The Inkscape editor with our image " src="img/B18674_09_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: The Inkscape editor with our image</p>
<p>Before continuing<a id="_idIndexMarker491"/> with the conversion, I want to show you how a bitmap looks close up. On your Mac trackpad, pinch and zoom in very close to the image; you will see pixelization and blurriness appear. This is one way you can tell whether the image is a bitmap and not a vector. (Of course, the file extension will also let you know whether it’s a bitmap or vector as well!)</p>
<p>Next, select your image on the Inkscape canvas (you will know it’s been selected if you see black arrows around it), then go to the <strong class="bold">Path</strong> menu at the top of the screen, and choose <strong class="bold">Trace Bitmap</strong>. This will open up the <strong class="bold">Preview</strong> option on the right-hand side of Inkscape:</p>
<div><div><img alt="Figure 9.4: Inkscape Preview " src="img/B18674_09_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: Inkscape Preview</p>
<p>In the <strong class="bold">Preview</strong> window, Inkscape<a id="_idIndexMarker492"/> shows us what the <strong class="bold">Trace Bitmap</strong> function will be able to trace, and what the image will look like as a vector graphic. Since the preview looks nearly identical to the “WE” image on the canvas, there will be a complete outline around the image. </p>
<p>You can’t see the vector lines and points just yet in the preview, but you will shortly.</p>
<p>Since we are using a black and white image, Inscape has selected the <strong class="bold">Single scan</strong> option from the top of the <strong class="bold">Preview</strong> window (which you can see in <em class="italic">Figure 9</em><em class="italic">.5</em>).</p>
<div><div><img alt="Figure 9.5: The Inkscape scan option " src="img/B18674_09_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5: The Inkscape scan option</p>
<p>The <strong class="bold">Single scan</strong> option is used for black<a id="_idIndexMarker493"/> and white images, but if we use a multicolored image, then we need to select the <strong class="bold">Multicolor</strong> option. The <strong class="bold">Multicolor</strong> option will scan your image, looking at the many colors it contains, and do its best to trace an outline around each of those colors. This is why I said earlier that it’s usually better to have a black-and-white image, as there are fewer colors to scan and thus less chance of not getting a good trace.</p>
<p>As highlighted in <em class="italic">Figure 9</em><em class="italic">.5</em>, you can also adjust the <strong class="bold">Threshold</strong> and <strong class="bold">Details</strong> sliders to get the best possible image in the previews. These sliders are useful if Inkscape is having difficulty getting a good scan. By moving the sliders, you can fine-tune the parts of the image that Inkscape can see.</p>
<p>Let’s look at the <strong class="bold">Details</strong> sliders:</p>
<ul>
<li>The <strong class="bold">Speckles</strong> slider will ignore the small spots in the vector – when set to maximum, it will ignore more speckles, and when set to minimum, it will ignore fewer speckles.</li>
<li>The <strong class="bold">Smooth corners</strong> slider will smooth out any sharp corners that are in the trace.</li>
<li>The <strong class="bold">Optimize</strong> slider will try to optimize paths by joining adjacent Bezier curve segments together; this means that the <strong class="bold">Optimize</strong> slider will try its best to remove as many vector nodes as it can. When you have fewer nodes in a vector image, there tends to be better tracing and fewer jagged edges. </li>
</ul>
<p>We will see the <strong class="bold">Threshold</strong> slider later when creating a stroke around the heart.</p>
<p>What we want<a id="_idIndexMarker494"/> to see in the preview is an image that is as close to the one in the center canvas as possible. When we do see this, it means that Inkscape can trace all around the shape on the canvas correctly and capture all the vector lines. If you don’t see an image that’s close to the original, then try and adjust some of the sliders I just mentioned to fine-tune the output.</p>
<p>Once you have finished adjusting the image so it looks close to the original, click <strong class="bold">Update Preview</strong>, and then <strong class="bold">Apply</strong>. Inkscape places its newly created vectors directly over the original image. To see the result, click on the “WE” image in the editor and drag the new vectors to the side:</p>
<div><div><img alt="Figure 9.6: Creating the vectors " src="img/B18674_09_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: Creating the vectors</p>
<p>You can now delete the original image, as it is no longer needed.</p>
<p>Let’s have a look<a id="_idIndexMarker495"/> at what Inkscape has done for us – it has traced the original image and created a new image that is now made of vector paths. To see the difference, pinch and zoom on your Mac trackpad on the new vector image as you did with the bitmap image. Do you see the difference? There is no pixelation or blurriness at all, as the image is created with code rather than pixels; the image can be blown up to any size and it will still remain sharp and crisp along its edges and curves:</p>
<div><div><img alt="Figure 9.7: Vector resolution " src="img/B18674_09_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7: Vector resolution</p>
<p>Now, remember that I mentioned<a id="_idIndexMarker496"/> that you will be able to see the vectors that Inkscape has created? Well, they are there, it’s just that we need to select the right editing tool to see them. Select the image in the center of the canvas, go to the left toolbar, and select the <strong class="bold">Node Editing</strong> tool. When you click on that tool, you will be able to see all the vector lines that Inkscape created:</p>
<div><div><img alt="Figure 9.8: The vectors " src="img/B18674_09_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8: The vectors</p>
<p>Each of those small squares<a id="_idIndexMarker497"/> is a point (or node) that links lines, curves, and corners to make this new shape – and these points can now be edited by clicking on them and dragging them to any location to reshape the vector image.</p>
<p>With the new vectors created, we can export them. To do this, open <strong class="bold">File</strong> at the top menu and choose <strong class="bold">Export</strong>. Then, you can choose the export options at the bottom right of the software. Choose the file type that you want to export to – we want a <strong class="bold">Plain SVG (*.svg)</strong> file. Then, click on the <strong class="bold">Export</strong> button:</p>
<div><div><img alt="Figure 9.9: Exporting to an SVG file " src="img/B18674_09_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9: Exporting to an SVG file</p>
<p>Now, we have an SVG file<a id="_idIndexMarker498"/> stored on our computer, ready to be translated into Swift code. Do the same process for any of the other images that you want to use in this project – whether you are using your own images or following along with the book’s project images – and then you can proceed to the next step.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor131"/>Translating the SVG file into Swift code</h2>
<p>Let’s continue. We have an SVG file<a id="_idIndexMarker499"/> ready<a id="_idIndexMarker500"/> for the next step. An <strong class="bold">SVG</strong> file is a file written in XML, and <strong class="bold">XML</strong> is a markup language used for storing<a id="_idIndexMarker501"/> and transferring digital information. The XML code in an SVG file creates all of the shapes, colors, and text that comprise the image. We will be turning that XML code into Swift code shortly, but first, we need to edit the images’ dimensions and we can do that in Sketch.</p>
<p>So, first, open the SVG “WE” image in Sketch. Then, in the <strong class="bold">Utilities</strong> area on the right, we can size the image however we like; in my case, I have set the width to <strong class="bold">250</strong>. To set this, make sure that the little lock icon in between the width and height fields is selected so that it’s locked – this will keep the correct proportions for the image – and hit <em class="italic">Enter</em>:</p>
<div><div><img alt="Figure 9.10: Sizing the image " src="img/B18674_09_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10: Sizing the image</p>
<p>And that’s all we need to do in Sketch. Now, minimize your Sketch document (but don’t close it!).</p>
<p>Next, we need a program <a id="_idIndexMarker502"/>that can turn XML <a id="_idIndexMarker503"/>code into Swift code. One option is Paint Code – although it is a great program, it costs around $200 per year for a subscription. Instead, we will use Kite – although this is currently $99 to buy outright with no subscription, you can always use the free trial to follow along with this project.</p>
<p>So, open up Kite. Then, click on <strong class="bold">File</strong> | <strong class="bold">Import</strong> | <strong class="bold">From Sketch…</strong>:</p>
<div><div><img alt="Figure 9.11: Importing from Sketch into Kite " src="img/B18674_09_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11: Importing from Sketch into Kite</p>
<p>You will then see a pop-up window<a id="_idIndexMarker504"/> asking how you would<a id="_idIndexMarker505"/> like to import the layers. Leave the default settings as they are, but make sure that <strong class="bold">Import text layers as</strong> is set to <strong class="bold">Image Layers</strong> and that <strong class="bold">Import images at</strong> is set to a scale of <strong class="bold">1x</strong>:</p>
<div><div><img alt="Figure 9.12: Import From Sketch settings " src="img/B18674_09_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12: Import From Sketch settings</p>
<p>Then, click on <strong class="bold">Import</strong>. You now have your image<a id="_idIndexMarker506"/> in Kite and are ready to turn it into Swift code, and that process is as simple<a id="_idIndexMarker507"/> as clicking one button, the <strong class="bold">Code</strong> button, at the top of the screen:</p>
<div><div><img alt="Figure 9.13: Converting the file into Swift code " src="img/B18674_09_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13: Converting the file into Swift code</p>
<p>The Swift code that is generated shows up in the bottom console, which you can resize like the Xcode console by dragging it upwards. Here is what the code console looks like for the “WE” image, containing all the Swift code that makes up its length, thickness, colors, position, and more:</p>
<div><div><img alt="Figure 9.14: The generated Swift code in Kite " src="img/B18674_09_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14: The generated Swift code in Kite</p>
<p>That looks like a lot of code<a id="_idIndexMarker508"/> just to create<a id="_idIndexMarker509"/> an image with two letters, doesn’t it? Well, yes, but there are a lot of things the code is doing – it’s mapping out all the paths needed to create the lines and curves that form the shape.</p>
<p>Let’s now get this code into Xcode. First, create a new Xcode project if you haven’t done so already – I’ve called it <strong class="bold">Animating Strokes</strong>. Then, all we have to do is copy a small segment of it from Kite. You should copy the code starting from here:</p>
<pre class="source-code">
let pathPath = CGMutablePath()</pre>
<p>And continue all the way down the file until you reach these two lines:</p>
<pre class="source-code">
 pathPath.closeSubpath()
 pathPath.move(to: CGPoint(x: 159, y: 104.854378))</pre>
<p>So, we just want to copy all the code that starts with <code>pathPath</code>; everything else we don’t need.</p>
<p>Now, before we enter Xcode, let’s summarize what we have done so far. We have taken a bitmap image, removed its background and cropped it, opened it with Inkscape and turned it into a vector<a id="_idIndexMarker510"/> image, and then finally<a id="_idIndexMarker511"/> imported that vector into Kite, where we turned it into Swift code. This process will get faster with more practice.</p>
<p>Let’s now proceed to Xcode and start making all this code work.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor132"/>Animating images with the stroke modifier</h1>
<p>In the following sections, we will be working<a id="_idIndexMarker512"/> in Xcode and refactoring<a id="_idIndexMarker513"/> the “WE” code somewhat in order to make it work in our project. We will use the Shape protocol that lets us draw a 2D shape using its <code>path()</code> function, and then use the <code>stroke</code> modifier to add a moving line around the path of our shapes. We will also get started on animating our heart and SwiftUI logo images.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Creating a stroke animation on the “WE” image</h2>
<p>To start animating the “WE” image, we need<a id="_idIndexMarker514"/> to create a file inside the project. Press <em class="italic">Command + N</em>, choose a <code>WeView</code>.</p>
<p>Then, create a struct at the bottom of the file; this will be the struct that conforms to the shape protocol, allowing us to create 2D shapes by using the <code>path</code> function:</p>
<pre class="source-code">
struct WeTextShape: Shape {
    func path(in rect: CGRect) -&gt; Path {
    }
}</pre>
<p>Now, we can paste in the code that we copied from the Kite program and place it right into that <code>path</code> function. This code is quite repetitive and long, as it is drawing a shape and must repeat itself for every<a id="_idIndexMarker515"/> line, curve, and corner. So, for the sake of brevity and to not take up too much space, I will just provide the beginning and end of the code (however, you can find the complete code in the GitHub repo):</p>
<pre class="source-code">
struct WeTextShape: Shape {
  func path(in rect: CGRect) -&gt; Path {
    let pathPath = CGMutablePath()
      pathPath.move(to: CGPoint(x: 33.544579, y: 
        105.919167))
      pathPath.addCurve(to: CGPoint(x: 20.994799, y: 
        60.169167), control1: CGPoint(x: 32.057159, y: 
        101.184097), control2: CGPoint(x: 29.932928, y: 
        93.440262))
      pathPath.addCurve(to: CGPoint(x: 3.45976, y: 
        7.26897), control1: CGPoint(x: 8.184458, y: 
        12.4843), control2: CGPoint(x: 7.749718, y: 
        11.17275))
      pathPath.addLine(to: CGPoint(x: 0, y: 0.16917))
      ........................................................
      pathPath.addCurve(to: CGPoint(x: 236.485107, y: 
        93.6082), control1: CGPoint(x: 237.051361, y: 
        79.890518), control2: CGPoint(x: 236.884613, y: 
        86.149673))
      pathPath.addLine(to: CGPoint(x: 235.758789, y: 
        107.169159))
      pathPath.addLine(to: CGPoint(x: 197.379395, y: 
        107.169159))
      pathPath.addLine(to: CGPoint(x: 159, y: 107.169159))
      pathPath.addLine(to: CGPoint(x: 159, y: 104.854378))
      pathPath.closeSubpath()
      pathPath.move(to: CGPoint(x: 159, y: 104.854378))
  }
}</pre>
<p>When you paste the code into Xcode, you will get some errors – don’t worry about these, as the code needs to be reworked a little bit anyway.</p>
<p>Fixing these issues is also a good<a id="_idIndexMarker516"/> excuse for me to show you how to refactor code in SwiftUI. Refactoring is a helpful feature that allows us to rename code or remove and replace different parts of code throughout multiple files in your project without having to search through all your files looking for each instance that needs refactoring and manually changing it.</p>
<p>One thing we want to change is the name of the <code>pathPath</code> constant, which is the first line of code inside the <code>path</code> function that was pasted in. This constant seems to have been named twice because it was exported from Inkscape. However, it should simply be named <code>path</code>.</p>
<p>So, to refactor this, just <em class="italic">Command + click</em> on the <code>pathPath</code> variable and select <code>pathPath</code> in the file, and all you have to do is just type in the new name, <code>path</code>, and hit <em class="italic">Enter</em>.</p>
<p>That’s our first revision of the code that we copied over. The next revision is to change the class that’s being assigned to the <code>path</code> constant. Currently, the <code>path</code> constant is assigned as a <code>CGMutablePath()</code> instance, which is a core graphics class used for drawing shapes and lines. Working in SwiftUI though, nearly everything is built with structs, so we need to use the <code>Path()</code> struct instead. Also, change the <code>let</code> keyword to the <code>var</code> keyword, because we need the <code>path</code> variable to be mutable, meaning its value can be changed.</p>
<p>With those modifications done, the first line of the code in your path function should look like the following:</p>
<pre class="source-code">
var path = Path()</pre>
<p>Now, let’s add one more line of code to this <code>path</code> function. At the very end of the function, we need to return the <code>path</code> variable, and to do so, we use the <code>return</code> keyword, followed by the variable the function<a id="_idIndexMarker517"/> must return; so, add this line at the bottom of the <code>path</code> function:</p>
<pre class="source-code">
return path</pre>
<p>The following are the changes we made to the start and end of the <code>path</code> function:</p>
<pre class="source-code">
func path(in rect: CGRect) -&gt; Path {
    var path = Path()
    path.move(to: CGPoint(x: 33.544579, y: 105.919167))
    path.addCurve(to: CGPoint(x: 3.45976, y: 7.26897), 
      control1: CGPoint(x: 8.184458, y: 12.4843), control2: 
      CGPoint(x: 7.749718, y: 11.17275))
       •••SHAPE CODE HERE•••
    return path
  }</pre>
<p>When you press <em class="italic">Command + B</em>, the code should be error-free.</p>
<p>Now let’s see what all of that Kite code is actually doing.</p>
<p>The <code>path()</code> function will return a shape according to the points, lines, and curves that are drawn inside it. The first line of code inside the <code>path()</code> function is creating a path instance; this will draw the shape, and you can think of this variable as the pencil moving along the canvas.</p>
<p>The second line of code is the <code>move()</code> function. This is what sets the starting location for the <code>path</code> variable to move to. The locations are based on the Cartesian coordinate system and an X and Y location are used to position the <code>path</code> variable.</p>
<p>In the third line of code, the <code>path</code> variable calls the <code>addCurve()</code> function, and this does what it says – it adds a Bezier curve to the path using the specified points. Continuing down our code, we see<a id="_idIndexMarker518"/> that the <code>path</code> variable also calls the <code>addLine()</code> function, and this will add a line to the path using the specified points. The code continues to call these two functions, <code>addCurve()</code> and <code>addLine()</code>, quite a bit until the <code>path</code> variable needs to finish off a particular path in the drawing and close off the ends of that finished line before moving on to the next line in the drawing.</p>
<p>The finished line is closed off using the <code>closeSubpath()</code> function and directly proceeded by the <code>moveTo()</code> function to start a new line in the drawing. So, as you can see, there are several lines drawn in this code to make up the finished shape.</p>
<p>And finally, at the end of all this code, the <code>path()</code> function returns the <code>pat</code>h variable, which now contains a finished shape inside of it, ready to be displayed on the iPhone screen.</p>
<p>Next, continuing to work in the same file, we need to come into the <code>WEView</code> struct and add the code to display this shape.</p>
<p>Starting at the top of the struct, add the following variables:</p>
<pre class="source-code">
//MARK: - VARIABLES
    @State var strokeReset: Bool = true
    @State var startStroke: CGFloat = 0.0
    @State var endStroke: CGFloat = 0.0</pre>
<p>Next, inside the <code>body</code> property, add a <code>ZStack</code>:</p>
<pre class="source-code">
var body: some View {
    ZStack {
    }
  }</pre>
<p>Inside the <code>ZStack</code>, let’s add a <code>Group</code>, and then the following code to display the shape in the preview:</p>
<pre class="source-code">
 ZStack {
        Group {
            //SHAPE OUTLINE
            WeTextShape()
                .stroke(style: StrokeStyle(lineWidth: 0.5, 
                  lineCap: .round, lineJoin: .round))
                .foregroundColor(.gray)
        }
    }</pre>
<p>Inside <code>Group</code>, we call the <code>WeTextShape</code> struct and add the <code>stroke</code> modifier directly to it. This modifier will create a new shape<a id="_idIndexMarker519"/> that has a stroke on it, which is styled according to the <code>StrokeStyle</code> function. The <code>StrokeStyle</code> function adds a <code>lineWidth</code> property of <code>0.5</code>, and sets both <code>lineCap</code> (the ends of the stroke) and <code>lineJoin</code> to <code>round</code>; this joins the ends of the stroke with a semi-circular arc. Finally, the color of the stroke shape is set to <code>gray</code>.</p>
<p>This completes the shape – we won’t add any animation to it, as we just want it to be a stationary shape. Instead, we will add this shape again, directly over the first one, and that’s the one we will animate in color. Let’s add that now.</p>
<p>Continuing inside the <code>Group</code> view, and directly under the last line of code, add the following:</p>
<pre class="source-code">
    Group {
        //SHAPE OUTLINE
        WeTextShape()
            .stroke(style: StrokeStyle(lineWidth: 0.5, 
              lineCap: .round, lineJoin: .round))
            .foregroundColor(.gray)
<strong class="bold">        //ANIMATING STROKE</strong>
<strong class="bold">        WeTextShape()</strong>
<strong class="bold">            .trim(from: startStroke, to: endStroke)</strong>
<strong class="bold">            .stroke(style: StrokeStyle(lineWidth: 5, </strong>
<strong class="bold">              lineCap: .round, lineJoin: .round))</strong>
<strong class="bold">            .foregroundColor(Color.red)</strong>
<strong class="bold">    }.offset(x: 75, y: 50)</strong>
<strong class="bold">  )</strong>
   }</pre>
<p>And that’s the code that will add a second shape, identical to the first one, directly over it.</p>
<p>As we did for the non-moving<a id="_idIndexMarker520"/> shape, we called the <code>WeTextView</code> struct to create the shape. Then, we used the <code>trim</code> modifier to trim the shape by a fractional amount based on the values that get passed into its parameters. By passing in the <code>startStroke</code> variable as the location of the start of the stroke animation and the <code>endStroke</code> variable to tell the <code>trim</code> modifier where to stop, a stroked line will be drawn along the shape’s path from start to end. The length of that stroke line will depend on the values inside the <code>startStroke</code> and <code>endStroke</code> variables.</p>
<p>As we did with the first shape, we also used the <code>strokeStyle</code> modifier to style the stroke with a <code>width</code> property of <code>5</code>, and <code>lineCap</code> and <code>lineJoin</code> set to <code>round</code>. This time, we set the color to <code>red</code> so that the moving stroke will stand out as it travels along the gray shape underneath it.</p>
<p>Then, finally, we’re using the <code>offset</code> modifier to center the shape inside the preview in the middle from left to right, and toward the top of the iPhone.</p>
<p>Now, the code for the outline and animating the stroke are complete. What’s needed next is to use the <code>onAppear</code> modifier to start the animation and set up some timers so that the stroke can proceed at a certain speed. Add the final bit of code right after the closing brace of the <code>ZStack</code>:</p>
<pre class="source-code">
.onAppear() {
    Timer.scheduledTimer(withTimeInterval: 0.23, repeats: 
      true) { timer in
        if (endStroke &gt;= 1) {
            if (strokeReset) {
                Timer.scheduledTimer(withTimeInterval: 0.6, 
                  repeats: false) { _ in
                    endStroke = 0
                    startStroke = 0
                    strokeReset.toggle()
                }
                strokeReset = false
            }
        }
        withAnimation(Animation.easeOut) {
            endStroke += 0.12
            startStroke = endStroke - 0.4
        }
    }
  }</pre>
<p>This code might look a little busy<a id="_idIndexMarker521"/> to grasp at first, but let’s break it down for clarity.</p>
<p>The <code>onAppear()</code> method is called on the <code>ZStack</code> container; this method is triggered when the view appears on the screen. Inside the method, a timer is scheduled using the <code>Timer.scheduledTimer</code> method, which is set to repeat every <code>0.23</code> seconds. This is the amount of time it takes for the animation to draw each stroke segment. A stroke segment is how we draw out the shape, in segments, one at a time. You can experiment with this timer’s interval value – a larger number will draw the stroke segments slower, and a smaller number will draw the segments faster, creating a smooth animating line around the shape.</p>
<p>Next, we want the animation to repeat, so we set the <code>repeats</code> parameter to <code>true</code>. Within the timer’s event handler, the code first checks whether the <code>endStroke</code> variable is greater than or equal to <code>1</code>. If this is true, the code then checks whether the <code>strokeReset</code> variable is <code>true</code>. If both of these conditions are met, another timer is scheduled using the <code>Timer.scheduledTimer</code> method. This timer is set to run only once, after <code>0.6</code> seconds, and within this timer’s event handler, the values of <code>endStroke</code> and <code>startStroke</code> are reset to <code>0</code>, so the stroke animation can once again start at the beginning, and the <code>strokeReset</code> variable is toggled. After the inner timer is scheduled, the <code>strokeReset</code> variable is set to <code>false</code>.</p>
<p>The <code>withAnimation</code> function is different<a id="_idIndexMarker522"/> from the animation modifier we have used in past projects. Remember in <a href="B18674_02.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, when we talked about the two types of animations, <em class="italic">implicit</em> and <em class="italic">explicit</em>? The <code>withAnimation</code> function is an explicit type of animation and is used to animate changes to the view’s state. It is considered an explicit animation because it requires you to specify the animation that you want to use, as opposed to an implicit animation, which would automatically animate changes without the need for additional code.</p>
<p>So, in the body of the <code>withAnimation</code> function, we set the <code>endStroke</code> variable to increase its value by <code>0.12</code> after every iteration of the animation. We also set <code>startStroke</code> to a value that is calculated by subtracting <code>0.4</code> from <code>endStroke</code> – this computation creates the length and speed of an animating stroke that I think looks pretty good for the “We” shape.</p>
<p>And with that, this animation is complete. So, to summarize the code in the <code>WeView</code> struct, it creates a view that animates a shape, this shape is outlined twice, once with a gray color and a small stroke, and then again, with a red color and a bigger stroke. The animation is controlled by the <code>startStroke</code> and <code>endStroke</code> variables, which are incremented over time. The animation will be repeated once the <code>endStroke</code> variable reaches <code>1</code>, and there is a <code>0.6</code>-second delay before the animation starts again.</p>
<p>Now that we have finished with the code, if you click on the <code>endStroke</code> in the <code>withAnimation</code> function, you can leave more of the stroke line on the shape or less of it, depending on the look you want to go for. </p>
<p>Play around with the values and experiment. You can create a flashing stroke by increasing the speed, or you can have a very slow-moving stroke. You can stroke the entire shape with a short line, or you can go with a very long line along the whole shape.</p>
<p>That completes<a id="_idIndexMarker523"/> our first animation, the “WE” image stroke. Even though that seems like a long process, the whole thing actually only takes a few minutes once you get familiar with the different programs and techniques used. We are going to move on to the heart image now and repeat the same process. After all, practice makes perfect!</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Creating a stroke animation on the heart image</h2>
<p>Okay, we have<a id="_idIndexMarker524"/> animated<a id="_idIndexMarker525"/> our first image, so we are going to follow the same process again for two more images. The next image will be a heart – for this one, we will animate a stroke around it as we did with the letters, but also we will add the heart image back into the scene.</p>
<p>If you are following along with the book’s project, you can find the heart image in the GitHub repository, where the background has already been removed. However, if you are using your own images, you will need to do this yourself.</p>
<p>After you have prepared your image, now open it with Inkscape so that you can vectorize it. With the image selected in the editor, go to the <strong class="bold">Path</strong> menu at the top and choose <strong class="bold">Trace Bitmap</strong>; this will trace the image and prepare it for vectorization, as before.</p>
<p>With the image selected on the canvas, if you look at the <strong class="bold">Previews</strong> pane at the right, the image has been converted into black and white. That’s because, by default, Inkscape selects the <strong class="bold">Single Scan</strong> option, the option for black-and-white images. And even though this is a color image, because it’s such a simple shape with not many variations of red in it, we don’t need the <strong class="bold">Multicolor</strong> option; so, <strong class="bold">Single scan</strong> will work fine here.</p>
<p>This is also a good opportunity to use the <strong class="bold">Smooth Corners</strong> option as well because this shape has (for the most part) smooth corners, and this selection will preserve them.</p>
<p>This is what it should look like so far:</p>
<div><div><img alt="Figure 9.15: The heart image in Inkscape " src="img/B18674_09_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15: The heart image in Inkscape</p>
<p>Also, do you notice that the<a id="_idIndexMarker526"/> heart image shown in <strong class="bold">Preview</strong> has two white<a id="_idIndexMarker527"/> areas inside it? That’s the Inkscape algorithm trying to capture the shiny parts of the red heart image on the canvas. We only want to trace the outside perimeter of the heart, which is the area that will be outlined later in the code – we don’t want those white areas. To remove those white areas in the preview, slide the <strong class="bold">Threshold</strong> slider to the right, just enough so the heart fills up like this:</p>
<div><div><img alt="Figure 9.16: Setting the options in Inkscape for the heart image " src="img/B18674_09_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16: Setting the options in Inkscape for the heart image</p>
<p>Now that the heart shape<a id="_idIndexMarker528"/> is ready to be vectorized, click the <strong class="bold">Apply</strong> button to complete<a id="_idIndexMarker529"/> the process, and a new vectorized black heart is placed directly over the red heart image on the canvas. Drag the black heart off to the side, in order to see the red heart under it, then delete the red heart.</p>
<p>Next, position the black heart back over the white canvas and export it like the “WE” image, making sure to choose the <strong class="bold">Plain SVG (*.svg)</strong> file type.</p>
<p>Moving away from Inkscape and into the Sketch program, open the new vector image we just exported from Inkscape into Sketch by right-clicking on the image and selecting <strong class="bold">Open with Sketch</strong>. We will resize the image again to a width of <strong class="bold">250</strong> (again, making sure to click on the lock icon to fix the proportions):</p>
<div><div><img alt="Figure 9.17: Setting the size for the heart image in Sketch " src="img/B18674_09_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17: Setting the size for the heart image in Sketch</p>
<p>Next minimize the Sketch<a id="_idIndexMarker530"/> window, as we only need it running<a id="_idIndexMarker531"/> in the background so that Kite can access it, and open the Kite program. In Kite, click on <strong class="bold">File</strong>, then <strong class="bold">Import</strong>, and then <strong class="bold">From Sketch</strong>. You will see the same window as shown in <em class="italic">Figure 9</em><em class="italic">.12</em>, and you can keep the default settings. Then, click <strong class="bold">Import</strong>.</p>
<p>Once the image has been imported, select the image on the canvas, and then click the <strong class="bold">Code</strong> button at the top to generate the Swift code we need:</p>
<div><div><img alt="Figure 9.18: Generating the heart’s Swift code in Kite " src="img/B18674_09_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18: Generating the heart’s Swift code in Kite</p>
<p>Like we did with the “WE” image<a id="_idIndexMarker532"/> code, we just want to copy the code<a id="_idIndexMarker533"/> that starts with the <code>pathtPath</code> name. In the example here, the code we need starts at the <code>let pathPath = CGMutablePath()</code> line and ends with <code>pathPath.move(to)</code>.</p>
<p>Now back to Xcode – create a new SwiftUI View file, which I will name <code>HeartView</code>. Inside the file, we will create a struct to put the code in, call it <code>HeartShape</code>, and make it conform to the <code>shape</code> protocol, like this:</p>
<pre class="source-code">
struct HeartShape: Shape {
    func path(in rect: CGRect) -&gt; Path {
    }
 }</pre>
<p>Remember when making the “WE” shape, we used the shape protocol? As before, it requires us to use the <code>path()</code> method, which I have added here. </p>
<p>Now, we can paste the Kite-generated<a id="_idIndexMarker534"/> Swift code inside this method (again, I will only include the first few lines<a id="_idIndexMarker535"/> and the last few lines so as not to take up too much space here; as before, the complete code file and project are available in the GitHub repo):</p>
<pre class="source-code">
struct HeartShape: Shape {
  func path(in rect: CGRect) -&gt; Path {
    let pathPath = CGMutablePath()
       pathPath.move(to: CGPoint(x: 245.632095, y: 
         460.368713))
       pathPath.addCurve(to: CGPoint(x: 221.824585, y: 
         420.429504), control1: CGPoint(x: 240.765762, y: 
         449.02652), control2: CGPoint(x: 231.057922, y: 
         432.740723))
........................................................
      pathPath.closeSubpath()
       pathPath.move(to: CGPoint(x: 245.632095, y: 
         460.368713))
    }
 }</pre>
<p>Next, let’s refactor the code as we did before. <em class="italic">Command + click</em> on the <code>pathPath</code> instance and choose <code>path</code>. Also, change the mutability of the <code>path</code> constant to a variable by replacing <code>let</code> with <code>var</code>, and change <code>CGMutablePath()</code> to <code>Path()</code>. These changes should look like this:</p>
<pre class="source-code">
var path = Path()</pre>
<p>The last change to make is at the bottom of the <code>HeartShape</code> struct; after the very last line of code, we need to return the path we created, so add the following line of code to the end of the <code>path</code> function:</p>
<pre class="source-code">
return path</pre>
<p>The code should now build<a id="_idIndexMarker536"/> cleanly, and we can move on to animating<a id="_idIndexMarker537"/> the outline around the heart. This is similar code to that in the <code>WEView</code> file. At the top of the struct, let’s add the following variables:</p>
<pre class="source-code">
//MARK: - VARIABLES
    @State var strokeReset: Bool = true
    @State var startStroke: CGFloat = 0.0
    @State var endStroke: CGFloat = 0.0</pre>
<p>The <code>strokeReset</code> variable will keep track of the animation, <code>startStroke</code> will hold a value that sets the <code>length</code> property of the stroke at the beginning, and <code>endStroke</code> will hold a value that sets the <code>length</code> property of the stroke at the end.</p>
<p>Moving into the <code>body</code> property of the struct, let’s add the views needed to display and animate our heart outline:</p>
<pre class="source-code">
var body: some View {
  ZStack {
    Group {
      //SHAPE OUTLINE
      HeartShape()
          .stroke(style: StrokeStyle(lineWidth: 0.5, 
            lineCap: .round, lineJoin: .round))
          .foregroundColor(.gray)
      //ANIMATING STROKE
      HeartShape()
          .trim(from: startStroke, to: endStroke)
          .stroke(style: StrokeStyle(lineWidth: 5, lineCap: 
            .round, lineJoin: .round))
          .foregroundColor(Color.white)
  }.offset (x: 75, y: -30)
  }.onAppear() {
    Timer.scheduledTimer(withTimeInterval: 0.23, repeats: 
      true) { timer in
        if (endStroke &gt;= 1) {
          if (strokeReset) {
              Timer.scheduledTimer(withTimeInterval: 0.6, 
                repeats: false) { _ in
                  endStroke = 0
                  startStroke = 0
                  strokeReset.toggle()
              }
              strokeReset = false
          }
      }
      withAnimation(Animation.easeOut) {
          endStroke += 0.12
          startStroke = endStroke - 0.4 
      }
    }
  }
}</pre>
<p>The code here is almost identical to the code in the <code>WEView</code> file – what’s different is the color of the stroke. Here, it is white and we are offsetting the heart to be lower on the screen.</p>
<p>Run the code and you’ll see that there is a smoothly animating stroke going around the heart shape.</p>
<p>Again, all the values<a id="_idIndexMarker538"/> are for you to explore and experiment<a id="_idIndexMarker539"/> with to create the look you want.</p>
<p>But let’s do something a bit different for this shape – let’s add the actual heart bitmap image right inside the animating heart shape. To do this, add the following code at the bottom of the <code>Group</code> view:</p>
<pre class="source-code">
Group {
      //SHAPE OUTLINE
      HeartShape()
          .stroke(style: StrokeStyle(lineWidth: 0.5, 
            lineCap: .round, lineJoin: .round))
          .foregroundColor(.gray)
      //ANIMATING STROKE
      HeartShape()
          .trim(from: startStroke, to: endStroke)
          .stroke(style: StrokeStyle(lineWidth: 5, lineCap: 
            .round, lineJoin: .round))
          .foregroundColor(Color.blue)
     <strong class="bold"> ///HEART BITMAP IMAGE</strong>
<strong class="bold">      Image("heart").resizable().aspectRatio(contentMode: </strong>
<strong class="bold">        .fit)</strong>
<strong class="bold">          .frame(width: 246, alignment: .center)</strong>
<strong class="bold">          .position(x: 125, y:117.5)</strong>
     }</pre>
<p>Run the code again and you’ll see<a id="_idIndexMarker540"/> that it performs as before, only now<a id="_idIndexMarker541"/> we’ve positioned the heart bitmap image inside the stationary stroke, so the animated stroke is tracing the heart image for an interesting look:</p>
<div><div><img alt="Figure 9.19: The stroke around the heart image " src="img/B18674_09_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19: The stroke around the heart image</p>
<p>We have completed two shapes now, the “WE” letters and the heart. Let’s continue and add the final image to the project, the SwiftUI logo.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor135"/>Creating a stroke animation on the SwiftUI logo image</h2>
<p>Now that we have reached<a id="_idIndexMarker542"/> the final image, I would like to challenge<a id="_idIndexMarker543"/> you by letting you take this one on by yourself. Use the steps we have outlined in the previous two shapes – including removing backgrounds, vectorizing your image, and converting the image into Swift Code – and copy the code into a new SwiftUI View file called <code>SwiftUILogoView</code>.</p>
<p>Okay, give it a try, and come back here when you’re ready…</p>
<p>How did you do?</p>
<p>After you vectorize a few shapes and gather the code, the process will become very familiar and much quicker. If you have used images other than the ones I supplied for this project, that’s perfectly fine; just know that the SwiftUI code for those images will be different from the code I will show here for the SwiftUI logo, but the animating code will be the same.</p>
<p>Here is the SwiftUI code that I got back from Kite for the SwiftUI logo image (and as before, the full code file is available in the GitHub repo):</p>
<pre class="source-code">
struct SwiftUILogoShape: Shape {
  func path(in rect: CGRect) -&gt; Path {
    var path = Path()
    path.move(to: CGPoint(x: 201.374207, y: 235.109955))
    path.addCurve(to: CGPoint(x: 231.023102, y: 
      220.544876), control1: CGPoint(x: 212.656006, y: 
      233.244553), control2: CGPoint(x: 222.89035, y: 
      228.216904))
   ........................................................
     path.addCurve(to: CGPoint(x: 207.854324, y: 
       191.140839), control1: CGPoint(x: 209.692215, y: 
       193.796051), control2: CGPoint(x: 208.764877, y: 
       192.663177))
     path.addLine(to: CGPoint(x: 207.854324, y: 
       191.140839))
     path.closeSubpath()
     path.move(to: CGPoint(x: 207.854324, y: 191.140839))
        return path
    }
}</pre>
<p>I have previously explained<a id="_idIndexMarker544"/> how this code creates a shape<a id="_idIndexMarker545"/> object in the <em class="italic">Creating a stroke animation on the “WE” image</em> section; if you would like a refresher on understanding how this works, go back to that section for the details on this code.</p>
<p>We can now move to the top of the file, inside the <code>SwiftUILogo</code> struct, and start adding the animation code. I will add the complete code for this final shape:</p>
<pre class="source-code">
struct SwiftUILogoView: View {
    //MARK: - VARIABLES
    @State var strokeReset: Bool = true
    @State var startStroke: CGFloat = 0.0
    @State var endStroke: CGFloat = 0.0
    var body: some View {
      ZStack {
        Group {
          //SHAPE OUTLINE
              SwiftUILogoShape()
          .stroke(style: StrokeStyle(lineWidth: 0.5, 
            lineCap: .round, lineJoin: .round))
          .foregroundColor(.gray)
      //ANIMATING STROKE
      SwiftUILogoShape()
          .trim(from: startStroke, to: endStroke)
          .stroke(style: StrokeStyle(lineWidth: 5, lineCap: 
            .round, lineJoin: .round))
          .foregroundColor(Color.blue)
  }.offset(x: UIScreen.main.bounds.size.width / 5.5)
    }.onAppear() {
  Timer.scheduledTimer(withTimeInterval: 0.23, repeats: 
    true) { timer in
      if (endStroke &gt;= 1) {
          if (strokeReset) {
              Timer.scheduledTimer(withTimeInterval: 0.6, 
                repeats: false) { _ in
                  endStroke = 0
                  startStroke = 0
                  strokeReset.toggle()
              }
              strokeReset = false
          }
      }
      withAnimation(Animation.easeOut) {
          endStroke += 0.12
          startStroke = endStroke - 0.4 
        }
      }
   }
  }
}</pre>
<p>This animating code is the same code that we have been adding all along, and if you would like an explanation of how it works, go back to the “WE” shape code for all the details. The minor differences here are that the line is blue, and we are offsetting it lower on the screen.</p>
<p>Give this a run and check<a id="_idIndexMarker546"/> out the stroke<a id="_idIndexMarker547"/> around the logo.</p>
<p>The final part of the project is to combine all three of the shape structs onto the screen together. Let’s do that next.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor136"/>Combining the animated strokes</h2>
<p>There is very little code needed<a id="_idIndexMarker548"/> for this, as we are just calling the three shape structs in one place. All you need to do is add the following code to the <code>ContentView</code> struct:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack  {
            WeView()
            HeartView()
            SwiftUILogoView()
        }.background(Color.black)
    }
}</pre>
<p>What we have done here is called all three structs inside <code>ContentView</code>, used a <code>VStack</code> to line up the views vertically, and then added a black background at the end. When you run the code, you will see the following result:</p>
<div><div><img alt="Figure 9.20: The finished project " src="img/B18674_09_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20: The finished project</p>
<p>Now, all three<a id="_idIndexMarker549"/> views are animated as being outlined with different colors.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor137"/>Summary</h1>
<p>Nice job finishing this project! To create the finished animation, we learned how to turn bitmap images into vector files, and then how to turn those vector files into code that we can work with using SwiftUI. Also, we learned how to create and animate a moving outline around almost any shape using the <code>stroke</code> modifier and timers, and used animation in this project.</p>
<p>Using this project, you can play around with the values. You can make the stroke thicker or thinner, make it move faster or slower, and make it any color of the rainbow. </p>
<p>There are many applications for animating strokes in your apps, too. It can be used for logos, text, and brands, so that they stand out and get noticed; it can be used in game apps to bring the users’ attention to different areas of the screen or can be used anywhere you want to make an app come alive. The uses are only limited by your imagination.</p>
<p>In the next chapter, we will learn how to animate lines in a different way to create waves, and then put them together to make an ocean with an animating buoy, complete with sound effects.</p>
</div>
<div><div></div>
</div>
</body></html>