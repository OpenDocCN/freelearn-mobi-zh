<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-158"><em class="italic"><a id="_idTextAnchor164"/>Chapter 6</em>: Threads and Coroutines</h1>&#13;
			<p>In the previous chapter, we had a glance at how our application can efficiently serve thousands of requests per second—to discuss why immutability is important, we introduced a race condition problem using two threads.</p>&#13;
			<p>In this chapter, we'll dive deeper into how to launch new threads in Kotlin and the reasons why coroutines can scale much better than threads. We will discuss how the Kotlin compiler treats coroutines and the relationship between coroutine scopes and dispatchers. We'll discuss the concept of <strong class="bold">structured concurrency</strong>, and how it helps us prevent resource leaks in our programs.</p>&#13;
			<p>We'll cover the following topics in this chapter:</p>&#13;
			<ul>&#13;
				<li>Looking deeper into threads</li>&#13;
				<li>Introducing coroutines and suspend functions</li>&#13;
				<li>Starting coroutines</li>&#13;
				<li>Jobs</li>&#13;
				<li>Coroutines under the hood</li>&#13;
				<li>Dispatchers</li>&#13;
				<li>Structured concurrency</li>&#13;
			</ul>&#13;
			<p>After reading this chapter, you'll be familiar with Kotlin's concurrency primitives and how to best utilize them. </p>&#13;
			<h1 id="_idParaDest-159"><a id="_idTextAnchor165"/>Technical requirements</h1>&#13;
			<p>In addition to the requirements from the previous chapters, you will also need a <strong class="bold">Gradle</strong>-enabled <strong class="bold">Kotlin</strong> project to be able to add the required dependencies.</p>&#13;
			<p>You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter06">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter06</a>.</p>&#13;
			<h1 id="_idParaDest-160"><a id="_idTextAnchor166"/>Looking deeper into threads</h1>&#13;
			<p>Before we dive into the nuances, let's discuss what kinds of problems threads can solve.</p>&#13;
			<p>In your laptop, you have a CPU with multiple cores – probably four of them, or even eight. This means that it can do four different computations <em class="italic">in parallel</em>, which is pretty amazing considering that 15 years ago, a single-core CPU was the default and even two cores were only for enthusiasts.</p>&#13;
			<p><em class="italic">But even back then, you were not limited to doing only a single task at a time, right?</em> You could listen to music and browse the internet at the same time, even on a single-core CPU. <em class="italic">How does your CPU manage to pull that off?</em> Well, the same way your brain does. It juggles tasks. When you're reading a book while listening to your friend talking, part of the time, you're not reading, and part of the time, you're not listening – that is, until we get at least two cores in our brains.</p>&#13;
			<p>The servers you run your code on have pretty much the same CPU. This means that they can serve four requests simultaneously. <em class="italic">But what if you have 10,000 requests per second?</em> You can't serve them in parallel because you don't have 10,000 CPU cores. But you can try and serve them concurrently.</p>&#13;
			<p>The most basic concurrency model provided by JVM is known as a <strong class="bold">thread</strong>. Threads allow us to run<a id="_idIndexMarker466"/> code concurrently (but not necessarily in parallel) so that we can make better use of multiple CPU cores, for example. They are more lightweight than processes. One process may spawn hundreds of threads. Unlike processes, sharing data between threads is easy. But that also introduces a lot of problems, as we'll see later.</p>&#13;
			<p>Let's learn how to create two threads in Java first. Each thread will output numbers between <code>0</code> and <code>100</code>:</p>&#13;
			<pre> for (int t = 0; t &lt; 2; t++) {</pre>&#13;
			<pre>    int finalT = t;</pre>&#13;
			<pre>    new Thread(() -&gt; {</pre>&#13;
			<pre>        for (int i = 0; i &lt; 100; i++) {</pre>&#13;
			<pre>            System.out.println("Thread " + finalT + ":               " + i);</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }).start();</pre>&#13;
			<pre>}</pre>&#13;
			<p>The <a id="_idIndexMarker467"/>output will look something like this:</p>&#13;
			<pre>&gt; ... </pre>&#13;
			<pre>&gt; T0: 12 </pre>&#13;
			<pre>&gt; T0: 13 </pre>&#13;
			<pre>&gt; T1: 60 </pre>&#13;
			<pre>&gt; T0: 14 </pre>&#13;
			<pre>&gt; T1: 61 </pre>&#13;
			<pre>&gt; T0: 15 </pre>&#13;
			<pre>&gt; T1: 16 </pre>&#13;
			<pre>&gt; ...</pre>&#13;
			<p>Note that the output will vary between executions and that at no point is it guaranteed to be interleaved.</p>&#13;
			<p>The same code in Kotlin would look as follows:</p>&#13;
			<pre>repeat(2) { t -&gt;</pre>&#13;
			<pre>    thread { </pre>&#13;
			<pre>        for (i in 1..100) { </pre>&#13;
			<pre>            println("T$t: $i") </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>In Kotlin, there's less boilerplate because there's a function that helps us create a new thread. Notice that, unlike Java, we don't need to call <code>start()</code> to launch the thread. It starts by default. If we would like to postpone it for later, we can set the <code>start</code> parameter to <code>false</code>:</p>&#13;
			<pre>val t = thread(start = false) </pre>&#13;
			<pre>... </pre>&#13;
			<pre>// Later </pre>&#13;
			<pre>t.start()</pre>&#13;
			<p>Another useful concept from<a id="_idIndexMarker468"/> Java is <strong class="bold">daemon threads</strong>. These threads don't prevent JVM from exiting and are very good for non-critical background tasks.</p>&#13;
			<p>In Java, the API is not fluent, so we'll have to assign our thread to a variable, set it to be a daemon thread, and then start it. In Kotlin, this is much simpler:</p>&#13;
			<pre>thread(isDaemon = true) { </pre>&#13;
			<pre>    for (i in 1..1_000_000) { </pre>&#13;
			<pre>        println("daemon thread says: $i") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice that although we asked this thread to print numbers up to one million, it prints only a few hundred. That's because it's a daemon thread. When the parent thread stops, all the daemon threads stop as well. </p>&#13;
			<h2 id="_idParaDest-161"><a id="_idTextAnchor167"/>Thread safety</h2>&#13;
			<p>There are entire books written<a id="_idIndexMarker469"/> about <strong class="bold">thread safety</strong> and there are good reasons for this. Concurrency bugs that are caused by a lack of thread safety are the hardest ones to track. They're hard to reproduce because you'll usually need a lot of threads competing for the same resource in order for an actual race to happen. Because this book is about Kotlin and not thread safety in general, we'll only scratch the surface of this topic. If you're interested in the topic of thread safety in the JVM language, you should check out the book <em class="italic">Java Concurrency in Practice</em>, by Brian Goetz.</p>&#13;
			<p>We'll start with the following example, which creates 100,000 threads to increment a <code>counter</code>. To make sure that all the threads complete their work before we check the value, we'll use <code>CountDownLatch</code>:</p>&#13;
			<pre>var counter = 0</pre>&#13;
			<pre>val latch = CountDownLatch(100_000)</pre>&#13;
			<pre>repeat(100) {</pre>&#13;
			<pre>    thread {</pre>&#13;
			<pre>        repeat(1000) {</pre>&#13;
			<pre>            counter++</pre>&#13;
			<pre>            latch.countDown()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>latch.await()</pre>&#13;
			<pre>println("Counter $counter")</pre>&#13;
			<p>The reason this<a id="_idIndexMarker470"/> code doesn't print the correct number is that we introduced a data race since the <code>++</code> operation is not atomic. So, if more threads try to increment our counter, then there are more chances for data races. </p>&#13;
			<p>Unlike Java, there's no <code>synchronized</code> keyword in Kotlin. The reason for this is that Kotlin designers believe that a language shouldn't be tailored to a particular concurrency model. Instead, there's a <code>synchronized()</code> function we can use:</p>&#13;
			<pre>thread {</pre>&#13;
			<pre>    repeat(1000) {</pre>&#13;
			<pre>        <strong class="bold">synchronized(latch)</strong> {</pre>&#13;
			<pre>            counter++</pre>&#13;
			<pre>            latch.countDown()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, our code prints <code>100,000</code>, as expected.</p>&#13;
			<p>If you miss the synchronized methods from Java, there's the <code>@Synchronized</code> annotation in<a id="_idIndexMarker471"/> Kotlin. Java's <code>volatile</code> keyword is also replaced by the <code>@Volatile</code> annotation instead. The following table shows us an example of this comparison:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/Table_01.jpg" alt="Table 6.1 – Comparison between Java and Kotlin (synchronized and volatile methods)&#13;&#10;" width="1663" height="271"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Table 6.1 – Comparison between Java and Kotlin (synchronized and volatile methods)</p>&#13;
			<p>The reason <code>Synchronized</code> and <code>Volatile</code> are annotations and not keywords is because Kotlin can be compiled on other platforms in addition to JVM. But the concepts of <code>synchronized</code> methods or <code>volatile</code> variables exist for JVM specifically. </p>&#13;
			<h2 id="_idParaDest-162"><a id="_idTextAnchor168"/>Why are threads expensive?</h2>&#13;
			<p>There is a price to pay <a id="_idIndexMarker472"/>whenever we create a new thread. Each thread needs a new memory stack.</p>&#13;
			<p><em class="italic">What if we simulate some work inside each thread by putting it to sleep?</em></p>&#13;
			<p>In the following piece of code, we'll attempt to create 10,000 threads, each sleeping for a relatively short period:</p>&#13;
			<pre>val counter = AtomicInteger() </pre>&#13;
			<pre>try { </pre>&#13;
			<pre>    for (i in 0..10_000) { </pre>&#13;
			<pre>        thread { </pre>&#13;
			<pre>            counter.incrementAndGet() </pre>&#13;
			<pre>            Thread.sleep(100) </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>} catch (oome: OutOfMemoryError) { </pre>&#13;
			<pre>    println("Spawned ${counter.get()} threads before       crashing") </pre>&#13;
			<pre>    System.exit(-42) </pre>&#13;
			<pre>}</pre>&#13;
			<p>Each thread requires<a id="_idIndexMarker473"/> one megabyte of RAM for its stack. Creating so many threads will require lots of communication with your operating system and a lot of memory. We attempt to identify whether we ran out of memory by catching the relevant exception.</p>&#13;
			<p>Depending on your operating system, this will result in either <code>OutOfMemoryError</code> or the entire system becoming very slow. </p>&#13;
			<p>Of course, there are ways to limit how many threads are run at once using the <strong class="bold">Executors API</strong>. This<a id="_idIndexMarker474"/> API was introduced back in <strong class="bold">Java 5</strong>, so it should be pretty well-known to you. </p>&#13;
			<p>Using that API, we can create a new thread pool of a specified size. Try setting the <code>pool</code> size to <code>1</code>, the number of cores on your machine to <code>100</code> and <code>2000</code>, and see what happens:</p>&#13;
			<pre>val pool = Executors.newFixedThreadPool(100)</pre>&#13;
			<p>Now, we would like to submit a new task. We can do this by calling <code>pool.submit()</code>:</p>&#13;
			<pre>val counter = AtomicInteger(0) </pre>&#13;
			<pre>val start = System.currentTimeMillis() </pre>&#13;
			<pre>for (i in 1..10_000) { </pre>&#13;
			<pre>    pool.submit { </pre>&#13;
			<pre>        // Do something </pre>&#13;
			<pre>        counter.incrementAndGet() </pre>&#13;
			<pre> </pre>&#13;
			<pre>        // Simulate wait on IO </pre>&#13;
			<pre>        Thread.sleep(100) </pre>&#13;
			<pre> </pre>&#13;
			<pre>        // Do something again </pre>&#13;
			<pre>        counter.incrementAndGet() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>By incrementing <code>counter</code> once before <code>sleep</code> and once after, we are simulating some business logic – for example, preparing some JSON and then parsing the response – while <code>sleep</code> itself <a id="_idIndexMarker475"/>simulates a network operation.</p>&#13;
			<p>Then, we need to make sure that the pool terminates and give it <code>20</code> seconds to do so by using the following lines:</p>&#13;
			<pre>pool.awaitTermination(20, TimeUnit.SECONDS) </pre>&#13;
			<pre>pool.shutdown() </pre>&#13;
			<pre>println("Took me ${System.currentTimeMillis() - start}   millis to complete ${counter.get() / 2} tasks")</pre>&#13;
			<p>Notice that it took us 20 seconds to complete. That's because a new task cannot begin until the previous tasks <em class="italic">wake up</em> and finish their jobs. </p>&#13;
			<p>And that's exactly what happens in a multithreaded system that is not concurrent enough.</p>&#13;
			<p>In the next section, we'll discuss how coroutines try to solve this problem.</p>&#13;
			<h1 id="_idParaDest-163"><a id="_idTextAnchor169"/>Introducing coroutines</h1>&#13;
			<p>In addition to the threading model provided by Java, Kotlin <a id="_idIndexMarker476"/>also has a <strong class="bold">coroutines</strong> model. Coroutines might be considered lightweight threads, and we'll see what advantages they provide over an existing model of threads shortly.</p>&#13;
			<p>The first thing you need to know is that coroutines are not part of the language. They are simply another library provided by JetBrains. For that reason, if we want to use them, we need to specify this in our Gradle configuration file; that is, <code>build.gradle.kts</code>:</p>&#13;
			<pre>dependencies { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    implementation("org.jetbrains.kotlinx:kotlinx-      coroutines-core:1.5.1") </pre>&#13;
			<pre>}</pre>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">By the time you read this book, the latest version of the Coroutines library will be <strong class="bold">1.6</strong> or greater.</p>&#13;
			<p>First, we will compare starting a new thread and a new coroutine.</p>&#13;
			<h2 id="_idParaDest-164"><a id="_idTextAnchor170"/>Starting coroutines</h2>&#13;
			<p>We've already<a id="_idIndexMarker477"/> seen how to start a new thread in Kotlin in the <em class="italic">Looking deeper into threads</em> section. Now, let's start a new coroutine instead.</p>&#13;
			<p>We'll create almost the same example we did with threads. Each coroutine will increment some counter, sleep for a while to emulate some kind of I/O, and then increment it again:</p>&#13;
			<pre>val latch = CountDownLatch(10_000)</pre>&#13;
			<pre>val c = AtomicInteger()</pre>&#13;
			<pre>val start = System.currentTimeMillis()</pre>&#13;
			<pre>for (i in 1..10_000) {</pre>&#13;
			<pre>    GlobalScope.launch {</pre>&#13;
			<pre>        c.incrementAndGet()</pre>&#13;
			<pre>        delay(100)</pre>&#13;
			<pre>        c.incrementAndGet()</pre>&#13;
			<pre>        latch.countDown()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>latch.await(10, TimeUnit.SECONDS)</pre>&#13;
			<pre> </pre>&#13;
			<pre>println("Executed ${c.get() / 2} coroutines in   ${System.currentTimeMillis() - start}ms")</pre>&#13;
			<p>The first way of starting a new coroutine is by using the <code>launch()</code> function. Again, note that this is simply another function and not a language construct. </p>&#13;
			<p>Another interesting <a id="_idIndexMarker478"/>point here is the call to the <code>delay()</code> function, which we use to simulate some I/O-bound work, such as fetching something from a database or over the network.</p>&#13;
			<p>Like the <code>Thread.sleep()</code> method, it puts the current coroutine to sleep. But unlike <code>Thread.sleep()</code>, other coroutines can work while it sleeps soundly. This is because <code>delay()</code> is marked with a <code>suspend</code> keyword, which we'll discuss in the <em class="italic">Jobs</em> section.</p>&#13;
			<p>If you run this code, you'll see that the task takes about 200 ms with coroutines, while with threads, it either takes 20 seconds or runs out of memory. And we didn't have to change our code that much. That's all thanks to the fact that coroutines are highly concurrent. They can be suspended without blocking the thread that runs them. Not blocking a thread is great because we can use fewer OS threads (which are expensive) to do more work.</p>&#13;
			<p>If you run this code in your IntelliJ IDEA, you'll notice that <code>GlobalScope</code> is marked as a <code>GlobalScope</code> shouldn't be used in real-world projects unless the developer understands how it works under the hood. Otherwise, it may cause unintended leaks. We'll learn about better ways of launching coroutines later in this chapter.</p>&#13;
			<p>Although we've seen <a id="_idIndexMarker480"/>that coroutines are much more concurrent than threads, there's nothing magical in them. Now, let's learn about another way of starting a coroutine, as well as some issues coroutines may still suffer from.</p>&#13;
			<p>The <code>launch()</code> function that we just discussed starts a coroutine that doesn't return anything. In contrast, the <code>async()</code> function starts a coroutine that returns some value. </p>&#13;
			<p>Calling <code>launch()</code> is much like calling a function that returns <code>Unit</code>. But most of our functions return some kind of result. For that purpose, we have the <code>async()</code> function. It also launches a coroutine, but instead of returning a job, it returns <code>Deferred&lt;T&gt;</code>, where <code>T</code> is the type that you expect to get later.</p>&#13;
			<p>For example, the following function will start a coroutine that generates a UUID asynchronously and returns it:</p>&#13;
			<pre>fun fastUuidAsync() = GlobalScope.async {</pre>&#13;
			<pre>    UUID.randomUUID()</pre>&#13;
			<pre>}</pre>&#13;
			<pre>println(fastUuidAsync())</pre>&#13;
			<p>If we run the following code from our <code>main</code> method, though, it won't print the expected result. The result that this code prints instead of some UUID value is as follows:</p>&#13;
			<pre>&gt; DeferredCoroutine{Active}</pre>&#13;
			<p>The returned object from a coroutine is called a job. Let's understand what this is and how to use it correctly.</p>&#13;
			<h2 id="_idParaDest-165"><a id="_idTextAnchor171"/>Jobs</h2>&#13;
			<p>The result of running an asynchronous task is<a id="_idIndexMarker481"/> called a <code>Thread</code> object represents an actual OS thread, the <code>job</code> object represents an actual coroutine. </p>&#13;
			<p>This means that what we tried to do is this:</p>&#13;
			<pre>val job: Job = fastUuidAsync()</pre>&#13;
			<pre>println(job)</pre>&#13;
			<p><code>job</code> has a simple life cycle. It can <a id="_idIndexMarker482"/>be in one of the following states:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">New</strong>: Created but not started yet.</li>&#13;
				<li><code>launch()</code> function, for example. This is the default state.</li>&#13;
				<li><strong class="bold">Completed</strong>: Everything went well.</li>&#13;
				<li><strong class="bold">Canceled</strong>: Something went wrong.</li>&#13;
			</ul>&#13;
			<p>Two more states are relevant to jobs that have child jobs:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Completing</strong>: Waiting to finish executing children before completing</li>&#13;
				<li><strong class="bold">Canceling</strong>: Waiting to finish executing children before canceling</li>&#13;
			</ul>&#13;
			<p>If you want to learn more about parent and child jobs, jump to the <em class="italic">Parent jobs</em> section of this chapter.</p>&#13;
			<p>The job we've confused with its value is in the Active state, meaning that it hasn't finished computing our UUID yet.</p>&#13;
			<p>A job that has a value is known as being <code>Deffered</code>:</p>&#13;
			<pre>val job: Deferred&lt;UUID&gt; = fastUuidAsync()</pre>&#13;
			<p>We'll discuss the <code>Deferred</code> value in more detail in <a href="B17816_08_ePub.xhtml#_idTextAnchor198"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing for Concurrency</em>.</p>&#13;
			<p>To wait for a job to complete and get the actual value, we can use the <code>await()</code> function:</p>&#13;
			<pre>val job: Deferred&lt;UUID&gt; = fastUuidAsync()</pre>&#13;
			<pre>println(job.await())</pre>&#13;
			<p>This code doesn't compile, though:</p>&#13;
			<pre>&gt; Suspend function 'await' should be called only from a coroutine or another suspend function</pre>&#13;
			<p>The reason for this is that, as stated in the error itself, our <code>main()</code> function is not marked with a <code>suspend</code> keyword and isn't a coroutine either. </p>&#13;
			<p>We can fix this by <a id="_idIndexMarker483"/>wrapping our code in a <code>runBlocking</code> function:</p>&#13;
			<pre>runBlocking {</pre>&#13;
			<pre>    val job: Deferred&lt;UUID&gt; = fastUuidAsync()</pre>&#13;
			<pre>    println(job.await())</pre>&#13;
			<pre>}</pre>&#13;
			<p>This function will block our main thread until all the coroutines finish. It is an implementation of the Bridge design pattern from <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, which allows us to connect between regular code and code that uses coroutines. </p>&#13;
			<p>Running this code now will produce the expected output of some random UUID.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">In this chapter, while discussing coroutines, we will sometimes omit <code>runBlocking</code> for conciseness. You can always find the full working examples in this book's GitHub repository.</p>&#13;
			<p>The <code>job</code> object also has some other useful methods, which we'll discuss in the following sections.</p>&#13;
			<h2 id="_idParaDest-166"><a id="_idTextAnchor172"/>Coroutines under the hood</h2>&#13;
			<p>So, we've mentioned the following facts a couple of times:</p>&#13;
			<ul>&#13;
				<li>Coroutines are like<a id="_idIndexMarker484"/> lightweight threads. They need fewer resources than regular threads, so you can create more of them.</li>&#13;
				<li>Instead of blocking an entire thread, coroutines suspend themselves, allowing the thread to execute another piece of code in the meantime.</li>&#13;
			</ul>&#13;
			<p><em class="italic">But how do coroutines work?</em></p>&#13;
			<p>As an example, let's <a id="_idIndexMarker485"/>take a look at a function that composes a user profile:</p>&#13;
			<pre>fun profileBlocking(id: String): Profile { </pre>&#13;
			<pre>    // Takes 1s</pre>&#13;
			<pre>    val bio = fetchBioOverHttpBlocking(id)  </pre>&#13;
			<pre>    // Takes 100ms</pre>&#13;
			<pre>    val picture = fetchPictureFromDBBlocking(id)  </pre>&#13;
			<pre>    // Takes 500ms</pre>&#13;
			<pre>    val friends = fetchFriendsFromDBBlocking(id) </pre>&#13;
			<pre>    return Profile(bio, picture, friends) </pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, our function takes around 1.6 seconds to complete. Its execution is completely sequential, and the executing thread will be blocked for the entire time.</p>&#13;
			<p>We can redesign this function so that it works with coroutines, as follows:</p>&#13;
			<pre>suspend fun profile(id: String): Profile {</pre>&#13;
			<pre>    // Takes 1s    </pre>&#13;
			<pre>    val bio = fetchBioOverHttpAsync(id) </pre>&#13;
			<pre>    // Takes 100ms</pre>&#13;
			<pre>    val picture = fetchPictureFromDBAsync(id) </pre>&#13;
			<pre>    // Takes 500ms</pre>&#13;
			<pre>    val friends = fetchFriendsFromDBAsync(id) </pre>&#13;
			<pre>    return Profile(bio.await(), picture.await(),       friends.await())</pre>&#13;
			<pre>}</pre>&#13;
			<p>Without the <code>suspend</code> keyword, our asynchronous code simply won't compile. We'll cover what the <code>suspend</code> keyword means later in this section.</p>&#13;
			<p>To understand what each of the asynchronous functions looks like, let's take a look at one of them as an example:</p>&#13;
			<pre>fun fetchFriendsFromDBAsync(id: String) = GlobalScope.async </pre>&#13;
			<pre>{</pre>&#13;
			<pre>    delay(500)</pre>&#13;
			<pre>    emptyList&lt;String&gt;()</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, let's compare the <a id="_idIndexMarker486"/>performance of the two functions: one that is written in a blocking manner, and another that uses coroutines.</p>&#13;
			<p>We can wrap both functions using a <code>runBlocking</code> function, as we've seen previously, and measure the time it takes them to complete using <code>measureTimeMillis</code>:</p>&#13;
			<pre>runBlocking {</pre>&#13;
			<pre>    val t1 = measureTimeMillis {</pre>&#13;
			<pre>        blockingProfile("123")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    val t2 = measureTimeMillis {</pre>&#13;
			<pre>        profile("123")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    println("Blocking code: $t1")</pre>&#13;
			<pre>    println("Async: $t2")</pre>&#13;
			<pre>}</pre>&#13;
			<p>The output will be something like this:</p>&#13;
			<pre>&gt; Blocking code: 1623</pre>&#13;
			<pre>&gt; Coroutines: 1021</pre>&#13;
			<p>The execution time of the concurrent coroutines is the maximum of the longest coroutine, while with sequential code, it's the sum of all functions. </p>&#13;
			<p>Having understood the first two examples, let's look at another way to write the same code. </p>&#13;
			<p>We'll mark each of the<a id="_idIndexMarker487"/> functions with the <code>suspend</code> keyword:</p>&#13;
			<pre>suspend fun fetchFriendsFromDB(id: String): List&lt;String&gt; {</pre>&#13;
			<pre>    delay(500)</pre>&#13;
			<pre>    return emptyList()</pre>&#13;
			<pre>}</pre>&#13;
			<p>If you run this example, the performance will be the same as the blocking code. <em class="italic">So, why would we want to use suspendable functions?</em> </p>&#13;
			<p>Suspendable functions don't block the thread. Looking at the bigger picture, by using the same number of threads, we can serve far more users, all thanks to the smart way Kotlin rewrites suspendable functions.</p>&#13;
			<p>When the Kotlin compiler sees the <code>suspend</code> keyword, it knows it can split and rewrite the function, like this:</p>&#13;
			<pre>fun profile(state: Int, id: String, context: ArrayList&lt;Any&gt;): Profile {</pre>&#13;
			<pre>    when (state) {</pre>&#13;
			<pre>        0 -&gt; {</pre>&#13;
			<pre>            context += fetchBioOverHttp(id) </pre>&#13;
			<pre>            profile(1, id, context)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        1 -&gt; {</pre>&#13;
			<pre>            context += fetchPictureFromDB(id) </pre>&#13;
			<pre>            profile(2, id, context)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        2 -&gt; {</pre>&#13;
			<pre>            context += fetchFriendsFromDB(id) </pre>&#13;
			<pre>            profile(3, id, context)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        3 -&gt; {</pre>&#13;
			<pre>            val (bio, picture, friends) = context</pre>&#13;
			<pre>            return Profile(bio, picture, friends)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This rewritten <a id="_idIndexMarker488"/>code uses the <strong class="bold">State design pattern</strong> from <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, to split the execution of the function into many steps. By doing so, we can release <a id="_idIndexMarker489"/>the thread that executes coroutines at every stage of the state machine.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">This is not a perfect depiction of the generated code. The goal is to demonstrate the idea behind what the Kotlin compiler does, but some subtle implementation details are omitted for brevity.</p>&#13;
			<p>Note that unlike the asynchronous code we produced earlier, the state machine itself is sequential and takes the same amount of time as the blocking code to execute all its steps. </p>&#13;
			<p>It is a fact that none of these steps block any threads, which is important in this example. </p>&#13;
			<h3>Canceling a coroutine</h3>&#13;
			<p>If you are a<a id="_idIndexMarker490"/> Java developer, you may know that stopping a thread is quite complicated.</p>&#13;
			<p>For example, the <code>Thread.stop()</code> method is deprecated. There's <code>Thread.interrupt()</code>, but not all threads are checking this flag, not to mention setting a <code>volatile</code> flag, which is often suggested but is very cumbersome.</p>&#13;
			<p>If you're using a thread pool, you'll get <code>Future</code>, which has the <code>cancel(boolean mayInterruptIfRunning)</code> method. In Kotlin, the <code>launch()</code> function returns a job.</p>&#13;
			<p>This job can be canceled. The same rules from the previous example apply, though. If your coroutine never calls another <code>suspend</code> function or the <code>yield</code> function, it will disregard <code>cancel()</code>.</p>&#13;
			<p>To demonstrate that, we'll <a id="_idIndexMarker491"/>create one coroutine that yields once in a while:</p>&#13;
			<pre>val cancellable = launch {</pre>&#13;
			<pre>    try {</pre>&#13;
			<pre>        for (i in 1..10_000) {</pre>&#13;
			<pre>            println("Cancellable: $i")</pre>&#13;
			<pre>            yield()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    catch (e: CancellationException) {</pre>&#13;
			<pre>        e.printStackTrace()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>As you can see, after each <code>print</code> statement, the coroutine calls the <code>yield</code> function. If it was canceled, it will print the stack trace.</p>&#13;
			<p>We'll also create another coroutine that doesn't yield:</p>&#13;
			<pre>val notCancellable = launch {</pre>&#13;
			<pre>    for (i in 1..10_000) {</pre>&#13;
			<pre>        if (i % 100 == 0) {</pre>&#13;
			<pre>            println("Not cancellable $i")</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This coroutine never yields <a id="_idIndexMarker492"/>and prints its results every <code>100</code> iterations to avoid spamming the console.</p>&#13;
			<p>Now, let's try cancelling both coroutines:</p>&#13;
			<pre>println("Canceling cancellable") </pre>&#13;
			<pre>cancellable.cancel() </pre>&#13;
			<pre>println("Canceling not cancellable") </pre>&#13;
			<pre>notCancellable.cancel()</pre>&#13;
			<p>Then, we'll wait for the results:</p>&#13;
			<pre>runBlocking { </pre>&#13;
			<pre>    cancellable.join() </pre>&#13;
			<pre>    notCancellable.join() </pre>&#13;
			<pre>}</pre>&#13;
			<p>By invoking <code>join()</code>, we can wait for the execution of the coroutine to complete.</p>&#13;
			<p>Let's look at the output of our code:</p>&#13;
			<pre>&gt; Canceling cancellable</pre>&#13;
			<pre>&gt; Cancellable: 1</pre>&#13;
			<pre>&gt; Not cancellable 100</pre>&#13;
			<pre>&gt;...</pre>&#13;
			<pre>&gt; Not cancellable 1000</pre>&#13;
			<pre>&gt; Canceling not cancellable</pre>&#13;
			<p>A few interesting points we can learn from this experiment regarding the behavior of coroutines are as follows:</p>&#13;
			<ul>&#13;
				<li>Canceling the <code>cancellable</code> coroutine doesn't happen immediately. It may still print a line or two before being canceled.</li>&#13;
				<li>We can catch <code>CancellationException</code>, but our coroutine will be marked as canceled anyway. Catching <a id="_idIndexMarker493"/>that exception doesn't automatically allow us to continue.</li>&#13;
			</ul>&#13;
			<p>Now, let's understand what happened. The coroutine checks whether it was canceled, but only when it is switching between states. Since the non-cancellable coroutine didn't have any suspending functions, it never checked if it was asked to stop. </p>&#13;
			<p>In the <code>cancellable</code> coroutine, we used a new function: <code>yield()</code>. We could have called <code>yield()</code> on every loop iteration, but decided to do that every 100th one. This function checks whether there is anybody else that wants to do some work. If there's nobody else, the execution of the current coroutine will resume. Otherwise, another coroutine will start or resume from the point where it stopped earlier.</p>&#13;
			<p>Note that without the <code>suspend</code> keyword on our function or a coroutine generator, such as <code>launch()</code>, we can't call <code>yield()</code>. This is true for any function marked with <code>suspend</code>: it should either be called from another <code>suspend</code> function or from a coroutine.</p>&#13;
			<h2 id="_idParaDest-167"><a id="_idTextAnchor173"/>Setting timeouts</h2>&#13;
			<p>Let's consider the <a id="_idIndexMarker494"/>following situation. <em class="italic">What if, as happens in some cases, fetching the user's profile takes too long? What if we decided that if the profile takes more than 0.5 seconds to return, we'll just show no profile?</em></p>&#13;
			<p>This can be achieved using the <code>withTimeout()</code> function:</p>&#13;
			<pre>val coroutine = async {</pre>&#13;
			<pre>    withTimeout(500) {</pre>&#13;
			<pre>        try {</pre>&#13;
			<pre>            val time = Random.nextLong(1000)</pre>&#13;
			<pre>            println("It will take me $time to do")</pre>&#13;
			<pre>            delay(time)</pre>&#13;
			<pre>            println("Returning profile")</pre>&#13;
			<pre>            "Profile"</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        catch (e: TimeoutCancellationException) {</pre>&#13;
			<pre>            e.printStackTrace()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>We set the timeout to be <code>500</code> milliseconds, and our coroutine will delay for between <code>0</code> and <code>1000</code> milliseconds, giving it a 50 percent chance of failing.</p>&#13;
			<p>We'll <code>await</code> the results from the coroutine and see what happens:</p>&#13;
			<pre>val result = try { </pre>&#13;
			<pre>    coroutine.await() </pre>&#13;
			<pre>} </pre>&#13;
			<pre>catch (e: TimeoutCancellationException) { </pre>&#13;
			<pre>    "No Profile" </pre>&#13;
			<pre>} </pre>&#13;
			<pre>println(result)</pre>&#13;
			<p>Here, we benefit from the<a id="_idIndexMarker495"/> fact that <code>try</code> is an expression in Kotlin. So, we can return a result immediately from it.</p>&#13;
			<p>If the coroutine manages to return before the timeout, the value of <code>result</code> becomes <code>profile</code>. Otherwise, we receive <code>TimeoutCancellationException</code> and set the value of <code>result</code> to <code>no profile</code>. </p>&#13;
			<p>A combination of timeouts and <code>try</code>-<code>catch</code> expressions is a really powerful tool that allows us to create robust interactions.</p>&#13;
			<h2 id="_idParaDest-168"><a id="_idTextAnchor174"/>Dispatchers</h2>&#13;
			<p>When we ran our<a id="_idIndexMarker496"/> coroutines using the <code>runBlocking</code> function, their code was executed on the main thread. </p>&#13;
			<p>You can check this by running the following code:</p>&#13;
			<pre>runBlocking {</pre>&#13;
			<pre>    launch {</pre>&#13;
			<pre>        println(Thread.currentThread().name) // Prints </pre>&#13;
			<pre>          "main"</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>In contrast, when we run a coroutine using <code>GlobalScope</code>, it runs on something called <code>DefaultDispatcher</code>:</p>&#13;
			<pre>GlobalScope.launch {</pre>&#13;
			<pre>    println("GlobalScope.launch: </pre>&#13;
			<pre>      ${Thread.currentThread().name}")</pre>&#13;
			<pre>}</pre>&#13;
			<p>This prints the following output:</p>&#13;
			<pre>&gt; DefaultDispatcher-worker-1</pre>&#13;
			<p><code>DefaultDispatcher</code> is a thread pool that is used for short-lived coroutines. </p>&#13;
			<p>Coroutine generators, such as <code>launch()</code> and <code>async()</code>, rely on default arguments, one of which is the dispatcher they will be launched on. To specify an alternative dispatcher, you can provide it as an argument to the coroutine builder:</p>&#13;
			<pre>runBlocking {</pre>&#13;
			<pre>    launch(Dispatchers.Default) {</pre>&#13;
			<pre>        println(Thread.currentThread().name)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The preceding code prints the following output:</p>&#13;
			<pre>&gt; DefaultDispatcher-worker-1</pre>&#13;
			<p>In addition to the <code>Main</code> and <code>Default</code> dispatchers, which we've already discussed, there is also an <code>IO</code> dispatcher, which is used for long-running tasks. You can use it similarly for other dispatchers by providing it to the coroutine builder, like so:</p>&#13;
			<pre>async(Dispatchers.IO) { </pre>&#13;
			<pre>    // Some long running task here</pre>&#13;
			<pre>}</pre>&#13;
			<h2 id="_idParaDest-169"><a id="_idTextAnchor175"/>Structured concurrency</h2>&#13;
			<p>It is a very common practice to spawn coroutines from inside another coroutine.</p>&#13;
			<p>The first rule of structured concurrency is that the parent coroutine should always wait for all its children to complete. This prevents resource leaks, which is very common in languages that don't have the <strong class="bold">structured concurrency</strong> concept.</p>&#13;
			<p>This means that if we look at the <a id="_idIndexMarker497"/>following code, which starts 10 child coroutines, the parent coroutine doesn't need to wait explicitly for all of them to complete:</p>&#13;
			<pre>val parent = launch(Dispatchers.Default) {</pre>&#13;
			<pre>    val children = List(10) { childId -&gt;</pre>&#13;
			<pre>        launch {</pre>&#13;
			<pre>            for (i in 1..1_000_000) {</pre>&#13;
			<pre>                UUID.randomUUID()</pre>&#13;
			<pre>                if (i % 100_000 == 0) {</pre>&#13;
			<pre>                    println("$childId - $i")</pre>&#13;
			<pre>                    yield()</pre>&#13;
			<pre>                }</pre>&#13;
			<pre>            }</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>} </pre>&#13;
			<p>Now, let's decide that one of the coroutines throws an exception after some time:</p>&#13;
			<pre>...</pre>&#13;
			<pre>if (i % 100_000 == 0) {</pre>&#13;
			<pre>    println("$childId - $i")</pre>&#13;
			<pre>    yield()</pre>&#13;
			<pre>}</pre>&#13;
			<pre><strong class="bold">if (childId == 8 &amp;&amp; i == 300_000) {</strong></pre>&#13;
			<pre><strong class="bold">    throw RuntimeException("Something bad happened")</strong></pre>&#13;
			<pre><strong class="bold">}</strong></pre>&#13;
			<pre>...</pre>&#13;
			<p>If you run this code, something interesting happens. Not only does the coroutine itself terminate, but also all its siblings are terminated as well.</p>&#13;
			<p>What happens here is that an uncaught<a id="_idIndexMarker498"/> exception bubbles up to the parent coroutine and cancels it. Then, the parent coroutine terminates all the other child coroutines to prevent any resource leaks. </p>&#13;
			<p>Usually, this is the desired behavior. If we'd like to prevent child exceptions from stopping the parent as well, we can use <code>supervisorScope</code>:</p>&#13;
			<pre>val parent = launch(Dispatchers.Default) {</pre>&#13;
			<pre>    <strong class="bold">supervisorScope</strong> {</pre>&#13;
			<pre>        val children = List(10) { childId -&gt;</pre>&#13;
			<pre>            ...</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>By using <code>supervisorScope</code>, even if one of the coroutines fails, the parent job won't be affected. </p>&#13;
			<p>The parent coroutine can still terminate all its children by using the <code>cancel()</code> function. Once we invoke <code>cancel()</code> on the parent job, all of its children are canceled too.</p>&#13;
			<p>Now that we've discussed the benefits of structured concurrency, let's reiterate one point from the start of this chapter: using <code>GlobalScope</code> and the fact that it's marked as a <code>GlobalScope</code> exposes functions such as <code>launch()</code> and <code>async()</code>, it doesn't benefit from structured concurrency principles and is prone to resource leaks when used incorrectly. For that reason, you should avoid using <code>GlobalScope</code> in real-world applications.</p>&#13;
			<h1 id="_idParaDest-170"><a id="_idTextAnchor176"/>Summary</h1>&#13;
			<p>In this chapter, we covered how to create threads and coroutines in Kotlin, as well as the benefits of coroutines over threads.</p>&#13;
			<p>Kotlin has simplified syntax for creating threads, compared to Java. But it still has the overhead of memory and, often, performance. Coroutines can solve these issues; use coroutines whenever you need to execute some code concurrently in Kotlin.</p>&#13;
			<p>At this point, you should know how to start a coroutine and how to wait for it to complete, getting its results in the process. We also covered how coroutines are structured and learned about how they interact with dispatchers.</p>&#13;
			<p>Finally, we touched upon the topic of structured concurrency, a modern idea that helps us prevent resource leaks in concurrent code easily.</p>&#13;
			<p>In the next chapter, we'll discuss how we can use these concurrency primitives to create scalable and robust systems that suit our needs.</p>&#13;
			<h1 id="_idParaDest-171"><a id="_idTextAnchor177"/>Questions</h1>&#13;
			<ol>&#13;
				<li>What are the different ways to start a coroutine in Kotlin?</li>&#13;
				<li>With structured concurrency, if one of the coroutines fails, all the siblings will be canceled as well. How can we prevent that behavior?</li>&#13;
				<li>What is the purpose of the <code>yield()</code> function?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>