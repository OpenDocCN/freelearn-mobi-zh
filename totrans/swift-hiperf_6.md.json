["```swift\nimport XCPlayground\nXCPSetExecutionShouldContinueIndefinitely()\n```", "```swift\nclass Handler: NSObject {\n  @objc class func run() {\n    print(\"run\")\n  }\n}\n\nNSThread.detachNewThreadSelector(\"run\", toTarget: Handler.self, withObject: nil)\n\nlet thread = NSThread(target: Handler.self, selector: \"run\", object: nil)\nthread.start()\n```", "```swift\nHandler.performSelectorInBackground(\"run\", withObject: nil)\n```", "```swift\nclass MyWorker: NSThread {\n\n  override func main() {\n    print(\"Do work here\")\n  }\n}\n\nlet worker = MyWorker()\nworker.start()\n```", "```swift\nlet bgQueue = dispatch_get_global_queue(QOS_CLASS_BACKGROUND,0)\ndispatch_async(bgQueue) {\n  print(\"run\")\n}\n```", "```swift\nlet mainQueue = dispatch_get_main_queue()\n```", "```swift\nfunc dispatch_get_global_queue(identifier: Int, flags: UInt) -> dispatch_queue_t!\n```", "```swift\nlet concurentQ = dispatch_queue_create(\"my-c\", DISPATCH_QUEUE_CONCURRENT)\nlet serialQ = dispatch_queue_create(\"my-s\", DISPATCH_QUEUE_SERIAL)\n```", "```swift\ntypealias dispatch_block_t = () -> Void\n\nlet tasks: dispatch_block_t = {\n  print(\"do Work\")\n}\n\nfunc doWork() {\n  print(\"do Work Function\")\n}\n```", "```swift\ndispatch_sync(queue: dispatch_queue_t, _ block: dispatch_block_t)\ndispatch_async(queue: dispatch_queue_t, _ block: dispatch_block_t)\n```", "```swift\ndispatch_sync(queue) { ... }\n```", "```swift\nlet queue = dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)\n\ndispatch_sync(queue) { print(\"Task 1\") }\nprint(\"1 Done\")\n\ndispatch_sync(queue) { print(\"Task 2\") }\nprint(\"2 Done\")\n```", "```swift\ndispatch_sync(queue) {\n  dispatch_sync(queue) {\n    print(\"Never called\") // Don't do this\n  }\n}\n```", "```swift\ndispatch_async(queue) { ... }\n```", "```swift\nlet queue = dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)\n\ndispatch_async(queue) {\n  sleep(2) // sleep for 2 seconds\n  print(\"Task 1\")\n}\nprint(\"1 Submitted\")\n\ndispatch_async(queue) { print(\"Task 2\") }\nprint(\"2 Submitted\")\n```", "```swift\n1 Submitted\n2 Submitted\nTask 2\nTask 1\n\n```", "```swift\nlet queue = NSOperationQueue()\nqueue.addOperationWithBlock {\n  print(\"Some task\")\n}\n\nNSOperationQueue.mainQueue().addOperationWithBlock {\n  print(\"Some task\")\n}\n```", "```swift\nclass SalesData {\n\n  var revenue: [Int]\n  var average: Int?\n\n  init (revenue: [Int]) {\n    self.revenue = revenue\n  }\n\n  func calculateAverage() {\n\n    let queue = GCD.backgroundQueue()\n    dispatch_async(queue) {\n\n      var sum = 0\n      for index in self.revenue.indices {\n      sum += self.revenue[index]\n      }\n\n      self.average = sum / self.revenue.count\n    }\n  }\n}\n```", "```swift\nstruct GCD {\n  static func backgroundQueue() -> dispatch_queue_t {\n    return dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)\n  }\n}\n```", "```swift\nlet sum = self.revenue.reduce(0, combine: +)\n```", "```swift\nlet data = SalesData(revenue: makeRandomArray(100))\ndata.calculateAverage()\ndata.average // nil\n```", "```swift\nfunc calculateAverage(result: () -> Void ) {\n  ...\n\n  self.average = sum / self.revenue.count\n  result()\n}\n```", "```swift\nlet data = SalesData(revenue: makeRandomArray(100))\ndata.calculateAverage {\n  print(data.average)\n}\n```", "```swift\ndispatch_async(GCD.mainQueue()) {\n  result()\n}\n```", "```swift\nfunc calculateAverage(result: (Int?) -> Void ) {\n  ...\n\n  self.average = sum / self.revenue.count\n\n  dispatch_async(GCD.mainQueue()) {\n    result(self.average)\n  }\n}\n\n// Use case\nlet data = SalesData(revenue: makeRandomArray(1000))\ndata.calculateAverage { average in\n  print(average)\n}\n```", "```swift\nlet data = SalesData(revenue: makeRandomArray(1000))\ndata.calculateAverage { average in\n  print(average)\n}\ndata.revenue.removeAll(keepCapacity: false)\n```", "```swift\nsum += self.revenue[index]\n```", "```swift\nlet revenue = self.revenue\ndispatch_async(queue) {\n  var sum = 0\n  for index in revenue.indices {\n    sum += revenue [index]\n  }\n\n  self.average = sum / revenue.count\n  ...\n}\n```", "```swift\ndispatch_async(queue) { [revenue] in\n  ...\n}\n```", "```swift\ndispatch_async(queue) { [numbers = revenue] in  ...\n```", "```swift\nclass SalesData {\n\n  let revenue: [Int]\n  ...\n}\n```", "```swift\n  data.revenue.removeAll(keepCapacity: false)\n```", "```swift\nfunc calculateAverage(result: (Int?) -> Void ) {\n\n  let queue = GCD.backgroundQueue()\n  dispatch_async(queue) {\n\n    var sum = 0\n    for index in self.revenue.indices {\n      sum += self.revenue[index]\n    }\n\n    self.average = sum / self.revenue.count\n    dispatch_async(GCD.mainQueue()) {\n      result(self.average)\n    }\n  }\n}\n```", "```swift\nfunc calculateAverage(result: (Int?) -> Void ) {\n\n  if let average = self.average {\n    result(average)\n  } else {\n\n    let queue = GCD.backgroundQueue()\n    dispatch_async(queue) {\n      ...\n    }\n  }\n}\n```", "```swift\nstruct SalesData {\n  ...\n  mutating func calculateAverage(result: (Int) -> Void ) {\n    ...\n  }\n}\n```", "```swift\nvar data = SalesData(revenue: makeRandomArray(1000))\ndata.calculateAverage { average in\n  print(average)\n}\n```", "```swift\nstruct SalesData {\n  let revenue: [Int]\n  var average: Int?\n\n  init (revenue: [Int]) {\n    self.revenue = revenue\n  }\n\n  mutating func calculateAverage(result: (Int?) -> Void ) {\n\n    if let average = self.average {\n      result(average)\n    } else {\n\n      let queue = GCD.backgroundQueue()\n      dispatch_async(queue) {\n        var sum = 0\n        for index in self.revenue.indices {\n          sum += self.revenue[index]\n        }\n\n        self.average = sum / self.revenue.count\n        dispatch_async(GCD.mainQueue()) {\n          result(self.average)\n        }\n      }\n    }\n  }\n}\n```", "```swift\nstruct SalesData {\n  let revenue: [Int]\n  var average: Int?\n}\n\nfunc calculateAverage(data: SalesData, result: (Int) -> Void ) {\n  ...\n}\n```", "```swift\nstruct SalesData {\n  let revenue: [Int]\n\n  var average: Int {\n    return revenue.reduce(0, combine: +) / revenue.count\n  }\n}\n```", "```swift\n  let data = SalesData(revenue: [145, 24, 3012])\n  data.average\n```", "```swift\nstruct AsyncOperation {\n\n  static func calculate(data: SalesData, result: (Int) -> Void ) {\n    GCD.asyncOnBackground {\n      let average = data.average\n      GCD.asyncOnMain {\n        result(average)\n      }\n    }\n  }\n}\n```", "```swift\nstruct GCD {\n  static func asyncOnBackground(block: () -> Void ) {\n    dispatch_async(self.backgroundQueue(), block)\n  }\n  static func asyncOnMain(block: () -> Void ) {\n    dispatch_async(self.mainQueue(), block)\n  }\n}\n```", "```swift\nstatic func calculateAverage(data: SalesData, result: (Int) -> Void ) {\n  runAsync(data.average, result: result)\n}\n\n//MARK: - Private\nprivate static func runAsync<T>(@autoclosure(escaping) work: () -> T, result: (T) -> Void ) {\n  GCD.asyncOnBackground {\n    let x = work()\n    GCD.asyncOnMain {\n      result(x)\n    }\n  }\n}\n```", "```swift\nlet data = SalesData(revenue: [145, 24, 3012])\nAsyncOperation.calculateAverage(data) { average in\n  print(average)\n}\n```", "```swift\nstruct SalesDataCache {\n  var revenueCache = [SalesData : Int]()\n\n  subscript (data: SalesData) -> Int? {\n    return revenueCache[data]\n  }\n\n  mutating func getAverage(data: SalesData, result: (Int) -> Void) {\n    if let average = self[data] {\n      result(average)\n    } else {\n      AsyncOperation.calculateAverage(data) { average in\n        self.revenueCache[data] = average\n        result(average)\n      }\n    }\n  }\n}\n```", "```swift\nvar hashValue: Int { get }\nfunc ==(lhs: Self, rhs: Self) -> Bool\n```", "```swift\nstruct SalesData {\n  let id: Int\n  revenue: [Int]\n}\n\n//MARK:- Hashable\nextension SalesData: Hashable {\n  var hashValue: Int {\n    return id.hashValue\n  }\n}\n\nfunc == (lhs: SalesData, rhs: SalesData) -> Bool {\n  return lhs.id == rhs.id\n}\n```", "```swift\nlet range = 0...10\nvar cache = SalesDataCache()\nlet salesData = range.map {\n  SalesData(id: $0, revenue: makeRandomArray(1000))\n}\n\nfor data in salesData {\n  cache.getAverage(data) { average in\n    print(average)\n  }\n}\n```", "```swift\nstruct SalesData {\n  let id: Int\n  let revenue: [Int]\n\n  var average: Int {\n    return revenue.reduce(0, combine: +) / revenue.count\n  }\n}\n\n//MARK:- Hashable\nextension SalesData: Hashable {\n  var hashValue: Int {\n    return id.hashValue\n  }\n}\n\nfunc == (lhs: SalesData, rhs: SalesData) -> Bool {\n  return lhs.id == rhs.id\n}\n\nstruct AsyncOperation {\n\n  static func calculateAverage(data: SalesData, result: (Int) -> Void) {\n    runAsync(data.average, result: result)\n  }\n\n  //MARK: - Private\n  private static func runAsync<T>(@autoclosure(escaping) work: () -> T, result: (T) -> Void ) {\n    GCD.asyncOnBackground {\n      let x = work()\n      GCD.asyncOnMain {\n        result(x)\n      }\n    }\n  } \n}\n\nstruct SalesDataCache {\n  private var revenueCache = [SalesData : Int]()\n\n  subscript (data: SalesData) -> Int? {\n    return revenueCache[data]\n  }\n\n  mutating func getAverage(data: SalesData, result: (Int) -> Void)  {\n    if let average = self[data] {\n      result(average)\n    } else {\n      AsyncOperation.calculateAverage(data) { average in\n        self.revenueCache[data] = average\n        result(average)\n      }\n    }\n  }\n}\n```", "```swift\nfunc aFunc(f: () -> Void )\nfunc increase(f: () -> Int ) -> Int\nfunc multiply(f: (Int, Int) -> Int ) -> Int\n```", "```swift\nfunc check(@autoclosure condition: () -> Bool)\nfunc increase(@autoclosure f: () -> Int ) -> Int\n```", "```swift\nlet x = 10\nlet res = increase( { x } )\ncheck( { x > 10 } )\n```", "```swift\nlet x = 10\nlet res = increase(x)\ncheck(x > 10)\n```", "```swift\nfunc increase(f: () -> Int ) -> Int {\n  return f() + 1\n}\n\nstruct Data {\n  var number: Int\n\n  mutating func increaseNumber() {\n    number = increase { number }\n  }\n}\n```", "```swift\nfunc increase(@noescape f: () -> Int ) -> Int {\n  return f() + 1\n}\n```"]