<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Writing Safer Code with Availability and Error Handling</h1></div></div></div><p>When I first started writing iOS and OS X applications with Objective-C, one of the most noticeable <em>deficiencies</em> was the lack of exception handling when working with the Cocoa and Cocoa Touch frameworks. Most modern programming languages such as Java and C# use <code class="literal">try-catch</code> blocks or something similar to handle exceptions. While Objective-C did have the <code class="literal">try-catch</code> block, it wasn't used within the Cocoa frameworks themselves and it never felt like a true part of the language. I do have significant experience with C, so I was able to understand how the Cocoa and Cocoa Touch frameworks received and responded to errors, and to be honest, I actually preferred this method, even though I had grown accustom to exception handling with Java and C#. When Swift was first introduced, I was hoping that Apple would put true error handling into the language, so we would have the option of using it; however, it was not in the initial release of Swift. Now with Swift 2, Apple has added error handling to Swift. While this error handling may look similar to exception handling in Java and C#, there are some very significant differences.</p><p>We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to use the <code class="literal">do-catch</code> block in Swift</li><li class="listitem" style="list-style-type: disc">How to represent errors</li><li class="listitem" style="list-style-type: disc">How to use the availability attribute</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Error handling prior to Swift 2.0</h1></div></div></div><p>Error handling<a class="indexterm" id="id366"/> is the process of responding to and recovering from error conditions within our applications. Prior to Swift 2.0, error reporting followed the same pattern as Objective-C; however, with Swift, we did have the added benefit of using optional return values, where returning a nil would indicate an error within the function.</p><p>In the simplest form of error handling, the return value from the function would indicate whether it was successful or not. This return value could be something as simple as a Boolean true/false value or something more complex such as an enum, whose values indicated what <a class="indexterm" id="id367"/>actually went wrong if the function was unsuccessful. If we needed to report additional information about the error that occurred, we could add an <code class="literal">NSError</code> out parameter of the <code class="literal">NSErrorPointer</code> type, but this wasn't the easiest of approaches and these errors tended to be ignored by developers. The following example illustrates how errors were generally handled prior to Swift 2.0:</p><div><pre class="programlisting">var str = "Hello World"
var error: NSError

var results = str.writeToFile(path, atomically: true, encoding: NSUTF8StringEncoding, error: &amp;error)

if results {
  // successful code here
} else {
    println("Error writing filer:  \(error)")
}</pre></div><p>While handling errors in this manner works well and can be modified to suit most needs, it definitely is not the perfect solution. There are a couple of issues with this solution, with the biggest being that it is easy for developers to ignore both the value that is returned and the error itself. While most experienced developers will be very careful to check all the errors, sometimes, it is hard for novice developers to understand what and when to check, especially if the function does not contain an <code class="literal">NSError</code> parameter.</p><p>In addition to using <code class="literal">NSError</code>, we could also raise and catch exceptions using the <code class="literal">NSException</code> class; however, very few developers actually use this method. Even within the Cocoa and Cocoa Touch frameworks, this method of exception handling was rarely ever used.</p><p>While using the <code class="literal">NSError</code> class and return values to handle errors does work well, there were many people, including me, who were disappointed that Apple did not include additional error handling when Swift was originally released. Well, now with Swift 2.0, we do have native error handling.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Error handling in Swift 2</h1></div></div></div><p>Languages such<a class="indexterm" id="id368"/> as Java and C# generally refer to the error handling process as <em>exception handling</em>; within the Swift documentation, Apple refers to this process as <em>error handling</em>. While on the outside, the Java and C# exception handling may look very similar to Swift's error handling, there are some significant differences that those familiar with exception handling in the other language will notice throughout this<a class="indexterm" id="id369"/> chapter.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Representing errors</h2></div></div></div><p>Before <a class="indexterm" id="id370"/>we can really understand how error handling works in Swift, we must first see how we would represent an error. In Swift, errors are represented by values of types that conform to the <code class="literal">ErrorType</code> protocol. Swift's enums are very well-suited to modeling the error conditions because generally, we have a finite number of error conditions to represent.</p><p>Let's look at how we would use an enum to represent an error. For this, we will define a fictitious error named <code class="literal">MyError</code> with three error conditions: <code class="literal">Minor</code>, <code class="literal">Bad</code>, and <code class="literal">Terrible</code>:</p><div><pre class="programlisting">enum MyError: ErrorType {
    case Minor
    case Bad
    case Terrible
}</pre></div><p>In this example, we define that the <code class="literal">MyError</code> enum conforms to the <code class="literal">ErrorType</code> protocol. We then define the three error conditions: <code class="literal">Minor</code>, <code class="literal">Bad</code>, and <code class="literal">Terrible</code>. We can also use the associated values with our error conditions. Let's say that we wanted to add a description to one of the error conditions; we would do it like this:</p><div><pre class="programlisting">enum MyError: ErrorType {
    case Minor
    case Bad
    case Terrible (description: String)
}</pre></div><p>Those who are familiar with exception handling in Java and C# can see that representing errors in Swift is a lot cleaner and easier. Another advantage that we have is it is very easy to define multiple error conditions and group them together, so all the related error conditions are of one type.</p><p>Now let's see how we would model errors in Swift. For this example, let's look at how we would assign numbers to players in a baseball team. In a baseball team, every new player who is called up is assigned a unique number for that team. This number also must be within a certain range of numbers. In this case, we would have three error conditions: number is too large, number is too small, or number is not unique. The following example shows how we might represent these error conditions:</p><div><pre class="programlisting">enum PlayerNumberError: ErrorType {
    case NumberTooHigh(description: String)
    case NumberTooLow(description: String)
    case NumberAlreadyAssigned
}</pre></div><p>With <a class="indexterm" id="id371"/>the <code class="literal">PlayerNumberError</code> type, we define three very specific error conditions that tell us exactly what was wrong. These error conditions are also grouped together in one type since they are all related to assigning player's numbers.</p><p>This method of defining errors allows us to define very specific errors that let our code know exactly what went wrong if an error condition occurs and, as we see in our example, it also lets us group our errors, so all of the related errors can be defined in the same type.</p><p>Now that we know how to represent errors, let's look at how we would throw errors.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec110"/>Throwing errors</h2></div></div></div><p>When <a class="indexterm" id="id372"/>an error occurs in a function, the code that called the function must be made aware of it; this is called <strong>throwing the error</strong>. When a function throws an error, it assumes that the code that called the function, or some code further up the chain, will catch and recover appropriately from the error.</p><p>To throw an error from a function we use the <code class="literal">throws</code> keyword. This keyword lets the code that called it know that an error may be thrown from the function. Unlike exception handling in other languages, we do not list the specific errors types that may be thrown.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Since we do not list the specific error types that may be thrown from a function within the function's definition, it would be good practice to list them in the documentation and comment for the function so that other developers who use our function know what error types to catch.</p></div></div><p>Let's look at how we would throw errors, but first, let's add a fourth error to our <code class="literal">PlayerNumberError</code> type that we defined earlier. This error condition is thrown if we are trying to retrieve a player by his or her number but no player is assigned that number. The new <code class="literal">PlayerNumberError</code> type will now look similar to this:</p><div><pre class="programlisting">enum PlayerNumberError: ErrorType {
    case NumberTooHigh(description: String)
    case NumberTooLow(description: String)
    case NumberAlreadyAssigned
    case NumberDoesNotExist
}</pre></div><p>To demonstrate how to throw errors, we will begin by creating a <code class="literal">BaseballTeam</code> struct that will contain a list of player for a given team. These players will be stored in a dictionary object named <code class="literal">players</code> and will use the player's number as the key. The <code class="literal">BaseballPlayer</code> type, which will be used to represent a single player, will be a <code class="literal">typealias</code> for a tuple type and is defined like this:</p><div><pre class="programlisting">typealias BaseballPlayer = (firstName: String, lastName: String, number: Int)</pre></div><p>In this <code class="literal">BaseballTeam</code> struct, we <a class="indexterm" id="id373"/>will have two methods. The first one will be named <code class="literal">addPlayer()</code>. This will have one parameter of the <code class="literal">BaseballPlayer</code> type and will attempt to add the player to the team. This method could throw one of the three error conditions: <code class="literal">NumberTooHigh</code>, <code class="literal">NumberTooLow</code>, or <code class="literal">NumberAlreadyExists</code>. Here is how we would write this method:</p><div><pre class="programlisting">    mutating func addPlayer(player: BaseballPlayer) throws {

        guard player.number &lt; maxNumber else {
            throw PlayerNumberError.NumberTooHigh(description: "Max number is \(maxNumber)")
        }

        guard player.number &gt; minNumber else {
            throw PlayerNumberError.NumberTooLow(description: "Min number is \(minNumber)")
        }

        guard players[player.number] == nil else {
            throw PlayerNumberError.NumberAlreadyAssigned
        }
        players[player.number] = player
    }</pre></div><p>In the method's definition, we see that the <code class="literal">throws</code> keyword is added. The <code class="literal">throws</code> keyword lets any code that calls this method know that it may throw an error and the errors must be handled. We then use the three <code class="literal">guard</code> statements. These <code class="literal">guard</code> statements are used to verify that the number is not too large, not too small, and is unique in the <code class="literal">players</code> dictionary. If any of the conditions are not met, we throw the appropriate error using the <code class="literal">throw</code> keyword.</p><p>If we make it through all the three checks, the player is added to the <code class="literal">players</code> dictionary.</p><p>The second method that we will be adding to the <code class="literal">BaseballTeam</code> struct is the <code class="literal">getPlayerByNumber()</code> method. This method will attempt to retrieve the baseball player that is assigned a given number. If no player is assigned that number, this method will throw a <code class="literal">PlayerNumberError.NumberDoesNotExist</code> error. The <code class="literal">getPlayerByNumber()</code> method will look similar to this:</p><div><pre class="programlisting">func getPlayerByNumber(number: Int) throws -&gt; BaseballPlayer {
    if let player = players[number] {
        return player
    } else {
        throw PlayerNumberError.NumberDoesNotExist
    }
}</pre></div><p>In this <a class="indexterm" id="id374"/>method definition, we see that it can throw an error because we use the <code class="literal">throws</code> keyword within the definition. The <code class="literal">throws</code> keyword must be placed before the <code class="literal">return</code> type in the method definition.</p><p>Within the method, we attempt to retrieve the baseball player with the number that is passed into the method. If we are able to retrieve the player, we return it; otherwise, we throw the <code class="literal">PlayerNumberError.NumberDoesNotExist</code> error. Notice that if we throw an error from a method that has a <code class="literal">return</code> type, we do not need to return a value.</p><p>Now let's see how we would catch an error with Swift.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Catching errors</h2></div></div></div><p>When an <a class="indexterm" id="id375"/>error is thrown from a function, we need to catch it in the code that called the function; this is done using the <code class="literal">do-catch</code> block. The <code class="literal">do-catch</code> block takes the following syntax:</p><div><pre class="programlisting">do {
    try [Some function that throws]
    [Any additional code]
} catch [pattern] {
    [Code if function threw error]
}</pre></div><p>If an error is thrown, it is propagated out until it is handled by a <code class="literal">catch</code> clause. The <code class="literal">catch</code> clause consists of the <code class="literal">catch</code> keyword, followed by a pattern to match the error against. If the error matches the pattern, the code within the <code class="literal">catch</code> block is executed.</p><p>Let's look at how we would use the <code class="literal">do-catch</code> block by calling both the <code class="literal">getPlayerByNumber()</code> and <code class="literal">addPlayer()</code> methods of the <code class="literal">BaseballTeam</code> struct. Let's look at the <code class="literal">getPlayerByNumber()</code> method first since it only throws one error condition:</p><div><pre class="programlisting">do {
    let player = try myTeam.getPlayerByNumber(34)
    print("Player is \(player.firstName) \(player.lastName)")
} catch PlayerNumberError.NumberDoesNotExist {
    print("No player has that number")
}</pre></div><p>Within this <a class="indexterm" id="id376"/>example, the <code class="literal">do-catch</code> block calls the <code class="literal">getPlayerByNumber()</code> method of the <code class="literal">BaseballTeam</code> struct. This method will throw the <code class="literal">PlayerNumberError.NumberDoesNotExist</code> error condition if no player on the team has been assigned this number; therefore, we attempt to match that error in our <code class="literal">catch</code> statement.</p><p>Anytime an error is thrown within a <code class="literal">do-catch</code> block, the remainder of the code within the block is skipped and the code within the <code class="literal">catch</code> block, which matches the error, is executed. Therefore, in our example, if the <code class="literal">PlayerNumberError.NumberDoesNotExist</code> error is thrown by the <code class="literal">getPlayerByNumber()</code> method, then the <code class="literal">print()</code> function is never reached.</p><p>We do not have to include a pattern after the <code class="literal">catch</code> statement. If a pattern is not included after the <code class="literal">catch</code> statement or we put an underscore, the <code class="literal">catch</code> statement will match all error conditions. For example, either one of the following two <code class="literal">catch</code> statements will catch all errors:</p><div><pre class="programlisting">do {
    // our statements
} catch {
    // our error conditions
}

do {
    // our statements
} catch _ {
    // our error conditions
}</pre></div><p>If we want to capture the error, we can use the <code class="literal">let</code> keyword, as shown in the following example:</p><div><pre class="programlisting">do {
    // our statements
} catch let error {
    print("Error:  \(error)")
}</pre></div><p>Now let's look at how we could use the <code class="literal">catch</code> statement, similar to a <code class="literal">switch</code> statement, to catch different error conditions. For this, we will call the <code class="literal">addPlayer()</code> method of our <code class="literal">BaseballTeam</code> struct:</p><div><pre class="programlisting">do {
    try myTeam.addPlayer(("David", "Ortiz", 34))
} catch PlayerNumberError.NumberTooHigh(let description) {
    print("Error: \(description)")
} catch PlayerNumberError.NumberTooLow(let description) {
    print("Error: \(description)")
} catch PlayerNumberError.NumberAlreadyAssigned {
    print("Error: Number already assigned")
}</pre></div><p>In this example, we <a class="indexterm" id="id377"/>have three <code class="literal">catch</code> statements. Each <code class="literal">catch</code> statement has a different pattern to match; therefore, they will each match a different error condition. If we recall, the <code class="literal">PlayerNumberError.NumberToHigh</code> and <code class="literal">PlayerNumberError.NumberToLow</code> error conditions have associated values. To retrieve the associated value, we use the <code class="literal">let</code> statement within the parentheses, as shown in the example.</p><p>It is always good practice to make your last <code class="literal">catch</code> statement an empty <code class="literal">catch</code> so that it will <code class="literal">catch</code> any error that did not match any of the patterns in the previous <code class="literal">catch</code> statements. Therefore, the previous example should be rewritten like this:</p><div><pre class="programlisting">do {
    try myTeam.addPlayer(("David", "Ortiz", 34))
} catch PlayerNumberError.NumberTooHigh(let description) {
    print("Error: \(description)")
} catch PlayerNumberError.NumberTooLow(let description) {
    print("Error: \(description)")
} catch PlayerNumberError.NumberAlreadyAssigned {
    print("Error: Number already assigned")
} catch {
    print("Error: Unknown Error")
}</pre></div><p>We can also let the errors propagate out rather than immediately catch them. To do this, we just need to add the <code class="literal">throws</code> keyword to the function definition. For instance, in the following example, rather than catching the error, we let it propagate out to the code that calls the function rather than handling the error within the function:</p><div><pre class="programlisting">func myFunc() throws {
    try myTeam.addPlayer(("David", "Ortiz", 34))
}</pre></div><p>If we are certain that an error will not be thrown, we can call the function using a forced-try expression, which is written as <code class="literal">try</code>!. The forced-try expression disables error propagation and wraps the function call in a runtime assertion that no error will be thrown from this call. If an error is thrown, we will get a runtime error, so be very careful when using this expression.</p><p>When I am <a class="indexterm" id="id378"/>working with exceptions in languages such as Java and C#, I see a lot of empty <code class="literal">catch</code> blocks. This is where we need to catch the exception because one might be thrown; however, we do not want to do anything with it. In Swift, the code would look something like this:</p><div><pre class="programlisting">do {
    let player = try myTeam.getPlayerByNumber(34)
    print("Player is \(player.firstName) \(player.lastName)")
} catch {}</pre></div><p>Seeing code like this is one of the things that I dislike about exception handling. Well, the Swift developers have an answer for this: the <code class="literal">try?</code> keyword. The <code class="literal">try?</code> keyword attempts to perform an operation that may throw an error. If the operation succeeds, the results are returned in the form of an optional; however, if the operation fails with an error being thrown, the operation returns a nil and the error is discarded.</p><p>Since the results of the <code class="literal">try?</code> keyword are returned in the form of an optional, we would normally want to use this keyword with optional binding. We could rewrite the previous example like this:</p><div><pre class="programlisting">if let player = try? myTeam.getPlayerByNumber(34) {
    print("Player is \(player.firstName) \(player.lastName)")
}</pre></div><p>As we can see, the <code class="literal">try?</code> keyword makes our code much cleaner and easier to read.</p><p>If we need to perform some clean up action, regardless of if we had any errors or not, we can use the <code class="literal">defer</code> statement. We use the <code class="literal">defer</code> statement to execute a block of code just before code execution leaves the current scope. The following example shows how we would use the <code class="literal">defer</code> statement:</p><div><pre class="programlisting">func deferFunction()  {
    print("Function started")
    var str: String?
    
    defer {
    print("In defer block")
        if let s = str {
            print("str is \(s)")
        }
    }
    
    str = "Jon"
    print("Function finished")
}</pre></div><p>If we called this<a class="indexterm" id="id379"/> function, the first line that is printed to the console is—<code class="literal">Function started</code>. The execution of the code would skip over the <code class="literal">defer</code> block and <code class="literal">Function finished</code> would be printed to the console next. Finally, the <code class="literal">defer</code> block of code would be executed just before we leave the function's scope, and we would see the message, <code class="literal">In defer block</code>. The following is the output from this function:</p><div><pre class="programlisting">Function started
Function finished
In defer block
str is Jon</pre></div><p>The <code class="literal">defer</code> block will always be called before execution leaves the current scope, even if an error is thrown. The <code class="literal">defer</code> block is very useful when we need to perform some clean up functions prior to leaving a function.</p><p>The <code class="literal">defer</code> statement is very useful when we want to make sure we perform all the necessary clean up, even if an error is thrown. For example, if we successfully open up a file to write to, we will always want to make sure we close that file, even if we have an error during the write operation. We could then put the file closed functionality in a <code class="literal">defer</code> block to make sure that the file is always closed prior to leaving the current scope.</p><p>Now let's look at how we would use the new availability attribute with Swift.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>The availability attribute</h1></div></div></div><p>Using the<a class="indexterm" id="id380"/> latest SDK gives us access to all of the latest features for the platform that we are developing for; however, there are times when we want to also target older platforms. Swift allows us to use the availability attribute to safely wrap code to run only when the correct version of the operating system is available. The availability was first introduced in Swift 2.</p><p>The availability blocks essentially lets us say, "If we are running the specified version of the operating system or higher, run this code. Otherwise, run some other code." There are two ways in which we can use the <code class="literal">availability</code> attribute. The first way allows us to execute a specific block of code and can be used with an <code class="literal">if</code> or <code class="literal">guard</code> statement. The second way allows us to mark a method or type as available only on certain platforms.</p><p>The <code class="literal">availability</code> attribute accepts up to five comma-separated arguments that allow us to define the minimum version of the operating system or application extension needed to execute our code. These <a class="indexterm" id="id381"/>arguments are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">iOS</code>: This is the minimum iOS version that is compatible with our code</li><li class="listitem" style="list-style-type: disc"><code class="literal">OSX</code>: This is the minimum OS X version that is compatible with our code</li><li class="listitem" style="list-style-type: disc"><code class="literal">watchOS</code>: This is<a class="indexterm" id="id382"/> the minimum watchOS version that is compatible with our code</li><li class="listitem" style="list-style-type: disc"><code class="literal">iOSApplicationExtension</code>: This is the minimum iOS application extension that is compatible with our code</li><li class="listitem" style="list-style-type: disc"><code class="literal">OSXApplicationExtension</code>: This is the minimum OS X application extension that is compatible with our code</li></ul></div><p>After the <a class="indexterm" id="id383"/>argument, we specify the minimum version that is required. We only need to include the arguments that are compatible with our code. As an example, if we are writing an iOS application, we only need to include the <code class="literal">iOS</code> argument in the <code class="literal">available</code> attribute. We end the argument list with an <code class="literal">*</code> (asterisk). Let's look at how we would execute a specific block of code only if we meet the minimum requirements:</p><div><pre class="programlisting">if #available(iOS 9.0, OSX 10.10, watchOS 2, *) {
     // Available for iOS 9, OSX 10.10, watchOS 2 or above
    print("Minimum requirements met")
} else {
    //  Block on anything below the above minimum requirements
    print("Minimum requirements not met")
}</pre></div><p>In this example, the <code class="literal">if #available(iOS 9.0, OSX 10.10, watchOS 2, *)</code> line of code prevents the block of code form executing when the application is run on a system that does not meet the specified minimum operating system version. In this example, we also use the <code class="literal">else</code> statement to execute a separate block of code if the operating system did not meet the minimum requirements.</p><p>We can also restrict access to a function or a type. In the previous code, the <code class="literal">available</code> attribute was prefixed with the <code class="literal">#</code> (pound) character. To restrict access to a function or type, we prefix the available attribute with an <code class="literal">@</code> (at) character. The following example shows how we would restrict access to a type and function:</p><div><pre class="programlisting">@available(iOS 9.0, *)
func testAvailability() {
    // Function only available for iOS 9 or above
}

@available(iOS 9.0, *)
struct TestStruct {
  // Type only available for iOS 9 or above
}</pre></div><p>In the previous example, we specify that the <code class="literal">testAvailability()</code> function and the <code class="literal">testStruct()</code> type can only be accessed if the code is run on a device that has iOS version 9 or above. In order to use the <code class="literal">@available</code> attribute to block access to a function or type, we must <a class="indexterm" id="id384"/>wrap the code that calls that function or type with the <code class="literal">#available</code> attribute. The following example shows how we would call the <code class="literal">testAvailability()</code> function:</p><div><pre class="programlisting">if #available(iOS 9.0, *) {
    testAvailability()
} else {
     // Fallback on earlier versions
}</pre></div><p>In this example, the <code class="literal">testAvailability()</code> function is only called if the application is running on a device that has iOS version 9 or above.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we looked at the new error-handling features and <code class="literal">availability</code> attribute that were added in Swift 2. These two features can help us write safer code and make our applications more stable.</p><p>The error-handling feature of Swift 2 significantly changes the way Swift programmers handle errors. While we are not required to use this new feature in our custom types, it does give us a uniform manner to handle and respond to error. Apple has also started to use this error handling in the Cocoa and Cocoa Touch frameworks.</p><p>The new <code class="literal">availability</code> attribute allows us to develop applications that take advantage of the latest features of our target operating systems while still allowing our applications to run on older versions.</p><p>In the next chapter, we will look at how to create and parse XML and JSON documents.</p></div></body></html>