["```java\n#version 300 es\nprecision mediump float;\n\nin vec2             TexCoord;      // Texture coordinates\nuniform sampler2D   Tex1;          // FBO texture\nuniform float       ScreenCoordX;  // X Screen Coordinate\nuniform vec2        FBS;          // Frame Buffer Size\nlayout(location = 0) out vec4   outColor;\n\n// Calculates the luminosity of a sample.\nfloat FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x;}\n\nvoid main() {\n        float FXAA_SPAN_MAX     = 8.0;\n    float FXAA_REDUCE_MUL   = 1.0/8.0;\n    float FXAA_REDUCE_MIN   = 1.0/128.0;\n\n    // Sample 4 texels including the middle one.\n    // Since the texture is in UV coordinate system, the Y is\n    // therefore, North direction is â€“ve and south is +ve.\n    vec3 rgbNW = texture(Tex1,TexCoord+(vec2(-1.,-1.)/FBS)).xyz;\n    vec3 rgbNE = texture(Tex1,TexCoord+(vec2(1.,-1.)/FBS)).xyz;\n    vec3 rgbSW = texture(Tex1,TexCoord+(vec2(-1.,1.)/FBS)).xyz;\n    vec3 rgbSE = texture(Tex1,TexCoord+(vec2(1.,1.)/FBS)).xyz;\n    vec3 rgbM  = texture(Tex1,TexCoord).xyz;\n\n    float lumaNW = FxaaLuma(rgbNW);   // Top-Left\n    float lumaNE = FxaaLuma(rgbNE);   // Top-Right\n    float lumaSW = FxaaLuma(rgbSW);   // Bottom-Left\n    float lumaSE = FxaaLuma(rgbSE);   // Bottom-Right\n    float lumaM  = FxaaLuma(rgbM);    // Middle\n\n      // Get the edge direction, since the y components are inverted\n      // be careful to invert the resultant x\n       vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n      // Now, we know which direction to blur, \n      // But far we need to blur in the direction? \n      float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * \n      (0.25 * FXAA_REDUCE_MUL),FXAA_REDUCE_MIN);\n      float rcpDirMin = 1.0/(min(abs(dir.x),abs(dir.y))+dirReduce);\n\n      dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), max(vec2(-\n      FXAA_SPAN_MAX,-FXAA_SPAN_MAX), dir*rcpDirMin))/FBS;\n\n      vec3 rgbA = (1.0/2.0)*(texture(Tex1, TexCoord.xy + dir *\n      (1.0/3.0 - 0.5)).xyz + texture(Tex1, TexCoord.xy \n      + dir * (2.0/3.0 - 0.5)).xyz);\n      vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (texture(Tex1, \n      TexCoord.xy + dir * (0.0/3.0 - 0.5)).xyz + texture\n      (Tex1, TexCoord.xy + dir * (3.0/3.0 - 0.5)).xyz);\n\n      float lumaB    = FxaaLuma(rgbB);\n      float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE),\n      min(lumaSW, lumaSE)));\n      float lumaMax    = max(lumaM, max(max(lumaNW, lumaNE), \n      max(lumaSW, lumaSE)));\n\n      if((lumaB < lumaMin) || (lumaB > lumaMax)){\n        outColor = vec4(rgbA, 1.0);\n      }else{\n        outColor = vec4(rgbB, 1.0);\n      }\n}\n```", "```java\nvec3 rgbNW = texture(Tex1,TexCoord+(vec2(-1.,-1.)/FBS)).xyz;\nvec3 rgbNE = texture(Tex1,TexCoord+(vec2( 1.,-1.)/FBS)).xyz;\nvec3 rgbSW = texture(Tex1,TexCoord+(vec2(-1., 1.)/FBS)).xyz;\nvec3 rgbSE = texture(Tex1,TexCoord+(vec2( 1., 1.)/FBS)).xyz;\nvec3 rgbM  = texture(Tex1,TexCoord).xyz;\n```", "```java\n   float lumaNW = FxaaLuma(rgbNW);    // Top-Left\n   float lumaNE = FxaaLuma(rgbNE);     // Top-Right\n   float lumaSW = FxaaLuma(rgbSW);     // Bottom-Left\n   float lumaSE = FxaaLuma(rgbSE);     // Bottom-Right\n   float lumaM  = FxaaLuma(rgbM);      // Middle\n```", "```java\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE)); //Inverted\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n```", "```java\nfloat rcpDirMin = 1.0/(min(abs(dir.x),abs(dir.y))+dirReduce);\n```", "```java\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * \n                     (0.25 * FXAA_REDUCE_MUL),FXAA_REDUCE_MIN);\n```", "```java\ndir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), max(vec2(-\n              FXAA_SPAN_MAX,-FXAA_SPAN_MAX), dir*rcpDirMin))/FBS;\n```", "```java\nvec3 rgbA = (1.0/2.0)*(texture(Tex1, TexCoord.xy + dir *\n            (1.0/3.0 - 0.5)).xyz + texture(Tex1, TexCoord.xy \n             + dir * (2.0/3.0 - 0.5)).xyz);\n```", "```java\n   vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (texture(Tex1, \n   TexCoord.xy + dir * (0.0/3.0 - 0.5)).xyz + texture\n   (Tex1, TexCoord.xy + dir * (3.0/3.0 - 0.5)).xyz);\n```", "```java\n   float lumaB     = FxaaLuma(rgbB);\n   float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE),\n   min(lumaSW, lumaSE)));\n   float lumaMax    = max(lumaM, max(max(lumaNW, lumaNE), \n   max(lumaSW, lumaSE)));\n```", "```java\nif((lumaB < lumaMin) || (lumaB > lumaMax)){\n       outColor = vec4(rgbA, 1.0);\n   }else{\n       outColor = vec4(rgbB, 1.0);\n}\n```", "```java\n#version 300 es\nprecision mediump float;\n\n// Reuse Phong shading light and material properties.\nuniform float  Time;\n\n// Flag to enable and disable Adaptive anti-aliasing\nuniform int     EnableAdaptiveAA;\n\nlayout(location = 0) out vec4 FinalColor;\n\nvec3 PhongShading{\n   // Reuse Phong shading code.\n}\n\nin float objectY;\nfloat Frequency = 6.0; // Controls number of stripes\n\n// Reference: OpenGL Shading Language by Randi J Rost\nvoid main() {\n    if(gl_FragCoord.x < ScreenCoordX+1.0 \n             && gl_FragCoord.x > ScreenCoordX-1.0){\n        FinalColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    float offset    = Time;\n\n    // GENERATE fractional value 0.0, 0.1, ........, 0.9\n    float sawtooth  = fract((objectY+offset) * Frequency);\n\n    // Produce values in the range between [-1, 1]\n    float triangle  = 2.0 * sawtooth - 1.0;\n\n    // Produce continuous range from [ 1.0 ... 0.0 ... 1.0 ]\n    triangle        = abs(triangle);\n    float dp        = length(vec2 (dFdx(objectY+offset),\n                                          dFdy(objectY+offset)));\n    float edge      = dp * Frequency * 4.0;\n    float square    = 0.0;\n\n    // Show the difference between aliased and anti-aliased.\n    if (gl_FragCoord.x < ScreenCoordX){\n        square      = step(0.5, triangle);\n    }\n    else{\n        square      = smoothstep(0.5-edge, 0.5 + edge, triangle);\n    }\n\n    FinalColor = vec4 (vec3 (square)*PhongShading(), 1.0);\n}\n```", "```java\n       glm::vec2 texCoords[4] = {\n           vec2(0.0f, 0.0f),vec2(0.0f, 1.0f),\n            vec2(1.0f, 0.0f), vec2(1.0f, 1.0f)\n        };\n        memcpy(texCoordinates, texCoords, sizeof(glm::vec2)*4);\n\n        glm::vec3 tempVtx[4] = {\n            vec3( -0.5f, -0.5f, 0.0f), vec3( -0.5f,  0.5f, 0.0f),\n            vec3(  0.5f, -0.5f, 0.0f), vec3(  0.5f,  0.5f, 0.0f)\n        };\n        memcpy(vertices, tempVtx, sizeof(glm::vec3)*4);\n    ```", "```java\n    #version 300 es\n\n    // Vertex information\n    layout(location = 0) in vec3  VertexPosition;\n    layout(location = 1) in vec2  VertexTexCoord;\n\n    out vec2 TexCoord;\n\n    uniform mat4 ModelViewProjectMatrix;\n\n    void main( void ) {\n        TexCoord = VertexTexCoord;\n        gl_Position = ModelViewProjectMatrix *\n                       vec4(VertexPosition,1.0);\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    // Texture coordinates\n    in vec2 TexCoord;\n\n    uniform vec3        PaintColor;     // circle color\n    uniform float       InnerRadius;    // inside radius\n    uniform float       OuterRadius;    // outside radius\n    layout(location = 0) out vec4   outColor;\n\n    void main() {\n       float weight = 0.0f;\n        // Displace the texture coordinate wrt \n        // hypothetical centered origin\n        float dx     = TexCoord.x - 0.5;\n        float dy     = TexCoord.y - 0.5;\n\n        // Calculate the distance of this transformed \n        // texture coordinate from Origin.\n        float length = sqrt(dx * dx + dy * dy);\n\n        // Calculate the weights\n        weight = smoothstep(InnerRadius, OuterRadius, length );\n\n        outColor = mix( vec4(PaintColor, 1.0), \n                       vec4(PaintColor, 0.0), weight);\n    }\n    ```", "```java\n    Renderer*       graphicsEngine; // Graphics Engine\n    Scene*          scene;          // Scene object\n    Circle*         circle;\n    Camera* camera;\n    bool GraphicsInit(){\n        // Create rendering engine\n        graphicsEngine  = new Renderer();\n\n        // Create the scene\n        scene = new Scene(\"MeshScene\", graphicsEngine);\n\n        // Create camera and added to the scene\n        camera = new Camera(\"Camera1\", scene);\n        camera->SetClearBitFieldMask(GL_COLOR_BUFFER_BIT | \n                                     GL_DEPTH_BUFFER_BIT);\n        camera->SetPosition(glm::vec3 (0.00000, 0.0, 2.00000));\n        camera->SetTarget(glm::vec3 (0.0, 0.0,0.0));\n\n        // Create a new circle shape object    \n        circle = new Circle(scene, NULL, None);\n        circle->SetName(std::string(\"My Circle\"));\n\n        scene->addModel(circle);\n        graphicsEngine->initializeScenes();\n        return true;\n    }\n\n    bool GraphicsResize( int width, int height ){\n        // Create the view port\n        camera->Viewport(0, 0, width, height);\n        graphicsEngine->resize(width, height);\n        return true;\n    }\n\n    bool GraphicsRender(){\n        // Rotate the circle\n        circle->Rotate(1.0, 1.0, 1.0, 1.0);\n        graphicsEngine->render();\n        return true;\n    }\n    ```", "```java\n float dx = TexCoord.x - 0.5;\n float dy = TexCoord.y - 0.5;\n```", "```java\nweight    = smoothstep( innerRadius, outerRadius, length );\noutColor  = mix( vec4(paintColor, 1.0), \n            vec4(paintColor, 0.0), weight);\n```"]