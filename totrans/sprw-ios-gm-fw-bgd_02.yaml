- en: Chapter 2. Displaying Our First Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we installed and configured Xcode developer tools
    and also as downloaded the Sparrow framework and linked it to a sample project.
    We proceeded to test it in both the iOS Simulator and a real device. We also set
    the scope for the game we are going to develop throughout the book. However, before
    we get into the game development process, let''s touch on some core concepts of
    Sparrow and get accustomed with the way things work in Sparrow. We will draw some
    objects on the screen and manipulate these objects by applying rotation and scaling
    transforms.*'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding display objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, a display object is something that will be displayed on
    the screen. We can think of display objects as separate graphical entities that
    contain different kinds of graphical data. While this may sound a bit abstract
    at first, every image (`SPImage`), quads (`SPQuad`), or other geometrical shapes
    are derived from the `SPDisplayObject` class, which is the representation of a
    display object in Sparrow.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining display object containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A display object container (`SPDisplayObjectContainer`) inherits from `SPDisplayObject`,
    adding the facility to own a set of child display objects. When you add a child
    display object to a parent display object container, you can think of it as attaching
    one display object to another. If you move, scale, or rotate the parent display
    object, all the changes are inherited by any children it might have. This concept
    is more or less identical to how objects on the screen are managed in the Adobe
    Flash API. The full set of parent and child nodes is referred to as the display
    list, or sometimes as a display tree. This is because, like a tree, it contains
    many branches that all ultimately converge into one single trunk, often referred
    to as the root. Yet another name for a display tree is a scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: The display list draws the display objects in the order they are added to their
    parent display object container. If we were to add a second child display object
    to the same parent as that of the previously added display object, the second
    display object will be drawn in front of the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and imagine ourselves as a cardboard puppet doll. We need a
    head, a torso and a leg, arm, and hand on the left side and the same goes for
    the right side. Refer to the following diagram that displays this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining display object containers](img/1509OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The root object for this arrangement would be the body object. The head, torso,
    legs, and arms would be directly bound to the body and the hands would be bound
    to each arm.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the background color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we draw a couple of objects on the screen, let's change the background
    color of our application that will eventually become our game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – changing the background color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the required steps to change the background color:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our Xcode game template if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Game.m` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the initialization method and before the existing `SPQuad` object, add
    the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the example is running, we see our red rectangle on a white background
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – changing the background color](img/1509OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened our Xcode template that we created in the previous chapter,
    and in step 2, we navigated to the `Game.m` file, which is where our game code
    currently lies. The game is the red rectangle that keeps showing up.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, right before we drew our red rectangle, we defined the `background`
    variable that is a pointer to an instance of `SPQuad`. The `SPQuad` class is derived
    from `SPDisplayObject`. The function of `SPQuad` is to draw a rectangular shape
    with a background color.
  prefs: []
  type: TYPE_NORMAL
- en: The `SPQuad` class provides a few factory methods for operations such as creating
    a quad with a width and height and also adds a color value to it. In this example,
    we are creating a quad with a predefined width and height and a color value of
    `0xffffff`. A color is defined as `0xRRGGBB` in a hexadecimal notation, that is,
    `REDRED` `GREENGREEN` `BLUEBLUE`.
  prefs: []
  type: TYPE_NORMAL
- en: While at the surface, the call to `[SPQuad quadWithWidth:Sparrow.stage.width
    height:Sparrow.stage.height]` seems to be the same as the one to `[[SPQuad alloc]
    initWithWidth:Sparrow.stage.width height:Sparrow.stage.height]`, but there is
    one major difference under the hood. When the factory method is called, it returns
    an auto-released object, which means we don't have an ownership over the instance
    and it's being destroyed at some point. On the other hand, if we use the alloc-and-init
    combination, we do have the ownership and the need to release the instance ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: As our application uses **Automatic Reference Counting** (**ARC**), we don't
    need to worry about releasing instances ourselves. On the other hand, Sparrow
    itself uses **Manual Reference Counting** (**MRC**).
  prefs: []
  type: TYPE_NORMAL
- en: To cover the whole screen, we need to get the width and height of the screen
    itself. Those values are available as properties in the `Sparrow.stage` object.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add the background to the `Game` class, which is exactly what `[self
    addChild:background]` does. The `self` keyword is a reference to the `Game` class,
    which is derived from the `SPSprite` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a white background with a red rectangle that appears on top of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Game.m` source file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an easier way to set the background color. While the performance
    penalty in this specific case is not that high to worry about, we could directly
    set the color through `Sparrow.stage` by using its color property: `Sparrow.stage.color
    = 0xffffff`. It consists of fewer lines, is more readable, and shows its intention
    better.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a stage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly touched on the topic of `Sparrow.stage`, which so far proved to have
    some useful properties for getting the width and height of the screen and setting
    the background color directly.
  prefs: []
  type: TYPE_NORMAL
- en: A stage is the top-level element of any Sparrow game and logically the root
    element of the display tree, which Sparrow automatically creates for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our cardboard puppet doll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement the cardboard puppet doll that we talked about in the beginning
    of the chapter. Remove the red rectangle that has been drawn on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a cardboard puppet doll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the cardboard puppet doll, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Game.m` file if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `body` container with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `torso` as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a local variable `head` as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a container for the `arms` local variable as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a container for the `legs` local variable as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the left arm as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the right arm as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Every arm needs a hand. Let''s add the left one first as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now use the following code for the right hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s move on to the legs. We''ll create the left one first with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll create the right leg with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we run the example, a simple cardboard puppet doll made of rectangles
    is looking right at us, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a cardboard puppet doll](img/1509OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we used the `Game.m` source file we are already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we needed a container object, which we called `body` for this example.
    A quad would not suffice in this case because `SPQuad` does not inherit from `SPDisplayObjectContainer`
    and so cannot have children added to it. We set the `x` and `y` properties, so
    the contents of the `body` element appeared somewhere in the middle of our screen.
    The coordinate system in Sparrow started at the top-left corner of the screen,
    just like how the coordinate system works in Flash or in traditional application
    development when adding control elements to a window. Developers from a traditional
    graphics development may take some time to get used to this. In OpenGL, for example,
    the *y* axis is flipped. We then add the `body` element to our Game instance.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we took the `torso,` which is a quad and added it to the body element.
    If we don't specify an `x` or `y` property, their default value is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we added the `head`. The `x` and `y` properties are measured relative
    to the parent display object. So, if we use a negative value, it doesn't necessarily
    mean that the element is drawn outside the screen. It depends on the position
    of the parent display object container.
  prefs: []
  type: TYPE_NORMAL
- en: While we know that we can use colors with the hexadecimal notation, we are using
    `SP_YELLOW` in this step. This has the same effect as typing `0xffff00`.
  prefs: []
  type: TYPE_NORMAL
- en: For the arms and legs, we added a container for each in step 5 and step 6, respectively.
    `SPSprite` is the most basic and lightweight container class that should be used
    when grouping objects. The leg container is already being positioned a bit to
    the bottom, so its children elements only need to be positioned horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: In the remaining steps, we added each limb and when we finally ran the application,
    we had a cardboard puppet doll made of rectangles looking at us.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – improving the cardboard puppet doll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our code can be improved quite a bit; the `legs`, `arms`, and `hands` code are
    practically the same, but we define each element separately. We could try to group
    and simplify the code a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the current arrangement, the hands are not directly connected to the
    arms of the doll. Instead, they are bound to the `arms` container object. So if
    we were to move a single arm, the hand would not move with the arm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some ideas on how to solve these problems:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to connect the hands to the arms, we would need at least two new container
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a cardboard puppet doll class in which its elements are classes inheriting
    from the display object containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we know that we can use colors with the hexadecimal notation, Sparrow
    provides some shorthand constants for the most commonly used colors. In the previous
    example, instead of using `0xffff00` for the color yellow, we used `SP_YELLOW`.
  prefs: []
  type: TYPE_NORMAL
- en: To generalize, macros are handy little functions that allow us to simplify the
    workflow when working with repetitious tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Macros in Objective-C are preprocessor directives and work the same way that
    macros work in C and C++. Before the code is compiled, the preprocessor goes through
    the entire code and replaces all occurrences of the macro with the result of the
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: While we could write each color in the hexadecimal color value notation, sometimes
    it does make more sense to use an RGB value. The `SP_COLOR` macro does exactly
    that, converting a RGB color into a hexadecimal color value.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at what the different kinds of macros are and
    how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The Angles macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sparrow uses radians to describe the rotation of its display objects. If we
    want to use degrees for our calculations, we would need the following macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_R2D` | Converts radians to degrees | `SP_R2D(PI);``// 180` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_D2R` | Converts degrees to radians | `SP_D2R(180);``// PI` |'
  prefs: []
  type: TYPE_TB
- en: The Colors macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to create a custom color or take an existing color apart, the following
    macros would fit our purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_COLOR_PART_ALPHA``SP_COLOR_PART_RED``SP_COLOR_PART_GREEN``SP_COLOR_PART_BLUE`
    | Getting the partial value of a color | `SP_COLOR_PART_RED(0xff0000);``// 0xff`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_COLOR` | Sets an RGB color | `SP_COLOR(255, 255, 0);``// 0xffff00` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_COLOR_ARGB` | Sets an ARGB color | `SP_COLOR_ARGB(128, 255, 255, 0);``//
    0x80ffff00` |'
  prefs: []
  type: TYPE_TB
- en: The utility functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the last group of macros that aren''t angle- or color-related:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_IS_FLOAT_EQUAL` | Does a float comparison between two values. Returns
    0 if it''s false, 1 if it''s true. | `SP_IS_FLOAT_EQUAL(0.11, 0.12);``// 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_CLAMP` | Clamps between two values. The first parameter is the initial
    value. The other two parameters are the minimum and maximum values respectively.
    | `SP_CLAMP(0.6, 1.0, 2.0);``// 1.0` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_SWAP` | Swaps two values with each other. | `NSUInteger x = 0;``NSUInteger
    y = 1;``SP_SWAP(x, y, NSUInteger);``// x = 1; y = 0` |'
  prefs: []
  type: TYPE_TB
- en: Constants in Sparrow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know about `SP_YELLOW`, so let's take a look at what constants are
    defined in Sparrow.
  prefs: []
  type: TYPE_NORMAL
- en: Math
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PI` constant, for example, is used in the macro to convert radians to
    degrees and vice versa. The following are the examples of `PI` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PI` | The value of Pi |'
  prefs: []
  type: TYPE_TB
- en: '| `PI_HALF` | The value of Pi divided by two |'
  prefs: []
  type: TYPE_TB
- en: '| `TWO_PI` | The value of Pi multiplied by two |'
  prefs: []
  type: TYPE_TB
- en: Color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sparrow predefines 16 colors for easier usage, so we don''t have to use a macro
    each time. These are the most basic colors and are also defined in a number of
    different libraries and frameworks, for example, HTML 4.01\. The following table
    shows 16 colors that are predefined in Sparrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | RGB value | Hex value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_WHITE` | `255, 255, 255` | `0xffffff` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_SILVER` | `208, 208, 208` | `0xc0c0c0` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_GRAY` | `128, 128, 128` | `0x808080` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_BLACK` | `0, 0, 0` | `0x000000` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_RED` | `255, 0, 0` | `0xff0000` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_MAROON` | `128, 0, 0` | `0x800000` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_YELLOW` | `255, 255, 0` | `0xffff00` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_OLIVE` | `128, 128, 0` | `0x808000` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_LIME` | `0, 255, 0` | `0x00ff00` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_GREEN` | `0, 128, 0` | `0x008000` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_AQUA` | `0, 255, 255` | `0x00ffff` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_TEAL` | `0, 128, 128` | `0x008080` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_BLUE` | `0, 0, 255` | `0x0000ff` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_NAVY` | `0, 0, 128` | `0x000080` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_FUCHSIA` | `255, 0, 255` | `0xff00ff` |'
  prefs: []
  type: TYPE_TB
- en: '| `SP_PURPLE` | `128, 0, 128` | `0x800080` |'
  prefs: []
  type: TYPE_TB
- en: Manipulating display objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our cardboard puppet doll on the screen, let's start manipulating
    the objects on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will take a look at how to rotate, scale, and skew objects,
    and then set the origin of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – manipulating display objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to manipulate the display objects we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method to `Game.m` below the `init` method we used to create the
    body parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to set the anchor (pivot) of our legs in the initializer,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the leg positions using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll set an event listener for the legs using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s add another method that should be called when we touch the head of our
    cardboard puppet doll. This method should be below the initializer and the `onLegTouch`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll need to set the pivot for the head as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s update the position of the head as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s add an event listener for the head as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another method that should be called if we touch the arms. This is shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bind the event listener to this newly added method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example and touch some limbs of our cardboard puppet doll. We should
    now see our cardboard puppet doll on the screen and if we touch an arm, leg, or
    the head, we see these objects rotated, skewed, or scaled.![Time for action –
    manipulating display objects](img/1509OS_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In step 1, we defined a method that should be called when we touch one of the
    legs. We need to get a reference to the touch event, which in Sparrow is described
    as `SPTouchEvent`. To get the touch instance (`SPTouch`), we looked for touches
    on any object in the touch began phase. Each touch moves through three phases:
    first `SPTouchPhaseBegan`, then `SPTouchPhaseMoved`, and finally `SPTouchPhaseEnded`.
    We need to check whether the touch is valid as objects have been touched by using
    it as a condition in the `if`-statement. The current target of the event is available
    in `event.target` although it needs to be casted to the appropriate display object
    type, in this case, `SPQuad`.'
  prefs: []
  type: TYPE_NORMAL
- en: We then got the current rotation of the touched object and add 10 degrees to
    the rotation. The new rotation will be set to the quad. If the rotation is bigger
    than 360 degrees, we'll subtract 360 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The origin for display objects is, by default, the top-left corner of the display
    object itself. If we want a different origin, we'll need to modify it using the
    `pivotX` and `pivotY` properties of a display object.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the origin also has an effect on the positioning of the element; so,
    if we want to keep the same position, we need to add the pivot value to the position
    values, which is what happened in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we added an event listener for each of the legs, so when we actually
    touch the legs, something happens. When using `addEventListener`, we are binding
    a selector that will be called once the event is triggered, in our case, `SP_EVENT_TYPE_TOUCH`.
    This event will be called if any touch occurs on the specified object, which was
    `self` (the `Game` instance) in this step. Multiple selectors can be bound to
    one event when using `addEventListener` each time.
  prefs: []
  type: TYPE_NORMAL
- en: For the next step, we added a method for touching the head of our cardboard
    puppet doll. We also needed to do the same touch check and target casting we did
    last time. This time when we touch the head, it should scale up to 150 percent
    of its original size, and if we touch the head again, it'll shrink back to its
    original size.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we set the origin to the center of the element. In step 7, we needed
    to update the position accordingly, and in step 8, we bound the method to the
    `head` element.
  prefs: []
  type: TYPE_NORMAL
- en: The last method that we defined is what would happen when we touch any `arms`
    element. If we are binding a touch event to a `SPSprite` instance, it will fire
    for all its children as well. The same touch check applies to this method. We'll
    skew an element by 20 degrees with the first touch and reset it to its original
    state when the element is touched again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a ternary statement here to check whether the target is already skewed.
    We check for the condition within the parenthesis. If the condition evaluates
    against `true`, the statement after the question mark will be executed; otherwise,
    the statement after the colon will be executed. The advantage is that the ternary
    statement is an expression and can be assigned to a value in a single step. It
    would translate to the following code if we were to use `if` statements instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `onArmsTouch` method was then bound to the `arms` object in step 10.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the example and touch various elements, we'll see all the skewing,
    scaling, and rotating in action.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What is an alternate term for display list/tree?
  prefs: []
  type: TYPE_NORMAL
- en: Display block
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scene graph
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What is a Sparrow stage?
  prefs: []
  type: TYPE_NORMAL
- en: A game level
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Root element of the display tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A display object on the `Game` class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What are macros?
  prefs: []
  type: TYPE_NORMAL
- en: Functions that are evaluated at runtime
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preprocessor directives that are evaluated before compiling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic constants
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about how to display objects on the screen
    and how to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered how to display objects on the screen and use macros
    and constants Sparrow provides. Another important aspect is that we manipulated
    the objects we drew on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched on some topics such as the Sparrow stage and got an overview
    of how the Sparrow API works.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to draw objects on the screen, we're ready to learn about
    asset and scene management—which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
