- en: Chapter 2. Displaying Our First Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 显示我们的第一个对象
- en: '*In the previous chapter, we installed and configured Xcode developer tools
    and also as downloaded the Sparrow framework and linked it to a sample project.
    We proceeded to test it in both the iOS Simulator and a real device. We also set
    the scope for the game we are going to develop throughout the book. However, before
    we get into the game development process, let''s touch on some core concepts of
    Sparrow and get accustomed with the way things work in Sparrow. We will draw some
    objects on the screen and manipulate these objects by applying rotation and scaling
    transforms.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们安装并配置了Xcode开发者工具，还下载了Sparrow框架并将其链接到一个示例项目中。我们接着在iOS模拟器和真实设备上进行了测试。我们还为本书中将要开发的整个游戏设定了范围。然而，在我们进入游戏开发过程之前，让我们先了解一下Sparrow的一些核心概念，并熟悉Sparrow中的工作方式。我们将在屏幕上绘制一些对象，并通过应用旋转和缩放变换来操作这些对象。*'
- en: Understanding display objects
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解显示对象
- en: As the name suggests, a display object is something that will be displayed on
    the screen. We can think of display objects as separate graphical entities that
    contain different kinds of graphical data. While this may sound a bit abstract
    at first, every image (`SPImage`), quads (`SPQuad`), or other geometrical shapes
    are derived from the `SPDisplayObject` class, which is the representation of a
    display object in Sparrow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，显示对象是将在屏幕上显示的东西。我们可以将显示对象视为包含不同类型图形数据的独立图形实体。虽然一开始这可能听起来有些抽象，但每个图像（`SPImage`）、四边形（`SPQuad`）或其他几何形状都是从`SPDisplayObject`类派生出来的，这是Sparrow中显示对象的表示。
- en: Explaining display object containers
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释显示对象容器
- en: A display object container (`SPDisplayObjectContainer`) inherits from `SPDisplayObject`,
    adding the facility to own a set of child display objects. When you add a child
    display object to a parent display object container, you can think of it as attaching
    one display object to another. If you move, scale, or rotate the parent display
    object, all the changes are inherited by any children it might have. This concept
    is more or less identical to how objects on the screen are managed in the Adobe
    Flash API. The full set of parent and child nodes is referred to as the display
    list, or sometimes as a display tree. This is because, like a tree, it contains
    many branches that all ultimately converge into one single trunk, often referred
    to as the root. Yet another name for a display tree is a scene graph.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示对象容器（`SPDisplayObjectContainer`）从`SPDisplayObject`继承，增加了拥有一组子显示对象的功能。当你将一个子显示对象添加到一个父显示对象容器中时，你可以将其视为将一个显示对象附加到另一个显示对象上。如果你移动、缩放或旋转父显示对象，所有这些变化都会被其可能拥有的任何子对象继承。这个概念与Adobe
    Flash API中屏幕上对象的管理方式大致相同。父节点和子节点的一整套被称为显示列表，有时也称为显示树。这是因为，就像一棵树一样，它包含许多分支，最终都汇聚到一个单一的树干上，通常被称为根。显示树的另一个名称是场景图。
- en: The display list draws the display objects in the order they are added to their
    parent display object container. If we were to add a second child display object
    to the same parent as that of the previously added display object, the second
    display object will be drawn in front of the first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 显示列表按照它们被添加到父显示对象容器中的顺序绘制显示对象。如果我们向与之前添加的显示对象相同的父对象中添加第二个子显示对象，第二个显示对象将被绘制在第一个显示对象的前面。
- en: 'Let''s go ahead and imagine ourselves as a cardboard puppet doll. We need a
    head, a torso and a leg, arm, and hand on the left side and the same goes for
    the right side. Refer to the following diagram that displays this concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续想象自己是一个纸板木偶娃娃。我们需要一个头部、一个躯干和一条腿，左边的手臂和手，右边的也是如此。参考以下显示这个概念的图示：
- en: '![Explaining display object containers](img/1509OS_02_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![解释显示对象容器](img/1509OS_02_01.jpg)'
- en: The root object for this arrangement would be the body object. The head, torso,
    legs, and arms would be directly bound to the body and the hands would be bound
    to each arm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个安排的根对象将是身体对象。头部、躯干、腿和手臂将直接绑定到身体上，而手将绑定到每只手臂上。
- en: Setting the background color
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置背景颜色
- en: Before we draw a couple of objects on the screen, let's change the background
    color of our application that will eventually become our game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在屏幕上绘制一些对象之前，让我们改变我们应用程序的背景颜色，这个应用程序最终将成为我们的游戏。
- en: Time for action – changing the background color
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 改变背景颜色
- en: 'Let''s take a look at the required steps to change the background color:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看改变背景颜色的必要步骤：
- en: Open our Xcode game template if it's not already open.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请打开我们的Xcode游戏模板。
- en: Open the `Game.m` source file.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Game.m`源文件。
- en: 'After the initialization method and before the existing `SPQuad` object, add
    the following lines:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化方法和现有的`SPQuad`对象之前，添加以下行：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the example.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'When the example is running, we see our red rectangle on a white background
    as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当示例运行时，我们会在以下屏幕截图所示的白色背景上看到我们的红色矩形：
- en: '![Time for action – changing the background color](img/1509OS_02_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间 – 更改背景颜色](img/1509OS_02_02.jpg)'
- en: '*What just happened?*'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened our Xcode template that we created in the previous chapter,
    and in step 2, we navigated to the `Game.m` file, which is where our game code
    currently lies. The game is the red rectangle that keeps showing up.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们打开了我们在上一章中创建的Xcode模板，在第2步中，我们导航到`Game.m`文件，这是我们当前的游戏代码所在之处。游戏是一个不断出现的红色矩形。
- en: In step 3, right before we drew our red rectangle, we defined the `background`
    variable that is a pointer to an instance of `SPQuad`. The `SPQuad` class is derived
    from `SPDisplayObject`. The function of `SPQuad` is to draw a rectangular shape
    with a background color.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步，在我们绘制红色矩形之前，我们定义了`background`变量，它是一个指向`SPQuad`实例的指针。`SPQuad`类是从`SPDisplayObject`派生出来的。`SPQuad`的功能是绘制一个带有背景色的矩形形状。
- en: The `SPQuad` class provides a few factory methods for operations such as creating
    a quad with a width and height and also adds a color value to it. In this example,
    we are creating a quad with a predefined width and height and a color value of
    `0xffffff`. A color is defined as `0xRRGGBB` in a hexadecimal notation, that is,
    `REDRED` `GREENGREEN` `BLUEBLUE`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`SPQuad`类提供了一些工厂方法，用于执行诸如创建具有宽度和高度的quad以及向其添加颜色值等操作。在这个例子中，我们正在创建一个具有预定义宽度和高度以及颜色值`0xffffff`的quad。颜色定义为十六进制表示的`0xRRGGBB`，即`REDRED`
    `GREENGREEN` `BLUEBLUE`。'
- en: While at the surface, the call to `[SPQuad quadWithWidth:Sparrow.stage.width
    height:Sparrow.stage.height]` seems to be the same as the one to `[[SPQuad alloc]
    initWithWidth:Sparrow.stage.width height:Sparrow.stage.height]`, but there is
    one major difference under the hood. When the factory method is called, it returns
    an auto-released object, which means we don't have an ownership over the instance
    and it's being destroyed at some point. On the other hand, if we use the alloc-and-init
    combination, we do have the ownership and the need to release the instance ourselves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，调用`[SPQuad quadWithWidth:Sparrow.stage.width height:Sparrow.stage.height]`似乎与调用`[[SPQuad
    alloc] initWithWidth:Sparrow.stage.width height:Sparrow.stage.height]]`相同，但在底层有一个主要区别。当调用工厂方法时，它返回一个自动释放的对象，这意味着我们没有实例的所有权，它将在某个时刻被销毁。另一方面，如果我们使用alloc-and-init组合，我们就拥有所有权，需要自己释放实例。
- en: As our application uses **Automatic Reference Counting** (**ARC**), we don't
    need to worry about releasing instances ourselves. On the other hand, Sparrow
    itself uses **Manual Reference Counting** (**MRC**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序使用**自动引用计数**（**ARC**），我们不需要担心自己释放实例。另一方面，Sparrow本身使用**手动引用计数**（**MRC**）。
- en: To cover the whole screen, we need to get the width and height of the screen
    itself. Those values are available as properties in the `Sparrow.stage` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖整个屏幕，我们需要获取屏幕本身的宽度和高度。这些值作为属性存在于`Sparrow.stage`对象中。
- en: We need to add the background to the `Game` class, which is exactly what `[self
    addChild:background]` does. The `self` keyword is a reference to the `Game` class,
    which is derived from the `SPSprite` class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将背景添加到`Game`类中，这正是`[self addChild:background]`所做的事情。`self`关键字是对`Game`类的引用，它是从`SPSprite`类派生出来的。
- en: Now, we have a white background with a red rectangle that appears on top of
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个白色背景，上面有一个红色矩形出现。
- en: 'Our `Game.m` source file should contain the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Game.m`源文件应该包含以下代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'There is also an easier way to set the background color. While the performance
    penalty in this specific case is not that high to worry about, we could directly
    set the color through `Sparrow.stage` by using its color property: `Sparrow.stage.color
    = 0xffffff`. It consists of fewer lines, is more readable, and shows its intention
    better.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一种更简单的方法来设置背景颜色。虽然在这个特定情况下性能损失并不高，以至于需要担心，但我们可以直接通过`Sparrow.stage`使用其颜色属性来设置颜色：`Sparrow.stage.color
    = 0xffffff`。这包含更少的行，更易于阅读，并且更好地展示了其意图。
- en: What is a stage?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是舞台？
- en: We briefly touched on the topic of `Sparrow.stage`, which so far proved to have
    some useful properties for getting the width and height of the screen and setting
    the background color directly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地提到了`Sparrow.stage`的话题，到目前为止，它已经证明有一些有用的属性，可以获取屏幕的宽度和高度，并直接设置背景颜色。
- en: A stage is the top-level element of any Sparrow game and logically the root
    element of the display tree, which Sparrow automatically creates for us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 舞台是任何Sparrow游戏的顶级元素，逻辑上是显示树的根元素，Sparrow会为我们自动创建。
- en: Creating our cardboard puppet doll
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的纸板木偶娃娃
- en: Let's implement the cardboard puppet doll that we talked about in the beginning
    of the chapter. Remove the red rectangle that has been drawn on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现本章开头提到的纸板木偶娃娃。移除屏幕上已经画出的红色矩形。
- en: Time for action – creating a cardboard puppet doll
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手制作纸板木偶娃娃了
- en: 'To create the cardboard puppet doll, we need to perform the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建纸板木偶娃娃，我们需要执行以下步骤：
- en: Open the `Game.m` file if it's not already open.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Game.m`文件还没有打开，请打开它。
- en: 'Add a `body` container with the following lines:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`body`容器，以下代码：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add `torso` as shown in the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码添加`torso`：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now add a local variable `head` as shown in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个局部变量`head`，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a container for the `arms` local variable as shown in the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码添加一个用于`arms`局部变量的容器：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a container for the `legs` local variable as shown in the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码添加一个用于`legs`局部变量的容器：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the left arm as shown in the following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码添加左臂：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the right arm as shown in the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码添加右臂：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Every arm needs a hand. Let''s add the left one first as shown in the following
    code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个手臂都需要一只手。让我们首先按照以下代码添加左手：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now use the following code for the right hand:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为右手使用以下代码：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s move on to the legs. We''ll create the left one first with the following
    code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续制作腿。我们将首先使用以下代码创建左腿：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll create the right leg with the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下代码创建右腿：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the example.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'When we run the example, a simple cardboard puppet doll made of rectangles
    is looking right at us, as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，一个由矩形组成的简单纸板木偶娃娃正对着我们，如下面的截图所示：
- en: '![Time for action – creating a cardboard puppet doll](img/1509OS_02_03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![动手制作纸板木偶娃娃](img/1509OS_02_03.jpg)'
- en: '*What just happened?*'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we used the `Game.m` source file we are already familiar with.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们使用了我们已熟悉的`Game.m`源文件。
- en: At first, we needed a container object, which we called `body` for this example.
    A quad would not suffice in this case because `SPQuad` does not inherit from `SPDisplayObjectContainer`
    and so cannot have children added to it. We set the `x` and `y` properties, so
    the contents of the `body` element appeared somewhere in the middle of our screen.
    The coordinate system in Sparrow started at the top-left corner of the screen,
    just like how the coordinate system works in Flash or in traditional application
    development when adding control elements to a window. Developers from a traditional
    graphics development may take some time to get used to this. In OpenGL, for example,
    the *y* axis is flipped. We then add the `body` element to our Game instance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个容器对象，在这个例子中我们称之为`body`。在这种情况下，一个四边形不足以满足需求，因为`SPQuad`不继承自`SPDisplayObjectContainer`，因此不能向其添加子对象。我们设置了`x`和`y`属性，这样`body`元素的内容就出现在屏幕的中间位置。Sparrow中的坐标系从屏幕的左上角开始，就像在Flash或传统应用程序开发中添加控制元素到窗口时的坐标系一样。来自传统图形开发的开发者可能需要一些时间来适应这一点。例如，在OpenGL中，*y*轴是反转的。然后我们将`body`元素添加到我们的游戏实例中。
- en: In step 3, we took the `torso,` which is a quad and added it to the body element.
    If we don't specify an `x` or `y` property, their default value is `0`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们将`torso`（一个四边形）添加到身体元素中。如果我们没有指定`x`或`y`属性，它们的默认值是`0`。
- en: After that, we added the `head`. The `x` and `y` properties are measured relative
    to the parent display object. So, if we use a negative value, it doesn't necessarily
    mean that the element is drawn outside the screen. It depends on the position
    of the parent display object container.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们添加了`头部`。`x`和`y`属性是相对于父显示对象测量的。因此，如果我们使用负值，这并不一定意味着元素被绘制在屏幕之外。这取决于父显示对象容器的位置。
- en: While we know that we can use colors with the hexadecimal notation, we are using
    `SP_YELLOW` in this step. This has the same effect as typing `0xffff00`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道我们可以使用十六进制表示法来使用颜色，但我们在这个步骤中使用`SP_YELLOW`。这和输入`0xffff00`有相同的效果。
- en: For the arms and legs, we added a container for each in step 5 and step 6, respectively.
    `SPSprite` is the most basic and lightweight container class that should be used
    when grouping objects. The leg container is already being positioned a bit to
    the bottom, so its children elements only need to be positioned horizontally.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于胳膊和腿，我们在第5步和第6步分别添加了每个的容器。`SPSprite`是最基本的轻量级容器类，当分组对象时应使用。腿的容器已经向下定位了一点点，所以其子元素只需要水平定位。
- en: In the remaining steps, we added each limb and when we finally ran the application,
    we had a cardboard puppet doll made of rectangles looking at us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的步骤中，我们添加了每个肢体，当我们最终运行应用程序时，我们得到了一个由矩形组成的纸板木偶娃娃。
- en: Have a go hero – improving the cardboard puppet doll
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——改进纸板木偶娃娃
- en: Our code can be improved quite a bit; the `legs`, `arms`, and `hands` code are
    practically the same, but we define each element separately. We could try to group
    and simplify the code a bit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以相当大地改进我们的代码；`legs`、`arms`和`hands`的代码实际上是一样的，但我们分别定义了每个元素。我们可以尝试分组和简化代码一点。
- en: Also, in the current arrangement, the hands are not directly connected to the
    arms of the doll. Instead, they are bound to the `arms` container object. So if
    we were to move a single arm, the hand would not move with the arm.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在当前的布局中，手并没有直接连接到娃娃的胳膊上。相反，它们被绑定到`arms`容器对象上。所以如果我们移动一个胳膊，手不会随着胳膊移动。
- en: 'The following are some ideas on how to solve these problems:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些解决这些问题的想法：
- en: In order to connect the hands to the arms, we would need at least two new container
    objects
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将手连接到胳膊上，我们需要至少两个新的容器对象
- en: Make a cardboard puppet doll class in which its elements are classes inheriting
    from the display object containers
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个纸板木偶娃娃类，其中其元素是继承自显示对象容器的类
- en: Explaining macros
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释宏
- en: While we know that we can use colors with the hexadecimal notation, Sparrow
    provides some shorthand constants for the most commonly used colors. In the previous
    example, instead of using `0xffff00` for the color yellow, we used `SP_YELLOW`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道我们可以使用十六进制表示法来使用颜色，但Sparrow为最常用的颜色提供了一些简写常量。在上一个例子中，我们使用`SP_YELLOW`代替了`0xffff00`的颜色黄色。
- en: To generalize, macros are handy little functions that allow us to simplify the
    workflow when working with repetitious tasks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概括，宏是方便的小函数，允许我们在处理重复性任务时简化工作流程。
- en: Macros in Objective-C are preprocessor directives and work the same way that
    macros work in C and C++. Before the code is compiled, the preprocessor goes through
    the entire code and replaces all occurrences of the macro with the result of the
    macro.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的宏是预处理器指令，它们的工作方式与C和C++中的宏相同。在代码编译之前，预处理器会遍历整个代码，并将所有宏的出现替换为宏的结果。
- en: While we could write each color in the hexadecimal color value notation, sometimes
    it does make more sense to use an RGB value. The `SP_COLOR` macro does exactly
    that, converting a RGB color into a hexadecimal color value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以用十六进制颜色值表示法写出每种颜色，但有时使用RGB值可能更有意义。`SP_COLOR`宏正是这样做的，它将RGB颜色转换为十六进制颜色值。
- en: In this section, we will look at what the different kinds of macros are and
    how to use them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同类型的宏是什么以及如何使用它们。
- en: The Angles macro
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角度宏
- en: 'Sparrow uses radians to describe the rotation of its display objects. If we
    want to use degrees for our calculations, we would need the following macros:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Sparrow使用弧度来描述其显示对象的旋转。如果我们想用度来计算，我们需要以下宏：
- en: '| Name | Description | Example |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SP_R2D` | Converts radians to degrees | `SP_R2D(PI);``// 180` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `SP_R2D` | 将弧度转换为度 | `SP_R2D(PI);``// 180` |'
- en: '| `SP_D2R` | Converts degrees to radians | `SP_D2R(180);``// PI` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `SP_D2R` | 将度转换为弧度 | `SP_D2R(180);``// PI` |'
- en: The Colors macro
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色宏
- en: 'If we need to create a custom color or take an existing color apart, the following
    macros would fit our purpose:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要创建自定义颜色或将现有颜色分解，以下宏将适合我们的目的：
- en: '| Name | Description | Example |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SP_COLOR_PART_ALPHA``SP_COLOR_PART_RED``SP_COLOR_PART_GREEN``SP_COLOR_PART_BLUE`
    | Getting the partial value of a color | `SP_COLOR_PART_RED(0xff0000);``// 0xff`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `SP_COLOR_PART_ALPHA``SP_COLOR_PART_RED``SP_COLOR_PART_GREEN``SP_COLOR_PART_BLUE`
    | 获取颜色的部分值 | `SP_COLOR_PART_RED(0xff0000);``// 0xff` |'
- en: '| `SP_COLOR` | Sets an RGB color | `SP_COLOR(255, 255, 0);``// 0xffff00` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `SP_COLOR` | 设置 RGB 颜色 | `SP_COLOR(255, 255, 0);``// 0xffff00` |'
- en: '| `SP_COLOR_ARGB` | Sets an ARGB color | `SP_COLOR_ARGB(128, 255, 255, 0);``//
    0x80ffff00` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `SP_COLOR_ARGB` | 设置 ARGB 颜色 | `SP_COLOR_ARGB(128, 255, 255, 0);``// 0x80ffff00`
    |'
- en: The utility functions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具函数
- en: 'Let''s take a look at the last group of macros that aren''t angle- or color-related:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最后一组不是与角度或颜色相关的宏：
- en: '| Name | Description | Example |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SP_IS_FLOAT_EQUAL` | Does a float comparison between two values. Returns
    0 if it''s false, 1 if it''s true. | `SP_IS_FLOAT_EQUAL(0.11, 0.12);``// 0` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `SP_IS_FLOAT_EQUAL` | 对两个值进行浮点比较。如果为假返回 0，如果为真返回 1。 | `SP_IS_FLOAT_EQUAL(0.11,
    0.12);``// 0` |'
- en: '| `SP_CLAMP` | Clamps between two values. The first parameter is the initial
    value. The other two parameters are the minimum and maximum values respectively.
    | `SP_CLAMP(0.6, 1.0, 2.0);``// 1.0` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `SP_CLAMP` | 在两个值之间夹紧。第一个参数是初始值。其他两个参数分别是最小值和最大值。 | `SP_CLAMP(0.6, 1.0, 2.0);``//
    1.0` |'
- en: '| `SP_SWAP` | Swaps two values with each other. | `NSUInteger x = 0;``NSUInteger
    y = 1;``SP_SWAP(x, y, NSUInteger);``// x = 1; y = 0` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `SP_SWAP` | 交换两个值。 | `NSUInteger x = 0;``NSUInteger y = 1;``SP_SWAP(x, y,
    NSUInteger);``// x = 1; y = 0` |'
- en: Constants in Sparrow
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sparrow 中的常量
- en: We already know about `SP_YELLOW`, so let's take a look at what constants are
    defined in Sparrow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 `SP_YELLOW`，那么让我们看看 Sparrow 中定义了哪些常量。
- en: Math
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学
- en: 'The `PI` constant, for example, is used in the macro to convert radians to
    degrees and vice versa. The following are the examples of `PI` constant:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`PI` 常量在宏中用于将弧度转换为度数，反之亦然。以下是一些 `PI` 常量的示例：
- en: '| Name | Description |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PI` | The value of Pi |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `PI` | π 的值 |'
- en: '| `PI_HALF` | The value of Pi divided by two |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `PI_HALF` | π 值的一半 |'
- en: '| `TWO_PI` | The value of Pi multiplied by two |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `TWO_PI` | π 值乘以二 |'
- en: Color
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色
- en: 'Sparrow predefines 16 colors for easier usage, so we don''t have to use a macro
    each time. These are the most basic colors and are also defined in a number of
    different libraries and frameworks, for example, HTML 4.01\. The following table
    shows 16 colors that are predefined in Sparrow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Sparrow 预定义了 16 种颜色以便于使用，因此我们不必每次都使用宏。这些是最基本的颜色，也定义在许多不同的库和框架中，例如，HTML 4.01。以下表格显示了
    Sparrow 中预定义的 16 种颜色：
- en: '| Name | RGB value | Hex value |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | RGB 值 | 十六进制值 |'
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SP_WHITE` | `255, 255, 255` | `0xffffff` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `SP_WHITE` | `255, 255, 255` | `0xffffff` |'
- en: '| `SP_SILVER` | `208, 208, 208` | `0xc0c0c0` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `SP_SILVER` | `208, 208, 208` | `0xc0c0c0` |'
- en: '| `SP_GRAY` | `128, 128, 128` | `0x808080` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `SP_GRAY` | `128, 128, 128` | `0x808080` |'
- en: '| `SP_BLACK` | `0, 0, 0` | `0x000000` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `SP_BLACK` | `0, 0, 0` | `0x000000` |'
- en: '| `SP_RED` | `255, 0, 0` | `0xff0000` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `SP_RED` | `255, 0, 0` | `0xff0000` |'
- en: '| `SP_MAROON` | `128, 0, 0` | `0x800000` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `SP_MAROON` | `128, 0, 0` | `0x800000` |'
- en: '| `SP_YELLOW` | `255, 255, 0` | `0xffff00` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `SP_YELLOW` | `255, 255, 0` | `0xffff00` |'
- en: '| `SP_OLIVE` | `128, 128, 0` | `0x808000` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `SP_OLIVE` | `128, 128, 0` | `0x808000` |'
- en: '| `SP_LIME` | `0, 255, 0` | `0x00ff00` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `SP_LIME` | `0, 255, 0` | `0x00ff00` |'
- en: '| `SP_GREEN` | `0, 128, 0` | `0x008000` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `SP_GREEN` | `0, 128, 0` | `0x008000` |'
- en: '| `SP_AQUA` | `0, 255, 255` | `0x00ffff` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `SP_AQUA` | `0, 255, 255` | `0x00ffff` |'
- en: '| `SP_TEAL` | `0, 128, 128` | `0x008080` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `SP_TEAL` | `0, 128, 128` | `0x008080` |'
- en: '| `SP_BLUE` | `0, 0, 255` | `0x0000ff` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `SP_BLUE` | `0, 0, 255` | `0x0000ff` |'
- en: '| `SP_NAVY` | `0, 0, 128` | `0x000080` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `SP_NAVY` | `0, 0, 128` | `0x000080` |'
- en: '| `SP_FUCHSIA` | `255, 0, 255` | `0xff00ff` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `SP_FUCHSIA` | `255, 0, 255` | `0xff00ff` |'
- en: '| `SP_PURPLE` | `128, 0, 128` | `0x800080` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `SP_PURPLE` | `128, 0, 128` | `0x800080` |'
- en: Manipulating display objects
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示对象的操作
- en: Now that we have our cardboard puppet doll on the screen, let's start manipulating
    the objects on the screen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上有了我们的纸板木偶娃娃，让我们开始操作屏幕上的对象。
- en: In this example, we will take a look at how to rotate, scale, and skew objects,
    and then set the origin of these objects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看看如何旋转、缩放和倾斜对象，然后设置这些对象的起点。
- en: Time for action – manipulating display objects
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 操作显示对象
- en: 'Perform the following steps to manipulate the display objects we created earlier:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来操作我们之前创建的显示对象：
- en: 'Add a new method to `Game.m` below the `init` method we used to create the
    body parts:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Game.m` 中添加一个新的方法，位于我们用来创建身体部分的 `init` 方法下面：
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''ll need to set the anchor (pivot) of our legs in the initializer,
    as shown in the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要在初始化器中设置我们腿部的锚点（枢轴），如下所示：
- en: '[PRE14]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the leg positions using the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新腿部位置：
- en: '[PRE15]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll set an event listener for the legs using the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码为腿部设置事件监听器：
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s add another method that should be called when we touch the head of our
    cardboard puppet doll. This method should be below the initializer and the `onLegTouch`
    method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个方法，当触摸到我们的纸板木偶头部时应该被调用。这个方法应该在初始化器和 `onLegTouch` 方法下面：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ll need to set the pivot for the head as well:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要设置头部的主轴（枢轴）：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s update the position of the head as shown in the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们根据以下代码更新头部位置：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s add an event listener for the head as shown in the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个事件监听器，用于头部，如下所示：
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add another method that should be called if we touch the arms. This is shown
    in the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个方法，当触摸到手臂时应该被调用。这将在以下代码中展示：
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Bind the event listener to this newly added method:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件监听器绑定到这个新添加的方法上：
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the example and touch some limbs of our cardboard puppet doll. We should
    now see our cardboard puppet doll on the screen and if we touch an arm, leg, or
    the head, we see these objects rotated, skewed, or scaled.![Time for action –
    manipulating display objects](img/1509OS_02_04.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并触摸我们的纸板木偶的一些肢体。现在我们应该在屏幕上看到我们的纸板木偶，如果我们触摸手臂、腿或头部，我们会看到这些对象旋转、倾斜或缩放。![操作时间
    – 操作显示对象](img/1509OS_02_04.jpg)
- en: '*What just happened?*'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'In step 1, we defined a method that should be called when we touch one of the
    legs. We need to get a reference to the touch event, which in Sparrow is described
    as `SPTouchEvent`. To get the touch instance (`SPTouch`), we looked for touches
    on any object in the touch began phase. Each touch moves through three phases:
    first `SPTouchPhaseBegan`, then `SPTouchPhaseMoved`, and finally `SPTouchPhaseEnded`.
    We need to check whether the touch is valid as objects have been touched by using
    it as a condition in the `if`-statement. The current target of the event is available
    in `event.target` although it needs to be casted to the appropriate display object
    type, in this case, `SPQuad`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们定义了一个方法，当触摸到一条腿时应该被调用。我们需要获取触摸事件的引用，在 Sparrow 中，这被描述为 `SPTouchEvent`。为了获取触摸实例（`SPTouch`），我们在触摸开始阶段查找任何对象的触摸。每个触摸会经过三个阶段：首先
    `SPTouchPhaseBegan`，然后 `SPTouchPhaseMoved`，最后 `SPTouchPhaseEnded`。我们需要检查触摸是否有效，因为可以通过在
    `if`-语句中使用它作为条件来检查对象是否被触摸。事件当前的目标在 `event.target` 中可用，尽管它需要被转换为适当的显示对象类型，在这个案例中是
    `SPQuad`。
- en: We then got the current rotation of the touched object and add 10 degrees to
    the rotation. The new rotation will be set to the quad. If the rotation is bigger
    than 360 degrees, we'll subtract 360 degrees.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取了被触摸对象的当前旋转，并将其增加10度。新的旋转将被设置为四边形。如果旋转大于360度，我们将减去360度。
- en: The origin for display objects is, by default, the top-left corner of the display
    object itself. If we want a different origin, we'll need to modify it using the
    `pivotX` and `pivotY` properties of a display object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象的默认原点是其自身的左上角。如果我们想要不同的原点，我们需要使用显示对象的 `pivotX` 和 `pivotY` 属性来修改它。
- en: Modifying the origin also has an effect on the positioning of the element; so,
    if we want to keep the same position, we need to add the pivot value to the position
    values, which is what happened in step 3.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 修改原点也会影响元素的位置；因此，如果我们想要保持相同的位置，我们需要将枢轴值添加到位置值中，这就是第3步中发生的事情。
- en: In step 4, we added an event listener for each of the legs, so when we actually
    touch the legs, something happens. When using `addEventListener`, we are binding
    a selector that will be called once the event is triggered, in our case, `SP_EVENT_TYPE_TOUCH`.
    This event will be called if any touch occurs on the specified object, which was
    `self` (the `Game` instance) in this step. Multiple selectors can be bound to
    one event when using `addEventListener` each time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们为每条腿添加了一个事件监听器，所以当我们实际触摸到腿时，会发生某些事情。当使用 `addEventListener` 时，我们正在绑定一个在事件触发时将被调用的选择器，在我们的案例中，是
    `SP_EVENT_TYPE_TOUCH`。如果指定的对象（在这个步骤中是 `self`，即 `Game` 实例）上发生任何触摸，这个事件将被调用。当使用
    `addEventListener` 时，可以将多个选择器绑定到同一个事件。
- en: For the next step, we added a method for touching the head of our cardboard
    puppet doll. We also needed to do the same touch check and target casting we did
    last time. This time when we touch the head, it should scale up to 150 percent
    of its original size, and if we touch the head again, it'll shrink back to its
    original size.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，我们添加了一个用于触摸我们纸板木偶头部的函数。我们还需要执行上一次相同的触摸检查和目标投射。这次当我们触摸头部时，它应该放大到原始大小的150%，如果我们再次触摸头部，它将缩小回原始大小。
- en: In step 6, we set the origin to the center of the element. In step 7, we needed
    to update the position accordingly, and in step 8, we bound the method to the
    `head` element.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们将原点设置为元素的中心。在第7步中，我们需要相应地更新位置，而在第8步中，我们将方法绑定到`head`元素。
- en: The last method that we defined is what would happen when we touch any `arms`
    element. If we are binding a touch event to a `SPSprite` instance, it will fire
    for all its children as well. The same touch check applies to this method. We'll
    skew an element by 20 degrees with the first touch and reset it to its original
    state when the element is touched again.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的最后一个方法是我们触摸任何`arms`元素时会发生什么。如果我们将触摸事件绑定到`SPSprite`实例，它将为其所有子元素触发。同样的触摸检查也适用于此方法。第一次触摸时，我们将元素倾斜20度，当元素再次被触摸时，将其重置到原始状态。
- en: 'We use a ternary statement here to check whether the target is already skewed.
    We check for the condition within the parenthesis. If the condition evaluates
    against `true`, the statement after the question mark will be executed; otherwise,
    the statement after the colon will be executed. The advantage is that the ternary
    statement is an expression and can be assigned to a value in a single step. It
    would translate to the following code if we were to use `if` statements instead:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用三元表达式来检查目标是否已经倾斜。我们检查括号内的条件。如果条件评估为`true`，则执行问号后面的语句；否则，执行冒号后面的语句。其优势是三元表达式是一个表达式，可以一次性赋值给一个变量。如果我们使用`if`语句，它将转换为以下代码：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `onArmsTouch` method was then bound to the `arms` object in step 10.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第10步中，我们将`onArmsTouch`方法绑定到了`arms`对象。
- en: When we run the example and touch various elements, we'll see all the skewing,
    scaling, and rotating in action.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例并触摸各种元素时，我们将看到所有的倾斜、缩放和旋转动作。
- en: Pop quiz
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. What is an alternate term for display list/tree?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 显示列表/树的另一个术语是什么？
- en: Display block
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示块
- en: Display object
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示对象
- en: Scene graph
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景图
- en: Q2\. What is a Sparrow stage?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 什么是Sparrow阶段？
- en: A game level
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个游戏关卡
- en: Root element of the display tree
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示树的根元素
- en: A display object on the `Game` class
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Game`类上的显示对象'
- en: Q3\. What are macros?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 宏是什么？
- en: Functions that are evaluated at runtime
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行时评估的函数
- en: Preprocessor directives that are evaluated before compiling
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译前评估的预处理器指令
- en: Dynamic constants
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态常量
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about how to display objects on the screen
    and how to manipulate them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于如何在屏幕上显示对象以及如何操作它们的知识。
- en: Specifically, we covered how to display objects on the screen and use macros
    and constants Sparrow provides. Another important aspect is that we manipulated
    the objects we drew on the screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了如何在屏幕上显示对象以及使用Sparrow提供的宏和常量。另一个重要方面是我们操作了我们在屏幕上绘制的对象。
- en: We also touched on some topics such as the Sparrow stage and got an overview
    of how the Sparrow API works.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涉及了一些主题，例如Sparrow阶段，并概述了Sparrow API的工作方式。
- en: Now that we know how to draw objects on the screen, we're ready to learn about
    asset and scene management—which is the topic of the next chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在屏幕上绘制对象，我们准备学习关于资源和场景管理的内容——这是下一章的主题。
