<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer103">
<h1 class="chapterNumber">6</h1>
<h1 class="chapterTitle" id="_idParaDest-168">Software Design with Dependency Injection</h1>
<p class="normal">Having introduced navigation and the Shell in .NET MAUI, we’ve laid the groundwork for building a comprehensive application. However, we are currently utilizing a mock data service, which we intend to modify in this chapter. Before diving into this, let’s first review the best practices in software design, starting with an overview of design principles. Later, we will explore how to leverage dependency injection in our application.</p>
<p class="normal">Software design principles and patterns typically form the backbone of best practices in software design. These principles offer rules and guidelines that software designers adhere to in crafting an efficient and clean design structure. They play a key role in shaping the software design process as they dictate the most effective practices. Design patterns are effectively best practices that experienced developers in object-oriented software employ. They function as templates designed to address repetitive design problems in specific contexts, offering reusable solutions that can be applied to prevalent issues in software design.</p>
<p class="normal"><strong class="keyWord">Dependency Injection</strong> (<strong class="keyWord">DI</strong>) is<a id="_idIndexMarker450"/> a software design pattern and technique that ensures a class is not dependent on its dependencies. It achieves this through decoupling an object’s utilization from its creation. The goal here is to create a system that is more adaptable, modular, and simpler to debug and maintain. DI is embodied in <a id="_idIndexMarker451"/>the <strong class="keyWord">Dependency Inversion Principle (DIP)</strong>, one of the five SOLID principles in object-oriented programming and design.</p>
<p class="normal">In this chapter, we will explore the following topics:</p>
<ul>
<li class="bulletList">A brief overview of design principles</li>
<li class="bulletList">Implementing DI</li>
<li class="bulletList">Replacing the mock data store</li>
</ul>
<p class="normal">DI is a method<a id="_idIndexMarker452"/> for implementing the design principle of dependency inversion, also known as the DIP. The DIP is one of the SOLID design principles, and we will learn <a id="_idIndexMarker453"/>how to incorporate SOLID principles into our design process. An overview of the SOLID design principles will be provided at the beginning of this chapter, before delving into the discussion on DI.</p>
<h1 class="heading-1" id="_idParaDest-169">Technical requirements</h1>
<p class="normal">To test and debug the source code in this chapter, you need to have Visual Studio 2022 installed on your PC or Mac. Please refer to the <em class="italic">Development environment setup</em> section in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting Started with .NET MAUI</em>, for the details.</p>
<p class="normal">The source code for this chapter is available in the following branch on GitHub: <a href="https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/8067aa8a0ea9a275b33e64adaae7b09f7414851b"><span class="url">https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter06</span></a>.</p>
<p class="normal">To check out the source code of this chapter, we can use the below command:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>git <span class="hljs-con-built_in">clone</span> -b 2nd/chapter06 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition.git PassXYZ.Vault2
</code></pre>
<p class="normal">To find out more about the source code in this book, please refer to the <em class="italic">Managing the source code in this book</em> section in <em class="chapterRef">Chapter 2</em>,<em class="italic"> Building Our First .NET MAUI App</em>.</p>
<h1 class="heading-1" id="_idParaDest-170">A brief overview of design principles</h1>
<p class="normal">Design principles <a id="_idIndexMarker454"/>are high-level guidelines that offer valuable advice on design considerations. These principles can provide essential guidance to help you make better design decisions. Some general design principles are applicable not only to software design but also to other design disciplines.</p>
<p class="normal">Let’s review some general design principles before we explore the commonly used design principles (SOLID) in software development.</p>
<h2 class="heading-2" id="_idParaDest-171">Exploring types of design principles</h2>
<p class="normal">Design principles <a id="_idIndexMarker455"/>encompass a vast subject area. Thus, rather than delving into intricate details, I will provide insights from my experiences in implementing design principles during development, offering a concise overview of the principles discussed in this book. We will begin with high-level principles such as <strong class="keyWord">DRY</strong>, <strong class="keyWord">KISS</strong>, and <strong class="keyWord">YAGNI</strong>, and then progress to those more commonly used in software development. In the realm of <strong class="keyWord">object-oriented programming</strong> (<strong class="keyWord">OOP</strong>), the most widely used design principles are the SOLID principles.</p>
<h3 class="heading-3" id="_idParaDest-172">Don’t Repeat Yourself (DRY)</h3>
<p class="normal">As people<a id="_idIndexMarker456"/> often say, don’t reinvent the wheel; we <a id="_idIndexMarker457"/>should strive to reuse existing components instead of redeveloping what has already been created.</p>
<h3 class="heading-3" id="_idParaDest-173">Keep It Simple, Stupid (KISS)</h3>
<p class="normal">We <a id="_idIndexMarker458"/>should choose a simple and straightforward <a id="_idIndexMarker459"/>approach rather than involve unnecessary complexity in a design.</p>
<h3 class="heading-3" id="_idParaDest-174">You Aren’t Gonna Need It (YAGNI)</h3>
<p class="normal">We should<a id="_idIndexMarker460"/> implement functionality <a id="_idIndexMarker461"/>when it is required. In software development, there is a tendency to futureproof a design. This may create something that is actually not needed and increase the complexity of the solution.</p>
<h3 class="heading-3" id="_idParaDest-175">SOLID design principles</h3>
<p class="normal">SOLID design principles <a id="_idIndexMarker462"/>are widely employed in<a id="_idIndexMarker463"/> software development and serve as high-level guidelines for numerous design patterns. SOLID is an acronym that encapsulates the following five principles:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Single Responsibility Principle (SRP)</strong>: A class should have a single responsibility. Adhering<a id="_idIndexMarker464"/> to <a id="_idIndexMarker465"/>this design principle, a developer should have only one reason to modify a class. By considering this principle during implementation, the resulting code becomes easier to comprehend and more effectively adapts to evolving requirements.</li>
<li class="bulletList"><strong class="keyWord">Open/Closed Principle (OCP)</strong>: Classes should be open for extension but closed<a id="_idIndexMarker466"/> for modification. The<a id="_idIndexMarker467"/> central concept behind this principle is to prevent disruptions to existing code when introducing new features.</li>
<li class="bulletList"><strong class="keyWord">Liskov Substitution Principle (LSP)</strong>: If the object of the parent type can be used in a<a id="_idIndexMarker468"/> context, an <a id="_idIndexMarker469"/>object with a child type should also be able to function in the same manner without causing any errors or disruptions.</li>
<li class="bulletList"><strong class="keyWord">Interface Segregation Principle (ISP)</strong>: A design should not implement an interface <a id="_idIndexMarker470"/>that it doesn’t use, and<a id="_idIndexMarker471"/> a class should not be forced to depend on methods it doesn’t intend to implement. We should design concise and simple interfaces rather than large and complex ones.</li>
<li class="bulletList"><strong class="keyWord">Dependency Inversion Principle (DIP)</strong>: This principle emphasizes the decoupling of <a id="_idIndexMarker472"/>software modules. High-level modules should not depend on low-level modules<a id="_idIndexMarker473"/> directly. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</li>
</ul>
<p class="normal">Design principles <a id="_idIndexMarker474"/>are guidelines to help us to make better design decisions. However, the responsibility ultimately lies with us to determine the most suitable course of action during the actual implementation, rather than solely relying on these principles.</p>
<p class="normal">Since we will focus on the usage of DI in this chapter, please refer to the <em class="italic">Further reading</em> section to find more information about design principles (SOLID) and design patterns.</p>
<h2 class="heading-2" id="_idParaDest-176">Using design principles</h2>
<p class="normal">Having discussed <a id="_idIndexMarker475"/>various design principles, allow me to share insights and lessons learned from implementing them in practice.</p>
<p class="normal">In our app’s model, I utilized<a id="_idIndexMarker476"/> the <strong class="keyWord">KeePassLib</strong> from Dominik Reichl. While porting it to .NET Standard, I modified the inheritance hierarchy, as depicted in <em class="italic">Figure 6.1</em>:</p>
<figure class="mediaobject"><img alt="Figure 6.1: Class diagram of Item, PwEntry, and PwGroup" height="431" src="../Images/B21554_06_01.png" width="551"/></figure>
<p class="packt_figref">Figure 6.1: Class diagram of Item, PwEntry, and PwGroup</p>
<p class="normal">In the process<a id="_idIndexMarker477"/> of porting KeePassLib to .NET Standard, I developed an abstract parent class, <code class="inlineCode">Item</code>, for the group (<code class="inlineCode">PwGroup</code>) and entry (<code class="inlineCode">PwEntry</code>). This modification appears to violate OCP within the SOLID principles. The rationale behind this approach is rooted in a lesson I learned from the past implementation.</p>
<p class="normal">In earlier versions, prior to 1.2.3, I had not <a id="_idIndexMarker478"/>implemented <strong class="keyWord">KPCLib</strong> in the manner described. Instead, I directly used <code class="inlineCode">PwGroup</code> and <code class="inlineCode">PwEntry</code>, which required handling groups and entries separately. This resulted in increased complexity in <code class="inlineCode">ItemsPage</code> and <code class="inlineCode">ItemsViewModel</code>. This approach’s most significant consequence was the inability to distinctly separate the model and the view model. Consequently, I had to manage numerous details <a id="_idIndexMarker479"/>using <strong class="keyWord">KeePassLib</strong> directly within the view model. However, upon introducing the <code class="inlineCode">Item</code> abstract parent class, I successfully concealed most of the intricate implementation within services (<code class="inlineCode">IDataStore</code> and <code class="inlineCode">IUserService</code>) and <code class="inlineCode">PassXYZLib</code>. This led to the elimination of any code reliant on KeePassLib within the view and view model.</p>
<p class="normal">The inspiration behind this change came from the KISS principle rather than merely adhering to OCP. When considering other SOLID principles, such as LSP and SRP, this modification significantly improved the overall architecture. It’s essential to recognize that, in practical work, conflicts can arise among various design principles. It is ultimately our responsibility to make informed decisions instead of adhering dogmatically to design principles. The most effective design decisions typically arise from the insights gained from prior failures.</p>
<p class="normal">Returning to<a id="_idIndexMarker480"/> our main focus, we will now discuss enhancing the design by employing one of the SOLID principles—dependency inversion. As part of the SOLID design principles, dependency inversion emphasizes the separation of software modules, and it also provides guidelines on how to achieve this. The fundamental concept behind it is the preference of relying on abstractions whenever possible. In practice, DI is a technique routinely used to implement the idea of dependency inversion.</p>
<h1 class="heading-1" id="_idParaDest-177">Implementing DI</h1>
<p class="normal">DI is a<a id="_idIndexMarker481"/> technique that can be utilized in .NET MAUI. Although <a id="_idIndexMarker482"/>not a novel concept, it has been extensively employed in backend frameworks like ASP.NET Core and the Java Spring Framework. DI facilitates dependency inversion (DIP) by decoupling an object’s usage from its creation, eliminating the need for direct reliance on the object. In our app, once we have separated the <code class="inlineCode">IDataStore</code> interface implementation, we can commence with a mock implementation and subsequently replace it with the actual implementation.</p>
<p class="normal">In .NET MAUI, the <code class="inlineCode">Microsoft.Extensions.DependencyInjection</code> service, which we will refer to as MS.DI throughout this chapter, is readily available for us to utilize as a built-in feature.</p>
<p class="normal">In the realm of .NET, numerous DI containers are available besides MS.DI. Some of these alternatives, such as the Autofac DI container and the Simple Injector DI container, offer enhanced power and flexibility compared to MS.DI. At this point, one may wonder why we are choosing MS.DI over the other potent and adaptable DI containers. It is essential to revisit the KISS and YAGNI principles in this context. We should not opt for a more powerful solution with the assumption that we may utilize certain features in the future. Instead, the most straightforward and efficient approach is to leverage what we already possess without any additional effort.</p>
<p class="normal">With MS.DI, we<a id="_idIndexMarker483"/> can avoid introducing extra dependencies. Regardless of our intention to use it, it is already incorporated in the .NET MAUI configuration. By simply adding a few lines of code, we can enhance our design. Alternative DI containers may offer more sophisticated features, but we would need to include additional dependencies and perform the necessary configuration in our code before utilizing them. If you are working on a complex system design, it’s recommended to evaluate the available DI containers and select the most suitable one for your system. In our scenario, <strong class="keyWord">PassXYZ.Vault</strong> is a <a id="_idIndexMarker484"/>relatively straightforward app, and we will not directly benefit from the advanced DI features offered by Autofac or Simple Injector. The functionalities provided by MS.DI are adequate for our implementation.</p>
<p class="normal">In our app, the module we aim to decouple is the model layer, which derives from a third-party library provided by KeePass. As depicted in the package diagram in <em class="italic">Figure 6.2</em>, our system comprises three distinct assemblies: <strong class="keyWord">KPCLib</strong>, <strong class="keyWord">PassXYZLib</strong>, and <strong class="keyWord">PassXYZ.Vault</strong>.</p>
<figure class="mediaobject"><img alt="A diagram of a computer server  Description automatically generated" height="423" src="../Images/B21554_06_02.png" width="565"/></figure>
<p class="packt_figref">Figure 6.2: Package diagram</p>
<p class="normal">The <strong class="keyWord">KPCLib</strong> package <a id="_idIndexMarker485"/>encompasses <a id="_idIndexMarker486"/>two namespaces, <strong class="keyWord">KeePassLib</strong> and <strong class="keyWord">KPCLib</strong>. <strong class="keyWord">PassXYZLib</strong> serves<a id="_idIndexMarker487"/> as an extension package <a id="_idIndexMarker488"/>to augment the <strong class="keyWord">KPCLib</strong> package’s functionality using .NET MAUI-specific implementation. <strong class="keyWord">PassXYZ.Vault</strong>, our app, relies directly on the <strong class="keyWord">PassXYZLib</strong> package and<a id="_idIndexMarker489"/> indirectly on the <strong class="keyWord">KPCLib</strong> package. In accordance with the DI principle, we aim to establish dependencies on abstractions rather than concrete implementations. To achieve this, we have designed two interfaces, <code class="inlineCode">IDataStore</code> and <code class="inlineCode">IUserService</code>, which enable us to decouple from the actual implementations.</p>
<p class="normal">The actual implementations that require access to KPCLib and PassXYZLib are encapsulated in the classes that implement these two interfaces: <code class="inlineCode">IDataStore</code> and <code class="inlineCode">IUserService</code>. The remainder of the code needed to access the functionalities in <strong class="keyWord">KPCLib</strong> and <strong class="keyWord">PassXYZLib</strong> can utilize these two interfaces. The key point is that we always have the flexibility to replace the implementations of <code class="inlineCode">IDataStore</code> and <code class="inlineCode">IUserService</code> if necessary. The remaining code will not be affected by these changes.</p>
<p class="normal">In order to utilize MS.DI as a DI service, two primary steps are involved: registration and resolution.</p>
<p class="normal">Initially, we <a id="_idIndexMarker490"/>must register our interfaces (such as <code class="inlineCode">IDataStore</code>) and their corresponding implementations (such as <code class="inlineCode">MockDataStore</code>) during the program’s startup. Following that, we can utilize these registered interfaces throughout our program without manually creating them. We can then resolve these registered dependencies using the DI container.</p>
<p class="normal">The <code class="inlineCode">ServiceCollection</code> class serves as the means for registration, while the <code class="inlineCode">ServiceProvider</code> class facilitates resolution, as depicted in <em class="italic">Figure 6.3</em>:</p>
<figure class="mediaobject"><img alt="Figure 6.3: Usage of MS.DI" height="501" src="../Images/B21554_06_03.png" width="825"/></figure>
<p class="packt_figref">Figure 6.3: Usage of MS.DI</p>
<p class="normal"><em class="italic">Figure 6.3</em> presents a simplified class diagram of <code class="inlineCode">ServiceCollection</code> and <code class="inlineCode">ServiceProvider</code> at the top. <code class="inlineCode">ServiceCollection</code> serves as the default implementation of the <code class="inlineCode">IServiceCollection</code> interface, while <code class="inlineCode">ServiceProvider</code> acts as the default implementation of the <code class="inlineCode">IServiceProvider</code> interface.</p>
<p class="normal">These interfaces, <code class="inlineCode">IServiceCollection</code> and <code class="inlineCode">IServiceProvider</code>, allow us to register and resolve dependencies. At the bottom of <em class="italic">Figure 6.3</em>, there’s a sequence diagram illustrating how to use both interfaces to achieve this. For a clearer understanding, we’ll use the <code class="inlineCode">IDataStore</code> service as an example to explain the utilization of <code class="inlineCode">IServiceCollection</code> and <code class="inlineCode">IServiceProvider</code>.</p>
<p class="normal">To utilize DI for <a id="_idIndexMarker491"/>implementing the <code class="inlineCode">IDataStore</code> service, we can follow the steps outlined in the subsequent code block:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Registration</span>
<span class="hljs-keyword">var</span> services = <span class="hljs-keyword">new</span> ServiceCollection();                           <span class="hljs-comment">//(1</span><span class="hljs-comment">)</span>
services.AddSingleton &lt;IDataStore&lt;Item&gt;, MockDataStore&gt;();        <span class="hljs-comment">//(2)</span>
<span class="hljs-comment">// Resolution</span>
ServiceProvider provider =
    services.BuildServiceProvider(validateScopes: <span class="hljs-literal">true</span>);            <span class="hljs-comment">//(3)</span>
IDataStore&lt;Item&gt; dataStore =
    provider.GetRequiredService&lt;IDataStore&lt;Item&gt;&gt;();                <span class="hljs-comment">//(4)</span>
</code></pre>
<p class="normal"><strong class="keyWord">(1)</strong> To begin, we must first create an instance of the <code class="inlineCode">ServiceCollection</code> class that implements the <code class="inlineCode">IServiceCollection</code> interface.</p>
<p class="normal"><strong class="keyWord">(2)</strong> The <code class="inlineCode">IServiceCollection</code> interface does not inherently specify any methods. Instead, a collection of extension methods is defined in the MS.DI namespace. Among these, the <code class="inlineCode">AddSingleton</code> extension method can be utilized to register the concrete <code class="inlineCode">MockDataStore</code> class that implements the <code class="inlineCode">IDataStore</code> interface. The method <code class="inlineCode">AddSingleton</code> is explained in the following section. This method employs a generic type to specify both the interface and its implementation. Additionally, there are several overloaded variations of the <code class="inlineCode">AddSingleton</code> extension method at your disposal.</p>
<p class="normal"><strong class="keyWord">(3)</strong> In order to access objects, we can obtain an instance of <code class="inlineCode">ServiceProvider</code> by invoking the <code class="inlineCode">BuildServiceProvider</code> extension method associated with <code class="inlineCode">IServiceCollection</code>. The <code class="inlineCode">ServiceProvider</code> class complies with the <code class="inlineCode">IServiceProvider</code> interface. Notably, the <code class="inlineCode">IServiceProvider</code> interface is located within the <code class="inlineCode">System</code> namespace and exclusively defines the <code class="inlineCode">GetService</code> method. Additional methods are designated as extension methods and can be found in the <code class="inlineCode">Microsoft.Extensions.DependencyInjection</code> namespace, as illustrated in <em class="italic">Figure 6.3</em>.</p>
<p class="normal"><strong class="keyWord">(4)</strong> Once we have an instance of <code class="inlineCode">ServiceProvider</code>, we can resolve the <code class="inlineCode">IDataStore</code> interface using the <code class="inlineCode">GetRequiredService</code> extension method.</p>
<p class="normal">To manage the scope of a service, we can resolve it within the scope as follows:</p>
<pre class="programlisting code"><code class="hljs-code">IServiceScope scope = provider.CreateScope();
IDataStore&lt;Item&gt; dataStore = scope.ServiceProvider
    .GetRequiredService&lt;IDataStore&lt;Item&gt;&gt;();
</code></pre>
<p class="normal">We will discuss the scope in the next section.</p>
<p class="normal">Though<a id="_idIndexMarker492"/> MS.DI is a lightweight DI service, it offers a sufficient range of features for .NET MAUI applications, as outlined below:</p>
<ul>
<li class="bulletList">Lifetime management of instances</li>
<li class="bulletList">Constructor, method, and property injections</li>
</ul>
<p class="normal">In the upcoming sections, we will delve deeper into these features.</p>
<h2 class="heading-2" id="_idParaDest-178">Lifetime management</h2>
<p class="normal">When using DI, you <a id="_idIndexMarker493"/>should consider how long instances of a registered service should be reused or retained before they are disposed of or new instances are created. Lifetime management is crucial in defining the scope within which a service instance is generated and shared.</p>
<p class="normal">Here are a few aspects to consider for lifecycle management:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Resource management</strong>: Resources, such <a id="_idIndexMarker494"/>as database connections utilized by a service, should not be left open indefinitely. For example, if a singleton service keeps a database connection open, it holds that resource for the application’s lifespan.</li>
<li class="bulletList"><strong class="keyWord">Performance</strong>: It might <a id="_idIndexMarker495"/>not always be the most efficient approach to create a new instance of a service each time it’s needed, particularly if constructing the service is resource-intensive.</li>
<li class="bulletList"><strong class="keyWord">Isolation</strong>: If your<a id="_idIndexMarker496"/> service requires isolation (for instance, if it maintains some state), it’s essential to configure its lifecycle in accordance with the scope that satisfies such isolation requirements.</li>
<li class="bulletList"><strong class="keyWord">Threading issues</strong>: Singleton services need to be thread-safe as they’re shared among <a id="_idIndexMarker497"/>different requests, usually processed in parallel on separate threads.</li>
</ul>
<p class="normal">Using MS.DI, we can manage the lifespan of these instances by configuring the <code class="inlineCode">ServiceCollection</code>.</p>
<p class="normal">There are commonly three types of lifetimes in dependency injection, and we can configure them<a id="_idIndexMarker498"/> using extension methods:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Singleton</strong>: A<a id="_idIndexMarker499"/> single instance of the service is created when requested for the first time and then reused for all subsequent requests throughout the application’s lifetime. All callers receive the same instance, meaning a singleton service behaves like a shared global resource. Singleton services can retain state and are useful for providing centralized management of resources, such as logging, caching, or configuration. The extension method <code class="inlineCode">AddSingleton</code> can be used to create a single instance throughout the life of the application.</li>
<li class="bulletList"><strong class="keyWord">Scoped</strong>: A <a id="_idIndexMarker500"/>scoped service creates a new instance per scope, typically per request in a web application. Each scope has its instance of the service, which is shared among all components within that specific scope. Scoped services are useful for maintaining state specific to a single request or user interaction, such as user information, request details, or database connections in a per-request context. The extension method <code class="inlineCode">AddScoped</code> can be used to create one instance and reuses the same instance within the defined scope.</li>
<li class="bulletList"><strong class="keyWord">Transient</strong>: Transient services<a id="_idIndexMarker501"/> create a new instance each time the service is requested, ensuring that each caller gets a unique instance without sharing state or resources. Transient services are useful for services without an internal state or a need for resource management. They are often lightweight and don’t require sharing across different components. The extension method <code class="inlineCode">AddTransient</code> can be used to create an instance for each call.</li>
</ul>
<p class="normal">In order to illustrate<a id="_idIndexMarker502"/> the lifetime management of MS.DI, let’s examine the following code snippet in conjunction with <em class="italic">Figure 6.4</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> services = <span class="hljs-keyword">new</span> ServiceCollection();
services.AddSingleton&lt; IUserService&lt;User&gt;, UserService&gt;();         <span class="hljs-comment">//(1)</span>
services.AddScoped&lt;IDataStore&lt;Item&gt;, DataStore&gt;();                 <span class="hljs-comment">//(1)</span>
services.AddTransient&lt;ItemsViewModel&gt;();                           <span class="hljs-comment">//(1)</span>
ServiceProvider rootContainer =
    services.BuildServiceProvider(validateScopes: <span class="hljs-literal">true</span>);           <span class="hljs-comment">//(2)</span>
<span class="hljs-keyword">var</span> userService =
    rootContainer.GetRequiredService&lt;IUserService&lt;User&gt;&gt;();
IServiceScope scope1 = rootContainer.CreateScope();                <span class="hljs-comment">//(3)</span>
IDataStore&lt;Item&gt; dataStore1 =
  scope1.ServiceProvider.GetRequiredService&lt;IDataStore&lt;Item&gt;&gt;();
IServiceScope scope2 = rootContainer.CreateScope();                <span class="hljs-comment">//(3)</span>
IDataStore&lt;Item&gt; dataStore2 = Scope2.ServiceProvider.  GetRequiredService&lt;IDataStore&lt;Item&gt;&gt;();
</code></pre>
<p class="normal">In the<a id="_idIndexMarker503"/> aforementioned code, in the lines marked by <strong class="keyWord">(1)</strong>, we registered <code class="inlineCode">IUserService</code> as a <code class="inlineCode">Singleton </code>object, <code class="inlineCode">IDataStore</code> as a <code class="inlineCode">Scoped</code> object, and <code class="inlineCode">ItemsViewModel</code> as a <code class="inlineCode">Transient</code> object.</p>
<p class="normal">Following the <a id="_idIndexMarker504"/>registration, in the line marked by <strong class="keyWord">(2)</strong>, we instantiated a <code class="inlineCode">ServiceProvider</code> and stored it in a <code class="inlineCode">rootContainer</code> variable. In the lines marked by <strong class="keyWord">(3)</strong>, utilizing the <code class="inlineCode">rootContainer</code>, we generated two scopes, named <strong class="keyWord">scope1</strong> and <strong class="keyWord">scope2</strong>. </p>
<p class="normal">The lifetime management of these created objects can be examined in <em class="italic">Figure 6.4</em>:</p>
<figure class="mediaobject"><img alt="A diagram of a software application  Description automatically generated" height="762" src="../Images/B21554_06_04.png" width="825"/></figure>
<p class="packt_figref">Figure 6.4: Lifetime management in MS.DI</p>
<p class="normal">The<a id="_idIndexMarker505"/> variable<strong class="keyWord"> </strong><code class="inlineCode">userService</code> is created as a <code class="inlineCode">Singleton</code> object, ensuring<a id="_idIndexMarker506"/> that only one instance exists, and its lifetime is equal to that of the application. The two scopes—namely, <strong class="keyWord">scope1</strong> and <strong class="keyWord">scope2</strong>—possess distinct lifetimes determined by our design. The <code class="inlineCode">Scoped</code> objects—<strong class="keyWord">dataStore1</strong> and <strong class="keyWord">dataStore2</strong>—have the same lifetime as the scope to which they belong. Meanwhile, the instances of <code class="inlineCode">ItemViewModel</code> are <code class="inlineCode">Transient</code> objects.</p>
<p class="normal">In the case of the three methods—<code class="inlineCode">AddSingleton</code>, <code class="inlineCode">AddScoped</code>, and <code class="inlineCode">AddTransient</code>—numerous overloaded variations have been defined to cater to an array of requirements pertaining to <code class="inlineCode">ServiceCollection</code> configuration.</p>
<p class="normal">In our <a id="_idIndexMarker507"/>application, we have two versions of the <code class="inlineCode">IDataStore</code> interface implementation:</p>
<ul>
<li class="bulletList"><code class="inlineCode">DataStore</code>: This version represents the actual implementation. </li>
<li class="bulletList"><code class="inlineCode">MockDataStore</code>: This version is employed for testing purposes.</li>
</ul>
<p class="normal">With MS.DI, we <a id="_idIndexMarker508"/>have the ability to utilize <code class="inlineCode">MockDataStore</code> in the Debug build and employ <code class="inlineCode">DataStore</code> in the Release build. This configuration can be executed as demonstrated in the subsequent code snippet:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">bool</span> isDebug = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">var</span> services = <span class="hljs-keyword">new</span> ServiceCollection();
services.AddSingleton&lt;DataStore, DataStore&gt;();
services.AddSingleton&lt;MockDataStore, MockDataStore&gt;();
services.AddSingleton&lt;IDataStore&lt;Item&gt;&gt;(c =&gt; {
    <span class="hljs-keyword">if</span> (isDebug)
    {
        <span class="hljs-keyword">return</span> c.GetRequiredService&lt;MockDataStore&gt;();
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span> c.GetRequiredService&lt;DataStore&gt;();
    }
});
</code></pre>
<p class="normal">In the code snippet mentioned earlier, we are able to set up concrete classes, <code class="inlineCode">DataStore</code> and <code class="inlineCode">MockDataStore</code>, and the interface <code class="inlineCode">IDataStore</code> for distinct build configurations. When configuring <code class="inlineCode">IDataStore</code>, a delegate can be employed to resolve the object. The <code class="inlineCode">isDebug</code> variable may be adjusted using build configurations, enabling it to be set as true or false, depending on whether the build is for debugging or release purposes.</p>
<h2 class="heading-2" id="_idParaDest-179">Configuring DI in .NET MAUI</h2>
<p class="normal">MS.DI is incorporated into the .NET release, making it accessible for all types of applications<a id="_idIndexMarker509"/> in .NET 5 or subsequent versions. As we discussed in the previous section, we can implement DI using <code class="inlineCode">ServiceCollection</code> and <code class="inlineCode">ServiceProvider</code>. However, there is a more straightforward approach to utilizing MS.DI in .NET MAUI. With DI integrated as part of the .NET Generic Host configuration, there is no need for us to create an instance of <code class="inlineCode">ServiceCollection</code> manually. This allows us to employ the preconfigured DI service directly, without any additional effort.</p>
<p class="normal">To gain a deeper understanding of the preconfigured DI service in .NET MAUI, let’s revisit the .NET MAUI application startup process as depicted in <em class="italic">Figure 6.5</em>. This figure encompasses both a class diagram and a sequence diagram, illustrating the classes involved in the process.</p>
<p class="normal">Please be<a id="_idIndexMarker510"/> aware that the number in <em class="italic">Figure 6.5</em> represents the type of object (<strong class="keyWord">(1)</strong> = MauiProgram, <strong class="keyWord">(2)</strong> = MauiApp, and <strong class="keyWord">(3)</strong> = MauiAppBuilder):</p>
<figure class="mediaobject"><img alt="A diagram of a program  Description automatically generated" height="586" src="../Images/B21554_06_05.png" width="825"/></figure>
<p class="packt_figref">Figure 6.5: .NET MAUI DI configuration</p>
<p class="normal">In <em class="italic">Figure 6.5</em>, at the top, we observe that the initiation of the .NET MAUI application involves four different classes:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Platform entry point</strong>: The initiation of the .NET MAUI application occurs in platform-specific code. For the .NET MAUI project, this can be found in the <strong class="keyWord">Platforms</strong> folder. Distinct classes have been defined for each platform, as illustrated in <em class="italic">Table 6.1</em>. In <em class="italic">Figure 6.5</em>, we use the <code class="inlineCode">MauiApplication</code> Android version as a representative example.
    <table class="table-container" id="table001-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Platform</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Entry point class</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Implement Interface</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Android</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">MauiApplication</code></p>
</td>
<td class="table-cell" rowspan="3">
<p class="normal"><code class="inlineCode">IPlatformApplication</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">iOS/macOS</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">MauiUIApplicationDelegate</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Windows</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">MauiWinUIApplication</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.1: Entry points in different platforms</p>
<p class="normal">All <a id="_idIndexMarker511"/>entry-point classes implement the <code class="inlineCode">IPlatformApplication</code> interface, as we can see in the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPlatformApplication</span>
{
    <span class="hljs-keyword">static</span> IPlatformApplication? Current { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    IServiceProvider Services { <span class="hljs-keyword">get</span>; }
    IApplication Application { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<p class="normal">The <code class="inlineCode">IPlatformApplication</code> interface defines a property called <code class="inlineCode">Services</code>, which is of the type <code class="inlineCode">IServiceProvider</code>. Once the application is initialized, this property can be utilized directly to resolve DI objects.</p>
<p class="normal">All platform entry-point classes also implement an override method, <code class="inlineCode">CreateMauiApp</code>, which calls the static method <code class="inlineCode">CreateMauiApp</code> defined in the <code class="inlineCode">MauiProgram</code> class. Please refer to the following code, <em class="italic">Table 6.1</em>, and <em class="italic">Figure 6.5</em>.</p></li>
</ul>
<ul>
<li class="bulletList"><code class="inlineCode">MauiProgram</code> <strong class="keyWord">(1)</strong>: In the subsequent <code class="inlineCode">MauiProgram</code> implementation code, it becomes apparent that every .NET MAUI application must define a static <code class="inlineCode">MauiProgram</code> class and include a <code class="inlineCode">CreateMauiApp</code> method. The <code class="inlineCode">CreateMauiApp</code> method gets called by an override function, which is present in all platform entry points. This override function ultimately returns a <code class="inlineCode">MauiApp</code> instance:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protected</span><span class="hljs-function"> </span><span class="hljs-keyword">override</span><span class="hljs-function"> MauiApp</span>
<span class="hljs-function">    </span><span class="hljs-title">CreateMauiApp</span><span class="hljs-function">()</span> =&gt; MauiProgram.CreateMauiApp();
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">MauiApp</code> <strong class="keyWord">(2)</strong>: Inside <code class="inlineCode">CreateMauiApp</code>, it creates a <code class="inlineCode">MauiAppBuilder</code> instance by calling the function <code class="inlineCode">MauiApp.CreateBuilder</code>.</li>
<li class="bulletList"><code class="inlineCode">MauiAppBuilder</code> <strong class="keyWord">(3)</strong>: <code class="inlineCode">MauiAppBuilder</code> incorporates an attribute called <code class="inlineCode">Services</code>, which is of the <code class="inlineCode">IServiceCollection</code> interface type. This attribute allows us to configure DI for the .NET MAUI application.</li>
</ul>
<p class="normal">Based <a id="_idIndexMarker512"/>on the above analysis of the .NET MAUI app startup process, it is apparent that both <code class="inlineCode">IServiceCollection</code> and <code class="inlineCode">IServiceProvider</code> are initialized during this procedure. As a result, we can conveniently utilize them without the need for additional configuration.</p>
<p class="normal">The <code class="inlineCode">MauiProgram</code> implementation can be observed in the code provided below. Here, we have registered interfaces—<code class="inlineCode">IDataStore</code> and <code class="inlineCode">IUserService</code>—as well as multiple classes including <code class="inlineCode">LoginService</code>, view models, and pages. It is important to note that all of these components are singleton objects, except for <code class="inlineCode">ItemsViewModel</code> and <code class="inlineCode">ItemsPage</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MauiProgram</span> {                                 <span class="hljs-comment">//(1)</span>
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">static</span><span class="hljs-function"> MauiApp </span><span class="hljs-title">CreateMauiApp</span><span class="hljs-function">()</span> {                         <span class="hljs-comment">//(2)</span>
    <span class="hljs-keyword">var</span> builder = MauiApp.CreateBuilder();                        <span class="hljs-comment">//(3)</span>
    builder
      .UseMauiApp&lt;App&gt;()
      .ConfigureFonts(fonts =&gt; {
        fonts.AddFont(<span class="hljs-string">"fa-regular-400.ttf"</span>,
            <span class="hljs-string">"FontAwesomeRegular"</span>);
        fonts.AddFont(<span class="hljs-string">"fa-solid-900.ttf"</span>,
            <span class="hljs-string">"FontAwesomeSolid"</span>);
        fonts.AddFont(<span class="hljs-string">"fa-brands-400.ttf"</span>,
            <span class="hljs-string">"FontAwesomeBrands"</span>);
        fonts.AddFont(<span class="hljs-string">"OpenSans-Regular.ttf"</span>,
            <span class="hljs-string">"OpenSansRegular"</span>);
        fonts.AddFont(<span class="hljs-string">"OpenSans-SemiBold.ttf"</span>,
            <span class="hljs-string">"OpenSansSemiBold"</span>);
      });
<span class="hljs-meta">#</span><span class="hljs-keyword">if</span><span class="hljs-meta"> DEBUG</span>
    builder.Logging.AddDebug();
    builder.Logging.SetMinimumLevel(LogLevel.Debug);
<span class="hljs-meta">#</span><span class="hljs-keyword">endif</span>
    builder.Services.AddSingleton&lt;IDataStore&lt;Item&gt;, DataStore&gt;();
    builder.Services.AddSingleton&lt;IUserService&lt;User&gt;, UserService&gt;();
    builder.Services.AddSingleton&lt;LoginService&gt;();
    builder.Services.AddSingleton&lt;LoginViewModel&gt;();
    builder.Services.AddSingleton&lt;LoginPage&gt;();
    builder.Services.AddSingleton&lt;SignUpPage&gt;();
    builder.Services.AddSingleton&lt;ItemDetailViewModel&gt;();
    builder.Services.AddSingleton&lt;ItemDetailPage&gt;();
    builder.Services.AddSingleton&lt;NewItemViewModel&gt;();
    builder.Services.AddSingleton&lt;NewItemPage&gt;();
    builder.Services.AddSingleton&lt;AboutViewModel&gt;();
    builder.Services.AddSingleton&lt;AboutPage&gt;();
    builder.Services.AddTransient&lt;ItemsViewModel&gt;();
    builder.Services.AddTransient&lt;ItemsPage&gt;();
    <span class="hljs-keyword">return</span> builder.Build();  }
}
</code></pre>
<p class="normal">After <a id="_idIndexMarker513"/>configuring DI for interfaces and classes, we can utilize them in our implementation. The <code class="inlineCode">IServiceProvider</code> interface enables us to resolve objects effectively. When implementing DI, there are three primary methods for injecting dependencies: constructor injection, method injection, and property injection. In the subsequent sections, we will explore how to apply these methods to our programming.</p>
<h2 class="heading-2" id="_idParaDest-180">Constructor injection</h2>
<p class="normal">With<a id="_idIndexMarker514"/> constructor injection, the necessary dependencies for a class are supplied as arguments to the constructor, allowing us to resolve<a id="_idIndexMarker515"/> dependencies using the constructor itself. In the code-behind of <code class="inlineCode">ItemsPage</code>, <code class="inlineCode">ItemsPage</code> relies on its view model, <code class="inlineCode">ItemsViewModel</code>. We can establish the constructor of <code class="inlineCode">ItemsPage</code> as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemsPage</span> : <span class="hljs-title">ContentPage</span> {
  ItemsViewModel viewModel;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ItemsPage</span><span class="hljs-function">(</span><span class="hljs-params">ItemsViewModel viewModel</span><span class="hljs-function">)</span> {
    InitializeComponent();
    BindingContext = <span class="hljs-keyword">this</span>.viewModel = viewModel;
  }
  <span class="hljs-keyword">protected</span><span class="hljs-function"> </span><span class="hljs-keyword">override</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnAppearing</span><span class="hljs-function">()</span> {
    <span class="hljs-keyword">base</span>.OnAppearing();
    viewModel.OnAppearing();
  }
}
</code></pre>
<p class="normal">In the <code class="inlineCode">ItemsPage</code> constructor, we inject the dependency through the argument <code class="inlineCode">viewModel</code>. In this instance, MS.DI resolves <code class="inlineCode">viewModel</code> according to the configuration defined in <code class="inlineCode">MauiProgram</code>.</p>
<p class="normal">Constructor injection is<a id="_idIndexMarker516"/> the most common and <a id="_idIndexMarker517"/>most advised form of DI because the object always gets created with the required dependencies. The biggest advantage is that it makes dependencies explicit, and the object never exists in an incomplete state.</p>
<p class="normal">Often, it may not be feasible to inject dependencies through the constructor, such as when a class comprises optional dependencies or when there’s a need to alter dependencies dynamically. In these circumstances, utilizing method injection or property injection would be the recommended approach.</p>
<h2 class="heading-2" id="_idParaDest-181">Method injection</h2>
<p class="normal">Instead <a id="_idIndexMarker518"/>of using constructor injection to provide required <a id="_idIndexMarker519"/>dependencies when the object is instantiated, method injection passes the dependencies directly to the methods that use them. Method injection is a technique in DI where dependencies are provided to an object through method parameters.</p>
<p class="normal">In our code, we can set up dependencies through a method instead of a constructor, as illustrated in the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.ViewModels</span> {
  [<span class="hljs-meta">QueryProperty(nameof(ItemId), nameof(ItemId))</span>]
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemsViewModel</span> : <span class="hljs-title">BaseViewModel</span> {
    <span class="hljs-keyword">readonly</span> IDataStore&lt;Item&gt; dataStore;
    ILogger&lt;ItemsViewModel&gt; logger;
    <span class="hljs-keyword">public</span> ObservableCollection&lt;Item&gt; Items { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ItemsViewModel</span><span class="hljs-function">(</span><span class="hljs-params">ILogger&lt;ItemsViewModel&gt; logger</span><span class="hljs-function">)</span> {
        <span class="hljs-keyword">this</span>.logger = logger;
        Items = <span class="hljs-keyword">new</span> ObservableCollection&lt;Item&gt;();
    }
    
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">SetDataStore</span><span class="hljs-function">(</span><span class="hljs-params">IDataStore&lt;Item&gt; store</span><span class="hljs-function">)</span> {
      <span class="hljs-keyword">this</span>.dataStore = store;
    }
    
...
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task </span><span class="hljs-title">AddItem</span><span class="hljs-function">(</span><span class="hljs-params">Item item</span><span class="hljs-function">)</span> {
      <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) {
        logger.LogDebug(<span class="hljs-string">"Item cannot be null"</span>);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">await</span> dataStore.AddItemAsync(item);
   }
    
    ...
  }
}
</code></pre>
<p class="normal">In this<a id="_idIndexMarker520"/> example, <code class="inlineCode">IDataStore</code> is set using the method <code class="inlineCode">SetDataStore</code> instead of being injected through the constructor. However, it has a disadvantage where the dependent object might forget to set the dependency. As a result, the object can exist in an incomplete state.</p>
<p class="normal">In the code example<a id="_idIndexMarker521"/> provided, using method injection enables us to utilize both the actual and mock DataStore implementations within the same code. Method injection also allows for more fine-grained control over when dependencies are created, passed, and disposed of compared to constructor injection. However, it can also make the method’s call more complex since the caller is responsible for providing the dependencies as parameters. </p>
<p class="normal">In general, constructor injection is often preferred for simplicity and better encapsulation, but method injection can be valuable for specific use cases.</p>
<h2 class="heading-2" id="_idParaDest-182">Property injection</h2>
<p class="normal">In <a id="_idIndexMarker522"/>property injection, dependencies are set through properties. Generally, method and property injection can be used to replace each other. It<a id="_idIndexMarker523"/> is similar to method injection—in numerous situations, we might be unable to utilize constructor injection, so we have to use method or property injection. The issue with method or property injection is that the dependent object might forget to set the dependency, so the object can exist in an incomplete state.</p>
<p class="normal">This <a id="_idIndexMarker524"/>problem can be partially mitigated through the use of attributes or annotations in object-oriented languages, an approach we will explore later.</p>
<p class="normal">In .NET MAUI, we <a id="_idIndexMarker525"/>can resolve the dependencies through <code class="inlineCode">IServiceProvider</code>. Within a .NET MAUI application, the hosting environment generates an <code class="inlineCode">IServiceProvider</code> interface for us, as demonstrated in <em class="italic">Figure 6.5</em>. </p>
<p class="normal">To obtain the <code class="inlineCode">IServiceProvider</code> interface, we can employ the <code class="inlineCode">IPlatformApplication</code> interface defined in the platform-specific entry points, as depicted in <em class="italic">Listing 6.1</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Services</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHelper</span>
{
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">static</span><span class="hljs-function"> TService </span><span class="hljs-title">GetService</span><span class="hljs-function">&lt;</span><span class="hljs-title">TService</span><span class="hljs-function">&gt;()</span>
        =&gt; Current.GetService&lt;TService&gt;();                        <span class="hljs-comment">//(2)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceProvider Current =&gt;                     <span class="hljs-comment">//(1)</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">if</span><span class="hljs-meta"> WINDOWS10_0_17763_0_OR_GREATER</span>
        MauiWinUIApplication.Current.Services;
<span class="hljs-meta">#</span><span class="hljs-keyword">elif</span><span class="hljs-meta"> ANDROID</span>
        MauiApplication.Current.Services;
<span class="hljs-meta">#</span><span class="hljs-keyword">elif</span><span class="hljs-meta"> IOS || MACCATALYST</span>
        MauiUIApplicationDelegate.Current.Services;
<span class="hljs-meta">#</span><span class="hljs-keyword">else</span>
        <span class="hljs-literal">null</span>;
<span class="hljs-meta">#</span><span class="hljs-keyword">endif</span>
}
</code></pre>
<p class="packt_figref">Listing 6.1: <code class="inlineCode">ServiceHelper.cs</code> (<a href="https://epa.ms/ServiceHelper6-1"><span class="url">https://epa.ms/ServiceHelper6-1</span></a>)</p>
<p class="normal"><strong class="keyWord">(1)</strong> In the <code class="inlineCode">ServiceHelper</code> class, we define a static variable called <code class="inlineCode">Current</code>, which maintains a reference to the <code class="inlineCode">IServiceProvider</code>. We can obtain the <code class="inlineCode">IServiceProvider</code> through the <code class="inlineCode">Services</code> property of the <code class="inlineCode">IPlatformApplication</code> interface.</p>
<p class="normal"><strong class="keyWord">(2)</strong> A <code class="inlineCode">GetService</code> static method is defined, which, in turn, invokes the <code class="inlineCode">GetService</code> method of the <code class="inlineCode">IServiceProvider</code> interface.</p>
<div class="note">
<p class="normal"><strong class="keyWord">ServiceHelper</strong></p>
<p class="normal">For the <strong class="keyWord">ServiceHelper</strong> implementation, I referred to the <strong class="keyWord">MauiApp-DI</strong> GitHub project. Thanks to James Montemagno for the sample code on GitHub!</p>
<p class="normal">(<a href="https://github.com/jamesmontemagno/MauiApp-DI"><span class="url">https://github.com/jamesmontemagno/MauiApp-DI</span></a>)</p>
</div>
<p class="normal">By utilizing the <code class="inlineCode">ServiceHelper</code> class, we can obtain an instance of <code class="inlineCode">IDataStore</code>, as demonstrated below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IDataStore&lt;Item&gt; DataStore =&gt;
           ServiceHelper.GetService&lt;IDataStore&lt;Item&gt;&gt;();
</code></pre>
<p class="normal">You <a id="_idIndexMarker526"/>might notice that the property injection code provided earlier appears less elegant when compared to constructor injection. We have to set the dependencies manually. In the worst case, the object can exist in an incomplete state.</p>
<p class="normal">As of now, I have <a id="_idIndexMarker527"/>not discovered a more efficient method for implementing this in .NET MAUI. Nonetheless, in the subsequent sections of this book, when we introduce the Blazor Hybrid app, we will be able to utilize C# attributes to address property injection more effectively. To resolve the <code class="inlineCode">IDataStore</code> interface in Blazor, a more straightforward approach can be employed, which is demonstrated in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">Inject</span>]
<span class="hljs-keyword">public</span> IDataStore&lt;Item&gt; DataStore { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
</code></pre>
<p class="normal">We can use the <code class="inlineCode">Inject</code> C# attribute to implicitly resolve dependencies without explicitly invoking the <code class="inlineCode">GetService</code> method from the <code class="inlineCode">ServiceHelper</code>.</p>
<p class="normal">By employing DI, we can seamlessly substitute the mock implementation of the <code class="inlineCode">IDataStore</code> interface with the actual one. This implementation can facilitate the CRUD operations of the password database. In the upcoming section, we will examine this new class in greater detail.</p>
<h1 class="heading-1" id="_idParaDest-183">Replacing the mock data store</h1>
<p class="normal">As explored <a id="_idIndexMarker528"/>in previous sections, we can register the implementation of data store services in <code class="inlineCode">MauiProgram.cs</code> as follows:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddSingleton&lt;IDataStore&lt;Item&gt;, MockDataStore&gt;();
builder.Services.AddSingleton&lt;IUserService&lt;User&gt;, UserService&gt;();
</code></pre>
<p class="normal">In the above code snippet, we receive an instance of <code class="inlineCode">MockDataStore</code> for the <code class="inlineCode">IDataStore</code> interface. This is a mock implementation to simplify the initial development. Now, it’s time to substitute this with the actual implementation. We will replace the above code with the following:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddSingleton&lt;IDataStore&lt;Item&gt;, DataStore&gt;();
builder.Services.AddSingleton&lt;IUserService&lt;User&gt;, UserService&gt;();
</code></pre>
<p class="normal">Here, <code class="inlineCode">DataStore</code> is the actual implementation of the <code class="inlineCode">IDataStore</code> service, which we will fully implement in the remainder of this chapter.</p>
<p class="normal">The<a id="_idIndexMarker529"/> password database is a local database in the KeePass 2.x format. Within this database, password information is organized into groups and entries. The <code class="inlineCode">KeePassLib</code> namespace contains a <code class="inlineCode">PwDatabase</code> class, which is designed to manage database operations. </p>
<p class="normal">To comprehend the relationship between <code class="inlineCode">PwDatabase</code>, <code class="inlineCode">PwGroup</code>, and <code class="inlineCode">PwEntry</code>, we can refer to the class diagram in <em class="italic">Figure 6.6</em>:</p>
<figure class="mediaobject"><img alt="Figure 6.6: Class diagram of KeePass database" height="463" src="../Images/B21554_06_06.png" width="825"/></figure>
<p class="packt_figref">Figure 6.6: Class diagram of KeePass database</p>
<p class="normal">In <strong class="keyWord">PwDatabase</strong>, the <strong class="keyWord">RootGroup</strong> property<a id="_idIndexMarker530"/> of type <strong class="keyWord">PwGroup</strong> is defined, which<a id="_idIndexMarker531"/> contains all groups and <a id="_idIndexMarker532"/>entries stored in the database. The data structure of the KeePass database can be navigated from <strong class="keyWord">RootGroup</strong> to a specific entry. <strong class="keyWord">PwEntry</strong> defines<a id="_idIndexMarker533"/> a set of standard fields, as illustrated in <em class="italic">Figure 6.7</em>:</p>
<figure class="mediaobject"><img alt="A screenshot of a phone  Description automatically generated" height="909" src="../Images/B21554_06_07.png" width="826"/></figure>
<p class="packt_figref">Figure 6.7: Group, entry, and field</p>
<p class="normal">If we possess a list of entries containing only standard fields, it will resemble a table. In <em class="italic">Figure 6.7</em>, the current group consists of five entries (<strong class="screenText">GitHub</strong>, <strong class="screenText">Google</strong>, <strong class="screenText">Facebook</strong>, <strong class="screenText">Instagram</strong>, and <strong class="screenText">Chase Bank</strong>) along with a sub-group (<strong class="screenText">Cloud</strong>). On the left, a screenshot of the <code class="inlineCode">ItemsPage</code> displays the items within the current group. If the <strong class="screenText">Google</strong> item is selected, it will appear as an entry in the screenshot on the right side. Users have the option to add extra fields to the entry, making the KeePass database dissimilar to a relational database; it is more akin to a key-value database. Each field consists of a key-value pair, such as a URL field.</p>
<p class="normal">In order to <a id="_idIndexMarker534"/>utilize <code class="inlineCode">PwDatabase</code> in our application, we have defined a derived class called <code class="inlineCode">PxDatabase</code>. This class introduces additional properties and methods, such as <code class="inlineCode">CurrentGroup</code>, <code class="inlineCode">DeleteGroup</code>, <code class="inlineCode">DeleteEntry</code>, and more.</p>
<p class="normal">To access a database, one can open the database file and perform CRUD operations on it. However, when building a cross-platform app, handling the database file directly may not be convenient for the end users. In <strong class="keyWord">PassXYZ.Vault</strong>, the<a id="_idIndexMarker535"/> concept of users is employed rather than using a data file. Within <strong class="keyWord">PassXYZLib</strong>, a <code class="inlineCode">User</code> class has<a id="_idIndexMarker536"/> been defined to encapsulate the underlying file operations.</p>
<p class="normal">In order to access the database, we have defined database initialization and CRUD operations within the <code class="inlineCode">IDataStore</code> and <code class="inlineCode">IUserService</code> interfaces. The <code class="inlineCode">DataStore</code> and <code class="inlineCode">UserService</code> concrete classes serve to implement these two interfaces.</p>
<h2 class="heading-2" id="_idParaDest-184">Initializing the database</h2>
<p class="normal">The<a id="_idIndexMarker537"/> database initialization is incorporated within the login process, so the subsequent login method is defined in the <code class="inlineCode">IUserService</code> interface:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function">Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">LoginAsync</span><span class="hljs-function">(</span><span class="hljs-params">T user</span><span class="hljs-function">)</span>;
</code></pre>
<p class="normal">The <code class="inlineCode">UserService</code> class serves as an implementation of the <code class="inlineCode">IUserService</code> interface. Within the <code class="inlineCode">UserService</code> class, the <code class="inlineCode">LoginAsync</code> method is defined as an asynchronous method, as illustrated here:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">LoginAsync</span><span class="hljs-function">(</span><span class="hljs-params">User user</span><span class="hljs-function">)</span>
{
  <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) { 
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(
      <span class="hljs-keyword">nameof</span>(user), <span class="hljs-string">"User cannot be null"</span>); }
  _user = user;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> dataStore.ConnectAsync(user);
}
</code></pre>
<p class="normal">In <code class="inlineCode">LoginAsync</code>, the <code class="inlineCode">IDataStore</code> method <code class="inlineCode">ConnectAsync</code> is invoked to perform the actual task. Let’s examine the <code class="inlineCode">ConnectAsync</code> implementation below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">ConnectAsync</span><span class="hljs-function">(</span><span class="hljs-params">User user</span><span class="hljs-function">)</span>
{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> Task.Run(() =&gt;                                     <span class="hljs-comment">//(1)</span>
  {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(user.Username) || 
      <span class="hljs-built_in">string</span>.IsNullOrEmpty(user.Password)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(user), 
        <span class="hljs-string">"Username or password cannot be null"</span>);
    }
    _db.Open(user);                                               <span class="hljs-comment">//(2)</span>
    <span class="hljs-keyword">if</span> (_db.IsOpen)
    {
        _db.CurrentGroup = _db.RootGroup;
    }
    <span class="hljs-keyword">return</span> _db.IsOpen;
  });
}
</code></pre>
<p class="normal">In<a id="_idIndexMarker538"/> the <code class="inlineCode">ConnectAsync</code> function, <strong class="keyWord">(1)</strong>, a distinct task is employed to manage the opening process of the database. The <code class="inlineCode">Open</code> method of <code class="inlineCode">PxDatabase</code> is invoked, <strong class="keyWord">(2)</strong>, and an instance of the <code class="inlineCode">User</code> class is provided as an argument to the <code class="inlineCode">Open</code> method.</p>
<p class="normal">After successfully establishing a connection and initializing the database, we need to implement the methods required for database operations. These can include tasks such as data retrieval, data insertion, data update, and data deletion, among others. These represent the fundamental operations to interact, manage, and maintain data within the database system.</p>
<h2 class="heading-2" id="_idParaDest-185">Performing CRUD operations</h2>
<p class="normal">The<a id="_idIndexMarker539"/> data manipulation in the KeePass database closely resembles the CRUD operations found in a relational database. These operations are outlined in the <code class="inlineCode">IDataStore</code> interface, as demonstrated in the subsequent code snippet. Upon logging in and connecting to a database, we can access our stored password data. Initially, we must retrieve a list of items. Upon login, the<a id="_idIndexMarker540"/> root group provides the first list. We use the <code class="inlineCode">SetCurrentGroup</code> method <strong class="keyWord">(1)</strong> to establish the current navigation location. </p>
<p class="normal">When the user navigates to another group, <code class="inlineCode">SetCurrentGroup</code> is invoked with an argument to set the new location in the navigation:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDataStore</span>&lt;<span class="hljs-title">T</span>&gt;
{
  <span class="hljs-function">Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">AddItemAsync</span><span class="hljs-function">(</span><span class="hljs-params">T item</span><span class="hljs-function">)</span>;
  <span class="hljs-function">Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">UpdateItemAsync</span><span class="hljs-function">(</span><span class="hljs-params">T item</span><span class="hljs-function">)</span>;
  <span class="hljs-function">Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">DeleteItemAsync</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> id</span><span class="hljs-function">)</span>;
  T? GetItem(<span class="hljs-built_in">string</span> id);
  Task&lt;IEnumerable&lt;T&gt;&gt; GetItemsAsync(
    <span class="hljs-built_in">bool</span> forceRefresh = <span class="hljs-literal">false</span>);
  <span class="hljs-built_in">string</span><span class="hljs-function"> </span><span class="hljs-title">SetCurrentGroup</span><span class="hljs-function">(</span><span class="hljs-params">T? </span><span class="hljs-keyword">group</span><span class="hljs-params"> = </span><span class="hljs-literal">default</span><span class="hljs-function">)</span>;                    <span class="hljs-comment">//(1)</span>
  <span class="hljs-function">Task&lt;</span><span class="hljs-built_in">bool</span><span class="hljs-function">&gt; </span><span class="hljs-title">ConnectAsync</span><span class="hljs-function">(</span><span class="hljs-params">User user</span><span class="hljs-function">)</span>;
  <span class="hljs-function">Task </span><span class="hljs-title">SignUpAsync</span><span class="hljs-function">(</span><span class="hljs-params">User user</span><span class="hljs-function">)</span>;
  <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Close</span><span class="hljs-function">()</span>;
  T? CreateNewItem(ItemSubType type);
}
</code></pre>
<p class="packt_figref">Listing 6.2: <code class="inlineCode">IDataStore.cs</code> (<a href="https://epa.ms/IDataStore6-2"><span class="url">https://epa.ms/IDataStore6-2</span></a>)</p>
<h3 class="heading-3" id="_idParaDest-186">Adding an item</h3>
<p class="normal">The initial <a id="_idIndexMarker541"/>operation in CRUD involves creating or adding an item. This item could be an entry or a group that is added to the current group. The user interface for performing this add operation can be found as a toolbar item in <code class="inlineCode">ItemsPage</code>, as illustrated below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">ContentPage.ToolbarItems</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ToolbarItem</span><span class="hljs-tag"> </span><span class="hljs-attr">Text</span><span class="hljs-tag">=</span><span class="hljs-string">"Add"</span><span class="hljs-tag"> </span><span class="hljs-attr">Command</span><span class="hljs-tag">=</span><span class="hljs-string">"{Binding AddItemCommand}"</span><span class="hljs-tag"> </span>
<span class="hljs-tag">    </span><span class="hljs-attr">IconImageSource</span><span class="hljs-tag">=</span><span class="hljs-string">"{FontImage FontFamily=FontAwesomeSolid, </span>
<span class="hljs-string">    Color=White, </span>
<span class="hljs-string">    Glyph={x:Static style:FontAwesomeSolid.PlusCircle}}"</span><span class="hljs-tag">/&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">ContentPage.ToolbarItems</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">We can see a toolbar item icon is shown in the top-right corner of <code class="inlineCode">ItemsPage</code> in <em class="italic">Figure 6.8</em>:</p>
<figure class="mediaobject"><img alt="Figure 6.8: Adding an item" height="821" src="../Images/B21554_06_08.png" width="632"/></figure>
<p class="packt_figref">Figure 6.8: Adding an item</p>
<p class="normal">When the <strong class="keyWord">+ </strong>button is clicked, the <code class="inlineCode">AddItemCommand</code> command in the <code class="inlineCode">ItemsViewModel</code> is invoked<a id="_idIndexMarker542"/> through data binding.</p>
<p class="normal">The <code class="inlineCode">AddItemCommand</code> command invokes the following <code class="inlineCode">AddItem</code> method in the view model:</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">RelayCommand</span>]
<span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task </span><span class="hljs-title">AddItem</span><span class="hljs-function">(</span><span class="hljs-built_in">object</span><span class="hljs-params"> obj</span><span class="hljs-function">)</span>
{
  <span class="hljs-built_in">string</span>[] templates = {
      Properties.Resources.item_subtype_group,
      Properties.Resources.item_subtype_entry,
      Properties.Resources.item_subtype_notes,
      Properties.Resources.item_subtype_pxentry
  };
  <span class="hljs-keyword">var</span> template = <span class="hljs-keyword">await</span> Shell.Current.DisplayActionSheet(
    Properties.Resources.pt_id_choosetemplate, 
    Properties.Resources.action_id_cancel, <span class="hljs-literal">null</span>, templates);       <span class="hljs-comment">//(1)</span>
  ItemSubType type;
  <span class="hljs-keyword">if</span> (template == 
    Properties.Resources.item_subtype_entry) {
    type = ItemSubType.Entry;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (template == 
    Properties.Resources.item_subtype_pxentry) {
    type = ItemSubType.PxEntry;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (template == 
    Properties.Resources.item_subtype_group) {
    type = ItemSubType.Group;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (template == 
    Properties.Resources.item_subtype_notes) {
    type = ItemSubType.Notes;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (template == 
    Properties.Resources.action_id_cancel) {
    type = ItemSubType.None;
  }
  <span class="hljs-keyword">else</span> {
    type = ItemSubType.None;
  }
  <span class="hljs-keyword">if</span> (type != ItemSubType.None) {
    <span class="hljs-keyword">var</span> itemType = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">object</span>&gt; {               <span class="hljs-comment">//</span><span class="hljs-comment">(2)</span>
        { <span class="hljs-string">"Type"</span>, type }
    };
    <span class="hljs-keyword">await</span> Shell.Current.GoToAsync(                                <span class="hljs-comment">//(3)</span>
      <span class="hljs-keyword">nameof</span>(NewItemPage), itemType);
  }
}
</code></pre>
<p class="packt_figref">Listing 6.3: <code class="inlineCode">ItemsViewModel.cs</code> (<a href="https://epa.ms/ItemsViewModel6-3"><span class="url">https://epa.ms/ItemsViewModel6-3</span></a>)</p>
<p class="normal"><strong class="keyWord">(1)</strong> In the <code class="inlineCode">AddItem</code> function, an <code class="inlineCode">ActionSheet</code> is displayed, allowing the user to select an item type. The item type can either be a group or an entry.</p>
<p class="normal"><strong class="keyWord">(2)</strong> Upon<a id="_idIndexMarker543"/> obtaining the item type, we can construct a dictionary that includes the item type and the query parameter’s name. Then, we store this dictionary object in a variable called <code class="inlineCode">itemType</code>.</p>
<p class="normal"><strong class="keyWord">(3)</strong> This <code class="inlineCode">itemType</code> variable can be passed to <code class="inlineCode">NewItemPage</code> as a query parameter. In <em class="chapterRef">Chapter 5</em>, <em class="italic">Navigation Using .NET MAUI Shell and NavigationPage</em>, we learned how to pass a string value as a query parameter to a page in Shell navigation. Here, we can pass an object as a query parameter to a page after we wrap it in a dictionary.</p>
<p class="normal">To add a new item, the user interface is defined in <code class="inlineCode">NewItemPage</code>, while the logic is managed within the <code class="inlineCode">NewItemViewModel</code>. Let’s examine the <code class="inlineCode">NewItemViewModel</code> implementation as shown in <em class="italic">Listing 6.4</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> CommunityToolkit.Mvvm.ComponentModel;
<span class="hljs-keyword">using</span> CommunityToolkit.Mvvm.Input;
<span class="hljs-keyword">using</span> Microsoft.Extensions.Logging;
<span class="hljs-keyword">using</span> KPCLib;
<span class="hljs-keyword">using</span> PassXYZLib;
<span class="hljs-keyword">using</span> PassXYZ.Vault.Services;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Net.Mime.MediaTypeNames;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.ViewModels</span>;
[<span class="hljs-meta">QueryProperty(nameof(Type), nameof(Type))</span>]                       <span class="hljs-comment">//(1)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NewItemViewModel</span> : <span class="hljs-title">ObservableObject</span>
{
  <span class="hljs-keyword">readonly</span> IDataStore&lt;Item&gt;? _dataStore;
  ILogger&lt;NewItemViewModel&gt; _logger;
  <span class="hljs-keyword">private</span> ItemSubType _type = ItemSubType.Group;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">NewItemViewModel</span><span class="hljs-function">(</span><span class="hljs-params">IDataStore&lt;Item&gt; dataStore, </span>
<span class="hljs-params">    ILogger&lt;NewItemViewModel&gt; logger</span><span class="hljs-function">)</span> {
    <span class="hljs-keyword">this</span>._dataStore = dataStore ?? 
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(dataStore));
    <span class="hljs-keyword">this</span>._logger = logger;
  }
  <span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">SetPlaceholder</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType type</span><span class="hljs-function">)</span> {
    <span class="hljs-keyword">if</span> (type == ItemSubType.Group) {
      Placeholder = Properties.Resources.action_id_add +
        <span class="hljs-string">" "</span> + Properties.Resources.item_subtype_group;
    }
    <span class="hljs-keyword">else</span>
    {
      Placeholder = Properties.Resources.action_id_add + 
        <span class="hljs-string">" "</span> + Properties.Resources.item_subtype_entry;
    }
  }
  <span class="hljs-keyword">public</span> ItemSubType Type {                                       <span class="hljs-comment">//(2)</span>
    <span class="hljs-keyword">get</span> =&gt; _type;
    <span class="hljs-keyword">set</span> {
      _ = SetProperty(<span class="hljs-keyword">ref</span> _type, <span class="hljs-keyword">value</span>);
      SetPlaceholder(_type);
    }
  }
  [<span class="hljs-meta">ObservableProperty</span>]
  [<span class="hljs-meta">NotifyCanExecuteChangedFor(nameof(SaveCommand))</span>]
  <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>? name;
  [<span class="hljs-meta">ObservableProperty</span>]
  [<span class="hljs-meta">NotifyCanExecuteChangedFor(nameof(SaveCommand))</span>]
  <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>? description;
  [<span class="hljs-meta">ObservableProperty</span>]
  <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>? placeholder;
  [<span class="hljs-meta">RelayCommand</span>]
  <span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task </span><span class="hljs-title">Cancel</span><span class="hljs-function">()</span> {
      <span class="hljs-keyword">await</span> Shell.Current.GoToAsync(<span class="hljs-string">".."</span>);
  }
  [<span class="hljs-meta">RelayCommand(CanExecute = nameof(ValidateSave))</span>]
  <span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task </span><span class="hljs-title">Save</span><span class="hljs-function">()</span> {
    <span class="hljs-keyword">if</span>(_dataStore == <span class="hljs-literal">null</span>) { 
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(
      <span class="hljs-string">"dataStore cannot be null"</span>); }
    Item? newItem = _dataStore.CreateNewItem(_type);             <span class="hljs-comment">//(3)</span>
    <span class="hljs-keyword">if</span> (newItem != <span class="hljs-literal">null</span>) {
      newItem.Name = Name;
      newItem.Notes = Description;
      <span class="hljs-keyword">await</span> _dataStore.AddItemAsync(newItem);                    <span class="hljs-comment">//(4</span><span class="hljs-comment">)</span>
    }
    <span class="hljs-keyword">await</span> Shell.Current.GoToAsync(<span class="hljs-string">".."</span>);
  }
  <span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-built_in">bool</span><span class="hljs-function"> </span><span class="hljs-title">ValidateSave</span><span class="hljs-function">()</span> {
    <span class="hljs-keyword">var</span> canExecute = !String.IsNullOrWhiteSpace(Name)
        &amp;&amp; !String.IsNullOrWhiteSpace(Description);
    _logger.LogDebug(<span class="hljs-string">"ValidateSave: {canExecute}"</span>, canExecute);
    <span class="hljs-keyword">return</span> canExecute;
  }
}
</code></pre>
<p class="packt_figref">Listing 6.4: <code class="inlineCode">NewItemViewModel.cs</code> (<a href="https://epa.ms/NewItemViewModel6-4"><span class="url">https://epa.ms/NewItemViewModel6-4</span></a>)</p>
<p class="normal">The design <a id="_idIndexMarker544"/>of the <code class="inlineCode">NewItemPage</code> is quite straightforward, featuring two controls: <strong class="keyWord">Entry</strong> and <strong class="keyWord">Editor</strong>, which serve to edit the name and notes of an item, respectively. The <strong class="keyWord">Entry</strong> control is employed for entering or editing a single line of text, whereas the <strong class="keyWord">Editor</strong> control is utilized for modifying multiple lines of text. Within the <code class="inlineCode">NewItemViewModel</code> view model, we can observe the process of adding a new item as demonstrated below:</p>
<p class="normal"><strong class="keyWord">(1)</strong> The query parameter is defined using the <code class="inlineCode">QueryPropertyAttribute</code>. <strong class="keyWord">(2)</strong> The <code class="inlineCode">Type</code> property, declared as <code class="inlineCode">ItemSubType</code>, is utilized to obtain the query parameter. The acquired item type is subsequently stored in the <code class="inlineCode">_type</code> backing variable. Within the <code class="inlineCode">NewItemPage</code>, two toolbar items are established, and their actions are associated with the <strong class="keyWord">Save</strong> and <strong class="keyWord">Cancel</strong> methods found in the view model.</p>
<p class="normal">Upon entering a name and notes in the user interface and clicking the <strong class="keyWord">Save</strong> button, <strong class="keyWord">(3)</strong>, a new item instance is created using the <code class="inlineCode">CreateNewItem</code> factory method, which is defined in the <code class="inlineCode">IDataStore </code>interface. <strong class="keyWord">(4)</strong> Once the new item instance is populated with the user input, it can be added to the database by calling the <code class="inlineCode">AddItemAsync</code> method.</p>
<p class="normal">We have now implemented the addition operation. In the following section, let’s proceed to implement the remaining data operations.</p>
<h3 class="heading-3" id="_idParaDest-187">Editing or deleting an item</h3>
<p class="normal">In CRUD operations, a<a id="_idIndexMarker545"/> create operation does not require an existing item. However, to perform update and delete operations, an instance of the existing item is necessary.</p>
<p class="normal">In a read operation, when<a id="_idIndexMarker546"/> an item is a group, we implement it by transmitting an <code class="inlineCode">ItemId</code> query parameter to the <code class="inlineCode">ItemsPage</code> and, subsequently, identifying the group within the setter of <code class="inlineCode">ItemId</code> in the <code class="inlineCode">ItemsViewModel</code> view model. Conversely, if the item is an entry, we transmit an <code class="inlineCode">ItemId</code> query parameter to <code class="inlineCode">ItemDetailPage</code> and locate the entry within the setter of <code class="inlineCode">ItemId</code> in the <code class="inlineCode">ItemDetailViewModel</code>.</p>
<p class="normal">For updating, editing, and deleting operations, we can utilize context actions. These actions allow us to manipulate items within a <code class="inlineCode">ListView</code> effectively. It is important to note that context actions have a distinct appearance on various platforms, such as iOS, Android, and Windows, as depicted in <em class="italic">Figure 6.9</em>:</p>
<figure class="mediaobject"><img alt="Figure 6.9: Context actions" height="572" src="../Images/B21554_06_09.png" width="825"/></figure>
<p class="packt_figref">Figure 6.9: Context actions</p>
<p class="normal">On the iOS platform, you can perform an action on an item by swiping it to the left. In an Android system, you can access the contextual actions menu by long-pressing an item, which will then appear in the top-right corner of the screen. On Windows, you might be familiar with right-clicking your mouse to display the contextual actions menu.</p>
<p class="normal">In our <a id="_idIndexMarker547"/>application, we introduce a context actions <a id="_idIndexMarker548"/>menu within the <code class="inlineCode">ItemsPage</code>. We configure the context actions in the <code class="inlineCode">ItemViewCell</code> inside <code class="inlineCode">ItemsPage</code>, as demonstrated below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">ListView.ItemTemplate</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">DataTemplate</span><span class="hljs-tag"> </span><span class="hljs-attr">x:DataType</span><span class="hljs-tag">=</span><span class="hljs-string">"model:Item"</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">template:ItemViewCell</span><span class="hljs-tag"> </span><span class="hljs-attr">Key</span><span class="hljs-tag">=</span><span class="hljs-string">"{Binding Name}"</span><span class="hljs-tag"> </span>
<span class="hljs-tag">      </span><span class="hljs-attr">Value</span><span class="hljs-tag">=</span><span class="hljs-string">"{Binding Description}"</span><span class="hljs-tag"> </span><span class="hljs-attr">Source</span><span class="hljs-tag">=</span><span class="hljs-string">"{Binding ImgSource}"</span>
<span class="hljs-tag">      </span><span class="hljs-attr">ParentPage</span><span class="hljs-tag">=</span><span class="hljs-string">"{x:Reference itemsPage}"</span><span class="hljs-tag">/&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">DataTemplate</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">ListView.ItemTemplate</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">The <code class="inlineCode">ItemViewCell</code> is a custom view that inherits from <code class="inlineCode">KeyValueView</code>, which was introduced in <em class="chapterRef">Chapter 4</em>, <em class="italic">Exploring MVVM and Data Binding</em>. Let’s examine the <code class="inlineCode">ItemViewCell</code> code in <em class="italic">Listing 6.5</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Diagnostics;
<span class="hljs-keyword">using</span> KPCLib;
<span class="hljs-keyword">using</span> PassXYZ.Vault.ViewModels;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Views.Templates</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemViewCell</span> : <span class="hljs-title">KeyValueView</span> {
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ItemViewCell</span><span class="hljs-function">()</span> {
    SetContextAction(GetEditMenu(), OnEditAction);
    SetContextAction(GetDeleteMenu(), OnDeleteAction);
  }
  <span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnEditAction</span><span class="hljs-function">(</span><span class="hljs-built_in">object</span><span class="hljs-params">? sender,                        </span><span class="hljs-comment">//(1)</span>
<span class="hljs-function">    System.EventArgs e)</span> {
    <span class="hljs-keyword">if</span>(sender <span class="hljs-keyword">is</span> MenuItem menuItem)
    {
      <span class="hljs-keyword">if</span>(menuItem.CommandParameter <span class="hljs-keyword">is</span> Item item &amp;&amp; 
          ParentPage.BindingContext <span class="hljs-keyword">is</span> ItemsViewModel vm)
      {
        vm.Update(item);
      }
    }
  }
  <span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnDeleteAction</span><span class="hljs-function">(</span><span class="hljs-built_in">object</span><span class="hljs-params">? sender,                </span><span class="hljs-comment">//(2)</span>
<span class="hljs-function">    System.EventArgs e)</span> {
    <span class="hljs-keyword">if</span> (sender <span class="hljs-keyword">is</span> MenuItem menuItem) {
      <span class="hljs-keyword">if</span> (menuItem.CommandParameter <span class="hljs-keyword">is</span> Item item &amp;&amp;
          ParentPage.BindingContext <span class="hljs-keyword">is</span> ItemsViewModel vm)
      {
        <span class="hljs-keyword">await</span> vm.Delete(item);
      }
    }
  }
}
</code></pre>
<p class="packt_figref">Listing 6.5: <code class="inlineCode">ItemViewCell.cs</code> (<a href="https://epa.ms/ItemViewCell6-5"><span class="url">https://epa.ms/ItemViewCell6-5</span></a>)</p>
<p class="normal">In the <code class="inlineCode">ItemViewCell</code>, we define two menu items for editing and deleting context actions. We <a id="_idIndexMarker549"/>assign two event handlers (<strong class="keyWord">(1)</strong> <code class="inlineCode">OnEditAction</code> and <strong class="keyWord">(2)</strong> <code class="inlineCode">OnDeleteAction</code>) to their corresponding context actions. Within<a id="_idIndexMarker550"/> the event handlers, we invoke the view model methods, <code class="inlineCode">Update</code> and <code class="inlineCode">Delete</code>, to execute the required operations.</p>
<p class="normal">Let us examine the source code for the <code class="inlineCode">Update</code> and <code class="inlineCode">Delete</code> functions in the <code class="inlineCode">ItemsViewModel</code>, as shown below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Update</span><span class="hljs-function">(</span><span class="hljs-params">Item item</span><span class="hljs-function">)</span> {
  <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">await</span> Shell.Current.Navigation.PushAsync(
    <span class="hljs-keyword">new</span> FieldEditPage(<span class="hljs-keyword">async</span> (<span class="hljs-built_in">string</span> k, <span class="hljs-built_in">string</span> v,  <span class="hljs-params">                </span><span class="hljs-comment">//(1)</span>
                      <span class="hljs-built_in">bool</span> isProtected) =&gt; {
    item.Name = k;
    item.Notes = v;
    <span class="hljs-keyword">await</span> dataStore.UpdateItemAsync(item);          <span class="hljs-params">              </span><span class="hljs-comment">//(2)</span>
  }, item.Name, item.Notes, <span class="hljs-literal">true</span>));
}
<span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> Task </span><span class="hljs-title">Delete</span><span class="hljs-function">(</span><span class="hljs-params">Item item</span><span class="hljs-function">)</span> {
  <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (Items.Remove(item)) {
      _ = <span class="hljs-keyword">await</span> dataStore.DeleteItemAsync(item.Id); <span class="hljs-params">              </span><span class="hljs-comment">//(3)</span>
  }
  <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullReferenceException(<span class="hljs-string">"Delete item error"</span>);
  }
}
</code></pre>
<p class="normal">In the <code class="inlineCode">ItemsViewModel</code>, to edit or update an item, <strong class="keyWord">(1)</strong>, we utilize a content page called <code class="inlineCode">FieldEditPage</code> to carry out the editing process. Upon invoking the constructor of <code class="inlineCode">FieldEditPage</code>, an <a id="_idIndexMarker551"/>anonymous function is passed <a id="_idIndexMarker552"/>as a parameter. This function is invoked when the user finishes editing within <code class="inlineCode">FieldEditPage</code>. Within this function, <strong class="keyWord">(2)</strong>, the <code class="inlineCode">UpdateItemAsync</code> method of the <code class="inlineCode">IDataStore</code> interface is called to update the item.</p>
<p class="normal">The delete operation is fairly straightforward. We can simply invoke the <code class="inlineCode">DeleteItemAsync</code> method, <strong class="keyWord">(3)</strong>, from the <code class="inlineCode">IDataStore</code> interface to eliminate the item.</p>
<p class="normal">Once the CRUD operations are implemented, our application will possess the essential features required for a password manager app. We can establish a new database by registering a new user. Upon creating a new database, we can then log in to access our data. Additionally, after generating entries and groups, we have the ability to modify or remove them as needed.</p>
<h1 class="heading-1" id="_idParaDest-188">Summary</h1>
<p class="normal">In this chapter, we began by introducing design principles. Following this, we delved into the SOLID design principles, and I shared insights gleaned from the development of our app. Among the most crucial SOLID principles is the <strong class="keyWord">DIP</strong>. <strong class="keyWord">DI</strong> is a technique that applies the DIP in practical implementation. In our app, we utilize the built-in DI service of .NET MAUI to decouple dependencies, enabling us to separate the implementation of the service from the interface.</p>
<p class="normal">We accumulated extensive knowledge about .NET MAUI and successfully completed our app implementation by replacing <code class="inlineCode">MockDataStore</code> with the actual implementation. We established CRUD operations on top of this new <code class="inlineCode">IDataStore</code> service, resulting in a fully functional password manager app.</p>
<p class="normal">Although we have incorporated essential features in our app, users often expect additional desirable features in a password manager application, such as fingerprint scanning and one-time passwords. Some of these features are platform-specific, which requires knowledge of platform integration. In the next chapter, we will delve into various platform integration topics to further improve our app.</p>
<h1 class="heading-1" id="_idParaDest-189">Further reading</h1>
<ul>
<li class="bulletList"><em class="italic">Beginning SOLID Principles and Design Patterns for ASP.NET Developers</em>, by Bipin Joshi</li>
<li class="bulletList"><strong class="keyWord">Autofac</strong> is an <strong class="keyWord">inversion of control</strong> (<strong class="keyWord">IoC</strong>) container for .NET Core, ASP.NET Core, .NET 4.5.1+, and more: <a href="https://autofac.org/"><span class="url">https://autofac.org/</span></a></li>
<li class="bulletList"><strong class="keyWord">Simple Injector</strong> is a DI container that can support .NET 4.5 and .NET Standard: <a href="https://simpleinjector.org/%20"><span class="url">https://simpleinjector.org/</span></a></li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/cross-platform-app"><span class="url">https://packt.link/cross-platform-app</span></a></p>
<p class="normal"><img alt="" height="354" src="../Images/QR_Code166522361691420406.png" style="width:10em;" width="354"/></p>
</div>
</div></body></html>