<html><head></head><body><div><div><div><h1 id="_idParaDest-161" class="chapter-number"><a id="_idTextAnchor255"/>7</h1>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor256"/>Modular and Layered Architectures</h1>
			<p>The previous chapters have repeatedly mentioned the importance of appropriate modularization of the system and addressing concerns separately. In this chapter, we delve into four prominent architectural patterns that offer their approaches to separate concerns in layers, modularize code, and set up clean boundaries among modules.</p>
			<p>All these patterns will be illustrated with the same real-life example to highlight the similarities and differences of these patterns.</p>
			<p>By understanding these patterns with code examples in Kotlin, engineers can make informed choices to create loosely coupling and highly cohesive modules that are testable, flexible, and maintainable.</p>
			<p>The following architectural patterns will be covered:</p>
			<ul>
				<li>Clean Architecture</li>
				<li>The hexagonal architecture</li>
				<li><strong class="bold">Functional core, imperative </strong><strong class="bold">shell</strong> (<strong class="bold">FCIS</strong>)</li>
				<li>The Connect pattern</li>
			</ul>
			<p>At the end, these patterns will be briefly compared with one another. We will also explore the possibility of taking elements from each pattern to create a hybrid pattern to meet the requirements.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor257"/>Technical requirements</h1>
			<p>You can find the code files used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7%0D">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7</a></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor258"/>Clean Architecture</h1>
			<p><strong class="bold">Clean Architecture</strong> is an<a id="_idIndexMarker570"/> architectural pattern that advocates organizing a software system into distinct layers, each with its own responsibilities and dependencies.</p>
			<p>The term Clean Architecture was introduced by Robert Martin (known as <em class="italic">Uncle Bob</em>) in his book titled <em class="italic">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</em>, published in 2017. The foundation of this approach is built upon a few earlier architectural patterns:</p>
			<ul>
				<li><strong class="bold">The hexagonal architecture</strong> (also known<a id="_idIndexMarker571"/> as <strong class="bold">ports and adapters</strong>) by Alistair Cockburn</li>
				<li><strong class="bold">Onion Architecture</strong> by Jeffrey Palermo</li>
				<li><strong class="bold">Screaming Architecture</strong> by Robert Martin</li>
				<li><strong class="bold">Data, context, and interaction</strong> (<strong class="bold">DCI</strong>) by James<a id="_idIndexMarker572"/> Coplien and Trygve Reenskaug</li>
				<li><strong class="bold">Boundary-control-entity</strong> (<strong class="bold">BCE</strong>) by <a id="_idIndexMarker573"/>Ivar Jacobson</li>
			</ul>
			<p>Clean Architecture dissects a software system by numerous layers, where each layer is wrapped one on top of the other, like an onion. The <strong class="bold">Dependency Rule</strong> of<a id="_idIndexMarker574"/> Clean Architecture states that the outer layers always depend on the inner layers.</p>
			<div><div><img src="img/B21737_07_1.jpg" alt="Figure 7.1 – Clean Architecture" width="1163" height="1164"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Clean Architecture</p>
			<p>Due to the Dependency Rule, any change in the outer layer does not affect the inner layer. On the contrary, any change in the inner layer may affect the outer layer.</p>
			<p>Let us go through the layer from the innermost to the outermost, demonstrated by the real-life example we <a id="_idIndexMarker575"/>use throughout previous chapters—households in a village exchanging services with each other.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor259"/>Entities</h2>
			<p>The <strong class="bold">Entities layer</strong> is the <a id="_idIndexMarker576"/>innermost layer, which depends <a id="_idIndexMarker577"/>on no other layer. This layer is designed to encapsulate business rules shared among applications.</p>
			<p>It contains mostly data structures and functions only. It rarely depends on external libraries. The only libraries it depends on are most likely those that provide specialized data structures. This layer is also the least likely to change.</p>
			<p>In our real-life example, there are a few candidates suitable to be hosted in the Entities layer. <code>Household</code>, <code>Contract</code>, <code>Service</code>, and subclasses of <code>Service</code> as Kotlin data classes belong to the Entities layer. Certain rules and policies can also reside in the Entities layer. Here are a few example rules.</p>
			<h3>Rule 1 – Household name must not be null and must have at least one member</h3>
			<p>This rule is enforced by the Kotlin non-null field syntax in data classes and the validation within the <code>init</code> function:</p>
			<pre class="source-code">
data class Household(
    val name: String,
    val members: List&lt;String&gt;
) {
    init {
        require(members.isNotEmpty()) { "Household must have at least one member" }
    }
}</pre>			<h3>Rule 2 – Contract must be in one of the specified states</h3>
			<p>This rule is <a id="_idIndexMarker578"/>enforced <a id="_idIndexMarker579"/>by the Kotlin enumeration feature:</p>
			<pre class="source-code">
enum class ContractState {
    DRAFTED,
    UNDER_REVIEW,
    AGREED,
    REJECTED,
    PARTIALLY_EXERCISED,
    FULLY_EXERCISED,
    WITHDRAWN
}</pre>			<h3>Rule 3 – a Contract consists of two Household objects and a state</h3>
			<p>This rule is enforced by Kotlin data classes:</p>
			<pre class="source-code">
data class Party(
    val household: Household,
    val serviceProvided: String,
    val agreedAt: Instant? = null,
    val completedAt: Instant? = null
)
data class Contract(
    val partyA: Party,
    val partyB: Party,
    val contractState: ContractState
)</pre>			<p>These classes are Pure Kotlin and can be shared among the four services we defined earlier in <a href="B21737_06.xhtml#_idTextAnchor212"><em class="italic">Chapter 6</em></a>, namely <em class="italic">Household Service</em>, <em class="italic">Contract Service</em>, and <em class="italic">Notification Service</em>. Arguably, Household <a id="_idIndexMarker580"/>Service does not need a <code>Contract</code> class, and <a id="_idIndexMarker581"/>this may be a trade-off for most services to share entity classes but not all.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor260"/>Use Cases</h2>
			<p>The <strong class="bold">Use Cases layer</strong> is <a id="_idIndexMarker582"/>one layer above the Entities layer. It is<a id="_idIndexMarker583"/> designed to encapsulate business rules within an application.</p>
			<p>It contains use cases that make use of the data structures and functions in the Entities layer. Any change in this layer should not affect the Entities layer. This layer should also remain neutral to choices of frameworks and technologies, such as databases and messaging.</p>
			<p>In our real-life example, we have a use case of a household drafting a contract with another household, using the Negotiation Service:</p>
			<pre class="source-code">
fun draftContract(
    householdA: Household,
    householdB: Household,
    serviceProvidedByHouseholdA: String,
    serviceProvidedByHouseholdB: String,
): Contract {
    require(householdA != householdB) { "Parties must be from different households" }
    return Contract(Party(
        householdA,
        serviceProvidedByHouseholdA,
    ), Party(
        householdB,
        serviceProvidedByHouseholdB,
    ), ContractState.DRAFTED)
}</pre>			<p>The <code>draftContract</code> function validates that the two households are not the same. If everything looks good, it creates a contract with both households and their services to be provided. In addition, it set the contract state to <code>DRAFTED</code>. This <code>draftContract</code> function in the Use Cases layer makes use of the <code>Household</code>, <code>Party</code>, <code>ContractState</code>, and <code>Contract</code> classes from the Entities layer.</p>
			<p>There could be a bit of fluidity between the Entities layer and the Use Cases layer. If one feature in Entities <a id="_idIndexMarker584"/>is considered only relevant to one application, it<a id="_idIndexMarker585"/> can be moved to the Use Cases layer. Similarly, if there are duplicated logics in the Use Cases layer in different applications, they can be extracted into the Entities layer.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor261"/>Interface Adapters</h2>
			<p>The Entities and Use<a id="_idIndexMarker586"/> Cases layers are considered internal models, where data structures are not exposed outside of the application. The <strong class="bold">Interface Adapters layer</strong> serves <a id="_idIndexMarker587"/>as the translation between the internal and the external models. Typical examples of external models are relational database tables, message payloads, HTTP request and response payloads, file formats, and visual representation<a id="_idIndexMarker588"/> in the <strong class="bold">graphical user </strong><strong class="bold">interface</strong> (<strong class="bold">GUI</strong>).</p>
			<p>We already have a few examples of where the code should stay in the Interface Adapters layer:</p>
			<ul>
				<li>The peer-to-peer architectures covered in <a href="B21737_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a> have illustrated the example code of <a id="_idIndexMarker589"/>conversion between a <code>Contract</code> object and a binary payload used for <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) transmission.</li>
				<li>In the same chapter, there is a similar example, but the conversion is between a <code>Contract</code> object<a id="_idIndexMarker590"/> and a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) payload that is<a id="_idIndexMarker591"/> defined by <strong class="bold">OpenAPI</strong> specifications, under the client-server architecture.</li>
				<li>The three frontend architectural styles covered in <a href="B21737_05.xhtml#_idTextAnchor125"><em class="italic">Chapter 5</em></a>, MVC, MVP, and MVVM, would have the corresponding code in this layer, as they transform internal models to the view that is rendered as GUI.</li>
			</ul>
			<p>If the application uses query languages, such as SQL, for relational databases, they should also stay in the Interface Adapters layer.</p>
			<p>These external models and their corresponding conversion should not leak into other layers. The layer<a id="_idIndexMarker592"/> should not contain business logic <a id="_idIndexMarker593"/>either. The concern of internal models is separated from layers outside of the Interface Adapters layer, and the concern of external models is separated from layers inside of the Interface Adapters layer.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor262"/>Frameworks and Drivers</h2>
			<p>The Frameworks and <a id="_idIndexMarker594"/>Drivers layer is <a id="_idIndexMarker595"/>one layer outside of the Interface Adapters layer. This is where external frameworks are added to make it an application. Typical examples are HTTP endpoint routing configurations, database connection details, Kubernetes configurations, and dependency management. Quite often, this layer contains configuration files more than source code.</p>
			<p>This layer should never contain business use cases. It does not know any internal models and therefore no conversion from external models. This layer focuses on supporting configurations that turn code into an application executable in a runtime. It should address only non-functiona<a id="_idIndexMarker596"/>l requirements, such as<a id="_idIndexMarker597"/> startup time, or redundancy.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor263"/>An example use case with Clean Architecture</h2>
			<p>Let us take a <a id="_idIndexMarker598"/>use case as an example of how different layers are used. A household is presented with a form to submit a draft contract, which is a web page in the Frameworks and Drivers layer.</p>
			<p>The household then submits the form as JSON values and enters the controller in the Interface Adapters layer. The controller converts the form into a few internal objects, such as the objects of both <code>Household</code> and the services provided as strings. These internal objects are then passed to a <code>draftContract</code> function in the Use Cases layer:</p>
			<pre class="source-code">
fun draftContract(
    householdA: Household,
    householdB: Household,
    serviceProvidedByHouseholdA: String,
    serviceProvidedByHouseholdB: String,
): Contract</pre>			<p>The function creates a <code>Contract</code> object, which comes from the Entities layer. The function passes a <code>Contract</code> object to the presenter in the Interface Adapters layer. The presenter converts the <code>Contract</code> object into a JSON value to be rendered by the web page in the Frameworks and Drivers layer. The whole journey is illustrated in <em class="italic">Figure 7</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21737_07_2.jpg" alt="Figure 7.2 – Example use case of Clean Architecture" width="1127" height="614"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Example use case of Clean Architecture</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor264"/>Benefits of Clean Architecture</h2>
			<p>The centerpiece <a id="_idIndexMarker599"/>of Clean Architecture is the Dependency Rule, not the four defined layers. With justifications, there could be variation in the layers, but the Dependency Rule should still apply.</p>
			<p>Overall, concerns are separated in each layer in Clean Architecture. Each layer is dedicated to address specific concerns that no other layers do:</p>
			<ul>
				<li><strong class="bold">Entities layer</strong>: Functional requirements shared among applications</li>
				<li><strong class="bold">Use Cases layer</strong>: Functional requirements within an application</li>
				<li><strong class="bold">Interface Adapters layer</strong>: Conversion between internal and external models</li>
				<li><strong class="bold">Frameworks and Drivers layer</strong>: Non-functional requirements</li>
			</ul>
			<p>With a clear separation of concerns, we now have the Entities layer and the Use Cases layer independent of the choices of frameworks and technologies. They have no knowledge about the external world. They are testable without <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>), databases, messaging, files, or any external representation. It is computationally cheap to execute a test in these two layers, and therefore we can afford to run a comprehensive test suite without significant penalty on build times.</p>
			<p>As the technology and framework choices only exist in the Interface Adapters layer and the Framework and Drivers layer, engineers can make changes to the framework in these layers, knowing that the functional logic in the Entities and Use Cases layers is intact. In addition, there could be test cases in these layers to ensure the correctness of internal-external model conversion, and the correctness of configuration of the framework in these layers.</p>
			<p>Moreover, it enables a smooth transition of technology change. A new technology can be introduced and coexist with the old one. Engineers can commit incrementally to the changes required for the new technology. There can be toggles to switch between the new and old technology for testing purposes. Once the team is happy with the change, they can switch to the new technology and clean up the code afterward.</p>
			<p>The hexagonal <a id="_idIndexMarker600"/>architecture is one of the architectural patterns that Clean Architecture is built upon. We are going to explore the hexagonal architecture in the next section.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor265"/>Hexagonal architecture</h1>
			<p>The <strong class="bold">hexagonal architecture</strong>, also<a id="_idIndexMarker601"/> known as the <strong class="bold">ports and adapters architecture</strong>, aims to <a id="_idIndexMarker602"/>address the problem of coupling between the core business logic and external dependencies, such as databases, UIs, and external systems.</p>
			<p>The hexagonal architecture was introduced by Alistair Cockburn in his paper, <em class="italic">Hexagonal Architecture</em>, published in 2005.</p>
			<p>The two fundamental concepts of this architectural style are <strong class="bold">ports</strong> and <strong class="bold">adapters</strong>. Ports define the interactions between the internal and the external worlds, and adapters provide the implementation details of these interactions.</p>
			<p>The concept of hexagonal architecture is visualized in <em class="italic">Figure 7</em><em class="italic">.3</em> as a hexagon. It is worth noting that this architecture allows as many sides as possible, not limited to only six as the name <em class="italic">hexagon</em> suggests.</p>
			<div><div><img src="img/B21737_07_3.jpg" alt="Figure 7.3 – An example of the hexagonal architecture" width="833" height="633"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – An example of the hexagonal architecture</p>
			<p>We will cover each <a id="_idIndexMarker603"/>element of the hexagonal architecture in the following sections.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor266"/>The core</h2>
			<p>The core of the <a id="_idIndexMarker604"/>hexagonal<a id="_idIndexMarker605"/> architecture encapsulates the business logic of the application in a pure way, without involving any technology and framework. The core is often called “the Domain.” The only exception may be a library that provides the data structure needed to support the business logic. The core does not depend on any adapter implementation.</p>
			<p>The core contains data structures and functions that represent pure business logic. Taking the same real-life example we have for households exchanging service, we should have these elements in the core:</p>
			<ul>
				<li><code>HouseHold</code>, <code>Party</code>, and <code>Contract</code> data<a id="_idIndexMarker606"/> classes; the <code>ContractState</code> enum class</li>
				<li><code>draftContract</code> function</li>
			</ul>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor267"/>Ports</h2>
			<p><strong class="bold">Ports</strong> are the interfaces <a id="_idIndexMarker607"/>describing what the application can do. There are two types of ports in the hexagonal <a id="_idIndexMarker608"/>architecture:</p>
			<ul>
				<li><strong class="bold">Primary port</strong>: Known as the driving port, this determines inputs required by the core to perform an operation</li>
				<li><strong class="bold">Secondary port</strong>: Known as the driven port, this determines what outputs are produced by the core for the external world’s consumption</li>
			</ul>
			<p>The port interfaces should be defined by the needs of the core and not the external world. If we are writing a new application from scratch, we should start from the core and define port interfaces for what the core needs, even without any code in adapters.</p>
			<p>In addition to the code we have in the core, we need to define port interfaces for the external world to use the core and consume the result produced by the core.</p>
			<p>In the real-life example where a household intends to draft a contract, the core validates the request and produces a drafted contract. The core needs a repository to store the drafted contract.</p>
			<p>We need a primary port to allow a contract to be drafted. The <code>ContractService</code> interface is exposed for external usage, but the implementation of the interface stays in the core:</p>
			<pre class="source-code">
 interface ContractService {
    fun draftContract(
        householdA: Household,
        householdB: Household,
        serviceProvidedByHouseholdA: String,
        serviceProvidedByHouseholdB: String,
    ): Contract
}</pre>			<p>We also need a secondary port to allow a draft contract to be persisted. The <code>ContractRepository</code> interface is implemented by adapters to provide the technical details of how a <code>Contract</code> object is saved:</p>
			<pre class="source-code">
interface ContractRepository {
    fun save(contract: Contract)
}</pre>			<p>The implementation of the primary port interface, <code>ContractService</code>, validates the draft contract and creates a <code>Contract</code> object with a <code>DRAFTED</code> state. Then, the <code>Contract</code> object <a id="_idIndexMarker609"/>is <a id="_idIndexMarker610"/>passed to <code>ContractRepository</code> to be saved:</p>
			<pre class="source-code">
 class ContractServiceImpl(
    private val contractRepository: ContractRepository,
) : ContractService {
    override fun draftContract(
        householdA: Household,
        householdB: Household,
        serviceProvidedByHouseholdA: String,
        serviceProvidedByHouseholdB: String,
    ): Contract =
        draftContract(
            householdA,
            householdB,
            serviceProvidedByHouseholdA,
            serviceProvidedByHouseholdB,
        ).also { contractRepository.save(it) }
}</pre>			<p>The <code>ContractServiceImpl</code> class is a part of the core logic and stays in the core. It is able to implement business behaviors without specifying how <code>Contract</code> is saved. In other words, the core focuses on business rules and is free of the concerns of the choice of technology <a id="_idIndexMarker611"/>and<a id="_idIndexMarker612"/> frameworks.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor268"/>Adapters</h2>
			<p>Adapters are <a id="_idIndexMarker613"/>responsible for translating external models to the internal models, which are defined in the core.</p>
			<p>Adapters use the primary port as an entrance to the core and run business operations. An adapter is tied to at least one framework, and it has an external representation of the entities involved.</p>
			<p>In the real-life example, the adapter can be a <code>POST</code> endpoint to create a draft contract. The payload is a JSON value, represented by the <code>DraftContractRequest</code> class, which can be converted into a <code>Contract</code> object:</p>
			<pre class="source-code">
data class DraftContractRequest(
    val householdA: String,
    val householdB: String,
    val serviceProvidedByHouseholdA: String,
    val serviceProvidedByHouseholdB: String
)</pre>			<p>Contract Service has locally cached <code>Household</code> objects, which can be looked up by household name from the <code>HouseholdRepository</code> repository:</p>
			<pre class="source-code">
interface HouseholdRepository {
    fun findByName(householdName: String): Household?
}</pre>			<p>The function returns a <code>Household</code> object if the household of the given name is found. Otherwise, it returns a <code>null</code> value. The REST controller class, <code>ContractController</code>, is defined to accept HTTP requests to draft a contract. This controller uses Spring Boot as the framework to register URI mapping:</p>
			<pre class="source-code">
@RestController
@RequestMapping("/contracts/")
class ContractController(
    private val contractService: ContractService,
    private val householdRepository: HouseholdRepository,
) {</pre>			<p>The controller is injected with the <code>ContractService</code> primary port to enter the core and draft a contract. It is also injected with the <code>HouseholdRepository</code> secondary port to look up <code>Household</code> objects for validation.</p>
			<pre class="source-code">
    @PostMapping(
        value = ["draft"],
        consumes = [MediaType.APPLICATION_JSON_VALUE],
        produces = [MediaType.APPLICATION_JSON_VALUE],
    )</pre>			<p>The controller <a id="_idIndexMarker615"/>defines a mapping of <code>POST /contracts/draft</code> that accepts JSON value as input and as output.</p>
			<pre class="source-code">
    fun draftContract(
        @RequestBody request: DraftContractRequest,
    ): ResponseEntity&lt;ContractDto&gt; {
        val householdA = householdRepository.findByName(request.householdA) ?: return ResponseEntity(HttpStatus.NOT_FOUND)
        val householdB = householdRepository.findByName(request.householdB) ?: return ResponseEntity(HttpStatus.NOT_FOUND)</pre>			<p>The controller converts the <code>DraftContractRequest</code> request payload and validates that household names in the payload exist. If any household does not exist, a <code>404 (Not Found)</code> HTTP status is returned to the requester.</p>
			<pre class="source-code">
         val contract =
            contractService.draftContract(
                householdA,
                householdB,
                request.serviceProvidedByHouseholdA,
                request.serviceProvidedByHouseholdB,
            )</pre>			<p>The controller invokes the <code>draftContract</code> function in the <code>ContractNegotiationService</code> primary port, which validates the request and persists the draft contract in the repository.</p>
			<pre class="source-code">
         return ResponseEntity(contract.toDto(), HttpStatus.CREATED)
}</pre>			<p>Finally, the operation<a id="_idIndexMarker616"/> has finished, and the controller returns a <code>201 (Created)</code> HTTP status back to the requester with the details of the draft contract. The response payload is represented by the <code>ContractDto</code> class:</p>
			<pre class="source-code">
 data class ContractDto(
    val householdA: String,
    val householdB: String,
    val serviceProvidedByHouseholdA: String,
    val serviceProvidedByHouseholdB: String,
    val contractState: String,
)</pre>			<p>There is a <code>toDto</code> function for the conversion from the internal model to the external model of the contract:</p>
			<pre class="source-code">
 fun Contract.toDto(): ContractDto =
    ContractDto(
        partyA.household.name,
        partyB.household.name,
        this.partyA.serviceProvided,
        this.partyB.serviceProvided,
        this.contractState.name,
    )</pre>			<p>The data was transformed and passed through the layers of the hexagonal architecture in this example, as demonstrated in <em class="italic">Figure 7</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B21737_07_4.jpg" alt="Figure 7.4 – Example use case of the hexagonal architecture" width="1325" height="810"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Example use case of the hexagonal architecture</p>
			<p>The request <a id="_idIndexMarker617"/>payload as JSON value is validated in the <code>ContractController</code> adapter with the help of a <code>HouseholdRepository</code> secondary port. Then, the payload is converted to the <code>Household</code> objects defined in the core. The core runs through the business process and uses a <code>ContractRepository</code> secondary port to persist a valid draft <code>Contract</code> object. Then, the result is populated to the <code>ContractController</code> adapter. Finally, the adapter converts the <code>Contract</code> object to a response payload.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor269"/>Benefits of hexagonal architecture</h2>
			<p>Separating source<a id="_idIndexMarker618"/> code in the layers of the hexagonal architecture certainly makes the code base more complicated. It does bring a few benefits by separating the source code between the core and the adapter.</p>
			<p>The core encapsulates pure business rules and the adapter contains all technology details. This separation makes it extremely easy to test the concerns of correctness and technology integration independently.</p>
			<p>The core contains a comprehensive test suite that ensures the business rules are enforced as intended, without involving any technology.</p>
			<p>On the other hand, the adapter contains test cases that verify the configuration of the chosen technology and frameworks work as intended, without mixing business rules.</p>
			<p>An adapter is designed to be pulled and replaced by another adapter at any time. An adapter is specifically implemented for a chosen technology or framework, but the port has no knowledge about it. For example, if the request and response use messaging technology, such as queuing, then we can replace <code>ContractController</code> with a different adapter, such as <code>DraftContractRequestConsumer</code>.</p>
			<p>The implementation of the secondary port as an adapter can also be replaced if needed. For example, we could have an implementation of a memory cache or relational database of <code>HouseholdRepository</code>. They can coexist and we can use configuration to decide which one is used at runtime. Each adapter can be tested in isolation.</p>
			<p>This separation of concerns results in enabling engineers to conform to the <strong class="bold">single responsibility principle</strong> (<strong class="bold">SRP</strong>), in which <a id="_idIndexMarker619"/>the core has only one reason to change, and each adapter has only one reason to change.</p>
			<p>Coming next, we are going to cover an architecture pattern that aims to solve this similar challenge, but in the functional style.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor270"/>Functional core, imperative shell</h1>
			<p> <strong class="bold">FCIS</strong> emerged as an <a id="_idIndexMarker620"/>architectural pattern over time in the functional programming community. It is a design principle that advocates separating the immutable core business logic from the mutable aspects, such as persistent storage or external system integration. It aligns and encourages functional programming principles with the use of stateless functions and immutable data structures.</p>
			<p>Stateless functions are sometimes called pure functions. They can be executed without causing side effects, in other words, for a given input, the function always produces the same output. Immutable data structures never change their content.</p>
			<p>The FCIS principle has been influenced by various software development paradigms and architectural patterns. It shares similarities with the hexagonal architecture, which also promotes separating the core logic from the infrastructure concerns.</p>
			<p>There are two major components in FCIS. The functional core contains stateless functions and immutable data structures that represent business logic and entities, respectively.</p>
			<p>The imperative shell, on the other hand, is the layer outside of the functional core that interacts with the external world, such as database operations, messaging, or UIs. This layer is responsible for<a id="_idIndexMarker621"/> executing the imperative and mutable operations required by the system.</p>
			<p>The FCIS architecture can be demonstrated in <em class="italic">Figure 7</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B21737_07_5.jpg" alt="Figure 7.5 – FCIS" width="689" height="694"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – FCIS</p>
			<p>We are going to cover these two components of this architectural style here.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor271"/>Functional core</h2>
			<p>The functional core<a id="_idIndexMarker622"/> focuses on the core business logic, which consists of stateless functions and immutable data structures only.</p>
			<p>Using the same real-life example we have for households exchanging service, we should have these elements in the core:</p>
			<ul>
				<li><code>HouseHold</code>, <code>Party</code>, and <code>Contract</code> data classes and the <code>ContractState</code> enum class</li>
				<li><code>draftContract</code> function</li>
			</ul>
			<p>All data classes are immutable, and all functions are stateless in our example. They are tested in isolation by simply verifying the output of the function given the input.</p>
			<p>However, the <code>draftContract</code> function would need a tweak from the implementation shown in the example from the Clean Architecture section, because we need to build up higher-order functions with potential errors found along the way.</p>
			<p>To start with this approach, we need to define what errors we may encounter. We will start with defining the types of errors first:</p>
			<pre class="source-code">
enum class ErrorType {
    HOUSEHOLD_NOT_FOUND,
    SAME_HOUSEHOLD_IN_CONTRACT
}</pre>			<p>We also need a wrapper data class for the error itself:</p>
			<pre class="source-code">
data class Error(
    val reason: String,
    val type: ErrorType
)</pre>			<p>We need to be able to communicate that functions can return an expected result, but there is also a chance an error occurred. This new implementation of <code>draftContract</code> uses the <code>Either</code> class from <strong class="bold">Arrow</strong> library to express this outcome:</p>
			<p class="callout-heading">Arrow</p>
			<p class="callout"><code>Option</code> and result types for error handling using <code>Either</code>. It also provides various functional programming patterns, such as functors, monads, and applicatives. Arrow aims to improve code readability, maintainability, and robustness by enabling developers to express computations in a functional style, making it easier to manage complex data flows and side effects in Kotlin applications.</p>
			<pre class="source-code">
 fun draftContract(
    householdA: Household,
    householdB: Household,
    serviceProvidedByHouseholdA: String,
    serviceProvidedByHouseholdB: String,
): Either&lt;Error, Contract&gt; =</pre>			<p>The <code>draftContract</code> function returns an <code>Either</code> object in which the left type parameter is always the <a id="_idIndexMarker623"/>potential error, and the right type parameter is always the expected result:</p>
			<pre class="source-code">
    if (householdA.name == householdB.name) {
        Either.Left(
            Error("Parties must be from different households", ErrorType.SAME_HOUSEHOLD_IN_CONTRACT),
        )
    }</pre>			<p>The same validation ensures the contract does not have the same <code>Household</code> on both sides. However, instead of throwing an exception, the function returns the left side value, which is represented by the <code>Error</code> class just defined earlier on.</p>
			<pre class="source-code">
      else {
        Either.Right(
            Contract(
                partyA = Party(householdA, serviceProvidedByHouseholdA),
                partyB = Party(householdB, serviceProvidedByHouseholdB),
                contractState = ContractState.DRAFTED,
            ),
        )
    }</pre>			<p>If everything is fine, the<a id="_idIndexMarker624"/> function returns the right side value, which is the <code>Contract</code> object itself.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor272"/>Imperative shell</h2>
			<p>The imperative shell<a id="_idIndexMarker625"/> handles the necessary interactions with the outside world, providing the necessary integration points and adaptors.</p>
			<p>In the real-life example, this includes the persistence of the <code>Contract</code> object and the REST endpoint controller that accepts HTTP <code>POST</code> requests to draft a contract.</p>
			<p>Apart from the REST controller, there are two more imperative operations involved. The first one looks up a <code>Household</code> object by the name, and the second one persists a <code>Contract</code> object. We define them using <code>typealias</code> in this example:</p>
			<pre class="source-code">
typealias HouseholdLookup = (String) -&gt; Household?
typealias ContractPersist = (Contract) -&gt; Either&lt;Error, Contract&gt;</pre>			<p>In addition to these two functions defined, we also need a function to ensure the household mentioned in the request exists:</p>
			<pre class="source-code">
fun DraftContractRequest.ensureHouseholdExist(
    householdLookup: HouseholdLookup
): Either&lt;Error, Pair&lt;Household, Household&gt;&gt; {
    val householdARecord = householdLookup(householdA)
    val householdBRecord = householdLookup(householdB)
    return if (householdARecord == null) {
        Either.Left(
            Error("Households not found: $householdA", ErrorType.HOUSEHOLD_NOT_FOUND),
        )
    } else if (householdBRecord == null) {
        Either.Left(
            Error("Households not found: $householdB", ErrorType.HOUSEHOLD_NOT_FOUND),
        )
    } else {
        Either.Right(
            householdARecord to householdBRecord,
        )
    }
}</pre>			<p>The <code>ensureHouseholdExist</code> function makes use of <code>HouseholdLookup</code> to check if the two households mentioned in the <code>DraftContractRequest</code> request exist. If not, the left side of <code>Either</code> will be returned to report the household not found error. If both households exist, the household records are returned for further processing.</p>
			<p>With this function <a id="_idIndexMarker626"/>defined, we can now inject them into the imperative controller implementation:</p>
			<pre class="source-code">
 @RequestMapping("/contracts/")
class ContractControllerShell(
    private val householdLookup: HouseholdLookup,
    private val contractPersist: ContractPersist,
) {
    @PostMapping(
        value = ["draft"],
        consumes = [MediaType.APPLICATION_JSON_VALUE],
        produces = [MediaType.APPLICATION_JSON_VALUE],
    )</pre>			<p>The <code>draft</code> function now takes full advantage of the <code>Either</code> class by collapsing the right type parameter <a id="_idIndexMarker627"/>with the <code>flatMap</code> function:</p>
			<pre class="source-code">
    fun draft(
        @RequestBody draftContractRequest: DraftContractRequest,
    ): ResponseEntity&lt;ContractDto&gt; =
        draftContractRequest
            .ensureHouseholdExist(householdLookup)
            .flatMap { (householdA, householdB) -&gt;
                draftContract(
                    householdA,
                    householdB,
                    draftContractRequest.serviceProvidedByHouseholdA,
                    draftContractRequest.serviceProvidedByHouseholdB,
                )
            }.flatMap { contractPersist(it) }
            .flatMap { Either.Right(it.toDto()) }
            .fold(
                { error -&gt; ResponseEntity(error.type.toHttpStatus()) },
                { contractDto -&gt; ResponseEntity(contractDto, HttpStatus.CREATED) },
            )</pre>			<p>The <code>flatMap</code> functions chain the results of <code>Either</code> to return either the first error on the left or the final expected result on the right. The preceding code firstly checks and ensures that both households mentioned in the request exist. The next chained call gets the household records from the <code>ensureHouseholdExist</code> function and it passes all parameters to the <code>draftContract</code> function to validate business rules and return a <code>Contract</code> object of the <code>DRAFTED</code> state.</p>
			<p>The next chained call receives the <code>Contract</code> object of the <code>DRAFTED</code> state and calls the <code>ContractPersist</code> function to persist this contract.</p>
			<p>After the <code>Contract</code> record is persisted, it is transformed into a <strong class="bold">data transfer object</strong> (<strong class="bold">DTO</strong>) that will <a id="_idIndexMarker628"/>be exposed and returned to the HTTP client that initiated the request.</p>
			<p>At the last part of the chained call, the <code>fold</code> function is invoked to differentiate the response back to the HTTP client. The success result as a <code>Contract</code> object, the right side, is converted to the <code>ContractDto</code> response payload by the <code>toDto</code> function. A <code>201 (Created)</code> HTTP status is returned together with the response payload.</p>
			<p>All the possible errors are collapsed onto the left side, and they are mapped to the HTTP status code, as <a id="_idIndexMarker629"/>shown here:</p>
			<pre class="source-code">
fun ErrorType.toHttpStatus(): HttpStatus = when (this) {
    ErrorType.HOUSEHOLD_NOT_FOUND -&gt; HttpStatus.NOT_FOUND
    ErrorType.SAME_HOUSEHOLD_IN_CONTRACT -&gt; HttpStatus.BAD_REQUEST
}</pre>			<h2 id="_idParaDest-179"><a id="_idTextAnchor273"/>Benefits of functional core, imperative shell</h2>
			<p>FCIS separates<a id="_idIndexMarker630"/> the code into two parts.</p>
			<p>The functional core is a purely functional area that only contains stateless functions and immutable data structures, which can be easily tested and reasoned about. There is no state management and no side effects. Each test is about verifying the output of the function given the input values.</p>
			<p>The functional core is also free of technology choice. It makes the functional core focus on only business concerns. There is no need to change the code if we decide to use other technologies to receive requests and produce responses. This makes the core logic reliable, adaptable, and maintainable.</p>
			<p>The only exception, as we shown in the example, is the use of the <code>Either</code> class brought from the Arrow library, to express that an operation can fail and return a different object.</p>
			<p>This encourages engineers to organize the code to conform to the SRP in which each function has only one reason to change. We still need to organize our functions with the best practices to conform to SRP though. For example, each function needs to be small, reusable, stateless, and with one purpose only.</p>
			<p>Separating the functional core from the imperative shell allows for easier evolution of the core logic without being tightly coupled to the external systems or implementation details. It also allows for greater flexibility and maintainability, leading to more robust and flexible software <a id="_idIndexMarker631"/>architectures.</p>
			<p>The next architectural pattern we are going to cover focuses on adapting to a remote API call.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor274"/>The Connect pattern</h1>
			<p>The Connect pattern <a id="_idIndexMarker632"/>was first introduced by David Denton in his technical article, <em class="italic">Smash your Adapter Monolith with the Connect pattern</em>, on the internet in 2011.</p>
			<p>This pattern, however, has a different focus from the three architectural patterns previously discussed. It is specifically targeted at remote system integration. It aims to provide a testable and extensible approach to encapsulate remote API interactions.</p>
			<p>The concept of the Connect pattern is illustrated in <em class="italic">Figure 7</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21737_07_6.jpg" alt="Figure 7.6 – The Connect pattern" width="664" height="797"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The Connect pattern</p>
			<p>An integration operation is abstracted as an Action. It understands how to generate a request and how to transform a response into an internal object. However, it does not know the connection details to the external system.</p>
			<p>An adapter, on the <a id="_idIndexMarker633"/>other hand, is crafted to adapt to a specific system. It can establish a connection with an external system while delegating the actual request-response exchange to an Action.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor275"/>Action</h2>
			<p>An <strong class="bold">Action</strong> is responsible<a id="_idIndexMarker634"/> for transforming requests from internal to external format and transforming responses from external to internal format. Using the same real-life example of the villagers exchanging services, there are some supporting functions that we need from the Household Service, and one of them is as simple as getting a household by the given household name.</p>
			<p>The Action related to communicating with the Household Service is defined here:</p>
			<pre class="source-code">
interface HouseholdApiAction&lt;R&gt; {
    fun toRequest(): Request
    fun fromResponse(response: Response): R
}</pre>			<p>There are only two simple functions. The <code>toRequest</code> function generates a request in an external format to communicate with Household Service. The <code>fromResponse</code> function transforms a response from Household Service to an internal object. The type variable, <code>R</code>, is specific to the given Action and can vary.</p>
			<p>The Action to get a<a id="_idIndexMarker635"/> household name by the given household name is defined here:</p>
			<pre class="source-code">
val householdLens = Body.auto&lt;Household&gt;().toLens()
data class GetHousehold(
    val householdName: String,
) : HouseholdApiAction&lt;Household&gt; {
    override fun toRequest(): Request = Request(Method.GET, "/households/$householdName")
    override fun fromResponse(response: Response): Household = householdLens(response)
}</pre>			<p>The <code>GetHousehold</code> class encapsulates the details needed to generate the HTTP request to Household Service. The response from Household Service is transformed to an internal data class, <code>Household</code>, using <code>Household</code> data class is defined here:</p>
			<pre class="source-code">
data class Household(
    val name: String,
    val emailAddress: String,
)</pre>			<p>So far, there are no <a id="_idIndexMarker638"/>connection details to Household Service, but this will be covered by the adapter.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor276"/>Adapter</h2>
			<p>The adapter class <a id="_idIndexMarker639"/>provides a way to abstract away the connectivity details and mechanism to an external system. The <code>Household</code> API is defined here:</p>
			<pre class="source-code">
interface HouseholdApi {
    operator fun &lt;R : Any&gt; invoke(action: HouseholdApiAction&lt;R&gt;): R
    companion object
}</pre>			<p>The <code>HouseholdApi</code> interface acts as a wrapper and handle for the invocation of the specific action. The companion object is defined as a placeholder for extension functions, which will be covered later. An HTTP implementation that communicates with a local Household Service is implemented as follows:</p>
			<pre class="source-code">
val token = "fakeToken"
fun HouseholdApi.Companion.Http(client: HttpHandler) =
    object : HouseholdApi {
        private val http =
 SetBaseUriFrom(Uri.of("http://localhost:9000"))
                .then(
                    Filter { next -&gt; { next(it.header("Authorization", "Bearer $token")) } },
                ).then(client)
        override fun &lt;R : Any&gt; invoke(action: HouseholdApiAction&lt;R&gt;) = action.fromResponse(http(action.toRequest()))
    }</pre>			<p>This <code>Household</code> API implementation is an anonymous inner class that sets the host of Household Service to localhost and sets the authorization bearer token. It assumes that all <code>HouseholdAction</code> would use the same connectivity settings.</p>
			<p>Moreover, an extension function is defined to make the usage code tidier:</p>
			<pre class="source-code">
fun HouseholdApi.getHousehold(householdName: String) = invoke(GetHousehold(householdName))</pre>			<p>The code usage <a id="_idIndexMarker640"/>example is going to be covered in the following section.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor277"/>Usage</h2>
			<p>With the Action <a id="_idIndexMarker641"/>and the adapter set up, the usage of the Household Service to get a household by the given name only requires three lines of code:</p>
			<pre class="source-code">
val app: HttpHandler =
    routes(
        "/households/{name}" bind GET to { request -&gt;
            val householdName = request.path("name")!!.toString()
            Response(OK).with(householdLens of Household(name = householdName, emailAddress = "same.address@domain.com"))
        },
    )
fun main() {
    val householdApi = HouseholdApi.Http(JavaHttpClient())
    val household: Household = householdApi.getHousehold("Whittington")
    println(household)
}</pre>			<p>The variable app is <code>HttpHandler</code>, which defines URI routings. Only a <code>GET</code> endpoint is defined in this example, together with a canned response back to the HTTP client.</p>
			<p>In the <code>main</code> function, an HTTP client implementation is created to be fed to create an HTTP implementation of <code>HouseholdApi</code>. Then, the extension function is used to get a household with the name <em class="italic">Whittington</em>. Internally, a <code>GetHousehold</code> Action is created and passed into <code>HouseholdApi</code> and kicks off the API communication. However, from a usage point of view, an <a id="_idIndexMarker642"/>object of the internal <code>Household</code> data class is returned.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor278"/>Test cases</h2>
			<p>One of the strengths <a id="_idIndexMarker643"/>of the Connect pattern is better testability. Each Action and API with the Household Service can be tested individually. This is the test case of getting a household from the Household API:</p>
			<pre class="source-code">
    @Test
    fun `Get the household from Household API`() {
        assertEquals(
            Response(OK)
                .contentType(ContentType.APPLICATION_JSON)
                .body("{\"name\":\"Whittington\",\"emailAddress\":\"same.address@domain.com\"}"),
            app(Request(GET, "/households/Whittington")),
        )
    }</pre>			<p>When there are more Actions, there will be more test cases, but each test case is isolated. In other <a id="_idIndexMarker644"/>words, the Actions and test cases scale without creating an interface with many functions.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor279"/>Benefits</h2>
			<p>The major benefits <a id="_idIndexMarker645"/>of the Connect pattern are extensibility and testability. Given it is common to use multiple APIs of an external system, engineers often end up with one interface for the external system with many functions. With the Connect pattern, each API call is represented by an Action and thus breaks down the big interface into smaller pieces.</p>
			<p>This pattern naturally conforms to the SRP as an Action represents only one API call. Moreover, each Action has its own dedicated test case, which is a lot simpler than testing an interface with many functions.</p>
			<p>The adapter has abstracted away the concern of connectivity details to a remote system, so Action classes can focus on the message formats and interactions.</p>
			<p>The use of Kotlin extension functions makes the code usage fluent, tidy, and small. A lot of details are hidden and encapsulated within the Action and adapter classes.</p>
			<p>Although the example uses HTTP and Kotlin, the Connect pattern itself is not restricted to them.</p>
			<p>This pattern is particularly useful in the usage of communicating with a monolithic application that<a id="_idIndexMarker646"/> exposes a lot of functions in one interface.</p>
			<p>Coming next, we are going to briefly compare these architectural styles.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor280"/>Comparisons of architectural styles</h1>
			<p>The first three architectural <a id="_idIndexMarker647"/>styles we discussed in this chapter have a great deal of similarities. They all aim to solve the same issues; the variations are in the approaches.</p>
			<p>Meanwhile, the Connect pattern focuses on the testability and extensibility of remote system interactions.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor281"/>Dependency on frameworks and technologies</h2>
			<p>Traditional <a id="_idIndexMarker648"/>architectures often tightly couple the business logic with specific frameworks, libraries, or technologies. This makes it difficult to switch or upgrade these components without making widespread changes throughout the code base.</p>
			<p>Clean Architecture proposes the Entities layer for enterprise business rules and the Use Cases layer for application-specific business rules. Both are neutral to choices of frameworks and technologies.</p>
			<p>The hexagonal architecture proposes the core as the centerpiece for business logic, also free of the choices of frameworks and technologies.</p>
			<p>FCIS proposes the functional core for business logic, but with the use of stateless functions and immutable data structures.</p>
			<p>The Connect pattern uses Action for the integration point of a single action and an adapter for the transport<a id="_idIndexMarker649"/> details of the interaction with the remote system.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor282"/>Testability</h2>
			<p>In traditional architectures, testing<a id="_idIndexMarker650"/> the core business logic can be challenging due to dependencies on external systems, databases, or UI frameworks.</p>
			<p>Testing a function coupled with a choice of technology typically requires a lot of setting up and tearing down of resources, and worse if there are asynchronous processes behind the scenes. This means it requires more effort from engineers to make the tests work, fewer tests can be written for the same amount of time, the test suite takes longer to run, and there could be flaky tests that fail occasionally due to some asynchronous processes involved. Any parallel executed tests can make the test suite even more flaky.</p>
			<p>Clean Architecture offers dedicated layers for business logic only (the Entities and Use Cases layers), which can be tested in isolation without involving any choice of technology. The Interface Adapters layer focuses on internal and external model translation, which can be also tested independently. The configurations of the Frameworks &amp; Driver layers can be tested without involving business rules.</p>
			<p>The hexagonal architecture advocates the core as a technology-neutral area where unit tests can be easily written without the need for complex setups or mocking extensive external components. Each adapter can be tested individually and without involving any business logic.</p>
			<p>FCIS suggests putting only business logic as stateless functions and immutable data structures in the functional core. This reduces testing of the functional core using a simple verification of the output result given by input. The imperative shell can also be tested easily by swapping the lower-order functions in the functional core, as a result, the immutable and the mutable parts of the systems can be tested separately.</p>
			<p>The Connect pattern breaks down the large remote interface of a monolithic application into one Action per API call. This reduces a lot of overhead, excessive mocking, test double, or stubbing of the interface. The ability to test an API call in isolation improves testability and enables easy extension of the usage of a remote API.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor283"/>Maintainability</h2>
			<p>Over time, applications<a id="_idIndexMarker651"/> tend to evolve and change, often requiring modifications to the core business logic or the choice of frameworks. In traditional architectures, making changes can be risky as these modifications may have unintended consequences throughout the system. Updating business logic may have intertwined with a deprecated library and eventually, both need to be changed.</p>
			<p>Clean Architecture, the hexagonal architecture, and FCIS provide a clear separation between the core business logic and the surrounding infrastructure, making it easier to modify or extend the application without affecting the core business rules.</p>
			<p>The Connect pattern is very lightweight and there is no overlapping among Actions. The connectivity and message interaction concerns are separated into adapter and Action classes, the maintenance of these classes is simple, and code changes are small.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor284"/>Flexibility and adaptability</h2>
			<p>Applications often need <a id="_idIndexMarker652"/>to integrate with various external resources, such as files, databases, third-party services, or UIs. In traditional architectures, these integrations are deeply embedded within the application code, making it challenging to switch or modify these integrations.</p>
			<p>Clean Architecture promotes the Interface Adapters and Frameworks and Drivers layers to contain external dependencies. This allows more flexibility and adaptability, as the business rules remain decoupled from specific technologies or protocols.</p>
			<p>The hexagonal architecture promotes the use of ports and adapters, which act as interfaces and adapters between the core logic and the external systems. A different choice of framework results in a separate implementation of adapters but the port interfaces remain the same. Changing technology or a protocol is easy by swapping an implementation of the same interface.</p>
			<p>FCIS uses the imperative shell layer to handle all the interactions with the external world. Any change in technology or protocol requires a change only in the imperative shell layer. With the high-level reuse of small functions, only a minor change is required to adapt to a new technology.</p>
			<p>The Connect pattern allows engineers to implement a new adapter if it needs to integrate with a new remote system. If it needs to adapt to a new communication protocol, it is required to implement a new adapter and new Action, but there is no need to update<a id="_idIndexMarker653"/> the current code.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor285"/>When to use which architectural style</h1>
			<p>Clean Architecture, the <a id="_idIndexMarker654"/>hexagonal architecture, and FCIS share a great deal of similarities that engineers may find hard to choose for their applications. The layers of these three architectural styles can be approximately mapped as follows:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Clean Architecture</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Hexagonal Architecture</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">FCIS</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Entities</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Shared / Common libs</p>
						</td>
						<td class="No-Table-Style">
							<p>Shared / Common libs</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Use Case</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Core / Domain / Port</p>
						</td>
						<td class="No-Table-Style">
							<p>Core</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Interface Adapters</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Adapters</p>
						</td>
						<td class="No-Table-Style">
							<p>Shell</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Frameworks </strong><strong class="bold">and Drivers</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Adapters</p>
						</td>
						<td class="No-Table-Style">
							<p>Shell</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – Approximate mapping among the three architectural styles</p>
			<p>If we accept the opinion that the three styles can be loosely mapped, then the choice would become convention among engineers. The following are some opinions for reference but they are not strict rules:</p>
			<ul>
				<li>Engineers with more functional programming experience would prefer FCIS.</li>
				<li>Clean Architecture provides better support to monolithic applications or systems with a big source repository. Having said that, Clean Architecture can absolutely support smaller repositories or microservices.</li>
				<li>The hexagonal architecture fits microservice applications in terms of scope and scale.</li>
			</ul>
			<p>There are also a lot of rooms to create a hybrid style. For instance, an application using the hexagonal architecture can borrow the concepts of FCIS, so all ports and adapters are basically functions using the Kotlin operator overload features:</p>
			<pre class="source-code">
class DummyContractPersist: ContractPersist {
    override fun invoke(p1: Contract): Either&lt;Error, Contract&gt; {</pre>			<p><code>ContractPersist</code> is a type alias we used in FCIS, and we can define a class that implements the type alias interface and provides the <code>invoke</code> function with operator override. So, in practice, callers can skip the <code>invoke</code> keyword and treat it as a function, like the following:</p>
			<pre class="source-code">
    val persist = DummyContractPersist()
    val result = persist(contract)</pre>			<p>So, this concept can be extended to port interfaces, where they are only type aliases or interfaces with one function only.</p>
			<p>The Connect pattern is an integration pattern that solves a different problem than the other three styles covered in this chapter. The Connect pattern can be used when there is a need to perform<a id="_idIndexMarker655"/> the same action in a business sense using external systems, but we want to decouple the technical integration details from the business logic.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor286"/>In relation to the anemic domain model</h1>
			<p>The <strong class="bold">anemic domain model</strong> (<strong class="bold">ADM</strong>) is a controversial<a id="_idIndexMarker656"/> architectural style that some people classify as an anti-pattern, while others find it useful in certain circumstances. In the ADM, the core or Use Cases layer has mainly data structures and little to zero business behaviors.</p>
			<p>The in-depth discussion on ADM is beyond the scope of this chapter, however, if a team has chosen to use ADM, then it is not advisable to combine it with Clean Architecture, the hexagonal architecture, or FCIS.</p>
			<p>The main reason is that these architectures are designed to have business behaviors kept in the core or Use Cases layer; in other words, they<a id="_idIndexMarker657"/> are designed to work with the <strong class="bold">rich domain model</strong> (<strong class="bold">RDM</strong>) only. The application does not get any benefit from adopting the layers from Clean Architecture, the hexagonal architecture, or FCIS covered in this chapter.</p>
			<p class="callout-heading">Usage of ADM</p>
			<p class="callout">Although ADM may be seen<a id="_idIndexMarker658"/> as an anti-pattern to some people, the lack of business behaviors may mean the application’s goals are data processing and infrastructure plumbing only. For example, an ADM application may be responsible for ingesting a large file, splitting the data in the file into chunks, and processing each chunk in parallel. The application focuses on data manipulation and scalability, meanwhile, the processed data is read by other downstream applications that contain actual business behaviors related to the data. Another example could be an application that consumes the headers of external messages and forwards these messages to their corresponding internal topics for further processing.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor287"/>Organizing source code as layers</h1>
			<p>There are two<a id="_idIndexMarker659"/> popular choices for organizing source code as layers. In Kotlin, the first approach is to put files into their belonging packages as layers.</p>
			<p>In the real-life example we used, we could have the following packages in each architectural style:</p>
			<ul>
				<li><strong class="bold">Clean Architecture</strong>:<pre class="source-code">
org.example.service.negotiation.entity
org.example.service.negotiation.usecase
org.example.service.negotiation.interface
org.example.service.negotiation.framework
org.example.service.negotiation.framework.rest</pre></li>				<li><strong class="bold">Hexagonal architecture</strong>:<pre class="source-code">
org.example.service.negotiation.core
org.example.service.negotiation.core.port
org.example.service.negotiation.adapter
org.example.service.negotiation.adapter.rest</pre></li>				<li><strong class="bold">FCIS</strong>:<pre class="source-code">
org.example.service.negotiation.core
org.example.service.negotiation.shell
org.example.service.negotiation.shell.rest</pre></li>			</ul>
			<p>Enforcing the layered architecture, where only the outer layer can use the inner layer and not the other way round, can easily be done using test cases and includes passing them as a part of a successful build.</p>
			<p>This is an exampl<a id="_idIndexMarker660"/>e of a test case that enforces the FCIS layer<a id="_idIndexMarker661"/> dependency, using <strong class="bold">ArchUnit</strong> as the test driver:</p>
			<pre class="source-code">
    val classes = ClassFileImporter().importPackages("fcis")
    @Test
    fun `layer dependencies are_respected`() {
        layeredArchitecture()
            .consideringAllDependencies()
            .layer("Imperative Shell")
            .definedBy("fcis.shell..")
            .layer("Functional Core")
            .definedBy("fcis.core..")
            .whereLayer("Imperative Shell")
            .mayNotBeAccessedByAnyLayer()
            .whereLayer("Functional Core")
            .mayOnlyBeAccessedByLayers("Imperative Shell")
            .check(classes)
    }</pre>			<p>The second approach is the use of a source code module within a build framework, such as <strong class="bold">Gradle</strong> or <strong class="bold">Maven</strong>. We <a id="_idIndexMarker662"/>create<a id="_idIndexMarker663"/> multi-module projects for an application, and the outer modules declare dependencies on inner modules.</p>
			<p>For example, the imperative shell of the Negotiation Service can have explicit dependencies declared in the Gradle Kotlin script of the imperative shell module.</p>
			<pre class="source-code">
implementation("com.example:service-negotiation-core")</pre>			<p>It is important to note that this approach is more heavy-weighted than the package approach as it creates actual artifacts of inner layers.</p>
			<p>The Connect pattern, however, is<a id="_idIndexMarker664"/> a modular but not layered architecture, so there is no need to enforce layer dependencies.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor288"/>Summary</h1>
			<p>In this chapter, we discussed three architectural styles that aim to solve the same issues in traditional architectures where business logic and technology choices are tightly coupled. These three architectures were covered in depth: Clean Architecture, hexagonal architecture, and FCIS. We also discussed the Connect pattern, which focuses on breaking down large remote interfaces for integrating with remote systems.</p>
			<p>We illustrated each architectural style using our real-life example and how each style is implemented in code.</p>
			<p>We also compared the four architecture styles in terms of how they tackle the issues in traditional architecture. We briefly covered how code can be organized in a repository under layered architectures.</p>
			<p>We mentioned that the core in the hexagonal architecture is sometimes named the <em class="italic">domain</em>. However, the term “domain” itself is worth a lengthy discussion. In the next chapter, we are going to cover the concepts surrounding the domain, with one common theme – <strong class="bold">domain-driven </strong><strong class="bold">development</strong> (<strong class="bold">DDD</strong>).</p>
		</div>
	</div></div></body></html>