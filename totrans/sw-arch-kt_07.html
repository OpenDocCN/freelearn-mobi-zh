<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer067">
			<h1 id="_idParaDest-161" class="chapter-number"><a id="_idTextAnchor255"/>7</h1>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor256"/>Modular and Layered Architectures</h1>
			<p>The previous chapters have repeatedly mentioned the importance of appropriate modularization of the system and addressing concerns separately. In this chapter, we delve into four prominent architectural patterns that offer their approaches to separate concerns in layers, modularize code, and set up clean boundaries <span class="No-Break">among modules.</span></p>
			<p>All these patterns will be illustrated with the same real-life example to highlight the similarities and differences of <span class="No-Break">these patterns.</span></p>
			<p>By understanding these patterns with code examples in Kotlin, engineers can make informed choices to create loosely coupling and highly cohesive modules that are testable, flexible, <span class="No-Break">and maintainable.</span></p>
			<p>The following architectural patterns will <span class="No-Break">be covered:</span></p>
			<ul>
				<li><span class="No-Break">Clean Architecture</span></li>
				<li>The <span class="No-Break">hexagonal architecture</span></li>
				<li><strong class="bold">Functional core, imperative </strong><span class="No-Break"><strong class="bold">shell</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">FCIS</strong></span><span class="No-Break">)</span></li>
				<li>The <span class="No-Break">Connect pattern</span></li>
			</ul>
			<p>At the end, these patterns will be briefly compared with one another. We will also explore the possibility of taking elements from each pattern to create a hybrid pattern to meet <span class="No-Break">the requirements.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor257"/>Technical requirements</h1>
			<p>You can find the code files used in this chapter on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7%0D"><span class="No-Break">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7</span></a></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor258"/>Clean Architecture</h1>
			<p><strong class="bold">Clean Architecture</strong> is an<a id="_idIndexMarker570"/> architectural pattern that advocates organizing a software system into distinct layers, each with its own responsibilities <span class="No-Break">and dependencies.</span></p>
			<p>The term Clean Architecture was introduced by Robert Martin (known as <em class="italic">Uncle Bob</em>) in his book titled <em class="italic">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</em>, published in 2017. The foundation of this approach is built upon a few earlier <span class="No-Break">architectural patterns:</span></p>
			<ul>
				<li><strong class="bold">The hexagonal architecture</strong> (also known<a id="_idIndexMarker571"/> as <strong class="bold">ports and adapters</strong>) by <span class="No-Break">Alistair Cockburn</span></li>
				<li><strong class="bold">Onion Architecture</strong> by <span class="No-Break">Jeffrey Palermo</span></li>
				<li><strong class="bold">Screaming Architecture</strong> by <span class="No-Break">Robert Martin</span></li>
				<li><strong class="bold">Data, context, and interaction</strong> (<strong class="bold">DCI</strong>) by James<a id="_idIndexMarker572"/> Coplien and <span class="No-Break">Trygve Reenskaug</span></li>
				<li><strong class="bold">Boundary-control-entity</strong> (<strong class="bold">BCE</strong>) by <a id="_idIndexMarker573"/><span class="No-Break">Ivar Jacobson</span></li>
			</ul>
			<p>Clean Architecture dissects a software system by numerous layers, where each layer is wrapped one on top of the other, like an onion. The <strong class="bold">Dependency Rule</strong> of<a id="_idIndexMarker574"/> Clean Architecture states that the outer layers always depend on the <span class="No-Break">inner layers.</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B21737_07_1.jpg" alt="Figure 7.1 – Clean Architecture" width="1163" height="1164"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Clean Architecture</p>
			<p>Due to the Dependency Rule, any change in the outer layer does not affect the inner layer. On the contrary, any change in the inner layer may affect the <span class="No-Break">outer layer.</span></p>
			<p>Let us go through the layer from the innermost to the outermost, demonstrated by the real-life example we <a id="_idIndexMarker575"/>use throughout previous chapters—households in a village exchanging services with <span class="No-Break">each other.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor259"/>Entities</h2>
			<p>The <strong class="bold">Entities layer</strong> is the <a id="_idIndexMarker576"/>innermost layer, which depends <a id="_idIndexMarker577"/>on no other layer. This layer is designed to encapsulate business rules shared <span class="No-Break">among applications.</span></p>
			<p>It contains mostly data structures and functions only. It rarely depends on external libraries. The only libraries it depends on are most likely those that provide specialized data structures. This layer is also the least likely <span class="No-Break">to change.</span></p>
			<p>In our real-life example, there are a few candidates suitable to be hosted in the Entities layer. <strong class="source-inline">Household</strong>, <strong class="source-inline">Contract</strong>, <strong class="source-inline">Service</strong>, and subclasses of <strong class="source-inline">Service</strong> as Kotlin data classes belong to the Entities layer. Certain rules and policies can also reside in the Entities layer. Here are a few <span class="No-Break">example rules.</span></p>
			<h3>Rule 1 – Household name must not be null and must have at least one member</h3>
			<p>This rule is enforced by the Kotlin non-null field syntax in data classes and the validation within the <span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
data class Household(
    val name: String,
    val members: List&lt;String&gt;
) {
    init {
        require(members.isNotEmpty()) { "Household must have at least one member" }
    }
}</pre>			<h3>Rule 2 – Contract must be in one of the specified states</h3>
			<p>This rule is <a id="_idIndexMarker578"/>enforced <a id="_idIndexMarker579"/>by the Kotlin <span class="No-Break">enumeration feature:</span></p>
			<pre class="source-code">
enum class ContractState {
    DRAFTED,
    UNDER_REVIEW,
    AGREED,
    REJECTED,
    PARTIALLY_EXERCISED,
    FULLY_EXERCISED,
    WITHDRAWN
}</pre>			<h3>Rule 3 – a Contract consists of two Household objects and a state</h3>
			<p>This rule is enforced by Kotlin <span class="No-Break">data classes:</span></p>
			<pre class="source-code">
data class Party(
    val household: Household,
    val serviceProvided: String,
    val agreedAt: Instant? = null,
    val completedAt: Instant? = null
)
data class Contract(
    val partyA: Party,
    val partyB: Party,
    val contractState: ContractState
)</pre>			<p>These classes are Pure Kotlin and can be shared among the four services we defined earlier in <a href="B21737_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, namely <em class="italic">Household Service</em>, <em class="italic">Contract Service</em>, and <em class="italic">Notification Service</em>. Arguably, Household <a id="_idIndexMarker580"/>Service does not need a <strong class="source-inline">Contract</strong> class, and <a id="_idIndexMarker581"/>this may be a trade-off for most services to share entity classes but <span class="No-Break">not all.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor260"/>Use Cases</h2>
			<p>The <strong class="bold">Use Cases layer</strong> is <a id="_idIndexMarker582"/>one layer above the Entities layer. It is<a id="_idIndexMarker583"/> designed to encapsulate business rules within <span class="No-Break">an application.</span></p>
			<p>It contains use cases that make use of the data structures and functions in the Entities layer. Any change in this layer should not affect the Entities layer. This layer should also remain neutral to choices of frameworks and technologies, such as databases <span class="No-Break">and messaging.</span></p>
			<p>In our real-life example, we have a use case of a household drafting a contract with another household, using the <span class="No-Break">Negotiation Service:</span></p>
			<pre class="source-code">
fun draftContract(
    householdA: Household,
    householdB: Household,
    serviceProvidedByHouseholdA: String,
    serviceProvidedByHouseholdB: String,
): Contract {
    require(householdA != householdB) { "Parties must be from different households" }
    return Contract(Party(
        householdA,
        serviceProvidedByHouseholdA,
    ), Party(
        householdB,
        serviceProvidedByHouseholdB,
    ), ContractState.DRAFTED)
}</pre>			<p>The <strong class="source-inline">draftContract</strong> function validates that the two households are not the same. If everything looks good, it creates a contract with both households and their services to be provided. In addition, it set the contract state to <strong class="source-inline">DRAFTED</strong>. This <strong class="source-inline">draftContract</strong> function in the Use Cases layer makes use of the <strong class="source-inline">Household</strong>, <strong class="source-inline">Party</strong>, <strong class="source-inline">ContractState</strong>, and <strong class="source-inline">Contract</strong> classes from the <span class="No-Break">Entities layer.</span></p>
			<p>There could be a bit of fluidity between the Entities layer and the Use Cases layer. If one feature in Entities <a id="_idIndexMarker584"/>is considered only relevant to one application, it<a id="_idIndexMarker585"/> can be moved to the Use Cases layer. Similarly, if there are duplicated logics in the Use Cases layer in different applications, they can be extracted into the <span class="No-Break">Entities layer.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor261"/>Interface Adapters</h2>
			<p>The Entities and Use<a id="_idIndexMarker586"/> Cases layers are considered internal models, where data structures are not exposed outside of the application. The <strong class="bold">Interface Adapters layer</strong> serves <a id="_idIndexMarker587"/>as the translation between the internal and the external models. Typical examples of external models are relational database tables, message payloads, HTTP request and response payloads, file formats, and visual representation<a id="_idIndexMarker588"/> in the <strong class="bold">graphical user </strong><span class="No-Break"><strong class="bold">interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">GUI</strong></span><span class="No-Break">).</span></p>
			<p>We already have a few examples of where the code should stay in the Interface <span class="No-Break">Adapters layer:</span></p>
			<ul>
				<li>The peer-to-peer architectures covered in <a href="B21737_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> have illustrated the example code of <a id="_idIndexMarker589"/>conversion between a <strong class="source-inline">Contract</strong> object and a binary payload used for <strong class="bold">User Datagram Protocol</strong> (<span class="No-Break"><strong class="bold">UDP</strong></span><span class="No-Break">) transmission.</span></li>
				<li>In the same chapter, there is a similar example, but the conversion is between a <strong class="source-inline">Contract</strong> object<a id="_idIndexMarker590"/> and a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) payload that is<a id="_idIndexMarker591"/> defined by <strong class="bold">OpenAPI</strong> specifications, under the <span class="No-Break">client-server architecture.</span></li>
				<li>The three frontend architectural styles covered in <a href="B21737_05.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, MVC, MVP, and MVVM, would have the corresponding code in this layer, as they transform internal models to the view that is rendered <span class="No-Break">as GUI.</span></li>
			</ul>
			<p>If the application uses query languages, such as SQL, for relational databases, they should also stay in the Interface <span class="No-Break">Adapters layer.</span></p>
			<p>These external models and their corresponding conversion should not leak into other layers. The layer<a id="_idIndexMarker592"/> should not contain business logic <a id="_idIndexMarker593"/>either. The concern of internal models is separated from layers outside of the Interface Adapters layer, and the concern of external models is separated from layers inside of the Interface <span class="No-Break">Adapters layer.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor262"/>Frameworks and Drivers</h2>
			<p>The Frameworks and <a id="_idIndexMarker594"/>Drivers layer is <a id="_idIndexMarker595"/>one layer outside of the Interface Adapters layer. This is where external frameworks are added to make it an application. Typical examples are HTTP endpoint routing configurations, database connection details, Kubernetes configurations, and dependency management. Quite often, this layer contains configuration files more than <span class="No-Break">source code.</span></p>
			<p>This layer should never contain business use cases. It does not know any internal models and therefore no conversion from external models. This layer focuses on supporting configurations that turn code into an application executable in a runtime. It should address only non-functiona<a id="_idIndexMarker596"/>l requirements, such as<a id="_idIndexMarker597"/> startup time, <span class="No-Break">or redundancy.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor263"/>An example use case with Clean Architecture</h2>
			<p>Let us take a <a id="_idIndexMarker598"/>use case as an example of how different layers are used. A household is presented with a form to submit a draft contract, which is a web page in the Frameworks and <span class="No-Break">Drivers layer.</span></p>
			<p>The household then submits the form as JSON values and enters the controller in the Interface Adapters layer. The controller converts the form into a few internal objects, such as the objects of both <strong class="source-inline">Household</strong> and the services provided as strings. These internal objects are then passed to a <strong class="source-inline">draftContract</strong> function in the Use <span class="No-Break">Cases layer:</span></p>
			<pre class="source-code">
fun draftContract(
    householdA: Household,
    householdB: Household,
    serviceProvidedByHouseholdA: String,
    serviceProvidedByHouseholdB: String,
): Contract</pre>			<p>The function creates a <strong class="source-inline">Contract</strong> object, which comes from the Entities layer. The function passes a <strong class="source-inline">Contract</strong> object to the presenter in the Interface Adapters layer. The presenter converts the <strong class="source-inline">Contract</strong> object into a JSON value to be rendered by the web page in the Frameworks and Drivers layer. The whole journey is illustrated in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B21737_07_2.jpg" alt="Figure 7.2 – Example use case of Clean Architecture" width="1127" height="614"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Example use case of Clean Architecture</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor264"/>Benefits of Clean Architecture</h2>
			<p>The centerpiece <a id="_idIndexMarker599"/>of Clean Architecture is the Dependency Rule, not the four defined layers. With justifications, there could be variation in the layers, but the Dependency Rule should <span class="No-Break">still apply.</span></p>
			<p>Overall, concerns are separated in each layer in Clean Architecture. Each layer is dedicated to address specific concerns that no other <span class="No-Break">layers do:</span></p>
			<ul>
				<li><strong class="bold">Entities layer</strong>: Functional requirements shared <span class="No-Break">among applications</span></li>
				<li><strong class="bold">Use Cases layer</strong>: Functional requirements within <span class="No-Break">an application</span></li>
				<li><strong class="bold">Interface Adapters layer</strong>: Conversion between internal and <span class="No-Break">external models</span></li>
				<li><strong class="bold">Frameworks and Drivers layer</strong>: <span class="No-Break">Non-functional requirements</span></li>
			</ul>
			<p>With a clear separation of concerns, we now have the Entities layer and the Use Cases layer independent of the choices of frameworks and technologies. They have no knowledge about the external world. They are testable without <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>), databases, messaging, files, or any external representation. It is computationally cheap to execute a test in these two layers, and therefore we can afford to run a comprehensive test suite without significant penalty on <span class="No-Break">build times.</span></p>
			<p>As the technology and framework choices only exist in the Interface Adapters layer and the Framework and Drivers layer, engineers can make changes to the framework in these layers, knowing that the functional logic in the Entities and Use Cases layers is intact. In addition, there could be test cases in these layers to ensure the correctness of internal-external model conversion, and the correctness of configuration of the framework in <span class="No-Break">these layers.</span></p>
			<p>Moreover, it enables a smooth transition of technology change. A new technology can be introduced and coexist with the old one. Engineers can commit incrementally to the changes required for the new technology. There can be toggles to switch between the new and old technology for testing purposes. Once the team is happy with the change, they can switch to the new technology and clean up the <span class="No-Break">code afterward.</span></p>
			<p>The hexagonal <a id="_idIndexMarker600"/>architecture is one of the architectural patterns that Clean Architecture is built upon. We are going to explore the hexagonal architecture in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor265"/>Hexagonal architecture</h1>
			<p>The <strong class="bold">hexagonal architecture</strong>, also<a id="_idIndexMarker601"/> known as the <strong class="bold">ports and adapters architecture</strong>, aims to <a id="_idIndexMarker602"/>address the problem of coupling between the core business logic and external dependencies, such as databases, UIs, and <span class="No-Break">external systems.</span></p>
			<p>The hexagonal architecture was introduced by Alistair Cockburn in his paper, <em class="italic">Hexagonal Architecture</em>, published <span class="No-Break">in 2005.</span></p>
			<p>The two fundamental concepts of this architectural style are <strong class="bold">ports</strong> and <strong class="bold">adapters</strong>. Ports define the interactions between the internal and the external worlds, and adapters provide the implementation details of <span class="No-Break">these interactions.</span></p>
			<p>The concept of hexagonal architecture is visualized in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.3</em> as a hexagon. It is worth noting that this architecture allows as many sides as possible, not limited to only six as the name <span class="No-Break"><em class="italic">hexagon</em></span><span class="No-Break"> suggests.</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B21737_07_3.jpg" alt="Figure 7.3 – An example of the hexagonal architecture" width="833" height="633"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – An example of the hexagonal architecture</p>
			<p>We will cover each <a id="_idIndexMarker603"/>element of the hexagonal architecture in the <span class="No-Break">following sections.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor266"/>The core</h2>
			<p>The core of the <a id="_idIndexMarker604"/>hexagonal<a id="_idIndexMarker605"/> architecture encapsulates the business logic of the application in a pure way, without involving any technology and framework. The core is often called “the Domain.” The only exception may be a library that provides the data structure needed to support the business logic. The core does not depend on any <span class="No-Break">adapter implementation.</span></p>
			<p>The core contains data structures and functions that represent pure business logic. Taking the same real-life example we have for households exchanging service, we should have these elements in <span class="No-Break">the core:</span></p>
			<ul>
				<li><strong class="bold">Data structures</strong>: The  <strong class="source-inline">HouseHold</strong>, <strong class="source-inline">Party</strong>, and <strong class="source-inline">Contract</strong> data<a id="_idIndexMarker606"/> classes; the <strong class="source-inline">ContractState</strong> <span class="No-Break">enum class</span></li>
				<li><strong class="bold">Functions</strong>: The <span class="No-Break"><strong class="source-inline">draftContract</strong></span><span class="No-Break"> function</span></li>
			</ul>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor267"/>Ports</h2>
			<p><strong class="bold">Ports</strong> are the interfaces <a id="_idIndexMarker607"/>describing what the application can do. There are two types of ports in the <span class="No-Break">hexagonal </span><span class="No-Break"><a id="_idIndexMarker608"/></span><span class="No-Break">architecture:</span></p>
			<ul>
				<li><strong class="bold">Primary port</strong>: Known as the driving port, this determines inputs required by the core to perform <span class="No-Break">an operation</span></li>
				<li><strong class="bold">Secondary port</strong>: Known as the driven port, this determines what outputs are produced by the core for the external <span class="No-Break">world’s consumption</span></li>
			</ul>
			<p>The port interfaces should be defined by the needs of the core and not the external world. If we are writing a new application from scratch, we should start from the core and define port interfaces for what the core needs, even without any code <span class="No-Break">in adapters.</span></p>
			<p>In addition to the code we have in the core, we need to define port interfaces for the external world to use the core and consume the result produced by <span class="No-Break">the core.</span></p>
			<p>In the real-life example where a household intends to draft a contract, the core validates the request and produces a drafted contract. The core needs a repository to store the <span class="No-Break">drafted contract.</span></p>
			<p>We need a primary port to allow a contract to be drafted. The <strong class="source-inline">ContractService</strong> interface is exposed for external usage, but the implementation of the interface stays in <span class="No-Break">the core:</span></p>
			<pre class="source-code">
 interface ContractService {
    fun draftContract(
        householdA: Household,
        householdB: Household,
        serviceProvidedByHouseholdA: String,
        serviceProvidedByHouseholdB: String,
    ): Contract
}</pre>			<p>We also need a secondary port to allow a draft contract to be persisted. The <strong class="source-inline">ContractRepository</strong> interface is implemented by adapters to provide the technical details of how a <strong class="source-inline">Contract</strong> object <span class="No-Break">is saved:</span></p>
			<pre class="source-code">
interface ContractRepository {
    fun save(contract: Contract)
}</pre>			<p>The implementation of the primary port interface, <strong class="source-inline">ContractService</strong>, validates the draft contract and creates a <strong class="source-inline">Contract</strong> object with a <strong class="source-inline">DRAFTED</strong> state. Then, the <strong class="source-inline">Contract</strong> object <a id="_idIndexMarker609"/>is <a id="_idIndexMarker610"/>passed to <strong class="source-inline">ContractRepository</strong> to <span class="No-Break">be saved:</span></p>
			<pre class="source-code">
 class ContractServiceImpl(
    private val contractRepository: ContractRepository,
) : ContractService {
    override fun draftContract(
        householdA: Household,
        householdB: Household,
        serviceProvidedByHouseholdA: String,
        serviceProvidedByHouseholdB: String,
    ): Contract =
        draftContract(
            householdA,
            householdB,
            serviceProvidedByHouseholdA,
            serviceProvidedByHouseholdB,
        ).also { contractRepository.save(it) }
}</pre>			<p>The <strong class="source-inline">ContractServiceImpl</strong> class is a part of the core logic and stays in the core. It is able to implement business behaviors without specifying how <strong class="source-inline">Contract</strong> is saved. In other words, the core focuses on business rules and is free of the concerns of the choice of technology <a id="_idIndexMarker611"/><span class="No-Break">and</span><span class="No-Break"><a id="_idIndexMarker612"/></span><span class="No-Break"> frameworks.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor268"/>Adapters</h2>
			<p>Adapters are <a id="_idIndexMarker613"/>responsible for translating external models to the internal models, which are defined in <span class="No-Break">the core.</span></p>
			<p>Adapters use the primary port as an entrance to the core and run business operations. An adapter is tied to at least one framework, and it has an external representation of the <span class="No-Break">entities involved.</span></p>
			<p>In the real-life example, the adapter can be a <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) controller <a id="_idIndexMarker614"/>that exposes a <strong class="source-inline">POST</strong> endpoint to create a draft contract. The payload is a JSON value, represented by the <strong class="source-inline">DraftContractRequest</strong> class, which can be converted into a <span class="No-Break"><strong class="source-inline">Contract</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
data class DraftContractRequest(
    val householdA: String,
    val householdB: String,
    val serviceProvidedByHouseholdA: String,
    val serviceProvidedByHouseholdB: String
)</pre>			<p>Contract Service has locally cached <strong class="source-inline">Household</strong> objects, which can be looked up by household name from the <span class="No-Break"><strong class="source-inline">HouseholdRepository</strong></span><span class="No-Break"> repository:</span></p>
			<pre class="source-code">
interface HouseholdRepository {
    fun findByName(householdName: String): Household?
}</pre>			<p>The function returns a <strong class="source-inline">Household</strong> object if the household of the given name is found. Otherwise, it returns a <strong class="source-inline">null</strong> value. The REST controller class, <strong class="source-inline">ContractController</strong>, is defined to accept HTTP requests to draft a contract. This controller uses Spring Boot as the framework to register <span class="No-Break">URI mapping:</span></p>
			<pre class="source-code">
@RestController
@RequestMapping("/contracts/")
class ContractController(
    private val contractService: ContractService,
    private val householdRepository: HouseholdRepository,
) {</pre>			<p>The controller is injected with the <strong class="source-inline">ContractService</strong> primary port to enter the core and draft a contract. It is also injected with the <strong class="source-inline">HouseholdRepository</strong> secondary port to look up <strong class="source-inline">Household</strong> objects <span class="No-Break">for validation.</span></p>
			<pre class="source-code">
    @PostMapping(
        value = ["draft"],
        consumes = [MediaType.APPLICATION_JSON_VALUE],
        produces = [MediaType.APPLICATION_JSON_VALUE],
    )</pre>			<p>The controller <a id="_idIndexMarker615"/>defines a mapping of <strong class="source-inline">POST /contracts/draft</strong> that accepts JSON value as input and <span class="No-Break">as output.</span></p>
			<pre class="source-code">
    fun draftContract(
        @RequestBody request: DraftContractRequest,
    ): ResponseEntity&lt;ContractDto&gt; {
        val householdA = householdRepository.findByName(request.householdA) ?: return ResponseEntity(HttpStatus.NOT_FOUND)
        val householdB = householdRepository.findByName(request.householdB) ?: return ResponseEntity(HttpStatus.NOT_FOUND)</pre>			<p>The controller converts the <strong class="source-inline">DraftContractRequest</strong> request payload and validates that household names in the payload exist. If any household does not exist, a <strong class="source-inline">404 (Not Found)</strong> HTTP status is returned to <span class="No-Break">the requester.</span></p>
			<pre class="source-code">
         val contract =
            contractService.draftContract(
                householdA,
                householdB,
                request.serviceProvidedByHouseholdA,
                request.serviceProvidedByHouseholdB,
            )</pre>			<p>The controller invokes the <strong class="source-inline">draftContract</strong> function in the <strong class="source-inline">ContractNegotiationService</strong> primary port, which validates the request and persists the draft contract in <span class="No-Break">the repository.</span></p>
			<pre class="source-code">
         return ResponseEntity(contract.toDto(), HttpStatus.CREATED)
}</pre>			<p>Finally, the operation<a id="_idIndexMarker616"/> has finished, and the controller returns a <strong class="source-inline">201 (Created)</strong> HTTP status back to the requester with the details of the draft contract. The response payload is represented by the <span class="No-Break"><strong class="source-inline">ContractDto</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
 data class ContractDto(
    val householdA: String,
    val householdB: String,
    val serviceProvidedByHouseholdA: String,
    val serviceProvidedByHouseholdB: String,
    val contractState: String,
)</pre>			<p>There is a <strong class="source-inline">toDto</strong> function for the conversion from the internal model to the external model of <span class="No-Break">the contract:</span></p>
			<pre class="source-code">
 fun Contract.toDto(): ContractDto =
    ContractDto(
        partyA.household.name,
        partyB.household.name,
        this.partyA.serviceProvided,
        this.partyB.serviceProvided,
        this.contractState.name,
    )</pre>			<p>The data was transformed and passed through the layers of the hexagonal architecture in this example, as demonstrated in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B21737_07_4.jpg" alt="Figure 7.4 – Example use case of the hexagonal architecture" width="1325" height="810"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Example use case of the hexagonal architecture</p>
			<p>The request <a id="_idIndexMarker617"/>payload as JSON value is validated in the <strong class="source-inline">ContractController</strong> adapter with the help of a <strong class="source-inline">HouseholdRepository</strong> secondary port. Then, the payload is converted to the <strong class="source-inline">Household</strong> objects defined in the core. The core runs through the business process and uses a <strong class="source-inline">ContractRepository</strong> secondary port to persist a valid draft <strong class="source-inline">Contract</strong> object. Then, the result is populated to the <strong class="source-inline">ContractController</strong> adapter. Finally, the adapter converts the <strong class="source-inline">Contract</strong> object to a <span class="No-Break">response payload.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor269"/>Benefits of hexagonal architecture</h2>
			<p>Separating source<a id="_idIndexMarker618"/> code in the layers of the hexagonal architecture certainly makes the code base more complicated. It does bring a few benefits by separating the source code between the core and <span class="No-Break">the adapter.</span></p>
			<p>The core encapsulates pure business rules and the adapter contains all technology details. This separation makes it extremely easy to test the concerns of correctness and technology <span class="No-Break">integration independently.</span></p>
			<p>The core contains a comprehensive test suite that ensures the business rules are enforced as intended, without involving <span class="No-Break">any technology.</span></p>
			<p>On the other hand, the adapter contains test cases that verify the configuration of the chosen technology and frameworks work as intended, without mixing <span class="No-Break">business rules.</span></p>
			<p>An adapter is designed to be pulled and replaced by another adapter at any time. An adapter is specifically implemented for a chosen technology or framework, but the port has no knowledge about it. For example, if the request and response use messaging technology, such as queuing, then we can replace <strong class="source-inline">ContractController</strong> with a different adapter, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">DraftContractRequestConsumer</strong></span><span class="No-Break">.</span></p>
			<p>The implementation of the secondary port as an adapter can also be replaced if needed. For example, we could have an implementation of a memory cache or relational database of <strong class="source-inline">HouseholdRepository</strong>. They can coexist and we can use configuration to decide which one is used at runtime. Each adapter can be tested <span class="No-Break">in isolation.</span></p>
			<p>This separation of concerns results in enabling engineers to conform to the <strong class="bold">single responsibility principle</strong> (<strong class="bold">SRP</strong>), in which <a id="_idIndexMarker619"/>the core has only one reason to change, and each adapter has only one reason <span class="No-Break">to change.</span></p>
			<p>Coming next, we are going to cover an architecture pattern that aims to solve this similar challenge, but in the <span class="No-Break">functional style.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor270"/>Functional core, imperative shell</h1>
			<p> <strong class="bold">FCIS</strong> emerged as an <a id="_idIndexMarker620"/>architectural pattern over time in the functional programming community. It is a design principle that advocates separating the immutable core business logic from the mutable aspects, such as persistent storage or external system integration. It aligns and encourages functional programming principles with the use of stateless functions and immutable <span class="No-Break">data structures.</span></p>
			<p>Stateless functions are sometimes called pure functions. They can be executed without causing side effects, in other words, for a given input, the function always produces the same output. Immutable data structures never change <span class="No-Break">their content.</span></p>
			<p>The FCIS principle has been influenced by various software development paradigms and architectural patterns. It shares similarities with the hexagonal architecture, which also promotes separating the core logic from the <span class="No-Break">infrastructure concerns.</span></p>
			<p>There are two major components in FCIS. The functional core contains stateless functions and immutable data structures that represent business logic and <span class="No-Break">entities, respectively.</span></p>
			<p>The imperative shell, on the other hand, is the layer outside of the functional core that interacts with the external world, such as database operations, messaging, or UIs. This layer is responsible for<a id="_idIndexMarker621"/> executing the imperative and mutable operations required by <span class="No-Break">the system.</span></p>
			<p>The FCIS architecture can be demonstrated in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B21737_07_5.jpg" alt="Figure 7.5 – FCIS" width="689" height="694"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – FCIS</p>
			<p>We are going to cover these two components of this architectural <span class="No-Break">style here.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor271"/>Functional core</h2>
			<p>The functional core<a id="_idIndexMarker622"/> focuses on the core business logic, which consists of stateless functions and immutable data <span class="No-Break">structures only.</span></p>
			<p>Using the same real-life example we have for households exchanging service, we should have these elements in <span class="No-Break">the core:</span></p>
			<ul>
				<li><strong class="bold">Data structures</strong>: The <strong class="source-inline">HouseHold</strong>, <strong class="source-inline">Party</strong>, and <strong class="source-inline">Contract</strong> data classes and the <strong class="source-inline">ContractState</strong> <span class="No-Break">enum class</span></li>
				<li><strong class="bold">Functions</strong>: The <span class="No-Break"><strong class="source-inline">draftContract</strong></span><span class="No-Break"> function</span></li>
			</ul>
			<p>All data classes are immutable, and all functions are stateless in our example. They are tested in isolation by simply verifying the output of the function given <span class="No-Break">the input.</span></p>
			<p>However, the <strong class="source-inline">draftContract</strong> function would need a tweak from the implementation shown in the example from the Clean Architecture section, because we need to build up higher-order functions with potential errors found along <span class="No-Break">the way.</span></p>
			<p>To start with this approach, we need to define what errors we may encounter. We will start with defining the types of <span class="No-Break">errors first:</span></p>
			<pre class="source-code">
enum class ErrorType {
    HOUSEHOLD_NOT_FOUND,
    SAME_HOUSEHOLD_IN_CONTRACT
}</pre>			<p>We also need a wrapper data class for the <span class="No-Break">error itself:</span></p>
			<pre class="source-code">
data class Error(
    val reason: String,
    val type: ErrorType
)</pre>			<p>We need to be able to communicate that functions can return an expected result, but there is also a chance an error occurred. This new implementation of <strong class="source-inline">draftContract</strong> uses the <strong class="source-inline">Either</strong> class from <strong class="bold">Arrow</strong> library to express <span class="No-Break">this outcome:</span></p>
			<p class="callout-heading">Arrow</p>
			<p class="callout"><strong class="bold">Arrow</strong> (<a href="https://arrow-kt.io/">https://arrow-kt.io/</a>) is a library for Kotlin. It aims to bring idiomatic functional programming constructs to Kotlin. It provides an alternative approach to handling null values using <strong class="source-inline">Option</strong> and result types for error handling using <strong class="source-inline">Either</strong>. It also provides various functional programming patterns, such as functors, monads, and applicatives. Arrow aims to improve code readability, maintainability, and robustness by enabling developers to express computations in a functional style, making it easier to manage complex data flows and side effects in <span class="No-Break">Kotlin applications.</span></p>
			<pre class="source-code">
 fun draftContract(
    householdA: Household,
    householdB: Household,
    serviceProvidedByHouseholdA: String,
    serviceProvidedByHouseholdB: String,
): Either&lt;Error, Contract&gt; =</pre>			<p>The <strong class="source-inline">draftContract</strong> function returns an <strong class="source-inline">Either</strong> object in which the left type parameter is always the <a id="_idIndexMarker623"/>potential error, and the right type parameter is always the <span class="No-Break">expected result:</span></p>
			<pre class="source-code">
    if (householdA.name == householdB.name) {
        Either.Left(
            Error("Parties must be from different households", ErrorType.SAME_HOUSEHOLD_IN_CONTRACT),
        )
    }</pre>			<p>The same validation ensures the contract does not have the same <strong class="source-inline">Household</strong> on both sides. However, instead of throwing an exception, the function returns the left side value, which is represented by the <strong class="source-inline">Error</strong> class just defined <span class="No-Break">earlier on.</span></p>
			<pre class="source-code">
      else {
        Either.Right(
            Contract(
                partyA = Party(householdA, serviceProvidedByHouseholdA),
                partyB = Party(householdB, serviceProvidedByHouseholdB),
                contractState = ContractState.DRAFTED,
            ),
        )
    }</pre>			<p>If everything is fine, the<a id="_idIndexMarker624"/> function returns the right side value, which is the <strong class="source-inline">Contract</strong> <span class="No-Break">object itself.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor272"/>Imperative shell</h2>
			<p>The imperative shell<a id="_idIndexMarker625"/> handles the necessary interactions with the outside world, providing the necessary integration points <span class="No-Break">and adaptors.</span></p>
			<p>In the real-life example, this includes the persistence of the <strong class="source-inline">Contract</strong> object and the REST endpoint controller that accepts HTTP <strong class="source-inline">POST</strong> requests to draft <span class="No-Break">a contract.</span></p>
			<p>Apart from the REST controller, there are two more imperative operations involved. The first one looks up a <strong class="source-inline">Household</strong> object by the name, and the second one persists a <strong class="source-inline">Contract</strong> object. We define them using <strong class="source-inline">typealias</strong> in <span class="No-Break">this example:</span></p>
			<pre class="source-code">
typealias HouseholdLookup = (String) -&gt; Household?
typealias ContractPersist = (Contract) -&gt; Either&lt;Error, Contract&gt;</pre>			<p>In addition to these two functions defined, we also need a function to ensure the household mentioned in the <span class="No-Break">request exists:</span></p>
			<pre class="source-code">
fun DraftContractRequest.ensureHouseholdExist(
    householdLookup: HouseholdLookup
): Either&lt;Error, Pair&lt;Household, Household&gt;&gt; {
    val householdARecord = householdLookup(householdA)
    val householdBRecord = householdLookup(householdB)
    return if (householdARecord == null) {
        Either.Left(
            Error("Households not found: $householdA", ErrorType.HOUSEHOLD_NOT_FOUND),
        )
    } else if (householdBRecord == null) {
        Either.Left(
            Error("Households not found: $householdB", ErrorType.HOUSEHOLD_NOT_FOUND),
        )
    } else {
        Either.Right(
            householdARecord to householdBRecord,
        )
    }
}</pre>			<p>The <strong class="source-inline">ensureHouseholdExist</strong> function makes use of <strong class="source-inline">HouseholdLookup</strong> to check if the two households mentioned in the <strong class="source-inline">DraftContractRequest</strong> request exist. If not, the left side of <strong class="source-inline">Either</strong> will be returned to report the household not found error. If both households exist, the household records are returned for <span class="No-Break">further processing.</span></p>
			<p>With this function <a id="_idIndexMarker626"/>defined, we can now inject them into the imperative <span class="No-Break">controller implementation:</span></p>
			<pre class="source-code">
 @RequestMapping("/contracts/")
class ContractControllerShell(
    private val householdLookup: HouseholdLookup,
    private val contractPersist: ContractPersist,
) {
    @PostMapping(
        value = ["draft"],
        consumes = [MediaType.APPLICATION_JSON_VALUE],
        produces = [MediaType.APPLICATION_JSON_VALUE],
    )</pre>			<p>The <strong class="source-inline">draft</strong> function now takes full advantage of the <strong class="source-inline">Either</strong> class by collapsing the right type parameter <a id="_idIndexMarker627"/>with the <span class="No-Break"><strong class="source-inline">flatMap</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
    fun draft(
        @RequestBody draftContractRequest: DraftContractRequest,
    ): ResponseEntity&lt;ContractDto&gt; =
        draftContractRequest
            .ensureHouseholdExist(householdLookup)
            .flatMap { (householdA, householdB) -&gt;
                draftContract(
                    householdA,
                    householdB,
                    draftContractRequest.serviceProvidedByHouseholdA,
                    draftContractRequest.serviceProvidedByHouseholdB,
                )
            }.flatMap { contractPersist(it) }
            .flatMap { Either.Right(it.toDto()) }
            .fold(
                { error -&gt; ResponseEntity(error.type.toHttpStatus()) },
                { contractDto -&gt; ResponseEntity(contractDto, HttpStatus.CREATED) },
            )</pre>			<p>The <strong class="source-inline">flatMap</strong> functions chain the results of <strong class="source-inline">Either</strong> to return either the first error on the left or the final expected result on the right. The preceding code firstly checks and ensures that both households mentioned in the request exist. The next chained call gets the household records from the <strong class="source-inline">ensureHouseholdExist</strong> function and it passes all parameters to the <strong class="source-inline">draftContract</strong> function to validate business rules and return a <strong class="source-inline">Contract</strong> object of the <span class="No-Break"><strong class="source-inline">DRAFTED</strong></span><span class="No-Break"> state.</span></p>
			<p>The next chained call receives the <strong class="source-inline">Contract</strong> object of the <strong class="source-inline">DRAFTED</strong> state and calls the <strong class="source-inline">ContractPersist</strong> function to persist <span class="No-Break">this contract.</span></p>
			<p>After the <strong class="source-inline">Contract</strong> record is persisted, it is transformed into a <strong class="bold">data transfer object</strong> (<strong class="bold">DTO</strong>) that will <a id="_idIndexMarker628"/>be exposed and returned to the HTTP client that initiated <span class="No-Break">the request.</span></p>
			<p>At the last part of the chained call, the <strong class="source-inline">fold</strong> function is invoked to differentiate the response back to the HTTP client. The success result as a <strong class="source-inline">Contract</strong> object, the right side, is converted to the <strong class="source-inline">ContractDto</strong> response payload by the <strong class="source-inline">toDto</strong> function. A <strong class="source-inline">201 (Created)</strong> HTTP status is returned together with the <span class="No-Break">response payload.</span></p>
			<p>All the possible errors are collapsed onto the left side, and they are mapped to the HTTP status code, as <a id="_idIndexMarker629"/><span class="No-Break">shown here:</span></p>
			<pre class="source-code">
fun ErrorType.toHttpStatus(): HttpStatus = when (this) {
    ErrorType.HOUSEHOLD_NOT_FOUND -&gt; HttpStatus.NOT_FOUND
    ErrorType.SAME_HOUSEHOLD_IN_CONTRACT -&gt; HttpStatus.BAD_REQUEST
}</pre>			<h2 id="_idParaDest-179"><a id="_idTextAnchor273"/>Benefits of functional core, imperative shell</h2>
			<p>FCIS separates<a id="_idIndexMarker630"/> the code into <span class="No-Break">two parts.</span></p>
			<p>The functional core is a purely functional area that only contains stateless functions and immutable data structures, which can be easily tested and reasoned about. There is no state management and no side effects. Each test is about verifying the output of the function given the <span class="No-Break">input values.</span></p>
			<p>The functional core is also free of technology choice. It makes the functional core focus on only business concerns. There is no need to change the code if we decide to use other technologies to receive requests and produce responses. This makes the core logic reliable, adaptable, <span class="No-Break">and maintainable.</span></p>
			<p>The only exception, as we shown in the example, is the use of the <strong class="source-inline">Either</strong> class brought from the Arrow library, to express that an operation can fail and return a <span class="No-Break">different object.</span></p>
			<p>This encourages engineers to organize the code to conform to the SRP in which each function has only one reason to change. We still need to organize our functions with the best practices to conform to SRP though. For example, each function needs to be small, reusable, stateless, and with one <span class="No-Break">purpose only.</span></p>
			<p>Separating the functional core from the imperative shell allows for easier evolution of the core logic without being tightly coupled to the external systems or implementation details. It also allows for greater flexibility and maintainability, leading to more robust and flexible <span class="No-Break">software </span><span class="No-Break"><a id="_idIndexMarker631"/></span><span class="No-Break">architectures.</span></p>
			<p>The next architectural pattern we are going to cover focuses on adapting to a remote <span class="No-Break">API call.</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor274"/>The Connect pattern</h1>
			<p>The Connect pattern <a id="_idIndexMarker632"/>was first introduced by David Denton in his technical article, <em class="italic">Smash your Adapter Monolith with the Connect pattern</em>, on the internet <span class="No-Break">in 2011.</span></p>
			<p>This pattern, however, has a different focus from the three architectural patterns previously discussed. It is specifically targeted at remote system integration. It aims to provide a testable and extensible approach to encapsulate remote <span class="No-Break">API interactions.</span></p>
			<p>The concept of the Connect pattern is illustrated in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B21737_07_6.jpg" alt="Figure 7.6 – The Connect pattern" width="664" height="797"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The Connect pattern</p>
			<p>An integration operation is abstracted as an Action. It understands how to generate a request and how to transform a response into an internal object. However, it does not know the connection details to the <span class="No-Break">external system.</span></p>
			<p>An adapter, on the <a id="_idIndexMarker633"/>other hand, is crafted to adapt to a specific system. It can establish a connection with an external system while delegating the actual request-response exchange to <span class="No-Break">an Action.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor275"/>Action</h2>
			<p>An <strong class="bold">Action</strong> is responsible<a id="_idIndexMarker634"/> for transforming requests from internal to external format and transforming responses from external to internal format. Using the same real-life example of the villagers exchanging services, there are some supporting functions that we need from the Household Service, and one of them is as simple as getting a household by the given <span class="No-Break">household name.</span></p>
			<p>The Action related to communicating with the Household Service is <span class="No-Break">defined here:</span></p>
			<pre class="source-code">
interface HouseholdApiAction&lt;R&gt; {
    fun toRequest(): Request
    fun fromResponse(response: Response): R
}</pre>			<p>There are only two simple functions. The <strong class="source-inline">toRequest</strong> function generates a request in an external format to communicate with Household Service. The <strong class="source-inline">fromResponse</strong> function transforms a response from Household Service to an internal object. The type variable, <strong class="source-inline">R</strong>, is specific to the given Action and <span class="No-Break">can vary.</span></p>
			<p>The Action to get a<a id="_idIndexMarker635"/> household name by the given household name is <span class="No-Break">defined here:</span></p>
			<pre class="source-code">
val householdLens = Body.auto&lt;Household&gt;().toLens()
data class GetHousehold(
    val householdName: String,
) : HouseholdApiAction&lt;Household&gt; {
    override fun toRequest(): Request = Request(Method.GET, "/households/$householdName")
    override fun fromResponse(response: Response): Household = householdLens(response)
}</pre>			<p>The <strong class="source-inline">GetHousehold</strong> class encapsulates the details needed to generate the HTTP request to Household Service. The response from Household Service is transformed to an internal data class, <strong class="source-inline">Household</strong>, using <strong class="bold">HTTP4k Lens</strong>. Please note that although this example<a id="_idIndexMarker636"/> makes <a id="_idIndexMarker637"/>use of the <strong class="bold">HTTP4K</strong> library, the Connect pattern itself is not restricted to this library. The internal <strong class="source-inline">Household</strong> data class is <span class="No-Break">defined here:</span></p>
			<pre class="source-code">
data class Household(
    val name: String,
    val emailAddress: String,
)</pre>			<p>So far, there are no <a id="_idIndexMarker638"/>connection details to Household Service, but this will be covered by <span class="No-Break">the adapter.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor276"/>Adapter</h2>
			<p>The adapter class <a id="_idIndexMarker639"/>provides a way to abstract away the connectivity details and mechanism to an external system. The <strong class="source-inline">Household</strong> API is <span class="No-Break">defined here:</span></p>
			<pre class="source-code">
interface HouseholdApi {
    operator fun &lt;R : Any&gt; invoke(action: HouseholdApiAction&lt;R&gt;): R
    companion object
}</pre>			<p>The <strong class="source-inline">HouseholdApi</strong> interface acts as a wrapper and handle for the invocation of the specific action. The companion object is defined as a placeholder for extension functions, which will be covered later. An HTTP implementation that communicates with a local Household Service is implemented <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
val token = "fakeToken"
fun HouseholdApi.Companion.Http(client: HttpHandler) =
    object : HouseholdApi {
        private val http =
 SetBaseUriFrom(Uri.of("http://localhost:9000"))
                .then(
                    Filter { next -&gt; { next(it.header("Authorization", "Bearer $token")) } },
                ).then(client)
        override fun &lt;R : Any&gt; invoke(action: HouseholdApiAction&lt;R&gt;) = action.fromResponse(http(action.toRequest()))
    }</pre>			<p>This <strong class="source-inline">Household</strong> API implementation is an anonymous inner class that sets the host of Household Service to localhost and sets the authorization bearer token. It assumes that all <strong class="source-inline">HouseholdAction</strong> would use the same <span class="No-Break">connectivity settings.</span></p>
			<p>Moreover, an extension function is defined to make the usage <span class="No-Break">code tidier:</span></p>
			<pre class="source-code">
fun HouseholdApi.getHousehold(householdName: String) = invoke(GetHousehold(householdName))</pre>			<p>The code usage <a id="_idIndexMarker640"/>example is going to be covered in the <span class="No-Break">following section.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor277"/>Usage</h2>
			<p>With the Action <a id="_idIndexMarker641"/>and the adapter set up, the usage of the Household Service to get a household by the given name only requires three lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
val app: HttpHandler =
    routes(
        "/households/{name}" bind GET to { request -&gt;
            val householdName = request.path("name")!!.toString()
            Response(OK).with(householdLens of Household(name = householdName, emailAddress = "same.address@domain.com"))
        },
    )
fun main() {
    val householdApi = HouseholdApi.Http(JavaHttpClient())
    val household: Household = householdApi.getHousehold("Whittington")
    println(household)
}</pre>			<p>The variable app is <strong class="source-inline">HttpHandler</strong>, which defines URI routings. Only a <strong class="source-inline">GET</strong> endpoint is defined in this example, together with a canned response back to the <span class="No-Break">HTTP client.</span></p>
			<p>In the <strong class="source-inline">main</strong> function, an HTTP client implementation is created to be fed to create an HTTP implementation of <strong class="source-inline">HouseholdApi</strong>. Then, the extension function is used to get a household with the name <em class="italic">Whittington</em>. Internally, a <strong class="source-inline">GetHousehold</strong> Action is created and passed into <strong class="source-inline">HouseholdApi</strong> and kicks off the API communication. However, from a usage point of view, an <a id="_idIndexMarker642"/>object of the internal <strong class="source-inline">Household</strong> data class <span class="No-Break">is returned.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor278"/>Test cases</h2>
			<p>One of the strengths <a id="_idIndexMarker643"/>of the Connect pattern is better testability. Each Action and API with the Household Service can be tested individually. This is the test case of getting a household from the <span class="No-Break">Household API:</span></p>
			<pre class="source-code">
    @Test
    fun `Get the household from Household API`() {
        assertEquals(
            Response(OK)
                .contentType(ContentType.APPLICATION_JSON)
                .body("{\"name\":\"Whittington\",\"emailAddress\":\"same.address@domain.com\"}"),
            app(Request(GET, "/households/Whittington")),
        )
    }</pre>			<p>When there are more Actions, there will be more test cases, but each test case is isolated. In other <a id="_idIndexMarker644"/>words, the Actions and test cases scale without creating an interface with <span class="No-Break">many functions.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor279"/>Benefits</h2>
			<p>The major benefits <a id="_idIndexMarker645"/>of the Connect pattern are extensibility and testability. Given it is common to use multiple APIs of an external system, engineers often end up with one interface for the external system with many functions. With the Connect pattern, each API call is represented by an Action and thus breaks down the big interface into <span class="No-Break">smaller pieces.</span></p>
			<p>This pattern naturally conforms to the SRP as an Action represents only one API call. Moreover, each Action has its own dedicated test case, which is a lot simpler than testing an interface with <span class="No-Break">many functions.</span></p>
			<p>The adapter has abstracted away the concern of connectivity details to a remote system, so Action classes can focus on the message formats <span class="No-Break">and interactions.</span></p>
			<p>The use of Kotlin extension functions makes the code usage fluent, tidy, and small. A lot of details are hidden and encapsulated within the Action and <span class="No-Break">adapter classes.</span></p>
			<p>Although the example uses HTTP and Kotlin, the Connect pattern itself is not restricted <span class="No-Break">to them.</span></p>
			<p>This pattern is particularly useful in the usage of communicating with a monolithic application that<a id="_idIndexMarker646"/> exposes a lot of functions in <span class="No-Break">one interface.</span></p>
			<p>Coming next, we are going to briefly compare these <span class="No-Break">architectural styles.</span></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor280"/>Comparisons of architectural styles</h1>
			<p>The first three architectural <a id="_idIndexMarker647"/>styles we discussed in this chapter have a great deal of similarities. They all aim to solve the same issues; the variations are in <span class="No-Break">the approaches.</span></p>
			<p>Meanwhile, the Connect pattern focuses on the testability and extensibility of remote <span class="No-Break">system interactions.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor281"/>Dependency on frameworks and technologies</h2>
			<p>Traditional <a id="_idIndexMarker648"/>architectures often tightly couple the business logic with specific frameworks, libraries, or technologies. This makes it difficult to switch or upgrade these components without making widespread changes throughout the <span class="No-Break">code base.</span></p>
			<p>Clean Architecture proposes the Entities layer for enterprise business rules and the Use Cases layer for application-specific business rules. Both are neutral to choices of frameworks <span class="No-Break">and technologies.</span></p>
			<p>The hexagonal architecture proposes the core as the centerpiece for business logic, also free of the choices of frameworks <span class="No-Break">and technologies.</span></p>
			<p>FCIS proposes the functional core for business logic, but with the use of stateless functions and immutable <span class="No-Break">data structures.</span></p>
			<p>The Connect pattern uses Action for the integration point of a single action and an adapter for the transport<a id="_idIndexMarker649"/> details of the interaction with the <span class="No-Break">remote system.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor282"/>Testability</h2>
			<p>In traditional architectures, testing<a id="_idIndexMarker650"/> the core business logic can be challenging due to dependencies on external systems, databases, or <span class="No-Break">UI frameworks.</span></p>
			<p>Testing a function coupled with a choice of technology typically requires a lot of setting up and tearing down of resources, and worse if there are asynchronous processes behind the scenes. This means it requires more effort from engineers to make the tests work, fewer tests can be written for the same amount of time, the test suite takes longer to run, and there could be flaky tests that fail occasionally due to some asynchronous processes involved. Any parallel executed tests can make the test suite even <span class="No-Break">more flaky.</span></p>
			<p>Clean Architecture offers dedicated layers for business logic only (the Entities and Use Cases layers), which can be tested in isolation without involving any choice of technology. The Interface Adapters layer focuses on internal and external model translation, which can be also tested independently. The configurations of the Frameworks &amp; Driver layers can be tested without involving <span class="No-Break">business rules.</span></p>
			<p>The hexagonal architecture advocates the core as a technology-neutral area where unit tests can be easily written without the need for complex setups or mocking extensive external components. Each adapter can be tested individually and without involving any <span class="No-Break">business logic.</span></p>
			<p>FCIS suggests putting only business logic as stateless functions and immutable data structures in the functional core. This reduces testing of the functional core using a simple verification of the output result given by input. The imperative shell can also be tested easily by swapping the lower-order functions in the functional core, as a result, the immutable and the mutable parts of the systems can be <span class="No-Break">tested separately.</span></p>
			<p>The Connect pattern breaks down the large remote interface of a monolithic application into one Action per API call. This reduces a lot of overhead, excessive mocking, test double, or stubbing of the interface. The ability to test an API call in isolation improves testability and enables easy extension of the usage of a <span class="No-Break">remote API.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor283"/>Maintainability</h2>
			<p>Over time, applications<a id="_idIndexMarker651"/> tend to evolve and change, often requiring modifications to the core business logic or the choice of frameworks. In traditional architectures, making changes can be risky as these modifications may have unintended consequences throughout the system. Updating business logic may have intertwined with a deprecated library and eventually, both need to <span class="No-Break">be changed.</span></p>
			<p>Clean Architecture, the hexagonal architecture, and FCIS provide a clear separation between the core business logic and the surrounding infrastructure, making it easier to modify or extend the application without affecting the core <span class="No-Break">business rules.</span></p>
			<p>The Connect pattern is very lightweight and there is no overlapping among Actions. The connectivity and message interaction concerns are separated into adapter and Action classes, the maintenance of these classes is simple, and code changes <span class="No-Break">are small.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor284"/>Flexibility and adaptability</h2>
			<p>Applications often need <a id="_idIndexMarker652"/>to integrate with various external resources, such as files, databases, third-party services, or UIs. In traditional architectures, these integrations are deeply embedded within the application code, making it challenging to switch or modify <span class="No-Break">these integrations.</span></p>
			<p>Clean Architecture promotes the Interface Adapters and Frameworks and Drivers layers to contain external dependencies. This allows more flexibility and adaptability, as the business rules remain decoupled from specific technologies <span class="No-Break">or protocols.</span></p>
			<p>The hexagonal architecture promotes the use of ports and adapters, which act as interfaces and adapters between the core logic and the external systems. A different choice of framework results in a separate implementation of adapters but the port interfaces remain the same. Changing technology or a protocol is easy by swapping an implementation of the <span class="No-Break">same interface.</span></p>
			<p>FCIS uses the imperative shell layer to handle all the interactions with the external world. Any change in technology or protocol requires a change only in the imperative shell layer. With the high-level reuse of small functions, only a minor change is required to adapt to a <span class="No-Break">new technology.</span></p>
			<p>The Connect pattern allows engineers to implement a new adapter if it needs to integrate with a new remote system. If it needs to adapt to a new communication protocol, it is required to implement a new adapter and new Action, but there is no need to update<a id="_idIndexMarker653"/> the <span class="No-Break">current code.</span></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor285"/>When to use which architectural style</h1>
			<p>Clean Architecture, the <a id="_idIndexMarker654"/>hexagonal architecture, and FCIS share a great deal of similarities that engineers may find hard to choose for their applications. The layers of these three architectural styles can be approximately mapped <span class="No-Break">as follows:</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Clean Architecture</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Hexagonal Architecture</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">FCIS</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Entities</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Shared / <span class="No-Break">Common libs</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Shared / <span class="No-Break">Common libs</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Use Case</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Core / Domain / <span class="No-Break">Port</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Core</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Interface Adapters</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Adapters</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Shell</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Frameworks </strong><span class="No-Break"><strong class="bold">and Drivers</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Adapters</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Shell</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – Approximate mapping among the three architectural styles</p>
			<p>If we accept the opinion that the three styles can be loosely mapped, then the choice would become convention among engineers. The following are some opinions for reference but they are not <span class="No-Break">strict rules:</span></p>
			<ul>
				<li>Engineers with more functional programming experience would <span class="No-Break">prefer FCIS.</span></li>
				<li>Clean Architecture provides better support to monolithic applications or systems with a big source repository. Having said that, Clean Architecture can absolutely support smaller repositories <span class="No-Break">or microservices.</span></li>
				<li>The hexagonal architecture fits microservice applications in terms of scope <span class="No-Break">and scale.</span></li>
			</ul>
			<p>There are also a lot of rooms to create a hybrid style. For instance, an application using the hexagonal architecture can borrow the concepts of FCIS, so all ports and adapters are basically functions using the Kotlin operator <span class="No-Break">overload features:</span></p>
			<pre class="source-code">
class DummyContractPersist: ContractPersist {
    override fun invoke(p1: Contract): Either&lt;Error, Contract&gt; {</pre>			<p><strong class="source-inline">ContractPersist</strong> is a type alias we used in FCIS, and we can define a class that implements the type alias interface and provides the <strong class="source-inline">invoke</strong> function with operator override. So, in practice, callers can skip the <strong class="source-inline">invoke</strong> keyword and treat it as a function, like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
    val persist = DummyContractPersist()
    val result = persist(contract)</pre>			<p>So, this concept can be extended to port interfaces, where they are only type aliases or interfaces with one <span class="No-Break">function only.</span></p>
			<p>The Connect pattern is an integration pattern that solves a different problem than the other three styles covered in this chapter. The Connect pattern can be used when there is a need to perform<a id="_idIndexMarker655"/> the same action in a business sense using external systems, but we want to decouple the technical integration details from the <span class="No-Break">business logic.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor286"/>In relation to the anemic domain model</h1>
			<p>The <strong class="bold">anemic domain model</strong> (<strong class="bold">ADM</strong>) is a controversial<a id="_idIndexMarker656"/> architectural style that some people classify as an anti-pattern, while others find it useful in certain circumstances. In the ADM, the core or Use Cases layer has mainly data structures and little to zero <span class="No-Break">business behaviors.</span></p>
			<p>The in-depth discussion on ADM is beyond the scope of this chapter, however, if a team has chosen to use ADM, then it is not advisable to combine it with Clean Architecture, the hexagonal architecture, <span class="No-Break">or FCIS.</span></p>
			<p>The main reason is that these architectures are designed to have business behaviors kept in the core or Use Cases layer; in other words, they<a id="_idIndexMarker657"/> are designed to work with the <strong class="bold">rich domain model</strong> (<strong class="bold">RDM</strong>) only. The application does not get any benefit from adopting the layers from Clean Architecture, the hexagonal architecture, or FCIS covered in <span class="No-Break">this chapter.</span></p>
			<p class="callout-heading">Usage of ADM</p>
			<p class="callout">Although ADM may be seen<a id="_idIndexMarker658"/> as an anti-pattern to some people, the lack of business behaviors may mean the application’s goals are data processing and infrastructure plumbing only. For example, an ADM application may be responsible for ingesting a large file, splitting the data in the file into chunks, and processing each chunk in parallel. The application focuses on data manipulation and scalability, meanwhile, the processed data is read by other downstream applications that contain actual business behaviors related to the data. Another example could be an application that consumes the headers of external messages and forwards these messages to their corresponding internal topics for <span class="No-Break">further processing.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor287"/>Organizing source code as layers</h1>
			<p>There are two<a id="_idIndexMarker659"/> popular choices for organizing source code as layers. In Kotlin, the first approach is to put files into their belonging packages <span class="No-Break">as layers.</span></p>
			<p>In the real-life example we used, we could have the following packages in each <span class="No-Break">architectural style:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Clean Architecture</strong></span><span class="No-Break">:</span><pre class="source-code">
org.example.service.negotiation.entity
org.example.service.negotiation.usecase
org.example.service.negotiation.interface
org.example.service.negotiation.framework
org.example.service.negotiation.framework.rest</pre></li>				<li><span class="No-Break"><strong class="bold">Hexagonal architecture</strong></span><span class="No-Break">:</span><pre class="source-code">
org.example.service.negotiation.core
org.example.service.negotiation.core.port
org.example.service.negotiation.adapter
org.example.service.negotiation.adapter.rest</pre></li>				<li><span class="No-Break"><strong class="bold">FCIS</strong></span><span class="No-Break">:</span><pre class="source-code">
org.example.service.negotiation.core
org.example.service.negotiation.shell
org.example.service.negotiation.shell.rest</pre></li>			</ul>
			<p>Enforcing the layered architecture, where only the outer layer can use the inner layer and not the other way round, can easily be done using test cases and includes passing them as a part of a <span class="No-Break">successful build.</span></p>
			<p>This is an exampl<a id="_idIndexMarker660"/>e of a test case that enforces the FCIS layer<a id="_idIndexMarker661"/> dependency, using <strong class="bold">ArchUnit</strong> as the <span class="No-Break">test driver:</span></p>
			<pre class="source-code">
    val classes = ClassFileImporter().importPackages("fcis")
    @Test
    fun `layer dependencies are_respected`() {
        layeredArchitecture()
            .consideringAllDependencies()
            .layer("Imperative Shell")
            .definedBy("fcis.shell..")
            .layer("Functional Core")
            .definedBy("fcis.core..")
            .whereLayer("Imperative Shell")
            .mayNotBeAccessedByAnyLayer()
            .whereLayer("Functional Core")
            .mayOnlyBeAccessedByLayers("Imperative Shell")
            .check(classes)
    }</pre>			<p>The second approach is the use of a source code module within a build framework, such as <strong class="bold">Gradle</strong> or <strong class="bold">Maven</strong>. We <a id="_idIndexMarker662"/>create<a id="_idIndexMarker663"/> multi-module projects for an application, and the outer modules declare dependencies on <span class="No-Break">inner modules.</span></p>
			<p>For example, the imperative shell of the Negotiation Service can have explicit dependencies declared in the Gradle Kotlin script of the imperative <span class="No-Break">shell module.</span></p>
			<pre class="source-code">
implementation("com.example:service-negotiation-core")</pre>			<p>It is important to note that this approach is more heavy-weighted than the package approach as it creates actual artifacts of <span class="No-Break">inner layers.</span></p>
			<p>The Connect pattern, however, is<a id="_idIndexMarker664"/> a modular but not layered architecture, so there is no need to enforce <span class="No-Break">layer dependencies.</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor288"/>Summary</h1>
			<p>In this chapter, we discussed three architectural styles that aim to solve the same issues in traditional architectures where business logic and technology choices are tightly coupled. These three architectures were covered in depth: Clean Architecture, hexagonal architecture, and FCIS. We also discussed the Connect pattern, which focuses on breaking down large remote interfaces for integrating with <span class="No-Break">remote systems.</span></p>
			<p>We illustrated each architectural style using our real-life example and how each style is implemented <span class="No-Break">in code.</span></p>
			<p>We also compared the four architecture styles in terms of how they tackle the issues in traditional architecture. We briefly covered how code can be organized in a repository under <span class="No-Break">layered architectures.</span></p>
			<p>We mentioned that the core in the hexagonal architecture is sometimes named the <em class="italic">domain</em>. However, the term “domain” itself is worth a lengthy discussion. In the next chapter, we are going to cover the concepts surrounding the domain, with one common theme – <strong class="bold">domain-driven </strong><span class="No-Break"><strong class="bold">development</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DDD</strong></span><span class="No-Break">).</span></p>
		</div>
	</div></div></body></html>