- en: Chapter 5. Behavioral Patterns – Strategy, State, and Template Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I hope you''re still with us; now, we will introduce you to the third and last
    category of the design patterns, which is categorized as a **Gang of Four** (**GoF**)
    design patterns: the behavioral pattern. Behavioral patterns are dedicated to
    algorithms and communication between them.'
  prefs: []
  type: TYPE_NORMAL
- en: As algorithms consist of several operations that are divided into different
    classes, behavioral patterns can handle the organization of such classes and the
    ways in which they can communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavioral category contains 11 patterns that we will discuss through four
    chapters. In this chapter, we will discuss the following three patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to change part of an object's algorithm at runtime, without modifying
    the client, the strategy pattern is the appropriate pattern to be used.
  prefs: []
  type: TYPE_NORMAL
- en: It removes an algorithm from its host class and moves it to a separate class.
    The algorithm part that can change is the **strategy**. Every strategy uses the
    same interface. The class using the strategy pattern delegates the treatment of
    the algorithm to the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern is used to create an interchangeable family of algorithms
    from which the required process is chosen at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm changes don''t affect the client part. This pattern can be used
    in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of a class can be implemented by different algorithms where some
    of them are better in terms of execution time or memory consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the appropriate algorithm with `if` conditions instruction complexify
    the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system has similar classes where only the behavior changes; in this case,
    the strategy pattern allows you to group these classes in only one class, which
    greatly simplifies the interface for clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic structure of the strategy platform is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4582_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants in the strategy pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IStrategy`: This class defines the common interface implemented by all algorithms.
    This is the interface used by the `ClassUsingStrategy` class to invoke the right
    algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteStrategyA` and `ConcreteStrategyB`: These are concrete classes that
    implement different algorithms based on the `IStrategy` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassUsingStrategyA` and `ClassUsingStrategyB`: These are classes that use
    an algorithm from classes that implement the `IStrategy` interface. These classes
    have a reference to one instance of one of the concrete strategy classes. These
    classes can expose some internal data to the implementation classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ClassUsingStrategy` and `ConcreteStrategy` classes interact to implement
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, data needed by the algorithms is sent as arguments to the constructor
    but can be sent by a set property too. If needed, the `ClassUsingStrategy` class
    can provide you some methods to allow you to access its internal data.
  prefs: []
  type: TYPE_NORMAL
- en: The `Client` instance will initiate `ClassUsingStrategy` with a `Strategy` object
    and call the `ClassUsingStrategy` method that uses the strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Then, this class will send the request received from the client to the instance
    that is referenced by the strategy attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see how to implement the strategy pattern using a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some objects can move, but some of them don''t move in the same manner. Each
    object has a particular manner in which it moves: some can walk and others can
    run and fly. The move behavior is our strategy, and we will encapsulate the `performMove()`
    action in the concrete strategy class that is referenced in the concrete class
    using the strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the strategy pattern Xcode project to see the organization of our code.
    The participants in this pattern are separated in four folders, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing that we will do is define the interface of the move strategy
    and then describe `AbstractClassUsingMoveStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: The interface of the move strategy is really easy; we will only tell the class
    implementing the strategy that we are waiting for a `performMove` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MoveStrategyProtocol.swift` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our abstract class needs to have a role to keep a reference to the strategy
    that will be applied by encapsulating the call to the `performMove` method of
    the current strategy into its own method that we will call `move()`. The instance
    of the strategy object will be received in the constructor of the class implementing
    the `AbstractObjectThatMove` class.
  prefs: []
  type: TYPE_NORMAL
- en: For our demo, we will add an internal computed property, `WhoAmI`, where we
    will set or get the name of the concrete class using the strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `AbstractObjectThatMove.swift` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift 2.0 has no support for abstract classes as yet. Here, we named the `AbstractObjectThatMove`
    class, even if it is not a "real" abstract class, only to be as close as possible
    to the general concept of the pattern. Nevertheless, there might be a way to have
    something that seems like an abstract class, but it differs from the general concept
    of the pattern where we pass a strategy to the initializer. Swift 2.0 has protocol
    extensions that give the opportunity to add partial implemented methods to protocols,
    and in "some way", make an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can process the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we come back to the implementation of the pattern. In our current example,
    we have three concrete classes that implement the abstract classes: `Rabbit`,
    `Bird`, and `Human`. As the implementation is the same for all these three objects,
    I will only display the implementation of the concrete `Human` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We want to add a value to the `WhoAmI` property while it is initializing, so
    we inform the `init` method that this method is required. We then set the value
    of the property with a simple `self.WhoAmi = "I'm a human"` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have done this by adding an additional parameter to the constructor
    defined in the `AbstractClass` that takes the value of `WhoAmI` and assigns it
    to the internal `whoAmI` variable too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will implement `WalkMoveStrategy`, as defined in the `MoveStrategyProtocol`
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing complex here; we implement the `performMove` method and print
    the message of the move action. The `RunMoveStrategy` and `FlyMoveStrategy` methods
    are implemented in the same way; just the `print` statement changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding highlighted code, you can see how we proceeded to apply the
    strategy to the `Human` class using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we instantiate a strategy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we instantiate a concrete class using the strategy pattern where the strategy
    declared first is sent as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we perform a move action in the concrete class. The move action invokes
    the `performMove` method of the strategy that the concrete class has in reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Run** button to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following result in the console of Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The state pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the state pattern, a class behavior changes based on its state. This type
    of design pattern comes under the behavior pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the state pattern, we create objects that represent various states and a
    context object whose behavior varies as its state object changes.
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The role of this pattern is to adapt its behavior depending on the internal
    state of an object. It can be used when implementing the dependency of the state
    object if the condition statement becomes complex.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic class diagram structure of the state pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4582_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants in the state pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StateMachine`: This is a concrete class that describes a state machine''s
    objects, which means that they have a set of states that can be described in a
    state transition diagram. This class has a reference to an instance of a sub class
    that implements the state abstract class and defines the current state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IState`: This is an abstract class that introduces you to the methods signature
    of a state behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteStateA` and `ConcreteStateB`: These are concrete subclasses that implement
    the behavioral methods depending on the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StateMachine` object delegates the call of the method to a `ConcreteState`
    object depending on the current state.
  prefs: []
  type: TYPE_NORMAL
- en: The `StateMachine` object can send a reference to itself and to the `ConcreteState`
    object if needed. This reference can then be sent through the initialization of
    the `concreteState` object or each time calls are delegated.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your company needs to sell a new device that has only two buttons that can
    play the radio or some music. You need to have the following functionalities,
    depending on the current state of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '| State | Action button | Source button |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Radio | This changes to the next station and plays it | This changes to music
    playing mode |'
  prefs: []
  type: TYPE_TB
- en: '| Playing music | This pauses the music | This changes to standby mode |'
  prefs: []
  type: TYPE_TB
- en: '| Pausing music | This plays the music | This changes to standby mode |'
  prefs: []
  type: TYPE_TB
- en: '| Standby | This changes to radio mode | This does nothing |'
  prefs: []
  type: TYPE_TB
- en: The preceding table shows us that we have four states to implement. Depending
    on the state, the button's behaviors will not be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, open the `StatePattern.xcodeproj` file to see the structure of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Our audio player device is represented by the `Player.swift` class in the `ConcreteClassWithState`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Our common interface that defines the method signature of a state behavior is
    defined in the `IPlayerState.swift` file. Each state that implements the `IPlayerState`
    interfaces are grouped in the `ConcreteState` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.swift` file contains our demo client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As always, we will first define our interface. Each state will implement a
    behavior for each of the two buttons visible on our audio player and pass the
    device object as an argument. This will allow the current state object to manipulate
    the current state of the audio player object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can implement our audio player. The `init` method is waiting to receive
    a `concreteState` instance that we will keep in mind in the state variable.
  prefs: []
  type: TYPE_NORMAL
- en: We define our two buttons. Each of them will delegate the request to the state
    object by invoking the appropriate button.
  prefs: []
  type: TYPE_NORMAL
- en: We then add a computed property called `CurrentState` that allows us to return
    the current state of the audio player or to change it through the state objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code of the `AudioPlayer` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our player is now ready and the interface implemented by the state''s objects
    is defined. We can now start with coding our first state: the `RadioState` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class represents the state where the audio player plays the radio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is quite simple; we inform the `init()` method that we are
    in the radio mode. We implement the `IAudioPlayerState` protocol and the `buttonSource`
    and `buttonAction` methods.
  prefs: []
  type: TYPE_NORMAL
- en: As we are in the radio mode, pressing `buttonAction` will change it to the next
    station, and clicking on the source button will move it to the `MusicPlaying`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the state of the audio player, we only need to make a call to the
    `CurrentState` property of the player object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same logical implementation and based on the table in the preceding
    example, we can complete our code. The following code is the implementation of
    the `MusicPlayingState` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the implementation of the `MusicPausedState` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the implementation of the `StandBySTate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our player is now ready to work. We will code our demo case to test whether
    the functionalities implemented are working as described in the table given in
    the introduction of the sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.swift` file and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we instantiate the first state where our audio player will be. We decide
    to put it in the `StandBy` mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we instantiate our audio player and pass the `standbymode` state as an
    argument. Finally, we will simulate an action on by clicking the action or source
    button. Let''s run the code, and you will see the result, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We start in the standby mode. The action button tells us that we cannot use
    it in the standby mode. So, we click on the source button and enter in the `radioMode`.
    We push the action button again; this changes to the next station and plays it.
  prefs: []
  type: TYPE_NORMAL
- en: We push the source button again and change to the music mode by playing the
    music. We push the action button and the music is paused. We then push the action
    button again and the music is played again.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we push the source button and the audio player comes back in the audio
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: The template method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template method pattern is a simple pattern used when you need a general
    behavior but where the details of the algorithm must be specific to subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The template method pattern isolates various parts of an algorithm. The algorithm
    skeleton is defined in an abstract class where some steps of the algorithm are
    delegated to its subclasses and some others are fixed in the abstract class itself
    and cannot be overridden in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram describes the generic structure of the template method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4582_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AbstractClass`, which defines the template method, and the signature of
    the sub parts of the algorithm are invoked by the template method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConcreteClass` implements abstract methods used by the template method
    of the `AbstractClass`. It is possible to have several concrete classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm defined in the template method is called `TemplateMethod()` in
    the generic UML class diagram and invokes parts of the algorithm in the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a new simulation game with several personage types. Each
    personage has several properties, such as money, happiness, fatigue, hungry, and
    knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these personages can "Play" a day. A day is decomposed in several parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetUp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EatBreakFast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoWashingUp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GoToWork`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Work`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GoHome`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoPersonalActivites`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EatDinner`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sleep`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have three types of personages: `Student`, `Searcher`, and `FireMan`; each
    of them can "play" a day but doesn''t react in the same way depending on the day
    phase.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we will override parts of the algorithm in the concrete class by defining
    the personage type. The only part of the algorithm that is fixed is the `DoWashingUp`
    function. This part will not and cannot be overridden in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the **TemplateMethod** project with Xcode. The project is quite simple.
    We will find the `TemplateMethod` folder in the `AbstractPersonage.Swift` class
    and all concrete subclasses that implement parts of the algorithm in the three
    concrete classes: `Searcher`, `Student`, and `FireMan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement the preceding example, we will first prepare our abstract class
    that defines a personage. Remember to consider this class as an abstract class.
    You must not instantiate it directly to your code, but you must instantiate only
    a subclass of `AbstractPersonage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can distinguish three parts. The first part is a
    private variable declaration. We mark the access modifier to avoid modification
    in subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `playDay` template method invokes all the parts of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the method signatures that are parts of the algorithm and we
    will eventually implement them. Here, we define a default implementation of each
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define our computed properties to modify the setter behavior by
    making an addition to itself when a new value is assigned to the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two steps make our sample better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a required constructor where we inject a name to the personage that
    we will instantiate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a `toString()` method that will print all the properties and values
    of the personage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Well, our abstract class that implements the template method is complete. Now,
    we have a skeleton to make a new concrete personage, for example, a student.
  prefs: []
  type: TYPE_NORMAL
- en: The student doesn't have a job, so he won't get paid. The student reads books
    during his personal activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will create a new `Student` class that implements our abstract class
    that contains the template method, and we will override only parts of the algorithm
    that changes in the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we define the `Searcher` and `FireMan` classes that implement
    our abstract classes and both can be paid but not the same amount. Also, each
    of them must override some parts of the algorithm to be more accurate with specificity
    of the entity that the class represent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Searcher` class, we will implement the `AbstractPersonage` protocol
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `FireMan` class, we will implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our template method and concrete classes are now ready. We can now write in
    the `main.swift` file. Our simple client will instantiate a student called `Simon`,
    a searcher called `Natasha`, and a fireman called `Edward`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will display the properties of each of them before simulating 30 days of
    their life. Then, we will tell these three personages to live for 30 days using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will play 30 days of life in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of these 30 days of life, we will check the properties of each of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The final code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. On the console, you will see the results after
    30 days of life:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4582_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are similarities between the strategy and state patterns, but the main
    difference is one of intents:'
  prefs: []
  type: TYPE_NORMAL
- en: The strategy object encapsulates an algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state object encapsulates a behavior that depends on the internal state
    of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both the patterns, we use polymorphism. So, for both the patterns, we define
    a parent interface or abstract class, and then we implement the methods defined
    in the parent interface or abstract class in concrete subclasses. The pattern
    maintains the context and depending on it decides the appropriate object to use.
    The biggest difference between these two patterns is that we encapsulate an algorithm
    into strategy classes in the strategy pattern, but we encapsulate a state into
    state classes in the state pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The template method pattern is more like the strategy pattern; it is based on
    the right application of an algorithm. In this pattern, all steps are specified
    in the template method and some subparts are deferred to subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will learn how to use two other behavioral patterns:
    chain of responsibility and command.'
  prefs: []
  type: TYPE_NORMAL
- en: Both are used to pass requests for actions to appropriate objects.
  prefs: []
  type: TYPE_NORMAL
