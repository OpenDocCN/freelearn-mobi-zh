- en: Chapter 5. Behavioral Patterns – Strategy, State, and Template Method
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 行为模式 – 策略、状态和模板方法
- en: 'I hope you''re still with us; now, we will introduce you to the third and last
    category of the design patterns, which is categorized as a **Gang of Four** (**GoF**)
    design patterns: the behavioral pattern. Behavioral patterns are dedicated to
    algorithms and communication between them.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您还在这里；现在，我们将向您介绍设计模式的第三和最后一个类别，它被归类为**四人帮**（**GoF**）设计模式：行为模式。行为模式致力于算法及其之间的通信。
- en: As algorithms consist of several operations that are divided into different
    classes, behavioral patterns can handle the organization of such classes and the
    ways in which they can communicate with one another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法由多个操作组成，这些操作被分为不同的类，因此行为模式可以处理这些类的组织和它们之间通信的方式。
- en: 'The behavioral category contains 11 patterns that we will discuss through four
    chapters. In this chapter, we will discuss the following three patterns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 行为类别包含11个模式，我们将通过四章来讨论。在本章中，我们将讨论以下三个模式：
- en: The strategy pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: The state pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: The template method pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The strategy pattern
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: When you need to change part of an object's algorithm at runtime, without modifying
    the client, the strategy pattern is the appropriate pattern to be used.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在运行时更改对象的部分算法，而不修改客户端时，策略模式是合适的模式。
- en: It removes an algorithm from its host class and moves it to a separate class.
    The algorithm part that can change is the **strategy**. Every strategy uses the
    same interface. The class using the strategy pattern delegates the treatment of
    the algorithm to the strategy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它将算法从其宿主类中移除并移动到单独的类。可以更改的算法部分是**策略**。每个策略都使用相同的接口。使用策略模式的类将算法的处理委托给策略。
- en: Roles
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The strategy pattern is used to create an interchangeable family of algorithms
    from which the required process is chosen at runtime.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式用于创建一个可互换的算法系列，在运行时从其中选择所需的过程。
- en: 'The algorithm changes don''t affect the client part. This pattern can be used
    in the following cases:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 算法变更不会影响客户端部分。此模式可以在以下情况下使用：
- en: The behavior of a class can be implemented by different algorithms where some
    of them are better in terms of execution time or memory consumption
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类的行为可以通过不同的算法实现，其中一些在执行时间或内存消耗方面表现更好
- en: Choosing the appropriate algorithm with `if` conditions instruction complexify
    the code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if` 条件指令选择合适的算法会使代码复杂化
- en: A system has similar classes where only the behavior changes; in this case,
    the strategy pattern allows you to group these classes in only one class, which
    greatly simplifies the interface for clients
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统具有类似类，其中只有行为发生变化；在这种情况下，策略模式允许您将这些类组合到一个类中，这大大简化了客户端的接口
- en: Design
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic structure of the strategy platform is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 策略平台的通用结构如下：
- en: '![Design](img/4582_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4582_05_01.jpg)'
- en: Participants
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants in the strategy pattern are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式中的参与者如下：
- en: '`IStrategy`: This class defines the common interface implemented by all algorithms.
    This is the interface used by the `ClassUsingStrategy` class to invoke the right
    algorithm.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IStrategy`：此类定义了所有算法实现的通用接口。这是 `ClassUsingStrategy` 类用来调用正确算法的接口。'
- en: '`ConcreteStrategyA` and `ConcreteStrategyB`: These are concrete classes that
    implement different algorithms based on the `IStrategy` interface.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteStrategyA` 和 `ConcreteStrategyB`：这些是根据 `IStrategy` 接口实现不同算法的具体类。'
- en: '`ClassUsingStrategyA` and `ClassUsingStrategyB`: These are classes that use
    an algorithm from classes that implement the `IStrategy` interface. These classes
    have a reference to one instance of one of the concrete strategy classes. These
    classes can expose some internal data to the implementation classes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassUsingStrategyA` 和 `ClassUsingStrategyB`：这些是使用实现 `IStrategy` 接口的类的算法的类。这些类有一个对具体策略类实例的引用。这些类可以向实现类公开一些内部数据。'
- en: Collaboration
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The `ClassUsingStrategy` and `ConcreteStrategy` classes interact to implement
    algorithms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassUsingStrategy` 和 `ConcreteStrategy` 类交互以实现算法。'
- en: In most cases, data needed by the algorithms is sent as arguments to the constructor
    but can be sent by a set property too. If needed, the `ClassUsingStrategy` class
    can provide you some methods to allow you to access its internal data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，算法所需的数据作为参数发送给构造函数，也可以通过设置属性发送。如果需要，`ClassUsingStrategy`类可以提供一些方法，让您访问其内部数据。
- en: The `Client` instance will initiate `ClassUsingStrategy` with a `Strategy` object
    and call the `ClassUsingStrategy` method that uses the strategy pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`实例将使用`Strategy`对象初始化`ClassUsingStrategy`，并调用使用策略模式的`ClassUsingStrategy`方法。'
- en: Then, this class will send the request received from the client to the instance
    that is referenced by the strategy attribute.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个类将把从客户端接收到的请求发送到策略属性引用的实例。
- en: Illustration
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: We will see how to implement the strategy pattern using a simple example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个简单的例子来了解如何实现策略模式。
- en: 'Some objects can move, but some of them don''t move in the same manner. Each
    object has a particular manner in which it moves: some can walk and others can
    run and fly. The move behavior is our strategy, and we will encapsulate the `performMove()`
    action in the concrete strategy class that is referenced in the concrete class
    using the strategy.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些物体可以移动，但它们移动的方式并不相同。每个物体都有其特定的移动方式：有的可以行走，有的可以奔跑和飞翔。移动行为是我们的策略，我们将把`performMove()`动作封装在具体策略类中，该类在具体类中使用策略。
- en: Implementation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Open the strategy pattern Xcode project to see the organization of our code.
    The participants in this pattern are separated in four folders, as shown in the
    following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开策略模式Xcode项目，查看我们代码的组织结构。该模式的参与者被分为四个文件夹，如下面的截图所示：
- en: '![Implementation](img/4582_05_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4582_05_02.jpg)'
- en: The first thing that we will do is define the interface of the move strategy
    and then describe `AbstractClassUsingMoveStrategy`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将定义移动策略的接口，然后描述`AbstractClassUsingMoveStrategy`。
- en: The interface of the move strategy is really easy; we will only tell the class
    implementing the strategy that we are waiting for a `performMove` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 移动策略的接口非常简单；我们只需告诉实现策略的类我们正在等待一个`performMove`方法。
- en: 'The `MoveStrategyProtocol.swift` file is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveStrategyProtocol.swift`文件如下：'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our abstract class needs to have a role to keep a reference to the strategy
    that will be applied by encapsulating the call to the `performMove` method of
    the current strategy into its own method that we will call `move()`. The instance
    of the strategy object will be received in the constructor of the class implementing
    the `AbstractObjectThatMove` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的抽象类需要有一个角色来保持对将要应用策略的引用，通过封装对当前策略的`performMove`方法的调用到我们自己的方法中，我们将调用该方法为`move()`。策略对象的实例将在实现`AbstractObjectThatMove`类的类的构造函数中接收。
- en: For our demo, we will add an internal computed property, `WhoAmI`, where we
    will set or get the name of the concrete class using the strategy pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将添加一个内部计算属性`WhoAmI`，我们将使用策略模式设置或获取具体类的名称。
- en: 'Our `AbstractObjectThatMove.swift` file is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AbstractObjectThatMove.swift`文件如下：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Swift 2.0 has no support for abstract classes as yet. Here, we named the `AbstractObjectThatMove`
    class, even if it is not a "real" abstract class, only to be as close as possible
    to the general concept of the pattern. Nevertheless, there might be a way to have
    something that seems like an abstract class, but it differs from the general concept
    of the pattern where we pass a strategy to the initializer. Swift 2.0 has protocol
    extensions that give the opportunity to add partial implemented methods to protocols,
    and in "some way", make an abstract class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2.0目前还没有支持抽象类。在这里，我们命名为`AbstractObjectThatMove`类，即使它不是一个“真正的”抽象类，也是为了尽可能接近模式的一般概念。尽管如此，可能有一种方法可以得到类似抽象类的东西，但它与通过初始化器传递策略的一般模式概念不同。Swift
    2.0有协议扩展，它提供了向协议添加部分实现方法的机会，并在“某种方式”上实现了一个抽象类：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we can process the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以处理以下代码：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we come back to the implementation of the pattern. In our current example,
    we have three concrete classes that implement the abstract classes: `Rabbit`,
    `Bird`, and `Human`. As the implementation is the same for all these three objects,
    I will only display the implementation of the concrete `Human` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们回到模式的实现。在我们的当前示例中，我们有三个具体类实现了抽象类：`Rabbit`、`Bird`和`Human`。由于这三个对象的实现相同，我将只展示具体`Human`类的实现：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We want to add a value to the `WhoAmI` property while it is initializing, so
    we inform the `init` method that this method is required. We then set the value
    of the property with a simple `self.WhoAmi = "I'm a human"` statement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在初始化 `WhoAmI` 属性时添加一个值，因此我们通知 `init` 方法这个方法是需要调用的。然后，我们使用简单的 `self.WhoAmI
    = "I'm a human"` 语句设置属性的值。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We could have done this by adding an additional parameter to the constructor
    defined in the `AbstractClass` that takes the value of `WhoAmI` and assigns it
    to the internal `whoAmI` variable too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在 `AbstractClass` 中定义的构造函数中添加一个额外的参数来实现这一点，该参数接受 `WhoAmI` 的值并将其分配给内部的
    `whoAmI` 变量。
- en: 'Now, we will implement `WalkMoveStrategy`, as defined in the `MoveStrategyProtocol`
    protocol:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现 `WalkMoveStrategy`，如 `MoveStrategyProtocol` 协议中定义的那样：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There''s nothing complex here; we implement the `performMove` method and print
    the message of the move action. The `RunMoveStrategy` and `FlyMoveStrategy` methods
    are implemented in the same way; just the `print` statement changes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有复杂的东西；我们实现了 `performMove` 方法并打印移动动作的消息。`RunMoveStrategy` 和 `FlyMoveStrategy`
    方法以相同的方式实现；只是 `print` 语句有所不同：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding highlighted code, you can see how we proceeded to apply the
    strategy to the `Human` class using the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的高亮代码中，您可以看到我们如何通过以下步骤将策略应用于 `Human` 类：
- en: First, we instantiate a strategy.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个策略。
- en: Next, we instantiate a concrete class using the strategy pattern where the strategy
    declared first is sent as an argument.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用策略模式实例化一个具体类，其中首先声明的策略作为参数传递。
- en: Then, we perform a move action in the concrete class. The move action invokes
    the `performMove` method of the strategy that the concrete class has in reference.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在具体类中执行一个移动动作。移动动作会调用具体类所引用的策略的 `performMove` 方法。
- en: Click on the **Run** button to see the result.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮查看结果。
- en: 'You should see the following result in the console of Xcode:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在 Xcode 的控制台中看到以下结果：
- en: '![Implementation](img/4582_05_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4582_05_03.jpg)'
- en: The state pattern
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: In the state pattern, a class behavior changes based on its state. This type
    of design pattern comes under the behavior pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态模式中，一个类的行为根据其状态而改变。这种设计模式属于行为模式。
- en: In the state pattern, we create objects that represent various states and a
    context object whose behavior varies as its state object changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态模式中，我们创建代表各种状态的对象以及一个上下文对象，其行为随着状态对象的变化而变化。
- en: Role
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The role of this pattern is to adapt its behavior depending on the internal
    state of an object. It can be used when implementing the dependency of the state
    object if the condition statement becomes complex.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的角色是根据对象的内部状态调整其行为。当条件语句变得复杂时，可以用来实现状态对象的依赖。
- en: Design
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic class diagram structure of the state pattern is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式的通用类图结构如下：
- en: '![Design](img/4582_05_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4582_05_04.jpg)'
- en: Participants
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants in the state pattern are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式中的参与者如下：
- en: '`StateMachine`: This is a concrete class that describes a state machine''s
    objects, which means that they have a set of states that can be described in a
    state transition diagram. This class has a reference to an instance of a sub class
    that implements the state abstract class and defines the current state.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StateMachine`：这是一个具体类，它描述了状态机对象的属性，这意味着它们有一组可以在状态转换图中描述的状态。这个类有一个指向实现状态抽象类的子类实例的引用，并定义了当前状态。'
- en: '`IState`: This is an abstract class that introduces you to the methods signature
    of a state behavior.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IState`：这是一个抽象类，它向您介绍了状态行为的方法签名。'
- en: '`ConcreteStateA` and `ConcreteStateB`: These are concrete subclasses that implement
    the behavioral methods depending on the state.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteStateA` 和 `ConcreteStateB`：这些是具体子类，根据状态实现行为方法。'
- en: Collaboration
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The `StateMachine` object delegates the call of the method to a `ConcreteState`
    object depending on the current state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateMachine` 对象根据当前状态将方法调用委派给一个 `ConcreteState` 对象。'
- en: The `StateMachine` object can send a reference to itself and to the `ConcreteState`
    object if needed. This reference can then be sent through the initialization of
    the `concreteState` object or each time calls are delegated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，`StateMachine` 对象可以发送对其自身和对 `ConcreteState` 对象的引用。然后，这个引用可以通过 `concreteState`
    对象的初始化或每次调用委派来发送。
- en: Illustration
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: 'Your company needs to sell a new device that has only two buttons that can
    play the radio or some music. You need to have the following functionalities,
    depending on the current state of the device:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的公司需要销售一款只有两个按钮的新设备，这两个按钮可以播放收音机或音乐。您需要根据设备的当前状态实现以下功能：
- en: '| State | Action button | Source button |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 动作按钮 | 源按钮 |'
- en: '| --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Radio | This changes to the next station and plays it | This changes to music
    playing mode |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 收音机 | 这将切换到下一个电台并播放 | 这将切换到音乐播放模式 |'
- en: '| Playing music | This pauses the music | This changes to standby mode |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 播放音乐 | 这将暂停音乐 | 这将切换到待机模式 |'
- en: '| Pausing music | This plays the music | This changes to standby mode |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 暂停音乐 | 这将播放音乐 | 这将切换到待机模式 |'
- en: '| Standby | This changes to radio mode | This does nothing |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 待机 | 这将切换到收音机模式 | 这将不执行任何操作 |'
- en: The preceding table shows us that we have four states to implement. Depending
    on the state, the button's behaviors will not be the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格显示我们需要实现四个状态。根据状态的不同，按钮的行为将不同。
- en: Implementation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现方式
- en: First, open the `StatePattern.xcodeproj` file to see the structure of the project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `StatePattern.xcodeproj` 文件以查看项目的结构。
- en: Our audio player device is represented by the `Player.swift` class in the `ConcreteClassWithState`
    folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐播放器设备由 `Player.swift` 类在 `ConcreteClassWithState` 文件夹中表示。
- en: Our common interface that defines the method signature of a state behavior is
    defined in the `IPlayerState.swift` file. Each state that implements the `IPlayerState`
    interfaces are grouped in the `ConcreteState` folder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的公共接口，它定义了状态行为的方法签名，在 `IPlayerState.swift` 文件中。实现 `IPlayerState` 接口的每个状态都分组在
    `ConcreteState` 文件夹中。
- en: 'The `main.swift` file contains our demo client:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.swift` 文件包含我们的演示客户端：'
- en: '![Implementation](img/4582_05_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4582_05_05.jpg)'
- en: 'As always, we will first define our interface. Each state will implement a
    behavior for each of the two buttons visible on our audio player and pass the
    device object as an argument. This will allow the current state object to manipulate
    the current state of the audio player object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先定义我们的接口。每个状态将为音频播放器上可见的两个按钮中的每一个实现一个行为，并将设备对象作为参数传递。这将允许当前状态对象操作音频播放器对象的当前状态：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, we can implement our audio player. The `init` method is waiting to receive
    a `concreteState` instance that we will keep in mind in the state variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以实现我们的音频播放器。`init` 方法正在等待接收一个 `concreteState` 实例，我们将记住它在状态变量中。
- en: We define our two buttons. Each of them will delegate the request to the state
    object by invoking the appropriate button.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个按钮。每个按钮将通过调用适当的按钮将请求委派给状态对象。
- en: We then add a computed property called `CurrentState` that allows us to return
    the current state of the audio player or to change it through the state objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了一个名为 `CurrentState` 的计算属性，允许我们返回音频播放器的当前状态或通过状态对象更改它。
- en: 'The final code of the `AudioPlayer` class is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayer` 类的最终代码如下：'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our player is now ready and the interface implemented by the state''s objects
    is defined. We can now start with coding our first state: the `RadioState` class.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐播放器现在已准备就绪，状态对象实现的接口已定义。我们现在可以开始编写我们的第一个状态：`RadioState` 类。
- en: 'This class represents the state where the audio player plays the radio:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此类表示音频播放器播放收音机的状态：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The implementation is quite simple; we inform the `init()` method that we are
    in the radio mode. We implement the `IAudioPlayerState` protocol and the `buttonSource`
    and `buttonAction` methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单；我们通知 `init()` 方法我们处于收音机模式。我们实现了 `IAudioPlayerState` 协议以及 `buttonSource`
    和 `buttonAction` 方法。
- en: As we are in the radio mode, pressing `buttonAction` will change it to the next
    station, and clicking on the source button will move it to the `MusicPlaying`
    state.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于收音机模式，按下 `buttonAction` 将将其切换到下一个电台，点击源按钮将将其移动到 `MusicPlaying` 状态。
- en: 'To change the state of the audio player, we only need to make a call to the
    `CurrentState` property of the player object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改音频播放器的状态，我们只需要调用播放器对象的 `CurrentState` 属性：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the same logical implementation and based on the table in the preceding
    example, we can complete our code. The following code is the implementation of
    the `MusicPlayingState` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的逻辑实现，并基于前一个示例中的表格，我们可以完成我们的代码。以下代码是 `MusicPlayingState` 类的实现：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code is the implementation of the `MusicPausedState` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `MusicPausedState` 类的实现：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code is the implementation of the `StandBySTate` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`StandBySTate`类的实现：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our player is now ready to work. We will code our demo case to test whether
    the functionalities implemented are working as described in the table given in
    the introduction of the sample.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏玩家现在已准备好工作。我们将编写我们的演示案例代码来测试实现的功能是否与样本介绍中给出的表格中描述的一致。
- en: 'Open the `main.swift` file and write the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main.swift`文件并编写以下代码：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we instantiate the first state where our audio player will be. We decide
    to put it in the `StandBy` mode.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化第一个状态，我们的音频播放器将处于其中。我们决定将其置于`StandBy`模式。
- en: 'Then, we instantiate our audio player and pass the `standbymode` state as an
    argument. Finally, we will simulate an action on by clicking the action or source
    button. Let''s run the code, and you will see the result, as shown in the following
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化我们的音频播放器，并将`standbymode`状态作为参数传递。最后，我们将通过点击动作或源按钮来模拟一个动作。让我们运行代码，你将看到以下示例中的结果：
- en: '![Implementation](img/4582_05_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Implementation](img/4582_05_06.jpg)'
- en: We start in the standby mode. The action button tells us that we cannot use
    it in the standby mode. So, we click on the source button and enter in the `radioMode`.
    We push the action button again; this changes to the next station and plays it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从待机模式开始。动作按钮告诉我们，在待机模式下不能使用它。因此，我们点击源按钮进入`radioMode`。我们再次按下动作按钮；这会切换到下一个电台并播放。
- en: We push the source button again and change to the music mode by playing the
    music. We push the action button and the music is paused. We then push the action
    button again and the music is played again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次按下源按钮，通过播放音乐切换到音乐模式。我们按下动作按钮，音乐暂停。然后我们再次按下动作按钮，音乐再次播放。
- en: Finally, we push the source button and the audio player comes back in the audio
    mode.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按下源按钮，音频播放器回到音频模式。
- en: The template method
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: The template method pattern is a simple pattern used when you need a general
    behavior but where the details of the algorithm must be specific to subclasses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式是一个简单的模式，当需要通用行为但算法的细节必须针对子类具体化时使用。
- en: Role
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The template method pattern isolates various parts of an algorithm. The algorithm
    skeleton is defined in an abstract class where some steps of the algorithm are
    delegated to its subclasses and some others are fixed in the abstract class itself
    and cannot be overridden in subclasses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式将算法的各个部分隔离开来。算法骨架在抽象类中定义，其中一些算法步骤被委派给其子类，而另一些则固定在抽象类本身中，不能在子类中重写。
- en: Design
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following diagram describes the generic structure of the template method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了模板方法的通用结构：
- en: '![Design](img/4582_05_07.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Design](img/4582_05_07.jpg)'
- en: Participants
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of this pattern are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本模式的参与者如下：
- en: The `AbstractClass`, which defines the template method, and the signature of
    the sub parts of the algorithm are invoked by the template method.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模板方法并调用算法子部分签名的`AbstractClass`，由模板方法调用。
- en: The `ConcreteClass` implements abstract methods used by the template method
    of the `AbstractClass`. It is possible to have several concrete classes.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteClass`实现了由`AbstractClass`的模板方法使用的抽象方法。可以有多个具体类。'
- en: Collaboration
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The algorithm defined in the template method is called `TemplateMethod()` in
    the generic UML class diagram and invokes parts of the algorithm in the subclasses.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法中定义的算法在通用UML类图中称为`TemplateMethod()`，并调用子类中算法的部分。
- en: Illustration
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: You are working on a new simulation game with several personage types. Each
    personage has several properties, such as money, happiness, fatigue, hungry, and
    knowledge.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在开发一个包含多个人物类型的新模拟游戏。每个角色都有几个属性，如金钱、幸福、疲劳、饥饿和知识。
- en: 'Each of these personages can "Play" a day. A day is decomposed in several parts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人物中的每一个都可以“玩”一天。一天被分解为几个部分：
- en: '`GetUp`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetUp`'
- en: '`EatBreakFast`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EatBreakFast`'
- en: '`DoWashingUp`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoWashingUp`'
- en: '`GoToWork`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoToWork`'
- en: '`Work`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Work`'
- en: '`GoHome`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoHome`'
- en: '`DoPersonalActivites`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoPersonalActivites`'
- en: '`EatDinner`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EatDinner`'
- en: '`Sleep`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sleep`'
- en: 'We have three types of personages: `Student`, `Searcher`, and `FireMan`; each
    of them can "play" a day but doesn''t react in the same way depending on the day
    phase.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种人物类型：`Student`、`Searcher`和`FireMan`；他们每个人都可以“玩”一天，但根据一天的不同阶段，他们的反应方式并不相同。
- en: So, we will override parts of the algorithm in the concrete class by defining
    the personage type. The only part of the algorithm that is fixed is the `DoWashingUp`
    function. This part will not and cannot be overridden in subclasses.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将通过定义人物类型来在具体类中覆盖算法的部分。算法中唯一固定的部分是`DoWashingUp`函数。这部分不会也不会在子类中被覆盖。
- en: Implementation
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Open the **TemplateMethod** project with Xcode. The project is quite simple.
    We will find the `TemplateMethod` folder in the `AbstractPersonage.Swift` class
    and all concrete subclasses that implement parts of the algorithm in the three
    concrete classes: `Searcher`, `Student`, and `FireMan`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Xcode打开**TemplateMethod**项目。该项目相当简单。我们将在`AbstractPersonage.Swift`类中的`TemplateMethod`文件夹以及所有具体子类中找到实现算法三部分的具体类：`Searcher`、`Student`和`FireMan`：
- en: '![Implementation](img/4582_05_08.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4582_05_08.jpg)'
- en: 'To implement the preceding example, we will first prepare our abstract class
    that defines a personage. Remember to consider this class as an abstract class.
    You must not instantiate it directly to your code, but you must instantiate only
    a subclass of `AbstractPersonage`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的示例，我们首先准备我们的抽象类，该类定义了一个人物。请记住，将此类视为抽象类。你不得直接在代码中实例化它，但必须只实例化`AbstractPersonage`的子类：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we can distinguish three parts. The first part is a
    private variable declaration. We mark the access modifier to avoid modification
    in subclasses:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以区分三个部分。第一部分是私有变量声明。我们标记访问修饰符以避免在子类中进行修改：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our `playDay` template method invokes all the parts of the algorithm:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`playDay`模板方法调用算法的所有部分：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we define the method signatures that are parts of the algorithm and we
    will eventually implement them. Here, we define a default implementation of each
    method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了算法的一部分的方法签名，我们最终将实现它们。在这里，我们为每个方法定义了一个默认实现：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we define our computed properties to modify the setter behavior by
    making an addition to itself when a new value is assigned to the property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了计算属性，通过在属性分配新值时对其自身进行添加来修改setter行为：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following two steps make our sample better:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个步骤使我们的示例变得更好：
- en: 'We add a required constructor where we inject a name to the personage that
    we will instantiate:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个必需的构造函数，其中注入一个名称到我们将要实例化的人物：
- en: '[PRE20]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We define a `toString()` method that will print all the properties and values
    of the personage:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个`toString()`方法，它将打印出人物的属性和值：
- en: '[PRE21]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Well, our abstract class that implements the template method is complete. Now,
    we have a skeleton to make a new concrete personage, for example, a student.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们实现模板方法的抽象类已经完成。现在，我们有一个骨架来创建一个新的具体人物，例如，一个学生。
- en: The student doesn't have a job, so he won't get paid. The student reads books
    during his personal activities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 学生没有工作，所以不会获得报酬。学生在个人活动中读书。
- en: 'So, we will create a new `Student` class that implements our abstract class
    that contains the template method, and we will override only parts of the algorithm
    that changes in the parent class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个新的`Student`类，该类实现了包含模板方法的抽象类，并且我们只覆盖了父类中改变的部分的算法：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the same way, we define the `Searcher` and `FireMan` classes that implement
    our abstract classes and both can be paid but not the same amount. Also, each
    of them must override some parts of the algorithm to be more accurate with specificity
    of the entity that the class represent:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们定义了`Searcher`和`FireMan`类，它们实现了我们的抽象类，并且两者都可以获得报酬，但金额并不相同。此外，每个类都必须覆盖算法的一些部分，以便更精确地反映该类所代表的实体的特定性：
- en: 'For the `Searcher` class, we will implement the `AbstractPersonage` protocol
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Searcher`类，我们将按照以下方式实现`AbstractPersonage`协议：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the `FireMan` class, we will implement it as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`FireMan`类，我们将按照以下方式实现它：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our template method and concrete classes are now ready. We can now write in
    the `main.swift` file. Our simple client will instantiate a student called `Simon`,
    a searcher called `Natasha`, and a fireman called `Edward`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式方法和具体类现在已准备就绪。我们现在可以在`main.swift`文件中编写代码。我们的简单客户端将实例化一个名为`Simon`的学生，一个名为`Natasha`的搜索者，以及一个名为`Edward`的消防员。
- en: 'We will display the properties of each of them before simulating 30 days of
    their life. Then, we will tell these three personages to live for 30 days using
    the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在模拟他们30天生活之前显示他们的属性。然后，我们将使用以下代码告诉这三个人物生活30天：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we will play 30 days of life in a `for` loop:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`for`循环模拟30天的生活：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At the end of these 30 days of life, we will check the properties of each of
    them:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这30天生命周期的最后，我们将检查每个对象的属性：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The final code is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码如下：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Click on the **Run** button. On the console, you will see the results after
    30 days of life:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。在控制台，你将在30天生命周期的结束后看到结果：
- en: '![Implementation](img/4582_05_09.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4582_05_09.jpg)'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'There are similarities between the strategy and state patterns, but the main
    difference is one of intents:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式和状态模式之间存在相似之处，但主要区别在于意图：
- en: The strategy object encapsulates an algorithm
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略对象封装了一个算法
- en: The state object encapsulates a behavior that depends on the internal state
    of an object
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态对象封装了一个依赖于对象内部状态的行为
- en: In both the patterns, we use polymorphism. So, for both the patterns, we define
    a parent interface or abstract class, and then we implement the methods defined
    in the parent interface or abstract class in concrete subclasses. The pattern
    maintains the context and depending on it decides the appropriate object to use.
    The biggest difference between these two patterns is that we encapsulate an algorithm
    into strategy classes in the strategy pattern, but we encapsulate a state into
    state classes in the state pattern.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种模式中，我们都使用多态。因此，对于这两种模式，我们定义一个父接口或抽象类，然后在具体的子类中实现父接口或抽象类中定义的方法。该模式维护上下文，并根据它决定使用适当的对象。这两种模式之间最大的区别在于，在策略模式中，我们将算法封装到策略类中，但在状态模式中，我们将状态封装到状态类中。
- en: The template method pattern is more like the strategy pattern; it is based on
    the right application of an algorithm. In this pattern, all steps are specified
    in the template method and some subparts are deferred to subclasses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式更像是策略模式；它基于算法的正确应用。在这个模式中，所有步骤都在模板方法中指定，一些子部分被延迟到子类中。
- en: 'In the next chapter, we will learn how to use two other behavioral patterns:
    chain of responsibility and command.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用两种其他的行为模式：责任链和命令。
- en: Both are used to pass requests for actions to appropriate objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都用于将动作请求传递给适当的对象。
