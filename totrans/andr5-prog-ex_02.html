<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Building a UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building a UI</h1></div></div></div><p>The <span class="strong"><strong>Material Design</strong></span> UI paradigm has brought a whole new look and feel to the Android platform. This<a id="id37" class="indexterm"/> new approach aims to give Android apps a clean and simple appearance with intuitive controls and animations. Google talks of virtual paper and virtual ink, and this concept can be seen most clearly in the new screen component (or widget), the Card (or <code class="literal">CardView</code>), which unlike previous Android widgets casts a shadow and has rounded corners.</p><div class="mediaobject"><img src="graphics/B04321_02_01.jpg" alt="Building a UI"/></div><p>Even before we have placed our first <code class="literal">CardView</code> widget into our layout, we can start to utilize Material Design by applying and customizing one of the material themes. These themes allow us to define a few base colors and properties which are then automatically applied throughout our app, giving it a brand identity that helps our app to be easily recognized by the user.</p><p>Having created our layout, we can then see how Java is used to provide functionality. Here, we will use a button to launch a simple Material Design animation, which we will then adapt to our layout to handle screen rotations and provide textual context to our images for users with visual impairments.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apply a material theme to our app</li><li class="listitem" style="list-style-type: disc">Apply your brand colors</li><li class="listitem" style="list-style-type: disc">Understand Material Design color guidelines</li><li class="listitem" style="list-style-type: disc">Add new widgets to a relative layout</li><li class="listitem" style="list-style-type: disc">Write some Java code to detect button clicks</li><li class="listitem" style="list-style-type: disc">Write code to produce an animation</li><li class="listitem" style="list-style-type: disc">Observe the build process with the Gradle console</li><li class="listitem" style="list-style-type: disc">Apply accessibility options for images</li><li class="listitem" style="list-style-type: disc">Create layouts for alternative screen orientations</li></ul></div><p>In this chapter, we will continue to develop the <code class="literal">Hello World</code> app that we started in the previous chapter and use it to demonstrate a simple animation. The code can be downloaded from the Packt Publishing website and is called <code class="literal">Hello World - Chapter 2</code>.</p><div class="section" title="Applying a Material Design theme"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Applying a Material Design theme</h1></div></div></div><p>Android themes govern the general appearance of our app, controlling things like default background<a id="id38" class="indexterm"/> colors and text colors and sizes. Prior to <a id="id39" class="indexterm"/>Android 5, the Holo theme was the most widely used built-in theme, and you can preview it by clicking on the <span class="strong"><strong>App Theme</strong></span> button at the top of the <code class="literal">activity_main.xml</code> file, when viewed in the <span class="strong"><strong>Design</strong></span> tab.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Note that previewing a theme will have no effect on the app when it is run on a handset or an emulator, as this has to be achieved within the code.</p></div></div><p>All Android themes are highly configurable and none more so than the material theme, which allows us, with just a few lines of code, to set a color scheme that is applied across the app, and unlike its predecessors, to also change the color of the toolbar and the navigation bar. The following exercise details how such branding can be applied to the project we set up in the last chapter:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Hello World</code> project from the last chapter.</li><li class="listitem">If it is not open already, open the <span class="strong"><strong>Project</strong></span> tool window from the menu with <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Tool Windows</strong></span> | <span class="strong"><strong>Project</strong></span>.</li><li class="listitem">Locate the <code class="literal">res/values</code> folder and right-click on it.</li><li class="listitem">Select <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>XML</strong></span> | <span class="strong"><strong>Values XML File</strong></span> from the menu and call the file <code class="literal">colors</code>.</li><li class="listitem">Fill out<a id="id40" class="indexterm"/> the <code class="literal">colors.xml</code> file as follows<a id="id41" class="indexterm"/> here:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
  &lt;color name="primary"&gt;#FF9800&lt;/color&gt;
  &lt;color name="primary_dark"&gt;#F57C00&lt;/color&gt;
  &lt;color name="accent"&gt;#03A9F4&lt;/color&gt;
  &lt;color name="text_primary"&gt;#DF000000&lt;/color&gt;
  &lt;color name="text_secondary"&gt;#8A000000&lt;/color&gt;&gt;
&lt;/resources&gt;</pre></div></li><li class="listitem">Open the <code class="literal">res/values/styles/styles.xml (v21)</code> file and complete it as below:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

  &lt;style name="AppTheme" parent="android:Theme.Material.Light"&gt;
    &lt;item name="android:colorPrimary"&gt;@color/primary&lt;/item&gt;
    &lt;item name="android:colorPrimaryDark"&gt;@color/primary_dark&lt;/item&gt;
    &lt;item name="android:colorAccent"&gt;@color/accent&lt;/item&gt;
    &lt;item name="android:textColorPrimary"&gt;@color/text_primary&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@color/text_secondary&lt;/item&gt;
    &lt;item name="android:navigationBarColor"&gt;@color/primary_dark&lt;/item&gt;
  &lt;/style&gt;
&lt;/resources&gt;</pre></div></li><li class="listitem">You can now run the app on a handset or an emulator, to see how our brand colors have been applied:<div class="mediaobject"><img src="graphics/B04321_02_02.jpg" alt="Applying a Material Design theme"/></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Note<a id="id42" class="indexterm"/> that not all the material theme colors will show<a id="id43" class="indexterm"/> up on the standard Android AVDs, in particular, the status and navigation bars. To view the changes, you will need a real device or one of the third-party emulators.</p></div></div><p>Being able to apply our own color scheme to the previously un-editable UI elements, such as the status and navigation bars is a huge bonus. Not only does it give us control over how the entire screen looks, but it gives our apps an identifiable and individual feel.</p><p>Android provides<a id="id44" class="indexterm"/> fields such as <code class="literal">colorPrimaryDark</code> and <code class="literal">navigationBarColor</code> as convenient ways to apply our color schemes throughout <a id="id45" class="indexterm"/>the app. It is generally recommended that the navigation bar be left black, and was colored here simply by way of demonstration. We did not use all the color attributes that we could have; had we wanted to, we could have set the window background color with <code class="literal">windowBackground</code> and <code class="literal">statusBarColor</code>, which will override it being set by default as <code class="literal">colorPrimaryDark</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Note that <code class="literal">colorAccent</code> is not visible in this demonstration. It is used for switches, sliders and editable text views, among other things. It is included here as we will be using this theme (or one with colors of your choice) throughout the book and the inclusion of <code class="literal">colorAccent</code> will become evident as we progress.</p></div></div><p>Selecting colors for our theme is made remarkably easy with the help of an IDE, as you can see that the colors we have defined are displayed in the gutter:</p><div class="mediaobject"><img src="graphics/B04321_02_03.jpg" alt="Applying a Material Design theme"/></div><p>From the <code class="literal">colors.xml</code> file, these colors can be clicked on to produce a dynamic color wheel for us to select from. Although we are free to use any colors we like for our theme, Google design guidelines<a id="id46" class="indexterm"/> suggest that colors should be picked from the recommended hues, a full list of which can be found at <a class="ulink" href="http://www.google.com/design/spec/style/color.html">http://www.google.com/design/spec/style/color.html</a>. Furthermore, Google also recommends that the primary color should have a value of 500 and the darker version should be 700.</p><p>In the <code class="literal">colors.xml</code> file, it can be seen that the text colors are defined with alpha channels.</p><p>Google recommends that we use transparency to produce various shades of text. In particular, they suggest around 87% opacity for our primary text and 54% for the secondary. When dealing with white text on a dark background, opacity values of 100% and 70% should be used. Edit text hints should be around 28% for either background.</p><p>You will have <a id="id47" class="indexterm"/>noticed that there are two <code class="literal">styles.xml</code> files, the <code class="literal">v21</code> version that we used and another with the same name. This other styles file is <a id="id48" class="indexterm"/>used for providing alternative themes for when we need to make our apps backward compatible. We will come to this in due course, but for now the other styles file can be safely ignored.</p><p>Material Design guidelines do not have to be followed rigidly, especially if you are designing a full-screen app such as a game. They are there to help developers build apps that provide a consistent experience across the platform, and how strictly you adhere to the guidelines is entirely up to you.</p><p>Having seen how easy it is to apply a personalized theme to our app, we can now start to add more visual components to our layout and take a look at how they can then be controlled programmatically with Java. We will continue with our <code class="literal">Hello World</code> project and to make it a little more interesting, we will add in some simple Android 5 animations.</p></div></div>
<div class="section" title="Adding animated widgets"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Adding animated widgets</h1></div></div></div><p>As with many<a id="id49" class="indexterm"/> programming languages, design and functionality are dealt with more or less separately. We use XML to design our layouts and Java to provide them with functionality. Here, we will see how both of these are done and will deal separately with each.</p><div class="section" title="Designing an XML layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Designing an XML layout</h2></div></div></div><p>We will be<a id="id50" class="indexterm"/> using the graphical design view to construct this UI, but it is worth checking the text view from the tab at the bottom after<a id="id51" class="indexterm"/> each step, to see how the changes that we make are applied in XML.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Hello World</code> project and then the <code class="literal">activity_main.xml</code> file.</li><li class="listitem">Click on the <span class="strong"><strong>Design</strong></span> tab at the bottom to view the device preview.</li><li class="listitem">Drag a <code class="literal">TextView</code> control into the middle of the screen, like so:<div class="mediaobject"><img src="graphics/B04321_02_04.jpg" alt="Designing an XML layout"/></div></li><li class="listitem">From<a id="id52" class="indexterm"/> the <span class="strong"><strong>Palette</strong></span> on the left, drag<a id="id53" class="indexterm"/> and drop a <span class="strong"><strong>Button</strong></span> widget to the bottom-center of the screen.</li><li class="listitem">Drag an <span class="strong"><strong>ImageView</strong></span> control from the <span class="strong"><strong>Palette</strong></span> just under the <span class="strong"><strong>TextView</strong></span>. The tip at the top should read:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>centreHorizontal</strong></span>
<span class="strong"><strong>below=&lt;generated&gt;</strong></span>
</pre></div></li><li class="listitem">With the <span class="strong"><strong>ImageView</strong></span> still selected, or by selecting it in the <span class="strong"><strong>Component Tree</strong></span> pane, locate <code class="literal">src</code> in the <span class="strong"><strong>Properties</strong></span> pane beneath this and click on the <span class="strong"><strong>....</strong></span> button to bring up this dialog box:<div class="mediaobject"><img src="graphics/B04321_02_05.jpg" alt="Designing an XML layout"/></div></li><li class="listitem">Select <span class="strong"><strong>Mip Map</strong></span> | <span class="strong"><strong>ic_launcher</strong></span> and click on <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">Selecting<a id="id54" class="indexterm"/> the <span class="strong"><strong>ImageView</strong></span> in the preview<a id="id55" class="indexterm"/> window and press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> followed by <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>V</em></span>.</li><li class="listitem">Place the <span class="strong"><strong>ImageView</strong></span> copy to the right of the one we just created.</li><li class="listitem">Repeat this process, placing a third <span class="strong"><strong>ImageView</strong></span> to the left, so that the lower half of the layout looks like this:<div class="mediaobject"><img src="graphics/B04321_02_06.jpg" alt="Designing an XML layout"/></div></li><li class="listitem">Now, open<a id="id56" class="indexterm"/> the <span class="strong"><strong>Text</strong></span> view of our layout <a id="id57" class="indexterm"/>with the tab at the bottom.</li><li class="listitem">Locate the <span class="strong"><strong>Button</strong></span> node and click on the line that reads <code class="literal">android:text="New Button"</code>. An amber quick fix bulb will appear along with a warning about hardcoding strings.<div class="mediaobject"><img src="graphics/B04321_02_07.jpg" alt="Designing an XML layout"/></div></li><li class="listitem">Click on the <span class="strong"><strong>quick fix</strong></span> drop-down and select <span class="strong"><strong>Extract string resource</strong></span>.</li><li class="listitem">In the resultant dialog, provide the <span class="strong"><strong>Resource name</strong></span> as <code class="literal">button_text</code> and click on <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">Open the file in <span class="strong"><strong>Text</strong></span> view and add this line to the <code class="literal">RelativeLayout</code> element:<div class="informalexample"><pre class="programlisting">android:id="@+id/view_group"</pre></div></li><li class="listitem">Then, add this line to the <span class="strong"><strong>TextView</strong></span>:<div class="informalexample"><pre class="programlisting">android:textAppearance="?android:attr/textAppearanceMedium"</pre></div><p>That's it, as far as designing our layout is concerned!</p></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>You can use <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>L</em></span> to automatically format any code. <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>L</em></span> will bring up the reformatting dialog.</p></div></div><p>All Android layout <a id="id58" class="indexterm"/>designs have at their root a<a id="id59" class="indexterm"/> container object called a <span class="strong"><strong>ViewGroup</strong></span>, in to which all other graphical objects are <a id="id60" class="indexterm"/>placed. This includes other ViewGroups, although complex layouts with lots of nested ViewGroups can have a negative effect on performance.</p><p>The ViewGroup widget container we <a id="id61" class="indexterm"/>used here was the <span class="strong"><strong>RelativeLayout</strong></span>. There are several other types of layout, each being suited to a particular purpose, and we will encounter these throughout the book. The RelativeLayout widget container we used here allows us to define widget positions relative to other widgets. For example:</p><div class="informalexample"><pre class="programlisting">android:layout_below="@+id/textView</pre></div><p>This is very handy when it comes to designing layouts that will run on screens of varying sizes and ratios.</p><p>There are three tools at our disposal when it comes to generating layout files. We have the (almost) WYSIWYG device preview window, that allows us to position and size the widgets, the <span class="strong"><strong>Properties</strong></span> pane which lets us set particular values and, perhaps most powerfully, the <span class="strong"><strong>Text</strong></span> edit window which provides control over every aspect of our design.</p><p>We set the size of our text with <code class="literal">android:attr/textAppearanceMedium</code>. We could have set the size exactly with something like <code class="literal">android:textSize="42sp"</code>, but using <code class="literal">textAppearanceMedium</code> or <code class="literal">textAppearanceLarge</code> or <code class="literal">textAppearanceSmall</code> takes into consideration the text settings that the user has configured on their phone.</p><p>By far the most important aspect of what we have just done is the fact that each widget has an identifier in the form of <code class="literal">android:id="@+id/some_unique_identifier"</code>. These IDs are how we refer to and control widgets during runtime from our Java code.</p><p>We used the built-in application icon for our <span class="strong"><strong>ImageView</strong></span> controls as a matter of convenience, but we could have supplied our own imagery, stored it in the <code class="literal">res(ources)/drawable</code> folder and used its filename (without the extension) as its ID. We will be doing a lot of this later, so it is not necessary to worry about it here. If you take a look inside the <code class="literal">mipmap</code> folder, you will see that there are four <code class="literal">ic_launcher</code> icons, for varying screen densities. To achieve high quality icons for all available screen densities, you <a id="id62" class="indexterm"/>will need to provide all four icons.</p><p>When we created<a id="id63" class="indexterm"/> the button on our screen, IDE provided the text <span class="strong"><strong>New Button</strong></span> for us. Although a hardcoded string like this will work perfectly well, it is not recommended, for the reason that you will not be able to provide translations into other languages.</p><p>With our layout in place, we can now get on with the business of making it do something. Here, we will apply some of the new Android 5 animations which work when the button is clicked on.</p></div><div class="section" title="Controlling the widget behavior with Java"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Controlling the widget behavior with Java</h2></div></div></div><p>Android 5 introduces a new and simpler way of animating screen elements. These animations<a id="id64" class="indexterm"/> are of most use when<a id="id65" class="indexterm"/> transitioning between one screen to another, and can be used to intuitively display to the user what the app is doing. This app has only one screen (<code class="literal">Activity</code>), so we will just animate our widgets to fly off the screen and then return. Before we start though, we need to configure the IDE to automatically import the Java libraries our app will use. Follow these steps to see how both tasks are done:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From the <span class="strong"><strong>File Menu</strong></span> select <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>General</strong></span> | <span class="strong"><strong>Auto Import</strong></span> and check all boxes as below:<div class="mediaobject"><img src="graphics/B04321_02_10.jpg" alt="Controlling the widget behavior with Java"/></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file.</li><li class="listitem">At the top of the class, add these fields:<div class="informalexample"><pre class="programlisting">public class MainActivity extends Activity {
  <span class="strong"><strong>private ViewGroup viewGroup;</strong></span>
  <span class="strong"><strong>private TextView textView;</strong></span>
  <span class="strong"><strong>private ImageView imageView, imageView2, imageView3;</strong></span>
  <span class="strong"><strong>private Button button;</strong></span>
</pre></div></li><li class="listitem">In the <code class="literal">onCreate()</code> method underneath the line <code class="literal">setContentView(R.layout.activity_main);</code> add this code:<div class="informalexample"><pre class="programlisting">viewGroup = (ViewGroup) findViewById(R.id.view_group);

textView = (TextView) findViewById(R.id.textView);
textView.setText("Animation demo");

imageView1 = (ImageView) findViewById(R.id.imageView);
imageView2 = (ImageView) findViewById(R.id.imageView2);
imageView3 = (ImageView) findViewById(R.id.imageView3);</pre></div></li><li class="listitem">Beneath<a id="id66" class="indexterm"/> this, add <a id="id67" class="indexterm"/>the code for the <code class="literal">Button</code> control as follows:<div class="informalexample"><pre class="programlisting">button = (Button) findViewById(R.id.button);
button.setText("OK");
button.setOnClickListener(new View.OnClickListener() {

  @Override
  public void onClick(View v) {
    TransitionManager.beginDelayedTransition(viewGroup, new Explode());
    toggle(textView, imageView, imageView2, imageView3);
  }
});</pre></div></li><li class="listitem">Create a new method called <code class="literal">toggle()</code> and complete it like this:<div class="informalexample"><pre class="programlisting">private static void toggle(View... views) {
  for (View v : views) {
    boolean isVisible = v.getVisibility() == View.VISIBLE;
    v.setVisibility(isVisible ? View.INVISIBLE : View.VISIBLE);
  }
}</pre></div></li><li class="listitem">The app can now be tested on an emulator or a connected handset. Click on the run icon on the IDE toolbar:<div class="mediaobject"><img src="graphics/B04321_02_08.jpg" alt="Controlling the widget behavior with Java"/></div></li></ol></div><p>Although simple to follow, the code here covers some very important points. Firstly, there is <a id="id68" class="indexterm"/>the <code class="literal">onCreate()</code> method. This method is called as soon as the Activity is launched, usually with the <a id="id69" class="indexterm"/>application icon, and will form the start point of almost every Android app you will ever create. The first three lines, that were created for us, inflate our layout. We then used <code class="literal">findViewById()</code>, to associate our layout widgets with our Java instances.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Note that, for convenience, we used the names that the editor suggested here. In future, we will use the form <code class="literal">textView</code> to declare the Java instances and <code class="literal">text_view</code> for the XML counterparts.</p></div></div><p>We also changed the text inside two of our widgets using the <code class="literal">setText()</code> method. We could have done this from within the XML, but it is very useful to know how to do this dynamically with Java.</p><p>The <code class="literal">OnClickListener()</code> interface we attached to our button provides us with the <code class="literal">onClick()</code> method, giving us control over what actions are performed when our widgets are clicked on. There was only one button in this Activity, so we created an <code class="literal">OnClickListener()</code> specifically for it. Often, our apps will have more than one button or clickable control and, as we will see in the next chapter, we can have the Activity itself implement a click listener and then have one <code class="literal">onClick()</code> method to handle all our buttons.</p><p>The animation itself is configured and triggered with the <code class="literal">TransitionManager</code> class and we will return to this later in the book. For now, it is worth changing the term <code class="literal">Explode()</code> to <code class="literal">Fade()</code> or <code class="literal">Slide()</code>. The effect these changes have will not surprise you, but it is useful to know that they are available. Most of the time, when we apply animations to our apps, they <a id="id70" class="indexterm"/>are for the purpose of<a id="id71" class="indexterm"/> demonstrating transitions from one Activity to another, rather than being merely for decoration, as we did here.</p><p>Once you click on the run icon, the build process can be quite slow, particularly on older machines. There are, however, one or two handy tools that allow us to observe this process. Hover over the small icon in the lower left corner of the IDE and select <span class="strong"><strong>Gradle Console</strong></span>.</p><div class="mediaobject"><img src="graphics/B04321_02_09.jpg" alt="Controlling the widget behavior with Java"/></div><p>It is not necessary to understand the output of the Gradle console, but it is reassuring to see that the process has not ground to a halt on longer builds. Two other very useful windows that can be accessed in the same manner are the <span class="strong"><strong>Android</strong></span> and <span class="strong"><strong>Run</strong></span> windows. These can also be opened from the keyboard with <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>4</em></span> and <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>6</em></span> respectively.</p><p>If you have <a id="id72" class="indexterm"/>spent any time experimenting with the above app, you will have noticed that when the emulator or the device is <a id="id73" class="indexterm"/>rotated through 90 degrees, one or two things do not work as we might hope. Firstly, the animation resets whenever the device is rotated. This is because this, along with any other Activity, is reloaded whenever the the orientation changes and the <code class="literal">onCreate()</code> method is called afresh. There are, however, several other callback methods that allow us to intercept this process. We will be taking a closer look at the Activity life-cycle later on, but for now we will explore the second issue, which is the way the system positions our text and images in the landscape view.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>An AVD can be rotated through 90 degrees by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F12</em></span>. Pressing the home key returns the AVD to its home screen and <span class="emphasis"><em>Esc</em></span> is the same as pressing the device's back button.</p></div></div></div></div>
<div class="section" title="Creating alternative layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Creating alternative layouts</h1></div></div></div><p>When a device<a id="id74" class="indexterm"/> running one of our apps is rotated into landscape orientation, it refers to the same XML file as it does in portrait mode. Often this works perfectly well, but it is incredibly simple to set up an alternative layout that better suits the shape of a landscape screen. Follow these steps to create an alternative layout file for landscape viewing.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">activity_main.xml</code> file in <span class="strong"><strong>Design</strong></span> view.</li><li class="listitem">Click on the icon in the top-left and select <span class="strong"><strong>Create Landscape Variation</strong></span>.<div class="mediaobject"><img src="graphics/B04321_02_11.jpg" alt="Creating alternative layouts"/></div></li><li class="listitem">Drag and rearrange the onscreen widgets to form a more pleasing use of space.</li><li class="listitem">Select one of the <code class="literal">ImageView</code> controls. Then click on the amber quick-fix icon. It will inform you that the image is missing a <code class="literal">contentDescription</code>. Click on this message and complete the resultant dialog as below:<div class="mediaobject"><img src="graphics/B04321_02_12.jpg" alt="Creating alternative layouts"/></div></li><li class="listitem">Finally, run<a id="id75" class="indexterm"/> the app on a device or an emulator and check its behavior when rotated.<div class="mediaobject"><img src="graphics/B04321_02_13.jpg" alt="Creating alternative layouts"/></div></li></ol></div><p>Including a layout file for landscape orientation is as simple as placing a file with the same name and widget IDs in the <code class="literal">res/layout-land</code> directory instead of the <code class="literal">res/layout</code> directory. This file can then be edited in any way we like and will be automatically inflated whenever the screen is rotated to a landscape orientation.</p><p>As creating alternative layout files is such a quick and simple task, we also looked at how to provide alternative output for users with visual impairments in the form of content description for images. When a user with a visual impairment sets accessibility options and we have provided an appropriate text alternative, this description will be read out to the user. For the sake of brevity, we will not be adding this description for every exercise in this book, but it is recommended that such attributes are included in any apps intended<a id="id76" class="indexterm"/> for release.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>This concludes our introduction to the relationship between XML layouts and Java code. We have seen how to produce layouts for a wide variety of screen sizes and orientations and how to connect these XML definitions to a dynamic Java code that controls our app's behavior at runtime. Significantly, we have seen how the <code class="literal">onCreate()</code> method is used to set up our app and how it is called whenever a device is rotated. We took advantage of this fact by creating an alternative layout, designed specifically for a rotated screen.</p><p>In the next chapter, we will look at how to implement the two newest Android widgets, the <code class="literal">CardView</code>, which is a convenient and stylish container for whatever information we wish to display, and the <code class="literal">RecyclerView</code>, which manages the lists of <code class="literal">CardView</code> controls, or other views, in a memory efficient manner.</p></div></body></html>