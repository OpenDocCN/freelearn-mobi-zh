<html><head></head><body>
		<div id="_idContainer133">
			<h1 id="_idParaDest-279" class="chapter-number"><a id="_idTextAnchor463"/><st c="0">15</st></h1>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor464"/><st c="3">Exploring Architectures for iOS</st></h1>
			<p><st c="35">In the previous chapter, we discussed Swift Testing, an essential framework that helps us test our Swift code. </st><st c="147">App testing is not only a technical topic – it is also a culture. </st><st c="213">Part of this culture is looking at our project as a set of classes and a whole structure with a certain logic. </st><st c="324">That’s why testing and architecture go hand in hand – they both look at our project as a well-designed system. </st><st c="435">This holistic approach is essential to meet our product requirements </st><span class="No-Break"><st c="504">over time.</st></span></p>
			<p><st c="514">In this chapter, we will cover the </st><span class="No-Break"><st c="550">following topics:</st></span></p>
			<ul>
				<li><st c="567">Understanding the importance </st><span class="No-Break"><st c="597">of architecture</st></span></li>
				<li><st c="612">Learning what exactly </st><span class="No-Break"><st c="635">architecture is</st></span></li>
				<li><st c="650">Going over the different architectures, such as multi-layer, modular, </st><span class="No-Break"><st c="721">and hexagonal</st></span></li>
				<li><st c="734">Comparing the different architectures by separations, testing, </st><span class="No-Break"><st c="798">and maintenance</st></span></li>
			</ul>
			<p><st c="813">First, let’s understand why architecture is </st><span class="No-Break"><st c="858">so important.</st></span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor465"/><st c="871">Technical requirements</st></h1>
			<p><st c="894">You must download Xcode version 16.0 or above from Apple’s App Store for </st><span class="No-Break"><st c="968">this chapter.</st></span></p>
			<p><st c="981">You’ll also need to run the latest version of macOS (Ventura or above). </st><st c="1054">Search for Xcode in the App Store and select and download the latest version. </st><st c="1132">Launch Xcode and follow any additional installation instructions that your system may prompt you with. </st><st c="1235">Once Xcode has fully launched, you’re ready </st><span class="No-Break"><st c="1279">to go.</st></span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor466"/><st c="1285">Understanding the importance of architecture</st></h1>
			<p><st c="1330">To understand </st><a id="_idIndexMarker945"/><st c="1345">the importance of architecture, let’s try to understand how the iOS development knowledge </st><span class="No-Break"><st c="1435">is built.</st></span></p>
			<p><st c="1444">Many think that iOS development is centralized around Swift – if we know Swift, we know </st><span class="No-Break"><st c="1533">iOS development.</st></span></p>
			<p><st c="1549">Nonetheless, iOS development contains many knowledge levels, and the Swift language is only one </st><span class="No-Break"><st c="1646">of them.</st></span></p>
			<p><st c="1654">Let’s try to </st><a id="_idIndexMarker946"/><st c="1668">structure the iOS development to </st><span class="No-Break"><st c="1701">different levels:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="1718">IDE</st></strong><st c="1722">: Familiarity with Xcode, its debugging tools, configuration, simulator, builder, and code signing </st><span class="No-Break"><st c="1822">is crucial.</st></span></li>
				<li><strong class="bold"><st c="1833">Language</st></strong><st c="1842">: Whether it’s Swift, Objective C, or C++, language is a fundamental part of iOS development. </st><st c="1937">It’s the basis for daily implementing our app’s logic and </st><span class="No-Break"><st c="1995">design pattern.</st></span></li>
				<li><strong class="bold"><st c="2010">System</st></strong><st c="2017">: Understanding iOS’s unique characteristics, strengths, and limitations is key. </st><st c="2099">Ultimately, we are developing in a particular environment with its own rules </st><span class="No-Break"><st c="2176">and policies.</st></span></li>
				<li><strong class="bold"><st c="2189">SDK</st></strong><st c="2193">: The SDK provides the toolset to do whatever we want. </st><st c="2249">SwiftUI, UIKit, Foundation, Core Animation, and many other frameworks are part of the SDK, and with them, we can create beautiful screens with user input components and </st><span class="No-Break"><st c="2418">persistent storage.</st></span></li>
				<li><strong class="bold"><st c="2437">Design patterns</st></strong><st c="2453">: These are solutions to common problems and tasks we </st><span class="No-Break"><st c="2508">encounter daily.</st></span></li>
				<li><strong class="bold"><st c="2524">Architecture</st></strong><st c="2537">: The high-level organization of our code and project is called </st><span class="No-Break"><st c="2602">its architecture.</st></span></li>
			</ul>
			<p><st c="2619">We can continue with more knowledge levels – testing, databases, networking, security, and more. </st><st c="2717">The knowledge spectrum has become huge over the years, with more and more capabilities and </st><span class="No-Break"><st c="2808">knowledge required.</st></span></p>
			<p><st c="2827">Still, many iOS developers don’t focus on architecture when they build their apps, and there are some obvious reasons why. </st><st c="2951">For example, developers prefer to see immediate results. </st><st c="3008">Sometimes, it’s not only a matter of choice – there are deadlines to meet, and a lack of resources forces us to focus on releasing our features as quickly </st><span class="No-Break"><st c="3163">as possible.</st></span></p>
			<p><st c="3175">However, ignoring good architectural planning is usually a result of a lack of experience and short-term focus, which gives a clue about how important </st><span class="No-Break"><st c="3327">architecture is.</st></span></p>
			<p><st c="3343">Let’s list some of the influences</st><a id="_idIndexMarker947"/><st c="3377"> of good architecture on </st><span class="No-Break"><st c="3402">our project:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="3414">Maintainability</st></strong><st c="3430">: Our projects can easily become more extensive and challenging to maintain. </st><st c="3508">A good architecture makes our code base more straightforward to understand and read. </st><st c="3593">It also makes it easier to modify </st><span class="No-Break"><st c="3627">and refactor.</st></span></li>
				<li><strong class="bold"><st c="3640">Scalability</st></strong><st c="3652">: The ability to add more features while keeping our project simple and stable is a crucial key to app success. </st><st c="3765">A bad architecture can require a significant overhaul whenever we want to add </st><span class="No-Break"><st c="3843">new features.</st></span></li>
				<li><strong class="bold"><st c="3856">Flexibility</st></strong><st c="3868">: A good architecture allows us to quickly change how our app works according to changes in requirements. </st><st c="3975">It also helps us add new features or replace </st><span class="No-Break"><st c="4020">third-party frameworks.</st></span></li>
			</ul>
			<p><st c="4043">These are some benefits of good architecture, but the picture is clear – we will mainly discuss </st><strong class="bold"><st c="4140">long-term influence</st></strong><st c="4159">. Working </st><a id="_idIndexMarker948"/><st c="4169">hard to create more classes, layers, and protocols in the short term seems like a big hassle. </st><st c="4263">Besides coding, good architecture requires upfront efforts such as good planning, tech design, and a good understanding of paradigms </st><span class="No-Break"><st c="4396">and patterns.</st></span></p>
			<p><st c="4409">Before we discuss the different types of architecture, let’s define what architecture means and what defines </st><span class="No-Break"><st c="4519">good architecture.</st></span></p>
			<h1 id="_idParaDest-283"><st c="4537">Learning what exactly architecture</st><a id="_idTextAnchor467"/><a id="_idTextAnchor468"/><st c="4572"> is</st></h1>
			<p><st c="4575">Many developers </st><a id="_idIndexMarker949"/><st c="4592">are confused between architecture and what we call a “design patte</st><a id="_idTextAnchor469"/><a id="_idTextAnchor470"/><st c="4658">rn”. </st><st c="4664">We previously touched on that when we discussed the different layers of knowledge (under the </st><em class="italic"><st c="4757">Understanding the importance of architecture</st></em><st c="4801"> section), and even though it sounds like a semantic difference, it’s crucial to understand the distinction. </st><st c="4910">While architecture refers to the </st><em class="italic"><st c="4943">high-level organization</st></em><st c="4966"> of our app, such as layers, modules, and components, design patterns are </st><em class="italic"><st c="5040">reusable solutions to </st></em><span class="No-Break"><em class="italic"><st c="5062">common problems</st></em></span><span class="No-Break"><st c="5077">.</st></span></p>
			<p><st c="5078">To explain that better, let’s imagine a building. </st><st c="5129">When planning a private house, we must decide its number of floors, entrance, roof, and garage In short, this is the </st><span class="No-Break"><st c="5246">house’s architecture.</st></span></p>
			<p><st c="5267">In contrast, each floor </st><a id="_idIndexMarker950"/><st c="5292">has its own goal and designation. </st><st c="5326">For example, one floor can be the kitchen and living room, and the second would be the bedrooms. </st><st c="5423">To accomplish that, we need to plan the internal design for each floor, deciding the sizes of the rooms, the door locations, and the different wires and water pipes. </st><st c="5589">In most cases, there are no tricks here – there are standards to follow. </st><st c="5662">These internal designs of the floors can be considered as design patterns – a reusable, specific solution to </st><span class="No-Break"><st c="5771">common problems.</st></span></p>
			<p><st c="5787">Now, let’s go back to our mobile app. </st><st c="5826">We should think of a mobile app’s structure as a private house. </st><st c="5890">The data flows in different layers – data, business logic, and </st><strong class="bold"><st c="5953">User Interface</st></strong><st c="5967"> (</st><strong class="bold"><st c="5969">UI</st></strong><st c="5971">). </st><st c="5975">We </st><a id="_idIndexMarker951"/><st c="5978">can look at each layer as a different floor in our home. </st><st c="6035">In each layer (or floor), we can use various design patterns to solve other problems. </st><st c="6121">For example, we can use Singleton to manage shared resources or a coordinator to simplify complex </st><span class="No-Break"><st c="6219">navigation needs.</st></span></p>
			<p><st c="6236">The more design patterns we know, the more solutions </st><span class="No-Break"><st c="6290">we have.</st></span></p>
			<p><st c="6298">Moreover, let’s continue with the house metaphor. </st><st c="6349">In that case, we can come to another conclusion – our choice regarding architecture affects the different design patterns we use for our floors, including the floors’ sizes and shapes, or even how they </st><span class="No-Break"><st c="6551">are connected.</st></span></p>
			<p><st c="6565">So, what are the different types of architecture available, and how do we select an architecture that fits </st><span class="No-Break"><st c="6673">our needs?</st></span></p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor471"/><st c="6683">Going over the different architectures</st></h1>
			<p><st c="6722">Developers make two common mistakes when choosing their project architecture. </st><st c="6801">First, they often say, “</st><em class="italic"><st c="6825">What architecture am I using for my app? </st><st c="6867">MVVM, </st></em><span class="No-Break"><em class="italic"><st c="6873">of course</st></em></span><span class="No-Break"><st c="6882">!”</st></span></p>
			<p><st c="6884">MVVM is not an architecture – it’s a design pattern that aims to solve state and logic management for a particular screen. </st><st c="7008">Not only does it not handle the app structure but it also doesn’t even describe how we handle our screens in general. </st><st c="7126">It only describes a particular screen, such as a login or a </st><span class="No-Break"><st c="7186">settings s</st><a id="_idTextAnchor472"/><a id="_idTextAnchor473"/><st c="7196">creen.</st></span></p>
			<p><st c="7203">The second mistake is the idea that we can only choose one of the most common and popular architectures from the list for our project. </st><st c="7339">Most of the architectures you read about are, in fact, a set of principles that can help us decide how to structure </st><span class="No-Break"><st c="7455">our project.</st></span></p>
			<p><st c="7467">Some principles provide flexibility and decoupling, and some may increase project overhead. </st><st c="7560">We should always consider tradeoffs; these become even more important in </st><span class="No-Break"><st c="7633">architectural designs.</st></span></p>
			<p><st c="7655">Let’s start with the most fundamental architectural idea: the </st><span class="No-Break"><st c="7718">multi-layer architecture.</st></span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor474"/><st c="7743">Separating our project into layers</st></h2>
			<p><st c="7778">It’s </st><a id="_idIndexMarker952"/><st c="7784">worthwhile to </st><a id="_idIndexMarker953"/><st c="7798">take a moment and discuss two important terms I’m using here. </st><st c="7860">The first is a </st><em class="italic"><st c="7875">project</st></em><st c="7882"> and not an </st><em class="italic"><st c="7894">app</st></em><st c="7897">. The reason for that is that our architectural decisions are related to the whole project – pods, Swift packages, extensions, or even other apps. </st><st c="8044">When we talk about structures, an app is only the expression of our product and how we </st><span class="No-Break"><st c="8131">deploy it.</st></span></p>
			<p><st c="8141">The second term is using </st><em class="italic"><st c="8167">layers</st></em><st c="8173"> instead of </st><em class="italic"><st c="8185">tiers</st></em><st c="8190"> – a typical mistake developers make. </st><st c="8228">When discussing separating a system into tiers, we often refer to hardware separation – different computers, servers, routers, or other hardware components. </st><st c="8385">We should use the term </st><em class="italic"><st c="8408">layers</st></em><st c="8414"> when discussing separating software such as an app </st><span class="No-Break"><st c="8466">or SDK.</st></span></p>
			<p><st c="8473">Separating a project into layers, usually three, is a common architectural decision in many projects. </st><st c="8576">The idea is that a basic project has at least three different levels of data and logic handling (</st><span class="No-Break"><em class="italic"><st c="8673">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="8683">.1</st></em></span><span class="No-Break"><st c="8685">):</st></span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B21795_15_1.jpg" alt="Figure 15.1: The three-layer architecture"/><st c="8688"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="8745">Figure 15.1: The three-layer architecture</st></p>
			<p><span class="No-Break"><em class="italic"><st c="8786">Figure 15</st></em></span><em class="italic"><st c="8796">.1</st></em><st c="8798"> shows</st><a id="_idIndexMarker954"/><st c="8804"> the three layers that we usually separate our </st><span class="No-Break"><st c="8851">app into.</st></span></p>
			<p><st c="8860">Let’s try to understand </st><span class="No-Break"><st c="8885">these layers:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="8898">Data</st></strong><st c="8903"> can </st><a id="_idIndexMarker955"/><st c="8908">sometimes be called </st><strong class="bold"><st c="8928">services</st></strong><st c="8936">. The Data layer handles the data persistent store, the model entities, network handling, and primarily services that handle data at a low level regardless of the </st><span class="No-Break"><st c="9099">project logic.</st></span></li>
				<li><strong class="bold"><st c="9113">Business logic</st></strong><st c="9128"> can </st><a id="_idIndexMarker956"/><st c="9133">sometimes be called </st><strong class="bold"><st c="9153">domain</st></strong><st c="9159">. The Business Logic layer handles the app’s main logic, including rules and </st><span class="No-Break"><st c="9236">data manipulations.</st></span></li>
				<li><strong class="bold"><st c="9255">Presentation</st></strong><st c="9268"> handles </st><a id="_idIndexMarker957"/><st c="9277">the UI, user interaction, </st><span class="No-Break"><st c="9303">and navigation.</st></span></li>
			</ul>
			<p><st c="9318">There are patterns that have even more layers – for example, an </st><em class="italic"><st c="9383">application</st></em><st c="9394"> layer, which handles the different use cases and can be placed under the presentation layer, or an </st><em class="italic"><st c="9494">infrastructure</st></em><st c="9508"> layer that handles class extensions, utils, </st><span class="No-Break"><st c="9553">and more.</st></span></p>
			<p><st c="9562">If you are an experienced developer, the idea of separating a project should be obvious. </st><st c="9652">Separating code creates a testable and maintainable structure that can be scaled over time. </st><st c="9744">However, the idea of working with layers is not </st><span class="No-Break"><st c="9792">always evident.</st></span></p>
			<p><st c="9807">Ultimately, it comes down to how the data flows around </st><span class="No-Break"><st c="9863">the app.</st></span></p>
			<h3><st c="9871">Controlling the app data flow</st></h3>
			<p><st c="9901">Data flow is a</st><a id="_idIndexMarker958"/><st c="9916"> central topic in any program. </st><st c="9947">To clarify that term, we must examine how messages and data flow between the different app components. </st><st c="10050">For example, when a user taps the </st><strong class="bold"><st c="10084">Save</st></strong><st c="10088"> button on one of their screens, we need to transform that tap into an actual logic</st><a id="_idIndexMarker959"/><st c="10171"> decision and continue that to the persistent store, where we can save that information locally. </st><st c="10268">The data flow doesn’t end here – at this point, we need to send a message back to the UI that a change has been made in the persistent store, and we should update what’s on </st><span class="No-Break"><st c="10441">the screen.</st></span></p>
			<p><st c="10452">This example demonstrates only a single use case. </st><st c="10503">A standard mobile app may have hundreds of such cases, emphasizing the importance of considering how to divide </st><span class="No-Break"><st c="10614">our project.</st></span></p>
			<p><st c="10626">Now that we understand data flow, let’s discuss the </st><strong class="bold"><st c="10679">open</st></strong><st c="10683"> and </st><strong class="bold"><st c="10688">closed</st></strong><st c="10694"> layers. </st><st c="10703">In a three-layer architecture, as described in </st><span class="No-Break"><em class="italic"><st c="10750">Figure 15</st></em></span><em class="italic"><st c="10759">.1</st></em><st c="10761">, the presentation layer communicates with the business logic layer. </st><st c="10830">However, does that mean that the presentation layer is also allowed to communicate with the </st><span class="No-Break"><st c="10922">data layer?</st></span></p>
			<p><st c="10933">For example, the presentation may receive updates about data changes directly from the data layer. </st><st c="11033">Working with business logic as middleware can be more complex and cumbersome in these cases. </st><st c="11126">At that point, we must decide whether our layers are open </st><span class="No-Break"><st c="11184">or closed.</st></span></p>
			<p><st c="11194">An open layer allows </st><a id="_idIndexMarker960"/><st c="11216">direct interaction between the layer above and underneath. </st><st c="11275">While open layers provide higher flexibility and simplicity, they can also increase coupling and reduce the separation </st><span class="No-Break"><st c="11394">of concerns.</st></span></p>
			<p><st c="11406">A</st><a id="_idIndexMarker961"/><st c="11408"> closed layer enforces strict interaction, and each communication between its adjacent layers must go through the closed layer itself. </st><st c="11543">A closed layer can increase the separation of concerns and loosen the coupling while decreasing flexibility and </st><span class="No-Break"><st c="11655">increasing complexity.</st></span></p>
			<p><st c="11677">Discussing closed and opened layers might sound a little weird when working with three-layer architecture. </st><st c="11785">The middle layer (business logic) is the only layer that can be either open or closed. </st><st c="11872">However, we can decide whether the layer is strictly or </st><span class="No-Break"><st c="11928">selectively closed.</st></span></p>
			<p><st c="11947">Each layer is built</st><a id="_idIndexMarker962"/><st c="11967"> from a set of components. </st><st c="11994">For example, the presentation layer can be built from the different app screens or flows. </st><st c="12084">The business logic layer can be built from the different logic parts of the app, and the data layer is built from the different services such as network, data, </st><span class="No-Break"><st c="12244">and security.</st></span></p>
			<p><st c="12257">In some situations, components from the presentation layer must communicate directly with the </st><span class="No-Break"><st c="12352">data layer.</st></span></p>
			<p><st c="12363">Look at </st><span class="No-Break"><em class="italic"><st c="12372">Figure 15</st></em></span><em class="italic"><st c="12381">.2</st></em><st c="12383">, which </st><a id="_idIndexMarker963"/><st c="12391">shows the basic three-layer architecture of a </st><span class="No-Break"><st c="12437">messaging app:</st></span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B21795_15_2.jpg" alt="Figure 15.2: Selective closed layer"/><st c="12451"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12593">Figure 15.2: Selective closed layer</st></p>
			<p><span class="No-Break"><em class="italic"><st c="12628">Figure 15</st></em></span><em class="italic"><st c="12638">.2</st></em><st c="12640"> shows the same three layers we discussed earlier – presentation, business logic, and data. </st><st c="12732">However, this time, we break the layer into different components. </st><st c="12798">In addition, we display the various communication paths between the multiple components. </st><st c="12887">For example, the login UI component communicates with the onboarding logic part of the app, and the messaging logic part communicates with the data and security components. </st><st c="13060">Even though most communication goes through the business logic layer, we see some exceptions. </st><st c="13154">For example, the following exceptions </st><span class="No-Break"><st c="13192">might apply:</st></span></p>
			<ul>
				<li><st c="13204">The Login UI component approaches the Security component directly, probably to understand the current </st><span class="No-Break"><st c="13307">authentication status</st></span></li>
				<li><st c="13328">The Thread UI component communicates with the Network components to present the network status in </st><span class="No-Break"><st c="13427">the UI</st></span></li>
			</ul>
			<p><st c="13433">We can scratch</st><a id="_idIndexMarker964"/><st c="13448"> our heads to find a way for these cases to go through the business logic layer; however, bypassing it and going directly to the data layer is perfectly acceptable in </st><span class="No-Break"><st c="13615">some cases.</st></span></p>
			<p><st c="13626">The architecture we selected serves our project needs rather than vice versa. </st><st c="13705">Yet we need to define a policy of bypassing the business logic layer since each exception, including those described in </st><span class="No-Break"><em class="italic"><st c="13825">Figure 15</st></em></span><em class="italic"><st c="13834">.2</st></em><st c="13836">, creates another coupling in </st><span class="No-Break"><st c="13866">our structure.</st></span></p>
			<p><st c="13880">We discussed the three layers of architecture, but is it always three? </st><st c="13952">Do we have more layers? </st><st c="13976">Let’s find out whether creating a more complex yet useful architecture </st><span class="No-Break"><st c="14047">is possible.</st></span></p>
			<h3><st c="14059">Adding more layers</st></h3>
			<p><st c="14078">Working with</st><a id="_idIndexMarker965"/><st c="14091"> three layers is the sweet spot between simplicity and good separations. </st><st c="14164">However, sometimes, the principle of separation of concerns still needs to be fulfilled in big projects. </st><st c="14269">Even though it looks very straightforward to have one layer for the presentation and another one for the business logic, there are some dilemmas that </st><span class="No-Break"><st c="14419">need clarification.</st></span></p>
			<p><st c="14438">Let’s take, for example, two different components we may have in an iOS app – a user service and a payment service. </st><st c="14555">Both are part of the app’s business logic. </st><st c="14598">When the user wants to make a purchase, we want to check their role using the user service and then go to the payment service to make the purchase. </st><st c="14746">Right after the purchase, we want to navigate the user to a screen and show them that the payment was successful. </st><st c="14860">So, we can see that we have a use case that involves incorporating different business logic services and coordinating different screens (</st><span class="No-Break"><em class="italic"><st c="14997">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="15007">.3</st></em></span><span class="No-Break"><st c="15009">):</st></span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B21795_15_3.jpg" alt="Figure 15.3: The payment use case, combining multiple components and layers"/><st c="15012"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15109">Figure 15.3: The payment use case, combining multiple components and layers</st></p>
			<p><st c="15184">Do we need </st><a id="_idIndexMarker966"/><st c="15196">to manage that use case in the presentation logic, in the business logic, or half here and half there? </st><st c="15299">Well, chances are that this logic is spread across components or centralized in one of the screen view models. </st><st c="15410">Remember that a view model handles UI states rather than app logic in </st><span class="No-Break"><st c="15480">most cases.</st></span></p>
			<p><st c="15491">The problem of handling use cases bundled with navigation is not new, and in apps that are more complex and require more flexibility, this needs to be taken into account when designing our </st><span class="No-Break"><st c="15681">app structure.</st></span></p>
			<p><st c="15695">So, to separate our concerns, we can add another layer – the </st><strong class="bold"><st c="15757">Application</st></strong><st c="15768"> layer, which can handle a specific app use case (</st><span class="No-Break"><em class="italic"><st c="15818">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="15828">.4</st></em></span><span class="No-Break"><st c="15830">):</st></span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B21795_15_4.jpg" alt="Figure 15.4: A four-layer architecture"/><st c="15833"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="16035">Figure 15.4: A four-layer architecture</st></p>
			<p><span class="No-Break"><em class="italic"><st c="16073">Figure 15</st></em></span><em class="italic"><st c="16083">.4</st></em><st c="16085"> shows an</st><a id="_idIndexMarker967"/><st c="16094"> architecture design similar to </st><span class="No-Break"><em class="italic"><st c="16126">Figure 15</st></em></span><em class="italic"><st c="16135">.2</st></em><st c="16137">, this time with the Application layer. </st><st c="16177">The Application layer has four use cases: Sign In, </st><strong class="bold"><st c="16228">Create Contact</st></strong><st c="16242">, </st><strong class="bold"><st c="16244">Delete Contact</st></strong><st c="16258">, and </st><strong class="bold"><st c="16264">Create group chat</st></strong><st c="16281">. These use cases handle everything from calling functions in other components to navigation. </st><st c="16375">The Application layer makes the business and presentation layers cleaner from specific </st><span class="No-Break"><st c="16462">app logic.</st></span></p>
			<p><st c="16472">Do we have more layers we </st><span class="No-Break"><st c="16499">can add?</st></span></p>
			<p><st c="16507">The Application layer coordinates multiple components to create an app-specific logic. </st><st c="16595">We can implement the same concept on the bottom side of the architecture, between the business logic and the </st><span class="No-Break"><st c="16704">data layer.</st></span></p>
			<p><st c="16715">For example, let’s discuss a data sync process. </st><st c="16764">Retrieving data from the network and storing it in the persistent store is a complex process that involves error handling and handling various edge cases. </st><st c="16919">Is it part of the business logic or the </st><span class="No-Break"><st c="16959">data layer?</st></span></p>
			<p><st c="16970">Data manipulation</st><a id="_idIndexMarker968"/><st c="16988"> and </st><strong class="bold"><st c="16993">Create, Read, Update, and Delete</st></strong><st c="17025"> (</st><strong class="bold"><st c="17027">CRUD</st></strong><st c="17031">) operations are also tasks that are unclear on which layer </st><span class="No-Break"><st c="17092">handles them.</st></span></p>
			<p><st c="17105">So, to handle tasks that are not business logic but focus on accessing and managing data from various sources, we can add </st><a id="_idIndexMarker969"/><st c="17228">another layer called the </st><strong class="bold"><st c="17253">Data Access layer</st></strong><st c="17270"> (</st><span class="No-Break"><em class="italic"><st c="17272">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="17281">.5</st></em></span><span class="No-Break"><st c="17283">):</st></span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B21795_15_5.jpg" alt="Figure 15.5: Data Access layer"/><st c="17286"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17529">Figure 15.5: Data Access layer</st></p>
			<p><span class="No-Break"><em class="italic"><st c="17559">Figure 15</st></em></span><em class="italic"><st c="17569">.5</st></em><st c="17571"> shows our </st><a id="_idIndexMarker970"/><st c="17582">architecture from </st><span class="No-Break"><em class="italic"><st c="17600">Figure 15</st></em></span><em class="italic"><st c="17609">.4</st></em><st c="17611">, now with an additional layer – the Data Access layer, which handles sync service, CRUD operations, and data mapping, transforming data model objects into business </st><span class="No-Break"><st c="17776">logic entities.</st></span></p>
			<p><st c="17791">Having more than three layers may sound too complex and imply over-engineering. </st><st c="17872">However, this strategy ensures excellent separation of concerns between the different layers. </st><st c="17966">The business logic doesn’t involve data manipulation, and the presentation layer doesn’t handle complex use cases. </st><st c="18081">In medium and large apps, separating our project into four or five layers can pay off when our app </st><span class="No-Break"><st c="18180">gets bigger.</st></span></p>
			<p><st c="18192">Separating into different layers is only one perspective we can consider in our project. </st><st c="18282">I mentioned earlier that architectural patterns such as this act more like principles. </st><st c="18369">The real power comes when we combine different patterns. </st><st c="18426">Let’s explore the modular </st><span class="No-Break"><st c="18452">architectural pattern.</st></span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor475"/><st c="18474">Separating our project into modules</st></h2>
			<p><st c="18510">I mentioned that</st><a id="_idIndexMarker971"/><st c="18527"> separating into layers is only one perspective we can look at in our project. </st><st c="18606">However, what does </st><span class="No-Break"><st c="18625">it mean?</st></span></p>
			<p><st c="18633">Let’s take our messaging app as an example. </st><st c="18678">The different layers represent different concerns: presentation, business logic, and data. </st><st c="18769">Our app data flows through the layers from the UI to the data </st><span class="No-Break"><st c="18831">and back.</st></span></p>
			<p><st c="18840">Another way to look at our app is through code units that encapsulate a set of functionalities or a </st><a id="_idIndexMarker972"/><st c="18941">specific business domain unit. </st><st c="18972">We can call these code </st><span class="No-Break"><st c="18995">units </st></span><span class="No-Break"><strong class="bold"><st c="19001">modules</st></strong></span><span class="No-Break"><st c="19008">.</st></span></p>
			<h3><st c="19009">Understanding the different considerations when working on modules</st></h3>
			<p><st c="19076">Separating our</st><a id="_idIndexMarker973"/><st c="19091"> project into modules requires careful consideration, as this step is crucial for the app’s structure over time. </st><st c="19204">In a messaging app, for example, the modules can be a user authentication module, user profile module, contacts module, and messaging module. </st><st c="19346">These modules reflect the app’s different domains and the decision to divide our app is </st><span class="No-Break"><st c="19434">very flexible.</st></span></p>
			<p><st c="19448">However, some key factors can help </st><span class="No-Break"><st c="19484">us decide:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="19494">Functionality and business domain</st></strong><st c="19528">: We already mentioned this in the previous paragraph. </st><st c="19584">Breaking down the app into core features can be an excellent start to understanding our project’s different modules – logic, song player, reminders, onboarding, </st><span class="No-Break"><st c="19745">and more.</st></span></li>
				<li><strong class="bold"><st c="19754">Reusability</st></strong><st c="19766">: Grouping functionalities we use across different parts of the app is another way of understanding how to create a module. </st><st c="19891">For example, if our app performs different HTTP requests, we may create a network module to manage all the API calls. </st><st c="20009">Another example can be shared components – if we use the same button on different screens, that can be a sign that it should be part of a UI module that contains different </st><span class="No-Break"><st c="20181">reusable components.</st></span></li>
				<li><strong class="bold"><st c="20201">Decoupling</st></strong><st c="20212">: Our module should be decoupled from the other modules as much as possible. </st><st c="20290">The level of interdependence the module has can define whether it was an excellent call to create it as a module. </st><st c="20404">In addition, if it’s possible to make a clear interface for the module, that’s another indication it can be a </st><span class="No-Break"><st c="20514">good module.</st></span></li>
				<li><strong class="bold"><st c="20526">Collaboration</st></strong><st c="20540">: Imagine that </st><a id="_idIndexMarker974"/><st c="20556">several teams are working on our project. </st><st c="20598">The fact that they can work without stepping on each other’s toes signals good module separation. </st><st c="20696">Note that the relevance of this rule remains the same, whether we are a team of one person or five teams with six developers each. </st><st c="20827">The principle is </st><span class="No-Break"><st c="20844">what counts.</st></span></li>
			</ul>
			<p><st c="20856">We must ask ourselves: can we create another app and use some of our modules in the new app, like using Lego bricks? </st><st c="20974">Can we test each module separately? </st><st c="21010">These questions give some sense of whether our modules are indeed independent or have </st><span class="No-Break"><st c="21096">tight coupling.</st></span></p>
			<h3><st c="21111">Organizing the code in our project</st></h3>
			<p><st c="21146">A few words </st><a id="_idIndexMarker975"/><st c="21159">about organizing our code into modules – modules are an abstract definition, as there’s no official way of technically separating our code into modules. </st><st c="21312">However, we can distinguish between two approaches – </st><strong class="bold"><st c="21365">physical</st></strong> <span class="No-Break"><st c="21373">and </st></span><span class="No-Break"><strong class="bold"><st c="21378">functional</st></strong></span><span class="No-Break"><st c="21388">:</st></span></p>
			<ul>
				<li><st c="21390">In the physical approach, we create our modules using a dedicated tool. </st><st c="21462">CocoaPods, Swift Packages, and XCFrameworks, for example, provide a way of physically encapsulating our code into </st><span class="No-Break"><st c="21576">code units.</st></span></li>
				<li><st c="21587">In the functional approach, we do not use any specific tool but instead organize the code into folders. </st><st c="21692">This simple approach is great for small projects </st><span class="No-Break"><st c="21741">or teams.</st></span></li>
			</ul>
			<p><st c="21750">The primary consideration here is obvious: reusability and independence in the physical approach versus simplicity and flexibility in the functional approach. </st><st c="21910">However, let’s delve deeper and make this comparison more practical and relevant to our day-to-day work as </st><span class="No-Break"><st c="22017">iOS developers.</st></span></p>
			<p><st c="22032">Creating a new project and understanding the different modules can be quite challenging. </st><st c="22122">On the one hand, good planning is crucial for the success of our project development over time. </st><st c="22218">On the other hand, it’s impossible to predict how our project will evolve over the years. </st><st c="22308">So, what we need at the beginning is flexibility. </st><st c="22358">Therefore, starting with a functional approach, which involves creating modules by folders, might be the right approach for </st><span class="No-Break"><st c="22482">most projects.</st></span></p>
			<p><st c="22496">As the project grows, the advantage of having flexibility in our modules can become its downfall. </st><st c="22595">One of the great things about the physical approach is that we create clear boundaries </st><a id="_idIndexMarker976"/><st c="22682">between our modules by encapsulating our code into pods or packages. </st><st c="22751">These boundaries prevent us from including external classes and types without handling the different dependencies correctly. </st><st c="22876">They also force us to declare a clear interface for the module, as private and internal functions and classes are inaccessible from the outside. </st><st c="23021">These restrictions are essential and valuable as the project evolves and the development team grows. </st><st c="23122">The different pods or packages allow other teams to work on each module and build and test it separately. </st><st c="23228">It even lets us share the same module between </st><span class="No-Break"><st c="23274">various projects.</st></span></p>
			<p><st c="23291">So, now that we are convinced that modules are important, how does the idea of layers fit in? </st><st c="23386">Do we have to choose between layers and modules? </st><st c="23435">Or is it the </st><span class="No-Break"><st c="23448">same thing?</st></span></p>
			<p><st c="23459">Let’s try to put things </st><span class="No-Break"><st c="23484">in order.</st></span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor476"/><st c="23493">Combining the multi-layer architecture with modules</st></h2>
			<p><st c="23545">We previously</st><a id="_idIndexMarker977"/><st c="23559"> said that multi-layers and modules are more like architectural patterns or concepts. </st><st c="23645">They are the guidelines for structuring our app and it is common practice to combine different concepts and patterns in our projects rather than stick with only </st><span class="No-Break"><st c="23806">one pattern.</st></span></p>
			<p><st c="23818">Let’s take the app onboarding module, for example (</st><span class="No-Break"><em class="italic"><st c="23870">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="23880">.6</st></em></span><span class="No-Break"><st c="23882">):</st></span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B21795_15_6.jpg" alt="Figure 15.6: The onboarding module"/><st c="23885"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24104">Figure 15.6: The onboarding module</st></p>
			<p><span class="No-Break"><em class="italic"><st c="24138">Figure 15</st></em></span><em class="italic"><st c="24148">.6</st></em><st c="24150"> shows the onboarding module structure divided into four different layers. </st><st c="24225">One way to combine modular and multi-layer architectures is to create a matrix structure separating each module into different layers. </st><st c="24360">In this case, the onboarding module has a presentation, coordinator, business logic, </st><span class="No-Break"><st c="24445">and data.</st></span></p>
			<p><st c="24454">The other </st><a id="_idIndexMarker978"/><st c="24465">case involves layers built from several modules. </st><st c="24514">In this case, each layer is a business unit built from </st><span class="No-Break"><st c="24569">several modules.</st></span></p>
			<p><st c="24585">Let’s compare </st><span class="No-Break"><st c="24600">both architectures:</st></span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B21795_15_7.jpg" alt="Figure 15.7: Comparing the two approaches of combining modules and layers"/><st c="24619"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24863">Figure 15.7: Comparing the two approaches of combining modules and layers</st></p>
			<p><span class="No-Break"><em class="italic"><st c="24936">Figure 15</st></em></span><em class="italic"><st c="24946">.7</st></em><st c="24948"> shows the two approaches we discussed side by side. </st><st c="25001">At first glance, these two approaches look similar, just from different points of view. </st><st c="25089">However, they represent two different project requirements and dramatically influence scalability, independence, </st><span class="No-Break"><st c="25202">and coupling.</st></span></p>
			<p><st c="25215">Let’s take, for example, the data modules. </st><st c="25259">On the right side (</st><strong class="bold"><st c="25278">Modules comprising multiple layers</st></strong><st c="25313">), we can see that each module has its data module. </st><st c="25366">However, on the left side (</st><strong class="bold"><st c="25393">Layers built from multiple modules</st></strong><st c="25428">), we have one data module that can serve various screens and business units. </st><st c="25507">The same goes for more data layer modules such as analytics, network, </st><span class="No-Break"><st c="25577">and security.</st></span></p>
			<p><st c="25590">When we consider it, for a module to be truly independent, it needs to contain all the layers and services. </st><st c="25699">This also means that we’ll have to duplicate some of the code in </st><span class="No-Break"><st c="25764">some cases.</st></span></p>
			<p><st c="25775">As always, we have a tradeoff between encapsulation and independence versus centralized logic and consistency. </st><st c="25887">Therefore, in practice, we must balance that, create a hybrid approach, and combine elements of both methods (</st><span class="No-Break"><em class="italic"><st c="25997">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="26007">.8</st></em></span><span class="No-Break"><st c="26009">):</st></span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B21795_15_8.jpg" alt="Figure 15.8: Combining layers built from modules and modules comprising multiple layers"/><st c="26012"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26234">Figure 15.8: Combining layers built from modules and modules comprising multiple layers</st></p>
			<p><span class="No-Break"><em class="italic"><st c="26321">Figure 15</st></em></span><em class="italic"><st c="26331">.8</st></em><st c="26333"> presents the hybrid approach we discussed. </st><st c="26377">Notice that we have several modules – </st><strong class="bold"><st c="26415">User</st></strong><st c="26419">, </st><strong class="bold"><st c="26421">Messages</st></strong><st c="26429">, and </st><strong class="bold"><st c="26435">Notifications</st></strong><st c="26448"> – each containing screens and business logic. </st><st c="26495">However, the data, network, and analytics services are shared across the </st><span class="No-Break"><st c="26568">different modules.</st></span></p>
			<p><st c="26586">The hybrid </st><a id="_idIndexMarker979"/><st c="26598">approach means that the different modules are only partially independent. </st><st c="26672">On the other hand, it expresses a nice balance between reusability </st><span class="No-Break"><st c="26739">and encapsulation.</st></span></p>
			<p><st c="26757">We can take it even further and share more logic, utilities, and </st><span class="No-Break"><st c="26823">UI components.</st></span></p>
			<p><st c="26837">The multi-layer and module architectures are straightforward for most developers. </st><st c="26920">They represent a logical way of examining apps and projects – either by levels of concerns, domains, </st><span class="No-Break"><st c="27021">or both.</st></span></p>
			<p><st c="27029">Can we take a different approach to architecture? </st><st c="27080">Let’s try looking at our app differently – using </st><span class="No-Break"><strong class="bold"><st c="27129">hexagonal architecture</st></strong></span><span class="No-Break"><st c="27151">.</st></span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor477"/><st c="27152">Building hexagonal architecture</st></h2>
			<p><st c="27184">Multi-layer </st><a id="_idIndexMarker980"/><st c="27197">architecture describes an app as data flowing through different layers of concerns. </st><st c="27281">The module architecture describes the app as different modules communicating with </st><span class="No-Break"><st c="27363">each other.</st></span></p>
			<p><st c="27374">To go over an architecture with a different approach, we discuss the meaning of an app. </st><st c="27463">What is an app? </st><st c="27479">Is it the screens? </st><st c="27498">Is it </st><span class="No-Break"><st c="27504">the logic?</st></span></p>
			<p><st c="27514">In hexagonal architecture, we </st><a id="_idIndexMarker981"/><st c="27545">consider the business logic to be the heart and soul of the app. </st><st c="27610">Let’s take our messaging app example. </st><st c="27648">The app’s core is the messaging logic, the way we authenticate, and the different data models. </st><st c="27743">We call that </st><a id="_idIndexMarker982"/><st c="27756">part of the business logic the </st><span class="No-Break"><strong class="bold"><st c="27787">domain model</st></strong></span><span class="No-Break"><st c="27799">.</st></span></p>
			<p><st c="27800">And what about the different screens, core data, and network layers? </st><st c="27870">In the hexagonal architecture, these app parts are not at the core. </st><st c="27938">The UI screens seem like the domain model’s clients, and the network and core data parts provide services to the </st><span class="No-Break"><st c="28051">domain layer.</st></span></p>
			<p><st c="28064">Look at </st><span class="No-Break"><em class="italic"><st c="28073">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="28082">.9</st></em></span><span class="No-Break"><st c="28084">:</st></span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B21795_15_9.jpg" alt="Figure 15.9: The domain model and its clients and services"/><st c="28086"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28178">Figure 15.9: The domain model and its clients and services</st></p>
			<p><span class="No-Break"><em class="italic"><st c="28236">Figure 15</st></em></span><em class="italic"><st c="28246">.9</st></em><st c="28248"> shows the domain model at the center while its clients and services </st><span class="No-Break"><st c="28317">surround it.</st></span></p>
			<p><st c="28329">Our next concept related to the hexagonal architecture is how the different actors connect to the domain model. </st><st c="28442">These actors connect using ports </st><span class="No-Break"><st c="28475">and adapters.</st></span></p>
			<h3><st c="28488">Learning the concept of ports and adapters</st></h3>
			<p><st c="28531">Think of our </st><a id="_idIndexMarker983"/><st c="28545">app </st><a id="_idIndexMarker984"/><st c="28549">as a computer system. </st><st c="28571">The computer has its motherboard, CPU, GPU, and memory. </st><st c="28627">We can connect external input peripherals such as a keyboard, a mouse, or a trackpad. </st><st c="28713">We can also connect output devices such as a display, a speaker, or </st><span class="No-Break"><st c="28781">a printer.</st></span></p>
			<p><st c="28791">We know </st><a id="_idIndexMarker985"/><st c="28800">how</st><a id="_idIndexMarker986"/><st c="28803"> computers are built – if we need to point out what is considered to be the heart of the computer, it wouldn’t be the printer or the displayer, but rather its motherboard and CPU. </st><st c="28983">However, can we connect any device we want to </st><span class="No-Break"><st c="29029">the computer?</st></span></p>
			<p><st c="29042">To do that, we need </st><span class="No-Break"><st c="29063">two things:</st></span></p>
			<ul>
				<li><st c="29074">A port on the computer that allows us to connect devices; for example, UBC </st><span class="No-Break"><st c="29150">or HDMI</st></span></li>
				<li><st c="29157">A driver installed on the device that knows how to work with the port and the interface the </st><span class="No-Break"><st c="29250">computer requires</st></span></li>
			</ul>
			<p><st c="29267">Each keyboard, printer, or mouse has a plug that fits the computer port and a driver that implements some protocol that allows this device to communicate with the computer. </st><st c="29441">In general, we can connect any device we want as long as it conforms to the protocol the </st><span class="No-Break"><st c="29530">computer demands.</st></span></p>
			<p><st c="29547">When we return to the hexagonal architecture, we can consider the domain model as the computer itself and the network or the UI as the printer and keyboard. </st><st c="29705">In addition, we have two more terms – port </st><span class="No-Break"><st c="29748">and adapter:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="29760">Port</st></strong><st c="29765">: This is</st><a id="_idIndexMarker987"/><st c="29775"> an entry or exit point to/from the domain. </st><st c="29819">In Swift, we use protocols to describe </st><span class="No-Break"><st c="29858">a port.</st></span></li>
				<li><strong class="bold"><st c="29865">Adapter</st></strong><st c="29873">: When</st><a id="_idIndexMarker988"/><st c="29880"> a particular class wants to connect to a port, it needs to implement the </st><span class="No-Break"><st c="29954">port protocol.</st></span></li>
			</ul>
			<p><st c="29968">Most iOS developers are familiar with the concept of a port and adapter. </st><st c="30042">Eventually, this will be another way to decouple two elements using a protocol. </st><st c="30122">However, in hexagonal architecture, all the elements that want to communicate with the domain model must </st><span class="No-Break"><st c="30227">use protocols.</st></span></p>
			<p><st c="30241">There are two types of adapters – driving and driven. </st><st c="30296">The distinction between them is fundamental to understanding the concept of </st><span class="No-Break"><st c="30372">hexagonal architecture.</st></span></p>
			<h3><st c="30395">Understanding the driving adapters</st></h3>
			<p><st c="30430">The driving </st><a id="_idIndexMarker989"/><st c="30443">adapters act as the entry point for the </st><a id="_idIndexMarker990"/><st c="30483">external world and are responsible for initiating any interaction with the </st><span class="No-Break"><st c="30558">domain model.</st></span></p>
			<p><st c="30571">If we return to the computer example, adapters can be considered an external keyboard or mouse. </st><st c="30668">We call them </st><em class="italic"><st c="30681">driving</st></em><st c="30688"> because they drive the app by invoking its </st><span class="No-Break"><st c="30732">use cases.</st></span></p>
			<p><st c="30742">The most common example of driving adapters is the UI. </st><st c="30798">A screen usually performs actions that drive our system to take meaningful action, such as logging in to the system, playing music, or fetching data from the network or the local </st><span class="No-Break"><st c="30977">persistent store.</st></span></p>
			<p><st c="30994">However, driving adapters are not limited to UI screens. </st><st c="31052">We can consider notification centers, app/scene delegates, location services, and universal links as </st><span class="No-Break"><st c="31153">driving adapters.</st></span></p>
			<p><st c="31170">The driving adapter depends on the domain model and communicates with it only with </st><span class="No-Break"><st c="31254">protocols (ports).</st></span></p>
			<p><st c="31272">Now, let’s understand what the driven </st><span class="No-Break"><st c="31311">adapter is.</st></span></p>
			<h3><st c="31322">Understanding the driven adapter</st></h3>
			<p><st c="31355">The</st><a id="_idIndexMarker991"/><st c="31359"> domain </st><a id="_idIndexMarker992"/><st c="31367">model uses the driven adapters to communicate with external systems or services, such as the network, persistent storage, or </st><span class="No-Break"><st c="31492">third-party services.</st></span></p>
			<p><st c="31513">In the computer example, we can look at the driven adapter as an external display or </st><span class="No-Break"><st c="31599">a printer.</st></span></p>
			<p><st c="31609">We can consider the whole hexagonal architecture as an I/O system – the driving adapters are the input devices, and the driven adapters are the output devices, performing updates to the local storage or executing </st><span class="No-Break"><st c="31823">API calls.</st></span></p>
			<p><st c="31833">Let’s look at our architecture now that we understand what ports, driving adapters, and driven adapters are (</st><span class="No-Break"><em class="italic"><st c="31943">Figure 15</st></em></span><span class="No-Break"><em class="italic"><st c="31953">.10</st></em></span><span class="No-Break"><st c="31956">):</st></span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B21795_15_10.jpg" alt="Figure 15.10: The complete hexagonal architecture"/><st c="31959"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="32071">Figure 15.10: The complete hexagonal architecture</st></p>
			<p><span class="No-Break"><em class="italic"><st c="32120">Figure 15</st></em></span><em class="italic"><st c="32130">.10</st></em><st c="32133"> shows </st><a id="_idIndexMarker993"/><st c="32140">the different adapters, divided into driving and driven. </st><st c="32197">It also </st><a id="_idIndexMarker994"/><st c="32205">shows that we need a port to access the </st><span class="No-Break"><st c="32245">domain model.</st></span></p>
			<p><st c="32258">At this point, we have discussed the hexagonal architecture mostly in theory. </st><st c="32337">Let’s examine some examples of how to implement this concept </st><span class="No-Break"><st c="32398">in practice.</st></span></p>
			<h3><st c="32410">Implementing the hexagonal architecture in practice</st></h3>
			<p><st c="32462">Let’s demonstrate the </st><a id="_idIndexMarker995"/><st c="32485">hexagonal architecture using a simple flow such </st><span class="No-Break"><st c="32533">as login.</st></span></p>
			<h4><st c="32542">Defining different ports</st></h4>
			<p><st c="32567">We start by </st><a id="_idIndexMarker996"/><st c="32580">defining the different ports. </st><st c="32610">The first port is the login use </st><span class="No-Break"><st c="32642">case itself:</st></span></p>
			<pre class="source-code"><st c="32654">
protocol LoginUseCaseProtocol {
    func login(username: String,
              password: String,
              completion: @escaping (Result&lt;User, Error&gt;)
                -&gt; Void)
}</st></pre>			<p><st c="32788">The </st><strong class="source-inline"><st c="32793">LoginUseCaseProtocol</st></strong><st c="32813"> protocol defines how the driving adapter or app UI communicates</st><a id="_idIndexMarker997"/><st c="32877"> with the app code, which is the </st><span class="No-Break"><st c="32910">domain model.</st></span></p>
			<p><st c="32923">Our second port is one that we use to connect to a driven adapter, such as the </st><span class="No-Break"><st c="33003">network service:</st></span></p>
			<pre class="source-code"><st c="33019">
enum NetworkRequestType{
    case login
}
protocol NetworkServiceProtocol {
    func performRequest(requestType: NetworkRequestType,
                        params: [String: Any],
                        completion: @escaping (Result&lt;User,
                        Error&gt;) -&gt; Void )
}</st></pre>			<p><st c="33223">The </st><strong class="source-inline"><st c="33228">NetworkServiceProtocol</st></strong><st c="33250"> protocol helps the domain model to communicate with external services such as </st><span class="No-Break"><st c="33329">network services.</st></span></p>
			<h4><st c="33346">Creating a login use case</st></h4>
			<p><st c="33372">Now that we </st><a id="_idIndexMarker998"/><st c="33385">have defined the different ports, we can create the login use case that sits at the heart of the </st><span class="No-Break"><st c="33482">domain model:</st></span></p>
			<pre class="source-code"><st c="33495">
class LoginUseCase: LoginUseCaseProtocol {
    let authService: NetworkServiceProtocol
    init(authService: NetworkServiceProtocol) {
        self.authService = authService
    }
    func login(username: String, password: String,
      completion: @escaping (Result&lt;User, any Error&gt;) -&gt;
      Void) {
        authService.performRequest(requestType: .login,
                                   params: ["username" : username,
                                            "password" : password],
                                   completion: completion)
    }
}</st></pre>			<p><st c="33893">The </st><strong class="source-inline"><st c="33898">LoginUseCase</st></strong><st c="33910"> class</st><a id="_idIndexMarker999"/><st c="33916"> implements the </st><strong class="source-inline"><st c="33932">LoginUseCaseProtocol</st></strong><st c="33952"> protocol, one of the ports we discussed earlier. </st><st c="34002">It also uses the </st><strong class="source-inline"><st c="34019">NetworkServiceProtocol</st></strong><st c="34041"> protocol as a dependency. </st><st c="34068">At this point, we have the login logic wrapped with a protocol and also communicate with the network service using a protocol. </st><st c="34195">This means that the domain logic of our app is completely decoupled from the driving or driven adapter we may have, which is exactly what </st><span class="No-Break"><st c="34333">we wanted.</st></span></p>
			<h4><st c="34343">Creating a network service</st></h4>
			<p><st c="34370">Now, let’s </st><a id="_idIndexMarker1000"/><st c="34382">create a </st><span class="No-Break"><st c="34391">network service:</st></span></p>
			<pre class="source-code"><st c="34407">
class NetworkService { }
extension NetworkService: </st><strong class="bold"><st c="34459">NetworkServiceProtocol</st></strong><st c="34481"> {
    func performRequest(requestType: NetworkRequestType,
                        params: [String : Any],
                        completion: @escaping (Result&lt;User, any Error&gt;) -&gt; Void) {
        // implementation needed
    }
}</st></pre>			<p><st c="34648">The </st><strong class="source-inline"><st c="34653">NetworkService</st></strong><st c="34667"> class implements the </st><strong class="source-inline"><st c="34689">NetworkServiceProtocol</st></strong><st c="34711"> protocol so</st><a id="_idIndexMarker1001"/><st c="34723"> that we can use it as a domain </st><span class="No-Break"><st c="34755">model dependency.</st></span></p>
			<h4><st c="34772">Creating a login screen</st></h4>
			<p><st c="34796">Now, let’s </st><a id="_idIndexMarker1002"/><st c="34808">turn to the driving adapter and create a </st><span class="No-Break"><st c="34849">login screen:</st></span></p>
			<pre class="source-code"><st c="34862">
import SwiftUI
struct LoginView: View {
    @State var username: String = ""
    @State var password: String = ""
</st><strong class="bold"><st c="34969">    let loginUseCase: LoginUseCaseProtocol</st></strong><st c="35007">
    var body: some View {
        VStack {
            TextField("Username", text: $username)
            SecureField("Password", text: $password)
            Button("Login") {
                loginUseCase.login(username: username,
                  password: password) { result in
                    // handle result
                }
            }
        }
        .padding()</st></pre>			<p><st c="35241">In this</st><a id="_idIndexMarker1003"/><st c="35249"> example, we create a simple login screen (username and password) that uses its protocol to work with the login use case. </st><st c="35371">If we need advanced state management, we can do that using a </st><span class="No-Break"><st c="35432">view model.</st></span></p>
			<h4><st c="35443">Connecting everything together</st></h4>
			<p><st c="35474">Now, all we need to do is to connect </st><span class="No-Break"><st c="35512">everything together:</st></span></p>
			<pre class="source-code"><st c="35532">
@main
struct HexagonalAppApp: App {
    var body: some Scene {
        WindowGroup {
            let networkService = NetworkService()
            let loginUserCase =
              LoginUseCase(networkService: networkService)
            LoginView(loginUseCase: loginUserCase)
        }
    }
}</st></pre>			<p><st c="35753">In the app initialization, we first create the driven adapters (the </st><strong class="source-inline"><st c="35822">NetworkService</st></strong><st c="35836"> class), inject them into the domain model (the login use case), and then inject the domain model int</st><a id="_idTextAnchor478"/><a id="_idTextAnchor479"/><a id="_idTextAnchor480"/><a id="_idTextAnchor481"/><st c="35937">o the driving adapter (the </st><span class="No-Break"><strong class="source-inline"><st c="35965">LoginView</st></strong></span><span class="No-Break"><st c="35974"> structure).</st></span></p>
			<p><st c="35986">At first glance, it appeared we’d created too many protocols and used more dependency injection than usual. </st><st c="36095">While it’s true that this is the cost of using architecture such as Hexagonal, let’s examine the </st><span class="No-Break"><st c="36192">benefits here:</st></span></p>
			<ul>
				<li><st c="36206">The different concerns are very clear. </st><st c="36246">We understand exactly what the app’s core logic is, what the external services are, and what the client of these </st><span class="No-Break"><st c="36359">modules is.</st></span></li>
				<li><st c="36370">Maintaining each adapter or core logic case is extremely easy since they are decoupled from each other and communicate only with a protocol. </st><st c="36512">When we say maintain, we mean testing, refactoring, and </st><span class="No-Break"><st c="36568">bug fixes.</st></span></li>
				<li><st c="36578">Replacing parts in our app, such as services or use cases, becomes very easy. </st><st c="36657">Let’s try to remember apps or even systems that we have worked on. </st><st c="36724">Imagine what it took to replace the network service, the persistent store, or even </st><span class="No-Break"><st c="36807">one screen.</st></span></li>
				<li><st c="36818">Adding more features and modules doesn’t require significant changes to our project. </st><st c="36904">Reusing existing cod</st><a id="_idTextAnchor482"/><a id="_idTextAnchor483"/><st c="36924">e when adding new screens or use cases </st><span class="No-Break"><st c="36964">is easy.</st></span></li>
			</ul>
			<p><st c="36972">Remember that, like the multi-layer and modular architectures, the hexagonal architecture provides a set of guidelines and principles for conducting a well-structured and maintainable </st><span class="No-Break"><st c="37157">project architecture.</st></span></p>
			<p><st c="37178">So, how do these </st><span class="No-Break"><st c="37196">principles compare?</st></span></p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor484"/><st c="37215">Comparing the different architectures</st></h1>
			<p><st c="37253">What is the </st><a id="_idIndexMarker1004"/><st c="37266">best architecture we can use? </st><st c="37296">Is there even right or wrong here? </st><st c="37331">How do we digest all </st><span class="No-Break"><st c="37352">of that?</st></span></p>
			<p><st c="37360">So, we saw how to combine modular and multi-layer architecture and emphasize each architecture’s advantage. </st><st c="37469">The same goes for the hexagonal architecture – let’s pull out the different principles </st><span class="No-Break"><st c="37556">we’ve learned:</st></span></p>
			<ul>
				<li><st c="37570">Use protocols to decouple the communication with the </st><span class="No-Break"><st c="37624">external services</st></span></li>
				<li><st c="37641">Make the domain model the core of </st><span class="No-Break"><st c="37676">the app</st></span></li>
			</ul>
			<p><st c="37683">These principles are relevant not only to hexagonal architecture but also to </st><span class="No-Break"><st c="37761">other architectures.</st></span></p>
			<p><st c="37781">Let’s try to compare the different architectures using several </st><span class="No-Break"><st c="37845">important metrics.</st></span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor485"/><st c="37863">By separation of concerns</st></h2>
			<p><st c="37889">Separation of concerns is </st><a id="_idIndexMarker1005"/><st c="37916">an important principle in project structuring, and all three architectures implement </st><span class="No-Break"><st c="38001">it well.</st></span></p>
			<p><st c="38009">However, each separates the </st><a id="_idIndexMarker1006"/><st c="38038">concerns in a slightly different way. </st><st c="38076">For example, the </st><em class="italic"><st c="38093">multi-layered architecture</st></em><st c="38119"> separations are clear and straightforward, but they may lead to tight coupling if not </st><span class="No-Break"><st c="38206">carefully implemented.</st></span></p>
			<p><st c="38228">On the other hand, in </st><em class="italic"><st c="38251">modular architecture</st></em><st c="38271">, the separations are easy to maintain and scale because each module contains its own different layers and is self-contained. </st><st c="38397">However, defining the distinct boundaries between the modules can </st><span class="No-Break"><st c="38463">be complex.</st></span></p>
			<p><st c="38474">The </st><em class="italic"><st c="38479">hexagonal architecture</st></em><st c="38501"> focuses on separating the application core from external services. </st><st c="38569">This approach is practical when adapting many external systems to the app. </st><st c="38644">However, it requires a complex setup that can be overhead in </st><span class="No-Break"><st c="38705">small apps.</st></span></p>
			<p><st c="38716">All these architectures have great separations of concerns because that’s one of the most important principles in designing an architecture. </st><st c="38858">However, each does that using a different approach, and the decision of the prominent architecture depends on the </st><span class="No-Break"><st c="38972">project requirements.</st></span></p>
			<p><st c="38993">Let’s see how to compare the different architectures in terms </st><span class="No-Break"><st c="39056">of testing.</st></span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor486"/><st c="39067">By testing</st></h2>
			<p><st c="39078">Testing and </st><a id="_idIndexMarker1007"/><st c="39091">separation of concerns principles are related to each other. </st><st c="39152">The separation of concerns principle encourages the isolation of different classes and modules, which makes it simpler to write unit tests for a specific part of our app. </st><st c="39323">Separating our apps based on concerns also makes it easier to manage dependencies, a critical factor in testing. </st><st c="39436">However, since each architecture performs the separation differently, it also influences </st><span class="No-Break"><st c="39525">the testing.</st></span></p>
			<p><st c="39537">For example, in a </st><em class="italic"><st c="39556">multi-layer architecture</st></em><st c="39580">, it becomes easier to test each layer independently. </st><st c="39634">We can perform core data or specific business logic testing in a simple way. </st><st c="39711">However, if </st><a id="_idIndexMarker1008"/><st c="39723">we want to write integration tests (tests that involve working with multiple components), the multi-layer architecture makes it much more complex because of the dependencies between </st><span class="No-Break"><st c="39905">the layers.</st></span></p>
			<p><st c="39916">However, writing integration tests is one advantage of </st><em class="italic"><st c="39972">modular architecture</st></em><st c="39992">, as the different interfaces within the module are well-defined. </st><st c="40058">On the other hand, trying to write a unit test for a specific app layer can become much more </st><span class="No-Break"><st c="40151">complex now.</st></span></p>
			<p><st c="40163">In the </st><em class="italic"><st c="40171">hexagonal architecture</st></em><st c="40193">, we work with adapters and ports. </st><st c="40228">This means loose coupling and many protocols with external services, which allows us to mock external services easily and easily test the </st><span class="No-Break"><st c="40366">application core.</st></span></p>
			<p><st c="40383">To summarize, testing is a big topic in development, and each of the architectures supports it very well. </st><st c="40490">To understand how the choice of architecture affects testing, we need to ask ourselves what the core unit we want to test is – is it a module, a layer, or the application core? </st><st c="40667">Also, are integration tests important to us? </st><st c="40712">Answering these questions can help us understand which architecture fits our </st><span class="No-Break"><st c="40789">project better.</st></span></p>
			<p><st c="40804">What about maintenance and scalability? </st><st c="40845">Let’s </st><span class="No-Break"><st c="40851">see now.</st></span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor487"/><st c="40859">By maintenance and scalability</st></h2>
			<p><st c="40890">Before </st><a id="_idIndexMarker1009"/><st c="40898">we see how each architecture stands out regarding maintenance and scalability, let’s understand exactly what it means. </st><st c="41017">Maintenance is ongoing to keep our project aligned with the changing requirements. </st><st c="41100">This involves fixing bugs, making new features and improvements, refactoring, and optimizing. </st><st c="41194">Scalability describes our ability to increase the number of features without redesigning our project. </st><st c="41296">In general, a well-maintained project is often considered to be scalable. </st><st c="41370">However, like testing and separations, each architecture has a </st><span class="No-Break"><st c="41433">different approach.</st></span></p>
			<p><st c="41452">The multi-layer architecture is great for medium-sized projects. </st><st c="41518">Due to the tight coupling between the layers, maintaining a clear multi-layer architecture over time can be challenging in large projects.  </st><st c="41657">Modular architecture is considered to be highly scalable in big projects, as there are clear boundaries and independence between different business units. </st><st c="41812">However, defining these units can be a challenge in the early stages. </st><st c="41882">The hexagonal architecture is excellent for scaling – the clear domain separations help add more services to the project and test them over time. </st><st c="42028">However, the maintenance can be overhead due to the many adapters we need </st><span class="No-Break"><st c="42102">to manage.</st></span></p>
			<p><st c="42112">Each of the</st><a id="_idIndexMarker1010"/><st c="42124"> architectures is suitable for a different scale of project and requirements. </st><st c="42202">Medium projects may work well with multi-layer architecture compared to modular, and hexagonal architecture can be great for large projects with one application core that can increase over </st><span class="No-Break"><st c="42391">the years.</st></span></p>
			<p><st c="42401">Let’s try to summarize by comparing the different architectures with </st><span class="No-Break"><st c="42471">different aspects:</st></span></p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="42489">Aspect</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="42496">Multi-layer</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="42508">Modular</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="42516">Hexagonal</st></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><st c="42526">Separation </st></strong><span class="No-Break"><strong class="bold"><st c="42538">of concerns</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42549">Clear, hierarchical layers (UI, logic, data); can become less flexible </st><span class="No-Break"><st c="42621">with dependencies</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42638">Independent, strong separation, </st><span class="No-Break"><st c="42671">flexible interfaces</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42690">Clear separation from external systems; core logic isolated via ports </st><span class="No-Break"><st c="42761">and adapters</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="42773">Testing</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42781">Easy within the layers, complex </st><span class="No-Break"><st c="42814">between layers</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42828">Simple to test a single module, and the same goes for integration tests within </st><span class="No-Break"><st c="42908">the module</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42918">Core logic is very testable; easy to </st><span class="No-Break"><st c="42956">mock adapters</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="42969">Maintenance</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="42981">Can be challenging due to </st><span class="No-Break"><st c="43008">tight coupling</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="43022">Easier due to modular; minimal impact </st><span class="No-Break"><st c="43061">across modules</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="43075">Easy due to isolation from </st><span class="No-Break"><st c="43103">external changes</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="43119">Scalability</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="43131">Limited by </st><span class="No-Break"><st c="43143">layer interactions</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="43161">Highly scalable as modules can </st><span class="No-Break"><st c="43193">scale independently</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="43212">Scales by adding new adapters; core </st><span class="No-Break"><st c="43249">remains stable</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p><st c="43263">This table can give us a sense of the different architectures’ performance in different aspects. </st><st c="43361">There are no scores here! </st><st c="43387">We need to choose and mix the architectural concepts based on </st><span class="No-Break"><st c="43449">our needs.</st></span></p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor488"/><st c="43459">Summary</st></h1>
			<p><st c="43467">Focusing on the correct architecture is a strategic decision that influences our project over time. </st><st c="43568">If you feel confused about what fits your app, that’s natural. </st><st c="43631">Remember that the right thing to do is to look at the different architectures as different principles – we should combine the best from all worlds in a way that suits our </st><span class="No-Break"><st c="43802">project requirements.</st></span></p>
			<p><st c="43823">In this chapter, we learned about the importance of architecture and what exactly it means. </st><st c="43916">We also compared the different architectures – multi-layer, modular, and hexagonal. </st><st c="44000">By now, you should be able to design your app’s different components to help you scale, maintain, and test it </st><span class="No-Break"><st c="44110">over time.</st></span></p>
			<p><st c="44120">It’s not a coincidence that the book’s last chapter discusses architecture. </st><st c="44197">In a way, architecture ties together everything we’ve learned, providing a structure that allows all the elements to work together harmoniously. </st><st c="44342">In addition, the app architecture is the infrastructure where we implement all the concepts we’ve learned throughout the book. </st><st c="44469">Our journey ends; this is a good chance to start experiencing all the advanced iOS capabilities. </st><span class="No-Break"><st c="44566">Good luck!</st></span></p>
		</div>
	<div id="charCountTotal" value="44576"/></body></html>