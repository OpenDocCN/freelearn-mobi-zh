- en: Collision Detection and Basic Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测和基本人工智能
- en: 'You learned an overview on how to play animations in our game, and now we are
    going to go a step further into this exciting journey of game development by learning
    one of the most complex yet crucial concepts required to make our game feel realistic.
    By adding animations, we can make our game look realistic, but it is also important
    for a game to feel realistic because that is what makes it fun to play. In this
    chapter, we will be taking a look at the following two concepts in further detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了如何在我们的游戏中播放动画的概述，现在我们将更进一步地进入这个激动人心的游戏开发之旅，通过学习制作游戏感觉真实所需的最复杂但至关重要的概念之一。通过添加动画，我们可以使我们的游戏看起来更真实，但游戏感觉真实也同样重要，因为这是使其有趣的原因。在本章中，我们将更详细地探讨以下两个概念：
- en: Collision detection
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Artificial intelligence
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能
- en: Thus, this chapter will be divided into two main sections. The studies of collision
    detection and artificial intelligence are in themselves quite vast topics. For
    the sake of simplicity to serve our purpose, we will be taking a look at the most
    basic version of these topics to get an entry level understanding for being able
    to apply the knowledge of these concepts in our game. So without further ado,
    let's dive into this complex yet exciting topic of collision detection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将分为两个主要部分。碰撞检测和人工智能的研究本身是非常广泛的课题。为了简化以服务于我们的目的，我们将查看这些主题的最基本版本，以便获得入门级理解，以便能够在我们的游戏中应用这些概念的知识。所以，无需多言，让我们深入这个复杂但令人兴奋的碰撞检测主题。
- en: Collision detection
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'To explain it simply, collision is a short duration interaction between two
    bodies. There are many different types of collisions such as elastic and non-elastic.
    The study of the intersection of two or more objects overlapping each other is
    called as **collision detection**. It is one of the most complex pieces of computational
    mathematics and is divided into many types, such as:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，碰撞是两个物体之间短暂相互作用。有各种不同类型的碰撞，如弹性碰撞和非弹性碰撞。研究两个或多个物体重叠的交集称为**碰撞检测**。它是计算数学中最复杂的部分之一，并分为许多类型，例如：
- en: '**Bounding Box Collision:** This is the simplest form of collision techniques
    wherein we take two rectangles and check for collision if they overlap each other.
    For this, we need four coordinates of each rectangle, namely, the *x* and *y*
    position and width and height of both rectangles.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界框碰撞**：这是一种最简单的碰撞技术形式，其中我们取两个矩形并检查它们是否重叠。为此，我们需要每个矩形的四个坐标，即 *x* 和 *y* 位置以及两个矩形的宽度和高度。'
- en: '**Circle Collision: **This is the second simplest type of collision wherein
    we test for collisions between two circles. Here, the radius of two circles and
    *x* and *y* position of the center of the circles are taken into account to test
    for overlapping.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**圆形碰撞**：这是第二种最简单的碰撞类型，其中我们测试两个圆之间的碰撞。在这里，我们考虑两个圆的半径和圆心的 *x* 和 *y* 位置来测试重叠。'
- en: '**Separating Axis Theorem:** This type of collision is a bit more complex than
    the other two mentioned earlier, primarily because this is used to detect collisions
    between two polygons.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离轴定理**：这种碰撞比前面提到的两种要复杂一些，主要是因为它主要用于检测两个多边形之间的碰撞。'
- en: There are, of course, many other types of collisions, but that is a totally
    huge concept in itself. For the purpose of this book, we will be dealing with
    the simpler forms of collision, and based on the understanding of these concepts,
    you can experiment further with more complex collision types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他类型的碰撞，但这本身就是一个庞大的概念。为了本书的目的，我们将处理更简单的碰撞形式，并根据对这些概念的理解，你可以进一步实验更复杂的碰撞类型。
- en: Now, let's look at the algorithms for the three types of collisions you learned
    about.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你所学的三种碰撞类型的算法。
- en: These algorithms are just pseudo codes. Pseudo means false, which means these
    codes are not to be executed. They are just mentioned here for the purpose of
    understanding the different collision techniques.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法只是伪代码。伪意味着虚假，这意味着这些代码不应被执行。它们只是在这里提到，以便理解不同的碰撞技术。
- en: Let's take a look at each of them individually before resuming work on our game
    project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续我们的游戏项目之前，让我们逐一查看它们。
- en: Algorithms for collision detection techniques
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测技术算法
- en: It is very essential that we get a foundation for understanding these collision
    techniques and therefore it is very important that we understand the way these
    techniques work. Let's take a look at the different algorithms for detecting collisions.
    We will be using these concepts in our game when we are dealing with collisions
    further in this chapter. Since we will only be working with the simple types in this
    book, we will only take a look at the algorithms for Bounding Box and Circle Collision
    Detection techniques.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常需要为理解这些碰撞技术打下基础，因此了解这些技术是如何工作的非常重要。让我们来看看检测碰撞的不同算法。在我们本章进一步处理碰撞时，我们将使用这些概念。由于我们在这本书中只处理简单类型，我们将只查看边界框和圆形碰撞检测技术的算法。
- en: Bounding Box Collision
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界框碰撞
- en: 'We saw in our preceding explanation points that Bounding Box Collision technique
    is one of the simplest. That''s because we are simply testing for between two
    rectangles. Consider the following pseudo code for a better understanding:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的解释中，我们看到边界框碰撞技术是最简单的之一。这是因为我们只是在两个矩形之间进行测试。考虑以下伪代码以更好地理解：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the preceding code, the mathematical operations required
    to detect a collision through this technique are quite simplistic. We are only
    working with basic `x`, `y` coordinates and `width` and `height`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中可以看到，通过这种技术检测碰撞所需的数学运算相当简单。我们只处理基本的 `x`、`y` 坐标以及 `width` 和 `height`。
- en: Circle Collision
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆形碰撞
- en: 'Yet another simple type of collision, this deals with mapping out the distance
    between the centers of two circles to detect a collision. Its algorithm goes as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种简单的碰撞类型，它涉及绘制两个圆心之间的距离以检测碰撞。其算法如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can observe here, we have two circles. We then take their individual
    distances of `x` and `y` coordinates. After that, we take the square root of the
    sum of their squares. This is just the simple formula to calculate the distance
    between two circles. Then in our testing condition, we check if the distance is
    less than the sum of two circles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所观察到的，我们有两个圆。然后我们取它们各自的 `x` 和 `y` 坐标距离。之后，我们取它们平方和的平方根。这就是计算两个圆之间距离的简单公式。然后在我们的测试条件下，我们检查这个距离是否小于两个圆的和。
- en: Now that we have a basic understanding of the algorithms for collision detection,
    we are equipped to move ahead on detecting the collision in our game. Let's start
    with it!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对碰撞检测的算法有了基本的了解，我们就可以继续在游戏中检测碰撞了。让我们开始吧！
- en: Detecting collisions in our game
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的游戏中检测碰撞
- en: Since we are dealing with a game here, we will be dealing with the theory with
    a practical application. So, let's a take up a task of studying collision techniques
    with an example of an approaching rock toward the player. Our game is a side scrolling
    game and therefore there will be multiple obstacles and collectibles heading our
    way. Through the simple Bounding Box Collision technique, we can detect collisions
    between our player and other objects and execute corresponding functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里处理的是一个游戏，我们将以实际应用的方式处理理论。因此，让我们通过一个玩家面前接近的岩石的例子来研究碰撞技术。我们的游戏是一个横版滚动游戏，因此将有多个障碍物和可收集物品朝我们走来。通过简单的边界框碰撞技术，我们可以检测玩家与其他对象之间的碰撞并执行相应的函数。
- en: After we are done creating our incoming rocks, we will also create incoming
    coins so that the player can score points as well. However, before we proceed
    with this, we have to come up with a way for our player to avoid these obstacles
    too. We will be implementing collision detection wherein if the player collides
    with a rock then he will die. Thus, it is crucial for our player to jump. We will
    give our player jumping abilities on our touch input. So, let's get our player
    to jump!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建即将到来的岩石之后，我们还将创建即将到来的硬币，以便玩家也能得分。然而，在我们继续进行之前，我们必须想出一种让我们的玩家避开这些障碍的方法。我们将实现碰撞检测，如果玩家与岩石相撞，他将死亡。因此，玩家跳跃是至关重要的。我们将在触摸输入上赋予玩家跳跃能力。所以，让我们让我们的玩家跳跃吧！
- en: Making our player jump
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们的玩家跳跃
- en: Since in our further chapters, we will be spawning obstacles and coins randomly
    on the screen, we will modify our player to navigate up and down on the screen.
    So, let's say if you touch your screen, the player will go up and if you stop
    touching the screen, our player will go down. Let us take a look at the changes
    we need to implement in our code first and then understand them step by step by
    breaking them down. We will be working on the `GameView.java` file for this code
    portion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在接下来的章节中，我们将在屏幕上随机生成障碍物和金币，我们将修改我们的玩家，使其能够在屏幕上上下移动。所以，如果你触摸屏幕，玩家将上升；如果你停止触摸屏幕，我们的玩家将下降。让我们首先看看我们需要在代码中实现的变化，然后一步一步地分解它们。我们将为这段代码部分在`GameView.java`文件上工作。
- en: 'Initially, our animation used to start as soon as the game started. But we
    need a little bit more control over our actions so we used our `getPlaying()`
    function to achieve this. Here''s how we will tackle this problem:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们的动画是在游戏开始时立即开始的。但我们需要对我们的动作有更多的控制，所以我们使用了`getPlaying()`函数来实现这一点。以下是我们将如何解决这个问题：
- en: 'We added a condition in our `update()` method that if our player is playing
    only then will we update our background image and player character. It simply
    means that the game won''t start without some signal:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`update()`方法中添加了一个条件，即只有当玩家正在玩游戏时，我们才会更新背景图像和玩家角色。这意味着如果没有信号，游戏将不会开始：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will now use the `onTouchEvent()` to notify that our game has started as
    well as when to go up and when to go down. In the first condition inside our `onTouchEvent()`
    , we will check if we have a touch event on the screen. `ACTION_DOWN` means that
    the screen is touched.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用`onTouchEvent()`来通知我们的游戏已经开始，以及何时上升和下降。在我们的`onTouchEvent()`的第一个条件中，我们将检查屏幕上是否有触摸事件。`ACTION_DOWN`表示屏幕被触摸。
- en: Inside this, if blocked, we will have another if block, which checks if the
    player is playing or not. If the player is not playing, then we set the `setPlaying()`
    function to set a `true` value, thereby starting the game loop which then starts
    the `update()` method because of our condition in step 1\. Otherwise, it will
    simply tell the player that the screen is touched and therefore our `up` Boolean
    variable is set to `true`, which means the player goes up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果被阻塞，我们将有一个另一个if块，它检查玩家是否正在玩游戏。如果玩家没有在玩游戏，那么我们将`setPlaying()`函数设置为`true`值，从而启动游戏循环，然后由于步骤1中的条件，它将启动`update()`方法。否则，它将简单地告诉玩家屏幕被触摸，因此我们的`up`布尔变量被设置为`true`，这意味着玩家上升。
- en: After this, we will write the `return true` statement, which is responsible
    for notifying about the touch event since our `onTouchEvent()` has a Boolean return
    type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写`return true`语句，它负责通知触摸事件，因为我们的`onTouchEvent()`有一个布尔返回类型。
- en: Next, we define our condition for the player to go down. In our case, this simply
    means that the touch input is no longer received, which means our finger was lifted
    from the screen. `ACTION_UP` defines this event.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义玩家下移的条件。在我们的例子中，这仅仅意味着不再接收到触摸输入，这意味着我们的手指已经从屏幕上抬起。`ACTION_UP`定义了这个事件。
- en: If this event takes place, then we set our `up` variable to `false` and therefore
    our player goes down.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生此事件，则将我们的`up`变量设置为`false`，因此玩家将下降。
- en: 'We will again write a `return true` statement for our event. Here''s what our
    code for `onTouchEvent()` will look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为事件再次编写一个`return true`语句。以下是我们的`onTouchEvent()`代码将看起来像：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From this edit, we have only defined the calls required for setting the up
    and down functionality of our player. However, we also need to add acceleration
    and deceleration to our player in order to actually move up and down. We will
    achieve this by editing our `PlayerCharacter.java` file. Let''s write some jumping
    code in this file. Open it up and write the following code marked in bold in the
    `update()` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次编辑中，我们只定义了设置玩家上下功能所需的调用。然而，我们还需要为我们的玩家添加加速度和减速度，以便实际上能够上下移动。我们将通过编辑我们的`PlayerCharacter.java`文件来实现这一点。让我们在这个文件中编写一些跳跃代码。打开它，并在`update()`方法中写下以下加粗的代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This block of code is extremely easy to understand. Let''s break it down to
    get a proper grasp of the same:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块非常容易理解。让我们分解它，以便更好地掌握：
- en: We check if our `up` variable is true or not.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查我们的`up`变量是否为真。
- en: If it is `true` , then we add a positive acceleration value which *increases
    by 1.1* in every update. You can tweak these values as per your liking.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是`true`，那么我们将添加一个正加速度值，该值在每次更新时增加1.1。你可以根据你的喜好调整这些值。
- en: If it is `false`, then we add a negative acceleration value which *decreases
    by 1.1* in every update.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是 `false`，那么我们将在每次更新中添加一个负加速度值，该值会减少 1.1。
- en: After this, we don't want the acceleration or deceleration to go beyond a certain
    limit so we limit it to some bounds. In our case, we have kept a *maximum of 10
    and minimum of -10.*
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们不想加速度或减速度超过某个限制，所以我们将其限制在某个范围内。在我们的例子中，我们将其限制在最大 10 和最小 -10。
- en: We add the double of our acceleration value to the `y` coordinates.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将加速度值的两倍添加到 `y` 坐标上。
- en: We set our deceleration to 0 to reset it on our next `update()` call.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将减速度设置为 0，以便在下一个 `update()` 调用中重置它。
- en: You can tweak the acceleration values to test for yourself and get comfortable
    with the desired speed. To change the speed of acceleration, simply change the
    values in `dyc`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整加速度值来自行测试并熟悉期望的速度。要更改加速度的速度，只需更改 `dyc` 中的值。
- en: 'And this will make our player jump with joy! Build your game and test it on
    your device or emulator. You will observe two things here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的玩家高兴地跳跃！构建你的游戏并在你的设备或模拟器上测试它。你将在这里观察到两件事：
- en: The game is paused when you start it and will only play when you touch the screen.
    This is because of our if condition in our `GameView.java` file.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你开始游戏时，游戏会暂停，并且只有在触摸屏幕时才会播放。这是因为我们的 `GameView.java` 文件中的 if 条件。
- en: Your player now moves up and down because of the acceleration values we provided
    in the `PlayerCharacter.java` file.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们在 `PlayerCharacter.java` 文件中提供的加速度值，你的玩家现在可以上下移动。
- en: Now that we have established this, it's time to deal with oncoming obstacles
    and dodge them! Oh, and also learn about collisions in the process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了这个，是时候处理迎面而来的障碍物并避开它们了！哦，顺便说一下，还要了解碰撞过程。
- en: Dodging incoming rocks
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免迎面而来的石头
- en: 'The very first thing we would need before we proceed with anything is a nice
    looking piece of rock. Not kidding, really! We need an image of a toony-looking
    rock, which would fit with the theme of our game. So, let''s get a rock for ourselves. For
    the purpose of this chapter, we will be using this rock:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行任何操作之前，我们首先需要一块看起来不错的石头。不是开玩笑，真的！我们需要一块看起来卡通的石头图像，这将符合我们游戏的主题。所以，让我们为自己找一块石头。 为了本章的目的，我们将使用这块石头：
- en: '![](img/B05066_06_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_06_01.png)'
- en: This is our basic rock
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们基本的石头
- en: As we had done in our previous part, we will need animation for the rock and
    so we will create a sprite sheet of the rock we have. Then, we will simply name
    it as `rock.png` and get started with it. It would be cool to have a rolling rock
    since that would make more sense in the game, and so we will use a rolling rock
    sprite sheet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中所做的那样，我们需要为石头创建动画，因此我们将创建我们拥有的石头的角色表。然后，我们只需将其命名为 `rock.png` 并开始使用它。 有一个滚动的石头会更好，因为这在游戏中更有意义，所以我们将使用 滚动的石头角色表。
- en: '![](img/B05066_06_02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_06_02.png)'
- en: Our rock.png sprite sheet
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 rock.png 角色表
- en: Of course, as we saw before, this rock is also just an image and will be placed
    inside the `res/drawable` folder as we did before. So, pick up any rock and place
    it into the `res/drawable` folder to get started.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们之前所看到的，这块石头也只是一个图像，并且会像之前一样放置在 `res/drawable` 文件夹中。所以，拿起任何一块石头并将其放入 `res/drawable`
    文件夹以开始。
- en: 'Now, since we are going to deal with a new object it must be pretty clear by
    this point that we would need to create a new class. So let''s go ahead and do
    that. Create a new class and name it `Rock.java`. This will have all our code
    for our obstacle rock. You will then have a blank java file in which you will
    need to extend it to our `GameObj.java` file like every other game object in our
    game:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们将处理一个新的对象，所以到这一点为止，必须非常清楚我们需要创建一个新的类。所以，让我们继续并创建一个新的类，命名为 `Rock.java`。这将包含我们障碍石头的所有代码。然后，你将有一个空白
    java 文件，你需要将其扩展到我们的 `GameObj.java` 文件，就像我们游戏中的其他任何游戏对象一样：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now gear up! We are going to do some heavy duty coding on this one. Let''s
    take a look at this step by step. We will need three methods in this file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好！我们将对这个进行一些重头戏的编码。让我们一步一步地看看。在这个文件中，我们需要三个方法：
- en: '`Constructor`: This will have the parameters for our rock, such as the `x`,
    `y` positions, `width`, `height`, `score`, and so on'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构造函数`：这将包含我们石头的参数，例如 `x`、`y` 位置、`宽度`、`高度`、`得分` 等等'
- en: '`Update` method: This is the method, as seen earlier, that gets called in every
    frame'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update` 方法：正如之前所见，这是在每一帧都会被调用的方法'
- en: '`Draw` method: This method is responsible for actually drawing our object on
    the screen'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Draw` 方法：这个方法负责在屏幕上实际绘制我们的对象'
- en: 'Let''s begin with our constructor and variables. We will need a `score` and
    `speed` variable as well as a variable for `Bitmap` and our predefined `AnimationClass`,
    since we will be animating this rock as well. Let''s do that. We will start with
    the variables first. We will declare our variables that will be needed for the
    game, which includes `score`, `speed`, our `animationClass` reference, and `spriteSheet`
    reference. We have also taken a `Random` number reference variable to generate
    a score based on a unique condition in the game loop that you will see shortly.
    Currently, we are not displaying the score on the screen but soon you will see
    it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构造函数和变量开始。我们需要一个`score`和`speed`变量，以及一个用于`Bitmap`和预定义的`AnimationClass`的变量，因为我们还将对这个石头进行动画处理。让我们开始吧。我们首先声明游戏所需的变量，包括`score`、`speed`、我们的`animationClass`引用和`spriteSheet`引用。我们还取了一个`Random`数字引用变量，用于根据游戏循环中即将看到的唯一条件生成分数。目前，我们没有在屏幕上显示分数，但很快你将看到它：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we will write our constructor. There are a bunch of parameters needed for
    the constructor such as the `x`, `y` coordinates, `width`, `height`, `score`,
    and `noOfFrames`. We basically take their reference as parameters to our method
    and hence we require `xc`, `yc`, `w`, `h`, `s`, and `noOfFrames` as parameters
    in our constructor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写我们的构造函数。构造函数需要一系列参数，如`x`、`y`坐标、`width`、`height`、`score`和`noOfFrames`。我们基本上将它们的引用作为参数传递给我们的方法，因此我们需要在构造函数中提供`xc`、`yc`、`w`、`h`、`s`和`noOfFrames`作为参数。
- en: 'After that, we actually need our rock to go faster once we survive for a longer
    time and hence we will write the code in such a way that, as our score increases,
    our rocks will become faster. We will use a little bit of math for this, wherein
    we will use our random variable. Basically, this will be our formula: `speed =
    7 + (int) (rnd.nextDouble()*score/30);`. Then we will set our Bitmap reference
    variable so it can scan through our sprite sheet followed by a `for` loop to scan
    through the same. And finally, we will set our frames to our `animationClass`
    and add a delay for our animation to play. Let''s see how that works out in our
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要我们的石头在生存时间更长后跑得更快，因此我们将编写代码，使得随着分数的增加，我们的石头会变得更快。我们将使用一点数学知识来完成这个任务，其中我们将使用我们的随机变量。基本上，这将是我们公式：`speed
    = 7 + (int) (rnd.nextDouble()*score/30);`。然后我们将设置我们的`Bitmap`引用变量，以便它可以扫描我们的精灵图集，随后通过一个`for`循环扫描相同的图集。最后，我们将设置我们的帧到`animationClass`，并为动画添加延迟。让我们看看这在我们的代码中是如何工作的：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this part of the code, we did nothing new but simply created our rock game
    object and its drawing on the screen method. It's the same thing that we did with
    our `PlayerCharacter`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分代码中，我们没有做任何新的工作，只是创建了一个石头游戏对象及其在屏幕上的绘制方法。这与我们为`PlayerCharacter`所做的是同一件事。
- en: 'Now that our constructor is ready, we can move on to write our code for the `update()`
    and `draw()` methods. In our `update()` method, we don''t need to do much. We''ll
    only be moving our rock from right to left, and hence we''ll use our `speed` variable
    to just shift our rock certain units in every frame toward the left. We will use
    the `draw()` method to simply draw our rock on the screen with the help of the
    `animationClass` reference variable:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了构造函数，我们可以继续编写`update()`和`draw()`方法的代码。在我们的`update()`方法中，我们不需要做太多。我们只需将我们的石头从右向左移动，因此我们将使用我们的`speed`变量，在每一帧中将石头向左移动一定的单位。我们将使用`draw()`方法，借助`animationClass`引用变量，在屏幕上简单地绘制我们的石头：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding code, we simply created our `update()` method
    and shifted our rock certain units on the left with our `speed` variable. After
    that, immediately we gave a call to the `update()` method of `animationClass`
    so that the sprite sheet of the rock gets updated and we get an effect as though
    the rock is rolling as it moves.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们简单地创建了一个`update()`方法，并使用`speed`变量将石头向左移动一定的单位。之后，我们立即调用了`animationClass`的`update()`方法，以便更新石头的精灵图集，并产生一种石头滚动移动的效果。
- en: We then simply used the `drawBitmap()` method to draw our rock on the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后简单地使用了`drawBitmap()`方法在屏幕上绘制我们的石头。
- en: We created our object, and now it's time for us to display it on the screen,
    and once we are done with that objective, we will move on to detecting the collision
    when it collides with our player.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了我们的对象，现在是我们将其显示在屏幕上的时间，一旦我们完成了这个目标，我们将继续检测石头与玩家碰撞时的情况。
- en: We will now create our rocks on the `GameView.java` file, which will spawn rocks
    at continuous intervals. Also, when our player collides with our rocks it will
    pause the game. So, let's open up our `GameView.java` file and get started with
    writing the code for this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建岩石在`GameView.java`文件中，这将以连续间隔生成岩石。同时，当我们的玩家与岩石发生碰撞时，游戏将暂停。所以，让我们打开我们的`GameView.java`文件，开始编写这段代码。
- en: 'We will create three new reference variables, `rockStartTime`, `rocks`, and
    `rnd`, which correspond to the start time of our rock game object, our actual
    rock game object, and a random variable for the purpose of randomizing the spawn
    location of the rocks on the screen. Since we are going to be spawning multiple
    rocks on the screen, we took its data type to be an `ArrayList` since dynamic
    arrays can be supported through an `ArrayList`. We will be needing this primarily
    because after our rocks have left the screen space, we will remove them, thereby having
    proper memory management of resources:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个新的引用变量，`rockStartTime`、`rocks`和`rnd`，分别对应岩石游戏对象的起始时间、实际岩石游戏对象以及用于随机化屏幕上岩石生成位置的随机变量。由于我们将在屏幕上生成多个岩石，我们将它的数据类型设置为`ArrayList`，因为动态数组可以通过`ArrayList`来支持。我们将主要需要这个，因为当我们的岩石离开屏幕空间后，我们将移除它们，从而实现资源的适当内存管理：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will improvise a bit on our `surfaceDestroyed()` method and create a `counter`
    as well as shift our `retry` variable block in order to avoid an infinite loop
    situation. Code changes are marked in bold:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的`surfaceDestroyed()`方法进行一些改进，并创建一个`counter`以及调整我们的`retry`变量块，以避免无限循环的情况。代码更改用粗体标出：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our `surfaceCreated()` method, we assign our reference variable rocks with
    our `Rock` class and we initialize the `rockStartTime` variable to take in the
    current `System.nanoTime()` as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`surfaceCreated()`方法中，我们将我们的引用变量`rocks`赋值为`Rock`类，并将`rockStartTime`变量初始化为当前`System.nanoTime()`，如下所示：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our update method, we address the real beast of *spawning rocks on the screen*.
    There are multiple things we are managing here so let's break them down further.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的更新方法中，我们处理屏幕上生成岩石的“真正难点”。这里有多个事情需要管理，所以让我们进一步分解它们。
- en: We will declare our `rockElapsed` variable, which keeps track of how much time
    the rock has been on the screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明我们的`rockElapsed`变量，它跟踪岩石在屏幕上停留的时间。
- en: Then, we define the frequency with which we want to spawn our rocks on the screen.
    You can manipulate this value in the `if` condition as you please according to
    the desired effects you want.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们希望在屏幕上生成岩石的频率。您可以根据所需的效应在`if`条件中随意操作这个值。
- en: Inside this `if` block, we have another nested `if` block which is essentially
    just to define where the rock will spawn. Here, we are defining the rock spawning
    in such a way that the first rock element is in the middle part of the screen,
    as you can see from the math calculations. Or if it is any other element than
    our first spawned rock, then we tell it to spawn randomly in any location where
    our `rnd` random variable comes into the picture.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if`块内部，我们还有一个嵌套的`if`块，其主要目的是定义岩石的生成位置。在这里，我们定义岩石的生成方式，使得第一个岩石元素位于屏幕的中间部分，正如您可以从数学计算中看到的那样。或者，如果它不是第一个生成的岩石元素，那么我们告诉它随机生成在任何位置，只要我们的`rnd`随机变量出现。
- en: We then define our collision logic. We will use a `for` loop here to run through
    all our rock objects on the screen, and if any element collides with our player
    character, then we pause the game.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的碰撞逻辑。在这里，我们将使用一个`for`循环来遍历屏幕上的所有岩石对象，如果任何元素与我们的玩家角色发生碰撞，那么我们将暂停游戏。
- en: Lastly, if the rock goes out of our defined screen space, then we `remove` the
    object from our `ArrayList`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果岩石超出我们定义的屏幕空间，那么我们就从我们的`ArrayList`中`remove`该对象。
- en: 'Let''s write the code for this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个写代码：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then move on to write our collision detection function. We do this based
    on the concept of the Bounding Box Collision technique that you learned about
    earlier in this chapter. You can easily observe from this code, `Rect.intersects(a.getRectangle(),
    b.getRectangle())`, that we are simply comparing the rectangles of both of our
    objects using the `Rect` class that is predefined in our `android.graphics.Rect`
    import. If there is an overlapping rectangle, then this function returns a `true`
    value; otherwise, it returns `false`. This function is of the return type `boolean`
    so it is important for it to `return` a `boolean` value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来编写我们的碰撞检测函数。我们这样做是基于你在本章前面学到的边界框碰撞技术。你可以很容易地从这段代码中观察到，`Rect.intersects(a.getRectangle(),
    b.getRectangle())`，我们只是使用预定义在我们的`android.graphics.Rect`导入中的`Rect`类来比较我们两个对象的矩形。如果存在重叠的矩形，那么这个函数返回一个`true`值；否则，它返回`false`。这个函数的返回类型是`boolean`，因此它返回一个`boolean`值是很重要的：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then finally, we draw our rock object on the screen. We do this again with
    a `for` loop and using our `draw()` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后，我们在屏幕上绘制我们的岩石对象。我们再次使用`for`循环和我们的`draw()`方法来完成：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will get our game equipped with our collision detection technique. After
    writing this code, it must be quite obvious how our collision technique is going
    to work in our game. We created a function with return type Boolean, which will
    detect collisions between the rectangles of our two objects, which we pass into
    it as references.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的游戏具备碰撞检测技术。编写完这段代码后，我们的碰撞技术在游戏中的工作方式应该非常明显。我们创建了一个返回类型为`Boolean`的函数，该函数将检测我们传递给它的两个对象的矩形之间的碰撞。
- en: Let's quickly review our code blocks one by one by listing down exactly what
    each code block is responsible for in our `GameView.java` file to get a better
    clarity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们的代码块，逐一列出每个代码块在`GameView.java`文件中的具体职责，以获得更好的清晰度。
- en: Defining our variables
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的变量
- en: 'We define our variables required by adding our desired variables, such as `rockStartTime`,
    `rocks`, and `rnd`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加我们想要的变量，如`rockStartTime`、`rocks`和`rnd`来定义所需的变量：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These variables give us references of objects to work with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量为我们提供了可以工作的对象引用。
- en: Tackling the infinite loop situation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决无限循环问题
- en: 'In our preceding code, there was a chance of running into an infinite loop
    and so we replace our retry and add in a counter for extra safety in case an infinite
    loop situation arises in our `surfaceDestroyed()` method. It is possible that
    our retry might return a `false` value or a `true` value during every run, and
    so there''s a chance of an infinite loop situation. To avoid this, we have this
    counter which increments every time the while loop is running and stops after
    that. You can go ahead and experiment to see what problems occur if you avoid
    using the counter for yourself:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的代码中，有可能遇到无限循环的情况，所以我们替换了重试并添加了一个计数器，以在`surfaceDestroyed()`方法中无限循环情况发生时提供额外的安全性。我们的重试可能在每次运行时返回一个`false`值或一个`true`值，因此有可能出现无限循环的情况。为了避免这种情况，我们有一个计数器，每次while循环运行时都会增加，并在之后停止。你可以自己尝试一下，看看如果不使用计数器会发生什么问题：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This tackles our infinite loop situation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们的无限循环问题。
- en: Initializing our variables
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化我们的变量
- en: 'After defining our variables, it is also essential to initialize them. We do
    so from our `surfaceCreated()` method as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义变量之后，初始化它们也是至关重要的。我们从`surfaceCreated()`方法中这样做，如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And that takes care of our variable values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理好了我们的变量值。
- en: Collision behavior
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞行为
- en: 'After this, we define what exactly will happen if there is a collision between
    two objects, which is defined in our `update()` method. We also address the situation
    if the rocks go out of the screen:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们定义了如果两个对象之间发生碰撞时会发生什么，这定义在我们的`update()`方法中。我们还处理了岩石飞出屏幕的情况：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our collision behavior is now ready.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了碰撞行为。
- en: Collision function
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞函数
- en: 'We defined our collision behavior, but it is also necessary that we write a
    logic that defines our collision itself. So, we make a collision detection function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了碰撞行为，但编写一个定义碰撞本身的逻辑也是必要的。因此，我们创建了一个碰撞检测函数：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our collision function is now ready.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的碰撞函数现在已经准备好了。
- en: Drawing our objects on the screen
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上绘制我们的对象
- en: 'Once we are done, we simply draw our object on the screen in our if a block
    of our`draw()` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成，我们只需在我们的`draw()`方法的`if`块中绘制我们的对象即可：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And that takes care of all the functionality needed to detect a collision.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理好了检测碰撞所需的所有功能。
- en: 'Now that we are done with our collision logic, let''s make a few tweaks to
    our player character. We have some unused variables there so let''s get rid of
    them and customize it a little further. Prior to this, they were needed to get
    an understanding how things work. But now they are pretty useless to us, so there''s
    no need for them to be lying around. Open up your `PlayerCharacter.java` and make
    the following changes to your code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了碰撞逻辑，让我们对我们的玩家角色做一些调整。那里有一些未使用的变量，所以让我们去掉它们，并进一步定制它。在此之前，它们是了解事物工作原理所必需的。但现在它们对我们来说几乎毫无用处，所以没有必要让它们随意存在。打开你的`PlayerCharacter.java`文件，对你的代码进行以下更改：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These are just minor tweaks which are quite self-explanatory and don''t require
    any separate explanation as such. Now that we have established all of this, we
    can finally test our collision technique! So, let''s go ahead and do that. Build
    your game and test it on your device or emulator. You will see something like
    this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是微小的调整，相当直观，不需要任何单独的解释。现在我们已经建立了所有这些，我们最终可以测试我们的碰撞技术了！所以，让我们继续前进，构建你的游戏，并在你的设备或模拟器上测试它。你将看到类似这样的东西：
- en: '![](img/B05066_06_03-1.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_06_03-1.png)'
- en: Hurray! Our rocks are on screen.... But wait, what?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！我们的岩石现在出现在屏幕上了……但是等等，发生了什么？
- en: So, the good news is that our rocks finally appear on the screen and the bad
    news is that they are all over the screen. We will address this situation shortly,
    but for now, we can get to test our collision functionality. As soon as our rocks
    collide with our player character the game will pause. We will now need to fix
    their frequency in order to control their spawning.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，好消息是我们的岩石终于出现在屏幕上了，坏消息是它们遍布整个屏幕。我们将很快解决这个问题，但现在我们可以测试我们的碰撞功能。一旦我们的岩石与玩家角色碰撞，游戏将暂停。现在我们需要调整它们的频率，以便控制它们的生成。
- en: 'Open up your `GameView.java` file and make the changes marked in bold. Remove
    all commented code marked in bold and add the `if(rocks.size() < 2)` statement
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`GameView.java`文件，对以下加粗的部分进行更改。删除所有加粗的注释代码，并添加以下`if(rocks.size() < 2)`语句：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We simply commented out our `rockElapsed` and `rockStartTime` variables and
    instead replaced our `if` condition with the `rocks.size()` condition, which tells
    our game to spawn only `2` rocks on the screen at any given time. This way, we
    get a control on the frequency of rocks spawned on the screen. You can tweak your
    frequency as you desire:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是注释掉了`rockElapsed`和`rockStartTime`变量，并用`rocks.size()`条件替换了我们的`if`条件，这个条件告诉游戏在任何给定时间内只生成`2`块岩石。这样，我们就控制了屏幕上生成的岩石频率。你可以根据需要调整你的频率：
- en: '![](img/B05066_06_04-1.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_06_04-1.png)'
- en: Okay, this looks better than the previous one
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这看起来比之前的好多了
- en: Of course, there is still the question of the appearance of the rock; this depends
    on the image that you use to create the sprite animation. But for now, we will
    move ahead with the further part. Also, note that in a similar way, you can also
    create collectible items such as coins so it is recommended for you create a coins
    class, which the player can collect and add to his score. Go ahead, experiment!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一个问题，那就是岩石的出现；这取决于你用来创建精灵动画的图像。但到目前为止，我们将继续进行下一步。此外，请注意，以类似的方式，你也可以创建可收集物品，如硬币，因此建议你创建一个硬币类，玩家可以收集并添加到他的分数中。继续前进，进行实验！
- en: Now let's learn about our next concept, that is artificial intelligence. Since
    we are not going to use any artificial intelligence in our game, we will just
    go through the concept of this topic. Our current game is a simple side scroller,
    which does not require any enemies as such. So, let's get started with artificial
    intelligence, or as many call it, AI And of course, if you come up with an idea
    to add enemies in the game then you can always use the concepts you learned from
    the previous chapters and couple them with the concept you are about to learn
    to come up with something cool!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来了解我们的下一个概念，那就是人工智能。由于我们游戏中不会使用任何人工智能，所以我们只需浏览一下这个主题的概念。我们当前的游戏是一个简单的横向卷轴游戏，不需要任何敌人。因此，让我们开始学习人工智能，或者像许多人所说的，AI。当然，如果你有在游戏中添加敌人的想法，那么你总是可以使用从前面章节中学到的概念，并将它们与你即将学习的概念结合起来，创造出一些酷炫的东西！
- en: Artificial Intelligence
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能
- en: '**Artificial Intelligence** (**A.I.**) is the study of systems being able to
    perform human tasks and automation without the requirement of human involvement.
    In games, this concept is widely used in order to create a real behavior for game
    enemies. Let''s understand the basic concept of A.I. in this chapter. This part
    of the chapter is going to be theory only so feel free to skip this part if you
    just want to focus on getting your game ready. However, it is highly recommended
    to go through this part because if you want to create A.I. in your game then the
    concepts from this part will come in handy.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**A.I.**）是研究能够执行人类任务和自动化，而不需要人类参与的系统的学科。在游戏中，这个概念被广泛用于为游戏敌人创建真实的行为。让我们在本章中了解人工智能的基本概念。这部分内容将是理论性的，所以如果你只想专注于准备你的游戏，可以自由跳过这部分。然而，强烈建议你阅读这部分内容，因为如果你想在游戏中创建人工智能，这部分的概念将会非常有用。'
- en: History of Artificial Intelligence
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能的历史
- en: In games, A.I. is used to create intelligent behaviors to objects that the user
    cannot control. This can be anything ranging from a dragon you see on the screen
    or simply a character that keeps following you. To put it simply, it is something
    that provides the means for a seemingly inanimate object to possess human-like
    intelligence. On a technical level, A.I. is the study of coming up with algorithms
    which include techniques from robotics, computer graphics, computer science, and
    control theory. There are many algorithms for creating a life-like A.I.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，人工智能被用来为用户无法控制的对象创建智能行为。这可以是屏幕上看到的龙，或者简单地是一个始终跟随你的角色。简单来说，它是一种为看似无生命的物体提供类似人类智能的手段。在技术层面上，人工智能是研究算法的学科，这些算法包括来自机器人学、计算机图形学、计算机科学和控制理论的技巧。有许多创建逼真人工智能的算法。
- en: 'The study of A.I. in games has been a part of this industry ever since its
    inceptions, as games provide one of the best ways to simulate artificial behavior
    in lifeless objects. However, if you take a look back at the 1950s era, you will
    observe that A.I. was relatively a simpler concept than what it has evolved into
    in today''s times. The game of Nim made in 1951 was the first examples of A.I.:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自从游戏行业诞生以来，游戏中的人工智能研究一直是这个行业的一部分，因为游戏提供了在无生命物体中模拟人工智能行为的一种最佳方式。然而，如果你回顾到20世纪50年代，你会观察到，与今天相比，人工智能是一个相对简单的概念。1951年制作的Nim游戏是人工智能的第一个例子：
- en: '![](img/B05066_06_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_06_05.jpg)'
- en: Game of Nim in 1951
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 1951年的Nim游戏
- en: 'This game was a simple Tic Tac Toe game, which demonstrated the very first
    example of A.I. while playing against the computer. The first notable ones for
    the arcade appeared in 1974: the Taito game, Speed Race (a racing video game),
    and the Atari games, Qwak (a duck hunting light gun shooter) and Pursuit (a fighter
    aircraft dogfighting simulator). Two text-based computer games from 1972, Hunt
    the Wumpus and Star Trek, also had enemies. Enemy movement was based on stored
    patterns. The incorporation of microprocessors would allow more computation and
    random elements overlaid into movement patterns. Let''s talk about some interesting
    A.I. algorithms.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏是一个简单的井字棋游戏，它展示了在对抗计算机时人工智能的第一个例子。1974年，在街机游戏中首次出现了几个引人注目的例子：Taito游戏《速度竞赛》（一款赛车视频游戏）、Atari游戏《Qwak》（一款鸭狩猎光枪射击游戏）和《Pursuit》（一款战斗机空战模拟器）。1972年的两款基于文本的计算机游戏《Hunt
    the Wumpus》和《Star Trek》也拥有敌人。敌人的移动基于存储的模式。微处理器的引入使得更多的计算和随机元素可以叠加到移动模式中。让我们来谈谈一些有趣的AI算法。
- en: Artificial Intelligence Algorithms
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能算法
- en: Algorithms for A.I. can include many aspects. Essentially, to break these down
    into simple terms, they are just search algorithms. Following are some of the
    most popular search algorithms, which can be implemented into A.I. logic. In between,
    there are pseudo codes for understanding these examples. Once you go through these,
    we can come up with some basic A.I. logic for our game if you wish to include
    it from your side.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能的算法可以包括许多方面。本质上，将这些分解成简单术语，它们只是搜索算法。以下是一些最流行的搜索算法，这些算法可以应用于人工智能逻辑。在中间，有一些伪代码用于理解这些示例。一旦你了解了这些，我们就可以为我们的游戏制定一些基本的AI逻辑，如果你愿意从你的角度加入的话。
- en: Breadth-First Search
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: This algorithm starts from the root node and then, after exploring all the neighboring
    nodes first, it moves toward the next level of neighbors, which returns the shortest
    path to our solution. It uses the FIFO queue data structure.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法从根节点开始，然后首先探索所有相邻节点，然后移动到下一层的相邻节点，这返回了到解决方案的最短路径。它使用先进先出（FIFO）队列数据结构。
- en: The disadvantage of this algorithm is that it consumes a lot of memory because
    each level of nodes is saved in order to create the next one.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的缺点是它消耗了大量的内存，因为为了创建下一个节点，必须保存每个层级的节点。
- en: 'Read more at: [https://en.wikipedia.org/wiki/Breadth-first_search](https://en.wikipedia.org/wiki/Breadth-first_search).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多：[https://en.wikipedia.org/wiki/Breadth-first_search](https://en.wikipedia.org/wiki/Breadth-first_search)
- en: Depth-First Search
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: The implementation of this algorithm is done using recursion with the LIFO stack
    data structure and it creates the same nodes as our first method but in a different
    order. The space requirement is quite linear since nodes on a single path are
    stored in each iteration from root-to-leaf node.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的实现使用递归和后进先出（LIFO）的栈数据结构，它创建与我们的第一种方法相同的节点，但顺序不同。由于每个迭代从根节点到叶节点存储节点，因此空间需求相当线性。
- en: The disadvantage of the algorithm is that there's a possibility that this algorithm
    may not terminate and go on infinitely on one path and in some cases the execution
    time increases. It can't check for duplicate nodes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的缺点是，有可能这个算法可能不会终止，并且在一个路径上无限期地继续，在某些情况下执行时间会增加。它不能检查重复节点。
- en: 'Read more at: [https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多：[https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search)
- en: Bidirectional search
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向搜索
- en: In this technique, the search is carried forward from the initial state and
    backward from the goal state until both are met to identify the common state and
    then the path from the initial state is concatenated with an inverse path from
    the goal state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，搜索从初始状态开始，并从目标状态反向进行，直到两者都满足以识别共同状态，然后从初始状态到目标状态的路径被连接起来。
- en: 'Read more at: [https://en.wikipedia.org/wiki/Bidirectional_search](https://en.wikipedia.org/wiki/Bidirectional_search)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多：[https://en.wikipedia.org/wiki/Bidirectional_search](https://en.wikipedia.org/wiki/Bidirectional_search)
- en: Uniform cost search
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致成本搜索
- en: In this algorithm, the sorting is done by increasing the cost of the path to
    a node and the node with the least cost is expanded. It is also popularly known
    as Dijkstra's algorithm.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，排序是通过增加节点到路径的成本来进行的，并且具有最低成本的节点被扩展。它也普遍被称为迪杰斯特拉算法。
- en: The disadvantage of this algorithm is that, since there can be multiple long
    paths, this technique must explore them all.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的缺点是，由于可能有多个长路径，这种技术必须探索它们所有。
- en: Read more at: [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多：[https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- en: Iterative deepening Depth-First Search
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代加深深度优先搜索
- en: A depth-first search to level 1 is performed and then the same is done on level
    2 and so on, until the solution is found. Until all the lower nodes are generated,
    a node is not created.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行到第1层的深度优先搜索，然后对第2层执行相同的操作，依此类推，直到找到解决方案。直到所有较低层节点生成，节点才不会被创建。
- en: 'Read more at: [https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多：[https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search)
- en: Comparison of preceding algorithms complexities
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前述算法复杂度比较
- en: 'Let''s take a look at some of the interesting results by comparing our first
    five algorithms. Here''s the performance of the algorithms based on various criteria:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过比较前五种算法来查看一些有趣的结果。以下是算法基于各种标准的性能：
- en: '| **Criteria** | **Breadth First** | **Depth ****First** | **Bidirectional**
    | **Uniform Cost** | **Deepening** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **标准** | **广度优先** | **深度优先** | **双向** | **一致成本** | **加深** |'
- en: '| Time | b^d | b^m | b^(d/2) | b^d | b^d |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | b^d | b^m | b^(d/2) | b^d | b^d |'
- en: '| Space | b^d | b^m | b^(d/2) | b^d | b^d |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 空间 | b^d | b^m | b^(d/2) | b^d | b^d |'
- en: '| Optimality | Yes | No | Yes | Yes | Yes |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 优化性 | 是 | 否 | 是 | 是 | 是 |'
- en: '| Completeness | Yes | No | Yes | Yes | Yes |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 完全性 | 是 | 否 | 是 | 是 | 是 |'
- en: A * search
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*搜索'
- en: This algorithm is the best known as the Best First search algorithm and is also
    widely used in games for pathfinding. Its performance is very efficient and expanding
    paths that are already expensive are avoided through this algorithm.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法最著名的是最佳优先搜索算法，并且在游戏中用于路径查找方面也广泛使用。它的性能非常高效，通过这个算法避免了扩展已经昂贵的路径。
- en: '`f(n) = g(n) + h(n)`, where `g(n)` the cost (so far) to reach the destination
    node, `h(n)` is the estimated cost to get from the node to the goal, and `f(n)` is
    the estimated total cost of the path through `n` to the goal. It is implemented
    using a priority queue by increasing `f(n)`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`f(n) = g(n) + h(n)`，其中`g(n)`是到达目标节点的成本（到目前为止），`h(n)`是从节点到目标估计的成本，而`f(n)`是通过`n`到目标的路径估计总成本。它是通过增加`f(n)`来使用优先队列实现的。'
- en: 'Read more at: [https://en.wikipedia.org/wiki/A*_search_algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅：[https://en.wikipedia.org/wiki/A*_search_algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)
- en: Creating your own Artificial Intelligence
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的人工智能
- en: 'Now, as for this game, we don''t really require any A.I. since most of our
    obstacles themselves are a big challenge for us. However, we can have some food
    for thought. Here''s an exercise for you. Using your knowledge gained in previous
    chapters, try to create an A.I. class for an enemy spawning, which will start
    shooting projectiles at you if it enters a certain radius. Here are your objectives
    for creating an A.I.:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于这个游戏，我们实际上并不需要人工智能，因为我们的大多数障碍本身对我们来说就是一个巨大的挑战。然而，我们可以有一些思考的食物。这里有一个练习给你。利用你在前几章中获得的知识，尝试创建一个用于生成敌人的AI类，如果它进入一定的半径，它将开始向你射击弹丸。以下是创建AI的目标：
- en: Spawn enemies from right side of the screen
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从屏幕右侧生成敌人
- en: Make them move in the left-hand direction
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让它们向左手方向移动
- en: Upon entering a certain radius, they will start shooting projectiles at you
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入一定半径后，它们将开始向你射击弹丸
- en: If you collide with the projectile, the game pauses
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你与弹丸相撞，游戏将暂停
- en: You can use your Rock.java class as a shooting projectile. You can have a monkey
    coming in from the side of the screen which starts throwing rocks at you if it
    enters a certain radius. Try this out by yourself; it'll be fun to see what you
    come up with!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你的Rock.java类作为射击弹丸。你可以有一个猴子从屏幕的侧面进入，如果它进入一定的半径，它将开始向你扔石头。自己试试看；看到你有什么想法会很有趣！
- en: So, that's about it for our collision and A.I. part of this book.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这本书关于碰撞和人工智能的部分就到这里了。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a great deal about the various collision techniques
    as well as multiple artificial intelligence algorithms. We now know how to create
    collisions based on the Bounding Box Collision technique.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了大量的各种碰撞技术以及多个人工智能算法。我们现在知道如何根据边界框碰撞技术创建碰撞。
- en: In the next chapter, we will add a ground for our player and understand how
    we can create explosions based on our collisions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的玩家添加地面，并了解我们如何根据我们的碰撞创建爆炸。
