- en: Collision Detection and Basic Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You learned an overview on how to play animations in our game, and now we are
    going to go a step further into this exciting journey of game development by learning
    one of the most complex yet crucial concepts required to make our game feel realistic.
    By adding animations, we can make our game look realistic, but it is also important
    for a game to feel realistic because that is what makes it fun to play. In this
    chapter, we will be taking a look at the following two concepts in further detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial intelligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, this chapter will be divided into two main sections. The studies of collision
    detection and artificial intelligence are in themselves quite vast topics. For
    the sake of simplicity to serve our purpose, we will be taking a look at the most
    basic version of these topics to get an entry level understanding for being able
    to apply the knowledge of these concepts in our game. So without further ado,
    let's dive into this complex yet exciting topic of collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explain it simply, collision is a short duration interaction between two
    bodies. There are many different types of collisions such as elastic and non-elastic.
    The study of the intersection of two or more objects overlapping each other is
    called as **collision detection**. It is one of the most complex pieces of computational
    mathematics and is divided into many types, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounding Box Collision:** This is the simplest form of collision techniques
    wherein we take two rectangles and check for collision if they overlap each other.
    For this, we need four coordinates of each rectangle, namely, the *x* and *y*
    position and width and height of both rectangles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circle Collision: **This is the second simplest type of collision wherein
    we test for collisions between two circles. Here, the radius of two circles and
    *x* and *y* position of the center of the circles are taken into account to test
    for overlapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separating Axis Theorem:** This type of collision is a bit more complex than
    the other two mentioned earlier, primarily because this is used to detect collisions
    between two polygons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are, of course, many other types of collisions, but that is a totally
    huge concept in itself. For the purpose of this book, we will be dealing with
    the simpler forms of collision, and based on the understanding of these concepts,
    you can experiment further with more complex collision types.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the algorithms for the three types of collisions you learned
    about.
  prefs: []
  type: TYPE_NORMAL
- en: These algorithms are just pseudo codes. Pseudo means false, which means these
    codes are not to be executed. They are just mentioned here for the purpose of
    understanding the different collision techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at each of them individually before resuming work on our game
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms for collision detection techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very essential that we get a foundation for understanding these collision
    techniques and therefore it is very important that we understand the way these
    techniques work. Let's take a look at the different algorithms for detecting collisions.
    We will be using these concepts in our game when we are dealing with collisions
    further in this chapter. Since we will only be working with the simple types in this
    book, we will only take a look at the algorithms for Bounding Box and Circle Collision
    Detection techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Bounding Box Collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in our preceding explanation points that Bounding Box Collision technique
    is one of the simplest. That''s because we are simply testing for between two
    rectangles. Consider the following pseudo code for a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, the mathematical operations required
    to detect a collision through this technique are quite simplistic. We are only
    working with basic `x`, `y` coordinates and `width` and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: Circle Collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yet another simple type of collision, this deals with mapping out the distance
    between the centers of two circles to detect a collision. Its algorithm goes as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe here, we have two circles. We then take their individual
    distances of `x` and `y` coordinates. After that, we take the square root of the
    sum of their squares. This is just the simple formula to calculate the distance
    between two circles. Then in our testing condition, we check if the distance is
    less than the sum of two circles.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the algorithms for collision detection,
    we are equipped to move ahead on detecting the collision in our game. Let's start
    with it!
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collisions in our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are dealing with a game here, we will be dealing with the theory with
    a practical application. So, let's a take up a task of studying collision techniques
    with an example of an approaching rock toward the player. Our game is a side scrolling
    game and therefore there will be multiple obstacles and collectibles heading our
    way. Through the simple Bounding Box Collision technique, we can detect collisions
    between our player and other objects and execute corresponding functions.
  prefs: []
  type: TYPE_NORMAL
- en: After we are done creating our incoming rocks, we will also create incoming
    coins so that the player can score points as well. However, before we proceed
    with this, we have to come up with a way for our player to avoid these obstacles
    too. We will be implementing collision detection wherein if the player collides
    with a rock then he will die. Thus, it is crucial for our player to jump. We will
    give our player jumping abilities on our touch input. So, let's get our player
    to jump!
  prefs: []
  type: TYPE_NORMAL
- en: Making our player jump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since in our further chapters, we will be spawning obstacles and coins randomly
    on the screen, we will modify our player to navigate up and down on the screen.
    So, let's say if you touch your screen, the player will go up and if you stop
    touching the screen, our player will go down. Let us take a look at the changes
    we need to implement in our code first and then understand them step by step by
    breaking them down. We will be working on the `GameView.java` file for this code
    portion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, our animation used to start as soon as the game started. But we
    need a little bit more control over our actions so we used our `getPlaying()`
    function to achieve this. Here''s how we will tackle this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We added a condition in our `update()` method that if our player is playing
    only then will we update our background image and player character. It simply
    means that the game won''t start without some signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will now use the `onTouchEvent()` to notify that our game has started as
    well as when to go up and when to go down. In the first condition inside our `onTouchEvent()`
    , we will check if we have a touch event on the screen. `ACTION_DOWN` means that
    the screen is touched.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this, if blocked, we will have another if block, which checks if the
    player is playing or not. If the player is not playing, then we set the `setPlaying()`
    function to set a `true` value, thereby starting the game loop which then starts
    the `update()` method because of our condition in step 1\. Otherwise, it will
    simply tell the player that the screen is touched and therefore our `up` Boolean
    variable is set to `true`, which means the player goes up.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we will write the `return true` statement, which is responsible
    for notifying about the touch event since our `onTouchEvent()` has a Boolean return
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define our condition for the player to go down. In our case, this simply
    means that the touch input is no longer received, which means our finger was lifted
    from the screen. `ACTION_UP` defines this event.
  prefs: []
  type: TYPE_NORMAL
- en: If this event takes place, then we set our `up` variable to `false` and therefore
    our player goes down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again write a `return true` statement for our event. Here''s what our
    code for `onTouchEvent()` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From this edit, we have only defined the calls required for setting the up
    and down functionality of our player. However, we also need to add acceleration
    and deceleration to our player in order to actually move up and down. We will
    achieve this by editing our `PlayerCharacter.java` file. Let''s write some jumping
    code in this file. Open it up and write the following code marked in bold in the
    `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This block of code is extremely easy to understand. Let''s break it down to
    get a proper grasp of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: We check if our `up` variable is true or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is `true` , then we add a positive acceleration value which *increases
    by 1.1* in every update. You can tweak these values as per your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is `false`, then we add a negative acceleration value which *decreases
    by 1.1* in every update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we don't want the acceleration or deceleration to go beyond a certain
    limit so we limit it to some bounds. In our case, we have kept a *maximum of 10
    and minimum of -10.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the double of our acceleration value to the `y` coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set our deceleration to 0 to reset it on our next `update()` call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can tweak the acceleration values to test for yourself and get comfortable
    with the desired speed. To change the speed of acceleration, simply change the
    values in `dyc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this will make our player jump with joy! Build your game and test it on
    your device or emulator. You will observe two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: The game is paused when you start it and will only play when you touch the screen.
    This is because of our if condition in our `GameView.java` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your player now moves up and down because of the acceleration values we provided
    in the `PlayerCharacter.java` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have established this, it's time to deal with oncoming obstacles
    and dodge them! Oh, and also learn about collisions in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Dodging incoming rocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very first thing we would need before we proceed with anything is a nice
    looking piece of rock. Not kidding, really! We need an image of a toony-looking
    rock, which would fit with the theme of our game. So, let''s get a rock for ourselves. For
    the purpose of this chapter, we will be using this rock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: This is our basic rock
  prefs: []
  type: TYPE_NORMAL
- en: As we had done in our previous part, we will need animation for the rock and
    so we will create a sprite sheet of the rock we have. Then, we will simply name
    it as `rock.png` and get started with it. It would be cool to have a rolling rock
    since that would make more sense in the game, and so we will use a rolling rock
    sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Our rock.png sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as we saw before, this rock is also just an image and will be placed
    inside the `res/drawable` folder as we did before. So, pick up any rock and place
    it into the `res/drawable` folder to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, since we are going to deal with a new object it must be pretty clear by
    this point that we would need to create a new class. So let''s go ahead and do
    that. Create a new class and name it `Rock.java`. This will have all our code
    for our obstacle rock. You will then have a blank java file in which you will
    need to extend it to our `GameObj.java` file like every other game object in our
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now gear up! We are going to do some heavy duty coding on this one. Let''s
    take a look at this step by step. We will need three methods in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Constructor`: This will have the parameters for our rock, such as the `x`,
    `y` positions, `width`, `height`, `score`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update` method: This is the method, as seen earlier, that gets called in every
    frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Draw` method: This method is responsible for actually drawing our object on
    the screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin with our constructor and variables. We will need a `score` and
    `speed` variable as well as a variable for `Bitmap` and our predefined `AnimationClass`,
    since we will be animating this rock as well. Let''s do that. We will start with
    the variables first. We will declare our variables that will be needed for the
    game, which includes `score`, `speed`, our `animationClass` reference, and `spriteSheet`
    reference. We have also taken a `Random` number reference variable to generate
    a score based on a unique condition in the game loop that you will see shortly.
    Currently, we are not displaying the score on the screen but soon you will see
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will write our constructor. There are a bunch of parameters needed for
    the constructor such as the `x`, `y` coordinates, `width`, `height`, `score`,
    and `noOfFrames`. We basically take their reference as parameters to our method
    and hence we require `xc`, `yc`, `w`, `h`, `s`, and `noOfFrames` as parameters
    in our constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we actually need our rock to go faster once we survive for a longer
    time and hence we will write the code in such a way that, as our score increases,
    our rocks will become faster. We will use a little bit of math for this, wherein
    we will use our random variable. Basically, this will be our formula: `speed =
    7 + (int) (rnd.nextDouble()*score/30);`. Then we will set our Bitmap reference
    variable so it can scan through our sprite sheet followed by a `for` loop to scan
    through the same. And finally, we will set our frames to our `animationClass`
    and add a delay for our animation to play. Let''s see how that works out in our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the code, we did nothing new but simply created our rock game
    object and its drawing on the screen method. It's the same thing that we did with
    our `PlayerCharacter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our constructor is ready, we can move on to write our code for the `update()`
    and `draw()` methods. In our `update()` method, we don''t need to do much. We''ll
    only be moving our rock from right to left, and hence we''ll use our `speed` variable
    to just shift our rock certain units in every frame toward the left. We will use
    the `draw()` method to simply draw our rock on the screen with the help of the
    `animationClass` reference variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we simply created our `update()` method
    and shifted our rock certain units on the left with our `speed` variable. After
    that, immediately we gave a call to the `update()` method of `animationClass`
    so that the sprite sheet of the rock gets updated and we get an effect as though
    the rock is rolling as it moves.
  prefs: []
  type: TYPE_NORMAL
- en: We then simply used the `drawBitmap()` method to draw our rock on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We created our object, and now it's time for us to display it on the screen,
    and once we are done with that objective, we will move on to detecting the collision
    when it collides with our player.
  prefs: []
  type: TYPE_NORMAL
- en: We will now create our rocks on the `GameView.java` file, which will spawn rocks
    at continuous intervals. Also, when our player collides with our rocks it will
    pause the game. So, let's open up our `GameView.java` file and get started with
    writing the code for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create three new reference variables, `rockStartTime`, `rocks`, and
    `rnd`, which correspond to the start time of our rock game object, our actual
    rock game object, and a random variable for the purpose of randomizing the spawn
    location of the rocks on the screen. Since we are going to be spawning multiple
    rocks on the screen, we took its data type to be an `ArrayList` since dynamic
    arrays can be supported through an `ArrayList`. We will be needing this primarily
    because after our rocks have left the screen space, we will remove them, thereby having
    proper memory management of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will improvise a bit on our `surfaceDestroyed()` method and create a `counter`
    as well as shift our `retry` variable block in order to avoid an infinite loop
    situation. Code changes are marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `surfaceCreated()` method, we assign our reference variable rocks with
    our `Rock` class and we initialize the `rockStartTime` variable to take in the
    current `System.nanoTime()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In our update method, we address the real beast of *spawning rocks on the screen*.
    There are multiple things we are managing here so let's break them down further.
  prefs: []
  type: TYPE_NORMAL
- en: We will declare our `rockElapsed` variable, which keeps track of how much time
    the rock has been on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the frequency with which we want to spawn our rocks on the screen.
    You can manipulate this value in the `if` condition as you please according to
    the desired effects you want.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `if` block, we have another nested `if` block which is essentially
    just to define where the rock will spawn. Here, we are defining the rock spawning
    in such a way that the first rock element is in the middle part of the screen,
    as you can see from the math calculations. Or if it is any other element than
    our first spawned rock, then we tell it to spawn randomly in any location where
    our `rnd` random variable comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: We then define our collision logic. We will use a `for` loop here to run through
    all our rock objects on the screen, and if any element collides with our player
    character, then we pause the game.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the rock goes out of our defined screen space, then we `remove` the
    object from our `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then move on to write our collision detection function. We do this based
    on the concept of the Bounding Box Collision technique that you learned about
    earlier in this chapter. You can easily observe from this code, `Rect.intersects(a.getRectangle(),
    b.getRectangle())`, that we are simply comparing the rectangles of both of our
    objects using the `Rect` class that is predefined in our `android.graphics.Rect`
    import. If there is an overlapping rectangle, then this function returns a `true`
    value; otherwise, it returns `false`. This function is of the return type `boolean`
    so it is important for it to `return` a `boolean` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then finally, we draw our rock object on the screen. We do this again with
    a `for` loop and using our `draw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will get our game equipped with our collision detection technique. After
    writing this code, it must be quite obvious how our collision technique is going
    to work in our game. We created a function with return type Boolean, which will
    detect collisions between the rectangles of our two objects, which we pass into
    it as references.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly review our code blocks one by one by listing down exactly what
    each code block is responsible for in our `GameView.java` file to get a better
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define our variables required by adding our desired variables, such as `rockStartTime`,
    `rocks`, and `rnd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These variables give us references of objects to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling the infinite loop situation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our preceding code, there was a chance of running into an infinite loop
    and so we replace our retry and add in a counter for extra safety in case an infinite
    loop situation arises in our `surfaceDestroyed()` method. It is possible that
    our retry might return a `false` value or a `true` value during every run, and
    so there''s a chance of an infinite loop situation. To avoid this, we have this
    counter which increments every time the while loop is running and stops after
    that. You can go ahead and experiment to see what problems occur if you avoid
    using the counter for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This tackles our infinite loop situation.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After defining our variables, it is also essential to initialize them. We do
    so from our `surfaceCreated()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And that takes care of our variable values.
  prefs: []
  type: TYPE_NORMAL
- en: Collision behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After this, we define what exactly will happen if there is a collision between
    two objects, which is defined in our `update()` method. We also address the situation
    if the rocks go out of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our collision behavior is now ready.
  prefs: []
  type: TYPE_NORMAL
- en: Collision function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We defined our collision behavior, but it is also necessary that we write a
    logic that defines our collision itself. So, we make a collision detection function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our collision function is now ready.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing our objects on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are done, we simply draw our object on the screen in our if a block
    of our`draw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: And that takes care of all the functionality needed to detect a collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are done with our collision logic, let''s make a few tweaks to
    our player character. We have some unused variables there so let''s get rid of
    them and customize it a little further. Prior to this, they were needed to get
    an understanding how things work. But now they are pretty useless to us, so there''s
    no need for them to be lying around. Open up your `PlayerCharacter.java` and make
    the following changes to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These are just minor tweaks which are quite self-explanatory and don''t require
    any separate explanation as such. Now that we have established all of this, we
    can finally test our collision technique! So, let''s go ahead and do that. Build
    your game and test it on your device or emulator. You will see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_06_03-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Hurray! Our rocks are on screen.... But wait, what?
  prefs: []
  type: TYPE_NORMAL
- en: So, the good news is that our rocks finally appear on the screen and the bad
    news is that they are all over the screen. We will address this situation shortly,
    but for now, we can get to test our collision functionality. As soon as our rocks
    collide with our player character the game will pause. We will now need to fix
    their frequency in order to control their spawning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your `GameView.java` file and make the changes marked in bold. Remove
    all commented code marked in bold and add the `if(rocks.size() < 2)` statement
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply commented out our `rockElapsed` and `rockStartTime` variables and
    instead replaced our `if` condition with the `rocks.size()` condition, which tells
    our game to spawn only `2` rocks on the screen at any given time. This way, we
    get a control on the frequency of rocks spawned on the screen. You can tweak your
    frequency as you desire:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_06_04-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, this looks better than the previous one
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is still the question of the appearance of the rock; this depends
    on the image that you use to create the sprite animation. But for now, we will
    move ahead with the further part. Also, note that in a similar way, you can also
    create collectible items such as coins so it is recommended for you create a coins
    class, which the player can collect and add to his score. Go ahead, experiment!
  prefs: []
  type: TYPE_NORMAL
- en: Now let's learn about our next concept, that is artificial intelligence. Since
    we are not going to use any artificial intelligence in our game, we will just
    go through the concept of this topic. Our current game is a simple side scroller,
    which does not require any enemies as such. So, let's get started with artificial
    intelligence, or as many call it, AI And of course, if you come up with an idea
    to add enemies in the game then you can always use the concepts you learned from
    the previous chapters and couple them with the concept you are about to learn
    to come up with something cool!
  prefs: []
  type: TYPE_NORMAL
- en: Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial Intelligence** (**A.I.**) is the study of systems being able to
    perform human tasks and automation without the requirement of human involvement.
    In games, this concept is widely used in order to create a real behavior for game
    enemies. Let''s understand the basic concept of A.I. in this chapter. This part
    of the chapter is going to be theory only so feel free to skip this part if you
    just want to focus on getting your game ready. However, it is highly recommended
    to go through this part because if you want to create A.I. in your game then the
    concepts from this part will come in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: History of Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In games, A.I. is used to create intelligent behaviors to objects that the user
    cannot control. This can be anything ranging from a dragon you see on the screen
    or simply a character that keeps following you. To put it simply, it is something
    that provides the means for a seemingly inanimate object to possess human-like
    intelligence. On a technical level, A.I. is the study of coming up with algorithms
    which include techniques from robotics, computer graphics, computer science, and
    control theory. There are many algorithms for creating a life-like A.I.
  prefs: []
  type: TYPE_NORMAL
- en: 'The study of A.I. in games has been a part of this industry ever since its
    inceptions, as games provide one of the best ways to simulate artificial behavior
    in lifeless objects. However, if you take a look back at the 1950s era, you will
    observe that A.I. was relatively a simpler concept than what it has evolved into
    in today''s times. The game of Nim made in 1951 was the first examples of A.I.:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Game of Nim in 1951
  prefs: []
  type: TYPE_NORMAL
- en: 'This game was a simple Tic Tac Toe game, which demonstrated the very first
    example of A.I. while playing against the computer. The first notable ones for
    the arcade appeared in 1974: the Taito game, Speed Race (a racing video game),
    and the Atari games, Qwak (a duck hunting light gun shooter) and Pursuit (a fighter
    aircraft dogfighting simulator). Two text-based computer games from 1972, Hunt
    the Wumpus and Star Trek, also had enemies. Enemy movement was based on stored
    patterns. The incorporation of microprocessors would allow more computation and
    random elements overlaid into movement patterns. Let''s talk about some interesting
    A.I. algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: Artificial Intelligence Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithms for A.I. can include many aspects. Essentially, to break these down
    into simple terms, they are just search algorithms. Following are some of the
    most popular search algorithms, which can be implemented into A.I. logic. In between,
    there are pseudo codes for understanding these examples. Once you go through these,
    we can come up with some basic A.I. logic for our game if you wish to include
    it from your side.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-First Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This algorithm starts from the root node and then, after exploring all the neighboring
    nodes first, it moves toward the next level of neighbors, which returns the shortest
    path to our solution. It uses the FIFO queue data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this algorithm is that it consumes a lot of memory because
    each level of nodes is saved in order to create the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more at: [https://en.wikipedia.org/wiki/Breadth-first_search](https://en.wikipedia.org/wiki/Breadth-first_search).'
  prefs: []
  type: TYPE_NORMAL
- en: Depth-First Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of this algorithm is done using recursion with the LIFO stack
    data structure and it creates the same nodes as our first method but in a different
    order. The space requirement is quite linear since nodes on a single path are
    stored in each iteration from root-to-leaf node.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of the algorithm is that there's a possibility that this algorithm
    may not terminate and go on infinitely on one path and in some cases the execution
    time increases. It can't check for duplicate nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more at: [https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search)'
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this technique, the search is carried forward from the initial state and
    backward from the goal state until both are met to identify the common state and
    then the path from the initial state is concatenated with an inverse path from
    the goal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more at: [https://en.wikipedia.org/wiki/Bidirectional_search](https://en.wikipedia.org/wiki/Bidirectional_search)'
  prefs: []
  type: TYPE_NORMAL
- en: Uniform cost search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this algorithm, the sorting is done by increasing the cost of the path to
    a node and the node with the least cost is expanded. It is also popularly known
    as Dijkstra's algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this algorithm is that, since there can be multiple long
    paths, this technique must explore them all.
  prefs: []
  type: TYPE_NORMAL
- en: Read more at: [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
  prefs: []
  type: TYPE_NORMAL
- en: Iterative deepening Depth-First Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A depth-first search to level 1 is performed and then the same is done on level
    2 and so on, until the solution is found. Until all the lower nodes are generated,
    a node is not created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more at: [https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search)'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of preceding algorithms complexities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of the interesting results by comparing our first
    five algorithms. Here''s the performance of the algorithms based on various criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Criteria** | **Breadth First** | **Depth ****First** | **Bidirectional**
    | **Uniform Cost** | **Deepening** |'
  prefs: []
  type: TYPE_TB
- en: '| Time | b^d | b^m | b^(d/2) | b^d | b^d |'
  prefs: []
  type: TYPE_TB
- en: '| Space | b^d | b^m | b^(d/2) | b^d | b^d |'
  prefs: []
  type: TYPE_TB
- en: '| Optimality | Yes | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Completeness | Yes | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: A * search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This algorithm is the best known as the Best First search algorithm and is also
    widely used in games for pathfinding. Its performance is very efficient and expanding
    paths that are already expensive are avoided through this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '`f(n) = g(n) + h(n)`, where `g(n)` the cost (so far) to reach the destination
    node, `h(n)` is the estimated cost to get from the node to the goal, and `f(n)` is
    the estimated total cost of the path through `n` to the goal. It is implemented
    using a priority queue by increasing `f(n)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more at: [https://en.wikipedia.org/wiki/A*_search_algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, as for this game, we don''t really require any A.I. since most of our
    obstacles themselves are a big challenge for us. However, we can have some food
    for thought. Here''s an exercise for you. Using your knowledge gained in previous
    chapters, try to create an A.I. class for an enemy spawning, which will start
    shooting projectiles at you if it enters a certain radius. Here are your objectives
    for creating an A.I.:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn enemies from right side of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make them move in the left-hand direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon entering a certain radius, they will start shooting projectiles at you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you collide with the projectile, the game pauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use your Rock.java class as a shooting projectile. You can have a monkey
    coming in from the side of the screen which starts throwing rocks at you if it
    enters a certain radius. Try this out by yourself; it'll be fun to see what you
    come up with!
  prefs: []
  type: TYPE_NORMAL
- en: So, that's about it for our collision and A.I. part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a great deal about the various collision techniques
    as well as multiple artificial intelligence algorithms. We now know how to create
    collisions based on the Bounding Box Collision technique.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add a ground for our player and understand how
    we can create explosions based on our collisions.
  prefs: []
  type: TYPE_NORMAL
