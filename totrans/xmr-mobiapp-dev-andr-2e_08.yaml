- en: Chapter 8. Creating Data Storage Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now turn our attention to data storage requirements. We need a way to store
    a list of **Point of Interest** (**POI**) data fetched from the server and make
    the list accessible when a device runs offline. This chapter shows how to use
    the built-in SQLite database engine to store and retrieve the POI data in a cross-platform
    way. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Approaches to data storage solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different app storage options in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using preferences to store key-value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite database storage in Xamarin.Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SQLite.NET ORM component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing database CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing the Android app using NUnitLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing caching to `POIApp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data storage solutions mainly fall into two general categories: storing in
    Cloud using web services or using the device''s local storage. Saving data in
    the Cloud provides great advantages over local data storage options, but in certain
    cases, such as apps that run offline or for games, generally you are required
    to store the data locally in the device''s storage.'
  prefs: []
  type: TYPE_NORMAL
- en: The current `POIApp` uses web services to store the POI list in the server,
    and the mobile app retrieves the list by making REST API calls. So far, it works
    great. However, it always requires an Internet connection to fetch and display
    the POI list. Let's overcome this problem by storing the list of POIs locally
    and accessing them even when the device is offline.
  prefs: []
  type: TYPE_NORMAL
- en: Data storage in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android supports several solutions that can be used for persisting data locally.
    The persisted data can be accessible even when the application shuts down or when
    a device restarts. The examples of such data include the device settings, contacts
    list, browser bookmarks, or any such app-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table depicts the different data storage options available in
    the Android platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage options
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: Shared preferences
  prefs: []
  type: TYPE_NORMAL
- en: This is the private data storage for your application that persists primitive
    key-value data pairs only. When the user uninstalls the application, this data
    is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Internal storage
  prefs: []
  type: TYPE_NORMAL
- en: This stores data in the device internal memory and is available until the app
    is uninstalled from the device. This data is private to your application and other
    apps cannot access it.
  prefs: []
  type: TYPE_NORMAL
- en: External file storage
  prefs: []
  type: TYPE_NORMAL
- en: This stores data in shared external storage such as an external SD card. The
    data stored is public. Other applications or users can access these files by connecting
    the device to a computer.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite storage
  prefs: []
  type: TYPE_NORMAL
- en: This is a structured private data store. SQLite databases created from an app
    can only be accessed from the same application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter briefly covers the shared preferences and SQLite storage options
    only. You can research the internal and external storage options on your own from
    the official Xamarin website.
  prefs: []
  type: TYPE_NORMAL
- en: Shared preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shared preferences are persistence **key/value** data pairs that are used to
    store primitive data pairs, such as **bool**, **float**, **int**, **string**,
    and **long**. The data saved in the Android preference is persisted across different
    app sessions and is private to the application it has created. Any other application
    cannot access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For using shared preferences to save data pairs, you first need to get an instance
    of the `ISharedPreferences` interface. A shared preference can be specific to
    an activity or made global to all the activities in the application. If you want
    to create a single preference file specific to an activity, you can use `Activity.GetPreferences`
    to get an instance of the `ISharedPreferences` interface, or you can call the
    `GetSharedPreferences` method on the application context by passing the preference
    name and mode of operation to get the application level preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call the `Edit()` method to get an instance of `ISharedPreferencesEditor`.
    This matches all of the changes made to values in shared preferences and only
    saves when a call to `Commit()` or `Apply()` is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To read values from shared preferences, we can use the `GetXX()` methods by
    providing the same key that was used while saving data, where `XX` represents
    the supported primitive types. The following code snippet retrieves the values
    stored in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The SQLite database storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is an open source, lightweight, and transactional database engine shipped
    with mobile platforms including Android, iOS, and Windows phones. According to
    the official documentation, Android is using **SQLite Version 3.4.0**. It is a
    widely used, standalone, relational database engine that requires no separate
    server process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the advantages that make the SQLite database engine
    one of the most shipped database engines today:'
  prefs: []
  type: TYPE_NORMAL
- en: It is an open source project and a large open source community is actively working
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't have a server, so it requires no server infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a lightweight engine that provides a set of classes to perform database
    transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete database is a single file stored in the device memory that is private
    to your application. The privacy of the SQLite database boils down to the platform
    filesystem privacy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As such, we have decided to go with SQLite for caching the POI list. When the
    list is downloaded successfully, we will save the POI in the database and update
    it periodically whenever the download is successful. When a device runs offline
    or is unable to fetch the updated list from the server, the cached POI list can
    be presented on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Although SQLite is built in Android and provides a set of APIs to perform all
    the database CRUD (Create, Read, Update, and Delete) operations, we will use the
    SQLite.ORM component from the component store. The following section walks you
    through the steps to perform different database operations using the SQLite.ORM
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SQLite.net ORM component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite.NET **Object Relational Mapping** (**ORM**) is an open source library
    that allows .NET and Mono applications to store data objects in the SQLite database.
    It is a lightweight and easy to use component that allows you to save and retrieve
    data objects, without having to worry about writing any SQL query. This is a free
    component available in the Xamarin Component Store. It was earlier designed to
    work for MonoTouch on iPhone, but later it was extended to support other platforms,
    including Android, Windows, and Silverlight platforms. Thanks to **Frank A. Krueger**
    for developing and maintaining this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to add SQLite.NET ORM to the Xamarin application. Either
    you can add it by downloading the required files from the GitHub open source code
    repository, NuGet, or the Xamarin Component Store:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite.NET is a very thin library with a single file. Download the `SQLite.cs`
    file from GitHub and add it to your application. The SQLite.NET library binds
    directly to the SQLite database engine on each platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add it from the Xamarin Component Store, you need to follow the same steps
    we used while adding the `UrlImageViewHelper` component in Chapter 4, *Adding
    a List View*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add it as a NuGet package bundle, you can navigate to **Packages** | **Add
    packages** from your Solution Explorer to open the NuGet gallery window. Search
    for `SQlite.NET` and select it to add it to your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the reference to the SQlite.NET ORM component is added to the project,
    we can focus on performing database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Using attributes to mark POIApp to be persisted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLite.NET ORM brings a set of attributes that allows you to mark classes and
    fields that are to be persisted to the database. You can apply any of the following
    attributes to control the construction of a table:'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`Table`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the class names are used as table names. You can use this attribute
    if you want to specify your own table name. This is an optional attribute applied
    to a class.
  prefs: []
  type: TYPE_NORMAL
- en: '`Column`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the property names are used as column names. This attribute provides
    you the control to specify your own column name.
  prefs: []
  type: TYPE_NORMAL
- en: '`PrimaryKey`'
  prefs: []
  type: TYPE_NORMAL
- en: This property is the primary key of the table. Only single-column primary keys
    are supported.
  prefs: []
  type: TYPE_NORMAL
- en: '`AutoIncrement`'
  prefs: []
  type: TYPE_NORMAL
- en: This property is automatically generated by the database upon insert. The property
    type should be an integer and should also be marked with the `PrimaryKey` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`Indexed`'
  prefs: []
  type: TYPE_NORMAL
- en: This property should have an index created for it.
  prefs: []
  type: TYPE_NORMAL
- en: '`Unique`'
  prefs: []
  type: TYPE_NORMAL
- en: This property will be unique in the table.
  prefs: []
  type: TYPE_NORMAL
- en: '`MaxLength`'
  prefs: []
  type: TYPE_NORMAL
- en: This property specifies the `varchar` max size. The default max length is `140`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ignore`'
  prefs: []
  type: TYPE_NORMAL
- en: This property will not be in the table.
  prefs: []
  type: TYPE_NORMAL
- en: '`NotNull`'
  prefs: []
  type: TYPE_NORMAL
- en: This property cannot be left null.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `POIApp`, let''s use some of the attributes from the preceding list of
    the `PointOfInterest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, notice that we declared that the table name will
    be `POITable`, the `Id` field is marked as the primary key, and the `Name` field
    cannot be null.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a database helper class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to create a standard class that will define the set of methods to
    allow basic CRUD operations. This class is likely to be accessed multiple times;
    therefore, we will mark this class as a singleton class to prevent multiple instances
    of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the database helper implementation class, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `DBManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the `DBManager` class a singleton class, first declare the default
    constructor private:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now declare a private static instance of the `DBManager` class and do the early
    initialization. We need to add a static getter method to make the `DBManager`
    class accessible. Add the following code snippet to the `DBManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are different ways to create a singleton class. I have chosen
    to use the singleton class using the *early initialization* method. For more information
    on singleton class implementation, follow the MSDN developer site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before saving the data, we need to first create a database. Let''s create a
    blank database or open an existing one by passing the file path to the `SQLiteConnection`
    class constructor. Add the following `CreateTable()` method to your `DBManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the following in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `DB_NAME` constant defines a name for the database. The database file will
    be created with this name and saved to the location specified in the path variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQLite database file path can be different for different platforms. Both
    Android and iOS use the environment class to construct a valid path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SQLiteConnection` class constructor opens the database if it already exists
    with the specified name, or else it creates a new database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CreateTable()` method opens the table if it exists, or else it creates
    a new table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating or updating the POI record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once your database connection is open, we can perform different database operations.
    To begin with, let's create a method named `SavePOI()` to save the POI object
    in the database. The `SQLiteConnection` class provides methods, such as **Insert**,
    `InsertOrReplace`, `InsertAll`, `Update`, and `UpdateAll`, to create or update
    a record in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `InsertOrReplace` method, as it is convenient for us. This method
    looks up for the same record in the database, updates it if it already exists,
    or else inserts a new one. For the `InsertOrReplace()` method to work, your table
    must have a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following code snippet to the `DBManager` class in the `SavePOI`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Reading POI details from the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `POIApp` reads the list of POI objects while the device runs in the offline
    mode, or if the app has failed to download the POI list data from the server.
    Add the following `GetPOIListFromCache()` method to retrieve all the records from
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetPOIListFromCache` method returns the list of all POIs available in
    the database. The following method will help you if you are looking for a particular
    POI by its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Deleting the POI data from the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like reading records from a database, we can either clear all of the database
    records or delete records one by one by the POI ID. Add the following methods
    to the `DBManager` class. They are straightforward and quite self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined all the methods to perform different database operations.
    The next step is to validate each method by writing unit test cases before using
    them in `POIApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Xamarin.Android NUnitLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be familiar with a process called **test-driven development** (**TDD**).
    At a high-level, the approach proposes that you create automated unit test cases
    to test the features that your software will need to support, and use these test
    cases to drive the development and unit testing cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will not cover the concepts behind test-driven development in detail,
    but we will introduce a feature delivered with Xamarin.Android, which supports
    teams using TDD. This feature is **NUnitLite**. NUnitLite is a lightweight, open
    source testing framework, which is based on the same ideas as **NUnit**. This
    has been designed to use minimal resources, making it ideal for embedded and mobile
    software development.
  prefs: []
  type: TYPE_NORMAL
- en: When working with NUnitLite, you create classes called test fixtures. These
    classes contain test methods that are used to test the various facets of the testing
    target; in our case, the `DBManager` class. To designate a class as a test fixture
    or a method as a test method, NUnitLite uses the .NET attributes. Once the test
    fixtures and test methods have been created, Xamarin.Android provides a user interface
    that allows the tests to be executed within the Android emulator or on a device.
  prefs: []
  type: TYPE_NORMAL
- en: To start using NUnitLite, we need to create a test project in the Solution pad
    that we have been working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a test project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `POIApp` solution from the **Solution** pad in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Add New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side of the **New Project** dialog box, go to **C#** | **Android**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the template list, in the middle of the dialog box, select the **Android
    Unit Test** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `POITestApp` for the name and click on **OK**. The new unit test project
    is created and added to the `POIApp` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Options** dialog box for the new project, and set the **Package**
    name to `POITestApp`, and verify that the **Target framework** is set to the latest
    available Android SDK framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that the new unit test project has the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity.cs`: This activity inherits from `TestSuiteActivity` and provides
    a test suite user interface when we run our tests. Basically, it allows us to
    run our tests and see the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestsSample.cs`: This class acts as a test fixture and allows us to add test
    methods that will exercise the features provided by `DBManager`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we need to create the test methods in order to exercise the features of
    our database operation performed by the `DBManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NUnitLite provides a place to execute any initialization code that may be required
    by the tests. In our case, we need to create an instance of the `DBManager` class,
    which the test methods will later interact with. The `Setup()` method is the perfect
    place since it will be called before each test. The following will steps help
    you to set up a new test case in Xamarin Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the `TestsSample.cs` file `POITestFixture.cs`. Rename the corresponding
    class inside the file as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `POITestApp`, select **References**, right-click on it, and select **Edit
    References**. Select the **Projects** tab in the **Edit References** dialog box,
    check on the `POIApp` project, and click on **OK**. `POITestApp` needs to reference
    `POIApp` so that it can work with the `DBManager` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Some version of Xamarin Studio have a bug, where the project references are
    not linked even after adding them to a test project. In such cases, you need go
    to the .NET Assembly tab in the **Edit References** dialog box and browse manually
    to the `POIApp/bin/Debug/POIApp.dll` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `POITestFixture` class and delete all the other methods except `Setup()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Setup()` method, call the `CreateTable()` method from the `DBManager`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the test methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now the real work begins; we need to create test methods to test each significant
    scenario. In the case of the data service, we need to be sure that we cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new POI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an existing POI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an existing POI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more scenarios we could choose to test, but the preceding small
    set should help you verify that the basics of our database logic are functioning.
  prefs: []
  type: TYPE_NORMAL
- en: The CreatePOI test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first test method we will start with is `CreatePOI()` and, as the name
    implies, we will test the process of creating and saving a new POI. To accomplish
    this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new instance of `PointOfInterest` and fill out some attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `SavePOI()` method on the `DBManager` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `save` method returns an integer, indicating the number of records updated.
    Ensure that it returns the value `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `GetPOI()` to retrieve the POI, based on the saved ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Assert` class to ascertain that the POI was retrieved (the reference
    is not null) and the name of the POI is what it was expected to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows an implementation of `CreatePOI()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The DeletePOI test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we will implement `DeletePOI()`. Again, we want `DeletePOI()` to be independent
    of other tests, so we will first need to create a POI which will be deleted later.
  prefs: []
  type: TYPE_NORMAL
- en: 'On calling `DeletePOI()`, the following steps will be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new instance of `PointOfInterest` and fill out some attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `SavePOI()` method on the `DBManager` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetPOI()` to retrieve the POI, based on the saved ID.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DeletePOI()` to delete the POI file and remove it from the database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetPOI()` to retrieve the POI, based on the saved ID.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Assert` class to ensure that the POI is not found (the reference is
    null).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows an implementation of `DeletePOI()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we will implement `ClearCache()` to verify that the call to `ClearPOICache()`
    clears all the database records. We will perform the following steps will be performed
    in the `ClearCache` test method:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `ClearPOICache()` on the `DBManager` class to delete all records from the
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `GetPOIListFromCache` on the `DBManager` class to get a list of records
    from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Assert` class to ensure that the number of records fetched from the
    server is `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows an implementation of `ClearCache()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Executing the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the tests have been developed, we are ready to execute them. To do
    this, we simply run the test app using the Android emulator or a physical device.
    To execute the tests in an emulator, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `POITestApp` using the Android emulator. Note that `POITestApp` is not set
    as the startup project, so you will need to select the project when you select
    **Run**. You can make `POITestApp` the startup project by selecting it, right-clicking
    on it, and choosing **Set as Startup Project**. Once `POITestApp` is running,
    you should see the following screen when the app has been deployed and started:![](img/U0zngXrn.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the tests by clicking on the **Run Tests** label. You should see a green
    message label, indicating that all the tests have passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the test case fails, the message will be shown in red, and you can further
    drill down into the tests to see the failure details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we have created the `DBManager` class and have a suite of automated
    tests to test the CRUD methods. It is now time to focus on filling in the logic
    so that `POIApp` can save and fetch the data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: NUnitLite is a great framework to implement the unit testing strategy for the
    Android application development, but it's not all about testing. You need to implement
    some sort of UI automation testing framework to test most of your application
    components, including the user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin brings yet another platform; Xamarin Test Cloud makes it possible to
    test mobile apps written in any language on a collection of real devices from
    around the world. You can write your test scripts using the Xamarin testing framework
    and automate your app testing from CI systems. This book doesn't cover the UI
    automation frameworks and Xamarin Test Cloud service. You can visit the official
    [http://xamarin.com/](http://xamarin.com/) website for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the caching logic to POIApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DBManager` class is now tested and ready to use straightaway on `POIApp`.
    The `POIApp` will save the POI records when the download is completed, and the
    list will be retrieved later when the app is unable to fetch the updated list
    from the server. Perform the following steps to integrate the `DBManager` class
    with `POIApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `CreateTable()` method on the `POIListActivity` class to initiate
    the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `POIListFragment` class and go to the `DownloadPoisListAsync()` method.
    We have used this method to download the POI list from the server. The following
    updates are required here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the database cache when the POI downloads from the server are successful.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the newly fetched POI data to the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When a device is not connected to the network, return the cached data from the
    database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet depicts the the updated version of the `DownloadPoisListAsync()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we save all of the POI list data received from
    the server. However, when a user edits and saves any of the POI data, we need
    to update the local database for that POI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s call the `SavePOI()` method from the `POIDetailFragment`
    class in the `CreateOrUpdatePOIAsync()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the POI record is deleted from the server in the `POIDetailFragment` class,
    in the `DeletePOIAsync()` method we need to call the `DeletePOI()` method to delete
    the same POI from the local device database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet depicts the updated version of the `DeletePOIAsync()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we have implemented the database logic for the `POIApp` to work offline.
    Run the app; when connected to the network, it will download and cache the POI
    list. Now restart the application while the device is offline and notice that
    the same old cached POI list is presented on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used SQLite.ORM to save the POI records to the database
    and created a series of unit tests to verify that the database operations were
    functioning well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue integrating with device capabilities by
    adding camera support to capture and save the POI image.
  prefs: []
  type: TYPE_NORMAL
