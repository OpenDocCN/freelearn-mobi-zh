- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Understanding Blazor Routing and Layout
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Blazor 路由和布局
- en: In the previous chapter, we explored the process of designing a login page using
    Blazor. Although the app layout and navigation hierarchy remain XAML-based, our
    app utilizes a hybrid UI implementation that combines both Blazor and XAML. Blazor
    offers an alternative approach to UI design for .NET MAUI apps. In this second
    part of the book, we will reconstruct the entire UI using Blazor exclusively.
    Since the initial step of UI design typically involves the implementation of layout
    and navigation, this chapter will introduce the concepts of layout and routing
    within Blazor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了使用 Blazor 设计登录页面的过程。尽管应用程序布局和导航层次结构仍然是基于 XAML 的，但我们的应用程序利用了结合了 Blazor
    和 XAML 的混合 UI 实现。Blazor 为 .NET MAUI 应用程序提供了一种替代的 UI 设计方法。在本书的第二部分，我们将仅使用 Blazor
    重建整个 UI。由于 UI 设计的初始步骤通常涉及布局和导航的实现，因此本章将介绍 Blazor 中的布局和路由概念。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Client-side Blazor routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 Blazor 路由
- en: Using Blazor layout components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Blazor 布局组件
- en: Implementing navigation elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现导航元素
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章的源代码，您需要在您的 PC 或 Mac 上安装 Visual Studio 2022。有关详细信息，请参阅第 1 章，*Getting
    Started with .NET MAUI* 中的 *Development environment setup* 部分。
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter09](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/dcbd1d8d55bea3adccb3153f59b2d0152c282dd2).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter09](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/dcbd1d8d55bea3adccb3153f59b2d0152c282dd2)。
- en: 'To check out the source code of this chapter, we can use this command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书源代码的信息，请参阅第 2 章，*Building Our First .NET MAUI App* 中的 *Managing the
    source code in this book* 部分。
- en: Understanding client-side routing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端路由
- en: The routing and layout of Blazor bear similarities to the concepts of Shell
    and navigation in the XAML realm. In *Chapter 5**, Navigation Using .NET MAUI
    Shell and NavigationPage*, we introduced navigation and Shell while discussing
    the routing strategy of Shell. Shell offers a URI-based navigation experience
    that relies on routes to navigate to designated pages. The routing of Blazor closely
    resembles this approach.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 的路由和布局与 XAML 领域中的 Shell 和导航概念相似。在第 5 章，*Navigation Using .NET MAUI Shell
    and NavigationPage* 中，我们讨论了 Shell 的路由策略时介绍了导航和 Shell。Shell 提供了一种基于 URI 的导航体验，它依赖于路由来导航到指定的页面。Blazor
    的路由与此方法非常相似。
- en: Blazor routing allows for seamless transitions between Razor pages. Rendering
    Razor pages in `BlazorWebView` is akin to web apps operating in a browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 路由允许在 Razor 页面之间实现无缝过渡。在 `BlazorWebView` 中渲染 Razor 页面类似于在浏览器中运行的 Web
    应用程序。
- en: In traditional web applications, loading an HTML page in a browser fetches the
    page from the web server. Selecting a different route subsequently retrieves a
    new page from the server. However, the process varies slightly for **single-page
    applications** (**SPAs**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 Web 应用程序中，在浏览器中加载 HTML 页面是从 Web 服务器获取页面。选择不同的路由随后会从服务器检索新页面。然而，对于 **单页应用程序**（**SPAs**）来说，这个过程略有不同。
- en: Blazor WebAssembly applications fall under the category of SPAs. When launching
    an app, it is loaded into the browser, and any subsequent page navigation occurs
    solely on the client side. This approach is known as client-side routing, which
    is also employed by Blazor Hybrid apps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 应用程序属于 SPAs 的范畴。当启动应用程序时，它会被加载到浏览器中，并且任何后续的页面导航都仅发生在客户端。这种方法被称为客户端路由，Blazor
    混合应用程序也采用了这种方法。
- en: Setting up BlazorWebView
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 BlazorWebView
- en: To implement client-side routing, the router must be installed during the application’s
    startup. In .NET MAUI apps, both XAML and Blazor entry points are configured in
    `App.xaml.cs`. To switch the UI implementation from XAML to Blazor, refer to the
    modifications made to `App.xaml.cs` within the provided code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现客户端路由，必须在应用程序启动时安装路由器。在 .NET MAUI 应用程序中，XAML 和 Blazor 入口点都在 `App.xaml.cs`
    中配置。要切换 UI 实现从 XAML 到 Blazor，请参考提供的代码中对 `App.xaml.cs` 所做的修改。
- en: A Blazor Hybrid app operates within `BlazorWebView`. To initiate the Blazor
    Hybrid app, it is necessary to establish an instance of `BlazorWebView` first.
    In the previous chapter, we accomplished this setup in `LoginPage` and successfully
    navigated back to Shell after logging in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 混合应用程序在 `BlazorWebView` 中运行。要启动 Blazor 混合应用程序，首先需要创建一个 `BlazorWebView`
    实例。在前一章中，我们在 `LoginPage` 中完成了此设置，并在登录后成功导航回 Shell。
- en: 'To configure a `BlazorWebView` instance for the entire application, it is necessary
    to replace the instance assigned to the `MainPage` property within the `App` class.
    To achieve this, we modified the constructor of the `App` class (found in `App.xaml.cs`)
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要为整个应用程序配置 `BlazorWebView` 实例，需要替换 `App` 类中分配给 `MainPage` 属性的实例。为此，我们修改了 `App`
    类的构造函数（位于 `App.xaml.cs`），如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use a symbol, `MAUI_BLAZOR`, to facilitate conditional compilation,
    enabling the ability to switch between XAML and the Blazor UI during the build
    process. To utilize the Blazor UI, we assign the `MainPage` property to a `MainPage`
    instance **(1)**. Within the `MainPage` class, we define the `BlazorWebView` control
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个符号，`MAUI_BLAZOR`，来简化条件编译，使我们在构建过程中能够在 XAML 和 Blazor UI 之间切换。为了使用 Blazor
    UI，我们将 `MainPage` 属性分配给一个 `MainPage` 实例 **(1)**。在 `MainPage` 类中，我们定义了 `BlazorWebView`
    控件如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Within `BlazorWebView`, an HTML page (`index.xhtml`) is loaded to initiate the
    Blazor UI setup. Let’s examine how the router configuration operates.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BlazorWebView` 中，加载一个 HTML 页面（`index.xhtml`）以启动 Blazor UI 设置。让我们看看路由器配置是如何工作的。
- en: Setting up the Router component
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Router 组件
- en: The Blazor UI employs an HTML page-based design, resembling the structure of
    an SPA that originates from a static HTML page. Within `BlazorWebView`, the initial
    HTML page to be loaded is `index.xhtml`. This closely resembles the `login.xhtml`
    page we discussed in the previous chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor UI 采用基于 HTML 页面的设计，类似于从静态 HTML 页面起源的 SPA 结构。在 `BlazorWebView` 中，要加载的初始
    HTML 页面是 `index.xhtml`。这与我们在前一章中讨论的 `login.xhtml` 页面非常相似。
- en: 'The top-level Razor component, loaded in `RootComponent`, appears as the `Main`
    component, which can be viewed here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RootComponent` 中加载的顶级 Razor 组件看起来像是 `Main` 组件，可以在此查看：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9.1: `Main.razor` ([https://epa.ms/Main9-1](https://epa.ms/Main9-1))'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1：`Main.razor` ([https://epa.ms/Main9-1](https://epa.ms/Main9-1))
- en: As we can see in *Listing 9.1*, we set up the `Router` component, **(1)**, in
    `Main.razor`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 *列表 9.1* 中所见，我们在 `Main.razor` 中设置了 `Router` 组件 **(1)**。
- en: The `Router` component employs reflection to scan all page components and construct
    a routing table. The `AppAssembly` parameter determines which assemblies will
    be scanned. Upon encountering a navigation event, the router consults the routing
    table for a corresponding route. The `Router` component is, in essence, a templated
    component, which we will explore further in the next chapter. When a matching
    route is identified, the `Found` template is utilized. Conversely, if no matching
    routes are present, the `NotFound` template comes into play.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router` 组件使用反射来扫描所有页面组件并构建一个路由表。`AppAssembly` 参数决定了哪些程序集将被扫描。在遇到导航事件时，路由器会查阅路由表以找到相应的路由。本质上，`Router`
    组件是一个模板组件，我们将在下一章中进一步探讨。当找到匹配的路由时，将使用 `Found` 模板。相反，如果没有匹配的路由，则使用 `NotFound` 模板。'
- en: The `Found` template, **(2)**, employs a `RouteView` component to render the
    chosen component alongside its layout. The layout is specified in the `DefaultLayout`
    attribute, which we will examine in the upcoming section. Additionally, the new
    page to be loaded, as well as any route parameters, is passed using an instance
    of the `RouteData` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Found` 模板 **(2)** 使用 `RouteView` 组件来渲染所选组件及其布局。布局在 `DefaultLayout` 属性中指定，我们将在下一节中对其进行检查。此外，要加载的新页面以及任何路由参数都通过
    `RouteData` 类的实例传递。'
- en: If a match cannot be found, the `NotFound` template, **(3)**, is rendered. This
    template utilizes a `LayoutView` component to display error messages. The layout
    employed by `LayoutView` is designated via a `Layout` attribute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到匹配项，将渲染 `NotFound` 模板，**（3）**。此模板使用 `LayoutView` 组件来显示错误消息。`LayoutView`
    使用的布局通过 `Layout` 属性指定。
- en: Defining routes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义路由
- en: After setting up the router, we can proceed to create pages and define route
    templates within those pages. The router will then scan the route templates defined
    in the pages to construct a routing table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好路由器之后，我们可以继续创建页面并在这些页面内定义路由模板。然后，路由器将扫描页面中定义的路由模板以构建路由表。
- en: 'At the top level of our app, the navigation hierarchy and route templates can
    be established by referring to *Figure 9.1*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用的顶层，可以通过参考 *图 9.1* 来建立导航层次结构和路由模板：
- en: '![Figure 8.1: Navigation hierarchy of Razor pages](img/B21554_09_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：Razor 页面的导航层次结构](img/B21554_09_01.png)'
- en: 'Figure 9.1: Navigation hierarchy of Razor pages'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：Razor 页面的导航层次结构
- en: 'We presented the primary pages of our app in *Figure 9.1*. Each page possesses
    a name, which corresponds to the class name of a Razor page. Located beneath the
    name is the route template. For instance, for the `About` page, the route template
    can be declared as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *图 9.1* 中展示了我们应用的主要页面。每个页面都有一个名称，该名称对应于 Razor 页面的类名。名称下方是路由模板。例如，对于 `About`
    页面，路由模板可以声明如下：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `@page` directive comprises two components – the directive name and the
    route template. In this example, the route template is `/about`, which must be
    enclosed in quotes and always begin with a forward slash (`/`). Given that a Razor
    page’s final output is an HTML page, navigation to a Razor page can be treated
    like navigating to a web page using an anchor tag, `<a>`, as demonstrated here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`@page` 指令包含两个组件——指令名称和路由模板。在此示例中，路由模板是 `/about`，必须用引号括起来，并且始终以正斜杠 (`/`) 开头。鉴于
    Razor 页面的最终输出是一个 HTML 页面，导航到 Razor 页面可以像使用锚点标签 `<a>` 导航到网页一样处理，如下所示：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Passing data using route parameters
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用路由参数传递数据
- en: When navigating to a page using a route template, data can be passed to the
    page through route parameters. If we recall the process of passing data with query
    parameters in Shell, the use of route parameters is quite similar.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用路由模板导航到页面时，可以通过路由参数将数据传递到页面。如果我们回想一下在 Shell 中使用查询参数传递数据的过程，路由参数的使用相当类似。
- en: As depicted in *Figure 9.1*, after successfully logging in, the `Items` page
    appears, displaying a list of items in the root group, as shown in *Figure 9.2*.
    On this page, clicking on an item allows navigation based on the item type. To
    identify the selected item, an item `Id` value is passed to the new page as a
    parameter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 9.1* 所示，在成功登录后，将显示 `Items` 页面，显示根组中的项目列表，如 *图 9.2* 所示。在此页面上，点击项目可以根据项目类型进行导航。为了识别选定的项目，将项目
    `Id` 值作为参数传递到新页面。
- en: '![Figure 8.2: Items page in a Blazor Hybrid app](img/B21554_09_02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2：Blazor 混合应用中的项目页面](img/B21554_09_02.png)'
- en: 'Figure 9.2: Items page in a Blazor Hybrid app'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：Blazor 混合应用中的项目页面
- en: 'In the `Items` page, we have the following route templates defined:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Items` 页面中，我们定义了以下路由模板：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first route template is employed when displaying the root page, while the
    second comes into play upon selecting a group. The group `Id` value is transmitted
    to the `Items` page using the `SelectedItemId` route parameter. To designate the
    type of route parameter, we can incorporate constraints tied to the data type,
    as demonstrated here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由模板用于显示根页面，而第二个路由模板在选择一个组时生效。组 `Id` 值通过 `SelectedItemId` 路由参数传递到 `Items`
    页面。为了指定路由参数的类型，我们可以结合数据类型相关的约束，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding page directive, we define the data type of `Id` as an integer.
    For more information about route constraints, please refer to the relevant Microsoft
    documentation. You can access the pertinent document here: [https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-8.0#route-constraints](https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-8.0#route-constraints).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面指令中，我们将 `Id` 的数据类型定义为整数。有关路由约束的更多信息，请参阅相关的 Microsoft 文档。您可以通过以下链接访问相关文档：[https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-8.0#route-constraints](https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-8.0#route-constraints)。
- en: Navigating with NavigationManager
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NavigationManager 导航
- en: In a Razor page, navigation to another page typically involves using an `<a>`
    anchor tag. However, under certain circumstances, it may be necessary to perform
    the action via code. One such instance is when handling an event, where redirection
    to a page occurs within the event handler. This is precisely the situation on
    our `Login` page. Let’s explore how to navigate to the `Items` page using `NavigationManager`
    once a successful login has been achieved.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Razor 页面中，导航到另一个页面通常涉及使用 `<a>` 锚点标签。然而，在某些情况下，可能需要通过代码执行操作。这种情况之一是在处理事件时，在事件处理器中发生页面重定向。这正是我们的
    `Login` 页面所面临的情况。让我们探讨如何在成功登录后使用 `NavigationManager` 导航到 `Items` 页面。
- en: 'In our app, after logging in, we must redirect users to the `Items` page to
    display the root group. The user interface for the `Login` page remains unchanged
    from the previous chapter; however, we have modified the event handler in `Login.razor.cs`
    as shown below:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，登录后，我们必须将用户重定向到 `Items` 页面以显示根组。`Login` 页面的用户界面与上一章保持不变；然而，我们已经修改了
    `Login.razor.cs` 中的事件处理器，如下所示：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We obtain an instance of `NavigationManager` through dependency injection **(1)**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过依赖注入 **(1**) 获取 `NavigationManager` 的实例。
- en: Then, we invoke the `NavigateTo("/group")` method of `NavigationManager` to
    facilitate navigation to the `Items` page **(2)**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `NavigationManager` 的 `NavigateTo("/group")` 方法以方便导航到 `Items` 页面 **(2)**。
- en: In this section, we explored routing and navigation. As a next step, we can
    implement a navigation hierarchy akin to that of Shell navigation within the Blazor
    UI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了路由和导航。作为下一步，我们可以在 Blazor UI 中实现类似于 Shell 导航的导航层次结构。
- en: The top level of the HTML page navigation hierarchy encompasses a header, toolbar,
    menu, and footer. We can design this layout using a Blazor layout component, which
    shares similarities with the flyout and menu items in Shell. We previously introduced
    these concepts in *Chapter 5**, Navigation Using .NET MAUI Shell and NavigationPage*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 页面导航层次结构的顶层包括标题、工具栏、菜单和页脚。我们可以使用 Blazor 布局组件来设计此布局，它与 Shell 中的弹出和菜单项类似。我们之前在
    *第五章* 中介绍了这些概念，即使用 .NET MAUI Shell 和 NavigationPage 进行导航。
- en: Using Blazor layout components
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Blazor 布局组件
- en: Most web pages typically feature fixed elements such as headers, footers, or
    menus. By designing a page with a layout combined with its content, we can minimize
    redundant code. The page itself displays the content intended for users, while
    the layout assists in constructing visual styles and providing navigational methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网页通常具有固定元素，如标题、页脚或菜单。通过将布局与内容结合设计页面，我们可以最小化冗余代码。页面本身显示用户 intended 的内容，而布局则帮助构建视觉样式并提供导航方法。
- en: Blazor layout components are classes derived from `LayoutComponentBase`. Any
    functionality applicable to regular Razor components can also be applied to layout
    components.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 布局组件是从 `LayoutComponentBase` 派生的类。任何适用于常规 Razor 组件的功能也可以应用于布局组件。
- en: 'In *Listing 9.1*, we observe that `MainLayout` serves as the default layout
    for the pages. Its definition can be found in *Listing 9.2*, as shown below:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单 9.1* 中，我们可以看到 `MainLayout` 是页面的默认布局。其定义可以在 *清单 9.2* 中找到，如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9.2: `MainLayout.razor` ([https://epa.ms/MainLayout9-2](https://epa.ms/MainLayout9-2))'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9.2：`MainLayout.razor` ([https://epa.ms/MainLayout9-2](https://epa.ms/MainLayout9-2))
- en: The **MainLayout** component **(1)** inherits from the `LayoutComponentBase`
    class. The component features a **NavMenu** **(2)** to outline the navigation
    menu. Within the `<main>` tag **(3)**, the `@Body` Razor syntax designates the
    location in the layout markup for rendering content.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainLayout** 组件 **(1**) 继承自 `LayoutComponentBase` 类。该组件具有一个 **NavMenu** **(2**)
    用于概述导航菜单。在 `<main>` 标签 **(3**) 内，`@Body` Razor 语法指定了布局标记中渲染内容的位置。'
- en: 'It is essential to thoroughly examine the `NavMenu` component, as it serves
    as the primary navigation method within the app. Please refer to *Figure 9.3*
    for a visual representation of the **NavMenu** interface before reviewing the
    code. **NavMenu** comprises three menu items: **Home**, **About**, and **Logout**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查 `NavMenu` 组件非常重要，因为它作为应用程序中的主要导航方法。在审查代码之前，请参考 *图 9.3* 以查看 **NavMenu**
    接口的视觉表示。**NavMenu** 包含三个菜单项：**主页**、**关于**和**注销**。
- en: '![Figure 8.3: NavMenu](img/B21554_09_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3：NavMenu](img/B21554_09_03.png)'
- en: 'Figure 9.3: NavMenu'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：NavMenu
- en: '`NavMenu` is a Razor component responsible for defining the links used in navigation.
    The source code for `NavMenu` can be found in *Listing 9.3*, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavMenu`是一个Razor组件，负责定义导航中使用的链接。`NavMenu`的源代码可以在*清单9.3*中找到，如下所示：'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9.3: `NavMenu.razor` ([https://epa.ms/NavMenu9-3](https://epa.ms/NavMenu9-3))'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '清单9.3: `NavMenu.razor` ([https://epa.ms/NavMenu9-3](https://epa.ms/NavMenu9-3))'
- en: 'In the source code of the `NavMenu` component, we can observe that it consists
    of a Bootstrap `navBar` component accompanied by some C# logic within the code
    block. The `NavBar` is defined using a `navbar` Bootstrap class in the following
    `<div>` tag **(1)**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NavMenu`组件的源代码中，我们可以观察到它由一个Bootstrap `navBar`组件和一些代码块内的C#逻辑组成。`NavBar`在以下`<div>`标签中使用`navbar`
    Bootstrap类定义**（1）**：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As illustrated in *Figure 9.3*, a hamburger icon, **(2)**, is positioned at
    the top right of the screen, utilizing a `<button>` tag to toggle `NavMenu`. The
    hamburger button UI is implemented using the Bootstrap class, `navbar-toggler`,
    as detailed below:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9.3*所示，一个汉堡图标**（2）**位于屏幕的右上角，使用`<button>`标签来切换`NavMenu`。汉堡按钮UI使用Bootstrap类`navbar-toggler`实现，如下详细说明：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Three links are defined as menu items, utilizing the `nav-item` Bootstrap class
    **(3)**. Instead of employing the anchor tag, `<a>`, `NavLink` is used **(4)**.
    The `NavLink` component functions similarly to `<a>`. However, it toggles an `active`
    CSS class, contingent on whether its `href` matches the current URL, as demonstrated
    below:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了三个链接作为菜单项，使用`nav-item` Bootstrap类**（3）**。而不是使用锚标签`<a>`，我们使用`NavLink`**（4）**。`NavLink`组件的功能类似于`<a>`。然而，它根据其`href`是否与当前URL匹配来切换一个`active`
    CSS类，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We previously discussed `MainLayout`, which serves as the default layout in
    our app. Now, let’s examine how to apply this layout to a component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了`MainLayout`，它是我们应用中的默认布局。现在，让我们看看如何将此布局应用于组件。
- en: Applying a layout to a component
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将布局应用于组件
- en: '`MainLayout` serves as the default layout component, applying to all pages
    unless an alternative layout is specified. In certain scenarios, we may need to
    use a unique layout rather than the default one.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainLayout`作为默认布局组件，适用于所有页面，除非指定了其他布局。在某些情况下，我们可能需要使用一个独特的布局而不是默认布局。'
- en: 'For instance, within our app, we employ a distinct layout component for the
    `Login` page instead of the default layout (refer to *Listing 9.4*). `MainLayout`
    incorporates a `NavMenu` component, which we do not wish to display on the `Login`
    page since users should not access other content before logging in. Let’s examine
    the alterations made to the `Login` page after applying a specific layout, as
    shown in *Listing 9.4*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的应用中，我们为`登录`页面使用了一个独特的布局组件，而不是默认布局（参考*清单9.4*）。`MainLayout`包含一个`NavMenu`组件，我们不想在`登录`页面上显示它，因为用户在登录之前不应该访问其他内容。让我们查看在应用特定布局后对`登录`页面所做的修改，如*清单9.4*所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 9.4: `Login.razor` ([https://epa.ms/Login9-4](https://epa.ms/Login9-4))'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '清单9.4: `Login.razor` ([https://epa.ms/Login9-4](https://epa.ms/Login9-4))'
- en: 'To apply a specific layout, we can utilize the `@layout` Razor directive **(1)**.
    On the `Login` page, we implement the `LogoutLayout`. The code for `LogoutLayout`
    is presented in *Listing 9.5*, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用特定的布局，我们可以使用`@layout` Razor指令**（1）**。在`登录`页面上，我们实现了`LogoutLayout`。`LogoutLayout`的代码在*清单9.5*中展示，如下所示：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9.5: `LogoutLayout.razor` ([https://epa.ms/LogoutLayout9-5](https://epa.ms/LogoutLayout9-5))'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '清单9.5: `LogoutLayout.razor` ([https://epa.ms/LogoutLayout9-5](https://epa.ms/LogoutLayout9-5))'
- en: In `LogoutLayout`, we eliminated the `NavMenu` element and incorporated a sign-in
    link, enabling new users to register for an account.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LogoutLayout`中，我们移除了`NavMenu`元素，并加入了一个登录链接，允许新用户注册账户。
- en: Nesting layouts
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套布局
- en: 'Layout components can be nested as well. In `MainLayout`, we did not specify
    any margin for the content. While this layout is suitable for content list views
    on items pages or item details pages, it may not be visually appealing for content
    pages like the `About` page. To improve this, we can employ a distinct layout
    for the `About` page that is nested within `MainLayout`. Let’s call it `PageLayout`,
    and its implementation can be found in *Listing 9.6*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 布局组件也可以嵌套。在`MainLayout`中，我们没有为内容指定任何边距。虽然这个布局适合项目页面或项目详情页面上的内容列表视图，但它可能不适合像`关于`页面这样的内容页面。为了改进这一点，我们可以为`关于`页面使用一个嵌套在`MainLayout`中的独特布局。让我们称它为`PageLayout`，其实现可以在*清单9.6*中找到：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9.6: `PageLayout.razor` ([https://epa.ms/PageLayout9-6](https://epa.ms/PageLayout9-6))'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '清单9.6: `PageLayout.razor` ([https://epa.ms/PageLayout9-6](https://epa.ms/PageLayout9-6))'
- en: '`PageLayout` is a layout component that utilizes `MainLayout`. It places `@Body`
    inside an `<article>` tag with the `"content px-4"` style applied, thereby enabling
    the content to adopt a style that is appropriate for a paragraph of text.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageLayout`是一个布局组件，它使用`MainLayout`。它将`@Body`放置在一个应用了`"content px-4"`样式的`<article>`标签内，从而使内容采用适合段落文本的样式。'
- en: 'On the `About` page, we can designate the layout as `PageLayout` in the following
    manner:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`About`页面上，我们可以以下方式指定布局为`PageLayout`：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have now covered the basics of routing and layout in Blazor. Armed with this
    knowledge, we can proceed to implement the navigation elements within our app.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了Blazor中路由和布局的基础知识。有了这些知识，我们可以继续在我们的应用中实现导航元素。
- en: Implementing navigation elements
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现导航元素
- en: In *Chapter 5*, *Navigation Using .NET MAUI Shell and NavigationPage*, we introduced
    the concepts of absolute and relative routes within Shell. Absolute routes can
    be defined in a visual navigation hierarchy, while relative routes are navigable
    using query parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*中，*使用.NET MAUI Shell和NavigationPage进行导航*，我们介绍了Shell中的绝对和相对路由的概念。绝对路由可以在视觉导航层次结构中定义，而相对路由可以通过查询参数进行导航。
- en: This navigation approach closely resembles the strategy employed in the Blazor
    version of our app. As illustrated in *Figure 9.4*, we implement Blazor UI elements
    in a manner similar to the XAML version.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导航方法与我们在Blazor版本的应用中采用的策略相似。如图*图9.4*所示，我们以类似于XAML版本的方式实现Blazor UI元素。
- en: '![Figure 8.4: Navigation elements](img/B21554_09_04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：导航元素](img/B21554_09_04.png)'
- en: 'Figure 9.4: Navigation elements'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：导航元素
- en: 'The `Items` page serves as the main page of our app after login. On this page,
    which displays a list of items, the following UI elements are related to navigation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Items`页面是用户登录应用后的主页面。在这个显示项目列表的页面上，以下UI元素与导航相关：'
- en: '**A list view** – Users can navigate the list and select an item.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表视图** – 用户可以浏览列表并选择一个项目。'
- en: '**Context menu** – Associated with each item in the list view, enabling users
    to edit or delete items.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文菜单** – 与列表视图中的每个项目相关联，使用户能够编辑或删除项目。'
- en: '**Back button** – Allows users to navigate back.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回按钮** – 允许用户返回上一级。'
- en: '**Add button** – Enables users to add new items.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加按钮** – 允许用户添加新项目。'
- en: In this section, we will leverage the knowledge we have acquired to implement
    the aforementioned navigation elements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用我们所学的知识来实现上述导航元素。
- en: Implementing a list view
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现列表视图
- en: In the XAML version, our navigation begins with a list of items once the user
    logs in to the app. The list view is implemented using a .NET MAUI `ListView`
    control, which leverages platform-specific UI components for a consistent look
    and feel across platforms. In the Blazor version, we utilize a web-based UI, ensuring
    a uniform appearance on different platforms.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML版本中，用户登录应用后，导航从项目列表开始。列表视图是通过使用.NET MAUI `ListView`控件实现的，该控件利用特定平台的UI组件以实现跨平台的一致外观和感觉。在Blazor版本中，我们使用基于Web的UI，确保在不同平台上具有统一的外观。
- en: When it comes to implementing a list view with a web UI, we have numerous options
    to choose from. Throughout this book, we adhere to the Bootstrap framework. Our
    methodology, as demonstrated in the previous chapter, involves reusing UI designs
    from Bootstrap examples. Since we’re employing Bootstrap 5.1 in this book, we
    can reference the list group example depicted in *Figure 9.5*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用Web UI实现列表视图时，我们有众多选项可供选择。在本书中，我们遵循Bootstrap框架。我们的方法，如前一章所示，涉及重用Bootstrap示例中的UI设计。由于我们在本书中使用Bootstrap
    5.1，我们可以参考*图9.5*中展示的列表组示例。
- en: '![Figure 8.5: Bootstrap list group](img/B21554_09_05.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：Bootstrap列表组](img/B21554_09_05.png)'
- en: 'Figure 9.5: Bootstrap list group'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：Bootstrap列表组
- en: 'The preceding example can be accessed via this URL: [https://getbootstrap.com/docs/5.1/components/list-group/](https://getbootstrap.com/docs/5.1/components/list-group/).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例可以通过以下URL访问：[https://getbootstrap.com/docs/5.1/components/list-group/](https://getbootstrap.com/docs/5.1/components/list-group/)。
- en: A Bootstrap list group can be employed to construct a UI component similar to
    the `ListView` in XAML. To achieve this, we can apply the CSS class `"``list-group"`
    to HTML tags, such as `<ul>` or `<div>`, to create a list group. Within the list
    group, the `"list-group-item"` CSS class is applied to individual list items in
    the group.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Bootstrap 列表组来构建一个类似于 XAML 中的 `ListView` 的 UI 组件。为了实现这一点，我们可以将 CSS 类 `"list-group"`
    应用到 HTML 标签，如 `<ul>` 或 `<div>`，以创建列表组。在列表组内，将 `"list-group-item"` CSS 类应用于组中的单个列表项。
- en: In the XAML version, we facilitated CRUD operations using the context menu.
    However, the Bootstrap list group does not feature a built-in context menu, so
    we have to implement one ourselves. To create a context menu within the list group,
    we can utilize the Bootstrap `dropdown` component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XAML 版本中，我们使用上下文菜单来执行 CRUD 操作。然而，Bootstrap 列表组没有内置的上下文菜单，因此我们必须自己实现它。要在列表组内创建上下文菜单，我们可以使用
    Bootstrap `dropdown` 组件。
- en: 'In order to employ the `dropdown` component, it is necessary to include the
    JavaScript dependency in `index.xhtml`, as demonstrated below:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `dropdown` 组件，需要在 `index.xhtml` 中包含 JavaScript 依赖项，如下所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We included a JavaScript file, `bootstrap.bundle.min.js`, following `blazor.webview.js`.
    The `bootstrap.bundle.min.js` file is a component of the Bootstrap release package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `blazor.webview.js` 之后包含了 JavaScript 文件 `bootstrap.bundle.min.js`。`bootstrap.bundle.min.js`
    文件是 Bootstrap 发布包的一部分。
- en: 'To create a new Razor component called `Items`, simply right-click on the **Pages**
    folder in Visual Studio and choose **Add** -> **Razor Component**`…`. After this,
    insert the code provided in *Listing 9.7* and name the Razor file `Items.razor`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个名为 `Items` 的新 Razor 组件，只需在 Visual Studio 中的 **Pages** 文件夹上右键单击，然后选择 **Add**
    -> **Razor Component**`…`。之后，插入 *Listing 9.7* 中提供的代码，并将 Razor 文件命名为 `Items.razor`：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9.7: `Items.razor` ([https://epa.ms/Items9-7](https://epa.ms/Items9-7))'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7：`Items.razor` ([https://epa.ms/Items9-7](https://epa.ms/Items9-7))
- en: In `Items.razor` **(1)**, we can copy the Bootstrap list group sample code that
    utilizes the `<div>` tag with the `list-group` CSS class applied to it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Items.razor` **(1**) 中，我们可以复制使用具有 `list-group` CSS 类的 `<div>` 标签的 Bootstrap
    列表组示例代码。
- en: 'We customize the list group item to meet our requirements **(2)**, as demonstrated
    in *Figure 9.6*. The list group item is created within a `foreach` loop using
    the `<div>` tag, containing an icon, a name, a description, and a context menu:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据我们的要求 **(2**) 定制了列表组项，如图 9.6 所示。列表组项是在 `foreach` 循环中使用 `<div>` 标签创建的，包含一个图标、一个名称、一个描述和一个上下文菜单：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We apply the `dropdown`, `list-group-item`, and `list-group-item-action` CSS
    classes to the `<div>` tag, transforming it into a list group item that incorporates
    a context menu using a dropdown.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `dropdown`、`list-group-item` 和 `list-group-item-action` CSS 类应用到 `<div>`
    标签上，将其转换为一个包含下拉菜单的列表组项。
- en: '![Figure 8.6: List group item](img/B21554_09_06.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6：列表组项](img/B21554_09_06.png)'
- en: 'Figure 9.6: List group item'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：列表组项
- en: 'Within the list group item, we utilize an `<img>` tag to display the item’s
    icon:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表组项中，我们使用 `<img>` 标签来显示项目的图标：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can obtain the icon source by using an extension method called `GetIcon`
    from the `Item` class. To create this extension method, we need to add a new class
    file under the `Shared` folder and name it `ItemEx.cs`, as demonstrated in *Listing
    9.8*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从 `Item` 类中调用名为 `GetIcon` 的扩展方法来获取图标源。要创建此扩展方法，我们需要在 `Shared` 文件夹下添加一个新的类文件，并将其命名为
    `ItemEx.cs`，如图 *Listing 9.8* 所示。
- en: 'An `<a>` anchor tag is utilized to display the item’s name and description.
    The name and description are defined within the `<a>` tag like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<a>` 锚标签来显示项目的名称和描述。名称和描述在 `<a>` 标签中定义如下：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The item’s link can be obtained using the `GetActionLink` extension method,
    which is also defined in *Listing 9.8*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `GetActionLink` 扩展方法获取项目的链接，该方法也在 *Listing 9.8* 中定义。
- en: The context menu is a Bootstrap dropdown component that comprises a `<button>`
    tag **(3)** and an unordered list created with the `<ul>` tag **(4)**. Utilizing
    the Open Iconic icons, this button appears as a hamburger icon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文菜单是一个 Bootstrap 下拉组件，由一个 `<button>` 标签 **(3**) 和使用 `<ul>` 标签创建的无序列表组成 **(4)**。利用
    Open Iconic 图标，此按钮显示为汉堡图标。
- en: '**Open Iconic icons**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**开源图标**'
- en: 'In Blazor UI design, we utilize Open Iconic icons. Open Iconic is an open-source
    icon set featuring 223 icons in SVG, web font, and raster formats. For XAML design,
    FontAwesome is used, which can also be implemented in Blazor alongside Bootstrap.
    However, additional configuration is required prior to its use. Open Iconic comes
    bundled with the Blazor template and is included with Bootstrap. As a result,
    we can use it directly without any extra configuration. For instance, to display
    a hamburger icon in the context menu, the following HTML tag can be employed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor UI 设计中，我们使用 Open Iconic 图标。Open Iconic 是一个开源图标集，包含 223 个 SVG、网络字体和位图格式的图标。对于
    XAML 设计，使用 FontAwesome，它也可以在 Blazor 中与 Bootstrap 一起实现。然而，在使用之前需要额外的配置。Open Iconic
    与 Blazor 模板捆绑在一起，并包含在 Bootstrap 中。因此，我们可以直接使用它而无需任何额外配置。例如，要在上下文菜单中显示汉堡图标，可以使用以下
    HTML 标签：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the drop-down menu, there are two context action buttons: `Edit` and `Delete`.
    We apply the `dropdown-item` CSS class to these buttons. The context action button
    triggers a dialog box to perform CRUD operations, hence the inclusion of two Bootstrap
    modal CSS attributes, `data-bs-toggle` and `data-bs-target`. We will discuss handling
    CRUD operations in the next chapter.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单中，有两个上下文动作按钮：`Edit` 和 `Delete`。我们给这些按钮应用了 `dropdown-item` CSS 类。上下文动作按钮触发一个对话框来执行
    CRUD 操作，因此包含了两个 Bootstrap 模态 CSS 属性，`data-bs-toggle` 和 `data-bs-target`。我们将在下一章讨论处理
    CRUD 操作。
- en: 'Now, let’s review the extension methods of `Item` that we will use to support
    a list view UI, as shown in *Listing 9.8*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们将用于支持列表视图 UI 的 `Item` 扩展方法，如图 *清单 9.8* 所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9.8: `ItemEx.cs` ([https://epa.ms/ItemEx9-8](https://epa.ms/ItemEx9-8))'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9.8：`ItemEx.cs` ([https://epa.ms/ItemEx9-8](https://epa.ms/ItemEx9-8))
- en: 'In *Listing 9.8*, we create a static class called `ItemEx` to implement extension
    methods for the **Item** class. Within this class, we define three extension methods
    to obtain the necessary URL for navigation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单 9.8* 中，我们创建了一个名为 `ItemEx` 的静态类，用于实现 `Item` 类的扩展方法。在这个类中，我们定义了三个扩展方法来获取必要的导航
    URL：
- en: '`GetIcon` **(1)** – Returns the icon image’s URL'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetIcon` **(1)** – 返回图标图像的 URL'
- en: '`GetActionLink` **(2)** – Returns the URL of a selected item based on its type'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActionLink` **(2)** – 根据项目类型返回所选项目的 URL'
- en: '`GetParentLink` **(3)** – Returns the URL of the parent item'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetParentLink` **(3)** – 返回父项目的 URL'
- en: In the previous implementation of the list view UI, we created a list comprising
    both password entries and groups. When an item is selected, an anchor tag, `<a>`,
    is actually clicked. The `href` property of `<a>` is set to the return value of
    the `GetActionLink` method. This return value follows a `"/{itemType}/{item.Id}"`
    route template format, enabling navigation to the desired item. Additionally,
    a context menu button is situated to the right of each item. Upon clicking it,
    a list of context actions appears, allowing users to select an action for editing
    or deleting the current item.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前实现的列表视图 UI 中，我们创建了一个包含密码条目和组的列表。当选择一个项目时，实际上点击了一个锚点标签 `<a>`。`<a>` 的 `href`
    属性设置为 `GetActionLink` 方法的返回值。此返回值遵循 `"/{itemType}/{item.Id}"` 路由模板格式，允许导航到所需的项目。此外，每个项目右侧都有一个上下文菜单按钮。点击它时，会出现一个上下文动作列表，允许用户选择一个动作来编辑或删除当前项目。
- en: We have now managed to handle most of the navigation actions; however, two actions
    are still lacking. We are unable to navigate back after entering a child group
    and cannot add a new item. In the following section, we will address these two
    functionalities.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功处理了大部分的导航操作；然而，还有两个操作尚未实现。在进入子组后，我们无法进行回退导航，也无法添加新项目。在下一节中，我们将解决这两个功能。
- en: Adding a new item and navigating back
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新项目和回退导航
- en: 'To facilitate navigation back to the previous page and the addition of new
    items, we can incorporate a `Back` button and an `Add` button in the title bar.
    This simulates the navigation page of the XAML version, as demonstrated in *Figure
    9.7*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便导航回上一页和添加新项目，我们可以在标题栏中添加一个 `Back` 按钮和一个 `Add` 按钮。这模拟了 XAML 版本的导航页面，如图 *图
    9.7* 所示：
- en: '![Figure 8.7: The Title bar of the Items page](img/B21554_09_07.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7：项目页面标题栏](img/B21554_09_07.png)'
- en: 'Figure 9.7: The title bar of the Items page'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：项目页面标题栏
- en: 'As observed in the title bar, three UI elements are included:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如标题栏所示，包括三个 UI 元素：
- en: '**Title** – Representing the current item group’s title'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题** – 表示当前项目组的标题'
- en: '**Back** button – Facilitating navigation back; however, it remains hidden
    when there is no parent group'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回** 按钮 – 促进回退导航；然而，在没有父组时保持隐藏'
- en: '**Add** button – Enabling the addition of a new item'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加** 按钮 – 启用添加新项的功能'
- en: 'To examine the implementation, let’s expand the code for the `Back` button
    and the `Title` section in *Listing 9.7*, as demonstrated below:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查实现，让我们扩展 `Back` 按钮和 `Title` 部分的代码，如下所示，如 *Listing 9.7* 中所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The **Back button** **(1)** is implemented using an anchor tag, `<a>`. The `href`
    attribute of this anchor tag is set to the return value of the `Item` extension
    method, `GetParentLink`. This function returns the parent item’s link in the route
    template format, enabling navigation back through this link. If there is no parent
    group, such as a root group, the `Back` button remains invisible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回按钮** **(1**) 是通过一个锚标签 `<a>` 实现的。这个锚标签的 `href` 属性被设置为 `Item` 扩展方法的返回值，即
    `GetParentLink`。这个函数返回父项的链接，以路由模板格式，从而可以通过这个链接进行导航回退。如果没有父组，例如根组，则“返回”按钮保持不可见。'
- en: 'The **Add button** **(2)** is implemented using a `<button>` tag and is displayed
    on the right-hand side of the title bar. To position the button on the right side
    of the screen, we can utilize the Bootstrap class, `float-end`. When a user clicks
    on this button, a new item dialog box appears. This dialog box is configured using
    the following attributes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加按钮** **(2**) 是通过一个 `<button>` 标签实现的，并显示在标题栏的右侧。为了将按钮定位在屏幕的右侧，我们可以利用Bootstrap类，`float-end`。当用户点击此按钮时，会出现一个新的项目对话框。此对话框使用以下属性进行配置：'
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `Items.razor`, as depicted in *Listing 9.7*, three Bootstrap modal dialogs
    are utilized:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Items.razor` 中，如 *Listing 9.7* 所示，使用了三个Bootstrap模态对话框：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These dialogs are utilized to perform CRUD operations. To implement them, we
    also reuse code from Bootstrap. While this approach is relatively straightforward,
    it does involve a significant amount of duplicated code. To conserve space, the
    details have been collapsed in *Listing 9.7*. In the subsequent chapter, we will
    delve into the implementation of modal dialogs and demonstrate how to transform
    the code into reusable Razor components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对话框用于执行CRUD操作。为了实现它们，我们还重用了Bootstrap中的代码。虽然这种方法相对简单，但它确实涉及大量的代码重复。为了节省空间，细节已在
    *Listing 9.7* 中折叠。在下一章中，我们将深入研究模态对话框的实现，并展示如何将代码转换为可重用的Razor组件。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the routing and layout of Blazor, which are essential
    components for constructing the navigation hierarchy of our application. By the
    end of this chapter, we are now capable of executing basic navigation, similar
    to the functionality offered by the XAML version of our app.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Blazor的路由和布局，这些是构建我们应用程序导航层次结构的基本组件。到本章结束时，我们现在能够执行基本的导航，类似于我们应用程序的XAML版本提供的功能。
- en: Throughout the UI construction process in this chapter, we observed that the
    UI design technique of Blazor aligns with conventional web UI design practices.
    This allows for the reuse of code from existing frameworks, such as Bootstrap.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个UI构建过程中，我们观察到Blazor的UI设计技术与传统Web UI设计实践相一致。这允许重用来自现有框架（如Bootstrap）的代码。
- en: When creating a custom UI, it is often beneficial to design the initial layout
    in a playground first. Once satisfied with the UI design, the HTML and CSS code
    can be copied into a Razor file to construct a Razor component. Several playgrounds
    popular among frontend developers can also be utilized by Blazor developers, including
    CodePen, JSFiddle, CodeSandbox, and StackBlitz.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义用户界面时，首先在游乐场中设计初始布局通常是有益的。一旦对UI设计感到满意，可以将HTML和CSS代码复制到Razor文件中，以构建Razor组件。Blazor开发者也可以利用几个在前端开发者中流行的游乐场，包括CodePen、JSFiddle、CodeSandbox和StackBlitz。
- en: In this chapter, we utilized Bootstrap examples to construct our UIs. Although
    this approach offers a simple method for implementing a web UI, it results in
    a significant amount of duplicated code. In the upcoming chapter, we will streamline
    our code and transform it into reusable Razor components. By employing these Razor
    components, we will carry out CRUD operations to add, edit, and delete items.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了Bootstrap示例来构建我们的UI。虽然这种方法为实施Web UI提供了一个简单的方法，但它导致了大量的代码重复。在下一章中，我们将简化我们的代码，并将其转换为可重用的Razor组件。通过使用这些Razor组件，我们将执行CRUD操作以添加、编辑和删除项。
- en: Learn more on Discord
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
- en: '![](img/QR_Code166522361691420406.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code166522361691420406.png)'
