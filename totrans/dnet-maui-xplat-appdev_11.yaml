- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Blazor Routing and Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the process of designing a login page using
    Blazor. Although the app layout and navigation hierarchy remain XAML-based, our
    app utilizes a hybrid UI implementation that combines both Blazor and XAML. Blazor
    offers an alternative approach to UI design for .NET MAUI apps. In this second
    part of the book, we will reconstruct the entire UI using Blazor exclusively.
    Since the initial step of UI design typically involves the implementation of layout
    and navigation, this chapter will introduce the concepts of layout and routing
    within Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side Blazor routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Blazor layout components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing navigation elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter09](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/dcbd1d8d55bea3adccb3153f59b2d0152c282dd2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding client-side routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The routing and layout of Blazor bear similarities to the concepts of Shell
    and navigation in the XAML realm. In *Chapter 5**, Navigation Using .NET MAUI
    Shell and NavigationPage*, we introduced navigation and Shell while discussing
    the routing strategy of Shell. Shell offers a URI-based navigation experience
    that relies on routes to navigate to designated pages. The routing of Blazor closely
    resembles this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor routing allows for seamless transitions between Razor pages. Rendering
    Razor pages in `BlazorWebView` is akin to web apps operating in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional web applications, loading an HTML page in a browser fetches the
    page from the web server. Selecting a different route subsequently retrieves a
    new page from the server. However, the process varies slightly for **single-page
    applications** (**SPAs**).
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly applications fall under the category of SPAs. When launching
    an app, it is loaded into the browser, and any subsequent page navigation occurs
    solely on the client side. This approach is known as client-side routing, which
    is also employed by Blazor Hybrid apps.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up BlazorWebView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement client-side routing, the router must be installed during the application’s
    startup. In .NET MAUI apps, both XAML and Blazor entry points are configured in
    `App.xaml.cs`. To switch the UI implementation from XAML to Blazor, refer to the
    modifications made to `App.xaml.cs` within the provided code.
  prefs: []
  type: TYPE_NORMAL
- en: A Blazor Hybrid app operates within `BlazorWebView`. To initiate the Blazor
    Hybrid app, it is necessary to establish an instance of `BlazorWebView` first.
    In the previous chapter, we accomplished this setup in `LoginPage` and successfully
    navigated back to Shell after logging in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a `BlazorWebView` instance for the entire application, it is necessary
    to replace the instance assigned to the `MainPage` property within the `App` class.
    To achieve this, we modified the constructor of the `App` class (found in `App.xaml.cs`)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a symbol, `MAUI_BLAZOR`, to facilitate conditional compilation,
    enabling the ability to switch between XAML and the Blazor UI during the build
    process. To utilize the Blazor UI, we assign the `MainPage` property to a `MainPage`
    instance **(1)**. Within the `MainPage` class, we define the `BlazorWebView` control
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Within `BlazorWebView`, an HTML page (`index.xhtml`) is loaded to initiate the
    Blazor UI setup. Let’s examine how the router configuration operates.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Router component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Blazor UI employs an HTML page-based design, resembling the structure of
    an SPA that originates from a static HTML page. Within `BlazorWebView`, the initial
    HTML page to be loaded is `index.xhtml`. This closely resembles the `login.xhtml`
    page we discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level Razor component, loaded in `RootComponent`, appears as the `Main`
    component, which can be viewed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.1: `Main.razor` ([https://epa.ms/Main9-1](https://epa.ms/Main9-1))'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Listing 9.1*, we set up the `Router` component, **(1)**, in
    `Main.razor`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Router` component employs reflection to scan all page components and construct
    a routing table. The `AppAssembly` parameter determines which assemblies will
    be scanned. Upon encountering a navigation event, the router consults the routing
    table for a corresponding route. The `Router` component is, in essence, a templated
    component, which we will explore further in the next chapter. When a matching
    route is identified, the `Found` template is utilized. Conversely, if no matching
    routes are present, the `NotFound` template comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The `Found` template, **(2)**, employs a `RouteView` component to render the
    chosen component alongside its layout. The layout is specified in the `DefaultLayout`
    attribute, which we will examine in the upcoming section. Additionally, the new
    page to be loaded, as well as any route parameters, is passed using an instance
    of the `RouteData` class.
  prefs: []
  type: TYPE_NORMAL
- en: If a match cannot be found, the `NotFound` template, **(3)**, is rendered. This
    template utilizes a `LayoutView` component to display error messages. The layout
    employed by `LayoutView` is designated via a `Layout` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Defining routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After setting up the router, we can proceed to create pages and define route
    templates within those pages. The router will then scan the route templates defined
    in the pages to construct a routing table.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top level of our app, the navigation hierarchy and route templates can
    be established by referring to *Figure 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Navigation hierarchy of Razor pages](img/B21554_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Navigation hierarchy of Razor pages'
  prefs: []
  type: TYPE_NORMAL
- en: 'We presented the primary pages of our app in *Figure 9.1*. Each page possesses
    a name, which corresponds to the class name of a Razor page. Located beneath the
    name is the route template. For instance, for the `About` page, the route template
    can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@page` directive comprises two components – the directive name and the
    route template. In this example, the route template is `/about`, which must be
    enclosed in quotes and always begin with a forward slash (`/`). Given that a Razor
    page’s final output is an HTML page, navigation to a Razor page can be treated
    like navigating to a web page using an anchor tag, `<a>`, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Passing data using route parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When navigating to a page using a route template, data can be passed to the
    page through route parameters. If we recall the process of passing data with query
    parameters in Shell, the use of route parameters is quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in *Figure 9.1*, after successfully logging in, the `Items` page
    appears, displaying a list of items in the root group, as shown in *Figure 9.2*.
    On this page, clicking on an item allows navigation based on the item type. To
    identify the selected item, an item `Id` value is passed to the new page as a
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Items page in a Blazor Hybrid app](img/B21554_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Items page in a Blazor Hybrid app'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Items` page, we have the following route templates defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first route template is employed when displaying the root page, while the
    second comes into play upon selecting a group. The group `Id` value is transmitted
    to the `Items` page using the `SelectedItemId` route parameter. To designate the
    type of route parameter, we can incorporate constraints tied to the data type,
    as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding page directive, we define the data type of `Id` as an integer.
    For more information about route constraints, please refer to the relevant Microsoft
    documentation. You can access the pertinent document here: [https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-8.0#route-constraints](https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-8.0#route-constraints).'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating with NavigationManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a Razor page, navigation to another page typically involves using an `<a>`
    anchor tag. However, under certain circumstances, it may be necessary to perform
    the action via code. One such instance is when handling an event, where redirection
    to a page occurs within the event handler. This is precisely the situation on
    our `Login` page. Let’s explore how to navigate to the `Items` page using `NavigationManager`
    once a successful login has been achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, after logging in, we must redirect users to the `Items` page to
    display the root group. The user interface for the `Login` page remains unchanged
    from the previous chapter; however, we have modified the event handler in `Login.razor.cs`
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We obtain an instance of `NavigationManager` through dependency injection **(1)**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we invoke the `NavigateTo("/group")` method of `NavigationManager` to
    facilitate navigation to the `Items` page **(2)**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored routing and navigation. As a next step, we can
    implement a navigation hierarchy akin to that of Shell navigation within the Blazor
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: The top level of the HTML page navigation hierarchy encompasses a header, toolbar,
    menu, and footer. We can design this layout using a Blazor layout component, which
    shares similarities with the flyout and menu items in Shell. We previously introduced
    these concepts in *Chapter 5**, Navigation Using .NET MAUI Shell and NavigationPage*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Blazor layout components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web pages typically feature fixed elements such as headers, footers, or
    menus. By designing a page with a layout combined with its content, we can minimize
    redundant code. The page itself displays the content intended for users, while
    the layout assists in constructing visual styles and providing navigational methods.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor layout components are classes derived from `LayoutComponentBase`. Any
    functionality applicable to regular Razor components can also be applied to layout
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 9.1*, we observe that `MainLayout` serves as the default layout
    for the pages. Its definition can be found in *Listing 9.2*, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.2: `MainLayout.razor` ([https://epa.ms/MainLayout9-2](https://epa.ms/MainLayout9-2))'
  prefs: []
  type: TYPE_NORMAL
- en: The **MainLayout** component **(1)** inherits from the `LayoutComponentBase`
    class. The component features a **NavMenu** **(2)** to outline the navigation
    menu. Within the `<main>` tag **(3)**, the `@Body` Razor syntax designates the
    location in the layout markup for rendering content.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to thoroughly examine the `NavMenu` component, as it serves
    as the primary navigation method within the app. Please refer to *Figure 9.3*
    for a visual representation of the **NavMenu** interface before reviewing the
    code. **NavMenu** comprises three menu items: **Home**, **About**, and **Logout**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: NavMenu](img/B21554_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: NavMenu'
  prefs: []
  type: TYPE_NORMAL
- en: '`NavMenu` is a Razor component responsible for defining the links used in navigation.
    The source code for `NavMenu` can be found in *Listing 9.3*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.3: `NavMenu.razor` ([https://epa.ms/NavMenu9-3](https://epa.ms/NavMenu9-3))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the source code of the `NavMenu` component, we can observe that it consists
    of a Bootstrap `navBar` component accompanied by some C# logic within the code
    block. The `NavBar` is defined using a `navbar` Bootstrap class in the following
    `<div>` tag **(1)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As illustrated in *Figure 9.3*, a hamburger icon, **(2)**, is positioned at
    the top right of the screen, utilizing a `<button>` tag to toggle `NavMenu`. The
    hamburger button UI is implemented using the Bootstrap class, `navbar-toggler`,
    as detailed below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Three links are defined as menu items, utilizing the `nav-item` Bootstrap class
    **(3)**. Instead of employing the anchor tag, `<a>`, `NavLink` is used **(4)**.
    The `NavLink` component functions similarly to `<a>`. However, it toggles an `active`
    CSS class, contingent on whether its `href` matches the current URL, as demonstrated
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We previously discussed `MainLayout`, which serves as the default layout in
    our app. Now, let’s examine how to apply this layout to a component.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a layout to a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MainLayout` serves as the default layout component, applying to all pages
    unless an alternative layout is specified. In certain scenarios, we may need to
    use a unique layout rather than the default one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, within our app, we employ a distinct layout component for the
    `Login` page instead of the default layout (refer to *Listing 9.4*). `MainLayout`
    incorporates a `NavMenu` component, which we do not wish to display on the `Login`
    page since users should not access other content before logging in. Let’s examine
    the alterations made to the `Login` page after applying a specific layout, as
    shown in *Listing 9.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.4: `Login.razor` ([https://epa.ms/Login9-4](https://epa.ms/Login9-4))'
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a specific layout, we can utilize the `@layout` Razor directive **(1)**.
    On the `Login` page, we implement the `LogoutLayout`. The code for `LogoutLayout`
    is presented in *Listing 9.5*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.5: `LogoutLayout.razor` ([https://epa.ms/LogoutLayout9-5](https://epa.ms/LogoutLayout9-5))'
  prefs: []
  type: TYPE_NORMAL
- en: In `LogoutLayout`, we eliminated the `NavMenu` element and incorporated a sign-in
    link, enabling new users to register for an account.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Layout components can be nested as well. In `MainLayout`, we did not specify
    any margin for the content. While this layout is suitable for content list views
    on items pages or item details pages, it may not be visually appealing for content
    pages like the `About` page. To improve this, we can employ a distinct layout
    for the `About` page that is nested within `MainLayout`. Let’s call it `PageLayout`,
    and its implementation can be found in *Listing 9.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.6: `PageLayout.razor` ([https://epa.ms/PageLayout9-6](https://epa.ms/PageLayout9-6))'
  prefs: []
  type: TYPE_NORMAL
- en: '`PageLayout` is a layout component that utilizes `MainLayout`. It places `@Body`
    inside an `<article>` tag with the `"content px-4"` style applied, thereby enabling
    the content to adopt a style that is appropriate for a paragraph of text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `About` page, we can designate the layout as `PageLayout` in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have now covered the basics of routing and layout in Blazor. Armed with this
    knowledge, we can proceed to implement the navigation elements within our app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing navigation elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Navigation Using .NET MAUI Shell and NavigationPage*, we introduced
    the concepts of absolute and relative routes within Shell. Absolute routes can
    be defined in a visual navigation hierarchy, while relative routes are navigable
    using query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This navigation approach closely resembles the strategy employed in the Blazor
    version of our app. As illustrated in *Figure 9.4*, we implement Blazor UI elements
    in a manner similar to the XAML version.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Navigation elements](img/B21554_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Navigation elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Items` page serves as the main page of our app after login. On this page,
    which displays a list of items, the following UI elements are related to navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A list view** – Users can navigate the list and select an item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context menu** – Associated with each item in the list view, enabling users
    to edit or delete items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Back button** – Allows users to navigate back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add button** – Enables users to add new items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will leverage the knowledge we have acquired to implement
    the aforementioned navigation elements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a list view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the XAML version, our navigation begins with a list of items once the user
    logs in to the app. The list view is implemented using a .NET MAUI `ListView`
    control, which leverages platform-specific UI components for a consistent look
    and feel across platforms. In the Blazor version, we utilize a web-based UI, ensuring
    a uniform appearance on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to implementing a list view with a web UI, we have numerous options
    to choose from. Throughout this book, we adhere to the Bootstrap framework. Our
    methodology, as demonstrated in the previous chapter, involves reusing UI designs
    from Bootstrap examples. Since we’re employing Bootstrap 5.1 in this book, we
    can reference the list group example depicted in *Figure 9.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Bootstrap list group](img/B21554_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Bootstrap list group'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example can be accessed via this URL: [https://getbootstrap.com/docs/5.1/components/list-group/](https://getbootstrap.com/docs/5.1/components/list-group/).'
  prefs: []
  type: TYPE_NORMAL
- en: A Bootstrap list group can be employed to construct a UI component similar to
    the `ListView` in XAML. To achieve this, we can apply the CSS class `"``list-group"`
    to HTML tags, such as `<ul>` or `<div>`, to create a list group. Within the list
    group, the `"list-group-item"` CSS class is applied to individual list items in
    the group.
  prefs: []
  type: TYPE_NORMAL
- en: In the XAML version, we facilitated CRUD operations using the context menu.
    However, the Bootstrap list group does not feature a built-in context menu, so
    we have to implement one ourselves. To create a context menu within the list group,
    we can utilize the Bootstrap `dropdown` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to employ the `dropdown` component, it is necessary to include the
    JavaScript dependency in `index.xhtml`, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We included a JavaScript file, `bootstrap.bundle.min.js`, following `blazor.webview.js`.
    The `bootstrap.bundle.min.js` file is a component of the Bootstrap release package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new Razor component called `Items`, simply right-click on the **Pages**
    folder in Visual Studio and choose **Add** -> **Razor Component**`…`. After this,
    insert the code provided in *Listing 9.7* and name the Razor file `Items.razor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.7: `Items.razor` ([https://epa.ms/Items9-7](https://epa.ms/Items9-7))'
  prefs: []
  type: TYPE_NORMAL
- en: In `Items.razor` **(1)**, we can copy the Bootstrap list group sample code that
    utilizes the `<div>` tag with the `list-group` CSS class applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We customize the list group item to meet our requirements **(2)**, as demonstrated
    in *Figure 9.6*. The list group item is created within a `foreach` loop using
    the `<div>` tag, containing an icon, a name, a description, and a context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We apply the `dropdown`, `list-group-item`, and `list-group-item-action` CSS
    classes to the `<div>` tag, transforming it into a list group item that incorporates
    a context menu using a dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: List group item](img/B21554_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: List group item'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the list group item, we utilize an `<img>` tag to display the item’s
    icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can obtain the icon source by using an extension method called `GetIcon`
    from the `Item` class. To create this extension method, we need to add a new class
    file under the `Shared` folder and name it `ItemEx.cs`, as demonstrated in *Listing
    9.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `<a>` anchor tag is utilized to display the item’s name and description.
    The name and description are defined within the `<a>` tag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The item’s link can be obtained using the `GetActionLink` extension method,
    which is also defined in *Listing 9.8*.
  prefs: []
  type: TYPE_NORMAL
- en: The context menu is a Bootstrap dropdown component that comprises a `<button>`
    tag **(3)** and an unordered list created with the `<ul>` tag **(4)**. Utilizing
    the Open Iconic icons, this button appears as a hamburger icon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Iconic icons**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Blazor UI design, we utilize Open Iconic icons. Open Iconic is an open-source
    icon set featuring 223 icons in SVG, web font, and raster formats. For XAML design,
    FontAwesome is used, which can also be implemented in Blazor alongside Bootstrap.
    However, additional configuration is required prior to its use. Open Iconic comes
    bundled with the Blazor template and is included with Bootstrap. As a result,
    we can use it directly without any extra configuration. For instance, to display
    a hamburger icon in the context menu, the following HTML tag can be employed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the drop-down menu, there are two context action buttons: `Edit` and `Delete`.
    We apply the `dropdown-item` CSS class to these buttons. The context action button
    triggers a dialog box to perform CRUD operations, hence the inclusion of two Bootstrap
    modal CSS attributes, `data-bs-toggle` and `data-bs-target`. We will discuss handling
    CRUD operations in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s review the extension methods of `Item` that we will use to support
    a list view UI, as shown in *Listing 9.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.8: `ItemEx.cs` ([https://epa.ms/ItemEx9-8](https://epa.ms/ItemEx9-8))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 9.8*, we create a static class called `ItemEx` to implement extension
    methods for the **Item** class. Within this class, we define three extension methods
    to obtain the necessary URL for navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetIcon` **(1)** – Returns the icon image’s URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetActionLink` **(2)** – Returns the URL of a selected item based on its type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetParentLink` **(3)** – Returns the URL of the parent item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous implementation of the list view UI, we created a list comprising
    both password entries and groups. When an item is selected, an anchor tag, `<a>`,
    is actually clicked. The `href` property of `<a>` is set to the return value of
    the `GetActionLink` method. This return value follows a `"/{itemType}/{item.Id}"`
    route template format, enabling navigation to the desired item. Additionally,
    a context menu button is situated to the right of each item. Upon clicking it,
    a list of context actions appears, allowing users to select an action for editing
    or deleting the current item.
  prefs: []
  type: TYPE_NORMAL
- en: We have now managed to handle most of the navigation actions; however, two actions
    are still lacking. We are unable to navigate back after entering a child group
    and cannot add a new item. In the following section, we will address these two
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new item and navigating back
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To facilitate navigation back to the previous page and the addition of new
    items, we can incorporate a `Back` button and an `Add` button in the title bar.
    This simulates the navigation page of the XAML version, as demonstrated in *Figure
    9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: The Title bar of the Items page](img/B21554_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: The title bar of the Items page'
  prefs: []
  type: TYPE_NORMAL
- en: 'As observed in the title bar, three UI elements are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Title** – Representing the current item group’s title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Back** button – Facilitating navigation back; however, it remains hidden
    when there is no parent group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add** button – Enabling the addition of a new item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To examine the implementation, let’s expand the code for the `Back` button
    and the `Title` section in *Listing 9.7*, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The **Back button** **(1)** is implemented using an anchor tag, `<a>`. The `href`
    attribute of this anchor tag is set to the return value of the `Item` extension
    method, `GetParentLink`. This function returns the parent item’s link in the route
    template format, enabling navigation back through this link. If there is no parent
    group, such as a root group, the `Back` button remains invisible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Add button** **(2)** is implemented using a `<button>` tag and is displayed
    on the right-hand side of the title bar. To position the button on the right side
    of the screen, we can utilize the Bootstrap class, `float-end`. When a user clicks
    on this button, a new item dialog box appears. This dialog box is configured using
    the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Items.razor`, as depicted in *Listing 9.7*, three Bootstrap modal dialogs
    are utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These dialogs are utilized to perform CRUD operations. To implement them, we
    also reuse code from Bootstrap. While this approach is relatively straightforward,
    it does involve a significant amount of duplicated code. To conserve space, the
    details have been collapsed in *Listing 9.7*. In the subsequent chapter, we will
    delve into the implementation of modal dialogs and demonstrate how to transform
    the code into reusable Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the routing and layout of Blazor, which are essential
    components for constructing the navigation hierarchy of our application. By the
    end of this chapter, we are now capable of executing basic navigation, similar
    to the functionality offered by the XAML version of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the UI construction process in this chapter, we observed that the
    UI design technique of Blazor aligns with conventional web UI design practices.
    This allows for the reuse of code from existing frameworks, such as Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a custom UI, it is often beneficial to design the initial layout
    in a playground first. Once satisfied with the UI design, the HTML and CSS code
    can be copied into a Razor file to construct a Razor component. Several playgrounds
    popular among frontend developers can also be utilized by Blazor developers, including
    CodePen, JSFiddle, CodeSandbox, and StackBlitz.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we utilized Bootstrap examples to construct our UIs. Although
    this approach offers a simple method for implementing a web UI, it results in
    a significant amount of duplicated code. In the upcoming chapter, we will streamline
    our code and transform it into reusable Razor components. By employing these Razor
    components, we will carry out CRUD operations to add, edit, and delete items.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
