["```kt\n/// <summary>\n/// FixedUpdate is a prime place to put physics\n/// calculations happening over a period of time.\n/// </summary>\nvoid FixedUpdate()\n{\n    // Check if we're moving to the side\n    var horizontalSpeed = Input.GetAxis(\"Horizontal\") *\n        dodgeSpeed;\n    /* If the mouse is held down (or the screen is pressed\n     * on Mobile) */\n    if (Input.GetMouseButton(0))\n    {\n        /* Get a reference to the camera for converting\n         * between spaces */\n        var cam = Camera.main;\n        /* Converts mouse position to a 0 to 1 range */\n        var screenPos = Input.mousePosition;\n        var viewPos = cam.ScreenToViewportPoint(screenPos);\n        float xMove = 0;\n        /* If we press the right side of the screen */\n        if (viewPos.x < 0.5f)\n        {\n            xMove = -1;\n        }\n        else\n        {\n            /* Otherwise we're on the left */\n            xMove = 1;\n        }\n        /* Replace horizontalSpeed with our own value */\n        horizontalSpeed = xMove * dodgeSpeed;\n    }\n    rb.AddForce(horizontalSpeed, 0, rollSpeed);\n}\n```", "```kt\n    /// <summary>\n    /// FixedUpdate is a prime place to put physics\n    /// calculations happening over a period of time.\n    /// </summary>\n    void FixedUpdate()\n    {\n        // Check if we're moving to the side\n        var horizontalSpeed = Input.GetAxis(\"Horizontal\")\n            * dodgeSpeed;\n        /* Check if Input has registered more than 0\n           touches */\n        if (Input.touchCount > 0)\n        {\n            /* Get a reference to the camera for\n               converting between spaces */\n            var cam = Camera.main;\n            /* Store the first touch detected */\n            var firstTouch = Input.touches[0];\n            /* Converts mouse position to a 0 to 1 range\n            */\n            var screenPos = firstTouch.position;\n            var viewPos =\n                cam.ScreenToViewportPoint(screenPos);\n            float xMove = 0;\n            /* If we press the right side of the screen */\n            if (viewPos.x < 0.5f)\n            {\n                xMove = -1;\n            }\n            else\n            {\n                /* Otherwise we're on the left */\n                xMove = 1;\n            }\n            /* Replace horizontalSpeed with our own value\n            */\n            horizontalSpeed = xMove * dodgeSpeed;\n        }\n        rb.AddForce(horizontalSpeed, 0, rollSpeed);\n    }\n    ```", "```kt\n    /// <summary>\n    /// Will figure out where to move the player\n    /// horizontally\n    /// </summary>\n    /// <param name=\"screenPos\">The position the player\n    /// has touched/clicked on in screen space</param>\n    /// <returns>The direction to move in the x\n        axis</returns>\n    private float CalculateMovement(Vector3 screenPos)\n    {\n        /* Get a reference to the camera for converting\n         * between spaces */\n        var cam = Camera.main;\n        /* Converts mouse position to a 0 to 1 range */\n        var viewPos =\n            cam.ScreenToViewportPoint(screenPos);\n        float xMove = 0;\n        /* If we press the right side of the screen */\n        if (viewPos.x < 0.5f)\n        {\n            xMove = -1;\n        }\n        else\n        {\n            /* Otherwise we're on the left */\n            xMove = 1;\n        }\n        /* Replace horizontalSpeed with our own value */\n        return xMove * dodgeSpeed;\n    }\n    ```", "```kt\n    /// <summary>\n    /// FixedUpdate is a prime place to put physics\n    /// calculations happening over a period of time.\n    /// </summary>\n    void FixedUpdate()\n    {\n        // Check if we're moving to the side\n        var horizontalSpeed = Input.GetAxis(\"Horizontal\")\n            * dodgeSpeed;\n        /* Check if we are running either in the Unity\n           editor or in a * standalone build.*/\n        #if UNITY_STANDALONE || UNITY_WEBPLAYER ||\n            UNITY_EDITOR\n            /* If the mouse is held down (or the screen is\n               tapped * on Mobile */\n            if (Input.GetMouseButton(0))\n            {\n                var screenPos = Input.mousePosition;\n                horizontalSpeed =\n                    CalculateMovement(screenPos);\n            }\n        /* Check if we are running on a mobile device */\n        #elif UNITY_IOS || UNITY_ANDROID\n            // Check if Input has registered more than\n            // zero touches\n            if (Input.touchCount > 0)\n            {\n                /* Store the first touch detected */\n                var firstTouch = Input.touches[0];\n                var screenPos = firstTouch.position;\n                horizontalSpeed =\n                    CalculateMovement(screenPos);\n            }\n        #endif\n        rb.AddForce(horizontalSpeed, 0, rollSpeed);\n    }\n    ```", "```kt\n    [Header(\"Swipe Properties\")]\n    [Tooltip(\"How far will the player move upon swiping\")]\n    public float swipeMove = 2f;\n    [Tooltip(\"How far must the player swipe before we will\n        execute the action (in inches)\")]\n    public float minSwipeDistance = 0.25f;\n    /// <summary>\n    /// Used to hold the value that converts\n    /// minSwipeDistance to pixels\n    /// </summary>\n    private float minSwipeDistancePixels;\n    /// <summary>\n    /// Stores the starting position of mobile touch\n    /// events\n    /// </summary>\n    private Vector2 touchStart;\n    ```", "```kt\n    // Start is called before the first frame update\n    public void Start()\n    {\n        // Get access to our Rigidbody component\n        rb = GetComponent<Rigidbody>();\n        minSwipeDistancePixels = minSwipeDistance *\n            Screen.dpi;\n    }\n    ```", "```kt\n    /// <summary>\n    /// Update is called once per frame\n    /// </summary>\n    private void Update()\n    {\n        /* Check if we are running on a mobile device */\n        #if UNITY_IOS || UNITY_ANDROID\n            /* Check if Input has registered more than\n               zero touches */\n            if (Input.touchCount > 0)\n            {\n                /* Store the first touch detected */\n                Touch touch = Input.touches[0];\n                SwipeTeleport(touch);\n            }\n        #endif\n    }\n    ```", "```kt\n/// <summary>\n/// Will teleport the player if swiped to the left or\n/// right\n/// </summary>\n/// <param name=\"touch\">Current touch event</param>\nprivate void SwipeTeleport(Touch touch)\n{\n    /* Check if the touch just started */\n    if (touch.phase == TouchPhase.Began)\n    {\n        /* If so, set touchStart */\n        touchStart = touch.position;\n    }\n    /* If the touch has ended */\n    else if (touch.phase == TouchPhase.Ended)\n    {\n        /* Get the position the touch ended at */\n        Vector2 touchEnd = touch.position;\n        /* Calculate the difference between the\n           beginning and end of the touch on the x\n           axis. */\n        float x = touchEnd.x - touchStart.x;\n        /* If not moving far enough, don't do the\n           teleport */\n        if (Mathf.Abs(x) < minSwipeDistancePixels)\n        {\n            return;\n        }\n        Vector3 moveDirection;\n        /* If moved negatively in the x axis, move\n           left */\n        if (x < 0)\n        {\n            moveDirection = Vector3.left;\n        }\n        else\n        {\n            /* Otherwise player is on the right */\n            moveDirection = Vector3.right;\n        }\n        RaycastHit hit;\n        /* Only move if player wouldn't hit something\n        */\n        if (!rb.SweepTest(moveDirection, out hit,\n        swipeMove))\n        {\n            /* Move the player */\n            var movement = moveDirection * swipeMove;\n            var newPos = rb.position + movement;\n            rb.MovePosition(newPos);\n        }\n    }\n}\n```", "```kt\n    [Header(\"Scaling Properties\")]\n    [Tooltip(\"The minimum size (in Unity units) that the\n        player should be\")]\n    public float minScale = 0.5f;\n    [Tooltip(\"The maximum size (in Unity units) that the\n        player should be\")]\n    public float maxScale = 3.0f;\n    /// <summary>\n    /// The current scale of the player\n    /// </summary>\n    private float currentScale = 1;\n    ```", "```kt\n    /// <summary>\n    /// Will change the player's scale via pinching and\n    /// stretching two touch events\n    /// </summary>\n    private void ScalePlayer()\n    {\n        /* We must have two touches to check if we are\n         * scaling the object */\n        if (Input.touchCount != 2)\n        {\n            return;\n        }\n        else\n        {\n            /* Store the touches detected. */\n            Touch touch0 = Input.touches[0];\n            Touch touch1 = Input.touches[1];\n            Vector2 t0Pos = touch0.position;\n            Vector2 t0Delta = touch0.deltaPosition;\n            Vector2 t1Pos = touch1.position;\n            Vector2 t1Delta = touch1.deltaPosition;\n            /* Find the previous frame position of each\n               touch. */\n            Vector2 t0Prev = t0Pos - t0Delta;\n            Vector2 t1Prev = t1Pos - t1Delta;\n            /* Find the the distance (or magnitude)\n               between the * touches in each frame. */\n            float prevTDeltaMag =\n                (t0Prev - t1Prev).magnitude;\n            float tDeltaMag = (t0Pos - t1Pos).magnitude;\n            /* Find the difference in the distances\n             * between each frame. */\n            float deltaMagDiff =\n                prevTDeltaMag - tDeltaMag;\n            /* Keep the change consistent no matter what\n             * the framerate is */\n            float newScale = currentScale;\n            newScale -= (deltaMagDiff * Time.deltaTime);\n            // Ensure that the new value is valid\n            newScale = Mathf.Clamp(newScale, minScale,\n                maxScale);\n            /* Update the player's scale */\n            transform.localScale = Vector3.one * newScale;\n            /* Set our current scale for the next frame */\n            currentScale = newScale;\n        }\n    }\n    ```", "```kt\n    /// <summary>\n    /// Update is called once per frame\n    /// </summary>\n    private void Update()\n    {\n        /* Check if we are running on a mobile device */\n        #if UNITY_IOS || UNITY_ANDROID\n            /* Check if Input has registered more than\n               zero touches */\n            if (Input.touchCount > 0)\n            {\n                /* Store the first touch detected */\n                Touch touch = Input.touches[0];\n                SwipeTeleport(touch);\n                ScalePlayer();\n            }\n        #endif\n    }\n    ```", "```kt\n    [Tooltip(\"How fast the ball moves forwards\n        automatically\")]\n    [Range(0, 10)]\n    public float rollSpeed = 5;\n    public enum MobileHorizMovement\n    {\n        Accelerometer,\n        ScreenTouch\n    }\n    [Tooltip(\"What horizontal movement type should be\n        used\")]\n    public MobileHorizMovement horizMovement =\n        MobileHorizMovement.Accelerometer;\n    [Header(\"Swipe Properties\")]\n    [Tooltip(\"How far will the player move upon swiping\")]\n    public float swipeMove = 2f;\n    ```", "```kt\n    /* Check if we are running on a mobile device */\n    #elif UNITY_IOS || UNITY_ANDROID\n        switch (horizMovement)\n        {\n            case MobileHorizMovement.Accelerometer:\n                /* Move player based on accelerometer\n                   direction */\n                horizontalSpeed = Input.acceleration.x *\n                    dodgeSpeed;\n                break;\n            case MobileHorizMovement.ScreenTouch:\n                /* Check if Input registered more than\n                   zero touches */\n                if (Input.touchCount > 0)\n                {\n                    /* Store the first touch detected */\n                    var firstTouch = Input.touches[0];\n                    var screenPos = firstTouch.position;\n                    horizontalSpeed =\n                        CalculateMovement(screenPos);\n                }\n                break;\n        }\n    #endif\n    // Check if we are running on a mobile device\n    #elif UNITY_IOS || UNITY_ANDROID\n    if(horizMovement == MobileHorizMovement.Accelerometer)\n    {\n    // Move player based on direction of the accelerometer\n    horizontalSpeed = Input.acceleration.x * dodgeSpeed;\n    }\n    //Check if Input has registered more than zero touches if (Input.touchCount > 0)\n    {\n        if (horizMovement ==\n        MobileHorizMovement.ScreenTouch)\n        {\n            //Store the first touch detected.\n            Touch touch = Input.touches[0];\n            horizontalSpeed =\n                CalculateMovement(touch.position);\n        }\n    }\n    #endif\n    ```", "```kt\n    /// <summary>\n    /// Will determine if we are touching a game object\n    /// and if so call events for it\n    /// </summary>\n    /// <param name=\"screenPos\">The position of the touch\n    /// in screen space</param>\n    private static void TouchObjects(Vector2 screenPos)\n    {\n        /* Convert the position into a ray */\n        Ray touchRay =\n            Camera.main.ScreenPointToRay(screenPos);\n        RaycastHit hit;\n        /* Create a LayerMask that will collide with all\n         * possible channels */\n        int layerMask = ~0;\n        /* Are we touching an object with a collider? */\n        if (Physics.Raycast(touchRay, out hit,\n        Mathf.Infinity, layerMask,\n        QueryTriggerInteraction.Ignore))\n        {\n            /* Call the PlayerTouch function if it exists\n             * on a component attached to this object */\n            hit.transform.SendMessage(\"PlayerTouch\",\n            SendMessageOptions.DontRequireReceiver);\n        }\n    }\n    /// <summary>\n    /// Will determine if we are touching a game object\n    /// and if so call events for it\n    /// </summary>\n    /// <param name=\"touch\">Our touch event</param> private static void TouchObjects(Touch touch)\n    {\n    // Convert the position into a ray\n    Ray touchRay =\n        Camera.main.ScreenPointToRay(touch.position);\n    RaycastHit hit;\n    // Create a LayerMask that will collide with all\n    // possible channels\n    int layerMask = ~0;\n    // Are we touching an object with a collider?\n    if (Physics.Raycast(touchRay, out hit, Mathf.Infinity, layerMask, QueryTriggerInteraction.Ignore))\n    {\n        // Call the PlayerTouch function if it exists on a\n        // component attached to this object\n        hit.transform.SendMessage(\"PlayerTouch\",\n            SendMessageOptions.DontRequireReceiver);\n    }\n    }\n    ```", "```kt\n    /// <summary>\n    /// Update is called once per frame\n    /// </summary>\n    private void Update()\n    {\n        /* Check if we are running either in the Unity\n           editor or in a\n         * standalone build.*/\n        #if UNITY_STANDALONE || UNITY_WEBPLAYER ||\n            UNITY_EDITOR\n        /* If the mouse is tapped */\n        if (Input.GetMouseButtonDown(0))\n        {\n            Vector2 screenPos = new Vector2(\n                Input.mousePosition.x,\n                    Input.mousePosition.y);\n            TouchObjects(screenPos);\n        }\n        /* Check if we are running on a mobile device */\n        #elif UNITY_IOS || UNITY_ANDROID\n            /* Check if Input has registered more than\n               zero touches */\n            if (Input.touchCount > 0)\n            {\n                /* Store the first touch detected */\n                Touch touch = Input.touches[0];\n                TouchObjects(touch.position);\n                SwipeTeleport(touch);\n                ScalePlayer();\n            }\n        #endif\n    }\n    ```", "```kt\n    [Tooltip(\"Explosion effect to play when tapped\")]\n    public GameObject explosion;\n    /// <summary>\n    /// If the object is tapped, we spawn an explosion and\n    /// destroy this object\n    /// </summary>\n    private void PlayerTouch()\n    {\n        if (explosion != null)\n        {\n            var particles = Instantiate(explosion,\n                transform.position,\n                    Quaternion.identity);\n            Destroy(particles, 1.0f);\n        }\n        Destroy(this.gameObject);\n    }\n    public GameObject explosion;\n    /// <summary>\n    /// If the object is tapped, we spawn an explosion and\n    /// destroy this object\n    /// </summary>\n    private void PlayerTouch()\n    {\n        if (explosion != null)\n        {\n            var particles = Instantiate(explosion,\n                transform.position, Quaternion.identity);\n            Destroy(particles, 1.0f);\n        }\n        Destroy(this.gameObject);\n    }\n    ```"]