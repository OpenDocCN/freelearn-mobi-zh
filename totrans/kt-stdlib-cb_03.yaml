- en: Shaping Code with Kotlin Functional Programming Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin函数式编程特性塑造代码
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Working effectively with lambda expressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用lambda表达式
- en: Discovering basic scoping functions – `let`, `also`, and `apply`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现基本的范围函数——`let`、`also`和`apply`
- en: Initializing objects the clean way using the `run` scoping function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`run`范围函数以干净的方式初始化对象
- en: Working with higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: Functions currying
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: Function composition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Implementing the Either Monad design pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Either Monad设计模式
- en: Approach to automatic function memoization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动函数记忆化的方法
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Despite the fact that Kotlin is recognized implicitly as an object-oriented
    language, it is still open to other programming styles and paradigms. Thanks to
    Kotlin's built-in features, we are able to apply functional programming patterns
    to our code with ease. Having the possibility to return functions from other functions
    or to pass a function as a parameter allows us to benefit from a deferred computation.
    In addition, we are able to return functions, instead of already-computed values,
    on different layers in the code. This results in the lazy-evaluation feature.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kotlin被隐式地认可为一种面向对象的语言，但它仍然对其他编程风格和范式持开放态度。多亏了Kotlin的内置特性，我们能够轻松地将函数式编程模式应用到我们的代码中。能够从其他函数中返回函数或传递一个函数作为参数，使我们能够从延迟计算中受益。此外，我们能够在代码的不同层返回函数，而不是已经计算出的值。这导致了懒加载特性的出现。
- en: Compared to Scala or other functional programming languages, Kotlin doesn't
    require us to use dedicated, functional style design patterns. It also lacks some
    of their out-of-the-box implementations. However, in return, it brings more flexibility
    to developers as far as software architecture and implementation details are concerned.
    The Kotlin language and standard library components provide full built-in support
    for basic functional programming concepts. And more sophisticated ones can always
    be implemented from scratch or reused from some of the available external libraries.
    The ones worth giving a try are the Kotlin Arrow ([http://arrow-kt.io](http://arrow-kt.io))
    and funKTionale ([https://github.com/MarioAriasC/funKTionale](https://github.com/MarioAriasC/funKTionale))
    projects. However, keep in mind the words of Robert C. Martin—*It is perfectly
    possible to write a program that is both object-oriented and functional. Not only
    is it possible, it is desirable. There is no "OO vs FP," the two are orthogonal
    and coexist nicely*<q>.</q> It should be understood that functional programming
    is only one available tool. It should be used wisely and only where it is applicable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与Scala或其他函数式编程语言相比，Kotlin不需要我们使用专门的函数式风格设计模式。它也缺乏它们的一些现成实现。然而，作为回报，它在软件架构和实现细节方面为开发者提供了更多的灵活性。Kotlin语言和标准库组件为基本的函数式编程概念提供了全面内置支持。更复杂的概念总是可以从头实现或从一些可用的外部库中重用。值得一试的项目有Kotlin
    Arrow ([http://arrow-kt.io](http://arrow-kt.io)) 和 funKTionale ([https://github.com/MarioAriasC/funKTionale](https://github.com/MarioAriasC/funKTionale))。然而，请记住罗伯特·C·马丁的话——*编写既面向对象又函数式的程序是完全可能的。这不仅可能，而且是可取的。不存在“OO
    vs FP”，两者是正交的，并且很好地共存*<q>。</q> 应该理解，函数式编程只是可用的工具之一。它应该被明智地使用，并且仅在适用的情况下使用。
- en: This chapter focuses on explaining functional programming features supported
    by Kotlin internally. It gives you hands-on experience in solving real-life problems
    by using state-of-the-art functional programming concepts. By the end of the chapter,
    you should be familiar with the Kotlin language support for the functional programming
    approach and standard library components that can help implement it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍Kotlin内部支持的函数式编程特性。它通过使用最先进的函数式编程概念来解决实际问题，为您提供了实践经验。到本章结束时，您应该熟悉Kotlin语言对函数式编程方法的支持以及可以帮助实现它的标准库组件。
- en: Working effectively with lambda expressions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用lambda表达式
- en: In this recipe, we are going to explore the concept of lambdas and closures.
    We are going to write part of an Android application code responsible for handling
    button-click actions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨lambda和闭包的概念。我们将编写一部分Android应用程序代码，负责处理按钮点击操作。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to implement this recipe's code, you need to create a new Android application
    project using Android Studio IDE.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个菜谱的代码，您需要使用Android Studio IDE创建一个新的Android应用程序项目。
- en: 'Let''s assume we have the following class, which is a sort of a controller of
    the application view layer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下类，它是一种应用视图层的控制器：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It contains a reference to the `submitButton: Button` instance. Inside the `onCreate()` function
    we are going to implement logic responsible for handling the button clicks. Once
    the button is clicked, we want to make it invisible.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '它包含对 `submitButton: Button` 实例的引用。在 `onCreate()` 函数中，我们将实现处理按钮点击的逻辑。一旦按钮被点击，我们希望使其不可见。'
- en: 'In order to invoke some action when the button is clicked, we need to call
    the `View.setOnClickListener(listener: OnClickListener)` function on the `View`
    subclass. The `OnClickListener` is a functional interface defined as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '为了在按钮点击时执行某些操作，我们需要在 `View` 子类上调用 `View.setOnClickListener(listener: OnClickListener)`
    函数。`OnClickListener` 是一个如下定义的函数式接口：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Under the hood, the Android OS invokes the `onClick()` function when the user
    clicks the view.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，当用户点击视图时，Android 操作系统会调用 `onClick()` 函数。
- en: 'There are two ways of implementing a functional interface in Kotlin:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中实现函数式接口有两种方式：
- en: 'Defining an object that implements the interface:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实现接口的对象：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Treating the interface as a function and implementing it, for example, in the
    form of the lambda:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将接口作为函数处理并实现它，例如，以 lambda 的形式：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Call the `setOnClickListener` function and pass an empty `OnClickListener` instance
    as a lambda expression:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `setOnClickListener` 函数，并传递一个空的 `OnClickListener` 实例作为 lambda 表达式：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Modify the visibility of the `submitButton` instance inside the function body:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体内部修改 `submitButton` 实例的可见性：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Thanks to treating `OnClickListener` as a function, we were able to implement
    it in the clean and concise form of a lambda expression. The lambda's body will
    globally be invoked whenever the user clicks the button. In our case, once the
    button is clicked, it will be hidden away.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将 `OnClickListener` 作为函数处理，我们能够以简洁的 lambda 表达式形式实现它。lambda 的主体将在用户点击按钮时全局调用。在我们的例子中，一旦按钮被点击，它将被隐藏起来。
- en: 'Lambda expressions are one of the most essential functional features of the
    language and are used extensively in the standard library components. They can
    be seen as an abbreviated form of a function or a functional interface implementation.
    Lambdas help to organize code correctly and reduce a lot of boilerplate code.
    The syntax of a lambda expression can be seen as a block of code placed between
    `{` `}` symbols. Lambda expressions can have function arguments defined explicitly,
    for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是语言中最基本的函数特性之一，在标准库组件中被广泛使用。它们可以看作是函数或函数式接口实现的缩写形式。Lambda 帮助正确组织代码并减少大量样板代码。lambda
    表达式的语法可以看作是放置在 `{` `}` 符号之间的代码块。Lambda 表达式可以显式定义函数参数，例如：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the sake of brevity, the explicit parameter can be omitted. However, we
    can still access it using `it` modifier:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，可以省略显式参数。然而，我们仍然可以使用 `it` 修饰符来访问它：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When working with lambdas, whenever we want to execute the code inside their
    body, we need to call the `invoke()` function on them or its equivalent, the `()`
    operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 lambda 一起工作时，每次我们想要执行它们体内的代码时，我们都需要在它们上调用 `invoke()` 函数或其等效的 `()` 操作符：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code is going to print the text twice:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印文本两次：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also another clean way of passing functions as the parameters to other
    functions. We can do it using function references:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种将函数作为参数传递给其他函数的简洁方式。我们可以使用函数引用来完成：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function references approach can be particularly useful for reusing the
    function implementation across the codebase.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数引用方法在代码库中重用函数实现时特别有用。
- en: Discovering basic scoping functions – let, also, apply
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现基本的作用域函数 – let, also, apply
- en: In this recipe, we are going to explore three useful extension functions from
    the standard library—`let`, `also`, and `apply`. They work great together with
    lambda expressions and help to write clean and safe code. We are going to practice
    their usage while applying them to implement a sequence of data-processing operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索标准库中的三个有用的扩展函数—`let`、`also` 和 `apply`。它们与 lambda 表达式配合得很好，有助于编写干净和安全的代码。我们将练习它们的用法，同时将它们应用于实现一系列数据处理操作。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s assume we can fetch the date using the following function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们可以使用以下函数获取日期：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the `Player` class is defined like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Player` 类是这样定义的：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We would like to perform the following sequence of operations to the `getPlayers()`
    function result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对 `getPlayers()` 函数的结果执行以下操作序列：
- en: Print the original set of players in the list to the console
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表中的原始玩家集打印到控制台
- en: Sort the collection of the `Player` objects in descending order
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按降序对 `Player` 对象集合进行排序
- en: Transform collection `Player` objects into the list of strings obtained from
    the `Player.name` property
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Player` 集合转换为由 `Player.name` 属性获取的字符串列表
- en: Limit the collection to the first element and print it to the console
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将集合限制为第一个元素并打印到控制台
- en: 'In order to accomplish the task, first, we need to get familiar with the characteristics
    of the `let`, `also`, and `apply` functions. They are provided in the standard
    library as extension functions for a generic type. Let''s explore the headers
    of the `let`, `also`, and `apply` functions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，首先，我们需要熟悉 `let`、`also` 和 `apply` 函数的特性。它们作为泛型类型的扩展函数提供在标准库中。让我们探索 `let`、`also`
    和 `apply` 函数的头部：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'They look similar, however, there are some subtle differences in return types
    and in parameters. The following table compares the three functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来很相似，然而，在返回类型和参数方面有一些细微的差异。以下表格比较了这三个函数：
- en: '| **Function** | **Return type** | **Argument in block argument** | **Block
    argument definition** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **返回类型** | **块参数中的参数** | **块参数定义** |'
- en: '| `let` | `R` (from block body) | Explicit it | `(T) -> R` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `let` | `R` (从块体) | 显式 it | `(T) -> R` |'
- en: '| `also` | `T` (this) | Explicit it | `(T) -> Unit` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `also` | `T` (this) | 显式 it | `(T) -> Unit` |'
- en: '| `apply` | `T` (this) | Implicit this | `T.() -> Unit` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `apply` | `T` (this) | 隐式 this | `T.() -> Unit` |'
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the `let` function together with the safe operator to assure null safety:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `let` 函数与安全运算符一起使用以确保空安全：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `let` function''s lambda parameter block, use the `also()` function
    to print the original set of players in the list to the console:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `let` 函数的 lambda 参数块内部，使用 `also()` 函数将列表中的原始玩家集打印到控制台：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the `let()` function to perform sorting and mapping transformations:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `let()` 函数执行排序和映射转换：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Limit the collection of players to a single `Player` instance with the highest
    score using the `let()` function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `let()` 函数将玩家集合限制为具有最高分数的单个 `Player` 实例：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Print the name of the best player to the console:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最佳玩家的名字打印到控制台：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s test our implementation. For the sake of the test, we can assume that
    the `getPlayers()` function returns the following results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的实现。为了测试的目的，我们可以假设 `getPlayers()` 函数返回以下结果：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code we have implemented is going to print the following output to the
    console:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的代码将打印以下输出到控制台：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that, in the case of the `apply()` function, we can omit `this` keyword
    while accessing class properties and functions inside the function lambda block:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `apply()` 函数的情况下，在函数 lambda 块内部访问类属性和函数时，我们可以省略 `this` 关键字：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It was just used in the example code for the sake of clarity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了在示例代码中提高清晰度而使用。
- en: 'The useful feature of the `let()` function is that it can be used to assure
    the null safety of the given object. In the following example inside the `let`
    scope, the `players` argument will always hold a not null value even if some background
    thread tries to modify the original value of the mutable `results` variable:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()` 函数的有用特性是它可以用来确保给定对象的空安全。在以下 `let` 范围内的示例中，即使某些后台线程试图修改可变 `results`
    变量的原始值，`players` 参数也始终持有非空值：'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to learn more about lambda expressions, check out the *Working
    effectively with lambda expressions *recipe
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 lambda 表达式的内容，请查看 *有效使用 lambda 表达式* 菜谱
- en: Initializing objects the clean way using the run scoping function
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `run` 范围函数以干净的方式初始化对象
- en: In this recipe, we are going to explore another useful extension function provided
    by the standard library, called `run()`. We are going to use it in order to create
    and set up an instance of the `java.util.Calendar` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索标准库提供的另一个有用的扩展函数，称为 `run()`。我们将使用它来创建和设置 `java.util.Calendar` 类的实例。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, let''s  explore the characteristics of the `run()` function defined
    in the standard library with the following function header:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过以下函数头探索标准库中定义的 `run()` 函数的特性：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is declared as an extension function for a generic type. The `run` function
    provides implicit `this` parameter inside the `block` argument and returns the
    result of the `block` execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它被声明为一个泛型类型的扩展函数。`run`函数在`block`参数内部提供了隐式的`this`参数，并返回`block`执行的返回值。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare an instance of the `Calendar.Builder` class and apply the `run()` function
    to it:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`Calendar.Builder`类的实例并将其`run()`函数应用于它：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the desired properties to the builder:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的属性添加到构建器中：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Print the date from the calendar to the console:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日历中的日期打印到控制台：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `run` function is applied to the `Calendar.Builder` instance. Inside the
    lambda passed to the `run` function, we can access the `Calendar.Builder` properties
    and methods via `this` modifier. In other words, inside the `run` function block,
    we are accessing the scope of the `Calendar.Builder` instance. In the recipe code,
    we are omitting to invoke `Builder` methods with `this` keyword. We can call them
    directly because the `run` function allows accessing the `Builder` instance inside
    its scope by an implicit `this` modifier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`函数应用于`Calendar.Builder`实例。在传递给`run`函数的lambda内部，我们可以通过`this`修饰符访问`Calendar.Builder`的属性和方法。换句话说，在`run`函数块内部，我们正在访问`Calendar.Builder`实例的作用域。在食谱代码中，我们省略了使用`this`关键字调用`Builder`方法。我们可以直接调用它们，因为`run`函数允许通过隐式的`this`修饰符在其作用域内访问`Builder`实例。'
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can also use the `run()` function together with the safe `?` operator to
    provide null safety of the object referenced by `this` keyword inside the `run()`
    function scope. You can see it in action in the following example of configuring
    the Android `WebView` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`run()`函数与安全的`?`运算符一起使用，以提供`run()`函数作用域内`this`关键字引用的对象的null安全性。您可以在以下配置Android
    `WebView`类的示例中看到它的实际应用：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding piece of code, we are ensuring that the `settings` property
    is not null inside the `run` function scope and we can access it with `this` keyword.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们确保在`run`函数的作用域内`settings`属性不为null，并且我们可以通过`this`关键字访问它。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The Kotlin standard library offers another similar extension function, called
    `apply()`, which is useful for the initialization of objects. The main difference
    is that it returns an original instance of the object it was called on. You can
    explore it in the* Implementing builders the smart way *recipe in [Chapter 5](6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml), *Tasteful
    Design Patterns Adopting Kotlin Concepts*.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了另一个类似的扩展函数，称为`apply()`，它对于对象的初始化非常有用。主要区别在于它返回调用它的对象的原始实例。您可以在[第5章](6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml)的*“以美味的方式实现构建器”*食谱中探索它，*采用Kotlin概念的优雅设计模式*。
- en: Working with higher-order functions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: Kotlin is designed to provide first-class support for operating on functions.
    For example, we are able to easily pass functions as parameters to a function.
    We can also create a function that can return another function. This kind of a
    function is called a *higher-order function*. This powerful feature helps to write
    a functional style code easily. The possibility to return a function instead of
    a value makes along with the ability to pass a function instance to an other function
    as an argument, makes it possible to defer computations and to shape code cleanly. In
    this recipe, we are going to implement a helper function that is going to measure
    the execution time of other functions passed to it as an argument.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin被设计为提供对函数的一等支持。例如，我们能够轻松地将函数作为参数传递给另一个函数。我们还可以创建一个可以返回另一个函数的函数。这种类型的函数称为*高阶函数*。这个强大的功能有助于轻松编写函数式风格的代码。返回函数而不是值的能力，加上将函数实例作为参数传递给另一个函数的能力，使得延迟计算和清晰塑造代码成为可能。在本食谱中，我们将实现一个辅助函数，该函数将测量传递给它作为参数的其他函数的执行时间。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Implement the `measureTime` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`measureTime`函数：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `measureTime()` function takes an argument, called `block`, of the functional
    type. The `block` function parameter is invoked inside the `measureTime()` function
    using the `()` modifier. Finally, the difference between timestamps (before and
    after the block execution) is returned.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`measureTime()`函数接受一个名为`block`的函数类型参数。`block`函数参数在`measureTime()`函数内部使用`()`修饰符调用。最后，返回时间戳（在块执行前后）之间的差异。'
- en: 'Let''s analyze the following example showing the `measureTime()` function in
    action. We can consider having the following function responsible for computing
    the factorial of a given integer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下示例，展示`measureTime()`函数的实际应用。我们可以考虑以下函数负责计算给定整数的阶乘：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In order to measure the `factorial()` function execution time we can use the
    `measureTime()` function as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量`factorial()`函数的执行时间，我们可以使用`measureTime()`函数如下：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As the result, we get the execution time printed to the console:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到打印到控制台上的执行时间：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that it is also possible to pass a function reference instead of a lambda
    instance as the parameter to the `measureTime()` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，也可以将函数引用而不是lambda实例作为`measureTime()`函数的参数传递：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Functions currying
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: Currying is a common technique in functional programming. It allows transforming
    a given function that takes multiple arguments into a sequence of functions, each
    having a single argument. Each of the resulting functions handles one argument
    of the original (uncurried) function and returns another function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是函数式编程中的一种常见技术。它允许将给定的多参数函数转换为一串函数，每个函数只有一个参数。每个生成的函数处理原始（未柯里化）函数的一个参数，并返回另一个函数。
- en: In this recipe, we are going to implement an automatic currying mechanism that
    could be applied to any function taking three parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个可以应用于任何接受三个参数的函数的自动柯里化机制。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To understand the concept of function currying, let''s consider the following
    example of a function handling three parameters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解函数柯里化的概念，让我们考虑以下处理三个参数的函数的示例：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Its curried form would look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它的柯里化形式看起来是这样的：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In other words, the curried form of the `foo` function would take a single
    argument of the `A` type and return another function of the following type: `(B)
    -> (C) -> D`. The returned function is responsible for handling the second argument
    of the original function and returns another function, which takes the third argument
    and returns a value of type `D`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`foo`函数的柯里化形式将接受一个`A`类型的单个参数，并返回一个以下类型的函数：`(B) -> (C) -> D`。返回的函数负责处理原始函数的第二个参数，并返回另一个函数，该函数接受第三个参数并返回一个类型为`D`的值。
- en: In the next section, we are going to implement the `curried()` extension function
    for the generic functional type declared as follows: `<P1, P2, P3, R> ((P1, P2,
    P3)`. The `curried()` function is going to return a chain of single-argument functions
    and will be applicable to any function which takes three arguments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现`curried()`扩展函数，该函数用于以下声明的泛型函数类型：`<P1, P2, P3, R> ((P1, P2, P3))`。`curried()`函数将返回一个单参数函数链，并将适用于任何接受三个参数的函数。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare a header of the `curried()` function:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`curried()`函数的标题：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the `curried()` function body:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数`curried()`的主体：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s explore how to use the `curried()` function in action. In the following
    example we are going to call `curried()` on the following function instance which
    is responsible for computing a sum of three integers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在实际中使用`curried()`函数。在以下示例中，我们将对以下函数实例调用`curried()`，该实例负责计算三个整数的和：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to obtain a curried form of the `sum()` function, we have to invoke
    the `curried()` function on its reference:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得`sum()`函数的柯里化形式，我们必须在它的引用上调用`curried()`函数：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we can invoke the curried sum function in the following way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以以以下方式调用柯里化的求和函数：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the end, the `result` variable is going to be assigned an integer value equal
    to `6`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`result`变量将被分配一个等于`6`的整数值。
- en: In order to invoke the `curried()` extension function, we access the `sum()`
    function reference using the `::` modifier. Then we invoke the next functions
    from the function sequence returned by the curried function one by one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用`curried()`扩展函数，我们使用`::`修饰符访问`sum()`函数引用。然后，我们依次调用由柯里化函数返回的函数序列中的下一个函数。
- en: 'The preceding code could be written in an equivalent more verbose form with
    explicit types declarations:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以用更冗长的形式来写，带有显式的类型声明：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Under the hood, the currying mechanism implementation is just returning functions
    nested inside each other. Every time the specific function is invoked, it returns
    another function with the arity reduced by one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，柯里化机制的实现只是返回嵌套在彼此内部的函数。每次调用特定函数时，它都会返回另一个具有减少一个参数的函数。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is a similar pattern called *partial application. *It is more flexible
    than currying as it doesn''t limit the number of arguments handled by each of
    the functions. For example, given a `foo` function declared as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类似的模式称为*部分应用*。它比柯里化更灵活，因为它不限制每个函数处理的参数数量。例如，给定一个如下声明的`foo`函数：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We could transform it into the following form:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其转换为以下形式：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both currying and partial application are useful whenever we can't provide the
    full number of required arguments to the function in the current scope. We can
    apply only the available ones to the function and return the transformed function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们无法在当前作用域中为函数提供所需的所有参数时，柯里化和部分应用都非常有用。我们可以只将可用的参数应用到函数上，并返回转换后的函数。
- en: Function composition
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: In the* Functions currying* recipe, we discovered a neat way of transforming
    a function to extract new functions from it. In this recipe, we are going to work
    on implementing the opposite transformation. It would be useful to have the option
    to merge a number of existing functions' declarations and define a new function
    from them. This is a common functional programming pattern called *functions composition*. Kotlin
    doesn't provide function composition mechanism out of the box. However, thanks
    to the extended built-in support for operations on functional types, we are able
    to implement a reusable mechanism for the composition manually.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在*函数柯里化*配方中，我们发现了一种巧妙的方法，可以从函数中提取新的函数。在这个配方中，我们将实现相反的转换。有一个选项可以合并多个现有函数的声明，并从中定义一个新的函数，这是一种常见的函数式编程模式，称为*函数组合*。Kotlin没有提供内置的函数组合机制。然而，多亏了对函数类型操作扩展的内置支持，我们能够手动实现一个可重用的组合机制。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to get familiar with function composition, let''s study the following
    example. Let''s say we have the following functions defined:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉函数组合，让我们研究以下示例。假设我们定义了以下函数：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first one is responsible for returning the length of a given string. The
    second one checks whether a given integer is even. In order to define a new function
    based on those two functions, we can make nested function calls:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数负责返回给定字符串的长度。第二个函数检查给定的整数是否为偶数。为了定义一个基于这两个函数的新函数，我们可以进行嵌套函数调用：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This works fine, however, it would be useful if we were able to operate on
    the function references instead. In order to make it more concise we''d like to
    be able to declare the `isCharCountEven()` function using the following syntax
    for the functions composition:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们能够对函数引用进行操作，那就更好了。为了使其更加简洁，我们希望能够使用以下语法声明`isCharCountEven()`函数，用于函数组合：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare an `infix` extension function for the single-argument function called
    `and()`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`and()`的单参数函数的`infix`扩展函数：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Invoke the base function and the one passed as an argument of `and()` internally:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部调用基本函数和`and()`函数的参数：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to explore our function composition implementation, let''s use the
    `and()` function to compose the `isCharCountEven()` function using the `length()`
    property and the `isEven()` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索我们的函数组合实现，让我们使用`and()`函数，通过`length()`属性和`isEven()`函数组合`isCharCountEven()`函数：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code is going to return the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将返回以下输出：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Under the hood, the `and()` extension function just invokes the given two functions
    one inside another. However, thanks to the infix notation we can perform the composition
    in the code while avoiding nested function calls. Moreover, the result of the `::length
    and ::isEven` call in the preceding example returns a new function instance which
    can be easily reused, just like a normal function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`and()`扩展函数只是依次调用给定的两个函数。然而，多亏了中缀表示法，我们可以在代码中执行组合，同时避免嵌套函数调用。此外，前一个示例中`::length
    and ::isEven`调用的结果返回一个新的函数实例，它可以像普通函数一样轻松重用。
- en: Implementing the Either Monad design pattern
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Either Monad设计模式
- en: The concept of Monad is one of the fundamental functional programming design
    patterns. We can understand a Monad as an encapsulation for a data type that adds
    a specific functionality to it or provides custom handlers for different states
    of the encapsulated object. One of the most commonly used is a Maybe monad. The
    Maybe monad is supposed to provide information about the enclosed property presence.
    It can return an instance of the wrapped type whenever it's available or nothing
    when it's not. Java 8 introduced the `Optional<T>` class, which is implementing
    the Maybe concept. It's a great way to avoid operating on null values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Monad的概念是函数式编程设计模式之一。我们可以将Monad理解为对数据类型的封装，它为该数据类型添加特定的功能或为封装对象的不同的状态提供自定义处理程序。最常用的之一是Maybe
    monad。Maybe monad旨在提供有关封装属性存在的信息。它可以在属性可用时返回封装类型的实例，在不可用时返回空值。Java 8引入了`Optional<T>`类，它实现了Maybe概念。这是一种避免在null值上操作的好方法。
- en: However, apart from having the information about the unavailable state, we would often
    like to be able to provide some additional information. For example, if the server
    returns an empty response, it would be useful to get an error code or a message
    instead of the `null` or an empty response string. This is a scenario for another
    type of Monad, usually called `Either`, which we are going to implement in this
    recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了有关于不可用状态的信息之外，我们通常还希望能够提供一些额外的信息。例如，如果服务器返回一个空响应，那么获取一个错误代码或消息而不是`null`或空响应字符串将是有用的。这是一个适用于另一种类型Monad的场景，通常称为`Either`，我们将在本食谱中实现它。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Declare `Either` as a `sealed` class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Either`声明为一个`sealed`类：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add two subclasses of `Either`, representing Error and Value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个`Either`的子类，分别表示错误和值：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add factory functions for the convenient instantiating of `Either`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于方便实例化`Either`的工厂函数：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to make use of the class `Either` and benefit from the `Either.right()`
    and `Either.left()` methods, we can implement a `getEither()` function that will
    try to perform some operation passed to it as a parameter. If the operation succeeds,
    it is going to return the `Either.Right` instance holding the result of the operation,
    otherwise, it is going to return `Either.Left`, holding a thrown exception instance:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`Either`类并从中受益于`Either.right()`和`Either.left()`方法，我们可以实现一个`getEither()`函数，该函数将尝试执行作为参数传递给它的某些操作。如果操作成功，它将返回包含操作结果的`Either.Right`实例，否则，它将返回`Either.Left`，包含一个抛出的异常实例：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By convention, we use the `Either.Right` type to provide a default value and
    `Either.Left` to handle any possible edge cases.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们使用`Either.Right`类型来提供默认值，而使用`Either.Left`来处理任何可能的边缘情况。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One of the essential functional programming features the `Either` Monad can
    provide, is the ability to apply functions to its values. We can simply extend
    the `Either` class with the `fold()` function, which can take two functions as
    the parameters. The first function that should be applied to the `Either.Left`
    type and second, that should be applied to `Either.Right`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` Monad可以提供的一个基本函数式编程特性，是能够对其值应用函数。我们可以简单地通过`fold()`函数扩展`Either`类，该函数可以接受两个函数作为参数。第一个函数应用于`Either.Left`类型，第二个函数应用于`Either.Right`：'
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `fold()` function is going to return a value from either the `leftOp` or `rightOp`
    function, whichever is used. We can illustrate the usage of the `fold()` function
    with a server-request parsing example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold()`函数将从`leftOp`或`rightOp`函数返回一个值，取决于使用的是哪一个。我们可以通过一个服务器请求解析示例来说明`fold()`函数的用法。'
- en: 'Let''s say we have the following types declared:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们声明了以下类型：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also have a function responsible for delivering a backend response:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个负责提供后端响应的函数：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can use the `fold()` function to handle the returned value in the right
    way:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fold()`函数以正确的方式处理返回值：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We could also extend the `Either` class with other useful functions similar
    to the ones available in the standard library for data-processing operations—`map`,
    `filter`, and `exists`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过其他有用的函数扩展`Either`类，这些函数类似于标准库中用于数据处理操作的可用的函数——`map`、`filter`和`exists`。
- en: Approach to automatic functions memoization
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动函数记忆化的方法
- en: Memoization is a technique used to optimize the program-execution speed by caching
    the results of expensive function calls and reusing their ready values when they
    are required again. Although memoization causes an obvious trade-off between memory
    usage and computation time, often it's crucial to provide the desired performance. Usually,
    we apply this pattern to computationally-expensive functions. It can help to optimize
    recursive functions that call themselves multiple times with the same parameters'
    values. Memoization can easily be added internally to function implementation.
    However, in this recipe, we are going to create a general-purpose, reusable memoization
    mechanism that could be applied to any function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种用于通过缓存昂贵函数调用的结果并在需要时重新使用它们的准备好的值来优化程序执行速度的技术。尽管缓存在内存使用和计算时间之间造成明显的权衡，但通常提供所需的性能至关重要。通常，我们将此模式应用于计算昂贵的函数。它可以帮助优化多次以相同参数值调用自身的递归函数。缓存可以轻松地添加到函数实现中。然而，在这个菜谱中，我们将创建一个通用、可重用的缓存机制，可以应用于任何函数。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare a `Memoizer` class responsible for caching the results:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个负责缓存结果的`Memoizer`类：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Provide a `memoized()` extension function for the `(P) -> R` function type:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`(P) -> R`函数类型提供一个`memoized()`扩展函数：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `memoize()` function takes an instance of a one-argument function as its
    argument. The `Memoizer` class contains the `ConcurrentHashmap<P, R>` instance,
    which is used to cache the function''s return values. The map stores functions
    passed to `memoize()` as arguments as the keys, and it puts their return values
    as its values. First, the `memoize()` function looks up the value for a specific
    param of the function passed as an argument. If the value is present in the map,
    it is returned. Otherwise, the function is executed and its result is both returned
    by `memoize()` and put into the map. This is achieved using the handy `inline
    fun <K, V> ConcurrentMap<K, V>.computeIfAbsent(key: K, defaultValue: () -> V):
    V` extension function provided by the standard library.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoize()`函数接受一个单参数函数的实例作为其参数。`Memoizer`类包含`ConcurrentHashmap<P, R>`实例，用于缓存函数的返回值。该映射存储传递给`memoize()`作为参数的函数作为键，并将它们的返回值作为其值。首先，`memoize()`函数查找传递给函数作为参数的特定参数的值。如果该值存在于映射中，则返回。否则，执行函数，并将结果既通过`memoize()`返回，又放入映射中。这是通过标准库提供的方便的`inline
    fun <K, V> ConcurrentMap<K, V>.computeIfAbsent(key: K, defaultValue: () -> V):
    V`扩展函数实现的。'
- en: Additionally, we provide an extension function `memoized()` for the `Function1`
    type that allows us to apply the `memoize()` function directly to the function
    references.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了一个`Function1`类型的扩展函数`memoized()`，允许我们直接将`memoize()`函数应用于函数引用。
- en: 'Under the hood functions in Kotlin are compiled to the `FunctionN` interface
    instances in the Java bytecode, where `N` corresponds to the number of function
    arguments. Thanks to that fact, we are able to declare an extension function for
    a function. For example, in order to add an extension function for the function
    taking two arguments, `(P, Q) -> R`, we need to define an extension as `fun <P,
    Q, R> Function2<P, Q, R>.myExtension(): MyReturnType`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kotlin中的底层函数被编译成Java字节码中的`FunctionN`接口实例，其中`N`对应函数参数的数量。正因为这个事实，我们能够为函数声明一个扩展函数。例如，为了为接受两个参数的函数`（P,
    Q）-> R`添加一个扩展函数，我们需要定义一个扩展函数为`fun <P, Q, R> Function2<P, Q, R>.myExtension():
    MyReturnType`。'
- en: 'Now, let''s take a look at how we could benefit from the `memoized()` function
    in action. Let''s consider a function that computes the factorial of an integer
    recursively:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何从`memoized()`函数的实际应用中受益。让我们考虑一个递归计算整数的阶乘的函数：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can apply the `memoized()` extension function to enable results-caching:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`memoized()`扩展函数应用于启用结果缓存：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code gives the following output on a standard computer:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在标准计算机上给出以下输出：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, even though the second computation requires a higher number
    of recursive calls of the `factorial()` function, it takes much less time than
    the first computation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管第二次计算需要更多的`factorial()`函数递归调用次数，但它比第一次计算花费的时间少得多。
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We could implement similar automatic memoization implementations for the other
    functions that take more than one argument. In order to declare an extension function
    for a function taking *N* arguments, we'd have to implement an extension function
    for the `FunctionN` type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为接受超过一个参数的其他函数实现类似的自动记忆化实现。为了声明一个接受*N*个参数的扩展函数，我们需要为`FunctionN`类型实现一个扩展函数。
