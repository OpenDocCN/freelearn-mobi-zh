- en: Shaping Code with Kotlin Functional Programming Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working effectively with lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering basic scoping functions – `let`, `also`, and `apply`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing objects the clean way using the `run` scoping function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Either Monad design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approach to automatic function memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the fact that Kotlin is recognized implicitly as an object-oriented
    language, it is still open to other programming styles and paradigms. Thanks to
    Kotlin's built-in features, we are able to apply functional programming patterns
    to our code with ease. Having the possibility to return functions from other functions
    or to pass a function as a parameter allows us to benefit from a deferred computation.
    In addition, we are able to return functions, instead of already-computed values,
    on different layers in the code. This results in the lazy-evaluation feature.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to Scala or other functional programming languages, Kotlin doesn't
    require us to use dedicated, functional style design patterns. It also lacks some
    of their out-of-the-box implementations. However, in return, it brings more flexibility
    to developers as far as software architecture and implementation details are concerned.
    The Kotlin language and standard library components provide full built-in support
    for basic functional programming concepts. And more sophisticated ones can always
    be implemented from scratch or reused from some of the available external libraries.
    The ones worth giving a try are the Kotlin Arrow ([http://arrow-kt.io](http://arrow-kt.io))
    and funKTionale ([https://github.com/MarioAriasC/funKTionale](https://github.com/MarioAriasC/funKTionale))
    projects. However, keep in mind the words of Robert C. Martin—*It is perfectly
    possible to write a program that is both object-oriented and functional. Not only
    is it possible, it is desirable. There is no "OO vs FP," the two are orthogonal
    and coexist nicely*<q>.</q> It should be understood that functional programming
    is only one available tool. It should be used wisely and only where it is applicable.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on explaining functional programming features supported
    by Kotlin internally. It gives you hands-on experience in solving real-life problems
    by using state-of-the-art functional programming concepts. By the end of the chapter,
    you should be familiar with the Kotlin language support for the functional programming
    approach and standard library components that can help implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Working effectively with lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore the concept of lambdas and closures.
    We are going to write part of an Android application code responsible for handling
    button-click actions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement this recipe's code, you need to create a new Android application
    project using Android Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following class, which is a sort of a controller of
    the application view layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains a reference to the `submitButton: Button` instance. Inside the `onCreate()` function
    we are going to implement logic responsible for handling the button clicks. Once
    the button is clicked, we want to make it invisible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to invoke some action when the button is clicked, we need to call
    the `View.setOnClickListener(listener: OnClickListener)` function on the `View`
    subclass. The `OnClickListener` is a functional interface defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the Android OS invokes the `onClick()` function when the user
    clicks the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of implementing a functional interface in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining an object that implements the interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Treating the interface as a function and implementing it, for example, in the
    form of the lambda:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Call the `setOnClickListener` function and pass an empty `OnClickListener` instance
    as a lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the visibility of the `submitButton` instance inside the function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to treating `OnClickListener` as a function, we were able to implement
    it in the clean and concise form of a lambda expression. The lambda's body will
    globally be invoked whenever the user clicks the button. In our case, once the
    button is clicked, it will be hidden away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda expressions are one of the most essential functional features of the
    language and are used extensively in the standard library components. They can
    be seen as an abbreviated form of a function or a functional interface implementation.
    Lambdas help to organize code correctly and reduce a lot of boilerplate code.
    The syntax of a lambda expression can be seen as a block of code placed between
    `{` `}` symbols. Lambda expressions can have function arguments defined explicitly,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of brevity, the explicit parameter can be omitted. However, we
    can still access it using `it` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with lambdas, whenever we want to execute the code inside their
    body, we need to call the `invoke()` function on them or its equivalent, the `()`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is going to print the text twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also another clean way of passing functions as the parameters to other
    functions. We can do it using function references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The function references approach can be particularly useful for reusing the
    function implementation across the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering basic scoping functions – let, also, apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore three useful extension functions from
    the standard library—`let`, `also`, and `apply`. They work great together with
    lambda expressions and help to write clean and safe code. We are going to practice
    their usage while applying them to implement a sequence of data-processing operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume we can fetch the date using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Player` class is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to perform the following sequence of operations to the `getPlayers()`
    function result:'
  prefs: []
  type: TYPE_NORMAL
- en: Print the original set of players in the list to the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the collection of the `Player` objects in descending order
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform collection `Player` objects into the list of strings obtained from
    the `Player.name` property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limit the collection to the first element and print it to the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to accomplish the task, first, we need to get familiar with the characteristics
    of the `let`, `also`, and `apply` functions. They are provided in the standard
    library as extension functions for a generic type. Let''s explore the headers
    of the `let`, `also`, and `apply` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'They look similar, however, there are some subtle differences in return types
    and in parameters. The following table compares the three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Return type** | **Argument in block argument** | **Block
    argument definition** |'
  prefs: []
  type: TYPE_TB
- en: '| `let` | `R` (from block body) | Explicit it | `(T) -> R` |'
  prefs: []
  type: TYPE_TB
- en: '| `also` | `T` (this) | Explicit it | `(T) -> Unit` |'
  prefs: []
  type: TYPE_TB
- en: '| `apply` | `T` (this) | Implicit this | `T.() -> Unit` |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `let` function together with the safe operator to assure null safety:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `let` function''s lambda parameter block, use the `also()` function
    to print the original set of players in the list to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `let()` function to perform sorting and mapping transformations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Limit the collection of players to a single `Player` instance with the highest
    score using the `let()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the name of the best player to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our implementation. For the sake of the test, we can assume that
    the `getPlayers()` function returns the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code we have implemented is going to print the following output to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in the case of the `apply()` function, we can omit `this` keyword
    while accessing class properties and functions inside the function lambda block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It was just used in the example code for the sake of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The useful feature of the `let()` function is that it can be used to assure
    the null safety of the given object. In the following example inside the `let`
    scope, the `players` argument will always hold a not null value even if some background
    thread tries to modify the original value of the mutable `results` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to learn more about lambda expressions, check out the *Working
    effectively with lambda expressions *recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing objects the clean way using the run scoping function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore another useful extension function provided
    by the standard library, called `run()`. We are going to use it in order to create
    and set up an instance of the `java.util.Calendar` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s  explore the characteristics of the `run()` function defined
    in the standard library with the following function header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is declared as an extension function for a generic type. The `run` function
    provides implicit `this` parameter inside the `block` argument and returns the
    result of the `block` execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare an instance of the `Calendar.Builder` class and apply the `run()` function
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the desired properties to the builder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the date from the calendar to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `run` function is applied to the `Calendar.Builder` instance. Inside the
    lambda passed to the `run` function, we can access the `Calendar.Builder` properties
    and methods via `this` modifier. In other words, inside the `run` function block,
    we are accessing the scope of the `Calendar.Builder` instance. In the recipe code,
    we are omitting to invoke `Builder` methods with `this` keyword. We can call them
    directly because the `run` function allows accessing the `Builder` instance inside
    its scope by an implicit `this` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also use the `run()` function together with the safe `?` operator to
    provide null safety of the object referenced by `this` keyword inside the `run()`
    function scope. You can see it in action in the following example of configuring
    the Android `WebView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding piece of code, we are ensuring that the `settings` property
    is not null inside the `run` function scope and we can access it with `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin standard library offers another similar extension function, called
    `apply()`, which is useful for the initialization of objects. The main difference
    is that it returns an original instance of the object it was called on. You can
    explore it in the* Implementing builders the smart way *recipe in [Chapter 5](6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml), *Tasteful
    Design Patterns Adopting Kotlin Concepts*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is designed to provide first-class support for operating on functions.
    For example, we are able to easily pass functions as parameters to a function.
    We can also create a function that can return another function. This kind of a
    function is called a *higher-order function*. This powerful feature helps to write
    a functional style code easily. The possibility to return a function instead of
    a value makes along with the ability to pass a function instance to an other function
    as an argument, makes it possible to defer computations and to shape code cleanly. In
    this recipe, we are going to implement a helper function that is going to measure
    the execution time of other functions passed to it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement the `measureTime` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `measureTime()` function takes an argument, called `block`, of the functional
    type. The `block` function parameter is invoked inside the `measureTime()` function
    using the `()` modifier. Finally, the difference between timestamps (before and
    after the block execution) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the following example showing the `measureTime()` function in
    action. We can consider having the following function responsible for computing
    the factorial of a given integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to measure the `factorial()` function execution time we can use the
    `measureTime()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As the result, we get the execution time printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is also possible to pass a function reference instead of a lambda
    instance as the parameter to the `measureTime()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Functions currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currying is a common technique in functional programming. It allows transforming
    a given function that takes multiple arguments into a sequence of functions, each
    having a single argument. Each of the resulting functions handles one argument
    of the original (uncurried) function and returns another function.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to implement an automatic currying mechanism that
    could be applied to any function taking three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the concept of function currying, let''s consider the following
    example of a function handling three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Its curried form would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the curried form of the `foo` function would take a single
    argument of the `A` type and return another function of the following type: `(B)
    -> (C) -> D`. The returned function is responsible for handling the second argument
    of the original function and returns another function, which takes the third argument
    and returns a value of type `D`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to implement the `curried()` extension function
    for the generic functional type declared as follows: `<P1, P2, P3, R> ((P1, P2,
    P3)`. The `curried()` function is going to return a chain of single-argument functions
    and will be applicable to any function which takes three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare a header of the `curried()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `curried()` function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore how to use the `curried()` function in action. In the following
    example we are going to call `curried()` on the following function instance which
    is responsible for computing a sum of three integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to obtain a curried form of the `sum()` function, we have to invoke
    the `curried()` function on its reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can invoke the curried sum function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the end, the `result` variable is going to be assigned an integer value equal
    to `6`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to invoke the `curried()` extension function, we access the `sum()`
    function reference using the `::` modifier. Then we invoke the next functions
    from the function sequence returned by the curried function one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code could be written in an equivalent more verbose form with
    explicit types declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the currying mechanism implementation is just returning functions
    nested inside each other. Every time the specific function is invoked, it returns
    another function with the arity reduced by one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a similar pattern called *partial application. *It is more flexible
    than currying as it doesn''t limit the number of arguments handled by each of
    the functions. For example, given a `foo` function declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We could transform it into the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Both currying and partial application are useful whenever we can't provide the
    full number of required arguments to the function in the current scope. We can
    apply only the available ones to the function and return the transformed function.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the* Functions currying* recipe, we discovered a neat way of transforming
    a function to extract new functions from it. In this recipe, we are going to work
    on implementing the opposite transformation. It would be useful to have the option
    to merge a number of existing functions' declarations and define a new function
    from them. This is a common functional programming pattern called *functions composition*. Kotlin
    doesn't provide function composition mechanism out of the box. However, thanks
    to the extended built-in support for operations on functional types, we are able
    to implement a reusable mechanism for the composition manually.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get familiar with function composition, let''s study the following
    example. Let''s say we have the following functions defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one is responsible for returning the length of a given string. The
    second one checks whether a given integer is even. In order to define a new function
    based on those two functions, we can make nested function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine, however, it would be useful if we were able to operate on
    the function references instead. In order to make it more concise we''d like to
    be able to declare the `isCharCountEven()` function using the following syntax
    for the functions composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare an `infix` extension function for the single-argument function called
    `and()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the base function and the one passed as an argument of `and()` internally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to explore our function composition implementation, let''s use the
    `and()` function to compose the `isCharCountEven()` function using the `length()`
    property and the `isEven()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is going to return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the `and()` extension function just invokes the given two functions
    one inside another. However, thanks to the infix notation we can perform the composition
    in the code while avoiding nested function calls. Moreover, the result of the `::length
    and ::isEven` call in the preceding example returns a new function instance which
    can be easily reused, just like a normal function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Either Monad design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of Monad is one of the fundamental functional programming design
    patterns. We can understand a Monad as an encapsulation for a data type that adds
    a specific functionality to it or provides custom handlers for different states
    of the encapsulated object. One of the most commonly used is a Maybe monad. The
    Maybe monad is supposed to provide information about the enclosed property presence.
    It can return an instance of the wrapped type whenever it's available or nothing
    when it's not. Java 8 introduced the `Optional<T>` class, which is implementing
    the Maybe concept. It's a great way to avoid operating on null values.
  prefs: []
  type: TYPE_NORMAL
- en: However, apart from having the information about the unavailable state, we would often
    like to be able to provide some additional information. For example, if the server
    returns an empty response, it would be useful to get an error code or a message
    instead of the `null` or an empty response string. This is a scenario for another
    type of Monad, usually called `Either`, which we are going to implement in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare `Either` as a `sealed` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two subclasses of `Either`, representing Error and Value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add factory functions for the convenient instantiating of `Either`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make use of the class `Either` and benefit from the `Either.right()`
    and `Either.left()` methods, we can implement a `getEither()` function that will
    try to perform some operation passed to it as a parameter. If the operation succeeds,
    it is going to return the `Either.Right` instance holding the result of the operation,
    otherwise, it is going to return `Either.Left`, holding a thrown exception instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By convention, we use the `Either.Right` type to provide a default value and
    `Either.Left` to handle any possible edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the essential functional programming features the `Either` Monad can
    provide, is the ability to apply functions to its values. We can simply extend
    the `Either` class with the `fold()` function, which can take two functions as
    the parameters. The first function that should be applied to the `Either.Left`
    type and second, that should be applied to `Either.Right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `fold()` function is going to return a value from either the `leftOp` or `rightOp`
    function, whichever is used. We can illustrate the usage of the `fold()` function
    with a server-request parsing example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have the following types declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a function responsible for delivering a backend response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `fold()` function to handle the returned value in the right
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We could also extend the `Either` class with other useful functions similar
    to the ones available in the standard library for data-processing operations—`map`,
    `filter`, and `exists`.
  prefs: []
  type: TYPE_NORMAL
- en: Approach to automatic functions memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memoization is a technique used to optimize the program-execution speed by caching
    the results of expensive function calls and reusing their ready values when they
    are required again. Although memoization causes an obvious trade-off between memory
    usage and computation time, often it's crucial to provide the desired performance. Usually,
    we apply this pattern to computationally-expensive functions. It can help to optimize
    recursive functions that call themselves multiple times with the same parameters'
    values. Memoization can easily be added internally to function implementation.
    However, in this recipe, we are going to create a general-purpose, reusable memoization
    mechanism that could be applied to any function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare a `Memoizer` class responsible for caching the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a `memoized()` extension function for the `(P) -> R` function type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `memoize()` function takes an instance of a one-argument function as its
    argument. The `Memoizer` class contains the `ConcurrentHashmap<P, R>` instance,
    which is used to cache the function''s return values. The map stores functions
    passed to `memoize()` as arguments as the keys, and it puts their return values
    as its values. First, the `memoize()` function looks up the value for a specific
    param of the function passed as an argument. If the value is present in the map,
    it is returned. Otherwise, the function is executed and its result is both returned
    by `memoize()` and put into the map. This is achieved using the handy `inline
    fun <K, V> ConcurrentMap<K, V>.computeIfAbsent(key: K, defaultValue: () -> V):
    V` extension function provided by the standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we provide an extension function `memoized()` for the `Function1`
    type that allows us to apply the `memoize()` function directly to the function
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood functions in Kotlin are compiled to the `FunctionN` interface
    instances in the Java bytecode, where `N` corresponds to the number of function
    arguments. Thanks to that fact, we are able to declare an extension function for
    a function. For example, in order to add an extension function for the function
    taking two arguments, `(P, Q) -> R`, we need to define an extension as `fun <P,
    Q, R> Function2<P, Q, R>.myExtension(): MyReturnType`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how we could benefit from the `memoized()` function
    in action. Let''s consider a function that computes the factorial of an integer
    recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the `memoized()` extension function to enable results-caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output on a standard computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even though the second computation requires a higher number
    of recursive calls of the `factorial()` function, it takes much less time than
    the first computation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could implement similar automatic memoization implementations for the other
    functions that take more than one argument. In order to declare an extension function
    for a function taking *N* arguments, we'd have to implement an extension function
    for the `FunctionN` type.
  prefs: []
  type: TYPE_NORMAL
