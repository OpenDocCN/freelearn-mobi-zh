<html><head></head><body>
		<div><h1 id="_idParaDest-36"><em class="italic"><a id="_idTextAnchor069"/>Chapter 2</em>: Handling UI State with Jetpack ViewModel</h1>
			<p>In this chapter, we will cover one of the most important libraries in Jetpack: <code>ViewModel</code> architecture component. We will see what it is, why we need it in our apps, and how we can implement one in our Restaurants app, which we started in the previous chapter.</p>
			<p>In the next section, <em class="italic">Defining and handling state with Compose</em>, we will study how state is managed in Compose and exemplify usages of state inside our project. Afterward, in the <em class="italic">Hoisting state in Compose</em> section, we will understand what state hoisting is, why we need to achieve it, and then we will apply it to our app.</p>
			<p>Finally, in the <em class="italic">Recovering from system-initiated process death</em> section, we will cover what a system-initiated process death is, how it occurs, and how essential it is for our applications to be able to recover from it by restoring the previous state details.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the Jetpack ViewModel</li>
				<li>Defining and handling state with Compose</li>
				<li>Hoisting state in Compose</li>
				<li>Recovering from system-initiated process death</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>When building Compose-based Android projects with Jetpack ViewModel, you usually require your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app that we developed in the previous chapter. If you haven't followed the implementation side by side, access the starting point for this chapter by navigating to the <code>Chapter_01</code> directory of this book's GitHub repository and importing the Android project entitled <code>chapter_1_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_02</code> folder: </p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app</a>.</p>
			<p>The project coding solution for the Restaurants app that we will develop throughout this chapter can be found in the <code>chapter_2_restaurants_app</code> Android project folder, which you can import.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor071"/>Understanding the Jetpack ViewModel</h1>
			<p>While<a id="_idIndexMarker094"/> developing Android applications, you must have heard of the term <strong class="bold">ViewModel</strong>. If you haven't heard of it, then don't worry – this section aims to clearly illustrate what this component represents and why we need it in the first place.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>What is a ViewModel?</li>
				<li>Why do you need ViewModels?</li>
				<li>Introducing Android Jetpack ViewModel</li>
				<li>Implementing your first ViewModel</li>
			</ul>
			<p>Let's start with the first question: what is this <code>ViewModel</code> that we keep hearing about in Android?</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor072"/>What is a ViewModel?</h2>
			<p>Initially, the <code>ViewModel</code> <a id="_idIndexMarker095"/>was designed to allow developers to persist UI state across configuration changes. In time, the <code>ViewModel</code> became a way to also recover from edge cases such as system-initiated process death.</p>
			<p>However, often, Android apps require you to write code that is responsible for getting the data from the server, transforming it, caching it, and then displaying it. To delegate some work, developers <a id="_idIndexMarker096"/>made use of this separate component, which should model the UI (also called the <strong class="bold">View</strong>) – the <em class="italic">ViewModel</em>.</p>
			<p>So, we can perceive a <code>ViewModel</code> class as a component that manages and caches the UI's state:</p>
			<div><div><img src="img/B17788_02_01.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – ViewModel stores the state and receives interactions</p>
			<p>As we can see, <code>ViewModel</code> not only handles the UI state and provides it to the UI but also receives user interaction events from <code>View</code> and updates the state accordingly. </p>
			<p>In Android, the views are usually represented<a id="_idIndexMarker097"/> by <code>Activity</code>, <code>Fragment</code>, or <code>Composable</code> since they are intended to display the UI data. These components are prone to being recreated when configuration changes occur, so <code>ViewModel</code> must find a way to cache and then restore the UI state – more on this in the next section, <em class="italic">Why do you need ViewModels?</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>ViewModel</code> oversees what data is sent back to the UI controllers and how the UI state reacts to user-generated events. That's why we can call <code>ViewModel</code> as a master of the UI controller – since it represents the authority that performs decision-making for UI-related events.</p>
			<p>We can try to<a id="_idIndexMarker098"/> enumerate some core activities that a <code>ViewModel</code> should perform. <code>ViewModel</code> should be able to do the following:</p>
			<ul>
				<li>Hold, manage, and preserve the entire UI state.</li>
				<li>Request data or reload content from the server or other sources.</li>
				<li>Prepare data to be displayed by applying various transformations (such as map, sort, filter, and so on).</li>
				<li>Accept user interaction events and change the state based on those events.</li>
			</ul>
			<p>Even though you now understand what a <code>ViewModel</code> is, you might be wondering, why do we need a separate class that holds the UI state or that prepares data to be displayed? Why can't we do that directly in the UI, in <code>Activity</code>, <code>Fragment</code>, or even inside the Composable? We'll address this question next.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor073"/>Why do you need ViewModels?</h2>
			<p>Imagine that <a id="_idIndexMarker099"/>we put all the state-handling logic inside the UI classes. Following this approach, we may soon add other logic for handling network requests, caching, or any other implementation details – everything will be inside the UI layer.</p>
			<p>Obviously, this is not a great approach. If we do that, we will end up with an <code>Activity</code>, <code>Fragment</code>, or <code>composable</code> function that has way too many responsibilities. In other words, our UI components will become bloated with so much code and so many responsibilities, thus making the entire project difficult to maintain, fix, or extend.</p>
			<p><code>ViewModel</code> is an architecture component that alleviates these potential issues. By adding <code>ViewModel</code> components to our projects, we are taking the first step toward a solid <em class="italic">architecture</em> since we can delegate the responsibilities of a UI controller to components such as <code>ViewModel</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>ViewModel</code> should not have a reference to a UI controller and should run independently of it. This reduces coupling between the UI layer and <code>ViewModel</code> and allows multiple UI components to reuse the same <code>ViewModel</code>.</p>
			<p>Preventing <a id="_idIndexMarker100"/>multiple responsibilities in UI controllers is the cornerstone of a good system architecture since it promotes a very simple principle called <strong class="bold">separation of concerns</strong>. This <a id="_idIndexMarker101"/>principle states that every component/module within our app should have and handle one concern.</p>
			<p>If, in our case, we add the entire application logic inside <code>Activity</code>, <code>Fragment</code>, or <code>composable</code>, these components will become huge pieces of code that violate the separation of concerns principle, simply because they know how to do everything: from displaying the UI to getting data and serving their UI states. To alleviate this, we can start implementing ViewModels.</p>
			<p>Next, we'll see how ViewModels are designed in Android.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor074"/>Introducing Android Jetpack ViewModel</h2>
			<p>Creating a <code>ViewModel</code> class to <a id="_idIndexMarker102"/>govern the UI state of a <code>View</code> is doable and straightforward. We can simply create a separate class and move the corresponding logic there.</p>
			<p>However, as we mentioned previously, UI controllers have their own lifecycle: the <code>Activity</code> or <code>Fragment</code> objects have their own lifecycles, while composables have a composition cycle. That's why UI controllers are usually fragile and end up being recreated when different events occur, such as a configuration change or a process death. When this happens, any UI state information is lost.</p>
			<p>Moreover, UI controllers usually need to make async calls (to obtain data from the server, for example) that have to be managed correctly. This means that when the system destroys UI controllers (such as by calling <code>onDestroy()</code> on an <code>Activity</code>), you need to manually interrupt or cancel any pending or ongoing work. Otherwise, your application can leak memory since your UI controller's memory reference cannot be freed up by the system. This is because it's still trying to finish some asynchronous work.</p>
			<p>To preserve the UI state and to manage async work easier, our <code>ViewModel</code> class should be able to get around these <em class="italic">downsides</em>. But how?</p>
			<p><code>ViewModel</code> is lifecycle aware, this means that it knows how to outlive events such as configuration changes, which are triggered by the user.</p>
			<p>It does that by having a <em class="italic">lifecycle scope</em> tied to the lifecycle of its UI controller. Let's see how the lifecycle of an <code>Activity</code> and a <code>composable</code> are defined as opposed to the one of <code>ViewModel</code>:</p>
			<div><div><img src="img/B17788_02_02.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The ViewModel's lifecycle in comparison to UI controller's lifecycle</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When the <code>ViewModel</code> is used in Compose, it lives by default for as long as the parent <code>Fragment</code> or <code>Activity</code> does. For the <code>ViewModel</code> to live as long as a top-level composable (or screen composable) function does, as shown in the previous diagram, the composable must be used in conjunction with a navigation library. More granular composables can have smaller lifetimes. Don't worry, we will cover the aspect of scoping the lifetime of a ViewModel to the lifetime of a screen composable in <a href="B17788_05_ePub.xhtml#_idTextAnchor147"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Navigation in Compose with Jetpack Navigation</em>.</p>
			<p>When the UI is recreated or recomposed because of such events, the <code>ViewModel</code>'s lifecycle awareness allows it to outlive those events and avoid being destroyed, thus allowing the state to be preserved. When the entire lifecycle is finalized, the <code>ViewModel</code>'s <code>onCleared()</code> method is called to allow you to easily clean up any pending async work.</p>
			<p>Yet one question <a id="_idIndexMarker104"/>arises: how can the Jetpack ViewModel do that?</p>
			<p>By design, the <code>ViewModel</code> classes outlive specific instantiations of <code>LifecycleOwners</code>. In our case, UI controllers are <code>LifecycleOwners</code> since they have a designated lifecycle, and they can be <code>Activity</code> or <code>Fragment</code> objects.</p>
			<p>To understand how <code>ViewModel</code> components are scoped to a specific <code>Lifecycle</code>, let's have a look at a traditional way of getting a reference to a <code>ViewModel</code> instance:</p>
			<pre>val vm = ViewModelProvider(this)[MyViewModel::class.java]</pre>
			<p>To obtain an instance of <code>MyViewModel</code>, we pass a <code>ViewModelStoreOwner</code> to the <code>ViewModelProvider</code> constructor. We used to get our <code>ViewModel</code> like this in <code>Activity</code> or <code>Fragment</code> classes, so this is a reference to the current <code>ViewModelStoreOwner</code>.</p>
			<p>To control the lifetime of the instance of our <code>MyViewModel</code>, <code>ViewModelProvider</code> needs an instance of <code>ViewModelStoreOwner</code> because when it creates an instance of <code>MyViewModel</code>, it will link the lifetime of this instance to the lifetime of <code>ViewModelStoreOwner</code> – that is, of our <code>Activity</code>. </p>
			<p>The <code>Activity</code> or <code>Fragment</code> components are <code>LifecycleOwners</code> with a lifecycle, meaning that every time you get a reference to your <code>ViewModel</code>, the object you receive is scoped to the <code>LifecycleOwner</code>'s lifecycle. This means that your <code>ViewModel</code> remains alive in memory until the <code>LifecycleOwner</code>'s lifecycle is finished. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will explain the inner workings of <code>ViewModel</code> components and how they are scoped to the lifecycle of a <code>LifecycleOwner</code> in more detail in <a href="B17788_12_ePub.xhtml#_idTextAnchor327"><em class="italic">Chapter 12</em></a>, <em class="italic">Exploring the Jetpack Lifecycle Components</em>.</p>
			<p>In Compose, the <code>ViewModel</code> objects<a id="_idIndexMarker105"/> are instantiated differently by using a special inline function called <code>viewModel()</code>, which abstracts all the boilerplate code that was needed previously.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Optionally, if you need to pass parameters whose values are decided at runtime to your <code>ViewModel</code>, you can create and pass a <code>ViewModelFactory</code> instance to the <code>viewModel()</code> constructor. <code>ViewModelFactory</code> is a special class that allows you to control the way your <code>ViewModel</code> is instantiated.</p>
			<p>Now that we have provided an overview of how the Android <code>ViewModel</code> works, let's create one!</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor075"/>Implementing your first ViewModel</h2>
			<p>It's time to create a <code>ViewModel</code> inside<a id="_idIndexMarker106"/> the Restaurants application that we created in the previous chapter. To do this, follow these steps:</p>
			<ol>
				<li>First, create a new file by left-clicking the application package, selecting <code>RestaurantsViewModel</code> as the name and select <strong class="bold">File</strong> as the type. Inside the newly created file, add the following code:<pre>import androidx.lifecycle.ViewModel
class RestaurantsViewModel(): ViewModel() {
   fun getRestaurants() = dummyR<a id="_idTextAnchor076"/>estaurants
}</pre></li>
			</ol>
			<p>Our <code>RestaurantsViewModel</code> inherits from the <code>ViewModel</code> class (previously referenced as the Jetpack ViewModel) that's defined in <code>androidx.lifecycle.ViewModel</code>, so it becomes lifecycle aware of the components that instantiate it.</p>
			<p>Moreover, we've added the <code>getRestaurants()</code> method to our <code>ViewModel</code>, allowing it to be the provider of our <code>dummyRestaurants</code> list – a first and shy step toward giving it responsibility for governing the UI state.</p>
			<p>Next, it's time to prepare to instantiate our <code>RestaurantsViewModel</code>. In Compose, we can't use the previous syntax for instantiating <code>ViewModel</code> objects, so we will use a special and dedicated syntax instead. </p>
			<ol>
				<li value="2">To gain access to<a id="_idIndexMarker107"/> this special syntax, go to the <code>build.gradle</code> file in the app module and inside the <code>dependencies</code> block, add the ViewModel-Compose dependency:<pre>dependencies {
      […]
    debugImplementation "androidx.compose.ui:ui-
        tooling:$compose_version"
    <strong class="bold">implementation "androidx.lifecycle:lifecycle-</strong>
<strong class="bold">        viewmodel-compose:2.4.1"</strong>
}</pre></li>
			</ol>
			<p>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="3">Going back to the <code>RestaurantsScreen</code> file, we want to instantiate our <code>RestaurantsViewModel</code> inside our <code>RestaurantsScreen</code> composable function. We can do this using the <code>viewModel()</code> inline function syntax and specifying the type of <code>ViewModel</code> that we expect; that is, <code>RestaurantsViewModel</code>:<pre>@Composable
fun RestaurantsScreen() {
   <strong class="bold">val viewModel: RestaurantsViewModel = viewModel()</strong>
   LazyColumn( … ) {
       items(<strong class="bold">viewModel.getRestaurants()</strong>) { restaurant-&gt;
             RestaurantItem(restaurant)
  <a id="_idTextAnchor077"/>     }
   }
}</pre></li>
			</ol>
			<p>Behind the <a id="_idIndexMarker108"/>scenes, the <code>viewModel()</code> function gets the default <code>ViewModelStoreOwner</code> for our <code>RestaurantsScreen()</code> composable. Since we haven't implemented a navigation library, the default <code>ViewModelStoreOwner</code> will be the calling parent of our composable – the <code>MainActivity</code> component. This means that for now, even though our <code>RestaurantsViewModel</code> has been instantiated inside a composable, it will live for as long as our <code>MainActivity</code> does.</p>
			<p>In other words, our <code>RestaurantsViewModel</code> is scoped to the lifecycle of our <code>MainActivity</code>, thereby outliving our <code>RestaurantsScreens</code> composable, or any other composable we would pass to the <code>setContent()</code> method call from within <code>MainActivity</code>.</p>
			<p>To make sure that our <code>ViewModel</code> lives for as long as the composable function that needs it does, we will implement a navigation library in <a href="B17788_05_ePub.xhtml#_idTextAnchor147"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Navigation in Compose with Jetpack Navigation</em>.</p>
			<p>We also made sure that we now get the restaurants to be displayed from our <code>RestaurantsViewModel</code> by calling <code>getRestaurants()</code> on the <code>viewModel</code> variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">From this point on, on certain older Compose versions, the Compose Preview functionality might not work as expected anymore. As the <code>RestaurantsScreen</code> composable now depends on a <code>RestaurantsViewModel</code> object, Compose can fail to infer the data that is passed to the previewed composable, thereby not being able to show us the content. That's why directly referencing a <code>ViewModel</code> inside your screen composable isn't a good practice. We will fix this in <a href="B17788_08_ePub.xhtml#_idTextAnchor285"><em class="italic">Chapter 8</em></a>, <em class="italic">Getting Started with Clean Architecture in Android</em>. Alternatively, to see any changes in your code, you can just run the application on your emulator or physical device.</p>
			<p>Getting back to <a id="_idIndexMarker109"/>our Restaurants app, we have successfully added a <code>ViewModel</code>, yet our <code>RestaurantsViewModel</code> doesn't handle any state for our UI. It only sends a hardcoded list of restaurants, which has no state. We envisioned that its purpose is to govern the state of the UI, so let's take a break from <code>ViewModel</code> and work on understanding state.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor078"/>Defining and handling state with Compose</h1>
			<p>State and events are <a id="_idIndexMarker110"/>essential to any application since their existence implies that <a id="_idIndexMarker111"/>the UI can change over time as you interact with it. </p>
			<p>In this <a id="_idIndexMarker112"/>section, we will cover the<a id="_idIndexMarker113"/> concept of state and events and then<a id="_idIndexMarker114"/> integrate them into our <a id="_idIndexMarker115"/>Restaurants app.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>Understanding state and events</li>
				<li>Adding state to our Restaurants app</li>
			</ul>
			<p>Let's start by exploring the basic concepts of state and events in Android applications.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor079"/>Understanding state and events</h2>
			<p><strong class="bold">State</strong> represents<a id="_idIndexMarker116"/> a possible form of the UI at a certain point in time. This form can change or mutate. When the user interacts with the UI, an event is created that triggers a change in the state of the UI. So, an <strong class="bold">event</strong> is<a id="_idIndexMarker117"/> represented by different interactions that are initiated by the user that target the app and that consequently cause its state to update.</p>
			<p>In simple terms, state <a id="_idIndexMarker118"/>changes over time because of events. The UI, on the <a id="_idIndexMarker119"/>other hand, should observe the changes within the state<a id="_idIndexMarker120"/> so that it can update accordingly:</p>
			<div><div><img src="img/B17788_02_03.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – UI update flow</p>
			<p>In Compose, composable functions <a id="_idIndexMarker121"/>are, by default, stateless. That's why, when we tried to use a <code>TextField</code> composable in the previous chapter, it didn't present anything to the UI that we typed in with the keyboard. This happened because the composable had no state defined and it didn't get recomposed with the new values that had to be displayed!</p>
			<p>This is why, in Compose, it's our job to define state objects for our composables. With the help of <em class="italic">state</em> objects, we make sure that recomposition is triggered every time a state object's value is changed.</p>
			<p>To make such a <code>TextField</code> display the text that we are typing in, remember that we added a <code>textState</code> variable. Our <code>TextField</code> needed such a state object that holds a <code>String</code> value. This value represents the text that's written by us, which can change as we keep on typing:</p>
			<pre>@Composable
fun NameInput() {
   <strong class="bold">val textState: MutableState&lt;String&gt; =</strong>
       <strong class="bold">remember { mutableStateOf("") }</strong>
   TextField(…) 
}</pre>
			<p>Let's have a closer<a id="_idIndexMarker122"/> look at how we defined a state object for our <code>TextField</code>:</p>
			<ul>
				<li>First, we created a <a id="_idIndexMarker123"/>variable to hold our state object and made<a id="_idIndexMarker124"/> sure that its value can change over time by making it <code>MutableState</code>. We did that by defining a <code>textState</code> variable <a id="_idIndexMarker125"/>that is of type <code>MutableState</code>, which, in turn, holds data of type <code>String</code>.</li>
			</ul>
			<p>At its core, <code>textState</code> is a <code>androidx.compose.runtime.State</code> object, yet since we want to be able to change its value over time, we directly used a <code>MutableState</code> that implements <code>State</code>.</p>
			<ul>
				<li>We instantiated <code>textState</code> with the <code>mutableStateOf("")</code> constructor to create a state object and passed an initial value of the data that it holds: an empty string.</li>
			</ul>
			<p>We also wrapped the <code>mutableStateOf("")</code> constructor inside a <code>remember { }</code> block. The <code>remember</code> block.</p>
			<p>Now that we've covered how state objects are defined, some questions remain: how can we alter the state to retrigger recomposition and how can we make sure our <code>TextField</code> accesses the updated values from our <code>textState</code>? Let's add these missing pieces:</p>
			<pre>@Composable
fun NameInput() {
   val textState = remember { mutableStateOf("")<strong class="bold"> </strong>}
   TextField(
            <strong class="bold">value = textState.value,</strong>
            onValueChange = { newValue -&gt;
                <strong class="bold">textState.value = newValue</strong>
            },
            label = { Text("Your name") })
}</pre>
			<p>Let's have a<a id="_idIndexMarker127"/> closer look at how we wired everything up inside <code>TextField</code>:</p>
			<ul>
				<li>For <code>TextField</code> to <a id="_idIndexMarker128"/>always have access to the latest value of <a id="_idIndexMarker129"/>the <code>textState</code> state object, we obtained the current state value with the <code>.value</code> accessor using <code>textState.value</code>. Then, we <a id="_idIndexMarker130"/>passed it to the <code>TextField</code>'s <code>value</code> parameter to display it.</li>
				<li>To change the state value, we made use of the <code>onValueChange</code> callback, which can be portrayed as an <em class="italic">event</em>. Inside this callback, we updated the <code>textState</code> state value by using the same <code>.value</code> accessor and set the new value that was received, called <code>newValue</code>. Since we updated a <code>State</code> object, the UI should recompose and our <code>TextField</code> should render the new input value from the keyboard. This will repeat for as long as we keep on writing.</li>
			</ul>
			<p>Now that we have got the hang of defining and altering state in Compose, it's time to add such state functionality to our Restaurants app.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor080"/>Adding state to our Restaurants app</h2>
			<p>Let's imagine that the<a id="_idIndexMarker131"/> user can scroll through the list of restaurants<a id="_idIndexMarker132"/> and then tap a particular one, thereby marking it as a favorite. For this to be more suggestive, we will add a heart icon for each restaurant. To do this, follow these steps:</p>
			<ol>
				<li value="1">Inside the <code>RestaurantsScreen.kt</code> file, add another composable inside <code>RestaurantItem</code> called <code>FavoriteIcon</code>. Then, pass a weight of <code>0.15f</code> to make it occupy 15% of the parent <code>Row</code>:<pre>@Composable
fun RestaurantItem(item: Restaurant) {
   Card(...) {
       Row(...) {
           RestaurantIcon(..., Modifier.weight(0.15f)<a id="_idTextAnchor081"/>)
           RestaurantDetails(..., Modifier.weight(<strong class="bold">0.7f</strong>))
           <strong class="bold">FavoriteIcon(Mo<a id="_idTextAnchor082"/>difier.weight(0.15f))</strong>
       }
   }
}</pre></li>
			</ol>
			<p>We have also made sure to decrease the weight of <code>RestaurantDetails</code> from 85% to 70%.</p>
			<ol>
				<li value="2">Still inside the <code>RestaurantsScreen.kt</code> file, define the missing <code>FavoriteIcon</code> composable, which receives an <code>imageVector</code> as a predefined icon with <code>Icons.Filled.FavoriteBorder</code>. Also, make it receive a <code>Modifier</code> object with <code>8.dp</code> of padding:<pre>@Composable
private fun FavoriteIcon(modifier: Modifier) {
   Image(
       imageVector = Icons.Filled.FavoriteBorder,
       contentDescription = "Favorite restaurant icon",
      <a id="_idTextAnchor083"/> modifier = modifier.padding(8.dp))
}</pre></li>
				<li>If we try to <a id="_idIndexMarker133"/>refresh the preview or run the app, we can see several <code>RestaurantItem</code> composables similar to the following:</li>
			</ol>
			<div><div><img src="img/B17788_02_04.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The RestaurantItem composable with a favorite icon</p>
			<p>Our <code>RestaurantItem</code> composable now has a favorite icon. However, when we click it, nothing <a id="_idIndexMarker134"/>happens. Clicking it should change the heart icon into a filled one, marking the restaurant as a favorite. To fix this, we must add a state that allows us to hold the favorite status of a restaurant.</p>
			<ol>
				<li value="4">Add state to the <code>FavoriteIcon</code> composable by adding the following code:<pre>@Composable
private fun FavoriteIcon(modifier: Modifier) {
   <strong class="bold">val favoriteState = remember { </strong>
<strong class="bold">       mutableStateOf(false) }</strong>
<strong class="bold">   val icon = if (favoriteState.value)</strong>
<strong class="bold">       Icons.Filled.Favorite</strong>
<strong class="bold">   else</strong>
<strong class="bold">       Icons.Filled.FavoriteBorder</strong>
    Image(
        <strong class="bold">imageVector = icon,</strong>
        contentDescription = "Favorite restaurant icon",
        modifier = modifier
            .padding(8.dp)
            <strong class="bold">.clickable { favoriteState.value =</strong>
<strong class="bold">                    !favoriteState.value</strong>
            <strong class="bold">}</strong>
    )
}</pre></li>
			</ol>
			<p>To hold the state of<a id="_idIndexMarker135"/> being a favorite or not and to trigger a change in this<a id="_idIndexMarker136"/> state value, we've done the following:</p>
			<ol>
				<li value="1">We added a <code>favoriteState</code> variable that holds a <code>MutableState</code> of type <code>Boolean</code> with an initial value of <code>false</code>. As usual, we wrap the <code>mutableStateOf</code> constructor inside a <code>remember</code> block to preserve the state's value across recompositions.</li>
				<li>We defined an <code>icon</code> variable that can hold a value of <code>Icons.Filled.Favorite</code>, which means that the restaurant is your favorite, or a value of <code>Icons.Filled.FavoriteBorder</code>, which means that the restaurant is not your favorite.</li>
				<li>We passed the value of <code>icon</code> value to the <code>imageVector</code> parameter of our <code>Image</code> composable.</li>
				<li>We added a <code>clickable</code> modifier that's chained after the <code>padding</code> one. In this callback, we made sure to update <code>favoriteState</code> with the <code>.value</code> accessor by obtaining it and writing the previously negated value.<p class="callout-heading">Note</p><p class="callout">When defining state objects in Compose, you can replace the assignment (<code>=</code>) operator with property delegation, which can be achieved with the <code>by</code> operator: <code>val favoriteState by remember { … }</code>. By doing this, you will not need to use the <code>.value</code> accessor anymore as it is delegated.</p></li>
			</ol>
			<p>When we're <a id="_idIndexMarker137"/>running or live previewing the application, we can see <a id="_idIndexMarker138"/>that upon clicking the empty heart icon of each restaurant, it becomes filled, marking the restaurant as a favorite:</p>
			<div><div><img src="img/B17788_02_05.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The RestaurantsScreen composable with a favorite state for its items</p>
			<p>Most of the time, keeping state and state handling logic inside composable functions is not recommended. Let's explore why this is not the best practice and how we can improve the way we manage state with the help of state hoisting.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor084"/>Hoisting state in Compose</h1>
			<p>Composable functions are usually categorized in terms of state handling in two main categories:</p>
			<ul>
				<li><code>State</code> object.</li>
				<li><code>ViewModel</code> component can be the only source of truth for their state to control and manage UI changes but also to avoid illegal states.</li>
			</ul>
			<p>In our case, state changes when a restaurant is marked as a favorite or not. Since we want to control this interaction at the presentation level in the <code>ViewModel</code> class to keep track of which restaurants have been favorited, we need to move the state up from the <code>FavoriteIcon</code> composable.</p>
			<p>The pattern of moving state up<a id="_idIndexMarker143"/> from a composable to its caller composable is called <code>State</code> object with two parameters:</p>
			<ul>
				<li>One <code>value</code> parameter for the data that defines the current state</li>
				<li>A callback function that is triggered as an event when a new value is emitted </li>
			</ul>
			<p>By receiving data as input and forwarding events to the parent composable, we make sure that our Compose UI obeys the previously introduced concept of the unidirectional flow of state and events. This concept defines how state values and events should only flow in one direction: the events upwards and the state downwards, and with state hoisting, we enforce just that.</p>
			<p>The benefits of state<a id="_idIndexMarker144"/> hoisting are as follows:</p>
			<ul>
				<li><code>ViewModel</code>. Composables can be decoupled from their state to avoid illegal states in your UI.</li>
				<li><strong class="bold">Reusability</strong>: Since composables only render the data that's received as input, it's much easier to reuse them within other composables as you can simply pass different values.</li>
				<li><strong class="bold">Encapsulation limitation</strong>: Only stateful composables can change their state internally. This means that you can limit the number of composables that handle their state, which could lead to illegal UI states.</li>
			</ul>
			<p>Now that we've briefly<a id="_idIndexMarker145"/> covered what state hoisting is and why it is <a id="_idIndexMarker146"/>beneficial, it's time to hoist the state within our Restaurants application:</p>
			<ol>
				<li value="1">First, lift the state from the <code>FavoriteIcon</code> composable by removing the existing <code>favoriteState</code> and <code>icon</code> variables along with their instantiation logic from the top of the body of the function. At the same time, update the <code>FavoriteIcon</code> composable to accept an <code>icon</code> parameter for receiving input data and also an <code>onClick</code> event callback for forwarding upwards events:<pre>@Composable
private fun FavoriteIcon(<strong class="bold">icon: ImageVector</strong>, 
                         modifier: Modifier<strong class="bold">,</strong>
                         <strong class="bold">onClick: () -&gt; Unit</strong>) {
   Image(
       imageVector <strong class="bold">= icon</strong>,
       contentDescription = "Favorite restaurant icon",
       modifi<a id="_idTextAnchor085"/>er = [...]
           .clickable { <strong class="bold">onClick()</strong> })
}</pre></li>
			</ol>
			<p>Additionally, we passed <code>icon</code> to the <code>imageVector</code> parameter of the <code>Image</code> composable and triggered the <code>onClick</code> callback function whenever the <code>clickable</code> event is triggered. By applying these changes, we lifted the state up and transformed <code>FavoriteIcon</code> from a stateful composable into a stateless one.</p>
			<ol>
				<li value="2">Now, move<a id="_idIndexMarker147"/> the <code>favoriteState</code> variable in <a id="_idIndexMarker148"/>the <code>RestaurantItem</code> parent composable of <code>FavoriteIcon</code>. The <code>RestaurantItem</code> composable provides the state to <code>FavoriteIcon</code> and is also in charge of updating its state over time:<pre>@Composable
fun RestaurantItem(item: Restaurant) {
   <strong class="bold">val favoriteState</strong> <strong class="bold">= remember { </strong>
<strong class="bold">       mutableStateOf(false) }</strong>
<strong class="bold">   val icon = if (favoriteState.value)</strong>
<strong class="bold">       Icons.Filled.Favorite</strong>
<strong class="bold">   else</strong>
<strong class="bold">       Icons.Filled.FavoriteBorder</strong>
   Card(...) {
       Row(...) {
          [...]
          FavoriteIcon(<strong class="bold">icon</strong>, Modifier.weight(0.15f)) <strong class="bold">{</strong>
               <strong class="bold">favoriteState.value = </strong>
<strong class="bold">  <a id="_idTextAnchor086"/>                 !favoriteState.value</strong>
          <strong class="bold">}</strong>
       }
   }
}</pre></li>
			</ol>
			<p>The corresponding <code>icon</code> for each state is now passed to <code>FavoriteIcon</code>. Additionally, <code>RestaurantItem</code> is now listening for <code>onClick</code> events in the trailing lambda block, where it mutates the <code>favoriteState</code> object, triggering recomposition upon every click.</p>
			<p>Yet, looking at <code>FavoriteIcon</code> and <code>RestaurantIcon</code>, we can see many similarities. Both are stateless composables that receive an <code>ImageVector</code> as a parameter. Since<a id="_idIndexMarker149"/> they are stateless and perform similar<a id="_idIndexMarker150"/> functions, let's reuse one of them and delete the other.</p>
			<ol>
				<li value="3">Inside <code>RestaurantIcon</code>, add a similar <code>onClick</code> function parameter (just like <code>FavoriteIcon</code> has) and bind it to the <code>clickable</code> modifier's callback: <pre>@Composable
private fun RestaurantIcon(icon: ImageVector, modifier: Modifier<strong class="bold">, onClick: () -&gt; Unit = { })</strong> {
   Image([...],
       modifier = modifier
           .padding(8.dp)
           <strong class="bold">.clickable { onClick() }</strong>
<strong class="bold">   )</strong>
}</pre></li>
			</ol>
			<p>Since we don't want to execute anything on click events for the restaurant profile icon, we provided a default empty function (<code>{ }</code>) value to the <code>onClick</code> parameter. </p>
			<p>Once you've done this, you can delete the <code>FavoriteIcon</code> composable since we won't need it<a id="_idIndexMarker151"/> anymore.</p>
			<ol>
				<li value="4">Inside<a id="_idIndexMarker152"/> the <code>RestaurantItem</code> composable, replace <code>FavoriteIcon</code> with <code>RestaurantIcon</code>: <pre>@Composable
fun RestaurantItem(item: Restaurant) {
   val favoriteState = ...
   Card(...) {
       Row(...) {
          RestaurantIcon(…)
          RestaurantDetails(...)
          <strong class="bold">RestaurantIcon</strong>(icon, Modifier.weight(0.15f)) {
               favoriteState.value = !favoriteState.value
           }
       }
   }
}</pre></li>
			</ol>
			<p>You have now hoisted the state from <code>RestaurantIcon</code> to the <code>RestaurantItem</code> composable. </p>
			<p>Let's keep on hoisting the state even further uphill, into the <code>RestaurantsScreen</code> composable. However, we cannot keep individual <code>State</code> objects for each <code>RestaurantItem</code> inside this composable, so we will have to change the <code>State</code> object to hold a list of <code>Restaurant</code> objects, each having a separate <code>isFavorite</code> value.</p>
			<ol>
				<li value="5">Inside the <code>Restaurant.kt</code> file, add another property for <code>Restaurant</code> called <code>isFavorite</code>. It should have a default value of <code>false</code> since, by default, restaurants are not marked as favorites when the application starts:<pre>data class Restaurant(val id: Int,
                      val title: String,
                      val description: String,
                      <strong class="bold">var isFavorite: Boolean = false</strong>)
val dummyRestaurants = listOf(…)</pre></li>
				<li>Going back <a id="_idIndexMarker153"/>inside the <code>RestaurantsScreen.kt</code> file, hoist the state up again, this time from <code>RestaurantItem</code>, by adding an <code>onClick</code> function parameter that's triggered inside <a id="_idIndexMarker154"/>the <code>RestaurantIcon</code>'s callback function parameter. We won't add a new argument for the input data since we already have the <code>item</code> argument of type <code>Restaurant</code>, and you can also safely remove the <code>favoriteState</code> variable since we won't be needing it anymore:<pre>@Composable
fun RestaurantItem(item: Restaurant, 
                   <strong class="bold">onClick: (id: Int) -&gt; Unit</strong>) {
   val icon = if (<strong class="bold">item.isFavorite</strong>)
       Icons.Filled.Favorite
   else
       Icons.Filled.FavoriteBorder
   Card(...) {
       Row(...) {
           ...
          RestaurantIcon(…)
          RestaurantDetails(…)
          RestaurantIcon(…) {
              <strong class="bold">onClick(item.id)</strong>
          }
       }
   }
}</pre></li>
			</ol>
			<p>This time, the <code>item</code> parameter will be our <code>Restaurant</code> object. <code>Restaurant</code> now holds an <code>isFavorite: Boolean</code> property that states whether the restaurant is favorited or not. That's why we set the correct value for the <code>icon</code> variable based on the item's field by checking the <code>item.isFavorite</code> value.</p>
			<p>Now, <code>RestaurantItem</code> is a stateless<a id="_idIndexMarker155"/> composable, so it's time to add a <code>State</code> object <a id="_idIndexMarker156"/>to its parent.</p>
			<ol>
				<li value="7">Inside <code>RestaurantsScreen</code>, add a <code>state</code> variable that will hold our list of restaurants. Its type will be <code>MutableState&lt;List&lt;Restaurant&gt;&gt;</code> and we will set the restaurants from <code>viewModel</code> as it initial value, finally passing the state's <code>value</code> to the <code>items</code> constructor of <code>LazyColumn</code>:<pre>@Composable
fun RestaurantsScreen() {
  val viewModel: RestaurantsViewModel = viewModel()
<strong class="bold">  val state: MutableState&lt;List&lt;Restaurant&gt;&gt; =</strong>
<strong class="bold">    remember {</strong>
<strong class="bold">      mutableStateOf(viewModel.getRestaurants())</strong>
<strong class="bold">    }</strong>
  LazyColumn(...) {
   items(<strong class="bold">state.value</strong>) { restaurant -&gt;
     RestaurantItem(restaurant) <strong class="bold">{ id -&gt;</strong>
      <strong class="bold"> val restaurants = state.value.toMutableList()</strong>
<strong class="bold">       val itemIndex =</strong>
<strong class="bold">         restaurants.indexOfFirst { it.id == id }</strong>
<strong class="bold">       val item = restaurants[itemIndex]</strong>
<strong class="bold">       restaurants[itemIndex] =</strong>
<strong class="bold">         item.copy(isFavorite = !item.isFavorite)</strong>
<strong class="bold">       state.value = restaurants</strong>
<strong class="bold">      }</strong>
    }
  }
}</pre></li>
			</ol>
			<p>Inside <code>RestaurantItem</code>'s <code>onClick</code> trailing lambda block, we must toggle the favorite status of the<a id="_idIndexMarker157"/> corresponding restaurant and update the state. Because <a id="_idIndexMarker158"/>of this, we did the following:</p>
			<ol>
				<li value="1">We obtained the current list of restaurants by calling <code>state.value</code> and converting it into a mutable list so that we could replace the item whose <code>isFavorite</code> field's value should be updated.</li>
				<li>We obtained the index of the item whose <code>isFavorite</code> field should be updated via the <code>indexOfFirst</code> function, where we matched the <code>id</code> property of the <code>Restaurant</code> objects.</li>
				<li>Having found <code>itemIndex</code>, we obtained the <code>item</code> object of type <code>Restaurant</code> and applied the <code>copy()</code> constructor, where we negated the <code>isFavorite</code> field. The resulting value replaced the existing <code>item</code> at <code>itemIndex</code>.</li>
				<li>Finally, we passed the updated <code>restaurants</code> list back to the <code>state</code> object with the <code>.value</code> accessor.<p class="callout-heading">Note</p><p class="callout">For Compose to observe changes within a list of objects of type <code>T</code> called <code>List&lt;T&gt;,</code> where <code>T</code> is a data class, you must update the memory reference of the updated item. You can do that by calling the <code>copy()</code> constructor of <code>T</code> so that when the updated list is passed back to your <code>State</code> object, Compose triggers a recomposition. Alternatively, you can use <code>mutableStateListOf&lt;Restaurant&gt;()</code> to have easier recomposition events triggered.</p></li>
			</ol>
			<p>If we try to run the <a id="_idIndexMarker159"/>app, we should notice that the functionality is <a id="_idIndexMarker160"/>the same, yet the state was hoisted and that we can now reuse composables such as <code>RestaurantItem</code> or <code>RestaurantIcon</code> much easier.</p>
			<p>But what happens if we toggle a couple of restaurants that are favorites and then rotate the device, thereby changing the screen orientation? </p>
			<p>Even though we used the <code>remember</code> block to preserve the state across recompositions, our selections were lost, and all the restaurants are marked as not favorites again. This is because the <code>MainActivity</code> host of our <code>RestaurantsScreen</code> composable has been recreated, so any state was also lost when the configuration change occurred.</p>
			<p>To fix this, we can do the following:</p>
			<ul>
				<li>Replace the <code>remember</code> block with <code>rememberSaveable</code>. This will allow the state to be automatically saved across configuration changes of the host <code>Activity</code>.</li>
				<li>Hoist the state to <code>ViewModel</code>. We know that <code>RestaurantsViewModel</code> is not scoped to the lifecycle of our <code>RestaurantsScreen</code> yet since no navigation library was used, so this means it's scoped to <code>MainActivity</code>, which allows it to survive configuration changes.</li>
			</ul>
			<p>You can try replacing the <code>remember</code> block with <code>rememberSaveable</code> and then rotate the screen to see that the state is now preserved across configuration changes. However, we want to take the high road and make sure <code>ViewModel</code> is the only source of truth for our state. Let's get started:</p>
			<ol>
				<li value="1">To lift the state to <code>ViewModel</code>, we must move the <code>State</code> object from the <code>RestaurantsScreen</code> composable to the <code>RestaurantsViewModel</code> and we must also create a new method called <code>toggleFavorite</code> that will allow the <code>RestaurantsViewModel</code> to mutate the value of the <code>state</code> variable every time we try to <a id="_idIndexMarker161"/>toggle the favorite status of a<a id="_idIndexMarker162"/> restaurant:<pre>class RestaurantsViewModel() : ViewModel() {
   <strong class="bold">val state = mutableStateOf(dummyRestaurants)</strong>
<strong class="bold">    fun toggleFavorite(id: Int) {</strong>
<strong class="bold">        val restaurants = state.value.toMutableList()</strong>
<strong class="bold">        val itemIndex =</strong>
<strong class="bold">            restaurants.indexOfFirst { it.id == id }</strong>
<strong class="bold">        val item = restaurants[itemIndex]</strong>
<strong class="bold">        restaurants[itemIndex] =</strong>
<strong class="bold">            item.copy(isFavori<a id="_idTextAnchor087"/>te = !item.isFavorite)</strong>
<strong class="bold">        state.value = restaurants</strong>
<strong class="bold">    }</strong> 
}</pre></li>
			</ol>
			<p>The new method called <code>toggleFavorite</code> accepts the <code>id</code> property of the targeted restaurant. Inside this method, we moved the code from the <code>RestaurantItem</code>'s <code>onClick</code> trailing lambda block, where we toggle the favorite status of the corresponding item and update its state.</p>
			<p>By this time, you can safely remove the <code>getRestaurants()</code> method from the <code>RestaurantsViewModel</code> class since we won't be needing it anymore.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>State</code> object that's contained within the <code>ViewModel</code> should not be publicly available for other classes to modify it, since we want it to be encapsulated and allow only the <code>ViewModel</code> to update it. We will fix this in <a href="B17788_07_ePub.xhtml#_idTextAnchor249"><em class="italic">Chapter 7</em></a><em class="italic">, Introducing Presentation Patterns in Android</em>.</p>
			<ol>
				<li value="2">Inside the <code>RestaurantsScreen</code> composable, remove the <code>state</code> variable and pass the <a id="_idIndexMarker163"/>restaurants from <code>RestaurantsViewModel</code> by accessing<a id="_idIndexMarker164"/> the value of its state through the <code>.value</code> accessor with <code>viewModel.state.value</code>:<pre>fun RestaurantsScreen() {
   val viewModel: RestaurantsViewModel = viewModel()
   LazyColumn(...) {
       items(<strong class="bold">viewModel.state.value</strong>) { restaurant -&gt;
           RestaurantItem(restaurant) { id -&gt;
               <strong class="bold">viewModel.toggleFavorite(id)</strong>
           }
       }
   }
}</pre></li>
			</ol>
			<p>We also removed the old code from the <code>RestaurantItem</code>'s <code>onClick</code> trailing lambda block and replaced it with a call to our <code>ViewModel</code>'s <code>toggleFavorite</code> method.</p>
			<p>If you run the application, the UI should perform as expected, so you should be able to toggle any<a id="_idIndexMarker165"/> restaurants as favorite and your selections should be saved upon events like<a id="_idIndexMarker166"/> orientation change.</p>
			<p>The only difference is that now, <code>RestaurantsViewModel</code> is the only source of truth for the state of <code>RestaurantsScreen</code> and we no longer need to hold or save the UI state inside the composables themselves.</p>
			<p>We now know how to hoist the state up into the <code>ViewModel</code>. Now, let's cover a very important scenario in the world of Android that's related to process death.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor088"/>Recovering from system-initiated process death</h1>
			<p>We've already learned how, whenever a configuration change occurs, our <code>Activity</code> is recreated, which can cause our UI to lose its state. To bypass this issue and to preserve the UI's state, we ended up implementing a <code>ViewModel</code> component and hoisted the UI state there.</p>
			<p>But what would happen in the case of a system-initiated process death?</p>
			<p>A <strong class="bold">system-initiated process death</strong> happens <a id="_idIndexMarker167"/>when the user places our application in the background and decides to use other apps for a while – in the meantime, though, the system decides to kill our app's process to free up system resources, which initiates process death.</p>
			<p>Let's try to simulate<a id="_idIndexMarker168"/> such an event and see what happens:</p>
			<ol>
				<li value="1">Start the Restaurants app using the IDE's <strong class="bold">Run</strong> button and mark some restaurants as favorites:</li>
			</ol>
			<div><div><img src="img/B17788_02_06.jpg" alt="Figure 2.6 – The RestaurantsScreen composable with favorite selections made&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The RestaurantsScreen composable with favorite selections made</p>
			<ol>
				<li value="2">Place the app in <a id="_idIndexMarker169"/>the background by pressing the <strong class="bold">Home</strong> button on the device/emulator.</li>
				<li>In Android Studio, select the <strong class="bold">Logcat</strong> window and then press the red square button on the left-hand side to terminate the application:</li>
			</ol>
			<div><div><img src="img/B17788_02_07.jpg" alt="Figure 2.7 – Killing the process in Logcat to simulate system-initiated process death&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Killing the process in Logcat to simulate system-initiated process death</p>
			<ol>
				<li value="4">Relaunch the<a id="_idIndexMarker170"/> application from the application drawer:</li>
			</ol>
			<div><div><img src="img/B17788_02_08.jpg" alt="Figure 2.8 – The RestaurantsScreen composable with favorite selections lost&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The RestaurantsScreen composable with favorite selections lost</p>
			<p>We have now <a id="_idIndexMarker171"/>simulated a situation where the system would kill our process. When we return to the app, we can see that our selections are now gone and that the restaurants that were favorited are now in their default states.</p>
			<p>To restore state upon system-initiated process death, we used to use the <code>onSaveInstanceState()</code> callback of our activity.</p>
			<p>Similarly, every <code>ViewModel</code> that uses the default <code>ViewModelFactory</code> (like we did with the <code>viewModel()</code> inline syntax previously) can access a <code>SavedStateHandle</code> object through its constructor. If you use a custom <code>ViewModelFactory</code>, make sure that it extends <code>AbstractSavedStateViewModelFactory</code>.</p>
			<p>The <code>SavedStateHandle</code> object is a key-value map that allows you to save and then restore objects that are crucial to your state. This map survives the event of process death when this event is initiated by the system, which allows you to retrieve and restore your saved objects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When we're saving state-related data, it's crucial to save lightweight objects that define the state and not the entire data that is described on the screen. For large data, we should use local persistence.</p>
			<p>Let's try to do<a id="_idIndexMarker173"/> this in our application by saving a list of <code>id</code> values of the restaurants that were toggled as favorites in <code>SavedStateHandle</code>. Saving the <code>id</code> values is better than saving the entire list of restaurants since a list of <code>Int</code> values is lightweight. And since we can always get the restaurant list back at runtime, the only thing that's missing is to remember which of them were favorited.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Usually, <code>SavedStateHandle</code> is used for saving transient data like sorting or filtering selections performed by the user, or other selections that you need to restore upon system-initiated process death. In our case though, favorited restaurants should be restored not only upon system-initiated process death but also upon a simple application restart. That's why we will save these selections as part of the domain data of the app inside a local database later in <a href="B17788_06_ePub.xhtml#_idTextAnchor186"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding Offline Capabilities with Jetpack Room</em>.</p>
			<p>Let's use a <code>SavedStateHandle</code> object to recover from system-initiated process death:</p>
			<ol>
				<li value="1">Add the <code>SavedStateHandle</code> parameter to your <code>RestaurantsViewModel</code>:<pre>class RestaurantsViewModel(
    <strong class="bold">private val stateHandle: SavedStateHandle</strong>) : 
<strong class="bold">        </strong>ViewModel() {
   …
}</pre></li>
				<li>Call a <code>storeSelection</code> method whenever we toggle the favorite status of a restaurant inside the <code>toggleFavorite</code> method and pass the respective restaurant: <pre>class RestaurantsViewModel(…) {
   fun toggleFavorite(id: Int) {
       …
       restaurants[itemIndex] = item.copy(isFavorite = 
           !item.isFavorite)
       <strong class="bold">storeSelection(restaurants[itemIndex])</strong>
       state.value = restaurants
   }
 ...
}</pre></li>
			</ol>
			<p>This code won't compile though because we haven't yet defined the <code>storeSelection</code> method. Let's do that up next.</p>
			<ol>
				<li value="3">Inside <code>RestaurantsViewModel</code>, create a new <code>storeSelection</code> method that <a id="_idIndexMarker174"/>receives a <code>Restaurant</code> object whose <code>isFavorite</code> property has just been altered, and saves that selection inside the <code>SavedStateHandle</code> object provided by the <code>RestaurantsViewModel</code> class:<pre>private fun storeSelection(item: Restaurant) {
   val savedToggled = stateHandle
     .get&lt;List&lt;Int&gt;?&gt;(FAVORITES)
     .orEmpty().toMutableList()
   if (item.isFavorite) savedToggled.add(item.id)
   else savedToggled.remove(item.id)
   stateHandle[FAVORITES] = savedToggled
}
companion object {
  const val FAVORITES = "favorites"
}</pre></li>
			</ol>
			<p>This new method will try to save the <code>id</code> value of a restaurant in our <code>stateHandle</code> object every time we toggle its favorite status. It does this as follows:</p>
			<ol>
				<li value="1"> It obtains a<a id="_idIndexMarker175"/> list containing the IDs of the previously favorited restaurants from <code>stateHandle</code> by accessing the <code>FAVORITES</code> key inside the map. It stores the result in a <code>savedToggle</code> mutable list. If no restaurants were favorited, the list will be empty.</li>
				<li> If this restaurant was marked as favorite, it adds the ID of the restaurant to the <code>savedToggle</code> list. Otherwise, it removes it.</li>
				<li> Saves the updated list of favorited restaurants with the <code>FAVORITES</code> key inside the <code>stateHandle</code> map.</li>
			</ol>
			<p>We have also added a <code>companion object</code> construct to the <code>RestaurantsViewModel</code> class as a static extension object. We used this <code>companion object</code> to define a constant value for the key used to save the restaurant's selection inside our <code>stateHandle</code> map.</p>
			<p>Now, we've made sure to cache the selections of favorite restaurants before process death, so our next step is to find a way to restore these selections after the app recovers from a system-initiated process death event.</p>
			<ol>
				<li value="4">Call a <code>restoreSelections()</code> extension method on the <code>dummyRestaurants</code> list that we are passing as an initial value to our <code>state</code> object. This call should restore the UI selections:<pre>class RestaurantsViewModel(
   private val stateHandle: SavedStateHandle):
      ViewModel() {
   val state = mutableStateOf(
     <strong class="bold">dummyRestaurants.restoreSelections()</strong>
   )
    ...
}</pre></li>
			</ol>
			<p>This code won't compile though because we haven't yet defined the <code>restoreSelections</code> method. Let's do that up next.</p>
			<ol>
				<li value="5">Inside <a id="_idIndexMarker176"/><code>RestaurantsViewModel</code>, define the <code>restoreSelections</code> extension function that will allow us to retrieve the restaurants that were favorited upon process death:<pre>private fun List&lt;Restaurant&gt;.restoreSelections():
        List&lt;Restaurant&gt; {
    stateHandle.get&lt;List&lt;Int&gt;?&gt;(FAVORITES)?.let {
            selectedIds -&gt;
        val restaurantsMap = this.associateBy { it.id }
        selectedIds.forEach { id -&gt;
            restaurantsMap[id]?.isFavorite = true
        }
        return restaurantsMap.values.toList()
    }
    return this
}</pre></li>
			</ol>
			<p>This extension function will allow us to mark those restaurants that were marked by the user previously as favorites upon system-initiated process death. The <code>restoreSelections</code> extension function achieves that in the following way:</p>
			<ol>
				<li value="1">First, by obtaining the list with the unique identifiers of the previously favorited restaurants from <code>stateHandle</code> by accessing the <code>FAVORITES</code> key inside the map. If the list is not <code>null</code>, this means that a process death occurred, and it references the list as <code>selectedIds</code>; otherwise, it will return the list without any modifications.</li>
				<li>Then, by creating<a id="_idIndexMarker177"/> a map from the input list of restaurants with the key being the <code>id</code> value of the restaurant and the value the <code>Restaurant</code> object itself.</li>
				<li>By iterating over the unique identifiers of the favorited restaurants and for each of them, by trying to access the respective restaurant from our new list and sets its <code>isFavorite</code> value to <code>true</code>.</li>
				<li>By returning the modified restaurants list from <code>restaurantMap</code>. This list should now contain the restored <code>isFavorite</code> values from before the death process occurred.</li>
			</ol>
			<p>6.	Finally, build the app and then repeat <em class="italic">steps 1</em>, <em class="italic">2</em>, <em class="italic">3</em>, and <em class="italic">4</em> from when we simulated a system-initiated process death.</p>
			<p>The application should now correctly display the UI state with the previously favorited restaurants from before the system-initiated process death.</p>
			<p>With that, we've made sure that our application not only stores the UI state at the <code>ViewModel</code> level but that it also can recover from extraordinary events, such as system-initiated process death.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor089"/>Summary</h1>
			<p>In this chapter, we learned what a <code>ViewModel</code> class is, we explored the concepts that define it, and we learned how to instantiate one. We tackled why a <code>ViewModel</code> is useful as a single source of truth for the UI's <em class="italic">state</em>: to avoid illegal and undesired states.</p>
			<p>For that to make sense, we explored how a UI is defined by its state and how to define such a state in Compose. We then understood what <em class="italic">state hoisting</em> is and how to separate widgets between <em class="italic">stateless</em> and <em class="italic">stateful</em> composables. </p>
			<p>Finally, we put all these new concepts into practice by defining state in our Restaurants app, hoisting it, and then lifting it even higher into the newly created <code>ViewModel</code>.</p>
			<p>Finally, we learned how system-initiated process death occurs and how to allow the app to recover by restoring the previous state with the help of <code>SavedStateHandle</code>.</p>
			<p>In the next chapter, we will add real data to our Restaurants app by connecting it to our database using Retrofit.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor090"/>Further reading</h1>
			<p>Working with ViewModels and handling state changes in Compose represent two essential topics for reliable projects. Let's see what other subjects revolve around them. </p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor091"/>Exploring ViewModel with runtime-provided arguments</h2>
			<p>In most cases, you can declare and provide dependencies to your <code>ViewModel</code> inside the constructor, at compile time. In some cases, though, you might need to initialize a <code>ViewModel</code> instance with a parameter that's only known at runtime. </p>
			<p>For example, when we're adding a composable screen that displays the details of a restaurant, instead of sending the ID of the target restaurant from the composable to <code>ViewModel</code> through a function call, we can provide it directly to the <code>ViewModel</code> constructor through <strong class="bold">ViewModelFactory</strong>.</p>
			<p>To explore the process of building a <code>ViewModelFactory</code>, check out the following Codelab: <a href="https://developer.android.com/codelabs/kotlin-android-training-view-model#7">https://developer.android.com/codelabs/kotlin-android-training-view-model#7</a>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor092"/>Exploring ViewModel for Kotlin Multiplatform projects</h2>
			<p>While this chapter covered the Jetpack ViewModel for Compose in pure Android apps, if you're aiming to build cross-platform projects using <strong class="bold">Kotlin Multiplatform</strong> (<strong class="bold">KMP</strong>) or <strong class="bold">Kotlin Multiplatform Mobile</strong> (<strong class="bold">KMM</strong>), the Jetpack ViewModel might not be your best option.</p>
			<p>When we're building cross-platform projects, we should try to avoid platform-specific dependencies. The Jetpack ViewModel is suited for Android and therefore is an Android dependency, so we might need to build or define a ViewModel.</p>
			<p>To learn more about KMM and platform-agnostic ViewModels, check out the following GitHub example: <a href="https://github.com/dbaroncelli/D-KMP-sample">https://github.com/dbaroncelli/D-KMP-sample</a>.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor093"/>Understanding how to minimize the number of recompositions</h2>
			<p>In this chapter, we learned how to trigger recompositions by using <code>State</code> objects. While in Compose, recompositions happen often, we haven't had a chance to optimize the performance of our Compose-based screens.</p>
			<p>We can reduce the number of recompositions by ensuring that the input of the composables is deeply stable. To learn more about how to achieve this, go to <a href="https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&amp;skip_cache=true#skipping">https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&amp;skip_cache=true#skipping</a>.</p>
		</div>
	</body></html>